(function(){
shadow$provide[2]=function(G,y,X,g){Object.defineProperty(g,"__esModule",{value:!0});g.Solver=void 0;var A;(function(m){m[m.Start=0]="Start";m[m.BasicIntegrationStep=1]="BasicIntegrationStep";m[m.ConvergenceStep=2]="ConvergenceStep";m[m.HopeForConvergence=3]="HopeForConvergence";m[m.Accept=4]="Accept";m[m.Reject=5]="Reject"})(A||(A={}));class u{constructor(m,e,c={}){this.nEval=this.hMax=0;this.t=[];this.err=0;this.errOld=1E10;this.iPt=this.nReject=this.nAccept=this.nStep=0;this.options=Object.assign({},
u.defaults,c);this.n=e;this.f=this.options.rawFunction?m:(l,n,p)=>{this.copy(p,m(l,n,[]))};if(0>=this.options.maxSteps)throw Error("maxSteps must be positive");if(2>=this.options.maxExtrapolationColumns)throw Error("maxExtrapolationColumns must be \x3e 2");e=this.options.maxExtrapolationColumns;this.options.stepSizeSequence=this.options.stepSizeSequence||(this.options.denseOutput?4:1);if(3>=this.options.stepSizeSequence&&this.options.denseOutput)throw Error("stepSizeSequence incompatible with denseOutput");
if(0>=this.options.interpolationFormulaDegree||7<=this.options.interpolationFormulaDegree)throw Error("bad interpolationFormulaDegree");if(this.options.denseOutput){if(!Array.isArray(this.options.denseComponents)||0==this.options.denseComponents.length)for(this.options.denseComponents=[],c=0;c<this.n;++c)this.options.denseComponents.push(c);for(var h of this.options.denseComponents)if(0>h||h>=this.n)throw Error("illegal dense component index "+h);}if(1E-35>=this.options.uRound||1<this.options.uRound)throw Error("suspicious value of uRound");
h=2*e*e+e;this.aTol=this.expandToArray(this.options.absoluteTolerance);this.rTol=this.expandToArray(this.options.relativeTolerance);this.ySafe=Array(e);this.fSafe=Array(h);for(h=0;h<this.fSafe.length;++h)this.fSafe[h]=Array(this.options.denseComponents.length);for(h=0;h<this.ySafe.length;++h)this.ySafe[h]=Array(this.options.denseComponents.length);this.hh=Array(e);this.t=Array(e);for(h=0;h<this.t.length;++h)this.t[h]=Array(this.n);this.nj=u.stepSizeSequence(this.options.stepSizeSequence,e);this.a=
Array(e);this.a[0]=1+this.nj[0];for(h=1;h<e;++h)this.a[h]=this.a[h-1]+this.nj[h];this.w=Array(e);this.w[0]=0;this.scal=Array(this.n);this.fx=Array(this.n);this.dy=Array(this.n);this.dz=Array(this.n);this.yh1=Array(this.n);this.yh2=Array(this.n);this.iPoint=Array(e+1);this.errfac=Array(2*e);this.dens=Array(2*this.options.maxExtrapolationColumns+5+this.options.denseComponents.length);this.ap=Array(31);this.t0i=Array(this.n);this.posNeg=1}grid(m,e){if(!this.options.denseOutput)throw Error("Must set .denseOutput to true when using grid");
const c=this.options.denseComponents;let h;return(l,n,p,v)=>{for(h=null!==h&&void 0!==h?h:l;h<=n;){l=Array(c.length);for(p=0;p<c.length;++p)l[p]=v(c[p],h);if(!1===e(h,l))return!1;h+=m}}}expandToArray(m){return Array.isArray(m)?m:Array(this.n).fill(m,0)}copy(m,e){if(m.length!==e.length)throw Error("copy used on arrays of differing size");for(let c=0;c<m.length;++c)m[c]=e[c]}noDenseOutput(m,e){throw Error("denseOutput not enabled for this problem");}static stepSizeSequence(m,e){const c=Array(e);switch(m){case 1:for(m=
0;m<e;++m)c[m]=2*(m+1);break;case 2:c[0]=2;for(m=1;m<e;++m)c[m]=4*m;break;case 3:c[0]=2;c[1]=4;c[2]=6;for(m=3;m<e;++m)c[m]=2*c[m-2];break;case 4:for(m=0;m<e;++m)c[m]=4*m+2;break;case 5:for(m=0;m<e;++m)c[m]=4*(m+1);break;default:throw Error("invalid stepSizeSequence selected");}return c}interp(m,e){const c=this.options.denseComponents.length;for(let w=0;w<c;++w){var h=m[w];const z=m[2*c+w];var l=m[c+w];const x=m[3*c+w];var n=z-h,p=-x+n,v=l-n;m[c+w]=n;m[2*c+w]=p;m[3*c+w]=v;if(!(0>e)){h=.5*(h+z)+.125*
(p+v);n+=.25*(p-v);l=-(l-x);p=6*(v-p);if(1<=e&&(this.ap[1]=16*(m[5*c+w]-n),3<=e&&(this.ap[3]=16*(m[7*c+w]-p+3*this.ap[1]),5<=e)))for(p=5;p<=e;p+=2)v=p*(p-1)/2,this.ap[p]=16*(m[(p+4)*c+w]+v*this.ap[p-2]-v*(p-2)*(p-3)*2*this.ap[p-4]);this.ap[0]=16*(m[4*c+w]-h);if(2<=e&&(this.ap[2]=16*(m[6*c+w]-l+this.ap[0]),4<=e))for(h=4;h<=e;h+=2)this.ap[h]=16*(m[c*(h+4)+w]+h*(h-1)/2*this.ap[h-2]-this.ap[h-4]*h*(h-1)*(h-2)*(h-3));for(h=0;h<=e;++h)m[c*(h+4)+w]=this.ap[h]}}}contex(m,e,c){const h=this.dens.slice();return(l,
n)=>{const p=this.options.denseComponents.length;let v=this.options.denseComponents.indexOf(l);if(0>v)throw Error("no dense output available for component "+l);l=(n-m)/e;n=1-l;const w=h[v]+l*(h[p+v]+n*(h[2*p+v]*l+h[3*p+v]*n));if(0>c)return w;const z=l-.5;let x=h[p*(c+4)+v];for(let E=c;1<=E;--E)x=h[p*(E+3)+v]+x*z/E;return w+Math.pow(l*n,2)*x}}midEx(m,e,c,h,l){var n=e/this.nj[m];for(var p=0;p<this.n;++p)this.yh1[p]=h[p],this.yh2[p]=h[p]+n*l[p];p=this.nj[m]-1;const v=this.nj[m]/2|0;for(let x=1;x<=p;++x){if(this.options.denseOutput&&
x===v)for(var w=0;w<this.options.denseComponents.length;++w)this.ySafe[m][w]=this.yh2[this.options.denseComponents[w]];this.f(c+n*x,this.yh2,this.dy);if(this.options.denseOutput&&Math.abs(x-v)<=2*m+1)for(++this.iPt,w=0;w<this.options.denseComponents.length;++w)this.fSafe[this.iPt-1][w]=this.dy[this.options.denseComponents[w]];for(w=0;w<this.n;++w){var z=this.yh1[w];this.yh1[w]=this.yh2[w];this.yh2[w]=z+2*n*this.dy[w]}if(x<=this.options.stabilityCheckCount&&m<this.options.stabilityCheckTableLines){w=
0;for(z=0;z<this.n;++z)w+=Math.pow(l[z]/this.scal[z],2);z=0;for(let E=0;E<this.n;++E)z+=Math.pow((this.dy[E]-l[E])/this.scal[E],2);if(4<z/Math.max(this.options.uRound,w))return++this.nEval,!1}}this.f(c+e,this.yh2,this.dy);if(this.options.denseOutput&&v<=2*m+1)for(++this.iPt,c=0;c<this.options.denseComponents.length;++c)this.fSafe[this.iPt-1][c]=this.dy[this.options.denseComponents[c]];for(c=0;c<this.n;++c)this.t[m][c]=(this.yh1[c]+this.yh2[c]+n*this.dy[c])/2;this.nEval+=this.nj[m];if(0===m)return!0;
for(c=m;0<c;--c)for(n=Math.pow(this.nj[m]/this.nj[c-1],2)-1,l=0;l<this.n;++l)this.t[c-1][l]=this.t[c][l]+(this.t[c][l]-this.t[c-1][l])/n;this.err=0;for(n=0;n<this.n;++n)this.scal[n]=this.aTol[n]+this.rTol[n]*Math.max(Math.abs(h[n]),Math.abs(this.t[0][n])),this.err+=Math.pow((this.t[0][n]-this.t[1][n])/this.scal[n],2);this.err=Math.sqrt(this.err/this.n);if(1<=this.err*this.options.uRound||1<m&&this.err>=this.errOld)return!1;this.errOld=Math.max(4*this.err,1);h=1/(2*m+1);n=Math.pow(this.options.stepSizeFac1,
h);n=Math.min(this.options.stepSizeFac2/n,Math.max(n,Math.pow(this.err/this.options.stepSafetyFactor1,h)/this.options.stepSafetyFactor2));this.hh[m]=Math.min(1/n*Math.abs(e),this.hMax);this.w[m]=this.a[m]/this.hh[m];return!0}acceptStep(m,e,c,h,l){const n=2*m-this.options.interpolationFormulaDegree+1;var p=void 0;if(this.options.denseOutput){const H=this.options.denseComponents.length;for(var v=0;v<H;++v)this.dens[v]=h[this.options.denseComponents[v]];for(v=0;v<H;++v)this.dens[H+v]=e*l[this.options.denseComponents[v]];
v=2*H;for(var w=0;w<H;++w)this.dens[v+w]=this.t[0][this.options.denseComponents[w]];for(v=2;v<=m;++v)for(w=v;2<=w;--w){var z=Math.pow(this.nj[v-1]/this.nj[w-2],2)-1;for(var x=0;x<H;++x)this.ySafe[w-2][x]=this.ySafe[w-1][x]+(this.ySafe[w-1][x]-this.ySafe[w-2][x])/z}z=4*H;for(v=0;v<H;++v)this.dens[z+v]=this.ySafe[0][v];for(v=0;v<this.n;++v)this.t0i[v]=this.t[0][v];this.f(c+e,this.t0i,this.fx);z=3*H;for(v=0;v<H;++v)this.dens[z+v]=this.fx[this.options.denseComponents[v]]*e;for(v=1;v<=n;++v){w=(v+1)/2|
0;for(z=w;z<=m;++z){x=Math.pow(this.nj[z-1]/2,v-1);this.iPt=this.iPoint[z]-2*z+v;for(var E=0;E<H;++E)this.ySafe[z-1][E]=this.fSafe[this.iPt-1][E]*x}for(z=w+1;z<=m;++z)for(x=z;x>=w+1;--x){E=Math.pow(this.nj[z-1]/this.nj[x-2],2)-1;for(let I=0;I<H;++I)this.ySafe[x-2][I]=this.ySafe[x-1][I]+(this.ySafe[x-1][I]-this.ySafe[x-2][I])/E}z=(v+4)*H;for(x=0;x<H;++x)this.dens[z+x]=this.ySafe[w-1][x]*e;if(v!==n){for(w=(v+2)/2|0;w<=m;++w){x=this.iPoint[w];z=this.iPoint[w-1]+v+1;for(1===v&&4===this.options.stepSizeSequence&&
(z+=2);x>=z;x-=2)for(E=0;E<H;++E)this.fSafe[x-1][E]-=this.fSafe[x-3][E];if(1===v&&4===this.options.stepSizeSequence)for(x=z-2,z=0;z<H;++z)this.fSafe[x-1][z]-=l[this.options.denseComponents[z]]}for(w=(v+2)/2|0;w<=m;++w)for(x=this.iPoint[w]-1,z=this.iPoint[w-1]+v+2;x>=z;x-=2)for(E=0;E<H;++E)this.fSafe[x-1][E]-=this.fSafe[x-3][E]}}this.interp(this.dens,n);if(this.options.denseOutputErrorEstimator&&1<=n){m=0;for(p=0;p<H;++p)m+=Math.pow(this.dens[(n+4)*H+p]/this.scal[this.options.denseComponents[p]],2);
m=Math.sqrt(m/H)*this.errfac[n-1];p=e/Math.max(Math.pow(m,1/(n+4)),.01);if(10<m)return++this.nReject,{accept:!1,hoptde:p}}this.copy(l,this.fx)}this.copy(h,this.t[0]);++this.nAccept;return{accept:!0,hoptde:p,densef:this.options.denseOutput?this.contex(c,e,n):this.noDenseOutput}}newOrderAndStepSize(m,e,c,h){let l;2===e?(l=Math.min(3,this.options.maxExtrapolationColumns-1),m&&(l=2)):e<=c?(l=e,this.w[e-2]<this.w[e-1]*this.options.stepSizeFac3&&(l=e-1),this.w[e-1]<this.w[e-2]*this.options.stepSizeFac4&&
(l=Math.min(e+1,this.options.maxExtrapolationColumns-1))):(l=e-1,3<e&&this.w[e-3]<this.w[e-2]*this.options.stepSizeFac3&&(l=e-2),this.w[e-1]<this.w[l-1]*this.options.stepSizeFac4&&(l=Math.min(e,this.options.maxExtrapolationColumns-1)));if(m)return{k:Math.min(l,e),h:this.posNeg*Math.min(Math.abs(h),Math.abs(this.hh[c-1]))};m={h:0,k:0};m.h=l<=e?this.hh[l-1]:e<c&&this.w[e-1]<this.w[e-2]*this.options.stepSizeFac4?this.hh[e-1]*this.a[l]/this.a[e-1]:this.hh[e-1]*this.a[l-1]/this.a[e-1];m.h=this.posNeg*
Math.abs(m.h);m.k=l;return m}solve(m,e,c,h){if(this.options.denseOutput&&!h)throw Error("solve: denseOutput requires a solution observer function");let l=e;for(let n of this.solutionSegments(m,e,c))h&&h(n.x0,n.x1,n.y,n.f),l=n.y;return{y:l,nStep:this.nStep,xEnd:c,nAccept:this.nAccept,nReject:this.nReject,nEval:this.nEval}}integrate(m,e){if(!this.options.denseOutput)throw Error("integrate interface requires denseOutput");const c=this.options.denseComponents,h=this.solutionSegments(m,e);let l=h.next(),
n=!1;return(p,v)=>{if(void 0===p)return h.next(!1),n=!0,[];if(p<l.value.x0)throw Error("cannot use interpolation function in backwards direction");if(n)throw Error("cannot use interpolation function after closing integrator");for(;!l.done&&p>l.value.x1;)l=h.next();if(void 0!==v){for(var w=0;w<c.length;++w)v[w]=l.value.f(c[w],p);return v}v=Array(c.length);for(w=0;w<c.length;++w)v[w]=l.value.f(c[w],p);return v}}*solutionSegments(m,e,c){var h,l;if(!Array.isArray(e)||e.length!=this.n)throw Error("y0 must be an array sized to the dimension of the problem");
e=e.slice();this.hMax=(this.hMax=this.options.maxStepSize)?this.options.maxStepSize:c?Math.abs(c-m):1;this.nStep=this.nAccept=this.nReject=0;this.posNeg=c?0<=c-m?1:-1:1;for(var n=0;n<this.n;++n)this.scal[n]=this.aTol[n]+this.rTol[n]+Math.abs(e[n]);n=Math.max(2,Math.min(this.options.maxExtrapolationColumns-1,Math.floor(.6*-Math.log10(this.rTol[0]+1E-40)+1.5)));let p=Math.max(Math.abs(this.options.initialStepSize),1E-4);p=this.posNeg*Math.min(p,this.hMax,c?Math.abs(c-m)/2:Infinity);let v=m;this.iPt=
0;if(this.options.denseOutput){this.iPoint[0]=0;for(var w=0;w<this.options.maxExtrapolationColumns;++w){var z=4*(w+1)-2;this.nj[w]>z&&++z;this.iPoint[w+1]=this.iPoint[w]+z}for(w=0;w<2*this.options.maxExtrapolationColumns;++w){z=.5*Math.sqrt((w+1)/(w+5));var x=Math.pow(1/(w+5),2);for(var E=1;E<=w+1;++E)x*=z/E;this.errfac[w]=x}}this.err=0;this.errOld=1E10;w=this.posNeg*this.hMax;x=z=!1;E=0;var H=A.Start;a:for(;;)switch(this.options.debug&&console.log(`#${this.nStep} ${A[H]} [${v},${m}] h=${p} k=${n}`),
H){case A.Start:if(void 0!==c){if(.1*Math.abs(c-m)<=Math.abs(m)*this.options.uRound)break a;p=this.posNeg*Math.min(Math.abs(p),Math.abs(c-m),this.hMax,Math.abs(w));0<(m+1.01*p-c)*this.posNeg&&(p=c-m,x=!0)}else p=this.posNeg*Math.min(Math.abs(p),this.hMax,Math.abs(w));0!==this.nStep&&this.options.denseOutput||(this.f(m,e,this.dz),++this.nEval);if(0===this.nStep||x){this.iPt=0;++this.nStep;for(var I=1;I<=n;++I){E=I;if(!this.midEx(I-1,p,m,e,this.dz)){p*=this.options.stepSizeReductionFactor;z=!0;continue a}if(1<
I&&1>=this.err){H=A.Accept;continue a}}H=A.HopeForConvergence;continue}H=A.BasicIntegrationStep;continue;case A.BasicIntegrationStep:this.iPt=0;if(++this.nStep>=this.options.maxSteps)throw Error("maximum allowed steps exceeded: "+this.nStep);E=n-1;for(H=0;H<E;++H)if(!this.midEx(H,p,m,e,this.dz)){p*=this.options.stepSizeReductionFactor;z=!0;H=A.Start;continue a}H=2===n||z?A.ConvergenceStep:1>=this.err?A.Accept:this.err>Math.pow(this.nj[n]*this.nj[n-1]/4,2)?A.Reject:A.ConvergenceStep;continue;case A.ConvergenceStep:if(!this.midEx(n-
1,p,m,e,this.dz)){p*=this.options.stepSizeReductionFactor;z=!0;H=A.Start;continue}E=n;if(1>=this.err){H=A.Accept;continue}H=A.HopeForConvergence;continue;case A.HopeForConvergence:if(this.err>Math.pow(this.nj[n]/2,2)){H=A.Reject;continue}E=n+1;this.midEx(E-1,p,m,e,this.dz)?H=1<this.err?A.Reject:A.Accept:(p*=this.options.stepSizeReductionFactor,z=!0,H=A.Start);continue;case A.Accept:I=this.acceptStep(E,p,m,e,this.dz);H=A.Start;w=null!==(h=I.hoptde)&&void 0!==h?h:w;if(!I.accept){p=w;z=!0;continue}v=
m;m+=p;if(!1===(yield{x0:v,x1:m,y:e.slice(),f:null!==(l=I.densef)&&void 0!==l?l:this.noDenseOutput}))return;({k:n,h:p}=this.newOrderAndStepSize(z,E,n,p));z=!1;continue;case A.Reject:n=Math.min(n,E,this.options.maxExtrapolationColumns-1),2<n&&this.w[n-1]<this.w[n]*this.options.stepSizeFac3&&--n,++this.nReject,p=this.posNeg*this.hh[n-1],z=!0,H=A.BasicIntegrationStep}}}g.Solver=u;u.defaults={uRound:2.3E-16,maxSteps:1E4,initialStepSize:1E-4,maxStepSize:0,maxExtrapolationColumns:9,stepSizeSequence:0,stabilityCheckCount:1,
stabilityCheckTableLines:2,denseOutput:!0,denseOutputErrorEstimator:!0,denseComponents:[],interpolationFormulaDegree:4,stepSizeReductionFactor:.5,stepSizeFac1:.02,stepSizeFac2:4,stepSizeFac3:.8,stepSizeFac4:.9,stepSafetyFactor1:.65,stepSafetyFactor2:.94,relativeTolerance:1E-5,absoluteTolerance:1E-5,debug:!1,rawFunction:!1}};
'use strict';var nD,UNa,VNa,oD,pD,qD,XNa,sD,ZNa,tD,uD,vD,wD,$Na,aOa,bOa,xD,yD,zD,AD,BD,CD,cOa,dOa,eOa,fOa,DD,gOa,hOa,iOa,ID,kOa,mOa,oOa,pOa,PD,RD,SD,UD,VD,qOa,uOa,XD,YD,vOa,ZD,xOa,$D,zOa,AOa,bE,cE,GOa,IOa,LOa,MOa,eE,POa,SOa,WOa,XOa,gE,YOa,ZOa,dPa,fPa,gPa,mE,hPa,kPa,pE,pPa,oPa,rPa,sPa,tPa,uPa,BPa,FPa,HPa,IPa,JPa,tE,vE,uE,MPa,NPa,OPa,RPa,SPa,XPa,ZPa,$Pa,bQa,fQa,gQa,hQa,iQa,jQa,kQa,lQa,nQa,sQa,wQa,AQa,BQa,DQa,EQa,FQa,GQa,HQa,IQa,JQa,MQa,QE,NQa,OQa,PQa,RE,RQa,SQa,TQa,VQa,WQa,XQa,YQa,hRa,mRa,pRa,vRa,wRa,
yRa,ARa,BRa,FRa,GRa,HRa,IRa,JRa,KRa,QRa,URa,WRa,XRa,dE,aSa,bSa,fSa,hSa,nF,gSa,mSa,iSa,pSa,rSa,uSa,kF,wSa,ySa,HE,GE,zSa,jSa,BSa,sF,CSa,DSa,uF,wF,ESa,FSa,GSa,HSa,ISa,KSa,yF,LSa,MSa,NSa,zF,OSa,AF,BF,CF,DF,EF,GF,QSa,RSa,HF,TSa,IF,USa,LF,VSa,SF,UF,XSa,WF,YSa,ZSa,$Sa,XF,aTa,bTa,YF,ZF,cTa,dTa,eTa,fTa,cG,dG,eG,gTa,gG,hTa,kTa,lTa,mTa,pTa,rTa,tTa,uTa,vTa,wTa,yTa,zTa,ATa,BTa,CTa,DTa,ETa,vG,FTa,GTa,HTa,ITa,JTa,KTa,BG,CG,LTa,MTa,NTa,OTa,PTa,QTa,RTa,$Ta,aUa,bUa,HG,cUa,dUa,eUa,fUa,gUa,jUa,kUa,IG,lUa,mUa,nUa,oUa,
wUa,xUa,JG,KG,LG,MG,FUa,HUa,GUa,LUa,KUa,PUa,QUa,SUa,RUa,QG,WUa,RG,VUa,UUa,SG,TG,ZUa,$Ua,bVa,UG,cVa,eVa,gVa,hVa,iVa,oVa,pVa,uVa,vVa,AVa,$G,aH,aWa,dH,bWa,gH,cWa,dWa,iH,jH,eWa,hWa,iWa,jWa,kWa,zH,lWa,mWa,oWa,pWa,qWa,rWa,DH,tWa,uWa,vWa,xWa,EH,zWa,FH,GH,HH,IH,AWa,JH,KH,CWa,LH,MH,OH,DWa,EWa,FWa,GWa,SH,UH,VH,WH,YH,ZH,$H,IWa,KWa,bI,cI,LWa,dI,MWa,NWa,eI,OWa,gI,iI,hI,PWa,QWa,RWa,kI,SWa,TWa,UWa,mI,nI,oI,pI,VWa,WWa,XWa,YWa,ZWa,tI,uI,$Wa,bXa,aXa,dXa,vI,wI,eXa,fXa,gXa,hXa,iXa,kXa,lXa,mXa,nXa,oXa,pXa,qXa,rXa,zI,
AI,sXa,tXa,uXa,vXa,CI,wXa,xXa,yXa,zXa,AXa,FI,BXa,CXa,DXa,GI,EXa,FXa,GXa,HXa,IXa,HI,JXa,II,KXa,KI,LXa,MI,MXa,NI,OI,PI,QI,NXa,RI,OXa,SI,TI,PXa,QXa,UI,VI,RXa,SXa,TXa,UXa,VXa,WI,WXa,YI,ZI,$I,ZXa,aJ,bJ,cJ,$Xa,dJ,bYa,cYa,fYa,gYa,hYa,iYa,jYa,kYa,lYa,nYa,oYa,pYa,gJ,hJ,qYa,rYa,kJ,sYa,tYa,uYa,vYa,wYa,xYa,zYa,lJ,nJ,pJ,AYa,BYa,CYa,qJ,rJ,sJ,DYa,EYa,FYa,GYa,HYa,IYa,JYa,KYa,tJ,LYa,OYa,UYa,XYa,bZa,hZa,iZa,sZa,tZa,uZa,wZa,xZa,zK,zZa,BK,CK,DK,EK,FK,GK,HK,IK,AZa,BZa,CZa,DZa,EZa,FZa,GZa,HZa,IZa,JZa,NK,KZa,LZa,MZa,PK,
QK,RK,TK,UK,NZa,OZa,VK,WK,PZa,QZa,RZa,YK,WZa,XZa,ZK,$K,YZa,aL,ZZa,bL,cL,eL,fL,gL,$Za,a_a,iL,jL,c_a,d_a,lL,nL,oL,e_a,f_a,pL,g_a,sL,tL,h_a,i_a,j_a,vL,wL,xL,yL,AL,k_a,l_a,CL,m_a,n_a,o_a,p_a,DL,EL,FL,GL,q_a,r_a,s_a,t_a,HL,IL,u_a,v_a,w_a,y_a,x_a,JL,A_a,KL,LL,ML,NL,OL,PL,QL,RL,B_a,C_a,D_a,E_a,F_a,G_a,H_a,UL,I_a,J_a,VL,K_a,WL,ZL,O_a,P_a,$L,aM,Q_a,T_a,bM,W_a,Y_a,Z_a,$_a,a0a,b0a,f0a,g0a,h0a,i0a,k0a,kM,l0a,n0a,o0a,p0a,q0a,r0a,s0a,t0a,u0a,v0a,x0a,z0a,A0a,B0a,C0a,D0a,E0a,F0a,G0a,H0a,sM,tM,uM,I0a,J0a,K0a,L0a,
vM,M0a,xM,N0a,O0a,P0a,Q0a,R0a,S0a,T0a,U0a,V0a,W0a,X0a,Y0a,Z0a,$0a,yM,a1a,zM,AM,b1a,c1a,CM,d1a,f1a,h1a,HM,IM,JM,KM,z1a,QM,A1a,SM,UM,C1a,VM,D1a,WM,E1a,F1a,XM,G1a,H1a,I1a,J1a,K1a,L1a,aN,M1a,O1a,N1a,gN,fN,kN,jN,lN,P1a,mN,nN,oN,pN,qN,Q1a,rN,R1a,S1a,sN,T1a,tN,U1a,V1a,W1a,X1a,Y1a,uN,wN,Z1a,$1a,a2a,b2a,yN,zN,c2a,d2a,e2a,f2a,AN,g2a,h2a,BN,i2a,j2a,DN,EN,GN,k2a,IN,l2a,m2a,n2a,o2a,p2a,q2a,r2a,s2a,KN,t2a,u2a,v2a,MN,PN,A2a,B2a,SN,C2a,D2a,TN,E2a,VN,F2a,G2a,H2a,I2a,ZN,XN,J2a,$N,aO,K2a,bO,cO,L2a,N2a,O2a,Q2a,R2a,U2a,
V2a,W2a,X2a,Y2a,Z2a,hO,$2a,iO,a3a,jO,b3a,c3a,d3a,e3a,f3a,g3a,h3a,i3a,nO,k3a,l3a,o3a,pO,rO,q3a,t3a,sO,u3a,tO,z3a,vO,wO,A3a,B3a,xO,yO,C3a,D3a,E3a,zO,AO,uO,F3a,CO,DO,EO,G3a,H3a,I3a,J3a,HO,L3a,M3a,N3a,O3a,IO,R3a,T3a,V3a,X3a,Y3a,Z3a,$3a,a4a,b4a,UO,WO,f4a,g4a,h4a,e4a,d4a,j4a,k4a,ZO,l4a,m4a,o4a,p4a,q4a,r4a,s4a,v4a,A4a,B4a,aP,cP,D4a,E4a,dP,fP,G4a,H4a,I4a,J4a,iP,L4a,M4a,kP,O4a,Q4a,S4a,lP,W4a,X4a,Z4a,$4a,mP,nP,a5a,pP,b5a,c5a,d5a,e5a,f5a,sP,tP,uP,vP,h5a,i5a,j5a,k5a,l5a,m5a,n5a,o5a,p5a,AP,r5a,s5a,u5a,BP,x5a,
z5a,A5a,C5a,E5a,EP,G5a,FP,GP,HP,J5a,K5a,L5a,M5a,N5a,O5a,P5a,R5a,S5a,T5a,U5a,V5a,W5a,X5a,Y5a,Z5a,$5a,a6a,b6a,c6a,NP,d6a,e6a,f6a,g6a,h6a,i6a,j6a,OP,k6a,PP,QP,n6a,o6a,p6a,q6a,r6a,t6a,u6a,v6a,w6a,x6a,y6a,z6a,RP,A6a,B6a,C6a,D6a,E6a,F6a,G6a,H6a,I6a,J6a,K6a,L6a,M6a,N6a,R6a,S6a,XP,YP,T6a,aQ,X6a,bQ,cQ,Y6a,dQ,Z6a,m7a,n7a,gQ,hQ,o7a,p7a,iQ,jQ,s7a,t7a,u7a,v7a,B7a,C7a,F7a,G7a,H7a,rQ,sQ,L7a,M7a,N7a,O7a,Q7a,S7a,T7a,U7a,V7a,X7a,Y7a,Z7a,$7a,a8a,d8a,f8a,h8a,i8a,k8a,l8a,n8a,o8a,p8a,q8a,s8a,u8a,v8a,w8a,x8a,y8a,z8a,A8a,
C8a,D8a,EQ,F8a,G8a,H8a,I8a,J8a,K8a,L8a,N8a,O8a,P8a,Q8a,R8a,S8a,IQ,T8a,U8a,V8a,W8a,$8a,a9a,f9a,KQ,MQ,NQ,g9a,h9a,j9a,k9a,l9a,m9a,n9a,o9a,p9a,q9a,r9a,s9a,u9a,v9a,TQ,w9a,x9a,y9a,z9a,A9a,B9a,C9a,D9a,E9a,F9a,G9a,H9a,I9a,WQ,J9a,XQ,K9a,L9a,M9a,N9a,P9a,Q9a,S9a,U9a,V9a,W9a,X9a,Y9a,Z9a,dR,$9a,a$a,b$a,c$a,d$a,e$a,f$a,g$a,h$a,j$a,k$a,l$a,fR,gR,m$a,n$a,o$a,p$a,hR,iR,q$a,r$a,jR,s$a,lR,t$a,nR,u$a,v$a,w$a,oR,x$a,y$a,z$a,pR,qR,A$a,sR,B$a,C$a,D$a,E$a,F$a,G$a,H$a,I$a,yR,K$a,L$a,M$a,N$a,O$a,P$a,Q$a,R$a,AR,S$a,T$a,U$a,
V$a,W$a,Y$a,aab,dab,hab,iab,jab,mab,nab,qab,rab,LR,sab,tab,uab,vab,wab,xab,NR,OR,PR,yab,zab,Aab,Bab,Cab,QR,Eab,Fab,Jab,Kab,Lab,Mab,Nab,Oab,Pab,Qab,Rab,Sab,Tab,Uab,Vab,Wab,TR,Xab,Yab,Zab,$ab,abb,bbb,cbb,dbb,ebb,XK,fbb,hK,A7a,gbb,hbb,ibb,jbb,kbb,qRa,lbb,mbb,nbb,obb,vSa,pbb,qbb,rbb,sbb,tbb,ubb,vbb,wbb,xbb,PPa,ybb,zbb,Abb,Bbb,Cbb,Dbb,Ebb,Fbb,Gbb,Hbb,F5a,Ibb,Jbb,Kbb,Lbb,Mbb,Nbb,Obb,Pbb,UR,Qbb,Rbb,Sbb,t9a,Tbb,Ubb,Vbb,VR,Wbb,Xbb,Ybb,Zbb,$bb,acb,bcb,ccb,dcb,ecb,fcb,gcb,Q3a,icb,jcb,WR,kcb,lcb,mcb,ncb,ocb,
pcb,qcb,rcb,scb,tcb,ucb,vcb,wcb,YR,xcb,ycb,zcb,Acb,Bcb,Ccb,Dcb,Ecb,ZR,Fcb,Gcb,Hcb,Icb,Jcb,Kcb,Lcb,Mcb,Ncb,$R,eJ,Ocb,Pcb,Qcb,Rcb,Scb,Tcb,Ucb,JUa,Vcb,Wcb,Xcb,Ycb,Zcb,$cb,adb,aS,bdb,cdb,ddb,edb,fdb,gdb,hdb,idb,jdb,kdb,T4a,ldb,mdb,ndb,NRa,odb,pdb,qdb,rdb,sdb,tdb,udb,bS,vdb,wdb,xdb,ydb,zdb,Adb,FD,Bdb,Cdb,Ddb,Edb,cS,Fdb,Gdb,Hdb,Idb,Jdb,dS,Kdb,Ldb,Mdb,Ndb,CRa,Odb,Pdb,JOa,Qdb,Rdb,Sdb,eS,Tdb,Udb,S3a,Wdb,cSa,Xdb,Ydb,Zdb,$db,eRa,aeb,beb,ceb,deb,eeb,feb,geb,heb,ieb,jeb,keb,leb,fS,gS,meb,neb,oeb,peb,qeb,reb,seb,
teb,ueb,U3a,web,hS,xeb,yeb,Aeb,Beb,Ceb,iS,Deb,Eeb,Feb,Geb,Heb,jS,Ieb,kS,Jeb,CPa,Keb,Leb,lS,Meb,Neb,Oeb,Peb,Qeb,Reb,Seb,Teb,Ueb,Veb,Web,jTa,Xeb,Yeb,Zeb,$eb,afb,bfb,cfb,dfb,FVa,efb,mS,ffb,LVa,nS,gfb,hfb,ifb,jfb,oS,kfb,lfb,mfb,FF,UN,nfb,ofb,LPa,pfb,qfb,TOa,pS,rfb,sfb,tfb,tK,ufb,vfb,uK,vK,qS,rS,wfb,nZa,xfb,yfb,zfb,Afb,Bfb,Cfb,Dfb,Efb,APa,rE,Ffb,Gfb,Hfb,Ifb,Jfb,Kfb,QPa,Lfb,Mfb,Nfb,Ofb,Pfb,Qfb,tS,Rfb,Sfb,Tfb,uS,vS,Ufb,Vfb,rOa,Wfb,Xfb,Yfb,Zfb,$fb,wS,agb,bgb,cgb,BUa,xS,QS,xK,TTa,yK,dgb,egb,fgb,ggb,hgb,igb,
jgb,kgb,lgb,mgb,ngb,ogb,pgb,ED,RS,qgb,rgb,sgb,tgb,ugb,vgb,wgb,NG,xgb,x2a,ygb,bK,cK,SS,eK,fK,zgb,Agb,Bgb,Cgb,KOa,Dgb,Egb,EVa,Fgb,Ggb,Hgb,Igb,Jgb,Kgb,Lgb,TS,US,Mgb,Ngb,JVa,ROa,Ogb,Pgb,Qgb,Rgb,Sgb,Tgb,VS,Ugb,Vgb,Wgb,Y8a,Xgb,b8a,Ygb,Zgb,$gb,ahb,bhb,chb,kab,DPa,dhb,ehb,fhb,WS,ghb,hhb,ihb,jhb,khb,oQa,lhb,mhb,nhb,XS,ohb,phb,qhb,rhb,shb,thb,FOa,uhb,XH,kK,vhb,whb,xhb,YS,yhb,zhb,Ahb,ZS,Bhb,Chb,Dhb,Ehb,Fhb,Ghb,Hhb,Ihb,Jhb,EOa,Khb,Lhb,s6a,Mhb,Nhb,Ohb,Phb,cPa,Qhb,Rhb,Shb,Thb,Uhb,Vhb,Whb,uRa,Xhb,Yhb,W3a,$hb,aib,
bib,cib,dib,eib,fib,$S,gib,hib,iib,aT,jib,kib,lib,mib,nib,oib,pib,qib,rib,sib,bT,tib,uib,DUa,vib,wib,xib,yib,pZa,zib,Aib,Bib,Cib,Dib,Eib,Fib,hcb,Hib,Iib,Jib,wWa,Kib,Lib,Mib,Nib,Oib,Pib,Qib,TM,Rib,Sib,Tib,Uib,Vib,Wib,Xib,DP,Yib,Zib,$ib,ajb,bjb,cjb,djb,ejb,fjb,gjb,hjb,ijb,COa,Vdb,kjb,VVa,ljb,mjb,ZM,YNa,njb,ojb,pjb,qjb,rjb,dT,sjb,tjb,ujb,vjb,eT,wjb,fT,xjb,yjb,QYa,zjb,Ajb,Bjb,Cjb,Djb,Ejb,Fjb,Gjb,Hjb,hT,GPa,NUa,Ijb,Jjb,Kjb,Ljb,Mjb,Njb,iT,jRa,Ojb,Pjb,Qjb,jT,Rjb,Sjb,Tjb,Ujb,Vjb,Wjb,Xjb,kT,Yjb,UE,Zjb,$jb,
akb,bkb,w5a,ckb,rZa,dkb,ekb,fkb,gkb,XL,KVa,hkb,ikb,aRa,jkb,kkb,lkb,mkb,nkb,okb,lT,pkb,qkb,rkb,skb,tkb,ukb,P6a,vkb,wkb,xkb,ykb,zkb,Akb,Bkb,Ckb,kZa,lZa,mT,w7a,Dkb,c8a,Ekb,Fkb,Gkb,Hkb,Ikb,Jkb,Kkb,Lkb,Mkb,nT,Nkb,Okb,Pkb,Qkb,Rkb,Skb,Tkb,Ukb,Vkb,J$a,Wkb,Xkb,Ykb,iPa,Zkb,$kb,alb,blb,clb,oT,dlb,elb,pT,flb,glb,hlb,ilb,jlb,n4a,klb,llb,mlb,qT,nlb,olb,plb,qlb,rlb,NN,yWa,slb,tlb,ulb,rT,vlb,wlb,xlb,ylb,zlb,Alb,Blb,Clb,Dlb,Elb,Flb,Glb,Hlb,Ilb,veb,Klb,Llb,e7a,w3a,Mlb,KPa,Nlb,Olb,Plb,Qlb,Rlb,Slb,Tlb,sT,Ulb,Vlb,Wlb,
yPa,Xlb,Ylb,Zlb,$lb,amb,bmb,cmb,dmb,emb,fmb,gmb,hmb,imb,jmb,kmb,xQa,lmb,mmb,nmb,omb,pmb,IP,qmb,rmb,smb,tmb,umb,vmb,wmb,xmb,j7a,ymb,zmb,Amb,Bmb,Cmb,Dmb,CQa,Emb,D5a,EPa,Fmb,Gmb,Hmb,Imb,Jmb,bPa,Kmb,Lmb,Mmb,tT,Nmb,Omb,Pmb,Qmb,mH,Rmb,Smb,Tmb,Umb,Vmb,Wmb,Xmb,uT,Ymb,Zmb,$mb,anb,bnb,vT,cnb,dnb,enb,fnb,gnb,hnb,inb,jnb,knb,lnb,mnb,nnb,onb,pnb,qnb,rnb,snb,tnb,unb,vnb,wnb,xnb,wT,WJ,ynb,VJ,znb,Anb,UJ,TJ,PJ,Bnb,Cnb,xT,Dnb,yT,zT,Enb,AT,OJ,NJ,Fnb,QJ,Gnb,Hnb,Inb,BT,Jnb,Knb,Lnb,Mnb,Nnb,Onb,Pnb,Qnb,BVa,Rnb,CT,Snb,Tnb,
Unb,Vnb,Wnb,Xnb,Ynb,Znb,$nb,aob,kRa,bob,cob,VRa,dob,eob,fob,gob,DT,hob,eP,ET,iob,job,kob,lob,mob,nob,oob,pob,qob,m6a,rob,sob,tob,uob,vob,jK,wob,LD,xob,FT,yob,zob,Aob,Bob,Cob,Dob,Eob,GT,oSa,pH,Fob,Gob,Hob,Iob,Job,Kob,Lob,P2a,Mob,Nob,Oob,Pob,Qob,Rob,Sob,Tob,IT,Uob,Vob,Wob,Xob,Yob,Zob,$ob,apb,bpb,cpb,dpb,epb,fpb,gpb,hpb,ipb,jpb,kpb,lpb,yYa,mpb,npb,JT,opb,ppb,qpb,lSa,KT,rpb,spb,tpb,upb,vpb,LT,wpb,xpb,ypb,zpb,Apb,Bpb,Cpb,PRa,Dpb,p3a,MT,NT,Epb,Fpb,Gpb,Hpb,Ipb,Jpb,Kpb,V6a,Lpb,Mpb,Npb,Opb,OT,Ppb,Qpb,Rpb,
Spb,Tpb,Upb,Vpb,Wpb,Xpb,Ypb,Zpb,AE,i4a,$pb,aqb,bqb,cqb,dqb,eqb,Zhb,PT,gqb,hqb,iqb,QT,jqb,kqb,lqb,mqb,RT,nqb,oqb,pqb,ST,qqb,rqb,sqb,hF,tqb,uqb,vqb,wqb,xqb,Dab,yqb,zqb,Aqb,TT,Bqb,Cqb,Dqb,Eqb,Fqb,UT,Gib,Hqb,S_a,VT,Iqb,Jqb,ORa,oF,Kqb,cRa,Lqb,WT,Mqb,Nqb,Oqb,Pqb,TH,Qqb,Rqb,Sqb,Tqb,Uqb,Vqb,cF,l6a,Wqb,Xqb,Yqb,Zqb,$qb,arb,XT,brb,YE,crb,drb,WYa,VYa,erb,frb,grb,hrb,NVa,DVa,FO,irb,jrb,T9a,krb,lrb,mrb,nrb,orb,prb,qrb,rrb,srb,trb,urb,vrb,wrb,xrb,yrb,zrb,aI,Arb,Brb,Crb,Drb,Erb,Frb,Grb,Hrb,Irb,Jrb,Krb,Lrb,Mrb,Nrb,
Orb,Prb,Qrb,Rrb,Srb,Trb,Urb,Vrb,Wrb,Xrb,Yrb,Zrb,$rb,asb,bsb,csb,esb,fsb,gsb,hsb,isb,jsb,ksb,lsb,msb,YT,nsb,osb,psb,qsb,rsb,ssb,tsb,ZT,usb,l7a,vsb,wsb,xsb,ysb,AQ,zsb,Asb,Bsb,Csb,Dsb,Esb,Fsb,Gsb,Hsb,Isb,Jsb,$T,Ksb,aU,bU,Lsb,Msb,Nsb,Osb,Psb,Qsb,Rsb,mK,Ssb,Tsb,Usb,Vsb,Wsb,Xsb,Ysb,Zsb,WVa,Q6a,H5a,$sb,atb,btb,fRa,ctb,dtb,etb,cU,ftb,gtb,htb,itb,jtb,ktb,ltb,mtb,ntb,otb,ptb,qtb,OG,rtb,stb,ttb,utb,vtb,wtb,xtb,ytb,ztb,MK,Atb,Btb,Ctb,Dtb,dU,Etb,Ftb,Gtb,Htb,Itb,Jtb,Ktb,Ltb,Mtb,Ntb,Ptb,jjb,Jlb,Rtb,eU,Stb,Ttb,Utb,
Vtb,Wtb,Xtb,Ytb,fqb,cab,$tb,aub,Gqb,cub,dub,EUa,eub,fub,gub,iub,Otb,jub,lQ,kub,lub,mub,nub,zE,oub,pub,qub,rub,sub,tub,uub,vub,wub,xub,yub,zub,Bub,Qtb,IE,Cub,Dub,Eub,Fub,qVa,Gub,Hub,Iub,gU,Jub,Kub,Lub,Mub,Nub,Oub,Pub,Qub,Rub,hU,Sub,t8a,Tub,Uub,Vub,Wub,W6a,Xub,iU,Yub,Zub,$ub,avb,bvb,YXa,cvb,dvb,evb,fvb,gvb,hvb,ivb,jvb,Ztb,lvb,NYa,mvb,nvb,ovb,pvb,qvb,MJ,rvb,svb,tvb,uvb,vvb,wvb,xvb,yvb,zvb,Avb,Bvb,QVa,Cvb,Dvb,Evb,Fvb,Gvb,Hvb,oZa,Ivb,Jvb,Kvb,Lvb,Mvb,Nvb,MYa,Ovb,jU,Pvb,Qvb,Rvb,Svb,Tvb,Uvb,Vvb,Wvb,Xvb,Yvb,
Zvb,$vb,VO,Z$a,awb,bwb,cwb,dwb,ewb,fwb,gwb,hwb,iwb,jwb,kwb,lwb,mwb,nwb,owb,pwb,qwb,rwb,swb,twb,uwb,vwb,wwb,xwb,ywb,zwb,Awb,Bwb,kU,Cwb,Dwb,LK,Ewb,Fwb,Gwb,v5a,SZa,Hwb,Iwb,Jwb,Kwb,Lwb,Mwb,lU,Nwb,Owb,Pwb,Qwb,Rwb,Swb,Twb,Uwb,Vwb,Wwb,VOa,Xwb,Ywb,Zwb,mU,$wb,axb,nU,bxb,cxb,dxb,exb,fxb,gxb,hxb,ixb,jxb,kxb,lxb,mxb,nxb,oxb,oU,pxb,qxb,rxb,sxb,txb,uxb,vxb,bub,xxb,yxb,zxb,w2a,Axb,Bxb,hub,Dxb,Exb,Fxb,Gxb,Hxb,Ixb,Jxb,Kxb,Mxb,Aub,aYa,pU,Nxb,Oxb,kSa,Pxb,kvb,Rxb,Sxb,z2a,Txb,Vxb,wxb,Wxb,Xxb,Yxb,Zxb,$xb,ayb,dQa,byb,lRa,
cyb,dyb,eyb,RR,fyb,gyb,hyb,iyb,jyb,kyb,lyb,myb,nyb,oyb,pyb,lVa,qyb,ryb,syb,tyb,uyb,vyb,wyb,xyb,yyb,zyb,Ayb,Byb,Cyb,Dyb,Eyb,rU,sU,lO,Fyb,vU,Gyb,wU,Hyb,xU,Iyb,Jyb,XI,XG,yU,zU,cH,CR,SR,AU,Kyb,Lyb,Myb,CU,EU,FU,Nyb,Oyb,HU,IU,Pyb,ON,Qyb,Ryb,eQ,Syb,Tyb,Uyb,YRa,Vyb,a7a,Wyb,Xyb,Yyb,Zyb,JU,$yb,azb,bzb,czb,dzb,ezb,XXa,fzb,gzb,LU,hzb,izb,jzb,kzb,HJ,MU,lzb,NU,mzb,GJ,OU,PU,QU,AJ,nzb,ozb,pzb,qzb,rzb,RU,szb,tzb,uzb,CJ,JJ,vzb,wzb,xzb,yzb,zzb,Azb,Bzb,Czb,Dzb,Ezb,Fzb,Gzb,qH,nK,iRa,Hzb,Izb,Jzb,Kzb,Lzb,Mzb,IVa,Nzb,Ozb,
Pzb,Qzb,TU,LQa,dRa,Rzb,Szb,Tzb,Uzb,Vzb,Wzb,Xzb,Yzb,Zzb,$zb,aAb,bAb,cAb,dAb,eAb,fAb,gAb,hAb,iAb,UU,jAb,kAb,lAb,z4a,mAb,nAb,oAb,pAb,qAb,rAb,sAb,tAb,uAb,vAb,wAb,xAb,yAb,zAb,AAb,BAb,CAb,DAb,VU,SK,EAb,FAb,GAb,HAb,IAb,sVa,JAb,KAb,LAb,MAb,NAb,WU,OAb,PAb,QAb,XVa,RAb,DOa,SAb,TAb,UAb,YU,VAb,WAb,XAb,YAb,ePa,ZAb,$Ab,ZU,nPa,aBb,bBb,cBb,dBb,eBb,fBb,gBb,hBb,iBb,jBb,VZa,kBb,lBb,mBb,oab,nBb,oBb,pBb,$U,qBb,rBb,sBb,tBb,uBb,vBb,bV,wBb,xBb,yBb,zBb,ABb,BBb,cV,sRa,CBb,DBb,EBb,FBb,dV,GBb,HBb,wQ,IBb,JBb,KBb,LBb,MBb,NBb,OBb,
PBb,QBb,RBb,SBb,iF,TBb,UBb,VBb,WBb,XBb,AUa,YBb,ZBb,$Bb,aCb,bCb,cCb,dCb,eCb,h7a,fCb,gCb,hCb,MRa,iCb,jCb,wVa,kCb,eV,lCb,mCb,nCb,oCb,pCb,wE,qCb,rCb,sCb,tCb,uCb,Cxb,wCb,xCb,yCb,zCb,ACb,BCb,CCb,DCb,ECb,FCb,GCb,HCb,ICb,JCb,cXa,KCb,LCb,fV,gV,MCb,NCb,hV,OCb,PCb,QCb,RCb,SCb,iV,TCb,UCb,VCb,WCb,XCb,YCb,ZCb,$Cb,aDb,bDb,jV,cDb,t4a,dDb,eDb,fDb,gDb,hDb,iDb,jDb,kDb,lDb,mDb,nDb,oDb,pDb,qDb,rDb,sDb,tDb,uDb,vDb,wDb,xDb,yDb,zDb,g8a,ADb,BDb,CDb,DDb,EDb,FDb,GDb,HDb,IDb,kV,JDb,lV,KDb,LDb,MDb,NDb,ODb,XE,mV,PDb,QDb,RDb,SDb,
TDb,UDb,VDb,WDb,XDb,YDb,ZDb,$Db,aEb,bEb,cEb,dEb,eEb,fEb,gEb,XTa,hEb,iEb,jEb,kEb,lEb,mEb,nV,nEb,oEb,pEb,qEb,rEb,sEb,tEb,uEb,vEb,wEb,xEb,yEb,oRa,zEb,AEb,TO,BEb,CEb,DEb,EEb,FEb,oV,GEb,HEb,IEb,JEb,pV,KEb,LEb,MEb,NEb,OEb,PEb,QEb,REb,SEb,TEb,UEb,VEb,WEb,XEb,YEb,ZEb,$Eb,aFb,bFb,cFb,dFb,eFb,fFb,gFb,hFb,iFb,jFb,kFb,lFb,mFb,nFb,oFb,pFb,qFb,rFb,TD,sFb,tFb,uFb,vFb,wFb,xFb,IUa,yFb,zFb,AFb,BFb,CFb,DFb,EFb,FFb,GFb,HFb,IFb,JFb,KFb,LFb,MFb,NFb,qV,OFb,PFb,QFb,RFb,rV,SFb,TFb,UFb,VFb,WFb,XFb,YFb,ZFb,$Fb,aGb,JD,bGb,cGb,
dGb,eGb,fGb,gGb,sV,tV,hGb,iGb,jGb,kGb,lGb,mGb,nGb,oGb,pGb,qGb,rGb,sGb,tGb,PM,uGb,vGb,wGb,xGb,yGb,zGb,AGb,uV,BGb,CGb,DGb,iN,EGb,FGb,GGb,HGb,IGb,Lxb,LGb,MGb,NGb,OGb,PGb,QGb,hUa,RGb,SGb,TGb,UGb,lE,VGb,WGb,XGb,YGb,ZGb,$Gb,aHb,bHb,cHb,dHb,eHb,fHb,gHb,ER,hHb,yE,iHb,jHb,kHb,lHb,mHb,nHb,oHb,pHb,vV,wV,qHb,rHb,xV,P3a,sHb,tHb,uHb,LP,yV,vHb,wHb,xHb,yHb,zHb,AHb,BHb,CHb,DHb,EHb,qO,FHb,GHb,zV,HHb,IHb,JHb,TE,y7a,KHb,LHb,MHb,RH,i7a,NHb,R4a,OHb,PHb,QHb,AV,BV,RHb,SHb,THb,UHb,VHb,r7a,WHb,XHb,YHb,ZHb,$Hb,aIb,bIb,cIb,
dIb,eIb,mVa,fIb,gIb,hIb,CV,iIb,DV,jIb,kIb,lIb,mIb,nIb,oIb,pIb,qIb,rIb,sIb,tIb,uIb,vIb,EV,FV,wIb,xIb,GV,Qxb,zIb,AIb,BIb,CIb,HV,E8a,DIb,EIb,FIb,GIb,HIb,CP,IIb,BJ,JIb,KIb,IV,LIb,MIb,NIb,OIb,PIb,QIb,RIb,CUa,SIb,TIb,UIb,VIb,WIb,XIb,YIb,ZIb,$Ib,aJb,bJb,cJb,dJb,eJb,fJb,dYa,gJb,hJb,iJb,jJb,kJb,lJb,mJb,nJb,oJb,qJb,vPa,rJb,sJb,z_a,JV,tJb,uJb,vJb,wJb,xJb,yJb,zJb,AJb,BJb,CJb,DJb,oO,EJb,FJb,GJb,HJb,IJb,JJb,KJb,LJb,MJb,NJb,OJb,PJb,QJb,KV,RJb,SJb,N4a,SE,E7a,TJb,UJb,VJb,WJb,XJb,YJb,LV,MV,ZJb,$Jb,aKb,bKb,cKb,NV,dKb,
eKb,fKb,gKb,hKb,iKb,yUa,OV,jKb,kKb,lKb,mKb,nKb,$E,oKb,pKb,qKb,rKb,sKb,tKb,y3a,uKb,DRa,pUa,vKb,wKb,xKb,YVa,yKb,zKb,AKb,BKb,CKb,DKb,EKb,FKb,GKb,HKb,PV,QV,IKb,JKb,CQ,KKb,LKb,dF,MKb,NKb,OKb,y5a,PKb,QKb,RKb,SKb,TKb,UKb,VKb,WKb,OUa,XKb,YKb,Z8a,ZKb,oH,RV,$Kb,aLb,SV,bLb,cLb,dLb,eLb,fLb,gLb,hLb,iLb,jLb,vQa,kLb,lLb,mLb,MD,nLb,oLb,pLb,qLb,rLb,sLb,tLb,uLb,vLb,wLb,xLb,yLb,zLb,ALb,BLb,CLb,DLb,ELb,FLb,GLb,HLb,ILb,JLb,KLb,LLb,MLb,NLb,OLb,PLb,QLb,RLb,SLb,TLb,ULb,VLb,WLb,XLb,pQ,TV,YLb,ZLb,$Lb,aMb,bMb,cMb,mZa,dMb,aVa,
eSa,eMb,yVa,fMb,qQ,gMb,hMb,BO,iMb,g5a,jMb,kMb,lMb,mMb,nMb,oMb,pMb,qMb,rMb,sMb,tMb,uMb,vMb,wMb,xMb,yMb,zMb,AMb,UZa,BMb,CMb,DMb,EMb,FMb,GMb,HMb,IMb,JMb,KMb,LMb,MMb,NMb,OMb,PMb,QMb,RMb,zVa,Uxb,UMb,UV,VMb,VV,WMb,XMb,YMb,ZMb,WV,$Mb,aNb,bNb,cNb,jI,dNb,eNb,fNb,gNb,hNb,iNb,jNb,kNb,vCb,nNb,oNb,XV,pNb,qNb,rNb,sNb,tNb,uNb,vNb,wNb,xNb,yNb,zNb,ANb,BNb,CNb,DNb,ENb,FNb,GNb,iK,HNb,INb,JNb,KNb,LNb,MNb,NNb,ONb,PNb,QNb,RNb,SNb,TNb,UNb,VG,VNb,WNb,XNb,YNb,ZNb,$Nb,aOb,bOb,cOb,dOb,eOb,fOb,gOb,hOb,iOb,jOb,kOb,lOb,mOb,ME,
nOb,rUa,qUa,oOb,pOb,qOb,uUa,YV,rOb,ZV,sOb,$V,tOb,uOb,vOb,HD,wOb,aW,bW,xOb,yOb,tRa,zOb,AOb,BOb,COb,DOb,EOb,FOb,GOb,HOb,IOb,JOb,KOb,bab,m8a,LOb,MOb,NOb,OOb,HVa,POb,cW,C4a,QOb,ROb,SOb,uQa,TOb,UOb,VOb,WOb,XOb,STa,dW,YOb,ZOb,eW,$Ob,aPb,bPb,cPb,M2a,dPb,ePb,fPb,gPb,hPb,iPb,jPb,kPb,KGb,mPb,nPb,k7a,oPb,pPb,yIb,x3a,rPb,sPb,tPb,uPb,vPb,wPb,fW,xPb,yPb,zPb,APb,gW,hW,BPb,CPb,DPb,EPb,v3a,FPb,GPb,HPb,IPb,JPb,KPb,LPb,MPb,NPb,OPb,PPb,QPb,RPb,SPb,TPb,UPb,VPb,jZa,WPb,FJ,XPb,iW,YPb,ZPb,$Pb,aQb,bQb,cQb,dQb,eQb,fQb,gQb,
hQb,jW,iQb,jQb,kQb,lQb,mQb,nQb,oQb,pQb,qQb,rQb,SMb,tQb,uQb,vQb,wQb,xQb,kW,yQb,zQb,AQb,BQb,CQb,DQb,lNb,FQb,GQb,mPa,lW,z7a,mW,HQb,IQb,KD,JQb,KQb,LQb,MQb,hN,tOa,NQb,OQb,PQb,QQb,RQb,SQb,TQb,UQb,VQb,WQb,XQb,YQb,j8a,AK,ZQb,VTa,$Qb,aRb,bRb,CVa,DJ,zJ,cRb,dRb,eRb,fRb,EE,gRb,hRb,iRb,jRb,kRb,lRb,mRb,qZa,nRb,oRb,pRb,qRb,rRb,sRb,tRb,lPb,zQa,vRb,nE,ERa,wRb,xRb,zRb,ARb,BRb,CRb,DRb,ERb,oW,FRb,GRb,HRb,IRb,JRb,KRb,LRb,MRb,u4a,pW,NRb,ORb,PRb,QRb,RRb,SRb,qW,TRb,URb,VRb,WRb,rW,XRb,YRb,R9a,rQa,sW,ZRb,$Rb,aSb,bSb,cSb,dSb,
eSb,fSb,gSb,tW,hSb,iSb,jSb,kSb,lSb,mSb,nSb,oSb,pSb,uH,qSb,rSb,uW,vW,sSb,tSb,uSb,wW,xW,vSb,wSb,xSb,ySb,zSb,ASb,yW,BSb,CSb,DSb,ESb,zW,FSb,GSb,HSb,ISb,JSb,KSb,qPb,MSb,NSb,OSb,PSb,QSb,RSb,AW,BW,CW,DW,SSb,TSb,j3a,USb,sE,VSb,WSb,XSb,YSb,ZSb,nH,$Sb,aTb,bTb,cTb,dTb,HOa,eTb,sQb,EW,gTb,hTb,iTb,jTb,kE,FW,kTb,MVa,lTb,mTb,nTb,GW,RYa,oTb,pTb,qTb,rTb,GG,HW,IW,JW,sTb,tTb,uTb,vTb,KW,wTb,g7a,xTb,yTb,zTb,ATb,$Ra,fQ,BTb,CTb,DTb,ETb,FTb,GTb,HTb,ITb,JTb,KTb,LTb,MTb,UOa,NTb,fI,OTb,PTb,xP,cN,dN,W7a,QTb,RTb,STb,TTb,UTb,VTb,
WTb,XTb,YTb,ZTb,PYa,$Tb,aUb,bUb,cUb,dUb,eUb,PW,fUb,QW,gUb,hUb,iUb,jUb,kUb,lUb,RW,mUb,nUb,oUb,pUb,qUb,rUb,sUb,eYa,tUb,uUb,SW,vUb,wUb,xUb,yUb,zUb,AUb,HWa,BUb,CUb,DUb,EUb,FUb,UQa,GUb,HUb,IUb,JUb,KUb,LUb,MUb,NUb,OUb,PUb,QUb,qQa,EQb,SUb,TUb,UUb,VUb,YL,WUb,XUb,YUb,ZUb,$Ub,aVb,bVb,cVb,dVb,eVb,fVb,gVb,hVb,iVb,jVb,uRb,lVb,mVb,UW,nVb,oVb,pVb,qVb,rVb,sVb,jPa,tVb,$Va,uVb,LSb,cZa,wVb,xVb,dZa,eZa,fZa,gZa,yVb,zVb,VW,AVb,BVb,fTb,WW,DVb,XW,EVb,FVb,GVb,HVb,YYa,RUb,ZYa,$Ya,JVb,kVb,LVb,aZa,sOa,MVb,YW,NVb,OVb,PVb,QVb,
RVb,SVb,TVb,vVb,VVb,$W,WVb,XVb,YVb,ZVb,bX,$Vb,aWb,bWb,nOa,cWb,dWb,eWb,fWb,gWb,hWb,iWb,sUa,jWb,kWb,cX,lWb,mWb,nWb,oWb,dX,pWb,qWb,rWb,sWb,tWb,PE,uWb,vWb,wWb,xWb,yWb,zWb,eX,AWb,fX,BWb,CWb,DWb,CVb,FWb,GWb,HWb,IWb,jF,JWb,IVb,KVb,UVb,s3a,NWb,OWb,PWb,QWb,EWb,SWb,KWb,UWb,oE,VWb,WWb,XWb,YWb,ZWb,$Wb,aXb,LWb,cXb,iUa,dXb,eXb,fXb,bP,gXb,hXb,iXb,jXb,kXb,lXb,gX,c7a,nRa,mXb,nXb,oXb,pXb,qXb,rXb,sXb,tXb,uXb,vXb,wXb,xXb,yXb,zXb,AXb,BXb,CXb,DXb,EXb,FXb,GXb,HXb,IXb,JXb,KXb,LXb,MXb,NXb,OXb,PXb,QXb,RXb,SXb,rH,TXb,oK,UXb,
hX,VXb,WXb,XXb,YXb,ZXb,jX,$Xb,aYb,bYb,cYb,dYb,eYb,fYb,kX,gYb,hYb,iYb,jYb,kYb,lYb,mYb,nYb,oYb,pYb,qYb,rYb,lX,sYb,tYb,uYb,wYb,xYb,mX,yYb,zYb,AYb,rVa,BYb,CYb,DYb,EYb,nX,oX,FYb,GYb,HYb,IYb,V4a,JYb,pX,KYb,LYb,MYb,NYb,OYb,PYb,QYb,RYb,SYb,wPa,TYb,UYb,VYb,WYb,XYb,BM,YYb,ZYb,qX,$Yb,NE,aZb,bZb,RVa,cZb,dZb,eZb,fZb,gZb,hZb,iZb,DG,jZb,kZb,lZb,mZb,nZb,rX,oZb,K4a,sX,pZb,qZb,tX,rZb,sZb,tZb,uZb,uX,vX,vZb,wZb,xZb,yZb,mQ,zZb,wX,AZb,BZb,eQa,CZb,DZb,EZb,FZb,GZb,HZb,IZb,JZb,KZb,LZb,MZb,NZb,xX,OZb,PZb,KQa,QZb,RZb,SZb,TZb,
UZb,VZb,WZb,WTa,XZb,YZb,ZZb,$Zb,a_b,RRa,mYa,b_b,c_b,d_b,e_b,f_b,g_b,yX,h_b,zX,i_b,j_b,xVa,k_b,l_b,QOa,m_b,aPa,n_b,o_b,YPa,AX,p_b,q_b,r_b,s_b,t_b,u_b,v_b,w_b,UTa,x_b,y_b,z_b,A_b,B_b,sSa,C_b,zUa,D_b,E_b,F_b,G_b,H_b,I_b,J_b,K_b,L_b,M_b,N_b,O_b,P_b,Q_b,R_b,S_b,T_b,U_b,V_b,W_b,X_b,Y_b,Z_b,$_b,a0b,b0b,c0b,d0b,e0b,f0b,b7a,g0b,h0b,i0b,j0b,k0b,l0b,m0b,n0b,o0b,p0b,q0b,r0b,s0b,t0b,u0b,v0b,w0b,x0b,y0b,z0b,A0b,MM,sH,B0b,C0b,D0b,E0b,DX,F0b,G0b,P4a,H0b,BE,I0b,J0b,K0b,L0b,M0b,EX,N0b,FX,BOa,JWa,O0b,P0b,rRa,Q0b,R0b,
S0b,SRa,T0b,U0b,V0b,W0b,GX,X0b,Y0b,Z0b,$0b,a1b,b1b,c1b,d1b,e1b,f1b,g1b,h1b,i1b,j1b,k1b,WPa,l1b,m3a,m1b,HX,n1b,o1b,p1b,IX,q1b,r1b,s1b,t1b,u1b,v1b,w1b,x1b,KX,LX,MX,y1b,z1b,A1b,B1b,C1b,D1b,NX,E1b,F1b,G1b,H1b,OX,I1b,PX,J1b,K1b,L1b,M1b,N1b,TPa,O1b,P1b,Q1b,R1b,S1b,QX,T1b,U1b,V1b,W1b,X1b,Y1b,Z1b,$1b,MUa,pQa,a2b,b2b,c2b,d2b,e2b,f2b,RX,g2b,h2b,i2b,j2b,k2b,l2b,m2b,n2b,o2b,p2b,q2b,r2b,s2b,t2b,lK,u2b,v2b,w2b,x2b,y2b,z2b,A2b,SX,B2b,C2b,D2b,E2b,tSa,F2b,G2b,H2b,DE,I2b,J2b,K2b,L2b,M2b,vUa,N2b,O2b,P2b,Q2b,R2b,S2b,
T2b,U2b,V2b,TX,aR,W2b,LM,wOa,X2b,Y2b,Z2b,$2b,MWb,b3b,MP,c3b,d3b,e3b,f3b,g3b,h3b,i3b,j3b,k3b,l3b,m3b,n3b,o3b,p3b,q3b,r3b,s3b,t3b,u3b,UX,v3b,w3b,x3b,y3b,z3b,A3b,TZa,B3b,C3b,D3b,E3b,gF,F3b,G3b,H3b,I3b,K3b,PG,B5a,L3b,M3b,N3b,O3b,P3b,q5a,Q3b,S3b,T3b,U3b,V3b,WX,W3b,X3b,Y3b,jE,Z3b,$3b,wK,a4b,b4b,c4b,d4b,e4b,XX,f4b,g4b,h4b,i4b,YX,j4b,ZX,n3a,k4b,$X,l4b,oQ,m4b,n4b,o4b,p4b,q4b,r4b,aY,s4b,t4b,u4b,v4b,w4b,x4b,y4b,z4b,A4b,bY,B4b,kH,C4b,QQa,GO,D4b,E4b,F4b,G4b,H4b,I4b,J4b,K4b,L4b,M4b,N4b,O4b,lOa,P4b,cY,ZQa,Q4b,R4b,
S4b,T4b,dY,U4b,V4b,W4b,X4b,Y4b,VE,Z4b,$4b,a5b,b5b,c5b,d5b,qK,e5b,eY,f5b,fY,g5b,gY,RWb,JE,i5b,j5b,k5b,l5b,m5b,n5b,o5b,p5b,q5b,Iab,gK,r5b,U4a,s5b,t5b,y4a,u5b,hY,v5b,w5b,x5b,iY,y5b,OOa,z5b,ZVa,A5b,B5b,C5b,D5b,lPa,E5b,F5b,jY,G5b,H5b,I5b,J5b,K5b,L5b,WE,M5b,N5b,O5b,P5b,Q5b,R5b,S5b,T5b,$J,YJ,TWb,V5b,W5b,X5b,Y5b,TYa,Z5b,SYa,$5b,a6b,kY,b6b,M8a,c6b,d6b,e6b,f6b,g6b,h6b,i6b,j6b,lY,k6b,l6b,m6b,n6b,o6b,p6b,q6b,bRa,r6b,s6b,t6b,t5a,u6b,v6b,w6b,x6b,y6b,z6b,A6b,B6b,C6b,D6b,E6b,F6b,G6b,H6b,I6b,tQa,J6b,K6b,L6b,M6b,N6b,
O6b,P6b,w0a,Q6b,R6b,S6b,T6b,U6b,V6b,W6b,X6b,f7a,Y6b,Z6b,$6b,a7b,b7b,mY,c7b,d7b,e7b,f7b,nY,g7b,oY,LJ,h7b,KJ,IJ,i7b,j7b,pY,k7b,l7b,m7b,n7b,o7b,p7b,q7b,zPa,qY,r7b,s7b,t7b,u7b,v7b,b9a,w7b,x7b,y7b,z7b,A7b,B7b,C7b,D7b,rY,E7b,F7b,G7b,H7b,I7b,bXb,Q5a,K7b,L7b,M7b,x7a,sY,N7b,O7b,P7b,Q7b,R7b,S7b,T7b,U7b,V7b,yQa,W7b,X7b,Y7b,Z7b,$7b,a8b,b8b,tY,c8b,e8b,f8b,uY,g8b,h8b,i8b,vY,j8b,P7a,k8b,l8b,m8b,n8b,a3b,p8b,q8b,r8b,s8b,t8b,u8b,v8b,w8b,x8b,y8b,z8b,xY,A8b,h5b,C8b,D8b,E8b,F8b,G8b,H8b,I8b,J8b,K8b,U5b,M8b,yY,N8b,O8b,
P8b,fF,J7b,R8b,S8b,xPa,T8b,dSa,U8b,TVa,V8b,$Qa,kVa,W8b,X8b,Y8b,Z8b,$8b,nVa,RN,LRa,a9b,b9b,o8b,y2a,d9b,uG,e9b,SVa,f9b,g9b,h9b,i9b,j9b,k9b,l9b,m9b,n9b,o9b,p9b,q9b,r9b,s9b,t9b,u9b,v9b,w9b,x9b,y9b,z9b,A9b,B9b,C9b,D9b,E9b,F9b,G9b,H9b,I9b,J9b,K9b,L9b,zY,M9b,N9b,O9b,P9b,TRa,Q9b,R9b,S9b,T9b,U9b,V9b,W9b,X9b,Y9b,Z9b,$9b,a$b,b$b,c$b,d$b,e$b,BY,f$b,g$b,CY,h$b,i$b,j$b,qSa,k$b,DY,bF,l$b,m$b,n$b,o$b,p$b,q$b,r$b,s$b,t$b,K3a,u$b,v$b,wJ,aF,w$b,x$b,y$b,EY,FY,z$b,A$b,B$b,C$b,D$b,E$b,GY,nQ,F$b,wH,XJ,dK,ZJ,G$b,H$b,I$b,
aK,J$b,K$b,L$b,M$b,N$b,O$b,P$b,Q$b,R$b,S$b,T$b,U$b,V$b,W$b,X$b,Y$b,Z$b,$$b,aac,bac,cac,dac,eac,fac,gac,hac,iac,jac,kac,IY,lac,mac,nac,oac,pac,qac,rac,sac,tac,uac,rM,vac,wac,xac,yac,SJ,zac,Aac,Bac,Cac,Dac,Eac,mQa,Fac,Gac,Hac,Iac,Jac,Kac,Mac,R7a,Nac,Oac,Pac,Qac,Rac,Sac,Tac,Uac,Vac,Wac,Xac,Yac,B8b,$ac,abc,JY,bbc,cbc,dbc,ebc,fbc,gbc,hbc,ibc,jbc,kbc,lbc,mbc,nbc,obc,pbc,qbc,rbc,sbc,tbc,ubc,vbc,wbc,xbc,r3a,ybc,L8b,Abc,Bbc,Cbc,Dbc,Ebc,Fbc,Gbc,KY,Hbc,OVa,Ibc,Jbc,Kbc,Lbc,Mbc,Nbc,Obc,Pbc,Qbc,Rbc,Sbc,Tbc,Ubc,
Vbc,Wbc,Xbc,Ybc,Zbc,$$a,$bc,I5a,acc,bcc,nSa,ccc,dcc,ecc,fcc,gcc,hcc,icc,jcc,kcc,lcc,mcc,wP,ncc,occ,pcc,qcc,EG,rcc,scc,tcc,ucc,vcc,wcc,xcc,ycc,zcc,Acc,Bcc,LY,Ccc,Dcc,Ecc,Fcc,Gcc,Hcc,tUa,Icc,Jcc,Kcc,Lcc,MY,Mcc,Ncc,Occ,Pcc,GVa,Qcc,b_a,Hab,Rcc,Scc,Tcc,Ucc,Vcc,Wcc,X_a,Q8b,Ycc,Zcc,GD,BR,NY,WG,adc,bdc,cdc,ddc,edc,YTa,fdc,gdc,c9b,Y4a,$P,q7a,idc,jdc,D7a,kdc,ldc,Zac,ndc,odc,pdc,qdc,i$a,zbc,O9a,tdc,udc,vdc,wdc,xdc,FG,ydc,zdc,Adc,Bdc,Xcc,hdc,NM,Edc,Fdc,Gdc,Hdc,Idc,Jdc,Kdc,Ldc,Mdc,ZTa,Ndc,Odc,Pdc,Qdc,U6a,Rdc,
OY,Sdc,Tdc,Udc,KE,Vdc,Wdc,Xdc,PY,Ydc,Zdc,$dc,aec,bec,cec,dec,eec,fec,gec,hec,iec,jec,QY,kec,O6a,lec,mec,nec,oec,pec,RY,qec,rec,sec,tec,uec,vec,wec,xec,yec,zec,Aec,Bec,Cec,Dec,SY,Eec,Fec,ND;nD=function(a,b){a=String(a);let c=a.indexOf(".");-1===c&&(c=a.length);const d="-"===a[0]?"-":"";d&&(a=a.substring(1));return d+(0,$APP.Hs)("0",Math.max(0,b-c))+a};UNa=function(a,b){return function(){return $APP.Na(a,b)}};
VNa=function(a){a:{a=$APP.hi($APP.m.j(a)).split(".");for(var b=$APP.ia;;){if(null==b){a=null;break a}if(null==a){a=b;break a}b=$APP.Na(b,$APP.u(a));a=$APP.w(a)}}return a};oD=function(a,b){this.xe=a;this.name=b;this.O=6291456;this.U=0};pD=function(a,b){var c=$APP.hi($APP.m.j(b)),d=a.xe;return null!==d&&c in d?(b=$APP.Zg.A($APP.m.j(a.name),$APP.m.j(b)),new $APP.Ac(UNa(a.xe,c),b,new $APP.f(null,1,[$APP.wl,a],null))):null};
qD=function(a,b){return a===b?!0:a instanceof $APP.q&&b instanceof $APP.q?a.str===b.str:!1};XNa=function(){return $APP.Fj.B(WNa,$APP.Vl,function(a){return $APP.kh.j($APP.Fb(a))})};sD=function(a){null==rD&&(rD=$APP.kh.j($APP.F));var b=$APP.m.j(a);a=$APP.La(b,"$macros")?a:$APP.Zg.j([b,"$macros"].join(""));b=$APP.C.A($APP.Fb(rD),a);if(null!=b)return b;b=VNa(a);if(null==b)return null;b=new oD(b,a);$APP.lh.M(rD,$APP.rg,a,b);return b};
ZNa=function(){var a=YNa,b=VNa(a),c=new oD(b,a);return $APP.Id.B(function(d,g){var l=$APP.Zg.j($APP.Dda(g));return $APP.rg.B(d,l,new $APP.Ac(function(){return $APP.Na(b,g)},$APP.Zg.A($APP.m.j(a),$APP.m.j(l)),new $APP.f(null,1,[$APP.wl,c],null)))},$APP.F,$APP.Ma(b))};tD=function(a){return $APP.Lf.A($APP.vg,$APP.ng(a))};uD=function(a,b){return $APP.Jd(function(c,d,g){return $APP.rg.B(c,d,a.j?a.j(g):a.call(null,g))},$APP.ad(b),b)};vD=function(a,b){return a.test(b)};wD=function(a){return BigInt(a)};
$Na=function(a){return $APP.Uc.A("bigint",$APP.la(a))};aOa=function(a){return $APP.Ca(a)};bOa=function(a){return $APP.xa(a)};xD=function(a){return"number"===typeof a?a:Number(a)};yD=function(a){throw Error(a);};zD=function(){return $APP.m.j($APP.Gh())};AD=function(a){throw Error(a);};BD=function(a){throw Error(a);};CD=function(a){throw Error(a);};cOa=function(a){throw Error(a);};dOa=function(a){throw Error(a);};eOa=function(a){return Number.parseInt(a)};fOa=function(a){return Number.parseFloat(a)};
DD=function(a){return null!=a?a.O&4096||$APP.xc===a.Th?!0:!1:!1};
gOa=function(a,b){return $APP.Id.B(function(c,d){if(d instanceof $APP.q||d instanceof $APP.E)var g=new $APP.f(null,1,[ED,d],null);else{var l=$APP.r(d);g=$APP.u(l);l=$APP.w(l);var n=$APP.Jg($APP.Ke(new $APP.ug(null,new $APP.f(null,1,[$APP.dk,null],null),null)),l);l=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);var p=$APP.r(n);$APP.u(p);var v=$APP.w(p);p=$APP.u(v);v=$APP.w(v);$APP.r(n)?(d=$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[g],null),$APP.N.A(l,v)),g=new $APP.f(null,1,[$APP.dk,$APP.pe([p,g])],null),g=1<
$APP.Tc(d)?$APP.rg.B(g,ED,d):g):g=new $APP.f(null,1,[ED,d],null)}d=$APP.qe(g);g=$APP.C.A(d,$APP.dk);d=$APP.C.A(d,ED);a:for(FD.j(c),l=$APP.r(g),n=null,v=p=0;;)if(v<p){var t=n.aa(null,v);$APP.x.B(t,0,null);$APP.x.B(t,1,null);v+=1}else if(l=$APP.r(l))n=l,$APP.pd(n)?(l=$APP.lc(n),v=$APP.mc(n),n=l,p=$APP.Tc(l),l=v):(l=$APP.u(n),$APP.x.B(l,0,null),$APP.x.B(l,1,null),l=$APP.w(n),n=null,p=0),v=0;else break a;c=$APP.k(d)?$APP.Fj.M(c,GD,$APP.Vd,d):c;return $APP.k(g)?$APP.Fj.M(c,FD,$APP.Ni,g):c},new $APP.f(null,
2,[FD,b,GD,$APP.sf],null),a)};hOa=function(a){return $APP.Id.B(function(b,c){b=$APP.qe(b);var d=$APP.C.A(b,FD),g=$APP.r(c);c=$APP.u(g);g=$APP.w(g);if($APP.Uc.A(HD,c))return $APP.Fj.M(b,GD,$APP.Vd,$APP.Kn.A(c,g));d=gOa(g,d);g=$APP.qe(d);d=$APP.C.A(g,FD);g=$APP.C.A(g,GD);b=$APP.hd(d)?b:$APP.Fj.M(b,FD,$APP.Ni,d);return $APP.hd(g)?b:$APP.Fj.M(b,GD,$APP.Vd,$APP.Kn.A(c,g))},new $APP.f(null,2,[FD,$APP.F,GD,$APP.sf],null),a)};
iOa=function(a,b,c){return $APP.Id.B(function(d,g){var l=$APP.Vl.j(d);return g.B?g.B(l,d,c):g.call(null,l,d,c)},a,b)};ID=function(a,b,c){return $APP.Id.B(function(d,g){return $APP.rg.B(d,g,function(){var l=$APP.C.A(d,g);return $APP.od(l)?$APP.Lf.B($APP.sf,$APP.Vg.j(function(n){return ID(n,b,c)}),l):ID(l,b,c)}())},null==a?null:iOa(a,b,c),JD.j(a))};
kOa=function(a){a=$APP.qe(a);var b=$APP.C.A(a,$APP.$x);var c=$APP.Bd(jOa,$APP.$x.j(a));c?(c=$APP.sj.j(a),$APP.k(c)?a=c:(c=new $APP.ug(null,new $APP.f(null,2,[$APP.Ek,null,$APP.zl,null],null),null),b=c.j?c.j(b):c.call(null,b),a=$APP.k(b)?$APP.sj.j($APP.Wu.j(a)):null),b=new $APP.ug(null,new $APP.f(null,2,[$APP.Xx,"null",$APP.wv,"null"],null),null),a=b.j?b.j(a):b.call(null,a)):a=c;return $APP.vd(a)};
mOa=function(a){return $APP.Uc.A($APP.Hu,$APP.$x.j(a))&&$APP.Uc.A(1,$APP.Tc($APP.Tl.j(a)))&&$APP.Uc.A($APP.sf,KD.j($APP.em.j(a)))&&kOa(LD.j($APP.u($APP.Tl.j(a))))&&$APP.Uc.A(lOa,$APP.$x.j(MD.j($APP.em.j(a))))};oOa=function(a,b){return $APP.Fj.B(a,nOa,function(c){return $APP.Vg.A(function(d){return $APP.Fj.B(d,$APP.dm,function(g){return $APP.sn.A(function(l){return $APP.Uc.A(b,$APP.R.j(l))},g)})},c)})};
pOa=function(a){return function(b,c){b=$APP.Li.M(c,new $APP.H(null,2,5,$APP.I,[$APP.Vl,ND],null),$APP.Oi,a);return $APP.Uc.A($APP.Fk,$APP.$x.j(c))?oOa(b,a):b}};PD=function(){return $APP.C.A($APP.Fb(null),$APP.OD)};RD=function(a,b,c){a=$APP.C.B(a,b,QD);return a===QD?null:$APP.C.A(a,c)};SD=function(a,b,c,d){a=$APP.C.B(a,b,QD);if(a===QD)return null;c=$APP.C.B(a,c,QD);return c===QD?null:$APP.C.A(c,d)};
UD=function(a,b,c,d){a=$APP.C.B(a,TD,QD);if(a===QD)return null;b=$APP.C.B(a,b,QD);if(b===QD)return null;c=$APP.C.B(b,c,QD);return c===QD?null:$APP.C.A(c,d)};VD=function(a,b){return[$APP.ki($APP.hi($APP.m.j(a)),".","/"),".",$APP.Ag(b)].join("")};
qOa=function(a){if(a instanceof $APP.E)var b="cst$kw$";else{if(!(a instanceof $APP.q))throw Error(["constant type ",$APP.m.j($APP.hb(a))," not supported"].join(""));b="cst$sym$"}a=a instanceof $APP.E?$APP.Og.A($APP.m.j(a),1):$APP.m.j(a);a=$APP.Uc.A(".",a)?"_DOT_":$APP.ki($APP.ki($APP.hi($APP.ki(a,"-","_DASH_")),".","$"),/[^a-z0-9$_]/i,function(c){c=c.charCodeAt(0).toString(16);var d=c.length;if(4>d){var g=$APP.m,l=g.j;a:{var n="0";for(d=4-d;;)if(0<d)n=[$APP.m.j(n),$APP.m.j("0")].join(""),--d;else break a}c=
[l.call(g,n),$APP.m.j(c)].join("")}return["_u",$APP.m.j(c),"_"].join("")});return $APP.Zg.j([b,a].join(""))};
uOa=function(a,b){$APP.lh.A(null,function(c){c=$APP.Li.B(c,new $APP.H(null,1,5,$APP.I,[rOa],null),function(d){return $APP.k($APP.C.A(d,b))?d:$APP.rg.B(d,b,qOa(b))});return $APP.k(a)?$APP.Li.B(c,new $APP.H(null,3,5,$APP.I,[TD,$APP.R.j($APP.wl.j(a)),sOa],null),function(d){d=$APP.qe(d);var g=$APP.C.B(d,tOa,$APP.vg),l=$APP.C.B(d,$APP.WD,$APP.sf);return $APP.Bd(g,b)?d:$APP.rg.C(d,tOa,$APP.Vd.A(g,b),$APP.y([$APP.WD,$APP.Vd.A(l,b)]))}):c})};XD=function(a,b){a=$APP.Xi.j($APP.ed(a));return $APP.k(a)?a:$APP.Xi.j(b)};
YD=function(a,b){a=$APP.zj.j($APP.ed(a));return $APP.k(a)?a:$APP.zj.j(b)};vOa=function(a){return $APP.k($APP.Xi.j(a))?ZD(null,a):null};ZD=function(a,b){a=new $APP.f(null,3,[$APP.Wi,$APP.Uc.A($APP.R.j($APP.wl.j(b)),$APP.yn)?"cljs/core.cljs":null,$APP.Xi,XD(a,b),$APP.zj,YD(a,b)],null);return $APP.k(wOa.j(b))?$APP.Ni.C($APP.y([a,$APP.sg(b,new $APP.H(null,1,5,$APP.I,[wOa],null))])):a};
xOa=function(a,b){return[$APP.m.j(b),$APP.k($APP.Xi.j(a))?[" at line ",$APP.m.j($APP.Xi.j(a))," ",$APP.m.j(null)].join(""):$APP.k(null)?[" in file ",$APP.m.j(null)].join(""):null].join("")};$D=function(a,b,c){for(var d=$APP.r(yOa),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n);p.B?p.B(a,b,c):p.call(null,a,b,c);n+=1}else if(d=$APP.r(d))g=d,$APP.pd(g)?(d=$APP.lc(g),l=$APP.mc(g),g=d,p=$APP.Tc(d),d=l,l=p):(p=$APP.u(g),p.B?p.B(a,b,c):p.call(null,a,b,c),d=$APP.w(g),g=null,l=0),n=0;else return null};
zOa=function(a){return function(b,c,d){return $APP.k(b.j?b.j(aE):b.call(null,aE))?$APP.lh.B(a,$APP.Vd,new $APP.H(null,3,5,$APP.I,[b,c,d],null)):null}};AOa=function(a){$APP.gh(function(b){return $APP.Je.A($D,b)},$APP.Fb(a))};
bE=function(a,b,c){var d=$APP.Ni.C;a=vOa(a);var g=$APP.qe(a);a=$APP.C.A(g,$APP.Wi);var l=$APP.C.A(g,$APP.Xi);g=$APP.C.A(g,$APP.zj);return d.call($APP.Ni,$APP.y([new $APP.f(null,3,[BOa,a,COa,l,DOa,g],null),new $APP.f(null,1,[EOa,b],null),$APP.k(c)?new $APP.f(null,1,[FOa,c],null):null]))};cE=function(a,b){return GOa(a,b,null)};GOa=function(a,b,c){return $APP.Zi.B(xOa(a,b),$APP.rg.B(vOa(a),$APP.sj,HOa),c)};IOa=function(a){return $APP.Uc.A(HOa,$APP.sj.j($APP.Ih(a)))};
LOa=function(){return function(a,b,c){var d=$APP.Zg.A($APP.m.j(b),$APP.m.j(c));d=dE.A?dE.A(d,a):dE.call(null,d,a);return $D(JOa,a,new $APP.f(null,3,[$APP.Av,b,$APP.pq,c,KOa,null!=d],null))}};MOa=function(a){var b=$APP.Lg(/(.*)\$(.*)/,$APP.m.j(a));return $APP.k(b)?$APP.Se.A(1,b):new $APP.H(null,2,5,$APP.I,[a,null],null)};eE=function(a){return NOa($APP.Zl.A($APP.Fb(null),new $APP.H(null,1,5,$APP.I,[OOa],null)),a)};
POa=function(a){try{var b;if(b=$APP.Uc.A("default","nodejs")){var c=require.resolve($APP.m.j(a));var d=$APP.k(c)?c:require.resolve($APP.u(MOa(a)));b=$APP.vd(d)}return b}catch(g){return!1}};SOa=function(a){var b=MOa(a);a=$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.Zl.A($APP.Fb(null),new $APP.H(null,3,5,$APP.I,[QOa,$APP.m.j(a),ROa],null));return $APP.Bd(b,$APP.Zg.j(a))||$APP.Bd(b,$APP.Ag(a))};
WOa=function(a){a=MOa(a);var b=$APP.x.B(a,0,null);$APP.x.B(a,1,null);a=$APP.m.j(b);b=PD();b=TOa.j(b);$APP.k(b)&&(b=new $APP.ug(null,new $APP.f(null,2,["goog.array",null,"goog.object",null],null),null),b=b.j?b.j(a):b.call(null,a));return $APP.k(b)?!1:$APP.Uc.A(UOa,$APP.Zl.A($APP.Fb(null),new $APP.H(null,3,5,$APP.I,[QOa,a,VOa],null)))};XOa=function(){return function(a,b,c){return fE.M(a,b,c,function(d,g,l){throw cE(d,["Unable to resolve var: ",$APP.m.j(l)," in this context"].join(""));})}};
gE=function(a,b){return YOa(a,b,$APP.Zg.j(b))};YOa=function(a,b,c){b=$APP.Zg.j(b);return $APP.C.B($APP.ak.j($APP.wl.j(a)),b,c)};ZOa=function(a,b,c){b=$APP.Zg.j(b);return $APP.C.B($APP.tn.j($APP.wl.j(a)),b,c)};dPa=function(a,b){$APP.qg.A($APP.yn,b)&&null==$APP.C.A($Oa,b)&&null==$APP.C.A($APP.ak.j($APP.wl.j(a)),b)&&null==RD($APP.Fb(null),TD,b)&&$APP.eb(eE(b))&&$D(aPa,a,new $APP.f(null,2,[bPa,b,cPa,b],null))};
fPa=function(a,b){var c=function(){var d=null!=UD($APP.Fb(null),$APP.yn,jE,b);if(d)return d;d=dE.A?dE.A(b,a):dE.call(null,b,a);if(null==d)return!1;d=$APP.wl.j($APP.ed(d));return $APP.Uc.A(d.getName(),ePa)}();return c?!$APP.Bd(kE.j($APP.wl.j(a)),b):c};gPa=function(a,b){var c=function(){var d=UD($APP.Fb(null),a,jE,b);return $APP.k(d)?d:UD($APP.Fb(null),$APP.Zg.j([$APP.Ag(a),"$macros"].join("")),jE,b)}();return null!=c&&$APP.eb(function(){var d=$APP.Lo.j(c);return $APP.k(d)?d:lE.j(c)}())};
mE=function(a){return a instanceof $APP.q&&($APP.Uc.A($APP.Zw,a)||$APP.Uc.A("js",$APP.ae(a)))};hPa=function(a){return a instanceof $APP.q?a:$APP.hd(a)?null:1===$APP.Tc(a)?$APP.u(a):$APP.Bd(a,$APP.gy)?$APP.gy:$APP.Bd(a,$APP.Xx)?(a=$APP.ym.A(a,nE),1===$APP.Tc(a)?$APP.Xx:a):a};
kPa=function(a,b,c){for(;;){if($APP.hd(a))return!0;var d=$APP.u(a);b=$APP.Dd(b,d);if($APP.eb(b))return!1;d=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);d=$APP.ed(d);var g=$APP.Uc.A(iPa,$APP.sj.j(d));d=g?jPa.j(d):g;if($APP.k(d))return d=kPa($APP.Lf.A(new $APP.H(null,1,5,$APP.I,[oE],null),$APP.w(a)),b,c),$APP.k(d)?d:kPa($APP.w(a),b,c);a=$APP.w(a)}};
pE=function(a){var b=lPa.j($APP.Fb(null));var c=$APP.Dd($APP.Zl.A(b,new $APP.H(null,2,5,$APP.I,[mPa,oE],null)),$APP.u(a));null==c?c=a:(c=$APP.sj.j($APP.ed($APP.u(c))),c=null==c?a:$APP.Lf.A(new $APP.H(null,2,5,$APP.I,[c,oE],null),$APP.w(a)));c=kPa(c,b,b);if($APP.k(c))return c;if($APP.Uc.A(1,$APP.Tc(a))){c=$APP.u(a);var d=$APP.Zl.A(b,$APP.Vd.A(new $APP.H(null,2,5,$APP.I,[mPa,oE],null),c));b=$APP.k(d)?d:$APP.Zl.A(b,$APP.Vd.A(new $APP.H(null,1,5,$APP.I,[nPa],null),c))}else b=null;return $APP.k(b)?b:$APP.ri($APP.m.j($APP.$c(a)),
"cljs$")};pPa=function(a,b){var c=lPa.j($APP.Fb(null));return oPa(a,b,c,c)};oPa=function(a,b,c,d){c=$APP.Dd(c,$APP.u(a));if($APP.k(c)){var g=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);g=$APP.ed(g);g=b.j?b.j(g):b.call(null,g);if($APP.Uc.A($APP.Tc(a),1))return $APP.k(g)?$APP.Zg.A("js",$APP.m.j(qPa.A?qPa.A(g,g):qPa.call(null,g,g))):null;c=oPa($APP.w(a),b,c,d);return $APP.k(c)?c:oPa($APP.Lf.A(new $APP.H(null,1,5,$APP.I,[oE],null),$APP.w(a)),b,$APP.C.A(d,g),d)}return null};
rPa=function(a){a=$APP.m.j(a);return $APP.La(a,".")&&!$APP.La(a,"..")};sPa=function(a){return["node$module$",$APP.m.j($APP.hi($APP.ki($APP.m.j(a),/[.\\/]/,"$$")))].join("")};tPa=function(a){return["goog$module$",$APP.m.j($APP.hi($APP.ki($APP.m.j(a),/[.\\/]/,"$$")))].join("")};uPa=function(a){return["global$module$",$APP.m.j($APP.hi($APP.ki($APP.m.j(a),/[.\\/]/,"$$")))].join("")};
BPa=function(a){var b;if(b=$APP.Uc.A($APP.yn,$APP.yn))b=new $APP.ug(null,new $APP.f(null,2,[$APP.Wx,"null",$APP.Vu,"null"],null),null),b=b.j?b.j(a):b.call(null,a),b=$APP.k(b)?$APP.qg.A(vPa,wPa.j(PD()))?!1:null:b;return $APP.k(b)?$APP.Zl.A(new $APP.f(null,2,[$APP.hw,new $APP.f(null,2,[$APP.Wx,xPa,$APP.Vu,yPa],null),$APP.ew,new $APP.f(null,2,[$APP.Wx,zPa,$APP.Vu,APa],null)],null),new $APP.H(null,2,5,$APP.I,[$APP.qg.A(vPa,wPa.j(PD()))?!1:null,a],null)):a};
FPa=function(a){return WOa(a)?CPa:$APP.k(eE(a))?$APP.qE:POa(a)?DPa:SOa(a)?EPa:null};HPa=function(a,b){a=$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[$APP.Gx],null),$APP.tf($APP.Vg.A($APP.Zg,$APP.qi.A($APP.Ag(a),/\./))));$APP.k(pE(a))||$APP.lh.C(null,$APP.Li,$APP.Lf.A(new $APP.H(null,3,5,$APP.I,[TD,b,GPa],null),a),$APP.Ni,$APP.y([$APP.F]));return a};
IPa=function(a,b){a=gE(b,a);return(b=$APP.Bd($APP.yg($APP.pg(RD(b,$APP.wl,$APP.ak))),a)||$APP.Bd($APP.yg($APP.pg(RD(b,$APP.wl,rE))),a))?(b=eE(a),$APP.k(b)?b:POa(a)||SOa(a)):b};
JPa=function(a,b,c){a=gE(c,a);var d=FPa(a);d=d instanceof $APP.E?d.ga:null;switch(d){case "js":return b=$APP.Zg.j,d=SD($APP.Fb(null),OOa,a,$APP.R),c=$APP.k(d)?d:gE(c,a),new $APP.f(null,3,[$APP.R,b.call($APP.Zg,c),$APP.$x,sE,$APP.wl,$APP.Zw],null);case "node":return new $APP.f(null,3,[$APP.R,$APP.Zg.A($APP.m.j(b),sPa(gE(c,a))),$APP.$x,sE,$APP.wl,b],null);case "global":return new $APP.f(null,3,[$APP.R,$APP.Zg.A($APP.m.j(b),uPa(gE(c,a))),$APP.$x,sE,$APP.wl,b],null);default:throw Error(["No matching clause: ",
$APP.m.j(d)].join(""));}};tE=function(a,b){return b instanceof $APP.q?new $APP.f(null,1,[$APP.R,a],null):b};vE=function(a,b){return uE(a,b,null,!0)};
uE=function(a,b,c,d){for(;;){var g=ND.j(a);if("js"===$APP.ae(b)){c=$APP.Zg.j($APP.Ag(b));c=tE(c,$APP.C.A(g,c));if(null!=c)return $D(KPa,a,new $APP.f(null,1,[$APP.R,b],null)),$APP.rg.B(c,$APP.$x,$APP.zl);var l=$APP.tf($APP.Vg.A($APP.Zg,$APP.qi.A($APP.Ag(b),/\./)));$APP.eb(pE(l))&&$APP.eb($APP.mw.j($APP.ed(b)))&&$APP.lh.C(null,$APP.Li,$APP.Lf.A(new $APP.H(null,3,5,$APP.I,[TD,$APP.R.j($APP.wl.j(a)),GPa],null),l),$APP.Ni,$APP.y([$APP.F]));return $APP.Ni.C($APP.y([new $APP.f(null,4,[$APP.R,b,$APP.$x,sE,
$APP.wl,$APP.Zw,$APP.sj,$APP.z(function(){var Q=pPa(l,$APP.sj);if($APP.k(Q))return Q;Q=$APP.sj.j($APP.ed(b));return $APP.k(Q)?Q:$APP.Zw}(),new $APP.f(null,1,[$APP.Av,l],null))],null),function(){var Q=pPa(l,wE);return $APP.k(Q)?new $APP.f(null,2,[LPa,!0,wE,Q],null):null}()]))}var n=$APP.m.j(b),p=tE(b,$APP.C.A(g,b)),v=$APP.R.j($APP.wl.j(a));if(null!=p)return $APP.rg.B(p,$APP.$x,$APP.zl);if(null!=$APP.ae(b)){d=$APP.ae(b);var t="clojure.core"===d?"cljs.core":d;d=YOa(a,t,function(){var Q=eE(t);Q=$APP.k(Q)?
SD($APP.Fb(null),OOa,t,$APP.R):Q;return $APP.k(Q)?Q:$APP.Zg.j(t)}());if(null!=c){$APP.qg.A(v,d)&&dPa(a,d);g=a;p=d;var A=$APP.Zg.j($APP.Ag(b));c.B?c.B(g,p,A):c.call(null,g,p,A)}return xE.M(a,b,d,v)}if(rPa(b)){A=n.indexOf(".");var B=$APP.Zg.j($APP.Og.B(n,0,A)),G=$APP.Og.A(n,A+1),J=uE(a,B,null,!1);if($APP.k(J)){var O=J;return $APP.Fj.B(O,$APP.R,function(Q,W,Z,fa,ha,ja,ta,ua,ca){return function(V){return $APP.Zg.j([$APP.m.j(V),".",ca].join(""))}}(a,b,c,d,O,J,A,B,G,n,p,v,g))}c=$APP.m.j(function(){var Q=
n;if(WOa(b)){var W=a;if(WOa(Q)){var Z=$APP.Zg.j;W=$APP.R.j($APP.wl.j(W));Q=[$APP.m.j($APP.hi(W)),".",tPa(Q)].join("");Z=Z.call($APP.Zg,Q)}else Z=Q}else Z=Q;return Z}());v=c.lastIndexOf(".");l=$APP.Og.B(c,0,v);c=$APP.Og.A(c,v+1);return new $APP.f(null,3,[$APP.$x,$APP.Ek,$APP.R,$APP.Zg.A(l,c),$APP.wl,$APP.Zg.j(l)],null)}if(null!=UD($APP.Fb(null),v,rE,b))return d=UD($APP.Fb(null),v,rE,b),xE.M(a,b,d,v);if(null!=UD($APP.Fb(null),v,yE,b))return c=UD($APP.Fb(null),v,yE,b),d=$APP.Zg.j($APP.ae(c)),g=$APP.Zg.j($APP.Ag(c)),
xE.M(a,g,d,v);if(null!=UD($APP.Fb(null),v,$APP.sm,b))g=a,v=UD($APP.Fb(null),v,$APP.sm,b),a=g,b=v;else return null!=UD($APP.Fb(null),v,jE,b)?(null!=c&&(c.B?c.B(a,v,b):c.call(null,a,v,b)),$APP.Ni.C($APP.y([UD($APP.Fb(null),v,jE,b),new $APP.f(null,3,[$APP.R,$APP.Zg.A($APP.m.j(v),$APP.m.j(b)),$APP.$x,$APP.Ek,$APP.wl,v],null)]))):fPa(a,b)?(g=BPa(b),null!=c&&(v=a,d=$APP.yn,p=g,c.B?c.B(v,d,p):c.call(null,v,d,p)),$APP.Ni.C($APP.y([UD($APP.Fb(null),$APP.yn,jE,g),new $APP.f(null,3,[$APP.R,$APP.Zg.A("cljs.core",
$APP.m.j(g)),$APP.$x,$APP.Ek,$APP.wl,$APP.yn],null)]))):$APP.k(IPa(n,a))?JPa(n,v,a):$APP.k(d)?(null!=c&&(c.B?c.B(a,v,b):c.call(null,a,v,b)),$APP.Ni.C($APP.y([UD($APP.Fb(null),v,jE,b),new $APP.f(null,3,[$APP.R,$APP.Zg.A($APP.m.j(v),$APP.m.j(b)),$APP.$x,$APP.Ek,$APP.wl,v],null)]))):null}};MPa=function(a,b){return $APP.eb($APP.mw.j($APP.ed(b)))?uE(a,b,fE,!0):vE(a,b)};
NPa=function(a,b){var c=$APP.R.j($APP.wl.j(a)),d=$APP.C.A($APP.Fb(null),TD);if(null!=$APP.ae(b))return c=$APP.ae(b),c=$APP.Uc.A("clojure.core",c)?"cljs.core":c,a=ZOa(a,c,$APP.Zg.j(c)),a=$APP.Sda($APP.m.j(a),"$macros")?a:$APP.Zg.j([$APP.m.j(a),"$macros"].join("")),$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,[a,jE,$APP.Zg.j($APP.Ag(b))],null));if(null!=$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,[c,zE,b],null)))return a=$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,[c,zE,b],null)),$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,
[a,AE,b],null));if(null!=$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,[c,BE,b],null)))return b=$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,[c,BE,b],null)),a=$APP.Zg.j($APP.ae(b)),b=$APP.Zg.j($APP.Ag(b)),$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,[a,AE,b],null));c=null!=$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,[c,AE,b],null))?c:fPa(a,b)?ePa:null;return null!=c?$APP.Zl.A(d,new $APP.H(null,3,5,$APP.I,[c,jE,b],null)):null};
OPa=function(a,b){var c=function(){var g=$APP.Mm.j(a);return $APP.k(g)?g:$APP.Mm.j($APP.Wu.j(a))}(),d=$APP.Tc(b);return $APP.He(function(g){var l=(l=$APP.Sn.j(g)===d)?l:$APP.ru.j(g);return $APP.k(l)?g:l},c)};RPa=function(a,b){if(null!=b&&b instanceof $APP.q){a:{var c=CE;CE=!0;try{var d=vE(a,b);break a}finally{CE=c}d=void 0}a=$APP.Ti.j(d);return null==a?(a=$APP.Ti.j($APP.Wu.j(d)),null==a?(d=DE.j(d),null==d?$APP.C.A(new $APP.ug(null,new $APP.f(null,2,[PPa,"null",QPa,"null"],null),null),b):d):a):a}return null};
SPa=function(a){a=$APP.qe(a);var b=$APP.C.A(a,$APP.$x);return $APP.$d(b,$APP.Mk)?$APP.Bk.j(a):a};
XPa=function(a,b){var c=SPa($APP.Nr.j(b)),d=$APP.qe(c);c=$APP.C.A(d,$APP.$x);var g=$APP.C.A(d,$APP.Nw);d=function(){var l=EE.j(b);return FE.A?FE.A(a,l):FE.call(null,a,l)}();if($APP.$d(c,$APP.Kw)&&null!=g&&!1!==g)return d;c=function(){var l=$APP.tr.j(b);return FE.A?FE.A(a,l):FE.call(null,a,l)}();if(qD(d,c)||qD(c,TPa))return d;if(qD(d,TPa))return c;if(null==$APP.C.A(UPa,d)&&!RPa(a,d)||null==$APP.C.A(UPa,c)&&!RPa(a,c)){if(null!=$APP.C.A(VPa,d)&&null!=$APP.C.A(VPa,c))return $APP.Xx;d=DD(d)?d:$APP.wg([d]);
c=DD(c)?c:$APP.wg([c]);return $APP.Lf.A(d,c)}return WPa};
ZPa=function(a,b){var c=$APP.R.j(a),d=new $APP.H(null,5,5,$APP.I,[$APP.wl,$APP.P,$APP.Wi,$APP.Xi,$APP.zj],null);c=$APP.Ni.C($APP.y([function(){var g=$APP.h.j(a),l=$APP.ng(g);return $APP.Bg(l,$APP.Vg.A(function(n){return new $APP.D(null,$APP.K,new $APP.D(null,$APP.C.A(g,n),null,1,null),2,null)},l))}(),$APP.rg.C($APP.Bg(d,$APP.Vg.A(function(g){return new $APP.D(null,$APP.K,new $APP.D(null,$APP.C.A(a,g),null,1,null),2,null)},d)),$APP.R,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,
$APP.Zg.j($APP.Ag($APP.R.j(a))),null,1,null)))),$APP.y([$APP.Nr,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.qu,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,YPa,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)])))),$APP.U,function(){var g=$APP.U.j(a);g=$APP.Uc.A($APP.K,$APP.u(g))?$APP.Xc(g):g;return new $APP.D(null,$APP.K,new $APP.D(null,$APP.Dj.j($APP.Vg.B($APP.z,g,$APP.zx.j(a))),null,1,null),2,null)}()]))]));return $APP.k(b)?
GE?GE(b,c):HE.call(null,b,c):c};$Pa=function(a,b){var c=CE;CE=!0;try{var d=$APP.Oi.A(a,ND),g=uE(d,b,XOa(),!0),l=$APP.rg.B(d,IE,$APP.Bk),n=$APP.wl.j(g);if(null==n)var p=null;else{var v=GE?GE(l,b):HE.call(null,l,b),t=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,$APP.Zg.A($APP.Ag(n),$APP.Ag($APP.R.j(g))),null,1,null))));var A=GE?GE(l,t):HE.call(null,l,t);p=new $APP.f(null,3,[$APP.Ek,v,$APP.ix,A,$APP.h,ZPa(g,l)],null)}return p}finally{CE=c}};
bQa=function(a,b){if($APP.Td(b)&&2===$APP.Tc(b)&&$APP.Ge($APP.zc,b)){var c=function(){var l=aE;aE=$APP.Bg($APP.ng(aE),$APP.Uj.j(!1));try{var n=$APP.rg.B(a,IE,$APP.Bk),p=$APP.u(b);return GE?GE(n,p):HE.call(null,n,p)}finally{aE=l}}();if($APP.Uc.A($APP.Ek,$APP.$x.j(c))){var d=function(){var l=$APP.R.j(c);return aQa.j?aQa.j(l):aQa.call(null,l)}();if($APP.k(d)){var g=$APP.$c(b);return $APP.k(function(){var l=null==$APP.ae(g);return l?$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[ND,g],null)):l}())?new $APP.H(null,
2,5,$APP.I,[g,d],null):null}}}return null};
fQa=function(a,b){if($APP.Td(b)&&3===$APP.Tc(b)&&$APP.Ge($APP.zc,b)&&!$APP.Bd(cQa,$APP.u(b))){var c=function(){var n=aE;aE=$APP.Bg($APP.ng(aE),$APP.Uj.j(!1));try{var p=$APP.rg.B(a,IE,$APP.Bk),v=$APP.u(b);return GE?GE(p,v):HE.call(null,p,v)}finally{aE=n}}();if($APP.Uc.A($APP.Ek,$APP.$x.j(c))&&$APP.k(function(){var n=$APP.R.j(c),p=new $APP.ug(null,new $APP.f(null,2,[dQa,"null",eQa,"null"],null),null);return p.j?p.j(n):p.call(null,n)}())){var d=function(){var n=aE;aE=$APP.Bg($APP.ng(aE),$APP.Uj.j(!1));
try{var p=$APP.rg.B(a,IE,$APP.Bk),v=$APP.Xc(b);return GE?GE(p,v):HE.call(null,p,v)}finally{aE=n}}(),g=$APP.R.j(d),l=$APP.$c(b);return $APP.k(function(){var n=$APP.Uc.A($APP.Ek,$APP.$x.j(d));return n?(n=null==$APP.ae(l))?$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[ND,l],null)):n:n}())?new $APP.H(null,2,5,$APP.I,[l,g],null):null}}return null};
gQa=function(a,b){if($APP.k(function(){var d=b instanceof $APP.q;return d?(d=null==$APP.ae(b))?$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[ND,b],null)):d:d}())){var c=function(){var d=aE;aE=$APP.Bg($APP.ng(aE),$APP.Uj.j(!1));try{var g=$APP.rg.B(a,IE,$APP.Bk);return GE?GE(g,b):HE.call(null,g,b)}finally{aE=d}}();c=$APP.sj.j(c);return $APP.k(c)?$APP.jd(c)&&$APP.Bd(c,nE)?new $APP.H(null,2,5,$APP.I,[b,hPa($APP.ym.A(c,nE))],null):null:null}return null};
hQa=function(a,b){var c=bQa(a,b);$APP.k(c)||(c=fQa(a,b),c=$APP.k(c)?c:gQa(a,b));b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return $APP.k(b)?$APP.am(a,new $APP.H(null,3,5,$APP.I,[ND,b,$APP.sj],null),c):a};iQa=function(a){return a instanceof $APP.q?a:null};jQa=function(){var a=new $APP.f(null,1,[IE,$APP.Bk],null);return function(b,c){return $APP.rg.B(c,$APP.Vl,a)}};kQa=function(a){return $APP.bf.C(function(b){b=$APP.C.A(a,b);return $APP.od(b)?b:$APP.k(b)?new $APP.H(null,1,5,$APP.I,[b],null):null},$APP.y([JD.j(a)]))};
lQa=function(a){a=$APP.Ag(a);return 2<a.length&&$APP.Ia(a,"*")&&$APP.Ja(a,"*")};nQa=function(a){var b=$APP.Ag(a);return $APP.qg.A(mQa,a)&&($APP.Ia(b,"cljs.")||$APP.Ia(b,"clojure."))};
sQa=function(a){return function(b,c){var d=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);var g=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);if($APP.k($APP.ae(c)))throw cE(a,["Can't use qualified name as parameter: ",$APP.m.j(c)].join(""));var l=XD(c,a),n=YD(c,a),p=$APP.ed(c);p=$APP.sj.j(p);var v=null!=d?tE(c,d.j?d.j(c):d.call(null,c)):null,t=$APP.Ni.C($APP.y([$APP.sg(a,new $APP.H(null,1,5,$APP.I,[IE],null)),new $APP.f(null,2,[$APP.Xi,l,$APP.zj,n],null)]));g=$APP.fg([$APP.R,oQa,$APP.$x,$APP.Vl,$APP.zj,$APP.Xi,
pQa,$APP.Wu,$APP.sj,JE,$APP.zl],[c,!0,qQa,t,n,l,g,new $APP.f(null,2,[$APP.R,c,JE,v],null),p,v,rQa]);return new $APP.H(null,2,5,$APP.I,[$APP.rg.B(d,c,g),$APP.Vd.A(b,g)],null)}};
wQa=function(a,b,c,d,g){var l=$APP.u(c),n=$APP.vd($APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.Lh,"null"],null),null),l)),p=$APP.tf($APP.sn.A(new $APP.ug(null,new $APP.f(null,1,[$APP.Lh,"null"],null),null),l));l=$APP.w(c);b=$APP.Id.B(sQa(a),new $APP.H(null,2,5,$APP.I,[b,$APP.sf],null),$APP.gp.A($APP.ns,p));var v=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);p=!0===n?$APP.zg(b):b;p=$APP.Tc(p);var t=new $APP.f(null,4,[KE,KE.j(a),$APP.dm,b,tQa,$APP.kh.j(null),$APP.Ay,$APP.kh.j($APP.sf)],null),A=$APP.Yd(t,
LE);v=$APP.rg.C(a,IE,ME,$APP.y([ND,v]));l=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Qh,null,1,null),l)));if($APP.k(g))a:{g=LE;LE=A;try{var B=GE?GE(v,l):HE.call(null,v,l);break a}finally{LE=g}B=void 0}else B=null;g=$APP.Fb(tQa.j(t));return $APP.Ni.C($APP.y([new $APP.f(null,8,[$APP.Vl,a,$APP.$x,uQa,$APP.ru,n,$APP.dm,b,$APP.Sn,p,$APP.Ti,d,$APP.Nw,c,vQa,g],null),null!=B?new $APP.f(null,2,[$APP.em,$APP.rg.B(B,NE,!0),JD,new $APP.H(null,2,5,$APP.I,[$APP.dm,$APP.em],null)],null):new $APP.f(null,1,[JD,
new $APP.H(null,1,5,$APP.I,[$APP.dm],null)],null)]))};AQa=function(a,b,c){if(null!=c){var d=$APP.R.j($APP.wl.j(a));b=tE(c,$APP.C.A(b,c));b=$APP.k(b)?b:$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[xQa,c],null));a=yQa.j(a);d=new $APP.f(null,4,[$APP.R,c,$APP.$x,qQa,$APP.zl,$APP.Fk,$APP.Wu,new $APP.f(null,4,[zQa,!0,yQa,a,$APP.wl,d,JE,b],null)],null);c=$APP.sj.j($APP.ed(c));return $APP.Ni.C($APP.y([d,null!=c?new $APP.f(null,1,[wE,c],null):null]))}return null};
BQa=function(a,b,c,d){return $APP.Fl.A(function(g){return wQa(a,b,g,c,!0)},d)};DQa=function(a,b){return $APP.Fl.A(function(c){var d=$APP.rg.B(a,IE,CQa);return GE?GE(d,c):HE.call(null,d,c)},$APP.zg(b))};EQa=function(a,b){var c=LE;LE=$APP.Yd(null,LE);try{return DQa(a,b)}finally{LE=c}};FQa=function(a,b,c){var d=OE;OE=c;try{return GE?GE(a,b):HE.call(null,a,b)}finally{OE=d}};GQa=function(a,b){a=$APP.sj.j($APP.ed(a));return null==a?(a=$APP.sj.j(b),null==a?$APP.sj.j($APP.Wu.j(b)):a):a};
HQa=function(a,b,c){var d=$APP.sf,g=$APP.rg.B(a,IE,$APP.Bk);for(b=$APP.r($APP.Jl.A(2,b));;){var l=$APP.u(b);if(null==l)return new $APP.H(null,2,5,$APP.I,[d,g],null);var n=l,p=$APP.x.B(n,0,null),v=$APP.x.B(n,1,null);if(null!=$APP.ae(p)||$APP.La($APP.m.j(p),"."))throw cE(a,["Invalid local name: ",$APP.m.j(p)].join(""));var t=FQa(g,v,$APP.Yd(new $APP.f(null,1,[$APP.dm,d],null),OE)),A=XD(p,g),B=YD(p,g),G=function(){var O=tE(p,$APP.Zl.A(g,new $APP.H(null,2,5,$APP.I,[ND,p],null)));return $APP.k(O)?O:$APP.Zl.A(g,
new $APP.H(null,2,5,$APP.I,[xQa,p],null))}(),J=$APP.fg([JD,LD,$APP.R,oQa,$APP.$x,$APP.Vl,$APP.zj,$APP.Xi,$APP.Wu,$APP.sj,JE,$APP.zl],[new $APP.H(null,1,5,$APP.I,[LD],null),t,p,!0,qQa,new $APP.f(null,2,[$APP.Xi,A,$APP.zj,B],null),B,A,new $APP.f(null,2,[$APP.R,p,JE,G],null),GQa(p,t),G,c]);l=$APP.Uc.A($APP.Fk,$APP.$x.j(t))?$APP.Ni.C($APP.y([J,new $APP.f(null,5,[PE,!0,$APP.Mm,$APP.Lf.A($APP.sf,$APP.Vg.A(function(){return function(O){return $APP.sg(O,new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.Sn,$APP.ru],
null))}}(d,g,b,t,A,B,G,J,n,p,v,l),$APP.Mm.j(t))),$APP.ru,$APP.ru.j(t),$APP.nw,$APP.nw.j(t),$APP.ty,$APP.Vg.A($APP.dm,$APP.Mm.j(t))],null)])):J;d=$APP.Vd.A(d,l);l=$APP.am(g,new $APP.H(null,2,5,$APP.I,[ND,p],null),l);b=$APP.w(b);g=l}};IQa=function(a,b,c){var d=LE;LE=$APP.Yd(null,LE);try{return HQa(a,b,c)}finally{LE=d}};
JQa=function(a,b,c,d,g){var l=LE,n=OE;LE=d;OE=g;try{var p=$APP.rg.B(a,IE,$APP.Uc.A($APP.Bk,b)?ME:b),v=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Qh,null,1,null),c)));return GE?GE(p,v):HE.call(null,p,v)}finally{OE=n,LE=l}};
MQa=function(a,b,c){for(var d=null;;){var g=b,l=$APP.r(g),n=$APP.u(l),p=$APP.w(l),v=n,t=$APP.u(p),A=$APP.w(p),B=t,G=A,J=g;if(!$APP.od(B)||!$APP.Ie($APP.Tc(B)))throw cE(a,"bindings must be vector of even number of elements");var O=IE.j(a),Q=!0===c?KQa:$APP.Hu;b=$APP.k(d)?$APP.tf($APP.bf.C(function(){return function(ca,V){var da=$APP.x.B(ca,0,null);ca=$APP.x.B(ca,1,null);return new $APP.H(null,2,5,$APP.I,[$APP.Xj.M(da,$APP.rg,$APP.sj,V),ca],null)}}(a,b,c,d,O,Q,g,l,n,p,v,t,A,B,G,J),$APP.y([$APP.Jl.A(2,
B),d]))):B;b=IQa(function(){var ca=a;return!0===c?$APP.rg.B(ca,LQa,!0):ca}(),b,Q);var W=$APP.x.B(b,0,null),Z=$APP.x.B(b,1,null),fa=!0===c?new $APP.f(null,3,[$APP.dm,W,tQa,$APP.kh.j(null),$APP.Ay,$APP.kh.j($APP.Fl.A($APP.sj,W))],null):null,ha=$APP.k(fa)?$APP.Yd(fa,LE):LE,ja=!0===c?OE:null!=OE?$APP.Yd(new $APP.f(null,1,[$APP.dm,W],null),OE):null,ta=$APP.k(function(){var ca=c;return $APP.k(ca)?$APP.eb(d):ca}())?$APP.kh.j($APP.sf):null;b=$APP.k(ta)?function(){var ca=yOa;yOa=new $APP.H(null,1,5,$APP.I,
[zOa(ta)],null);try{return JQa(Z,O,G,ha,ja)}finally{yOa=ca}}():JQa(Z,O,G,ha,ja);g=new $APP.H(null,2,5,$APP.I,[$APP.Tl,$APP.em],null);var ua=$APP.dn.A($APP.Kd,$APP.gy);if($APP.k(function(){var ca=c;return $APP.k(ca)?$APP.eb(d)&&$APP.qg.A($APP.Fl.A(ua,$APP.Fb($APP.Ay.j(fa))),$APP.Fl.A($APP.Hl.A(ua,$APP.sj),W)):ca}()))Q=a,b=J,J=c,g=$APP.Fb($APP.Ay.j(fa)),a=Q,c=J,d=g;else return $APP.k(ta)&&AOa(ta),new $APP.f(null,6,[$APP.$x,Q,$APP.Vl,a,$APP.Tl,W,$APP.em,$APP.rg.B(b,NE,!0),$APP.Nw,J,JD,g],null)}};
QE=function(a,b){return[$APP.m.j(b),"; offending spec: ",$APP.jh.C($APP.y([a]))].join("")};
NQa=function(a,b){if(!(b instanceof $APP.q||"string"===typeof b||$APP.kd(b)))throw cE(a,QE(b,"Only [lib.ns \x26 options] and lib.ns specs supported in :require / :require-macros"));if($APP.kd(b)){if(!($APP.u(b)instanceof $APP.q||"string"===typeof $APP.u(b)))throw cE(a,QE(b,"Library name must be specified as a symbol in :require / :require-macros"));if($APP.Ie($APP.Tc(b)))throw cE(a,QE(b,"Only :as alias, :refer (names) and :rename {from to} options supported in :require"));if(!$APP.Ge(new $APP.ug(null,
new $APP.f(null,3,[$APP.ck,null,$APP.bn,null,$APP.an,null],null),null),$APP.Vg.A($APP.u,$APP.Jl.A(2,$APP.w(b)))))throw cE(a,QE(b,"Only :as, :refer and :rename options supported in :require / :require-macros"));var c=$APP.Kg($APP.w(b));if(!(1>=(c.A?c.A($APP.ck,0):c.call(null,$APP.ck,0))&&1>=(c.A?c.A($APP.an,0):c.call(null,$APP.an,0))))throw cE(a,QE(b,"Each of :as and :refer options may only be specified once in :require / :require-macros"));}};
OQa=function(a,b){return $APP.Id.B(function(c,d){var g=$APP.r(d),l=$APP.u(g),n=$APP.w(g);if($APP.Uc.A(l,HD)){if($APP.r(kE.j(c)))throw cE(a,"Only one :refer-clojure form is allowed per namespace definition");var p=new $APP.ug(null,new $APP.f(null,2,[$APP.cn,null,$APP.bn,null],null),null),v=function(){for(var t=$APP.r(n),A=new $APP.f(null,2,[kE,$APP.vg,yE,$APP.F],null),B=!$APP.Ie($APP.Tc(n));;){if(!0===B)throw cE(a,"Only [:refer-clojure :exclude (names)] and optionally `:rename {from to}` specs supported");
if(null!=t){var G=$APP.u(t);if($APP.k(p.j?p.j(G):p.call(null,G))){var J=$APP.Xc(t);if($APP.Uc.A(G,$APP.cn)&&$APP.kd(J)&&$APP.Ge($APP.zc,J)||$APP.Uc.A(G,$APP.bn)&&$APP.md(J)&&$APP.Ge(function(){return function(O){return $APP.Ge($APP.zc,O)}}(t,A,B,J,G,p,d,g,l,n,l,n),J))if($APP.Uc.A(G,$APP.cn))t=$APP.Zc(t),A=$APP.Li.M(A,new $APP.H(null,1,5,$APP.I,[kE],null),$APP.Lf,J),B=!1;else if($APP.Uc.A(G,$APP.bn))t=$APP.Zc(t),A=$APP.Li.M(A,new $APP.H(null,1,5,$APP.I,[yE],null),$APP.Ni,J),B=!1;else return null;else B=
!0}else B=!0}else return A}}();return $APP.Oo.C($APP.Lf,$APP.y([c,v]))}return c},new $APP.f(null,2,[kE,$APP.vg,yE,$APP.F],null),b)};
PQa=function(a,b){var c=$APP.r(b),d=$APP.u(c),g=$APP.w(c);if(!(d instanceof $APP.q)||$APP.Ie($APP.Tc(b)))throw cE(a,QE(b,"Only [lib.ns :only (names)] and optionally `:rename {from to}` specs supported in :use / :use-macros"));for(var l=$APP.r(g),n=new $APP.H(null,1,5,$APP.I,[d],null),p=!1;;){if(!0===p)throw cE(a,QE(b,"Only [lib.ns :only (names)] and optionally `:rename {from to}` specs supported in :use / :use-macros"));if(null!=l){var v=$APP.u(l),t=$APP.Uc.A(v,$APP.Mha);if(t||$APP.Uc.A(v,$APP.bn)){if(null!=
$APP.He($APP.wg([t?$APP.an:v]),n))throw cE(a,QE(b,"Each of :only and :rename options may only be specified once in :use / :use-macros"));var A=$APP.Xc(l);t&&$APP.kd(A)&&$APP.Ge($APP.zc,A)||$APP.Uc.A(v,$APP.bn)&&$APP.md(A)&&$APP.Ge(function(){return function(B){return $APP.Ge($APP.zc,B)}}(l,n,p,A,v,t,b,c,d,g,d,g,b),A)?(l=$APP.Zc(l),n=$APP.Lf.A(n,new $APP.H(null,2,5,$APP.I,[t?$APP.an:v,A],null)),p=!1):p=!0}else p=!0}else{if(null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.an,null],null),null),
n))return n;p=!0}}};
RE=function(a,b,c,d,g){for(;;)if(g instanceof $APP.q||"string"===typeof g)g=new $APP.H(null,1,5,$APP.I,[g],null);else{NQa(a,g);var l=g,n=$APP.r(l),p=$APP.u(n),v=$APP.w(n),t=p,A=v,B=function(){var Y=SD($APP.Fb(null),OOa,$APP.m.j(t),$APP.R);return null==Y?new $APP.H(null,2,5,$APP.I,[t,null],null):new $APP.H(null,2,5,$APP.I,[$APP.Zg.j(Y),t],null)}(),G=$APP.x.B(B,0,null),J=$APP.x.B(B,1,null),O=$APP.Je.A($APP.Jk,A),Q=$APP.qe(O),W=$APP.C.B(Q,$APP.ck,"string"===typeof G?$APP.Zg.j($APP.hi(G)):G),Z=$APP.C.A(Q,
$APP.an),fa=$APP.C.A(Q,$APP.bn),ha=$APP.r($APP.sn.A($APP.yg($APP.ng(fa)),Z)),ja=$APP.k(b)?new $APP.H(null,3,5,$APP.I,[$APP.tn,zE,BE],null):new $APP.H(null,3,5,$APP.I,[$APP.Yj,$APP.en,$APP.bn],null),ta=$APP.x.B(ja,0,null),ua=$APP.x.B(ja,1,null),ca=$APP.x.B(ja,2,null);if(!(W instanceof $APP.q||null==W))throw cE(a,QE(g,":as must be followed by a symbol in :require / :require-macros"));if(null!=W){var V=$APP.k(b)?AE:QQa,da=function(){var Y=V.j($APP.Fb(d));return Y.j?Y.j(W):Y.call(null,W)}();if(null!=
da&&$APP.qg.A(G,da))throw cE(a,QE(g,":as alias must be unique"));$APP.lh.C(d,$APP.Li,new $APP.H(null,1,5,$APP.I,[V],null),$APP.Vd,$APP.y([new $APP.H(null,2,5,$APP.I,[W,G],null),$APP.k(J)?new $APP.H(null,2,5,$APP.I,[J,G],null):null]))}if(!($APP.kd(Z)&&$APP.Ge($APP.zc,Z)||null==Z))throw cE(a,QE(g,":refer must be followed by a sequence of symbols in :require / :require-macros"));$APP.k(b)||$APP.lh.B(c,$APP.Vd,G);return $APP.Ni.C($APP.y([null!=W?$APP.pe([ta,$APP.Ni.C($APP.y([$APP.pe([W,G]),$APP.pe([G,
G]),$APP.k(J)?$APP.pe([J,G]):null]))]):null,null!=ha?$APP.pe([ua,$APP.Je.A($APP.Jk,$APP.Tj.A(ha,$APP.Uj.j(G)))]):null,null!=fa?$APP.pe([ca,$APP.Id.B(function(Y,ea,ya,wa,Ba,Qa,Va,cb,pb,rb,yb,Ub,Db,Nb,gc,Gc,yd,ve){return function(Xe,qf){var pi=$APP.x.B(qf,0,null);qf=$APP.x.B(qf,1,null);if(!$APP.k($APP.He($APP.wg([pi]),ve)))throw cE(Y,["Renamed symbol ",$APP.m.j(pi)," not referred"].join(""));return $APP.rg.B(Xe,qf,$APP.Zg.A($APP.m.j(Db),$APP.m.j(pi)))}}(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja,
ta,ua,ca),$APP.F,fa)]):null]))}};
RQa=function(a,b,c){if(!($APP.kd(c)&&$APP.Ge($APP.zc,c)||c instanceof $APP.q&&null==$APP.ae(c)))throw cE(a,QE(c,"Only lib.ns.Ctor or [lib.ns Ctor*] spec supported in :import"));a=$APP.kd(c)?$APP.Lf.A($APP.F,$APP.Vg.A(function(v){return new $APP.H(null,2,5,$APP.I,[v,$APP.Zg.j([$APP.m.j($APP.u(c)),".",$APP.m.j(v)].join(""))],null)},$APP.Fc(c))):-1!==$APP.m.j(c).indexOf(".")?$APP.pe([$APP.Zg.j($APP.$c($APP.qi.A($APP.m.j(c),/\./))),c]):$APP.F;for(var d=$APP.r(a),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,
n);$APP.x.B(p,0,null);p=$APP.x.B(p,1,null);$APP.lh.B(b,$APP.Vd,p);n+=1}else if(d=$APP.r(d))$APP.pd(d)?(l=$APP.lc(d),d=$APP.mc(d),g=l,l=$APP.Tc(l)):(g=$APP.u(d),$APP.x.B(g,0,null),g=$APP.x.B(g,1,null),$APP.lh.B(b,$APP.Vd,g),d=$APP.w(d),g=null,l=0),n=0;else break;return new $APP.f(null,2,[SE,a,$APP.Yj,a],null)};SQa=function(a){return $APP.Vg.A(function(b){if(b instanceof $APP.E)return b;b=$APP.Xc(b);return $APP.od(b)||$APP.md(b)?b:new $APP.H(null,1,5,$APP.I,[b],null)},a)};
TQa=function(a){return $APP.Vg.A(function(b){return b instanceof $APP.E?b:$APP.Xc(b)},a)};
VQa=function(a){function b(v){var t=new $APP.ug(null,new $APP.f(null,2,[$APP.ln,null,$APP.mn,null],null),null);return t.j?t.j(v):t.call(null,v)}function c(v){return $APP.kd(v)?$APP.Vg.A(function(t){return $APP.Uc.A(t,$APP.Lha)?$APP.an:t},v):v}function d(v,t){for(;;){var A=(A=$APP.kd(t))?$APP.He(v,t):A;if($APP.eb(A))return t;A=$APP.Jg($APP.Ke(v),t);t=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);t=$APP.N.A(t,$APP.Se.A(2,A))}}var g=$APP.Lf.A($APP.F,$APP.Vg.A(function(v){var t=$APP.r(v);v=$APP.u(t);t=$APP.w(t);
return new $APP.H(null,2,5,$APP.I,[v,$APP.Lf.A($APP.sf,t)],null)},a));g=$APP.qe(g);var l=$APP.C.A(g,$APP.Yj),n=new $APP.ug(null,new $APP.f(null,2,[UQa,null,$APP.Lha,null],null),null),p=$APP.Pi.A(d,n);l=$APP.r(function(v){return $APP.Vg.A(function(t){return $APP.eb(b(t))?c(d(new $APP.ug(null,new $APP.f(null,1,[$APP.bn,null],null),null),d(new $APP.ug(null,new $APP.f(null,1,[$APP.an,null],null),null),d(new $APP.ug(null,new $APP.f(null,1,[UQa,null],null),null),t)))):t},$APP.df.A(function(t){var A=(A=
$APP.kd(t))?$APP.He(n,t):A;if($APP.k(A))return A;A=b(t);if($APP.k(A))t=A;else if($APP.k(!0)){t=$APP.kd(t)?$APP.u(t):t;A=$APP.Zl.A($APP.Fb(null),new $APP.H(null,2,5,$APP.I,[TD,t],null));var B=$APP.qe(A);A=$APP.C.A(B,zE);B=$APP.C.A(B,$APP.tn);A=$APP.He($APP.wg([t]),$APP.pg(A));t=$APP.k(A)?A:$APP.He($APP.wg([t]),$APP.pg(B))}else t=null;return t},v))}(l));return null==l?a:$APP.Vg.A(function(v){if($APP.eb(b(v))){var t=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);return $APP.Yd(t,$APP.Vg.A(p,v))}return v},$APP.Li.M(g,
new $APP.H(null,1,5,$APP.I,[$APP.tn],null),$APP.dn.A($APP.Lf,$APP.sf),l))};
WQa=function(a,b,c){c=$APP.Vg.A(function(v){return new $APP.H(null,2,5,$APP.I,[$APP.Zg.j($APP.Il.A(".",$APP.zg(v))),$APP.Zg.j($APP.$c(v))],null)},$APP.Se.A(2,$APP.St.B($APP.Vd,$APP.sf,c)));c=$APP.r(c);for(var d=null,g=0,l=0;;)if(l<g){var n=d.aa(null,l),p=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);$APP.k($APP.Zl.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[TD,p,jE,n],null)))&&$D(TE,a,new $APP.f(null,2,[$APP.wl,b,$APP.Ek,$APP.Zg.A($APP.m.j(p),$APP.m.j(n))],null));l+=1}else if(c=$APP.r(c))$APP.pd(c)?(d=
$APP.lc(c),c=$APP.mc(c),p=d,g=$APP.Tc(d),d=p):(d=$APP.u(c),p=$APP.x.B(d,0,null),n=$APP.x.B(d,1,null),$APP.k($APP.Zl.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[TD,p,jE,n],null)))&&$D(TE,a,new $APP.f(null,2,[$APP.wl,b,$APP.Ek,$APP.Zg.A($APP.m.j(p),$APP.m.j(n))],null)),c=$APP.w(c),d=null,g=0),l=0;else break};XQa=function(a){var b=$APP.m.j(a);return $APP.eb($APP.Ja(b,"$macros"))?$APP.Zg.j([b,"$macros"].join("")):a};
YQa=function(a,b){if(0<$APP.Tc(a)){var c=new $APP.H(null,8,5,$APP.I,[zE,$APP.tn,BE,rE,$APP.ak,yE,$APP.sm,FD],null);return $APP.Ni.C($APP.y([a,$APP.sg(b,new $APP.H(null,1,5,$APP.I,[kE],null)),$APP.Oo.C($APP.Ni,$APP.y([$APP.sg(a,c),$APP.sg(b,c)]))]))}return b};
hRa=function(a,b,c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(c,2,null),l=$APP.x.B(c,3,null),n=$APP.x.B(c,4,null),p=$APP.R.j(vE($APP.Oi.A(b,ND),d)),v=$APP.Id.B(function(A,B){return $APP.rg.B(A,B,$APP.fg([$APP.R,UE,$APP.zj,ZQa,$APP.Xi,$APP.sj,$APP.go,$APP.Zx,JE,$APP.zl],[B,!0,YD(B,b),ZQa.j($APP.ed(B)),XD(B,b),$APP.sj.j($APP.ed(B)),$APP.go.j($APP.ed(B)),$APP.Zx.j($APP.ed(B)),A.j?A.j(B):A.call(null,B),UE]))},$APP.F,$APP.Uc.A($Qa,a)?$APP.N.A(g,new $APP.H(null,3,5,$APP.I,[aRa,bRa,$APP.z($APP.dya,
new $APP.f(null,1,[$APP.go,!0],null))],null)):g),t=VE.j($APP.ed(d));$APP.lh.M(null,$APP.Li,new $APP.H(null,4,5,$APP.I,[TD,$APP.R.j($APP.wl.j(b)),jE,d],null),function(A){A=$APP.rg.C($APP.k(A)?A:$APP.F,$APP.R,p,$APP.y([$APP.sj,$APP.gx,$APP.Ti,!0,cRa,$APP.Tc(g),dRa,$APP.Uc.A($Qa,a)]));return $APP.Ni.C($APP.y([A,$APP.Oi.A($APP.ed(d),VE),new $APP.f(null,1,[VE,t],null),ZD(d,b)]))});return $APP.fg([JD,eRa,VE,fRa,$APP.$x,$APP.Vl,$APP.gRa,$APP.Nw,$APP.sj,$APP.em],[new $APP.H(null,1,5,$APP.I,[$APP.em],null),
l,$APP.ym.A(t,WE),g,a,b,p,c,$APP.gx,function(){var A=$APP.rg.B(b,ND,v);return GE?GE(A,n):HE.call(null,A,n)}()])};mRa=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);var d=$APP.I;var g=(g=c instanceof $APP.q)?$APP.Lg(/^-.*/,$APP.Ag(c)):g;return new $APP.H(null,3,5,d,[null==b?iRa:XE,$APP.vd(g)?jRa:c instanceof $APP.q?kRa:$APP.td(c)?lRa:iRa,null==a?$APP.Ec:XE],null)};
pRa=function(a,b,c){return b instanceof $APP.q?new $APP.f(null,4,[nRa,oRa,YE,a,$APP.ky,b,$APP.Wj,c],null):new $APP.f(null,4,[nRa,oRa,YE,a,$APP.ky,$APP.u(b),$APP.Wj,c],null)};
vRa=function(a,b,c,d,g){b=ZE.j(new $APP.H(null,3,5,$APP.I,[b,c,d],null));var l=$APP.qe(b),n=$APP.C.A(l,nRa);d=$APP.C.A(l,YE);b=$APP.C.A(l,$APP.ky);c=$APP.C.A(l,UE);l=$APP.C.A(l,$APP.Wj);var p=$APP.rg.B(a,IE,$APP.Bk);d=GE?GE(p,d):HE.call(null,p,d);var v=$APP.ed(g),t=$APP.sj.j(d),A=$APP.k(c)?c:b,B=function(){var Q=$APP.sj.j(v);if($APP.k(Q))return Q;if(Q=mE(t)){Q=$APP.Xj.S;var W=$APP.Uc.A($APP.Zw,t)?t:$APP.z($APP.Zw,new $APP.f(null,1,[$APP.Av,$APP.Vd.A($APP.tf($APP.Vg.A($APP.Zg,$APP.qi.A($APP.Ag(t),
/\./))),oE)],null));Q=Q.call($APP.Xj,W,$APP.Li,new $APP.H(null,1,5,$APP.I,[$APP.Av],null),$APP.dn.A($APP.Vd,new $APP.H(null,1,5,$APP.I,[$APP.Gx],null)),A)}return $APP.k(Q)?Q:null}();if($APP.qg.A($E,A)&&!$APP.ri($APP.m.j(A),"cljs$")&&$APP.eb(qRa.j($APP.ed(A)))&&($APP.Uc.A($APP.Gx,$APP.u($APP.Av.j($APP.ed(B))))&&$D(aF,a,new $APP.f(null,3,[rRa,sRa,$APP.Nw,g,bF,A],null)),$APP.qg.A($APP.Zw,t))){$APP.k(function(){var Q=null==t;if(Q)return Q;Q=new $APP.ug(null,new $APP.f(null,1,[$APP.gy,"null"],null),null);
return Q.j?Q.j(t):Q.call(null,t)}())&&$D(aF,a,new $APP.f(null,3,[rRa,YE,$APP.Nw,g,bF,A],null));var G=$APP.wi.A($APP.zg,$APP.Kd)($APP.Av.j($APP.ed(B))),J=$APP.x.B(G,0,null),O=$APP.x.B(G,1,null);$APP.k(function(){var Q=pE(J);return $APP.k(Q)?$APP.eb(pE(O)):Q}())&&$D(aF,a,new $APP.f(null,4,[rRa,bF,$APP.Nw,g,$APP.Ti,$APP.Zg.A("js",$APP.Il.A(".",$APP.Uc.A(oE,$APP.$c(J))?$APP.zg(J):J)),bF,A],null))}mE(B)&&(G=$APP.Av.j($APP.ed(B)),$APP.k(pE(G))||$APP.lh.C(null,$APP.Li,$APP.Lf.A(new $APP.H(null,3,5,$APP.I,
[TD,$APP.R.j($APP.wl.j(a)),GPa],null),G),$APP.Ni,$APP.y([$APP.F])));n=n instanceof $APP.E?n.ga:null;switch(n){case "cljs.analyzer/access":return n=new $APP.H(null,1,5,$APP.I,[YE],null),new $APP.f(null,7,[$APP.$x,tRa,$APP.Vl,a,$APP.Nw,g,YE,d,UE,c,JD,n,$APP.sj,mE(B)?function(){var Q=$APP.Av.j($APP.ed(B));Q=pPa(Q,$APP.sj);return $APP.k(Q)?Q:B}():B],null);case "cljs.analyzer/call":return c=$APP.Fl.A(function(Q){return GE?GE(p,Q):HE.call(null,p,Q)},l),n=new $APP.H(null,2,5,$APP.I,[YE,$APP.Wj],null),new $APP.f(null,
8,[$APP.$x,uRa,$APP.Vl,a,$APP.Nw,g,YE,d,$APP.ky,b,$APP.Wj,c,JD,n,$APP.sj,mE(B)?function(){var Q=$APP.Av.j($APP.ed(B));Q=pPa(Q,wE);return $APP.k(Q)?Q:$APP.Zw}():B],null);default:throw Error(["No matching clause: ",$APP.m.j(n)].join(""));}};wRa=function(a){a=$APP.ed(a);var b=$APP.sj.j(a);return null==b?!0===cF.j(a)?$APP.Yu:null:b};
yRa=function(a){return null==a?!0:$APP.Uc.A(nE,a)?!0:mE(a)?!0:a instanceof $APP.q&&null!=$APP.C.A(xRa,a)?!0:DD(a)?$APP.Bd(a,$APP.Yu)||$APP.Bd(a,$APP.xv)||$APP.Bd(a,$APP.my)||$APP.Bd(a,$APP.gy)||$APP.Bd(a,$APP.Zw):null};ARa=function(a){if(null==a)a=!0;else if($APP.Uc.A(nE,a))a=!0;else if(mE(a))a=!0;else if($APP.Uc.A($APP.gy,a))a=!0;else if($APP.Bd(zRa,a))a=!0;else{if(DD(a)){var b=$APP.Bd(a,$APP.gy);a=b?b:(b=$APP.Bd(a,$APP.Zw))?b:$APP.He(zRa,a)}else a=null;a=$APP.vd(a)}return a};
BRa=function(a,b,c){return $APP.u($APP.Id.B(function(d,g){var l=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return new $APP.H(null,2,5,$APP.I,[$APP.Vd.A(l,GE?GE(d,g):HE.call(null,d,g)),$APP.Uc.A(a,$APP.vu)?hQa(d,g):d],null)},new $APP.H(null,2,5,$APP.I,[$APP.sf,b],null),c))};
FRa=function(a,b,c,d){function g(A,B){var G=$APP.Vg.A(function(J){return FE(a,J)},t);return $APP.k(B.j?B.j(G):B.call(null,G))?null:$D(A,a,new $APP.f(null,2,[dF,v,CRa,$APP.Lf.A($APP.sf,G)],null))}var l=$APP.rg.B(a,IE,$APP.Bk),n=$APP.ed(d);b=eF(b);var p=wRa(d),v=dF.j(n),t=BRa(v,l,c);c=cF.j(n);!0===c&&g(DRa,function(A){return $APP.Ge(yRa,A)});return $APP.fg([$APP.Wj,JD,cF,ERa,$APP.$x,$APP.Vl,dF,$APP.Nw,$APP.sj],[t,new $APP.H(null,1,5,$APP.I,[$APP.Wj],null),c,b,$APP.qE,a,v,d,p])};
GRa=function(a){return $APP.md(a)&&!$APP.ld(a)?$APP.rg.B(a,fF,!0):$APP.Xj.M(a,$APP.rg,fF,!0)};HRa=function(a){return $APP.vd($APP.md(a)&&!$APP.ld(a)?fF.j(a):fF.j($APP.ed(a)))};IRa=function(a){return $APP.Ge(function(b){return null==b||b instanceof $APP.q||"string"===typeof b||"number"===typeof b||!0===b||!1===b},a)};
JRa=function(a,b){var c;if(c=a instanceof $APP.q)c=(c=null!=$APP.ae(a))?$APP.Zl.A($APP.Fb(null),new $APP.H(null,5,5,$APP.I,[TD,$APP.Zg.j($APP.ae(a)),jE,$APP.Zg.j($APP.Ag(a)),dRa],null)):c;if(c=$APP.vd(c))c=$APP.Zg.j(["-\x3e",$APP.Ag(a)].join("")),a=$APP.u($APP.Zl.A($APP.Fb(null),new $APP.H(null,5,5,$APP.I,[TD,$APP.Zg.j($APP.ae(a)),jE,c,$APP.ty],null))),a=$APP.Lf.A($APP.vg,a),c=$APP.Bd(a,b);return c};
KRa=function(a,b,c,d){return(b=!(null==b||$APP.vd($APP.He($APP.wg([a]),$APP.Vg.A($APP.Tc,b)))))?(b=$APP.eb(c))?b:$APP.k(c)?a<d:c:b};
QRa=function(a,b){var c=$APP.r(b),d=$APP.u(c),g=$APP.w(c),l=$APP.rg.B(a,IE,$APP.Bk),n=GE?GE(l,d):HE.call(null,l,d),p=$APP.Tc(g),v=function(){var ja=PE.j($APP.Wu.j(n));return $APP.k(ja)?ja:LPa.j($APP.Wu.j(n))}();c=$APP.Uc.A(gF,$APP.sj.j(n));var t=$APP.R.j($APP.wl.j(a)),A=$APP.vd(!1)&&$APP.eb(v)&&!mE(d)&&!c&&!HRa(d),B=A&&!(d instanceof $APP.q),G=A&&!IRa(g);if(v){v=$APP.Wu.j(n);v=$APP.qe(v);var J=$APP.C.A(v,$APP.ru),O=$APP.C.A(v,$APP.nw),Q=$APP.C.A(v,$APP.ty);A=$APP.C.A(v,$APP.R);var W=$APP.C.A(v,$APP.wl),
Z=$APP.C.A(v,$APP.Bl);$APP.k(function(){var ja=$APP.Ja($APP.m.j(t),"$macros");return(ja=$APP.eb($APP.k(ja)?qD(t,W)&&!0===Z:ja))?KRa(p,Q,J,O):ja}())&&$D(hF,a,new $APP.f(null,2,[$APP.R,A,iF,p],null))}c&&1!==p&&2!==p&&$D(hF,a,new $APP.f(null,2,[$APP.R,$APP.u(b),iF,p],null));c=$APP.fBa.j($APP.Wu.j(n));v=LRa.j($APP.ed(b));$APP.vd(c)&&!$APP.vd(v)&&$D(MRa,a,new $APP.f(null,1,[NRa,n],null));null!=$APP.Ti.j($APP.Wu.j(n))&&$D(ORa,a,new $APP.f(null,1,[NRa,n],null));if(G||B){var fa=G?$APP.We.A(p,$APP.Nn.j($APP.Nj)):
null,ha=B?$APP.Nj.j("fexpr__"):null;c=function(){var ja=G?$APP.Lf.A($APP.sf,$APP.Tj.A(fa,g)):$APP.sf;return B?$APP.Vd.C(ja,ha,$APP.y([GRa(d)])):ja}();b=$APP.sj.j($APP.ed(b));b=$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.fm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(c)))),null,1,null),$APP.y([new $APP.D(null,$APP.z($APP.T.j($APP.r($APP.N.A(new $APP.D(null,GRa(B?ha:d),null,1,null),G?fa:g))),new $APP.f(null,1,[$APP.sj,b],null)),null,1,null)]))));return GE?GE(a,b):HE.call(null,a,
b)}c=$APP.Fl.A(function(ja){return GE?GE(l,ja):HE.call(null,l,ja)},g);if(d instanceof $APP.E&&null==$APP.ae(d)&&1===$APP.Tc(g)&&JRa($APP.sj.j($APP.u(c)),$APP.Zg.j($APP.Ag(d)))){b=$APP.Kn.A($APP.Zg.j([".-",$APP.Ag(d)].join("")),g);c=aE;aE=$APP.Bg($APP.ng(aE),$APP.Uj.j(!1));try{return GE?GE(a,b):HE.call(null,a,b)}finally{aE=c}}else return new $APP.f(null,6,[$APP.Vl,a,$APP.$x,PRa,$APP.Nw,b,$APP.Fk,n,$APP.Wj,c,JD,new $APP.H(null,2,5,$APP.I,[$APP.Fk,$APP.Wj],null)],null)};
URa=function(a,b){if(RRa.j(a))return uOa(a,b),b=new $APP.f(null,5,[$APP.$x,$APP.Kw,$APP.X,b,$APP.Vl,a,$APP.Nw,b,$APP.sj,jF],null),kF.j?kF.j(b):kF.call(null,b);var c=$APP.ed(b),d=$APP.qe(c);c=$APP.C.A(d,$APP.Xi);d=$APP.C.A(d,$APP.zj);a=null!=c?$APP.rg.B(a,$APP.Xi,c):a;var g=null!=d?$APP.rg.B(a,$APP.zj,d):a,l=new $APP.f(null,2,[$APP.Vl,g,$APP.Nw,b],null);a=ND.j(g);a=tE(b,$APP.C.A(a,b));if(null==a){a=$APP.ed(b);var n=$APP.ae(b),p=$APP.m.j($APP.R.j($APP.wl.j(g))),v=$APP.k(function(){if($APP.k(n)){var A=
$APP.qg.A(n,"cljs.core");return A?(A=$APP.Ja(p,"$macros"),$APP.k(A)?$APP.eb($APP.Ja(n,"$macros"))&&$APP.Uc.A(n,$APP.Og.B(p,0,p.length-7)):A):A}return n}())?$APP.Zg.A([n,"$macros"].join(""),$APP.Ag(b)):b,t=$APP.Bd(a,fF)?vE(g,v):MPa(g,v);return lF(!0!==SRa.j(g)?$APP.Ni.C($APP.y([$APP.rg.B(l,$APP.Wu,t),$APP.sg(t,new $APP.H(null,4,5,$APP.I,[$APP.$x,$APP.R,$APP.wl,$APP.sj],null)),function(){var A=TRa.j(t);return $APP.k(A)?new $APP.f(null,1,[TRa,A],null):null}()])):function(){var A=vE(g,v);return $APP.Ni.C($APP.y([$APP.rg.C(l,
$APP.$x,$APP.Ek,$APP.y([$APP.Wu,A])),$APP.sg(A,new $APP.H(null,4,5,$APP.I,[$APP.$x,$APP.R,$APP.wl,$APP.sj],null))]))}())}return $APP.Ni.C($APP.y([$APP.rg.C(l,$APP.$x,$APP.zl,$APP.y([$APP.Wu,a])),$APP.md(a)?$APP.sg(a,new $APP.H(null,5,5,$APP.I,[$APP.R,$APP.zl,pQa,$APP.ru,LD],null)):null]))};
WRa=function(a,b){var c=ZOa(a,b,null);c=$APP.k(c)?c:YOa(a,b,null);b=null!=c?$APP.m.j(c):b;if("clojure.core"===b)return sD(ePa);if("clojure.repl"===b)return sD(VRa);if($APP.k($APP.La(b,".")))return sD($APP.Zg.j(b));a=null==a?null:$APP.wl.j(a);a=null==a?null:$APP.tn.j(a);a=null==a?null:$APP.C.A(a,$APP.Zg.j(b));return null==a?null:sD(a)};
XRa=function(a,b){var c;!(c=null!=RD(b,ND,a))&&(c=null!=SD(b,$APP.wl,kE,a)||null!=UD($APP.Fb(null),RD(b,$APP.wl,$APP.R),kE,a))&&(c=!(null!=SD(b,$APP.wl,zE,a)||null!=UD($APP.Fb(null),RD(b,$APP.wl,$APP.R),zE,a)));if(c)return null;c=$APP.ae(a);if(null!=c)return b=WRa(b,c),null!=b?pD(b,$APP.Zg.j($APP.Ag(a))):null;if(null!=SD(b,$APP.wl,BE,a))return a=SD(b,$APP.wl,BE,a),b=$APP.Zg.j($APP.ae(a)),a=$APP.Zg.j($APP.Ag(a)),pD(sD(b),a);b=SD(b,$APP.wl,zE,a);return null!=b&&b instanceof $APP.q?pD(sD(b),a):pD(sD(ePa),
a)};dE=function(a,b){a=XRa(a,b);if(b=null!=a)b=(a.val.J?a.val.J():a.val.call(null)).Nj;return b?a:null};aSa=function(a,b,c){if($APP.eb(YRa.j($APP.OD.j($APP.Fb(null))))){var d=null!=VNa(YNa)?$APP.Fb(ZRa):null;if(null!=d)try{var g=$APP.w(b);d.A?d.A(c,g):d.call(null,c,g)}catch(l){throw b=l,$APP.Zi.B(null,bE(a,$Ra,c.pc),b);}}};
bSa=function(a,b){a=a.pc;var c=$APP.Zl.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[TD,$APP.Zg.j($APP.ae(a)),jE,$APP.Zg.j($APP.Ag(a))],null));if($APP.k(c)){var d=$APP.qe(c);c=$APP.C.A(d,$APP.ru);var g=$APP.C.A(d,$APP.nw);d=$APP.C.A(d,$APP.ty);b=$APP.Tc($APP.Fc(b));var l=$APP.Uc.A($APP.Hha,$APP.Yc(d))?2:0;if($APP.k(KRa(b,$APP.Vg.A(function(n){return $APP.zba(n,l)},d),c,$APP.k(g)?g-l:null)))throw Error(mF.A(hF,new $APP.f(null,2,[iF,b,$APP.R,a],null)));}};
fSa=function(a,b){var c=$APP.u(b);if($APP.Bd(cQa,c))return $APP.Uc.A($APP.Th,c)&&aSa(a,b,dE(cSa,a)),b;var d=c instanceof $APP.q?dE(c,a):null;if(null==d){if(c instanceof $APP.q){c=$APP.m.j(c);if("."===c.charAt(0)){var g=$APP.w(b),l=$APP.r(g);g=$APP.u(l);l=$APP.w(l);return $APP.z($APP.Kn.M($APP.$h,g,$APP.Zg.j($APP.Og.A(c,1)),l),$APP.ed(b))}return"."===c.charAt(c.length-1)?$APP.z($APP.Kn.B($APP.Sh,$APP.Zg.j($APP.Og.B(c,0,c.length-1)),$APP.w(b)),$APP.ed(b)):b}return b}aSa(a,b,d);c=function(){try{return bSa(d,
b),$APP.Je.M($APP.Fb(d),b,a,$APP.Fc(b))}catch(p){var n=p;throw $APP.Zi.B(null,bE(a,dSa,d.pc),n);}}();return null!=c&&(c.O&64||$APP.xc===c.Ad)&&(g=$APP.u(c),l=$APP.u(b),qD(g,$APP.Wh))?(g=null!=$APP.ae(l)?l:$APP.Zg.A("cljs.core",$APP.m.j(l)),g=new $APP.f(null,1,[dF,g],null),g=!0===function(){var n=$APP.Zg.j($APP.ae(d.pc)),p=$APP.Zg.j($APP.Ag(d.pc));return $APP.Zl.A($APP.Fb(null),new $APP.H(null,6,5,$APP.I,[TD,n,jE,p,$APP.h,eSa],null))}()?$APP.rg.B(g,cF,!0):g,$APP.Xj.B(c,$APP.Ni,g)):c};
hSa=function(a){switch(arguments.length){case 3:return nF(arguments[0],arguments[1],arguments[2]);case 4:return gSa(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};nF=function(a,b,c){return gSa(a,b,c,$APP.k(null)?$APP.OD.j($APP.Fb(null)):null)};
gSa=function(a,b,c,d){if(RRa.j(a))return iSa.A?iSa.A(a,b):iSa.call(null,a,b);var g=$APP.Xi.j($APP.ed(b));g=null==g?$APP.Xi.j(a):g;var l=$APP.zj.j($APP.ed(b));l=null==l?$APP.zj.j(a):l;a=$APP.rg.C(a,$APP.Xi,g,$APP.y([$APP.zj,l]));g=$APP.u(b);if(null==g)throw cE(a,"Can't call nil");try{var n=fSa(a,b)}catch(t){b=t;if($APP.Bd($APP.Ih(b),EOa))throw b;if(IOa(b))throw $APP.Zi.B(null,bE(a,oF,null),b);throw $APP.Zi.B(null,bE(a,oF,null),GOa(a,b.message,b));}if(b===n)try{if($APP.Bd(cQa,g))var p=pF.S(g,a,b,c,
d);else b:{c=LE;LE=$APP.Yd(null,LE);try{p=QRa(a,b);break b}finally{LE=c}p=void 0}var v=p}catch(t){b=t;if($APP.Bd($APP.Ih(b),EOa))throw b;if(IOa(b))throw $APP.Zi.B(null,bE(a,oF,null),b);throw $APP.Zi.B(null,bE(a,oF,null),GOa(a,b.message,b));}else v=jSa?jSa(a,n,c,d):HE.call(null,a,n,c,d);return v};
mSa=function(a,b){var c=$APP.rg.B(a,IE,$APP.Bk),d=function(){var l=LE;LE=$APP.Yd(null,LE);try{return $APP.Fl.A(function(n){return GE?GE(c,n):HE.call(null,c,n)},$APP.ng(b))}finally{LE=l}}(),g=function(){var l=LE;LE=$APP.Yd(null,LE);try{return $APP.Fl.A(function(n){return GE?GE(c,n):HE.call(null,c,n)},$APP.pg(b))}finally{LE=l}}();a=new $APP.f(null,7,[$APP.$x,$APP.nj,$APP.Vl,a,$APP.Nw,b,$APP.zu,d,kSa,g,JD,new $APP.H(null,2,5,$APP.I,[$APP.zu,kSa],null),$APP.sj,lSa],null);return kF.j?kF.j(a):kF.call(null,
a)};iSa=function(a,b){var c=$APP.rg.B(a,IE,$APP.Bk),d=function(){var g=LE;LE=$APP.Yd(null,LE);try{return $APP.Fl.A(function(l){return GE?GE(c,l):HE.call(null,c,l)},b)}finally{LE=g}}();a=new $APP.f(null,6,[$APP.$x,$APP.lj,$APP.Vl,a,$APP.Nw,b,$APP.qF,d,JD,new $APP.H(null,1,5,$APP.I,[$APP.qF],null),$APP.sj,nSa],null);return kF.j?kF.j(a):kF.call(null,a)};
pSa=function(a,b){var c=$APP.rg.B(a,IE,$APP.Bk),d=function(){var g=LE;LE=$APP.Yd(null,LE);try{return $APP.Fl.A(function(l){return GE?GE(c,l):HE.call(null,c,l)},b)}finally{LE=g}}();a=new $APP.f(null,6,[$APP.$x,$APP.mj,$APP.Vl,a,$APP.Nw,b,$APP.qF,d,JD,new $APP.H(null,1,5,$APP.I,[$APP.qF],null),$APP.sj,oSa],null);return kF.j?kF.j(a):kF.call(null,a)};
rSa=function(a,b){var c=$APP.rg.B(a,IE,$APP.Bk),d=function(){var g=LE;LE=$APP.Yd(null,LE);try{return $APP.Fl.A(function(l){return GE?GE(c,l):HE.call(null,c,l)},b)}finally{LE=g}}();a=new $APP.f(null,6,[$APP.$x,$APP.tj,$APP.Vl,a,$APP.Nw,b,$APP.qF,d,JD,new $APP.H(null,1,5,$APP.I,[$APP.qF],null),$APP.sj,qSa],null);return kF.j?kF.j(a):kF.call(null,a)};
uSa=function(a,b){var c=b.val,d=$APP.rg.B(a,IE,$APP.Bk);if($APP.md(c)){var g=$APP.tf($APP.ng(c)),l=function(){var n=LE;LE=$APP.Yd(null,LE);try{return $APP.Fl.A(function(p){return GE?GE(d,p):HE.call(null,d,p)},$APP.pg(c))}finally{LE=n}}();return new $APP.f(null,7,[$APP.$x,sSa,$APP.Vl,a,$APP.Nw,b,$APP.zu,g,kSa,l,JD,new $APP.H(null,1,5,$APP.I,[kSa],null),$APP.sj,$APP.ay],null)}g=function(){var n=LE;LE=$APP.Yd(null,LE);try{return $APP.Fl.A(function(p){return GE?GE(d,p):HE.call(null,d,p)},c)}finally{LE=
n}}();return new $APP.f(null,6,[$APP.$x,tSa,$APP.Vl,a,$APP.Nw,b,$APP.qF,g,JD,new $APP.H(null,1,5,$APP.I,[$APP.qF],null),$APP.sj,$APP.Px],null)};
kF=function(a){var b=$APP.Nw.j(a),c=$APP.Oi.A($APP.Oi.C($APP.ed(b),$APP.Wi,$APP.y([$APP.Xi,$APP.zj,$APP.Lr,$APP.Mr,$APP.Mi])),fF);if(null!=$APP.r(c)){var d=$APP.Vl.j(a);a=$APP.am(a,new $APP.H(null,2,5,$APP.I,[$APP.Vl,IE],null),$APP.Bk);c=mSa($APP.Vl.j(a),c);return new $APP.f(null,6,[$APP.$x,vSa,$APP.Vl,d,$APP.Nw,b,$APP.h,c,$APP.Bk,a,JD,new $APP.H(null,2,5,$APP.I,[$APP.h,$APP.Bk],null)],null)}return a};
wSa=function(a,b,c,d){if(b instanceof $APP.q)return URa(a,b);if(null!=b&&(b.O&64||$APP.xc===b.Ad)&&null!=$APP.r(b))return gSa(a,b,c,d);if($APP.nd(b)){c=LE;LE=$APP.Yd(null,LE);try{var g=$APP.rg.B(a,IE,$APP.Bk),l=$APP.Lf.A($APP.F,b);GE?GE(g,l):HE.call(null,g,l)}finally{LE=c}l=$APP.Vg.A($APP.Zg,$APP.qi.A($APP.jh.C($APP.y([$APP.hb(b)])),/\//));g=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);return new $APP.f(null,5,[$APP.$x,$APP.Kw,$APP.X,b,$APP.Vl,a,$APP.Nw,b,$APP.sj,$APP.Zg.A($APP.m.j(g),$APP.m.j(l))],null)}if(null!=
b&&(b.O&1024||$APP.xc===b.Mh))return mSa(a,b);if(null!=b&&(b.O&16384||$APP.xc===b.Lj))return pSa(a,b);if(DD(b))return rSa(a,b);if(b instanceof $APP.E)return uOa(a,b),new $APP.f(null,5,[$APP.$x,$APP.Kw,$APP.X,b,$APP.Vl,a,$APP.Nw,b,$APP.sj,gF],null);if(b instanceof $APP.bfa)return uSa(a,b);g=null==b?nE:"number"===typeof b?$APP.Yu:"string"===typeof b?$APP.Fy:!0===b?$APP.wv:!1===b?$APP.wv:$APP.Uc.A($APP.Ec,b)?nSa:null;a=new $APP.f(null,4,[$APP.$x,$APP.Kw,$APP.X,b,$APP.Vl,a,$APP.Nw,b],null);return $APP.k(g)?
$APP.rg.B(a,$APP.sj,g):a};ySa=function(a,b,c,d){var g=rF;g=null==g?xSa:g;b=b instanceof $APP.de?$APP.r(b)?b:$APP.Ec:b;c=wSa(a,b,c,d);return $APP.Id.B(function(l,n){return n.B?n.B(a,l,d):n.call(null,a,l,d)},c,g)};
HE=function(a){switch(arguments.length){case 2:return GE(arguments[0],arguments[1]);case 3:return zSa(arguments[0],arguments[1],arguments[2]);case 4:return jSa(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};GE=function(a,b){return zSa(a,b,null)};zSa=function(a,b,c){return jSa(a,b,c,$APP.k(null)?$APP.OD.j($APP.Fb(null)):null)};
jSa=function(a,b,c,d){try{if(HRa(b)){var g=aE;aE=$APP.Bg($APP.ng(aE),$APP.Uj.j(!1));try{return ySa(a,b,c,d)}finally{aE=g}}else return ySa(a,b,c,d)}catch(l){b=l;if($APP.Bd($APP.Ih(b),EOa))throw b;if(IOa(b))throw $APP.Zi.B(null,bE(a,oF,null),b);throw $APP.Zi.B(null,bE(a,oF,null),GOa(a,b.message,b));}};$APP.JEa=function(a,b){try{var c=CE;CE=!0;try{return uE(a,b,XOa(),!0)}finally{CE=c}}catch(d){return NPa(a,b)}};
BSa=function(a,b){a=$APP.k(b)?$APP.Hj.A(a,b+1):new $APP.H(null,1,5,$APP.I,[a],null);return $APP.Vg.A(function(c){return $APP.Lf.B($APP.sf,$APP.We.j(c),ASa)},a)};sF=function(a,b){this.n=a;this.d=b;this.O=4194304;this.U=2048};CSa=function(){throw Error("Fraction with zero denominator");};DSa=function(a,b){for(;;){if(b===tF)return a;var c=a%b;a=b;b=c}};uF=function(a){return Number(a.n)/Number(a.d)};
wF=function(a,b){tF===b&&CSa();var c=0>a?vF*a:a,d=0>b?vF*b:b,g=DSa(c,d);a=$APP.qg.A(0>a,0>b);c/=g;return new sF(a?vF*c:c,d/g)};ESa=function(a){var b=a.n,c=a.d;return 0>b?new sF(vF*b,c):a};FSa=function(a,b){var c=a.d,d=b.d;return wF(a.n*d+c*b.n,c*d)};GSa=function(a,b){var c=a.d,d=b.d;return wF(a.n*d-c*b.n,c*d)};HSa=function(a,b){return wF(a.n*b.n,a.d*b.d)};ISa=function(a,b){a=a.n*b.d-a.d*b.n;return 0>a?-1:0<a?1:0};
KSa=function(a,b){var c=a.n,d=a.d,g=BigInt(b);return $APP.Uc.A(b,tF)?JSa:$APP.Uc.A(b,xF)?a:g>tF?wF(c**g,d**g):wF(d**-g,c**-g)};yF=function(a){return xF===a.d?a.n:a};LSa=function(a,b){a=wF(a.n*b.d,a.d*b.n);0>a.n?(b=a.n,a=a.d,a=b/a+(0>b||b%a===tF?tF:xF)):(b=a.n,a=a.d,a=b/a-(0<b||b%a===tF?tF:xF));return a};MSa=function(a,b){return GSa(a,HSa(new sF(LSa(a,b),xF),b))};NSa=function(){};
zF=function(a){if(null!=a&&null!=a.nd)a=a.nd(a);else{var b=zF[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=zF._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("Numerical.numerical?",a);}return a};OSa=function(){};AF=function(){};BF=function(a){if(null!=a&&null!=a.rb)a=a.rb(a);else{var b=BF[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=BF._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IKind.kind",a);}return a};
CF=function(a){return $APP.Cba(a)||$APP.Uc.A("bigint",$APP.la(a))};DF=function(a){return"number"===typeof a||a instanceof $APP.za||a instanceof $APP.qa||$APP.Uc.A("bigint",$APP.la(a))||a instanceof sF};EF=function(a){var b="number"===typeof a;return b||(b=a instanceof $APP.za)||(b=a instanceof $APP.qa)||(b=$APP.Uc.A("bigint",$APP.la(a)))?b:(b=a instanceof sF)?b:null!=a?$APP.xc===a.bi?!0:a.$c?!1:$APP.gb(OSa,a):$APP.gb(OSa,a)};GF=function(a){return $APP.vh(BF(a),FF)};QSa=function(a,b){a[PSa]=b;return a};
RSa=function(a){var b=BF(a);return function(c){return $APP.vh(BF(c),b)}};
HF=function(a,b){if(a===b)return 0;if(null==a)return-1;if(null==b)return 1;if("number"===typeof a){var c=b.valueOf();if(DF(c))return $APP.Oa(a,c);throw Error(["Cannot compare ",$APP.m.j(a)," to ",$APP.m.j(b)].join(""));}if(null!=a?a.U&2048||$APP.xc===a.qc||(a.U?0:$APP.gb($APP.ic,a)):$APP.gb($APP.ic,a))return $APP.jc(a,b);if("string"!==typeof a&&!$APP.db(a)&&!0!==a&&!1!==a||$APP.hb(a)!==$APP.hb(b))throw Error(["Cannot compare ",$APP.m.j(a)," to ",$APP.m.j(b)].join(""));return $APP.Oa(a,b)};
TSa=function(a){return $APP.lh.B(SSa,$APP.Lf,a)};IF=function(a){return function(b,c){return Math.abs(b-c)<a}};USa=function(a){var b=a-JF;return function(c){if(b<=c&&c<a)return c;c-=JF*Math.floor(c/JF);return c<a?c:c-JF}};LF=function(a){var b=EF(a);return b?KF.j(a):b};
VSa=function(a,b){var c=BF(a),d=$APP.Dh(MF,new $APP.H(null,2,5,$APP.I,[c,c],null));return $APP.k(d)?(c=function(g,l){var n=l;for(l=NF.j(g);;){var p=$APP.Ie(n);n=$APP.Pd(n,2);if(p)g=d.A?d.A(g,g):d.call(null,g,g);else{if($APP.k(KF.j(n)))return d.A?d.A(g,l):d.call(null,g,l);l=d.A?d.A(g,l):d.call(null,g,l);g=d.A?d.A(g,g):d.call(null,g,g)}}},0<b?c(a,b):$APP.k(KF.j(b))?NF.j(a):OF.j(c(a,PF.j(b)))):AD(["No g/mul implementation registered for kind ",$APP.m.j(c)].join(""))};
SF=function(a){var b=CF(a);return b?b:(b=$APP.Eba(a))?(b=Math.round(a),$APP.k(KF.j(b))?1E-20>Math.abs(a):Math.abs(QF.A(RF.A(a,b),b))<WSa):b};UF=function(a){var b=EF(a);return b?(b=TF.j(a),$APP.k(b)?KF.j(a):b):b};XSa=function(a,b){return VF.A(a,b)};WF=function(a,b,c){this.type=a;this.expression=b;this.ca=c;this.O=2149974016;this.U=2048};YSa=function(a,b,c){return new WF(a,b,c)};ZSa=function(a,b){return YSa(a,b,null)};$Sa=function(a,b,c){return ZSa(a,$APP.Yd(b,$APP.r(c)))};
XF=function(a){return a instanceof WF};aTa=function(a){return XF(a)?a.type:null};bTa=function(a,b){var c=b.type,d=b.expression;a=a.j?a.j(d):a.call(null,d);return YSa(c,a,b.ca)};YF=function(a){return XF(a)?a.expression:a};ZF=function(a){for(;;){if(a instanceof $APP.q)return $APP.wg([a]);if(XF(a))a=YF(a);else return a=$APP.Fc($APP.cf($APP.kd,$APP.r,a)),$APP.Lf.B($APP.vg,$APP.df.j($APP.zc),a)}};
cTa=function(a,b,c){return function l(g){if(g instanceof $APP.q)return b.A?b.A(g,g):b.call(null,g,g);if($APP.kd(g)){var n=$APP.r(g);g=$APP.u(n);n=$APP.w(n);var p=c.j?c.j(g):c.call(null,g);return $APP.k(p)?$APP.Je.A(p,$APP.Fl.A(l,n)):AD(["Missing fn for symbol - ",$APP.m.j(g)].join(""))}return g}(YF(a))};dTa=function(a){return $APP.kd(a)?$APP.gi.A($F,a):a};eTa=function(a){return $APP.jh.C($APP.y([aG.j(bG.j(a))]))};fTa=function(a){return $APP.ZA.j(aG.j(bG.j(a)))};
cG=function(a,b){this.ha=a;this.ia=b;this.O=2149580800;this.U=0};dG=function(a,b){return new cG(a,b)};eG=function(a){return["#emmy/complex ",$APP.m.j(new $APP.H(null,2,5,$APP.I,[a.ha,a.ia],null))].join("")};gTa=function(a,b){var c=a.ha,d=a.ia;return b instanceof cG?(a=fG.A(c,b.ha),$APP.k(a)?fG.A(d,b.ia):a):DF(b)?(a=KF.j(d),$APP.k(a)?fG.A(c,b):a):fG.A(a,b)};gG=function(a){var b=KF.j(a.ha);return $APP.k(b)?KF.j(a.ia):b};
hTa=function(a){var b=a.ha;a=a.ia;var c=hG.j(b);var d=hG.j(a);c=c>d?c:d;if($APP.k(KF.j(c)))return c;b=QF.A(b,c);a=QF.A(a,c);return iG.A(c,jG.j(kG.A(lG.j(b),lG.j(a))))};
kTa=function(a){var b=$APP.Lg(iTa,a);if($APP.k(b)){$APP.x.B(b,0,null);var c=$APP.x.B(b,1,null),d=$APP.x.B(b,2,null),g=$APP.x.B(b,3,null);$APP.x.B(b,4,null);a=$APP.x.B(b,5,null);var l=$APP.x.B(b,6,null),n=$APP.x.B(b,7,null),p=$APP.x.B(b,8,null);return dG(function(){var v=$APP.k($APP.k(d)?d:g)?fOa:eOa;return v.j?v.j(c):v.call(null,c)}(),($APP.Uc.A(a,"-")?-1:1)*($APP.k(l)?function(){var v=$APP.k($APP.k(n)?n:p)?fOa:eOa;return v.j?v.j(l):v.call(null,l)}():0))}throw $APP.Zi.A("invalid complex number",new $APP.f(null,
1,[jTa,a],null));};lTa=function(a,b){return dG(kG.A(a.ha,b.ha),kG.A(a.ia,b.ia))};mTa=function(a,b){return dG(RF.A(a.ha,b.ha),RF.A(a.ia,b.ia))};
pTa=function(a,b){if($APP.k(function(){var n=mG.j(a);n=$APP.k(n)?gG(b):n;if($APP.k(n))return n;n=gG(a);return $APP.k(n)?mG.j(b):n}()))return nTa;if($APP.k(function(){var n=mG.j(a);return $APP.k(n)?n:mG.j(b)}()))return oTa;var c=a.ha,d=a.ia,g=b.ha,l=b.ia;return $APP.k(function(){var n=KF.j(d);return $APP.k(n)?KF.j(l):n}())?iG.A(c,g):dG(RF.A(iG.A(c,g),iG.A(d,l)),kG.A(iG.A(c,l),iG.A(d,g)))};
rTa=function(a,b){if($APP.k(function(){var p=gG(a);p=$APP.k(p)?gG(b):p;if($APP.k(p))return p;p=mG.j(a);return $APP.k(p)?mG.j(b):p}()))return nTa;if($APP.k(function(){var p=mG.j(a);return $APP.k(p)?p:gG(b)}()))return oTa;if($APP.k(function(){var p=gG(a);return $APP.k(p)?p:mG.j(b)}()))return qTa;var c=a.ha,d=a.ia,g=b.ha,l=b.ia;if($APP.k(KF.j(l)))return dG(QF.A(c,g),QF.A(d,g));if(hG.j(g)<hG.j(l)){var n=QF.A(g,l);g=kG.A(iG.A(g,n),l);return dG(QF.A(kG.A(iG.A(c,n),d),g),QF.A(RF.A(iG.A(d,n),c),g))}n=QF.A(l,
g);g=kG.A(iG.A(l,n),g);return dG(QF.A(kG.A(c,iG.A(d,n)),g),QF.A(RF.A(d,iG.A(c,n)),g))};tTa=function(a,b){if($APP.k(KF.j(a)))a=$APP.k(KF.j(b.ia))?a:nTa;else{var c;if(c=$APP.Uc.A(nG,a))c=KF.j(b.ia),c=$APP.k(c)?CF(b.ha):c;a=$APP.k(c)?$APP.x.A(new $APP.H(null,4,5,$APP.I,[1,nG,-1,sTa],null),$APP.Od(b.ha,4)):oG.j(iG.A(b,pG.j(a)))}return a};
uTa=function(a){var b=a.ha,c=0<=b,d=a.ia,g=KF.j(d);if($APP.k($APP.k(g)?c:g))return dG(jG.j(b),0);g=hG.j(a);a=c?QF.A(jG.j(iG.A(2,kG.A(g,b))),2):QF.A(hG.j(d),jG.j(iG.A(2,RF.A(g,b))));b=c?QF.A(hG.j(d),jG.j(iG.A(2,kG.A(g,b)))):QF.A(jG.j(iG.A(2,RF.A(g,b))),2);return dG(a,$APP.k(qG.j(d))?PF.j(b):b)};vTa=function(a){return dG(pG.j(hTa(a)),rG.A(a.ia,a.ha))};
wTa=function(a){var b=a.ha;a=a.ia;var c=uTa(dG(RF.C(iG.A(a,a),iG.A(b,b),$APP.y([-1])),iG.C(-2,b,$APP.y([a]))));b=vTa(dG(RF.A(c.ha,a),kG.A(c.ia,b)));return dG(b.ia,PF.j(b.ha))};yTa=function(a){var b=a.ha;a=a.ia;var c=uTa(dG(RF.C(iG.A(a,a),iG.A(b,b),$APP.y([-1])),iG.C(-2,b,$APP.y([a]))));b=vTa(dG(RF.A(c.ha,a),kG.A(c.ia,b)));return dG(xTa-b.ia,b.ha)};
zTa=function(a){var b=a.ha,c=a.ia;if($APP.k(function(){var d=KF.j(b);return $APP.k(d)?sG.j(c):d}()))return dG(0,Infinity);if($APP.k(function(){var d=KF.j(b);return $APP.k(d)?sG.j(PF.j(c)):d}()))return dG(0,-Infinity);a=kG.A(iG.A(b,b),lG.j(RF.A(1,c)));a=vTa(dG(QF.A(RF.C(1,lG.j(c),$APP.y([lG.j(b)])),a),QF.A(iG.A(-2,b),a)));return dG(QF.A(a.ia,-2),QF.A(a.ha,2))};ATa=function(a){a=wTa(dG(a.ia,PF.j(a.ha)));return dG(PF.j(a.ia),a.ha)};
BTa=function(a){var b=yTa(a);a=b.ha;b=b.ia;return 0>b?dG(-b,a):dG(b,-a)};CTa=function(a){var b=a.ha;a=a.ia;var c=(c=1<b)?KF.j(a):c;var d=RF.A(1,b),g=kG.A(1,b),l=kG.A(lG.j(d),lG.j(a));b=$APP.k(KF.j(l))?dG(-1===b?0:QF.A(b,0),$APP.k(KF.j(a))?0:QF.A(a,0)):dG(QF.A(RF.A(iG.A(g,d),lG.j(a)),l),QF.A(kG.A(iG.A(a,d),iG.A(g,a)),l));return dG(QF.A(pG.j(hTa(b)),2),QF.A(rG.A(b.ia,b.ha),$APP.k(c)?-2:2))};DTa=function(a){return dG(NF.j(a.ha),tG.j(a.ia))};
ETa=function(a){return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,uG,null,1,null),new $APP.D(null,a,null,1,null))))};vG=function(a){return a instanceof cG};FTa=function(a){return vG(a)?wG.A($APP.Ca(Math.round(xD(a.ha))),$APP.Ca(Math.round(xD(a.ia)))):$APP.xd(a)?a:Math.round(xD(a))};GTa=function(a){return vG(a)?$APP.k(qG.j(a.ha))?PF.j(a):a:DF(a)?hG.j(a):AD("not supported!")};
HTa=function(a,b){if($APP.k(KF.j(a)))return b;if($APP.k(KF.j(b)))return a;if($APP.k(fG.A(a,b)))return GTa(a);var c=TF.j(a);c=$APP.k(c)?TF.j(b):c;if($APP.eb(c))return AD("gcd can only be computed for gaussian integers.");b=xG.j(a)>xG.j(b)?new $APP.H(null,2,5,$APP.I,[a,b],null):new $APP.H(null,2,5,$APP.I,[b,a],null);a=$APP.x.B(b,0,null);for(c=b=$APP.x.B(b,1,null);;){if($APP.k(KF.j(c)))return GTa(a);b=c;c=yG.A(a,MF.A(FTa(zG.A(a,c)),c));a=b}};
ITa=function(a,b){if($APP.k(KF.j(a)))return hG.j(b);var c;(c=$APP.k(KF.j(b)))||(c=fG.A(a,b),c=$APP.k(c)?c:fG.A(a,PF.j(b)),c=$APP.k(c));if(c)return hG.j(a);if(CF(a)&&CF(b))for(a=hG.j(a),c=hG.j(b);;){if($APP.k(KF.j(c)))return a;b=c;c=AG.A(a,c);a=b}else return 1};JTa=function(a){return a instanceof sF};KTa=function(){};
BG=function(a){if(null!=a&&null!=a.Lg)a=a.Lg(a);else{var b=BG[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=BG._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IRational.numerator",a);}return a};CG=function(a){if(null!=a&&null!=a.Kg)a=a.Kg(a);else{var b=CG[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=CG._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IRational.denominator",a);}return a};
LTa=function(a){a.F(null,new $APP.H(null,2,5,$APP.I,[sF,DG],null),function(b,c){b=uF(b);return a.A?a.A(b,c):a.call(null,b,c)});a.F(null,new $APP.H(null,2,5,$APP.I,[DG,sF],null),function(b,c){c=uF(c);return a.A?a.A(b,c):a.call(null,b,c)})};
MTa=function(a){a.F(null,new $APP.H(null,2,5,$APP.I,[sF,EG],null),function(b,c){c=new sF(BigInt(c),xF);return a.A?a.A(b,c):a.call(null,b,c)});a.F(null,new $APP.H(null,2,5,$APP.I,[EG,sF],null),function(b,c){b=new sF(BigInt(b),xF);return a.A?a.A(b,c):a.call(null,b,c)})};NTa=function(a,b){return $APP.k(fG.A(b,a))?NF.j(b):$APP.k(fG.A(b,PF.j(a)))?PF.j(NF.j(b)):$APP.k(sG.j(b))?a:$APP.k(sG.j(PF.j(b)))?PF.j(a):null};OTa=function(a,b){a=0>a?-a:a;for(b=0>b?-b:b;;){if(0==b)return a;var c=a%b;a=b;b=c}};
PTa=function(a,b){for(var c=$APP.Fs;;){var d=b.fd(1);if($APP.eb(b.Ve()))b=d,a=a.multiply(a);else{if($APP.k(d.Rb()))return a.multiply(c);b=d;c=a.multiply(c);a=a.multiply(a)}}};QTa=function(a,b){for(var c=$APP.Ha;;){var d=b.fd(1);if($APP.eb(b.Ve()))b=d,a=a.multiply(a);else{if($APP.k(d.Rb()))return a.multiply(c);b=d;c=a.multiply(c);a=a.multiply(a)}}};
RTa=function(a){return function(){function b(c){if(0<arguments.length)for(var d=0,g=Array(arguments.length-0);d<g.length;)g[d]=arguments[d+0],++d;return a}b.G=0;b.K=function(c){$APP.r(c);return a};b.C=function(){return a};return b}()};
$Ta=function(a){var b=$APP.Lf.A($APP.sf,$APP.Nn.A(a+1,$APP.Nj)),c=$APP.gd(b),d=$APP.fd(b),g=$APP.Nj.J();return $APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.J()))),null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j($APP.Uj.A(a+1,0))))),null,1,null)))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,STa,null,1,null))))),null,1,null),new $APP.D(null,
$APP.T.j($APP.r($APP.N.C(new $APP.D(null,TTa,null,1,null),new $APP.D(null,FG,null,1,null),$APP.y([new $APP.D(null,STa,null,1,null)])))),null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,b,null,1,null),new $APP.D(null,g,null,1,null))))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.fm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j($APP.bf.C(function(l){return $APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,
UTa,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,FG,null,1,null),new $APP.D(null,l,null,1,null),$APP.y([new $APP.D(null,g,null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,g,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Rh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,VTa,null,1,null),new $APP.D(null,GG,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,WTa,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
XTa,null,1,null),new $APP.D(null,$APP.z(l,new $APP.f(null,1,[$APP.sj,$APP.my],null)),null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,XTa,null,1,null),new $APP.D(null,$APP.z(g,new $APP.f(null,1,[$APP.sj,$APP.my],null)),null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,$APP.Su,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,WTa,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,YTa,null,1,null),new $APP.D(null,
ZTa,null,1,null),$APP.y([new $APP.D(null,l,null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,YTa,null,1,null),new $APP.D(null,ZTa,null,1,null),$APP.y([new $APP.D(null,g,null,1,null)])))),null,1,null)])))),null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,FG,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iy,null,1,null),new $APP.D(null,l,null,1,null),$APP.y([new $APP.D(null,UTa,null,
1,null)])))),null,1,null),$APP.y([new $APP.D(null,g,null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,FG,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iy,null,1,null),new $APP.D(null,g,null,1,null),$APP.y([new $APP.D(null,UTa,null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,l,null,1,null)])))),null,1,null)])))),null,1,null),new $APP.D(null,l,null,1,null),new $APP.D(null,UTa,null,1,null)])))))},$APP.y([c])))))),null,1,null),$APP.y([new $APP.D(null,
$APP.tf($APP.T.j($APP.r($APP.N.A(c,new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,FG,null,1,null),new $APP.D(null,d,null,1,null),$APP.y([new $APP.D(null,g,null,1,null)])))),null,1,null))))),null,1,null)])))),null,1,null)))),null,1,null)])))))};aUa=function(a,b){return $APP.k(b)?function(c,d){return $APP.k(b.j?b.j(c):b.call(null,c))?$APP.Mc(c):a.A?a.A(c,d):a.call(null,c,d)}:a};
bUa=function(a,b,c,d){return function(){function g(n,p){for(var v=$APP.Nd(0),t=$APP.Nd(0),A=$APP.bc($APP.sf);;){var B=$APP.x.B(n,v,null),G=$APP.x.B(p,t,null);if($APP.eb(B))return $APP.Lf.A($APP.dc(A),$APP.oi.A(p,t));if($APP.eb(G))return $APP.Lf.A($APP.dc(A),$APP.oi.A(n,v));var J=B,O=$APP.x.B(J,0,null);J=$APP.x.B(J,1,null);var Q=G,W=$APP.x.B(Q,0,null);Q=$APP.x.B(Q,1,null);W=a.A?a.A(O,W):a.call(null,O,W);$APP.k(c.j?c.j(W):c.call(null,W))?(B=b.A?b.A(J,Q):b.call(null,J,Q),v+=1,t+=1,A=$APP.k(c.j?c.j(B):
c.call(null,B))?A:$APP.mf.A(A,d.A?d.A(O,B):d.call(null,O,B))):0>W?(v+=1,A=$APP.mf.A(A,B)):(t+=1,A=$APP.mf.A(A,G))}}var l=null;l=function(n,p){switch(arguments.length){case 0:return $APP.sf;case 1:return n;case 2:return g.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.J=function(){return $APP.sf};l.j=function(n){return n};l.A=g;return l}()};
HG=function(a,b){const c=Array.prototype.slice.call(arguments),d=c.shift();if("undefined"==typeof d)throw Error("[goog.string.format] Template required");return d.replace(/%([0\- \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g,function(g,l,n,p,v,t,A,B){if("%"==t)return"%";const G=c.shift();if("undefined"==typeof G)throw Error("[goog.string.format] Not enough arguments");arguments[0]=G;return HG.ld[t].apply(null,arguments)})};cUa=function(a){return"string"===typeof a?$APP.Uc.A(a,"")?null:a:null};
dUa=function(a){return"number"===typeof a?$APP.Nd(a):"string"===typeof a?(a=parseInt(a,10),$APP.k(isNaN(a))?null:a):null};eUa=function(a,b,c){return $APP.Vs.M($APP.Ot.j(2),$APP.Us.j(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return a.B?a.B(d,l,g):a.call(null,d,l,g)}),b,c)};fUa=function(a){return function(b,c){b=a.j?a.j(c):a.call(null,c);return $APP.k(b)?$APP.Mc(b):null}};gUa=function(a,b){return $APP.Id.B(fUa(a),null,b)};
jUa=function(a){a=$APP.qi.B($APP.m.j(a),/-/,2);var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);b=$APP.Oca(/\d+/,b);b=$APP.k(b)?$APP.Fl.A(dUa,b):null;return new $APP.f(null,2,[hUa,b,iUa,$APP.k(a)?$APP.mi(a):null],null)};kUa=function(a){return 1<$APP.Tc(a)?$APP.oi.A(a,1):$APP.sf};IG=function(a){return Math.random()<=a};lUa=function(a,b){this.n=a;this.Vg=b};mUa=function(a,b){this.n=a;this.oh=b};nUa=function(a,b,c){this.ca=a;this.ej=b;this.th=c};
oUa=function(a){if($APP.md(a))return $APP.Jd(function(c,d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return $APP.rg.B(c,d,new lUa(l,g))},$APP.F,a);if($APP.od(a)){var b=$APP.Pe(-1);return $APP.Id.B(function(c,d){var g=$APP.x.B(d,0,null),l=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return $APP.rg.B(c,$APP.k(d)?d:b.mc(null,b.Wa(null)+1),new lUa(g,l))},$APP.F,a)}throw $APP.Zi.A("[encore/cond!] No matching clause",$APP.F);};
wUa=function(a){function b(t,A){var B=(new Date).getTime();t=n.j?n.j(t):n.call(null,t);$APP.k(function(){var W=$APP.eb(A);return W?IG.j?IG.j(v):IG.call(null,v):W}())&&($APP.Ne(c,null),$APP.lh.A(d,function(W){return $APP.dc($APP.Jd(function(Z,fa,ha){ha=$APP.Jd(function(ja,ta,ua){var ca=$APP.C.A(g,ta);return $APP.k(ca)?B>=ua.oh+ca.Vg?$APP.Oi.A(ja,ta):ja:$APP.Oi.A(ja,ta)},ha,ha);return $APP.hd(ha)?$APP.rt.A(Z,fa):$APP.Nf.B(Z,fa,ha)},$APP.bc($APP.k(W)?W:$APP.F),W))}));for(;;){var G=$APP.Fb(d),J=$APP.C.A(G,
t),O=null==J?null:$APP.Jd(function(W,Z,fa,ha,ja,ta,ua){return function(ca,V,da){var Y=$APP.C.A(ua,V);if($APP.k(Y)){if(da.n<Y.n)return ca;da=da.oh+Y.Vg-fa;return 0>=da?ca:null==ca?new nUa($APP.pe([V,da]),V,da):da>ca.th?new nUa($APP.rg.B(ca.ca,V,da),V,da):new nUa($APP.rg.B(ca.ca,V,da),ca.ej,ca.th)}return ca}}(G,J,B,t,c,d,g,null,l,n,p,IG,v),null,J);if($APP.k($APP.k(A)?A:O)){var Q=O;return $APP.k(Q)?(t=Q,new $APP.H(null,3,5,$APP.I,[t.ej,t.th,t.ca],null)):null}Q=$APP.Fb(c);$APP.k(Q)||(J=$APP.Jd(function(W,
Z,fa,ha,ja){return function(ta,ua,ca){var V=$APP.rg.B;var da=$APP.C.A(fa,ua);if($APP.k(da)){var Y=da.oh;ca=ja>=Y+ca.Vg?new mUa(1,ja):new mUa(da.n+1,Y)}else ca=new mUa(1,ja);return V.call($APP.rg,ta,ua,ca)}}(Q,G,J,O,B,t,c,d,g,null,l,n,p,IG,v),J,g),$APP.Ne(d,$APP.rg.B(G,t,J)));return null}}if($APP.hd(a))return new $APP.H(null,2,5,$APP.I,[null,$APP.Le(null)],null);var c=$APP.kh.j(null),d=$APP.kh.j(null),g=oUa(a),l=$APP.qe(null),n=$APP.C.B(l,pUa,$APP.Kd),p=$APP.C.B(l,qUa,16E3),v=1/$APP.Nd(p);return new $APP.H(null,
2,5,$APP.I,[d,function(){function t(J,O){if($APP.k($APP.$d.A?$APP.$d.A(J,rUa):$APP.$d.call(null,J,rUa)))return $APP.k($APP.$d.A?$APP.$d.A(O,sUa):$APP.$d.call(null,O,sUa))?$APP.Ne(d,null):$APP.lh.B(d,$APP.Oi,n.j?n.j(O):n.call(null,O)),null;if($APP.k($APP.$d.A?$APP.$d.A(J,tUa):$APP.$d.call(null,J,tUa)))return b(O,!0);throw $APP.Zi.A("[encore/limiter*] Unexpected limiter command",new $APP.f(null,2,[uUa,new $APP.f(null,2,[$APP.fw,J,$APP.Ti,$APP.hb(J)],null),vUa,O],null));}function A(J){return b(J,!1)}
function B(){return b(null,!1)}var G=null;G=function(J,O){switch(arguments.length){case 0:return B.call(this);case 1:return A.call(this,J);case 2:return t.call(this,J,O)}throw Error("Invalid arity: "+arguments.length);};G.J=B;G.j=A;G.A=t;return G}()],null)};xUa=function(a){return void 0===a||null==a?"nil":a};JG=function(){return!0};KG=function(){return!1};LG=function(a){return $APP.qg.A(-1,a.indexOf("*"))?$APP.Pg($APP.ki($APP.ki(["^",$APP.m.j(a),"$"].join(""),".","\\."),"*","(.*)")):null};
MG=function(a,b){for(;;){if($APP.k(function(){var t=new $APP.ug(null,new $APP.f(null,2,["*",null,yUa,null],null),null);return t.j?t.j(a):t.call(null,a)}()))return JG;if($APP.k(function(){var t=$APP.wg([$APP.sf,$APP.vg,$APP.Nfa]);return t.j?t.j(a):t.call(null,a)}()))return KG;if(a instanceof RegExp)return function(t){return function(A){return $APP.Mg(t,A)}}(a,b,JG,KG,LG);if("string"===typeof a){var c=LG(a);if($APP.k(c)){var d=b;a=c;b=d}else return function(t){return function(A){return $APP.Uc.A(A,
t)}}(a,b,c,JG,KG,LG)}else if($APP.od(a)||$APP.jd(a)){if($APP.k(function(){var t=$APP.yg(a);return t.j?t.j("*"):t.call(null,"*")}()))return JG;if($APP.Uc.A($APP.Tc(a),1))c=$APP.u(a),d=b,a=c,b=d;else{var g=$APP.Id.B(function(t,A,B,G,J){return function(O,Q){var W=$APP.x.B(O,0,null);O=$APP.x.B(O,1,null);var Z=Q instanceof RegExp?Q:J(Q);return $APP.k(Z)?new $APP.H(null,2,5,$APP.I,[W,$APP.Vd.A(O,Z)],null):new $APP.H(null,2,5,$APP.I,[$APP.Vd.A(W,Q),O],null)}}(a,b,JG,KG,LG),new $APP.H(null,2,5,$APP.I,[$APP.vg,
$APP.sf],null),a),l=$APP.x.B(g,0,null),n=$APP.x.B(g,1,null),p=$APP.re(l),v=function(){var t=$APP.re(n);return $APP.k(t)?(t=function(A,B,G,J,O,Q,W,Z,fa,ha,ja){return function(ta){return gUa(function(){return function(ua){return $APP.Mg(ua,ta)}}(A,B,G,J,O,Q,W,Z,fa,ha,ja),G)}}(a,b,t,t,g,l,n,p,JG,KG,LG),$APP.k(b)?$APP.mh(t):t):null}();if($APP.k(function(){var t=p;return $APP.k(t)?v:t}()))return function(t,A,B,G,J,O,Q){return function(W){var Z=O.j?O.j(W):O.call(null,W);return $APP.k(Z)?Z:Q.j?Q.j(W):Q.call(null,
W)}}(a,b,g,l,n,p,v,JG,KG,LG);if($APP.k(p))return p;if($APP.k(v))return v;throw $APP.Zi.A("[encore/cond!] No matching clause",$APP.F);}}else throw $APP.Zi.A("[enc/compile-str-filter] Unexpected spec type",new $APP.f(null,1,[zUa,new $APP.f(null,2,[$APP.fw,a,$APP.Ti,$APP.hb(a)],null)],null));}};
FUa=function(a){for(;;){if($APP.md(a)){var b=$APP.C.A(a,AUa),c=function(){var n=$APP.C.A(a,$APP.Vm);return $APP.k(n)?n:$APP.C.A(a,BUa)}(),d=function(){var n=$APP.C.A(a,$APP.xn);return $APP.k(n)?n:$APP.C.A(a,CUa)}(),g=function(){var n=c;return $APP.k(n)?MG(n,b):null}(),l=function(){var n=d;return $APP.k(n)?MG(n,b):null}();if($APP.Uc.A(l,JG)||$APP.Uc.A(g,KG))return KG;if($APP.k(function(){var n=g;return $APP.k(n)?l:n}()))return function(n,p,v,t,A,B){return function(G){G=$APP.m.j(G);return $APP.k(A.j?
A.j(G):A.call(null,G))?$APP.k(B.j?B.j(G):B.call(null,G))?!1:!0:!1}}(a,b,c,d,g,l,JG,KG,LG,MG);if($APP.k(g))return $APP.Uc.A(g,JG)?JG:function(n,p,v,t,A){return function(B){B=$APP.m.j(B);B=A.j?A.j(B):A.call(null,B);return $APP.k(B)?!0:!1}}(a,b,c,d,g,l,JG,KG,LG,MG);if($APP.k(l))return $APP.Uc.A(l,KG)?JG:function(n,p,v,t,A,B){return function(G){G=$APP.m.j(G);G=B.j?B.j(G):B.call(null,G);return $APP.k(G)?!1:!0}}(a,b,c,d,g,l,JG,KG,LG,MG);throw $APP.Zi.A("[encore/compile-str-filter] `allow-spec` and `deny-spec` cannot both be nil",
new $APP.f(null,2,[DUa,c,EUa,d],null));}a=new $APP.f(null,2,[$APP.Vm,a,$APP.xn,null],null)}};HUa=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=0<b.length?new $APP.Bc(b.slice(0),0,null):null;return GUa(b)};GUa=function(a){$APP.x.B(a,0,null);return new $APP.f(null,2,[IUa,!0,$APP.Fk,function(b){b=$APP.qe(b);b=$APP.C.A(b,JUa);return $APP.Wt.C($APP.y([$APP.dh(b)]))}],null)};
LUa=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=0<b.length?new $APP.Bc(b.slice(0),0,null):null;return KUa(b)};
KUa=function(a){$APP.x.B(a,0,null);return new $APP.f(null,2,[IUa,!0,$APP.Fk,"undefined"===typeof console?function(){return null}:function(){function b(c){var d=function(){var g=c instanceof $APP.E?c.ga:null;switch(g){case "trace":return console.trace;case "debug":return console.debug;case "info":return console.info;case "warn":return console.warn;case "error":return console.error;case "fatal":return console.error;case "report":return console.info;default:throw Error(["No matching clause: ",$APP.m.j(g)].join(""));
}}();return $APP.k(d)?d:console.log}return function(c){var d=b($APP.Zu.j(c));if($APP.k(d)){if($APP.k(function(){var n=$APP.C.A(c,MUa);return $APP.k(n)?n:$APP.Zl.A(c,new $APP.H(null,2,5,$APP.I,[NUa,MUa],null))}())){var g=function(){var n=$APP.rg.C(c,OUa,"",$APP.y([NG,null])),p=OG.j(c);return p.j?p.j(n):p.call(null,n)}(),l=function(){var n=PG.j(c),p=NG.j(c);return $APP.k(p)?$APP.Yd(g,$APP.Yd(p,n)):$APP.Yd(g,n)}();return d.apply(console,$APP.Cn.j(l))}return d.call(console,$APP.dh(JUa.j(c)))}return null}}()],
null)};PUa=function(a,b,c,d,g){a=new Date(a,b,c);g=g||0;return a.valueOf()+864E5*(((void 0!==d?d:3)-g+7)%7-((a.getDay()+6)%7-g+7)%7)};QUa=function(){};
SUa=function(a){if("number"==typeof a){var b=new QUa;b.Tf=a;var c=a;if(0==c)c="Etc/GMT";else{var d=["Etc/GMT",0>c?"-":"+"];c=Math.abs(c);d.push(Math.floor(c/60)%100);c%=60;0!=c&&d.push(":",nD(c,2));c=d.join("")}b.kh=c;c=a;0==c?c="UTC":(d=["UTC",0>c?"+":"-"],c=Math.abs(c),d.push(Math.floor(c/60)%100),c%=60,0!=c&&d.push(":",c),c=d.join(""));a=RUa(a);b.nh=[c,c];b.be={hl:a,xh:a};b.Vf=[];return b}b=new QUa;b.kh=a.id;b.Tf=-a.std_offset;b.nh=a.names;b.be=a.names_ext;b.Vf=a.transitions;return b};
RUa=function(a){var b=["GMT"];b.push(0>=a?"+":"-");a=Math.abs(a);b.push(nD(Math.floor(a/60)%100,2),":",nD(a%60,2));return b.join("")};QG=function(a,b){b=Date.UTC(b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate(),b.getUTCHours(),b.getUTCMinutes())/36E5;for(var c=0;c<a.Vf.length&&b>=a.Vf[c];)c+=2;return 0==c?0:a.Vf[c-1]};WUa=function(a){this.Kf=[];this.Jb=TUa;"number"==typeof a?UUa(this,a):VUa(this,a)};RG=function(a){return a.getHours?a.getHours():0};
VUa=function(a,b){for(XUa&&(b=b.replace(/\u200f/g,""));b;){const c=b;for(let d=0;d<YUa.length;++d){const g=b.match(YUa[d]);if(g){let l=g[0];b=b.substring(l.length);0==d&&("''"==l?l="'":(l=l.substring(1,"'"==g[1]?l.length-1:l.length),l=l.replace(/''/g,"'")));a.Kf.push({text:l,type:d});break}}if(c===b)throw Error("Malformed pattern part: "+b);}};
UUa=function(a,b){let c;if(4>b)c=a.Jb.uh[b];else if(8>b)c=a.Jb.yh[b-4];else if(12>b)c=a.Jb.gj[b-8],c=c.replace("{1}",a.Jb.uh[b-8]),c=c.replace("{0}",a.Jb.yh[b-8]);else{UUa(a,10);return}VUa(a,c)};SG=function(a,b){{b=String(b);const c=a.Jb||TUa;if(void 0!==c.yj){a=[];for(let d=0;d<b.length;d++){const g=b.charCodeAt(d);a.push(48<=g&&57>=g?String.fromCharCode(c.yj+g-48):b.charAt(d))}b=a.join("")}}return b};
TG=function(a){if(!(a.getHours&&a.getSeconds&&a.getMinutes))throw Error("The date to format has no time (probably a goog.date.Date). Use Date or goog.date.DateTime, or use a pattern without time fields.");};
ZUa=function(a,b,c,d,g,l){var n=b.length;switch(b.charAt(0)){case "G":return c=0<d.getFullYear()?1:0,4<=n?a.Jb.ij[c]:a.Jb.jj[c];case "y":return c=d.getFullYear(),0>c&&(c=-c),2==n&&(c%=100),SG(a,nD(c,n));case "Y":return c=(new Date(PUa(d.getFullYear(),d.getMonth(),d.getDate(),a.Jb.wh,a.Jb.vh))).getFullYear(),0>c&&(c=-c),2==n&&(c%=100),SG(a,nD(c,n));case "M":a:switch(c=d.getMonth(),n){case 5:n=a.Jb.lj[c];break a;case 4:n=a.Jb.kj[c];break a;case 3:n=a.Jb.oj[c];break a;default:n=SG(a,nD(c+1,n))}return n;
case "k":return TG(g),SG(a,nD(RG(g)||24,n));case "S":return SG(a,(g.getMilliseconds()/1E3).toFixed(Math.min(3,n)).substr(2)+(3<n?nD(0,n-3):""));case "E":return c=d.getDay(),4<=n?a.Jb.xj[c]:a.Jb.qj[c];case "a":return TG(g),n=RG(g),a.Jb.fj[12<=n&&24>n?1:0];case "h":return TG(g),SG(a,nD(RG(g)%12||12,n));case "K":return TG(g),SG(a,nD(RG(g)%12,n));case "H":return TG(g),SG(a,nD(RG(g),n));case "c":a:switch(c=d.getDay(),n){case 5:n=a.Jb.tj[c];break a;case 4:n=a.Jb.wj[c];break a;case 3:n=a.Jb.vj[c];break a;
default:n=SG(a,nD(c,1))}return n;case "L":a:switch(c=d.getMonth(),n){case 5:n=a.Jb.sj[c];break a;case 4:n=a.Jb.rj[c];break a;case 3:n=a.Jb.uj[c];break a;default:n=SG(a,nD(c+1,n))}return n;case "Q":return c=Math.floor(d.getMonth()/3),4>n?a.Jb.pj[c]:a.Jb.mj[c];case "d":return SG(a,nD(d.getDate(),n));case "m":return TG(g),SG(a,nD(g.getMinutes(),n));case "s":return TG(g),SG(a,nD(g.getSeconds(),n));case "v":return n=l||SUa(c.getTimezoneOffset()),n.kh;case "V":return a=l||SUa(c.getTimezoneOffset()),2>=
n?a.kh:0<QG(a,c)?void 0!==a.be.hj?a.be.hj:a.be.DST_GENERIC_LOCATION:void 0!==a.be.xh?a.be.xh:a.be.STD_GENERIC_LOCATION;case "w":return c=PUa(g.getFullYear(),g.getMonth(),g.getDate(),a.Jb.wh,a.Jb.vh),SG(a,nD(Math.floor(Math.round((c-(new Date((new Date(c)).getFullYear(),0,1)).valueOf())/864E5)/7)+1,n));case "z":return a=l||SUa(c.getTimezoneOffset()),4>n?a.nh[0<QG(a,c)?2:0]:a.nh[0<QG(a,c)?3:1];case "Z":return b=l||SUa(c.getTimezoneOffset()),4>n?(n=-(b.Tf-QG(b,c)),a=[0>n?"-":"+"],n=Math.abs(n),a.push(nD(Math.floor(n/
60)%100,2),nD(n%60,2)),n=a.join("")):n=SG(a,RUa(b.Tf-QG(b,c))),n;default:return""}};$Ua=function(a){switch(a instanceof $APP.E?a.ga:null){case "trace":return 0;case "debug":return 1;case "info":return 2;case "warn":return 3;case "error":return 4;case "fatal":return 5;case "report":return 6;default:return null}};
bVa=function(a){if($APP.k($Ua(a)))return a;throw $APP.Zi.A("Invalid Timbre logging level: should be e/o #{:trace :debug :info :warn :error :fatal :report}",new $APP.f(null,2,[aVa,a,$APP.Ti,$APP.hb(a)],null));};UG=function(a){var b=$Ua(a);if($APP.k(b))return b;throw $APP.Zi.A("Invalid Timbre logging level: should be e/o #{:trace :debug :info :warn :error :fatal :report}",new $APP.f(null,2,[aVa,a,$APP.Ti,$APP.hb(a)],null));};
cVa=function(a,b){return(UG.j?UG.j(a):UG.call(null,a))>=(UG.j?UG.j(b):UG.call(null,b))};eVa=function(a,b){a=$APP.k($APP.cd.j?$APP.cd.j(a):$APP.cd.call(null,a))?a.j?a.j(b):a.call(null,b):dVa(a,b);return $APP.k(a)?!0:!1};gVa=function(a,b,c){b=$APP.od(b)?fVa(b,c):b;a=$APP.k(b)?b:a;return bVa.j?bVa.j(a):bVa.call(null,a)};hVa=function(a){if($APP.k(a)){var b=$APP.wg([$APP.sf,$APP.vg]);b=b.j?b.j(a):b.call(null,a);a=$APP.k(b)?null:a}else a=null;return a};
iVa=function(a,b){a=hVa(a);b=hVa(b);return $APP.k($APP.k(a)?a:b)?new $APP.f(null,2,[$APP.Vm,a,$APP.xn,b],null):null};
oVa=function(a,b,c,d){var g=$APP.k(d)?d:jVa;d=function(){var l=$APP.C.A(g,kVa);l=$APP.k(l)?l:$APP.C.A(g,$APP.Zu);return gVa.B?gVa.B(a,l,c):gVa.call(null,a,l,c)}();return $APP.k(cVa.A?cVa.A(b,d):cVa.call(null,b,d))?(b=function(){var l=$APP.C.A(g,lVa);if($APP.k(l))return l;l=$APP.C.A(g,mVa);var n=$APP.C.A(g,nVa);return iVa.A?iVa.A(l,n):iVa.call(null,l,n)}(),$APP.k(b)?$APP.k(eVa.A?eVa.A(b,c):eVa.call(null,b,c))?!0:!1:!0):!1};pVa=function(a){return null==a?"nil":"string"===typeof a?a:$APP.jh.C($APP.y([a]))};
uVa=function(a){var b=$APP.qe(a),c=$APP.C.A(b,qVa),d=$APP.C.A(b,rVa);a=$APP.C.A(b,PG);b=$APP.C.A(b,VG);b=$APP.qe(b);b=$APP.C.B(b,sVa,pVa);if($APP.Uc.A(null,c))return"";if($APP.Uc.A(WG,c))return d=$APP.Vg.j(b),$APP.k($APP.k(" ")?$APP.qg.A(" ",""):" ")?(c=$APP.Ri.j(" "),b=$APP.Us.A(tVa,$APP.m),a=$APP.k(d)?$APP.Vs.B($APP.Hl.A(d,c),b,a):$APP.Vs.B(c,b,a)):a=$APP.k(d)?$APP.Vs.B(d,$APP.Us.A(tVa,$APP.m),a):$APP.m.j($APP.Id.A(tVa,a)),a;if($APP.Uc.A($APP.Dy,c)){if("string"===typeof d)return null==d?a="":(a=
$APP.k(xUa)?$APP.Fl.A(xUa,a):a,a=$APP.Je.B(HG,d,a)),a;throw $APP.Zi.A("Timbre format-style logging call without a format pattern string",new $APP.f(null,3,[rVa,d,$APP.Ti,$APP.hb(d),PG,a],null));}throw Error(["No matching clause: ",$APP.m.j(c)].join(""));};
vVa=function(a){var b=$APP.$d.A?$APP.$d.A(XG,XG):$APP.$d.call(null,XG,XG),c=$APP.$d.A?$APP.$d.A(WG,$APP.Dy):$APP.$d.call(null,WG,$APP.Dy),d=$APP.x.B(a,0,null);if($APP.k($APP.k(b)?d instanceof Error:b)){var g=d,l=null,n=kUa(a);a=$APP.k(c)?$APP.x.B(n,0,null):null;c=$APP.k(c)?kUa(n):n;return new $APP.H(null,4,5,$APP.I,[g,l,a,c],null)}l=$APP.k(function(){var v=$APP.md(d);return v?$APP.h.j($APP.ed(d)):v}())?d:null;g=function(){var v=$APP.Mx.j(l);return $APP.k(v)?v:$APP.k(b)?null:XG}();var p=$APP.Oi.A(l,
$APP.Mx);n=$APP.k(p)?kUa(a):a;a=$APP.k(c)?$APP.x.B(n,0,null):null;c=$APP.k(c)?kUa(n):n;return new $APP.H(null,4,5,$APP.I,[g,p,a,c],null)};AVa=function(a,b){return function(c){try{return b.j?b.j(c):b.call(null,c)}catch(v){var d=v,g=$APP.qe(c),l=$APP.C.A(g,$APP.Zu),n=$APP.C.A(g,wVa),p=$APP.C.A(g,xVa);g=$APP.C.A(g,yVa);throw $APP.Zi.B(a,new $APP.f(null,4,[$APP.Zu,l,$APP.ly,c,zVa,[$APP.m.j($APP.k(n)?n:$APP.k(p)?p:"?"),":",$APP.m.j($APP.k(g)?g:"?")].join(""),OG,b],null),d);}}};
$G=function(a,b,c,d,g){var l=jVa;if(oVa(BVa,a,b,l)){var n=new Date;d=$APP.Fb(d);d=vVa(d);var p=$APP.x.B(d,0,null),v=$APP.x.B(d,1,null),t=$APP.x.B(d,2,null);d=$APP.x.B(d,3,null);c=$APP.Vd.A($APP.k(null)?null:$APP.F,$APP.fg([CVa,DVa,EVa,PG,xVa,FVa,wVa,$APP.Zu,qVa,NG,IE,yVa,GVa,NUa,rVa],[n,null,l,d,null,function(){var W=new $APP.ug(null,new $APP.f(null,2,[HVa,null,$APP.ew,null],null),null);return W.j?W.j(a):W.call(null,a)}(),b,a,WG,p,null,c,new $APP.bh(function(){return p},null),v,t]));c=$APP.Id.B(function(W,
Z){W=Z.j?Z.j(W):Z.call(null,W);return null==W?$APP.Mc(null):W},c,$APP.C.A(l,IVa));if($APP.k(c)){n=$APP.qe(c);var A=$APP.C.A(n,PG),B=$APP.rg.B(c,JVa,new $APP.bh(function(){return A},null)),G=YG.C(B,OUa,new $APP.bh(function(){return AVa("Timbre error when calling (msg-fn \x3cdata\x3e)",uVa)(B)},null),$APP.y([KVa,new $APP.bh(function(){return $APP.yc(function(){var W=$APP.C.A(v,$APP.Wl);if($APP.k(W))return new $APP.H(null,3,5,$APP.I,[W,g,a],null);W=$APP.C.A(v,LVa);if($APP.k(W))return W;W=$APP.C.A(v,
MVa);return $APP.k(W)?new $APP.H(null,4,5,$APP.I,[W,g,t,a],null):new $APP.H(null,4,5,$APP.I,[A,g,t,a],null)}())},null)])),J=function(){var W=$APP.mh(function(fa){return new $APP.bh(function(){var ha=$APP.C.A(G,CVa),ja=$APP.qe(fa);ja=$APP.C.A(ja,NVa);return $APP.k($APP.$d.A?$APP.$d.A(ja,OVa):$APP.$d.call(null,ja,OVa))?(new Date(ha)).toISOString():(new WUa(ja)).format(ha)},null)}),Z=new $APP.bh(function(){return $APP.Vd.A(PVa,$APP.C.A(l,QVa))},null);return function(fa){var ha=(ha=null==fa)?ha:$APP.$d.A?
$APP.$d.A(fa,RVa):$APP.$d.call(null,fa,RVa);return $APP.k(ha)?W($APP.Fb(Z)):W($APP.Vd.A($APP.Fb(Z),fa))}}(),O=function(){var W=$APP.mh($APP.C.B(l,OG,ZG));return function(Z){var fa=(fa=null==Z)?fa:$APP.$d.A?$APP.$d.A(Z,RVa):$APP.$d.call(null,Z,RVa);return AVa("Timbre error when calling (output-fn \x3cdata\x3e)",$APP.k(fa)?W:Z)}}(),Q=$APP.C.A(l,VG);$APP.Jd(function(W,Z,fa){if($APP.k(function(){var da=$APP.C.A(fa,IUa);return $APP.k(da)?oVa(SVa,a,b,fa):da}())){var ha=$APP.C.A(fa,TVa);if(function(){var da=
$APP.hd(ha);if(da)return da;da=UVa(Z,ha);var Y=$APP.dh($APP.C.A(G,KVa));da=da.j?da.j(Y):da.call(null,Y);return $APP.eb(da)}()){var ja=$APP.qe(fa);W=$APP.C.A(ja,$APP.Fk);$APP.C.A(ja,VVa);var ta=J($APP.C.A(fa,QVa)),ua=O($APP.C.A(fa,OG)),ca=function(){var da=$APP.C.A(fa,VG);return $APP.k(da)?da:Q}(),V=$APP.Vd.A(G,new $APP.f(null,6,[WVa,Z,XVa,fa,VG,ca,OG,ua,JUa,new $APP.bh(function(){var da=$APP.rg.C(G,YVa,ta,$APP.y([VG,ca]));return ua.j?ua.j(da):ua.call(null,da)},null),YVa,ta],null));ja=function(){var da=
$APP.C.A(fa,ZVa);return $APP.k(da)?da.j?da.j(V):da.call(null,V):V}();return $APP.k(ja)?W.j?W.j(ja):W.call(null,ja):null}}return null},null,$APP.C.A(l,$Va))}}return null};aH=function(a){return function(b){return $APP.td(b)&&$APP.Uc.A($APP.u.j?$APP.u.j(b):$APP.u.call(null,b),a)}};aWa=function(a){var b=$APP.td(a);return b?(b=bH($APP.u.j?$APP.u.j(a):$APP.u.call(null,a)),$APP.k(b)?$APP.Uc.A(cH,$APP.Xc($APP.u.j?$APP.u.j(a):$APP.u.call(null,a))):b):b};
dH=function(a,b){var c=b instanceof $APP.q?function(d){return new $APP.D(null,b,new $APP.D(null,d,null,1,null),2,null)}:b;return function(d){if(EF(d)){var g=a.j?a.j(d):a.call(null,d);return $APP.eb(TF.j(d))?g:$APP.k(TF.j(g))?g:c.j?c.j(d):c.call(null,d)}return c.j?c.j(d):c.call(null,d)}};bWa=function(a,b,c,d){return EF(a)&&EF(b)?c.A?c.A(a,b):c.call(null,a,b):$APP.Uc.A(a,b)?0:$APP.k(KF.j(a))?0:$APP.k(sG.j(b))?a:new $APP.D(null,d,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)};
gH=function(a,b){return EF(a)&&EF(b)?eH.A(a,b):EF(a)?$APP.k(KF.j(a))?b:$APP.k(fH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):EF(b)?$APP.k(KF.j(b))?a:$APP.k(fH(a))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,
a),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.k(fH(a))?$APP.k(fH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a),$APP.y([new $APP.D(null,
b,null,1,null)])))):$APP.k(fH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))};
cWa=function(a,b){return EF(a)&&EF(b)?yG.A(a,b):EF(a)?$APP.k(KF.j(a))?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Gv,null,1,null),new $APP.D(null,b,null,1,null)))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Gv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):EF(b)?$APP.k(KF.j(b))?a:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Gv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.Uc.A(a,b)?0:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.Gv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))};dWa=function(a){return cWa(0,a)};
iH=function(a,b){return EF(a)&&EF(b)?MF.A(a,b):EF(a)?$APP.k(KF.j(a))?a:$APP.k(sG.j(a))?b:$APP.k(hH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):EF(b)?$APP.k(KF.j(b))?b:$APP.k(sG.j(b))?a:$APP.k(hH(a))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,
null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.k(hH(a))?$APP.k(hH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),$APP.Fc.j?$APP.Fc.j(a):
$APP.Fc.call(null,a),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.k(hH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))};
jH=function(a,b){return EF(a)&&EF(b)?zG.A(a,b):EF(a)?$APP.k(KF.j(a))?a:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.rj,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):EF(b)?$APP.k(KF.j(b))?CD("division by zero"):$APP.k(sG.j(b))?a:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.rj,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.rj,null,1,null),new $APP.D(null,a,null,1,null),
$APP.y([new $APP.D(null,b,null,1,null)]))))};eWa=function(a){return jH(1,a)};
hWa=function(a){return EF(a)?$APP.k(TF.j(a))?$APP.k(KF.j(a))?0:new $APP.D(null,kH,new $APP.D(null,a,null,1,null),2,null):SF(a/lH)?0:SF(1/(a-fWa-gWa))?1:SF((a+fWa)/gWa)?-1:Math.sin(a):a instanceof $APP.q?$APP.k((new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).call(null,a))?0:$APP.k((new $APP.ug(null,
new $APP.f(null,1,[qH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[qH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,1,[qH,null],null),null)).call(null,a))?1:$APP.k((new $APP.ug(null,new $APP.f(null,1,[rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[rH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,1,[rH,null],null),null)).call(null,a))?-1:new $APP.D(null,kH,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,kH,new $APP.D(null,a,null,1,null),2,null)};
iWa=function(a){return EF(a)?$APP.k(TF.j(a))?$APP.k(KF.j(a))?1:new $APP.D(null,sH,new $APP.D(null,a,null,1,null),2,null):SF((a-fWa)/lH)?0:SF(a/gWa)?1:SF((a-lH)/gWa)?-1:Math.cos(a):a instanceof $APP.q?$APP.k((new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).call(null,a))?0:$APP.k((new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).j?
(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).call(null,a))?1:$APP.k((new $APP.ug(null,new $APP.f(null,2,[mH,null,nH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[mH,null,nH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[mH,null,nH,null],null),null)).call(null,a))?-1:new $APP.D(null,sH,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,sH,new $APP.D(null,a,null,1,null),2,null)};
jWa=function(a){return EF(a)?$APP.eb(TF.j(a))?tH.j(a):$APP.k(KF.j(a))?1:new $APP.D(null,uH,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,uH,new $APP.D(null,a,null,1,null),2,null)};kWa=function(a){return EF(a)?$APP.eb(TF.j(a))?vH.j(a):$APP.k(KF.j(a))?0:new $APP.D(null,wH,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,wH,new $APP.D(null,a,null,1,null),2,null)};zH=function(a){return EF(a)?xH.j(a):iH(zG.A(1,2),gH(a,yH(a)))};
lWa=function(a){return EF(a)?AH.j(a):iH(zG.A(1,2),iH(wG.A(0,-1),cWa(a,yH(a))))};mWa=function(a,b){return EF(a)&&EF(b)?BH.A(a,b):DF(a)?iH(a,zH(b)):DF(b)?iH(zH(a),b):gH(iH(zH(a),zH(b)),iH(lWa(a),lWa(b)))};
oWa=function(a){if($APP.k(nWa(a)))return a=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a)),new $APP.D(null,CH(cH,2),new $APP.D(null,a,null,1,null),2,null);if($APP.k(aWa(a))){var b=$APP.x.A($APP.u.j?$APP.u.j(a):$APP.u.call(null,a),2);a=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a));return new $APP.D(null,CH(cH,b+1),new $APP.D(null,a,null,1,null),2,null)}return new $APP.D(null,cH,new $APP.D(null,a,null,1,null),2,null)};
pWa=function(a,b){return!0===a?b:!1===a?a:!0===b?a:!1===b?b:$APP.Uc.A(a,b)?b:new $APP.D(null,$APP.io,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)};qWa=function(a,b){var c=EF(a),d=EF(b);return c&&d?fG.A(a,b):c||d?!1:$APP.Uc.A(a,b)?!0:new $APP.D(null,$APP.Zv,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)};rWa=function(a){return EF(a)?sG.j(a):new $APP.D(null,$APP.Zv,new $APP.D(null,1,new $APP.D(null,a,null,1,null),2,null),3,null)};
DH=function(a){return sWa.j?sWa.j(a):sWa.call(null,a)};tWa=function(a){return function(b,c){return $APP.k(a.j?a.j(b):a.call(null,b))?$APP.k(a.j?a.j(c):a.call(null,c))?$APP.Ed(b,c):-1:$APP.k(a.j?a.j(c):a.call(null,c))?1:$APP.Ed(b,c)}};uWa=function(a,b,c){if(null!=a&&null!=a.zf)a=a.zf(a,b,c);else{var d=uWa[$APP.la(null==a?null:a)];if(null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else if(d=uWa._,null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else throw $APP.ib("ICanonicalize.-\x3eexpression",a);}return a};
vWa=function(a,b){if(null!=a&&null!=a.Le)a=a.Le(a,b);else{var c=vWa[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=vWa._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICanonicalize.known-operation?",a);}return a};xWa=function(a){return wWa.j(a)};EH=function(a){return yWa.j(a)};zWa=function(){};
FH=function(a,b,c){if(null!=a&&null!=a.ac)a=a.ac(a,b,c);else{var d=FH[$APP.la(null==a?null:a)];if(null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else if(d=FH._,null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else throw $APP.ib("IPerturbed.replace-tag",a);}return a};
GH=function(a,b,c){if(null!=a&&null!=a.$b)a=a.$b(a,b,c);else{var d=GH[$APP.la(null==a?null:a)];if(null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else if(d=GH._,null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else throw $APP.ib("IPerturbed.extract-tangent",a);}return a};HH=function(a,b){if(null!=a&&null!=a.ic)a=a.ic(a,b);else{var c=HH[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=HH._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("IPerturbed.extract-id",a);}return a};
IH=function(a,b,c,d){this.Pc=a;this.R=b;this.N=c;this.P=d;this.O=2230716170;this.U=139264};AWa=function(a){return new IH(a,null,null,null)};JH=function(){return $APP.lh.A(BWa,$APP.Lc)};KH=function(a,b,c){this.tag=a;this.xc=b;this.Be=c;this.O=2149580800;this.U=2048};CWa=function(a,b,c){return new KH(a,b,c)};LH=function(a){return a instanceof KH};MH=function(a){return LH(a)?a.tag:null};OH=function(a,b,c){var d=NH;NH=$APP.Yd(a,NH);try{return $APP.Je.A(b,c)}finally{NH=d}};
DWa=function(a){return $APP.vd($APP.He($APP.wg([a]),NH))};EWa=function(a,b){return HF(PH.j(a),PH.j(b))};FWa=function(a){return function(b){var c=JH();b=QH.B(b,1,c);return GH(OH(c,a,new $APP.H(null,1,5,$APP.I,[b],null)),c,RH)}};GWa=function(){};SH=function(a){if(null!=a&&null!=a.bc)a=a.bc(a);else{var b=SH[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=SH._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IArity.arity",a);}return a};
UH=function(a){return $APP.vh(BF(a),TH)};VH=function(a){switch(arguments.length){case 2:return VH.A(arguments[0],arguments[1]);case 3:return VH.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};WH=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=0<b.length?new $APP.Bc(b.slice(0),0,null):null;return WH.C(b)};
YH=function(a){var b=$APP.ed(a);b=$APP.k(XH.j(b))?b:$APP.rg.B(b,XH,SH(a));a=$APP.mh(a);return QSa(a,b)};ZH=function(a){switch(arguments.length){case 2:return ZH.A(arguments[0],arguments[1]);case 3:return ZH.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
$H=function(a){switch(arguments.length){case 2:return $H.A(arguments[0],arguments[1]);case 3:return $H.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
IWa=function(a){return VH.B(function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(d){return tG.j($APP.Je.A(a,d))}b.G=0;b.K=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}(),SH(a),new $APP.f(null,1,[aI,HWa],null))};
KWa=function(a){return VH.B(function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(d){return NF.j($APP.Je.A(a,d))}b.G=0;b.K=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}(),SH(a),new $APP.f(null,1,[aI,JWa],null))};
bI=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=1<b.length?new $APP.Bc(b.slice(1),0,null):null;return bI.C(arguments[0],b)};cI=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=1<b.length?new $APP.Bc(b.slice(1),0,null):null;return cI.C(arguments[0],b)};
LWa=function(a){var b=$APP.Pg(/invoke\$arity\$\d+/),c=$APP.Lf.A($APP.vg,$APP.sn.A($APP.bb,$APP.N.A(new $APP.H(null,1,5,$APP.I,[a.G],null),$APP.Vg.A(function(d){d=$APP.Mg(b,d);return $APP.k(d)?parseInt($APP.Og.A(d,13)):null},$APP.Ma(a)))));return $APP.hd(c)?new $APP.H(null,1,5,$APP.I,[a.length],null):$APP.gi.j(c)};
dI=function(a){switch(arguments.length){case 0:return dI.J();case 1:return dI.j(arguments[0]);case 2:return dI.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};MWa=function(a){return $APP.Id.A(dI,a)};NWa=function(a){return $APP.Vs.B($APP.Vg.j(SH),dI,a)};eI=function(a,b){return GF(a)?VH.A($APP.Le(a),b):a};
OWa=function(a){return VH.A(function(b,c){var d=GF(b)?SH(c):SH(b),g=GF(c)?d:SH(c),l=eI(b,d),n=eI(c,g);b=MWa(new $APP.H(null,2,5,$APP.I,[d,g],null));return VH.A(function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=new $APP.Bc(B,0,null)}return v.call(this,A)}function v(t){var A=$APP.Je.A(l,t);t=$APP.Je.A(n,t);return a.A?a.A(A,t):a.call(null,A,t)}p.G=0;p.K=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}(),b)},new $APP.H(null,
2,5,$APP.I,[fI,2],null))};gI=function(a){var b=VH.A($APP.Pi.A($APP.Hl,a),new $APP.H(null,2,5,$APP.I,[fI,1],null));a.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(c){return b.j?b.j(c):b.call(null,c)})};iI=function(a){hI(a,a)};
hI=function(a,b){b=OWa(b);for(var c=$APP.r(new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[TH,TH],null),new $APP.H(null,2,5,$APP.I,[TH,jI],null),new $APP.H(null,2,5,$APP.I,[jI,TH],null)],null)),d=null,g=0,l=0;;)if(l<g){var n=d.aa(null,l);a.F(null,n,function(t,A,B,G,J,O){return function(Q,W){return O.A?O.A(Q,W):O.call(null,Q,W)}}(c,d,g,l,n,b));l+=1}else{var p=$APP.r(c);if(p){var v=p;$APP.pd(v)?(c=$APP.lc(v),g=$APP.mc(v),d=c,v=$APP.Tc(c),c=g,g=v):(n=$APP.u(v),a.F(null,n,function(t,A,B,G,J,O,
Q,W){return function(Z,fa){return W.A?W.A(Z,fa):W.call(null,Z,fa)}}(c,d,g,l,n,v,p,b)),c=$APP.w(v),d=null,g=0);l=0}else break}};
PWa=function(a,b,c){return VH.A(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){if(DWa(b)){var n=JH();return FH(GH(OH(b,a,$APP.Vg.A(function(p){return FH(p,b,n)},l)),b,c),n,b)}return GH(OH(b,a,l),b,c)}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),SH(a))};
QWa=function(a,b,c){return VH.A(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){if(DWa(b)){var n=JH();l=$APP.Vg.A(function(p){return FH(p,b,n)},l);return FH(FH($APP.Je.A(a,l),b,c),n,b)}return FH($APP.Je.A(a,l),b,c)}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),SH(a))};
RWa=function(a,b,c){return $APP.Id.B(function(d,g){var l=$APP.Ab(g),n=$APP.Bb(g);g=$APP.rg.B;var p=$APP.C.B(d,l,0);n=a.A?a.A(p,n):a.call(null,p,n);return g.call($APP.rg,d,l,n)},b,$APP.r(c))};kI=function(a,b){this.i=a;this.ca=b;this.O=2149580800;this.U=0};SWa=function(a,b){return new kI(a,b)};TWa=function(a){return a instanceof kI};UWa=function(a){return a.ca};mI=function(a,b){if(TWa(b)){var c=$APP.Uc.A(a.ca,b.ca);return c?fG.A(a.i,b.i):c}return EF(b)?fG.A(a.i,lI.A(b,a.ca)):!1};
nI=function(a,b){return SWa(lI.A(a,b),b)};oI=function(a){return function(b,c){if($APP.Uc.A(b.ca,c.ca)){var d=b.i;c=c.i;d=a.A?a.A(d,c):a.call(null,d,c);b=nI(d,b.ca)}else b=CD("unequal moduli");return b}};pI=function(a){return VWa(a.i,a.ca)};
VWa=function(a,b){a:if($APP.k(KF.j(a)))var c=new $APP.H(null,3,5,$APP.I,[hG.j(b),0,1],null);else if($APP.k(KF.j(b)))c=new $APP.H(null,3,5,$APP.I,[hG.j(a),1,0],null);else{c=0;for(var d=1,g=1,l=0,n=hG.j(b),p=hG.j(a);;){if($APP.k(KF.j(n))){c=new $APP.H(null,3,5,$APP.I,[p,d,l],null);break a}var v=qI.A(p,n);d=RF.A(d,iG.A(v,c));var t=c;l=RF.A(l,iG.A(v,g));var A=g;p=RF.A(p,iG.A(v,n));v=n;c=d;d=t;g=l;l=A;n=p;p=v}}g=$APP.x.B(c,0,null);n=$APP.x.B(c,1,null);$APP.x.B(c,2,null);return 2>g?nI(n,b):CD([$APP.m.j(a),
" is not invertible mod ",$APP.m.j(b)].join(""))};WWa=function(a,b,c){return SWa(Number(lI.A(rI.A(BigInt(a),BigInt(b)),c)),c)};XWa=function(a){return $APP.Jd(function(b,c,d){return 0===d?b:$APP.rg.B(b,c,d)},sI,a)};YWa=function(a,b){return $APP.Jd(function(c,d,g){return d>b?$APP.rg.B(c,d-1,g):$APP.rg.B(c,d,g)},sI,$APP.Oi.A(a,b))};ZWa=function(a,b,c){a=$APP.Jd(function(d,g,l){return g>=b?$APP.rg.B(d,g+1,l):$APP.rg.B(d,g,l)},sI,a);return 0===c?a:$APP.rg.B(a,b,c)};
tI=function(a){return $APP.Je.A($APP.wr,$APP.pg(a))};uI=function(a,b){return a.A?a.A(b,0):a.call(null,b,0)};
$Wa=function(a){var b=$APP.Hj.j($APP.Tc(a)),c=$APP.Lf.A($APP.sf,$APP.Ts.A(a,$APP.ng(a)));return new $APP.H(null,2,5,$APP.I,[function(d){return $APP.Lf.B(sI,$APP.bf.j(function(g){var l=c.j?c.j(g):c.call(null,g);l=d.j?d.j(l):d.call(null,l);return $APP.k(l)?new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[g,l],null)],null):null}),b)},function(d){return $APP.Lf.B(sI,$APP.bf.j(function(g){var l=d.j?d.j(g):d.call(null,g);return $APP.k(l)?new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[c.j?
c.j(g):c.call(null,g),l],null)],null):null}),b)}],null)};bXa=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=2<b.length?new $APP.Bc(b.slice(2),0,null):null;return aXa(arguments[0],arguments[1],b)};
aXa=function(a,b,c){c=$APP.qe(c);c=$APP.C.A(c,cXa);a=$APP.tf($APP.k(c)?$APP.Qb(a):a);b=$APP.tf($APP.k(c)?$APP.Qb(b):b);for(var d=$APP.Nd(0);;){var g=$APP.x.B(a,d,null),l=$APP.x.B(b,d,null);if($APP.eb(g)&&$APP.eb(l))return 0;if($APP.eb(g))return-1;if($APP.eb(l))return 1;var n=$APP.Ed($APP.x.A(g,0),$APP.x.A(l,0));if(0===n)if(g=$APP.x.A(g,1),l=$APP.x.A(l,1),$APP.Uc.A(g,l))d+=1;else return $APP.k(c)?l-g:g-l;else return 0>n?1:-1}};
dXa=function(a,b){var c=tI(a),d=tI(b);return $APP.Uc.A(c,d)?bXa(a,b):c-d};vI=function(a){return $APP.x.B(a,0,sI)};wI=function(a){return $APP.x.B(a,1,0)};eXa=function(a){var b=vI(a);a=wI(a);return[$APP.jh.C($APP.y([a])),"*",$APP.jh.C($APP.y([b]))].join("")};fXa=function(a){return $APP.k(KF.j(a))?$APP.sf:new $APP.H(null,1,5,$APP.I,[xI.A(sI,a)],null)};
gXa=function(a){var b=$APP.Hl.A($APP.gp.j(function(c,d){if($APP.k(KF.j(d)))return null;c=0===c?sI:yI.A?yI.A(0,c):yI.call(null,0,c);return new $APP.H(null,1,5,$APP.I,[xI.A(c,d)],null)}),$APP.eh);return $APP.Lf.B($APP.sf,b,a)};
hXa=function(a){return $APP.hd(a)?$APP.sf:$APP.Lf.A($APP.sf,$APP.Ts.B(vI,dXa,function(){return function d(c){return new $APP.de(null,function(){for(var g=c;;)if(g=$APP.r(g)){if($APP.pd(g)){var l=$APP.lc(g),n=$APP.Tc(l),p=$APP.fe(n);a:for(var v=0;;)if(v<n){var t=$APP.bd(l,v),A=$APP.x.B(t,0,null);t=$APP.x.B(t,1,null);t=$APP.Vs.B($APP.Vg.j(wI),kG,t);$APP.eb(KF.j(t))&&(A=$APP.od(A)?XWa(A):$APP.ld(A)?A:$APP.md(A)?$APP.Lf.A(sI,A):AD("Invalid inputs to sparse-\x3eterms TODO"),$APP.je(p,xI.A(A,t)));v+=1}else{l=
!0;break a}return l?$APP.ie($APP.ke(p),d($APP.mc(g))):$APP.ie($APP.ke(p),null)}l=$APP.u(g);p=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);l=$APP.Vs.B($APP.Vg.j(wI),kG,l);if($APP.eb(KF.j(l)))return p=$APP.od(p)?XWa(p):$APP.ld(p)?p:$APP.md(p)?$APP.Lf.A(sI,p):AD("Invalid inputs to sparse-\x3eterms TODO"),$APP.Yd(xI.A(p,l),d($APP.Fc(g)));g=$APP.Fc(g)}else return null},null,null)}($APP.oh(vI,a))}()))};
iXa=function(a,b){return $APP.Lf.A($APP.sf,function(){return function g(d){return new $APP.de(null,function(){for(var l=d;;)if(l=$APP.r(l)){if($APP.pd(l)){var n=$APP.lc(l),p=$APP.Tc(n),v=$APP.fe(p);a:for(var t=0;;)if(t<p){var A=$APP.bd(n,t),B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);A=a.j?a.j(A):a.call(null,A);$APP.eb(KF.j(A))&&$APP.je(v,xI.A(B,A));t+=1}else{n=!0;break a}return n?$APP.ie($APP.ke(v),g($APP.mc(l))):$APP.ie($APP.ke(v),null)}n=$APP.u(l);v=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);n=a.j?
a.j(n):a.call(null,n);if($APP.eb(KF.j(n)))return $APP.Yd(xI.A(v,n),g($APP.Fc(l)));l=$APP.Fc(l)}else return null},null,null)}(b)}())};kXa=function(a,b){return jXa(a,iXa(PF,b))};lXa=function(a,b){var c=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);for(var d=$APP.bc($APP.sf),g=0;;){var l=$APP.x.B(b,g,null);if(null==l)return $APP.dc(d);var n=l;l=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);d=$APP.mf.A(d,xI.A($APP.Oo.C($APP.wr,$APP.y([c,l])),MF.A(a,n)));g+=1}};
mXa=function(a,b){return function g(d){var l=$APP.x.B(a,d,null);return null==l?$APP.sf:jXa(lXa(l,b),g(d+1))}(0)};
nXa=function(a,b){var c=$APP.fd(b),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);for(var g=$APP.sf;;){if($APP.hd(a))return new $APP.H(null,2,5,$APP.I,[g,a],null);var l=$APP.fd(a),n=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);n=XWa($APP.Oo.C($APP.wr,$APP.y([n,uD($APP.Ck,d)])));if($APP.Ge($APP.Lba,$APP.pg(n)))l=zG.A(l,c),n=xI.A(n,l),g=jXa(g,new $APP.H(null,1,5,$APP.I,[n],null)),a=kXa(a,lXa(n,b));else return new $APP.H(null,2,5,$APP.I,[g,a],null)}};
oXa=function(a,b){var c=$APP.tf(a),d=$APP.Tc(c);return $APP.Vs.B($APP.gp.j(function(g,l){var n=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);var p=function(){return function B(A){return new $APP.de(null,function(){for(var G=A;;)if(G=$APP.r(G)){if($APP.pd(G)){var J=$APP.lc(G),O=$APP.Tc(J),Q=$APP.fe(O);a:for(var W=0;;)if(W<O){var Z=$APP.bd(J,W);$APP.qg.A(g,Z)&&$APP.je(Q,$APP.Zl.A(c,new $APP.H(null,2,5,$APP.I,[Z,0],null)));W+=1}else{J=!0;break a}return J?$APP.ie($APP.ke(Q),B($APP.mc(G))):$APP.ie($APP.ke(Q),
null)}Q=$APP.u(G);if($APP.qg.A(g,Q))return $APP.Yd($APP.Zl.A(c,new $APP.H(null,2,5,$APP.I,[Q,0],null)),B($APP.Fc(G)));G=$APP.Fc(G)}else return null},null,null)}($APP.Hj.j(d))}(),v=$APP.Je.A(iG,$APP.Vg.A(function(t){return RF.A(b,t)},p));p=$APP.Je.A(iG,$APP.Vg.A(function(t){return RF.A(n,t)},p));return iG.C(OF.j(p),l,$APP.y([v]))}),kG,c)};pXa=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,3,5,$APP.I,[b,b,a],null)};
qXa=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);var g=$APP.x.B(b,2,null);$APP.x.B(c,0,null);b=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);c=QF.A(kG.A(iG.A(RF.A(a,b),g),iG.A(RF.A(d,a),c)),RF.A(d,b));return new $APP.H(null,3,5,$APP.I,[d,b,c],null)}};rXa=function(a){return function(b){return $APP.Vg.B(qXa(a),b,$APP.Fc(b))}};zI=function(a){return $APP.Vg.A($APP.u,a)};
AI=function(a,b,c){return $APP.Hg.A($APP.r,$APP.af(function(d){return $APP.Vg.B(b,d,$APP.Fc(d))},$APP.Vg.A(a,c)))};sXa=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);$APP.x.B(c,0,null);var g=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);return new $APP.H(null,3,5,$APP.I,[d,g,((a-g)*b+(d-a)*c)/(d-g)],null)}};tXa=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,4,5,$APP.I,[b,b,a,a],null)};
uXa=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);$APP.x.B(b,2,null);var g=$APP.x.B(b,3,null);$APP.x.B(c,0,null);b=$APP.x.B(c,1,null);var l=$APP.x.B(c,2,null);$APP.x.B(c,3,null);c=(l-g)/(d-b);return new $APP.H(null,4,5,$APP.I,[d,b,c*(d-a),c*(b-a)],null)}};vXa=function(a){return BI.j($APP.Vg.A(function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);var c=$APP.x.B(b,2,null);$APP.x.B(b,3,null);return c},a))};
CI=function(a,b,c){return function(){function d(n,p){return $APP.St.B(b,a.j?a.j(p):a.call(null,p),n)}function g(n){return c.j?c.j(n):c.call(null,n)}var l=null;l=function(n,p){switch(arguments.length){case 0:return $APP.sf;case 1:return g.call(this,n);case 2:return d.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.J=function(){return $APP.sf};l.j=g;l.A=d;return l}()};wXa=function(a){return CI(pXa,sXa(a),function(b){return $APP.fd($APP.$c(b))})};
xXa=function(a){return $APP.Vs.B($APP.Vg.j(function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);var c=$APP.x.B(b,2,null);$APP.x.B(b,3,null);return c}),DI,a)};yXa=function(a){return CI(tXa,uXa(a),xXa)};zXa=function(a){return EI.j(yXa(a))};AXa=function(a){return $APP.Cba(a)?BigInt(a):a};FI=function(a){var b=$APP.Hj.A(1,a+1);return 19>a?$APP.Je.A($APP.Ws,b):$APP.Vs.B($APP.Vg.j(wD),iG,b)};BXa=function(a,b){a=$APP.Hj.B(a,0,-b);return $APP.Vs.B($APP.Vg.j(wD),iG,a)};
CXa=function(a,b){var c=$APP.kh.j(null);$APP.Ne(c,$APP.mh(function(g,l){if($APP.Uc.A(l,1)||$APP.Uc.A(g,l))return 1;var n=g-1;g=function(){var v=$APP.Fb(c);v=v.A?v.A(n,l):v.call(null,n,l);v=BigInt(v);return iG.A?iG.A(l,v):iG.call(null,l,v)}();var p=function(){var v=l-1,t=$APP.Fb(c);return t.A?t.A(n,v):t.call(null,n,v)}();return kG.A?kG.A(g,p):kG.call(null,g,p)}));if(0===b)return 0===a?1:0;if(b>a)return 0;var d=$APP.Fb(c);return d.A?d.A(a,b):d.call(null,a,b)};
DXa=function(a){var b=$APP.Vg.j(function(d){return CXa(a,d)}),c=$APP.Hj.j(a+1);return $APP.Vs.B(b,kG,c)};GI=function(a){return $APP.N.A(new $APP.de(null,function(){return a},null,null),new $APP.de(null,function(){return $APP.Uj.j(tG.j($APP.u(a)))},null,null))};EXa=function(a,b){return $APP.Vg.B(kG,a,b)};FXa=function(a,b){return new $APP.de(null,function(){return $APP.Yd(kG.A(a,$APP.u(b)),$APP.Fc(b))},null,null)};
GXa=function(a,b){return new $APP.de(null,function(){return $APP.Yd(kG.A($APP.u(a),b),$APP.Fc(a))},null,null)};HXa=function(a,b){return $APP.Vg.B(RF,a,b)};IXa=function(a,b){return new $APP.de(null,function(){return $APP.Yd(RF.A($APP.u(a),b),$APP.Fc(a))},null,null)};HI=function(a,b){return new $APP.de(null,function(){return $APP.Yd(RF.A(a,$APP.u(b)),$APP.Vg.A(PF,$APP.Fc(b)))},null,null)};JXa=function(a,b){return $APP.Vg.A(function(c){return MF.A(c,b)},a)};
II=function(a,b){return $APP.Vg.A(function(c){return MF.A(a,c)},b)};KXa=function(a,b){return $APP.Vg.A(function(c){return QF.A(c,b)},a)};KI=function(a,b){return function g(d){return new $APP.de(null,function(){var l=$APP.r(d),n=$APP.u(l);l=$APP.w(l);var p=$APP.Fc(b);l=JI(p,g(l));return $APP.Yd(n,l)},null,null)}(a)};LXa=function(a){return function d(c){return new $APP.de(null,function(){var g=$APP.Fc(c),l=d(c);return $APP.Yd(0,LI(KI(g,l)))},null,null)}(a)};
MI=function(a,b){return $APP.Yd(b,$APP.Vg.B(zG,a,$APP.af($APP.Lc,1)))};MXa=function(a,b){function c(d,g){for(var l=GI(new $APP.H(null,1,5,$APP.I,[1],null));;){var n=$APP.Ie(g);g=$APP.Pd(g,2);if(n)d=JI(d,d);else{if(0===g)return JI(d,l);l=JI(d,l);d=JI(d,d)}}}return 0<b?c(a,b):0===b?GI(new $APP.H(null,1,5,$APP.I,[1],null)):LI(c(a,PF.j(b)))};NI=function(a,b){this.xs=a;this.ca=b;this.O=2173042689;this.U=0};OI=function(a,b){return new NI(a,b)};
PI=function(a,b){this.xs=a;this.ca=b;this.O=2173042689;this.U=0};QI=function(a,b){return new PI(a,b)};NXa=function(a){return a instanceof NI||a instanceof PI};RI=function(a){return a instanceof PI};OXa=function(a){switch(a instanceof $APP.E?a.ga:null){case "emmy.series/series":return OI;case "emmy.series/power-series":return QI;default:return AD(["Unsupported kind: ",$APP.m.j(a)].join(""))}};SI=function(a){return OI(GI(a),null)};TI=function(a){return QI(GI(a),null)};
PXa=function(a){return RI(a)?a:NXa(a)?QI($APP.r(a),$APP.ed(a)):AD("non-series provided to -\x3efunction.")};QXa=function(a,b){var c=NF.j(b);return $APP.Vg.B(iG,a,$APP.af(function(d){return iG.A(b,d)},c))};UI=function(a,b){return function g(d){var l=$APP.Je.A($APP.u(d),b);return NXa(l)?new $APP.de(null,function(){var n=$APP.r(l),p=$APP.u(n);n=$APP.w(n);return $APP.Yd(p,EXa(n,g($APP.Fc(d))))},null,null):$APP.Yd(l,new $APP.de(null,function(){return g($APP.Fc(d))},null,null))}($APP.r(a))};
VI=function(a,b){a=$APP.Vg.A(a,b);var c=$APP.ed(b);b=RI(b)?QI:OI;return b.A?b.A(a,c):b.call(null,a,c)};RXa=function(a,b){if(1>=b)return a;var c=tG.j($APP.u(a));b=$APP.Uj.A(b-1,c);b=$APP.Je.A($APP.N,$APP.Vg.B($APP.Yd,a,$APP.Uj.j(b)));c=$APP.ed(a);a=RI(a)?QI:OI;return a.A?a.A(b,c):a.call(null,b,c)};SXa=function(a){var b=$APP.St.A(kG,a),c=$APP.ed(a);a=RI(a)?QI:OI;return a.A?a.A(b,c):a.call(null,b,c)};TXa=function(a,b){return $APP.Vs.B($APP.We.j(b+1),kG,a)};
UXa=function(a,b){return QI(KI($APP.r(a),$APP.r(b)),null)};VXa=function(a){a:{var b=$APP.bc(new $APP.H(null,1,5,$APP.I,[1],null));for(var c=1,d=1;;){if(0===a)break a;c=c*a/d;b=$APP.mf.A(b,c);--a;d+=1}}b=$APP.dc(b);return QI(GI(b),null)};WI=function(a){return $APP.Uc.A(a,$APP.Hv)};WXa=function(a){var b=(b=$APP.be(a))?vD(/^\?[^\?].*/,$APP.Ag(a)):b;return $APP.k(b)?b:$APP.kd(a)&&$APP.Uc.A($APP.u(a),XI)};
YI=function(a){var b=(b=$APP.be(a))?vD(/^\?\?[^\?].*/,$APP.Ag(a)):b;return $APP.k(b)?b:$APP.kd(a)&&$APP.Uc.A($APP.u(a),XXa)};ZI=function(a){var b=(b=$APP.be(a))?vD(/^\$\$[^\$].*/,$APP.Ag(a)):b;return $APP.k(b)?b:$APP.kd(a)&&$APP.Uc.A($APP.u(a),YXa)};$I=function(a){return $APP.be(a)?a:$APP.Xc(a)};ZXa=function(a){return $APP.be(a)?$APP.Zg.j(["??",$APP.Og.A($APP.Ag(a),2)].join("")):$APP.Xc(a)};aJ=function(a){function b(){return!0}return $APP.be(a)?b:(a=$APP.r($APP.Se.A(2,a)))?$APP.Je.A($APP.vt,a):b};
bJ=function(a){return $APP.kd(a)&&$APP.Uc.A($APP.u(a),$APP.Ij)};cJ=function(a){return $APP.kd(a)&&$APP.Uc.A($APP.u(a),$APP.Kj)};
$Xa=function(a,b,c){var d=$APP.Id.B(function(g,l){var n=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return $APP.k(a.j?a.j(l):a.call(null,l))?$APP.hd(g)?new $APP.H(null,2,5,$APP.I,[$APP.Vd.A(n,b.j?b.j(l):b.call(null,l)),$APP.sf],null):new $APP.H(null,2,5,$APP.I,[$APP.Vd.C(n,g,$APP.y([b.j?b.j(l):b.call(null,l)])),$APP.sf],null):new $APP.H(null,2,5,$APP.I,[n,$APP.Vd.A(g,b.j?b.j(l):b.call(null,l))],null)},new $APP.H(null,2,5,$APP.I,[$APP.sf,$APP.sf],null),c);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return $APP.hd(d)?
c:$APP.Vd.A(c,d)};dJ=function(a){return new $APP.f(null,1,[aYa,a],null)};bYa=function(a){return $APP.md(a)?aYa.A(a,a):a};cYa=function(a,b){a=$APP.be(a)?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,a,null,1,null)))):bJ(a)?$APP.Xc(a):a;return new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null)};
fYa=function(a,b){function c(g){g=$Xa($APP.wt.B(YI,ZI,cJ),d,g);return $APP.hd(g)?$APP.Ec:$APP.Uc.A(1,$APP.Tc(g))?$APP.u(g):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.py,null,1,null),g)))}var d=function n(l){var p=WXa(l);p=$APP.k(p)?p:YI(l);return $APP.k(p)?(l=$I(l),cYa(l,a)):$APP.k(ZI(l))?(l=ZXa(l),new $APP.D(null,dYa,new $APP.D(null,cYa(l,a),null,1,null),2,null)):l instanceof $APP.q?new $APP.D(null,$APP.K,new $APP.D(null,l,null,1,null),2,null):bJ(l)?$APP.Xc(l):cJ(l)?$APP.Lf.A($APP.sf,$APP.Xc(l)):
$APP.md(l)?uD(n,l):$APP.od(l)?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.rua,null,1,null),new $APP.D(null,c(l),null,1,null)))):$APP.kd(l)?$APP.hd(l)?l:$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Nu,null,1,null),new $APP.D(null,c(l),null,1,null)))):l};return $APP.k(b)?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.fm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,eYa,null,1,null),new $APP.D(null,d(b),null,1,null))))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.by,null,1,null),new $APP.D(null,eYa,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,eJ,null,1,null),new $APP.D(null,eYa,null,1,null)))),null,1,null)])))),null,1,null)])))):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,eJ,null,1,null),new $APP.D(null,b,null,1,null))))};gYa=function(){return null};hYa=function(a,b,c){return c.j?c.j(a):c.call(null,a)};iYa=function(a){return function(b,c,d){c=a.j?a.j(c):a.call(null,c);return $APP.k(c)?d.j?d.j(b):d.call(null,b):c}};
jYa=function(a){return function(b,c,d){c=a.j?a.j(b):a.call(null,b);return $APP.k(c)?d.j?d.j(b):d.call(null,b):c}};kYa=function(a,b){var c=fJ.j?fJ.j(b):fJ.call(null,b);return function(d,g,l){return $APP.k(a.j?a.j(g):a.call(null,g))?c.B?c.B(d,g,l):c.call(null,d,g,l):null}};lYa=function(a){var b=fJ.j?fJ.j(a):fJ.call(null,a);return function(c,d,g){return $APP.k(b.B?b.B(c,d,g):b.call(null,c,d,g))?null:g.j?g.j(c):g.call(null,c)}};nYa=function(a){return $APP.Xj.M(a,$APP.rg,mYa,!0)};
oYa=function(a,b){return nYa(function(c,d,g){d=$APP.k(d)?d:$APP.sf;var l=(l=$APP.kd(d))?b.j?b.j(d):b.call(null,d):l;if($APP.k(l)){if(WI(a))return g.A?g.A(c,null):g.call(null,c,null);l=c.j?c.j(a):c.call(null,a);if($APP.k(l))return $APP.Uc.A(d,l)?g.A?g.A(c,null):g.call(null,c,null):null;c=$APP.rg.B(c,a,d);return g.A?g.A(c,null):g.call(null,c,null)}return null})};
pYa=function(a){return function(b,c,d){if($APP.kd(c)){var g=$APP.Vg.A(fJ,a);return function t(n,p,v){function A(O){function Q(W,Z){return t(W,Z,$APP.w(v))}return O.B?O.B(n,p,Q):O.call(null,n,p,Q)}function B(O){function Q(Z){return t(Z,$APP.w(p),$APP.w(v))}var W=$APP.u(p);return O.B?O.B(n,W,Q):O.call(null,n,W,Q)}if($APP.k(v)){var G=$APP.u(v);if($APP.k(mYa.A($APP.ed(G),!1)))return A(G);var J=$APP.r(p);return J?B(G):J}return $APP.r(p)?!1:d.j?d.j(n):d.call(null,n)}(b,c,g)}return null}};
gJ=function(a,b,c){this.R=a;this.N=b;this.P=c;this.O=2230716170;this.U=139264};hJ=function(a){return a instanceof gJ};
qYa=function(a,b){var c=fJ(a),d=function(){function g(p,v){b.A?b.A(p,v):b.call(null,p,v);return!1}function l(p){b.j?b.j(p):b.call(null,p);return!1}var n=null;n=function(p,v){switch(arguments.length){case 1:return l.call(this,p);case 2:return g.call(this,p,v)}throw Error("Invalid arity: "+arguments.length);};n.j=l;n.A=g;return n}();return function(g){return c.B?c.B($APP.F,g,d):c.call(null,$APP.F,g,d)}};
rYa=function(a){var b=fJ(a);return function(c){var d=$APP.kh.j($APP.sf),g=function(){function l(v,t){$APP.lh.B(d,$APP.Vd,new $APP.H(null,2,5,$APP.I,[v,t],null));return!1}function n(v){$APP.lh.B(d,$APP.Vd,v);return!1}var p=null;p=function(v,t){switch(arguments.length){case 1:return n.call(this,v);case 2:return l.call(this,v,t)}throw Error("Invalid arity: "+arguments.length);};p.j=n;p.A=l;return p}();b.B?b.B($APP.F,c,g):b.call(null,$APP.F,c,g);return $APP.Fb(d)}};
kJ=function(a,b){var c=$APP.cd(a)?a:iJ.j(a);return function(d){d=c.j?c.j(d):c.call(null,d);hJ(d)?d=jJ:(d=b.j?b.j(d):b.call(null,d),d=bYa($APP.k(d)?d:jJ));return d}};sYa=function(a){return a};tYa=function(){return jJ};uYa=function(a){return function(b){return $APP.k(a.j?a.j(b):a.call(null,b))?b:jJ}};vYa=function(a){return function(){return a}};
wYa=function(a){return function(b){for(var c=a;;){if($APP.hd(c))return jJ;var d=$APP.u(c);d=d.j?d.j(b):d.call(null,b);if($APP.k(hJ.j?hJ.j(d):hJ.call(null,d)))c=$APP.Fc(c);else return d}}};xYa=function(a){return function(b){return $APP.Id.B(function(c,d){c=d.j?d.j(c):d.call(null,c);return $APP.k(hJ.j?hJ.j(c):hJ.call(null,c))?$APP.Mc(jJ):c},b,a)}};zYa=function(a){return yYa.A($APP.ed(a),!1)};lJ=function(a){return $APP.Xj.M(a,$APP.rg,yYa,!0)};nJ=function(a){return $APP.k(zYa(a))?a:lJ(mJ.C(a,$APP.y([sYa])))};
pJ=function(a,b){return oJ.C(uYa(a),$APP.y([b]))};AYa=function(a,b){return lJ(function(c){for(;;){var d=nJ(b);d=d.j?d.j(c):d.call(null,c);if($APP.k(a.A?a.A(c,d):a.call(null,c,d)))return d;c=d}})};BYa=function(a,b){return $APP.kd(b)?(a=$APP.Dj.j($APP.Vg.A(a,b)),$APP.Uc.A(b,a)?b:$APP.od(b)?$APP.tf(a):a):$APP.md(b)?(a=uD(a,b),$APP.Uc.A(b,a)?b:a):b};
CYa=function(a){var b=nJ(a),c=$APP.kh.j(null);$APP.Ne(c,$APP.mh(function(d){var g=BYa($APP.Fb(c),d);d=b.j?b.j(g):b.call(null,g);if($APP.Uc.A(d,g))return d;g=$APP.Fb(c);return g.j?g.j(d):g.call(null,d)}));return lJ($APP.Fb(c))};qJ=function(a){var b=EF(a);return b?qG.j(a):b};rJ=function(a){var b=vG(a);return b?(b=$APP.eb(KF.j(a)))?KF.j(xH.j(a)):b:b};sJ=function(a){return vG(a)&&$APP.eb(KF.j(xH.j(a)))&&$APP.eb(KF.j(AH.j(a)))};DYa=function(a){var b=rJ(a);return $APP.k(b)?SF(AH.j(a)):b};EYa=function(a){return!CF(a)};
FYa=function(a){return KF.j(lI.A(a,2))};GYa=function(a){return sG.j(lI.A(a,2))};HYa=function(a){var b=CF(a);return b?FYa(a):b};IYa=function(a){var b=CF(a);return b?GYa(a):b};JYa=function(a){var b=IYa(a);return $APP.k(b)?2<a:b};KYa=function(a){return EF(a)&&2<a};tJ=function(a){return EF(a)&&2<=a};
LYa=function(a,b){return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,a,new $APP.D(null,wJ,null,1,null),2,null),xJ),function(c){var d=$APP.N.A,g=new $APP.H(null,1,5,$APP.I,[a],null);c=$APP.qe(c);c=$APP.C.A(c,wJ);c=$APP.sn.A($APP.wg([b]),c);return(d=$APP.r(d.call($APP.N,g,c)))?d:dJ(d)})]))};
OYa=function(a){return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,CF,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(b):CJ.call(null,b),AJ.j?AJ.j(b):AJ.call(null,b)],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,
zJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),xJ),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)}),pJ(function(){return!0},kJ(vJ.j(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null)),function(b){b=$APP.qe(b);b=$APP.C.A(b,CJ);var c=a.j?a.j(b):a.call(null,b),d=EJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,
2,5,$APP.I,[zJ,c],null))],null)),c],null));d=d.call(EJ,c?c:dJ(c),MYa);return $APP.k(d)?b:d})),pJ(function(){return!0},kJ(vJ.j(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null)),function(b){b=$APP.qe(b);b=$APP.C.A(b,CJ);var c=a.j?a.j(b):a.call(null,b),d=EJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,c],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.rj,c,2],null))],null))],null));d=d.call(EJ,c?c:dJ(c),NYa);return $APP.k(d)?(b=$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,b,2],null))],null)))?b:dJ(b):d})),kJ(vJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,CJ.j?CJ.j(b):
CJ.call(null,b)],null))],null)))?b:dJ(b)})]))]))};
UYa=function(a){var b=DH($APP.Ev);return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,$APP.Hv,new $APP.D(null,0,null,1,null),2,null),3,null),xJ),function(){return $APP.k(1)?1:dJ(1)}),kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,1,null,1,null),2,null),3,null),xJ),function(c){c=CJ.j?CJ.j(c):CJ.call(null,c);return $APP.k(c)?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,nG,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,CF,null,1,null),
2,null),3,null),null,1,null),2,null),3,null),xJ),function(c){c=$APP.Od(c.j?c.j(AJ):c.call(null,AJ),4);var d=new $APP.H(null,4,5,$APP.I,[1,nG,-1,RF.j(nG)],null);c=d.j?d.j(c):d.call(null,c);return $APP.k(c)?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,GJ,null,1,null),2,null),3,null),new $APP.D(null,HJ,null,1,null),2,null),3,null),function(c){c=$APP.qe(c);var d=$APP.C.A(c,GJ),g=$APP.C.A(c,HJ),l=$APP.C.A(c,CJ),n=a.j?a.j(d):a.call(null,d),p=
a.j?a.j(g):a.call(null,g);return $APP.k(function(){var v=CF(n)&&CF(p);if(v)return v;v=function(){var t=HYa(p);$APP.k(t)&&(t=b.A?b.A(n,p):b.call(null,n,p),t=a.j?a.j(t):a.call(null,t),t=CF(t));return t}();return $APP.k(v)?v:$APP.k(!0)?EJ.A(function(){var t=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,l,n],null)),p],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,l,b.A?b.A(n,p):b.call(null,n,p)],null))],null));return t?t:dJ(t)}(),
PYa):!0}())?new $APP.f(null,1,[QYa,iG.A(d,g)],null):null}),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(c):CJ.call(null,c),QYa.j?QYa.j(c):QYa.call(null,c)],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,1,new $APP.D(null,2,null,1,null),2,null),3,null),null,1,null),2,null),3,null),function(){return!0}),function(c){return(c=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(c):CJ.call(null,c)],null)))?c:dJ(c)}),
kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,RYa,new $APP.D(null,CJ,new $APP.D(null,IJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,JJ,null,1,null),2,null),3,null),new $APP.D(null,KJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(c){return(c=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),LJ.j?LJ.j(c):LJ.call(null,c),$APP.y([IJ.j?IJ.j(c):IJ.call(null,c),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(c):CJ.call(null,
c),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,1,JJ.j?JJ.j(c):JJ.call(null,c)],null))],null))],null),KJ.j?KJ.j(c):KJ.call(null,c)]))))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,LJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,JJ,null,1,null),2,null),3,null),new $APP.D(null,IJ,new $APP.D(null,CJ,new $APP.D(null,KJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(c){return(c=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),LJ.j?LJ.j(c):
LJ.call(null,c),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(c):CJ.call(null,c),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,1,JJ.j?JJ.j(c):JJ.call(null,c)],null))],null))],null),IJ.j?IJ.j(c):IJ.call(null,c),KJ.j?KJ.j(c):KJ.call(null,c)]))))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,LJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,SYa,null,1,null),2,null),3,null),new $APP.D(null,IJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,
CJ,new $APP.D(null,TYa,null,1,null),2,null),3,null),new $APP.D(null,KJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(c){return(c=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),LJ.j?LJ.j(c):LJ.call(null,c),$APP.y([IJ.j?IJ.j(c):IJ.call(null,c),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(c):CJ.call(null,c),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,SYa.j?SYa.j(c):SYa.call(null,c),TYa.j?TYa.j(c):TYa.call(null,c)],null))],null))],null),KJ.j?
KJ.j(c):KJ.call(null,c)]))))?c:dJ(c)})]))]))};
XYa=function(a){return yJ.C($APP.y([kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,HYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(b){var c=$APP.I,d=CJ.j?CJ.j(b):CJ.call(null,b);b=QF.A(b.j?b.j(AJ):b.call(null,AJ),2);return(c=$APP.r(new $APP.H(null,3,5,c,[DJ,d,b],null)))?c:dJ(c)}),uJ.C($APP.y([pJ(function(){return!0},uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,
FJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,HYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),null,1,null),2,null),function(b){b=$APP.qe(b);var c=$APP.C.A(b,CJ);b=$APP.C.A(b,AJ);var d=a.j?a.j(c):a.call(null,c);c=QF.A(b,2);var g=EJ.A;b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,d,b],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,
[DJ,d,c],null))],null));return $APP.k(g.call(EJ,b?b:dJ(b),VYa))?new $APP.f(null,1,[MJ,c],null):null}),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(b):CJ.call(null,b),MJ.j?MJ.j(b):MJ.call(null,b)],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,JYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),null,1,null),2,null),function(b){b=$APP.qe(b);var c=
$APP.C.A(b,CJ);b=$APP.C.A(b,AJ);var d=a.j?a.j(c):a.call(null,c);c=QF.A(RF.A(b,1),2);var g=EJ.A;b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,d,b],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,d,c],null))],null));return $APP.k(g.call(EJ,b?b:dJ(b),WYa))?new $APP.f(null,1,[MJ,c],null):null}),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],
null)),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(b):CJ.call(null,b),MJ.j?MJ.j(b):MJ.call(null,b)],null))],null)))?b:dJ(b)})])))])),uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,IYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null)),g=$APP.I,l=
CJ.j?CJ.j(b):CJ.call(null,b);b=QF.A(RF.A(b.j?b.j(AJ):b.call(null,AJ),1),2);return(c=$APP.r(new $APP.H(null,3,5,c,[$APP.Ev,d,$APP.r(new $APP.H(null,3,5,g,[DJ,l,b],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,
new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,CJ,null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,CJ,new $APP.D(null,OJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),
2,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),NJ.j?NJ.j(b):NJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null),OJ.j?OJ.j(b):OJ.call(null,b)]))))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,OJ,null,
1,null),2,null),3,null),4,null),new $APP.D(null,CJ,null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),NJ.j?NJ.j(b):NJ.call(null,b),$APP.y([OJ.j?OJ.j(b):OJ.call(null,b)]))),$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,new $APP.D(null,
FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,OJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null)),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),NJ.j?NJ.j(b):NJ.call(null,b),$APP.y([OJ.j?OJ.j(b):OJ.call(null,b)])))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,
CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,CJ,new $APP.D(null,OJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),NJ.j?NJ.j(b):NJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null),OJ.j?OJ.j(b):OJ.call(null,b)])))],null)))?
b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,PJ,new $APP.D(null,CJ,new $APP.D(null,QJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,OJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,
[$APP.Ev],null),PJ.j?PJ.j(b):PJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null),QJ.j?QJ.j(b):QJ.call(null,b)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),NJ.j?NJ.j(b):NJ.call(null,b),$APP.y([OJ.j?OJ.j(b):OJ.call(null,b)])))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,PJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),
2,null),new $APP.D(null,QJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,CJ,new $APP.D(null,OJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),PJ.j?PJ.j(b):PJ.call(null,b),$APP.y([QJ.j?QJ.j(b):QJ.call(null,b)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),NJ.j?NJ.j(b):NJ.call(null,
b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null),OJ.j?OJ.j(b):OJ.call(null,b)])))],null)))?b:dJ(b)})]))]))};
bZa=function(a){function b(c){return function(d){var g=$APP.qe(d);d=$APP.C.A(g,CJ);g=$APP.C.A(g,JJ);d=a.j?a.j(d):a.call(null,d);g=a.j?a.j(g):a.call(null,g);return $APP.k(fG.A(d,g))?RJ.A(d,c):RJ.B(d,g,c)}}return nJ(pJ(function(){return!0},yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,CJ,new $APP.D(null,JJ,null,1,null),2,null),3,null),null,1,null),2,null),b(YYa)),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,
2,5,$APP.I,[FJ,CJ.j?CJ.j(c):CJ.call(null,c)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,JJ.j?JJ.j(c):JJ.call(null,c)],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,CJ,new $APP.D(null,JJ,new $APP.D(null,SJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),b(ZYa)),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(c):CJ.call(null,c)],null)),$APP.r(new $APP.H(null,2,5,
$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,JJ.j?JJ.j(c):JJ.call(null,c)],null),SJ.j?SJ.j(c):SJ.call(null,c)))],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,CJ,new $APP.D(null,JJ,null,1,null),2,null),3,null),null,1,null),2,null),b($Ya)),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(c):CJ.call(null,c)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,JJ.j?
JJ.j(c):JJ.call(null,c)],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,CJ,new $APP.D(null,JJ,new $APP.D(null,SJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),b(aZa)),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(c):CJ.call(null,c)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,JJ.j?JJ.j(c):JJ.call(null,c)],null),
SJ.j?SJ.j(c):SJ.call(null,c)))],null))],null)))?c:dJ(c)})]))]))))};
hZa=function(a){return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.j(new $APP.D(null,$APP.Ev,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,UJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,VJ,null,1,null),2,null),3,null),4,null),5,null),6,null)),function(b){b=$APP.qe(b);var c=$APP.C.A(b,CJ),d=$APP.C.A(b,JJ);c=a.j?a.j(c):a.call(null,c);d=a.j?a.j(d):a.call(null,d);if($APP.k(fG.A(c,d))){var g=RJ.A(c,cZa);
if(g)return(c=b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TJ.j?TJ.j(b):TJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[c],null),UJ.j?UJ.j(b):UJ.call(null,b),VJ.j?VJ.j(b):VJ.call(null,b)]))))?c:dJ(b)}else if(g=RJ.B(c,d,cZa))return(c=b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TJ.j?TJ.j(b):TJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,c,d],null))],null))],null),UJ.j?UJ.j(b):UJ.call(null,
b),VJ.j?VJ.j(b):VJ.call(null,b)]))))?c:dJ(b);return g}),kJ(vJ.j(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null)),function(b){var c=$APP.qe(b);b=$APP.C.A(c,CJ);c=$APP.C.A(c,JJ);b=a.j?a.j(b):a.call(null,b);c=a.j?a.j(c):a.call(null,c);if($APP.k(fG.A(b,c))){var d=RJ.A(b,dZa);return d?1:d}return(d=RJ.B(b,c,dZa))?(b=$APP.r(new $APP.H(null,2,5,$APP.I,
[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,b,c],null))],null)))?b:dJ(b):d}),kJ(vJ.j(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,UJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null)),function(b){b=$APP.qe(b);var c=$APP.C.A(b,CJ),d=$APP.C.A(b,JJ);c=a.j?a.j(c):a.call(null,c);d=a.j?
a.j(d):a.call(null,d);if($APP.k(fG.A(c,d))){var g=RJ.A(c,eZa);if(g)return(c=b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TJ.j?TJ.j(b):TJ.call(null,b),$APP.y([UJ.j?UJ.j(b):UJ.call(null,b)]))))?c:dJ(b)}else if(g=RJ.B(c,d,eZa))return(c=b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TJ.j?TJ.j(b):TJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,c,d],null))],null))],null),UJ.j?UJ.j(b):UJ.call(null,
b)]))))?c:dJ(b);return g}),kJ(vJ.j(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,UJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null)),function(b){b=$APP.qe(b);var c=$APP.C.A(b,CJ),d=$APP.C.A(b,JJ);c=a.j?a.j(c):a.call(null,c);d=a.j?a.j(d):a.call(null,d);if($APP.k(fG.A(c,d))){var g=
RJ.A(c,fZa);if(g)return(c=b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TJ.j?TJ.j(b):TJ.call(null,b),$APP.y([UJ.j?UJ.j(b):UJ.call(null,b)])))],null)))?c:dJ(b)}else if(g=RJ.B(c,d,fZa))return(c=b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,c,d],null))],null)),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TJ.j?TJ.j(b):TJ.call(null,b),$APP.y([UJ.j?UJ.j(b):
UJ.call(null,b)])))],null)))?c:dJ(b);return g}),kJ(vJ.j(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,UJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,WJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null)),function(b){b=
$APP.qe(b);var c=$APP.C.A(b,CJ),d=$APP.C.A(b,JJ);c=a.j?a.j(c):a.call(null,c);d=a.j?a.j(d):a.call(null,d);if($APP.k(fG.A(c,d))){var g=RJ.A(c,gZa);if(g)return(c=b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TJ.j?TJ.j(b):TJ.call(null,b),$APP.y([UJ.j?UJ.j(b):UJ.call(null,b)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([WJ.j?WJ.j(b):WJ.call(null,b)])))],null)))?c:dJ(b)}else if(g=RJ.B(c,d,gZa))return(c=
b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TJ.j?TJ.j(b):TJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,c,d],null))],null))],null),UJ.j?UJ.j(b):UJ.call(null,b)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([WJ.j?WJ.j(b):WJ.call(null,b)])))],null)))?c:dJ(b);return g})]))]))};
iZa=function(a){return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,XJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,YJ,null,1,null),2,null),new $APP.D(null,ZJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,$J,null,1,null),2,null),new $APP.D(null,aK,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Fv],null),XJ.j?XJ.j(b):XJ.call(null,b),$APP.y([ZJ.j?ZJ.j(b):ZJ.call(null,b),aK.j?aK.j(b):
aK.call(null,b),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,YJ.j?YJ.j(b):YJ.call(null,b),$J.j?$J.j(b):$J.call(null,b)],null))],null))],null)]))))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.Gv,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.rj,CJ.j?CJ.j(b):CJ.call(null,b),JJ.j?JJ.j(b):JJ.call(null,b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,XJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,bK,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,cK,null,1,null),2,null),3,null),4,null),new $APP.D(null,dK,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,eK,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,
fK,null,1,null),2,null),3,null),4,null),new $APP.D(null,ZJ,null,1,null),2,null),3,null),4,null),5,null),6,null),function(b){var c=function(){var g=(g=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),bK.j?bK.j(b):bK.call(null,b),$APP.y([cK.j?cK.j(b):cK.call(null,b)]))))?g:dJ(g);return a.j?a.j(g):a.call(null,g)}(),d=function(){var g=(g=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),eK.j?eK.j(b):eK.call(null,b),$APP.y([fK.j?fK.j(b):fK.call(null,b)]))))?g:dJ(g);return a.j?a.j(g):
a.call(null,g)}();return $APP.k(UF(function(){var g=new $APP.D(null,$APP.Gv,new $APP.D(null,c,new $APP.D(null,d,null,1,null),2,null),3,null);return a.j?a.j(g):a.call(null,g)}()))?new $APP.f(null,1,[gK,c],null):null}),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(b):CJ.call(null,b),JJ.j?JJ.j(b):JJ.call(null,b)],null))],null)),gK.j?gK.j(b):
gK.call(null,b)],null))],null),XJ.j?XJ.j(b):XJ.call(null,b),$APP.y([dK.j?dK.j(b):dK.call(null,b),ZJ.j?ZJ.j(b):ZJ.call(null,b)]))))?b:dJ(b)})]))]))};
sZa=function(a){return yJ.C($APP.y([function(){var b=DH(hK);return pJ(function(){return!0},kJ(vJ.j(new $APP.D(null,hK,new $APP.D(null,JJ,new $APP.D(null,CJ,null,1,null),2,null),3,null)),function(c){var d=$APP.qe(c);c=$APP.C.A(d,CJ);d=$APP.C.A(d,JJ);var g=a.j?a.j(c):a.call(null,c),l=a.j?a.j(d):a.call(null,d);if($APP.k(fG.A(l,g))){if(EF(l))return $APP.k(qG.j(l))?$APP.M($APP.Gv,$APP.M($APP.rj,$APP.M($APP.Ev,3,nH),4)):$APP.M($APP.rj,nH,4);c=EJ.A(new $APP.D(null,jZa,new $APP.D(null,g,null,1,null),2,null),
kZa);return $APP.k(c)?$APP.M($APP.rj,nH,4):c}if(EF(l)&&EF(g))return b.A?b.A(l,g):b.call(null,l,g);var n=function(){var p=new $APP.D(null,iK,new $APP.D(null,l,new $APP.D(null,g,null,1,null),2,null),3,null);return a.j?a.j(p):a.call(null,p)}();if($APP.k(sG.j(n)))return null;c=EJ.A(new $APP.D(null,jZa,new $APP.D(null,n,null,1,null),2,null),lZa);return $APP.k(c)?(c=function(){var p=new $APP.D(null,$APP.rj,new $APP.D(null,l,new $APP.D(null,n,null,1,null),2,null),3,null);return a.j?a.j(p):a.call(null,p)}(),
d=function(){var p=new $APP.D(null,$APP.rj,new $APP.D(null,g,new $APP.D(null,n,null,1,null),2,null),3,null);return a.j?a.j(p):a.call(null,p)}(),(c=$APP.r(new $APP.H(null,3,5,$APP.I,[hK,c,d],null)))?c:dJ(c)):c}))}(),uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,jK,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),xJ),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,kK,new $APP.D(null,
CJ,null,1,null),2,null),null,1,null),2,null),xJ),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,lK,new $APP.D(null,new $APP.D(null,hK,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),xJ),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,kK,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(b):CJ.call(null,b),2],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,jK,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,JJ.j?JJ.j(b):JJ.call(null,b),2],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,
lK,new $APP.D(null,new $APP.D(null,jK,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,JJ.j?JJ.j(b):JJ.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,JJ.j?JJ.j(b):JJ.call(null,b),2],null))],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,lK,new $APP.D(null,new $APP.D(null,kK,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),
2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(b):CJ.call(null,b),2],null))],null))],null)),CJ.j?CJ.j(b):CJ.call(null,b)],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,hK,new $APP.D(null,GJ,new $APP.D(null,HJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,
$APP.I,[$APP.rj,GJ.j?GJ.j(b):GJ.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,GJ.j?GJ.j(b):GJ.call(null,b),2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,HJ.j?HJ.j(b):HJ.call(null,b),2],null))],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,hK,new $APP.D(null,GJ,new $APP.D(null,HJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.rj,HJ.j?HJ.j(b):HJ.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,GJ.j?GJ.j(b):GJ.call(null,b),2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,HJ.j?HJ.j(b):HJ.call(null,b),2],null))],null))],null))],null)))?b:dJ(b)})])),pJ(function(){return!0},uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,jK,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);
b=$APP.C.A(b,CJ);var c=a.j?a.j(b):a.call(null,b);b=EJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[jK,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,c],null))],null)),c],null));return b.call(EJ,c?c:dJ(c),mZa)}),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,kK,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,CJ);var c=a.j?a.j(b):a.call(null,
b);b=EJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[kK,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,c],null))],null)),c],null));return b.call(EJ,c?c:dJ(c),nZa)}),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,hK,new $APP.D(null,new $APP.D(null,lK,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,CJ);var c=a.j?a.j(b):a.call(null,b);b=EJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,
[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[hK,$APP.r(new $APP.H(null,2,5,$APP.I,[lK,c],null))],null)),c],null));return b.call(EJ,c?c:dJ(c),oZa)}),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,hK,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,CJ);var c=a.j?a.j(b):a.call(null,b);b=EJ.A;
c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,3,5,$APP.I,[hK,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,c],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,c],null))],null)),c],null));return b.call(EJ,c?c:dJ(c),pZa)}),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,jK,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,CJ);var c=a.j?a.j(b):a.call(null,b);b=EJ.A;
c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[jK,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,c],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),nH],null)),c],null))],null));return b.call(EJ,c?c:dJ(c),qZa)}),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),
nH],null)),CJ.j?CJ.j(b):CJ.call(null,b)],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,kK,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,CJ);var c=a.j?a.j(b):a.call(null,b);b=EJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Zv,$APP.r(new $APP.H(null,2,5,$APP.I,[kK,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,c],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.rj,1,2],null)),nH],null)),c],null))],null));return b.call(EJ,c?c:dJ(c),rZa)}),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),nH],null)),CJ.j?CJ.j(b):CJ.call(null,b)],null)))?b:dJ(b)})])))]))};
tZa=function(a){function b(n){var p=(new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).call(null,n);$APP.k(p)?n=p:(n=l.A?l.A(n,nH):l.call(null,n,nH),n=a.j?a.j(n):a.call(null,n),n=CF(n));return n}var c=DH($APP.Fv),d=DH($APP.Gv),g=DH($APP.Ev),l=DH($APP.rj);return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,
kH,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,b,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(0)?0:dJ(0)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,1,[qH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[qH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,1,[qH,null],null),null)).call(null,n);$APP.k(p)?n=
p:(p=l.A?l.A(nH,2):l.call(null,nH,2),n=d.A?d.A(n,p):d.call(null,n,p),p=g.A?g.A(2,nH):g.call(null,2,nH),n=l.A?l.A(n,p):l.call(null,n,p),n=a.j?a.j(n):a.call(null,n),n=CF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(1)?1:dJ(1)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,1,[rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[rH,null],
null),null)).j(n):(new $APP.ug(null,new $APP.f(null,1,[rH,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=l.A?l.A(nH,2):l.call(null,nH,2),n=c.A?c.A(n,p):c.call(null,n,p),p=g.A?g.A(2,nH):g.call(null,2,nH),n=l.A?l.A(n,p):l.call(null,n,p),n=a.j?a.j(n):a.call(null,n),n=CF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(-1)?-1:dJ(-1)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,function(n){var p=(new $APP.ug(null,
new $APP.f(null,2,[qH,null,rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=l.A?l.A(nH,2):l.call(null,nH,2),n=d.A?d.A(n,p):d.call(null,n,p),n=l.A?l.A(n,nH):l.call(null,n,nH),n=a.j?a.j(n):a.call(null,n),n=CF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(0)?0:dJ(0)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,
XI,new $APP.D(null,$APP.Hv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=g.A?g.A(2,nH):g.call(null,2,nH),n=l.A?l.A(n,p):l.call(null,n,p),n=a.j?a.j(n):a.call(null,n),n=CF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(1)?1:dJ(1)}),
kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,2,[mH,null,nH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[mH,null,nH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,2,[mH,null,nH,null],null),null)).call(null,n);$APP.k(p)?n=p:(n=d.A?d.A(n,nH):d.call(null,n,nH),p=g.A?g.A(2,nH):g.call(null,2,nH),n=l.A?l.A(n,p):l.call(null,n,p),n=a.j?a.j(n):a.call(null,n),n=CF(n));return n},
null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(-1)?-1:dJ(-1)}),kJ(vJ.A(new $APP.D(null,lK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,b,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(0)?0:dJ(0)}),kJ(vJ.A(new $APP.D(null,lK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,2,[mK,null,nK,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,
2,[mK,null,nK,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,2,[mK,null,nK,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=l.A?l.A(nH,4):l.call(null,nH,4),n=d.A?d.A(n,p):d.call(null,n,p),n=l.A?l.A(n,nH):l.call(null,n,nH),n=a.j?a.j(n):a.call(null,n),n=CF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(1)?1:dJ(1)}),kJ(vJ.A(new $APP.D(null,lK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,function(n){var p=(new $APP.ug(null,
new $APP.f(null,1,[oK,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[oK,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,1,[oK,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=l.A?l.A(nH,4):l.call(null,nH,4),n=c.A?c.A(n,p):c.call(null,n,p),n=l.A?l.A(n,nH):l.call(null,n,nH),n=a.j?a.j(n):a.call(null,n),n=CF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(){return $APP.k(-1)?-1:dJ(-1)})]))]))};
uZa=function(a){var b=pK.A(qK,new $APP.ug(null,new $APP.f(null,2,[kH,null,sH,null],null),null)),c=rK.C(sK.C(sH,$APP.y([jYa(function(d){return $APP.Uc.A(kH,d.j?d.j(qK):d.call(null,qK))})])),$APP.y([sK.C(kH,$APP.y([jYa(function(d){return $APP.Uc.A(sH,d.j?d.j(qK):d.call(null,qK))})]))]));return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,tK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,b,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,2,null,
1,null),2,null),3,null),new $APP.D(null,uK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,c,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,vK,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(d){return(d=$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Fv,1],null),tK.j?tK.j(d):tK.call(null,d),$APP.y([uK.j?uK.j(d):uK.call(null,d),vK.j?vK.j(d):vK.call(null,d)]))))?d:dJ(d)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,
tK,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,bK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,b,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,cK,null,1,null),2,null),3,null),4,null),new $APP.D(null,uK,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,eK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,c,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,2,null,1,null),2,null),3,
null),new $APP.D(null,fK,null,1,null),2,null),3,null),4,null),new $APP.D(null,vK,null,1,null),2,null),3,null),4,null),5,null),6,null),function(d){var g=function(){var n=(n=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),bK.j?bK.j(d):bK.call(null,d),$APP.y([cK.j?cK.j(d):cK.call(null,d)]))))?n:dJ(n);return a.j?a.j(n):a.call(null,n)}(),l=function(){var n=(n=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),eK.j?eK.j(d):eK.call(null,d),$APP.y([fK.j?fK.j(d):fK.call(null,d)]))))?n:dJ(n);
return a.j?a.j(n):a.call(null,n)}();return $APP.k(UF(function(){var n=new $APP.D(null,$APP.Gv,new $APP.D(null,g,new $APP.D(null,l,null,1,null),2,null),3,null);return a.j?a.j(n):a.call(null,n)}()))?new $APP.f(null,1,[gK,g],null):null}),function(d){return(d=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Fv],null),tK.j?tK.j(d):tK.call(null,d),$APP.y([uK.j?uK.j(d):uK.call(null,d),vK.j?vK.j(d):vK.call(null,d),new $APP.H(null,1,5,$APP.I,[gK.j?gK.j(d):gK.call(null,d)],null)]))))?d:dJ(d)})]))]))};
wZa=function(a){return oJ.C(vZa,$APP.y([uZa(a)]))};
xZa=function(a){var b=$APP.Hl.A(LF,a),c=new $APP.ug(null,new $APP.f(null,2,[kH,null,sH,null],null),null),d=new $APP.f(null,2,[sH,kH,kH,sH],null);return yJ.C($APP.y([function(){function g(l){var n=$APP.qe(l),p=$APP.C.A(n,AJ);l=$APP.C.A(n,qK);n=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,GJ.j?GJ.j(n):GJ.call(null,n),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[qK.j?qK.j(n):qK.call(null,n),CJ.j?CJ.j(n):CJ.call(null,n)],null)),RF.A(p,2)],null))],null));return $APP.k(b(n?n:dJ(n)))?
new $APP.f(null,1,[wK,d.j?d.j(l):d.call(null,l)],null):null}return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,tK,new $APP.D(null,GJ,new $APP.D(null,uK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,c,null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,tJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,
vK,null,1,null),2,null),3,null),4,null),5,null),6,null),g),function(l){return(l=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Fv],null),tK.j?tK.j(l):tK.call(null,l),$APP.y([uK.j?uK.j(l):uK.call(null,l),vK.j?vK.j(l):vK.call(null,l),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,GJ.j?GJ.j(l):GJ.call(null,l),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[wK.j?wK.j(l):wK.call(null,l),CJ.j?CJ.j(l):CJ.call(null,l)],null)),2],null))],null))],null)]))))?
l:dJ(l)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,tK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,c,null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,tJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,uK,new $APP.D(null,GJ,new $APP.D(null,vK,null,1,null),2,null),3,null),4,null),5,null),6,null),g),function(l){return(l=
$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Fv],null),tK.j?tK.j(l):tK.call(null,l),$APP.y([uK.j?uK.j(l):uK.call(null,l),vK.j?vK.j(l):vK.call(null,l),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,GJ.j?GJ.j(l):GJ.call(null,l),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[wK.j?wK.j(l):wK.call(null,l),CJ.j?CJ.j(l):CJ.call(null,l)],null)),2],null))],null))],null)]))))?l:dJ(l)})]))}(),function(){function g(l){var n=$APP.qe(l),p=$APP.C.A(n,AJ);l=$APP.C.A(n,
qK);n=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,GJ.j?GJ.j(n):GJ.call(null,n),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),xK.j?xK.j(n):xK.call(null,n),$APP.y([yK.j?yK.j(n):yK.call(null,n),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[qK.j?qK.j(n):qK.call(null,n),CJ.j?CJ.j(n):CJ.call(null,n)],null)),RF.A(p,2)],null))],null)])))],null));return $APP.k(b(n?n:dJ(n)))?new $APP.f(null,1,[wK,d.j?d.j(l):d.call(null,l)],null):null}return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,
$APP.Fv,new $APP.D(null,tK,new $APP.D(null,GJ,new $APP.D(null,uK,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,xK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,c,null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,tJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,yK,null,1,null),2,null),3,null),4,null),
new $APP.D(null,vK,null,1,null),2,null),3,null),4,null),5,null),6,null),g),function(l){return(l=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Fv],null),tK.j?tK.j(l):tK.call(null,l),$APP.y([uK.j?uK.j(l):uK.call(null,l),vK.j?vK.j(l):vK.call(null,l),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,GJ.j?GJ.j(l):GJ.call(null,l),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[wK.j?wK.j(l):wK.call(null,l),CJ.j?CJ.j(l):CJ.call(null,l)],null)),2],null))],null))],
null)]))))?l:dJ(l)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,tK,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,xK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,c,null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,tJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,yK,null,1,null),2,null),3,null),
4,null),new $APP.D(null,uK,new $APP.D(null,GJ,new $APP.D(null,vK,null,1,null),2,null),3,null),4,null),5,null),6,null),g),function(l){return(l=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Fv],null),tK.j?tK.j(l):tK.call(null,l),$APP.y([uK.j?uK.j(l):uK.call(null,l),vK.j?vK.j(l):vK.call(null,l),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,GJ.j?GJ.j(l):GJ.call(null,l),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[wK.j?wK.j(l):wK.call(null,l),CJ.j?
CJ.j(l):CJ.call(null,l)],null)),2],null))],null))],null)]))))?l:dJ(l)})]))}()]))};zK=function(a,b){return $APP.vd($APP.r($APP.kz.A(a,b)))};
zZa=function(a){var b=UYa(a),c=OYa(a),d=tZa(a),g=sZa(a),l=XYa(a);return function(n){var p=ZF(n),v=zK(new $APP.ug(null,new $APP.f(null,2,[kH,null,sH,null],null),null),p),t=zK(new $APP.ug(null,new $APP.f(null,3,[hK,null,kK,null,jK,null],null),null),p),A=zK(new $APP.ug(null,new $APP.f(null,2,[BJ,null,zJ,null],null),null),p),B=$APP.Bd(p,FJ);p=$APP.Bd(p,AK);n=b.j?b.j(n):b.call(null,n);A=A?c.j?c.j(n):c.call(null,n):n;A=p?yZa.j?yZa.j(A):yZa.call(null,A):A;A=t?g.j?g.j(A):g.call(null,A):A;A=$APP.k(v?!0:v)?
d.j?d.j(A):d.call(null,A):A;return v&&t?(v=g.j?g.j(A):g.call(null,A),l.j?l.j(v):l.call(null,v)):B?l.j?l.j(A):l.call(null,A):A}};BK=function(a,b,c,d,g){this.o=a;this.arity=b;this.name=c;this.context=d;this.ca=g;this.O=393473;this.U=0};CK=function(a,b,c,d,g){return new BK(a,b,c,d,g)};DK=function(a){return a instanceof BK};EK=function(a){return DK(a)?a.o:AD(["non-operator supplied: ",$APP.m.j(a)].join(""))};FK=function(a){return DK(a)?a.arity:AD(["non-operator supplied: ",$APP.m.j(a)].join(""))};
GK=function(a){return DK(a)?a.name:AD(["non-operator supplied: ",$APP.m.j(a)].join(""))};HK=function(a){return DK(a)?a.context:AD(["non-operator supplied: ",$APP.m.j(a)].join(""))};IK=function(a,b){return DK(a)?CK(a.o,a.arity,a.name,b,a.ca):AD(["non-operator supplied: ",$APP.m.j(a)].join(""))};
AZa=function(a,b){return JK.A(ZH.A(EK(a),b),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.KK,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,LK,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,GK(a),null,1,null)])))))};
BZa=function(a,b){return $APP.Jd(function(c,d,g){var l=d.j?d.j(c):d.call(null,c);return $APP.k(l)?$APP.Uc.A(g,l)?c:$APP.Uc.A(d,MK)&&$APP.vh(l,g)?$APP.rg.B(c,d,g):$APP.Uc.A(d,MK)&&$APP.vh(g,l)?c:AD(["incompatible operator context: ",$APP.m.j(HK(a)),$APP.m.j(HK(b))," at key: ",$APP.m.j(d)].join("")):$APP.rg.B(c,d,g)},HK(a),HK(b))};
CZa=function(a,b,c,d){var g=eI(c,new $APP.H(null,2,5,$APP.I,[fI,1],null));return CK(function(l){var n=WH.C($APP.y([g,l]));l=d.j?d.j(l):d.call(null,l);return a.A?a.A(n,l):a.call(null,n,l)},FK(d),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,b,null,1,null),new $APP.D(null,aG.j(c),null,1,null),$APP.y([new $APP.D(null,GK(d),null,1,null)])))),HK(d),null)};
DZa=function(a,b,c,d){var g=eI(d,new $APP.H(null,2,5,$APP.I,[fI,1],null));return CK(function(l){var n=c.j?c.j(l):c.call(null,l);l=WH.C($APP.y([g,l]));return a.A?a.A(n,l):a.call(null,n,l)},FK(c),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,b,null,1,null),new $APP.D(null,GK(c),null,1,null),$APP.y([new $APP.D(null,aG.j(d),null,1,null)])))),HK(c),null)};
EZa=function(a){return CK(function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(d){return PF.j($APP.Je.A(a,d))}b.G=0;b.K=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}(),FK(a),new $APP.D(null,$APP.Gv,new $APP.D(null,GK(a),null,1,null),2,null),HK(a),$APP.ed(a))};
FZa=function(a,b){var c=BZa(a,b);return $APP.k(KF.j(b))?IK(a,c):CK(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return yG.A($APP.Je.A(a,l),$APP.Je.A(b,l))}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),MWa(new $APP.H(null,2,5,$APP.I,[FK(a),FK(b)],null)),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Gv,null,1,null),new $APP.D(null,GK(a),
null,1,null),$APP.y([new $APP.D(null,GK(b),null,1,null)])))),c,null)};
GZa=function(a,b){var c=BZa(a,b);return $APP.k(KF.j(a))?IK(b,c):$APP.k(KF.j(b))?IK(a,c):CK(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return eH.A($APP.Je.A(a,l),$APP.Je.A(b,l))}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),MWa(new $APP.H(null,2,5,$APP.I,[SH(a),SH(b)],null)),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,
null),new $APP.D(null,GK(a),null,1,null),$APP.y([new $APP.D(null,GK(b),null,1,null)])))),c,null)};
HZa=function(a,b){return CK(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return MF.A(a,$APP.Je.A(b,g))}c.G=0;c.K=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),FK(b),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,aG.j(a),null,1,null),$APP.y([new $APP.D(null,GK(b),null,1,null)])))),HK(b),$APP.ed(b))};
IZa=function(a,b){return CK(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return $APP.Je.A(a,$APP.Vg.A(function(l){return MF.A(b,l)},g))}c.G=0;c.K=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),FK(a),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,GK(a),null,1,null),$APP.y([new $APP.D(null,aG.j(b),null,1,null)])))),
HK(a),$APP.ed(a))};JZa=function(a,b){return CK(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return MF.A(OF.j(b),$APP.Je.A(a,g))}c.G=0;c.K=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),FK(a),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.rj,null,1,null),new $APP.D(null,GK(a),null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))),HK(a),$APP.ed(a))};
NK=function(a,b){return RF.A(iG.A(a,b),iG.A(b,a))};KZa=function(a,b){return kG.A(iG.A(a,b),iG.A(b,a))};LZa=function(a){return CK(OK.j?OK.j(a):OK.call(null,a),new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.T.j($APP.r($APP.N.A(new $APP.D(null,zJ,null,1,null),new $APP.D(null,GK(a),null,1,null)))),HK(a),$APP.ed(a))};MZa=function(a,b){return a===b?1:0};PK=function(a,b,c){this.orientation=a;this.v=b;this.ca=c;this.O=2310931231;this.U=131072};QK=function(a,b,c){return new PK(a,b,c)};
RK=function(a){return $APP.od(a)?a:a instanceof PK?a.v:AD(["non-structure supplied: ",$APP.m.j(a)].join(""))};TK=function(a){return a instanceof PK?a.orientation:SK};UK=function(a){return $APP.kd(a)?$APP.Tc($APP.ef(a)):1};NZa=function(a,b){return $APP.kd(a)?$APP.x.A(a,b):$APP.Uc.A(b,0)?a:AD(["non-sequential s:nth not supported: ",$APP.m.j(a)," with index !\x3d 0: ",$APP.m.j(b)].join(""))};
OZa=function(a,b){if(b instanceof PK){var c=$APP.Uc.A(a.orientation,b.orientation);return c?fG.A(a.v,b.v):c}return $APP.Uc.A(a.orientation,SK)?$APP.od(b)?fG.A(a.v,b):$APP.ud(b)?fG.A($APP.r(a),$APP.r(b)):!1:!1};VK=function(a){return a instanceof PK||$APP.od(a)};WK=function(a){return $APP.od(a)||a instanceof PK&&$APP.Uc.A(SK,a.orientation)};PZa=function(a){return a instanceof PK&&$APP.Uc.A(XK,a.orientation)};
QZa=function(a){return $APP.Bd(new $APP.ug(null,new $APP.f(null,2,[SK,null,XK,null],null),null),a)};RZa=function(a,b){return $APP.Uc.A(TK(a),TK(b))};YK=function(a){var b=$APP.Tc(a),c=TK(a),d=$APP.Lf.B($APP.vg,$APP.Vg.j(function(l){return VK(l)?$APP.Tc(l):1}),a),g=$APP.Lf.B($APP.vg,$APP.Vg.j(TK),a);return $APP.Ge(VK,a)&&$APP.Uc.A(1,$APP.Tc(g))&&$APP.Uc.A(1,$APP.Tc(d))?new $APP.f(null,4,[SZa,c,TZa,$APP.u(g),UZa,b,VZa,$APP.u(d)],null):null};
WZa=function(a,b){return function(c){c=YK(c);c=$APP.k(c)?$APP.Uc.A(a,SZa.j(c))&&$APP.Uc.A(b,TZa.j(c)):null;return $APP.vd(c)}};XZa=function(a){return $APP.vd(YK(a))};ZK=function(a,b){b=$APP.od(b)?b:$APP.Lf.A($APP.sf,b);return QK(a,b,null)};$K=function(a){return ZK(SK,a)};YZa=function(a){return QK(SK,a,null)};aL=function(a){return ZK(XK,a)};ZZa=function(a){return QK(XK,a,null)};bL=function(a,b){return ZK(TK(a),b)};cL=function(a,b,c){return QK(b,$APP.Fl.A(c,$APP.Hj.j(a)),null)};
eL=function(a,b,c){var d=dL.j?dL.j(c):dL.call(null,c),g=[$APP.m.j(a),$APP.m.j(d)].join("");return cL(b,c,function(l){return $APP.Zg.j([g,$APP.m.j(l)].join(""))})};fL=function(a,b){return eL(a,b,SK)};gL=function(a,b){return eL(a,b,XK)};$Za=function(a,b){function c(g){var l=$APP.Vg.A(function(n){return NZa(n,g)},b);return $APP.Je.A(a,l)}var d=$APP.x.B(b,0,null);d=$APP.Tc(d);return hL.B?hL.B(c,0,d):hL.call(null,c,0,d)};
a_a=function(a,b){var c=$APP.x.B(b,0,null);return VK(c)?cL($APP.Tc(c),TK(c),function(d){var g=$APP.Vg.A(function(l){return NZa(l,d)},b);return $APP.Je.A(a,g)}):$APP.Je.A(a,b)};iL=function(a,b){return function n(d,g,l){if(VK(d)){var p=TK(d);return cL($APP.Tc(d),TK(d),function(v){return n(NZa(d,v),$APP.Vd.A(g,v),$APP.Vd.A(l,p))})}return a.B?a.B(d,g,l):a.call(null,d,g,l)}(b,$APP.sf,$APP.sf)};jL=function(a){return VK(a)?iL(function(b,c,d){return $APP.z($APP.r(c),new $APP.f(null,1,[b_a,d],null))},a):null};
c_a=function(a,b){return kL.C(function(c){var d=$APP.Vg.A(dL,b_a.j($APP.ed(c)));c=$APP.Vg.B($APP.m,d,c);return $APP.Zg.j($APP.Je.B($APP.m,a,c))},$APP.y([jL(b)]))};d_a=function(a){var b=TK(a);return a_a(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return ZK(b,g)}c.G=0;c.K=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),a)};
lL=function(a){return kL.C(function(){return $APP.Nj.j($APP.Vv)},$APP.y([a]))};nL=function(a){return tG.j(mL(a))};oL=function(a){return lL(mL(a))};e_a=function(a,b){return bL(a,$APP.Vg.A(function(c){return iG.A(c,b)},a))};f_a=function(a,b){return bL(b,$APP.Vg.A(function(c){return iG.A(a,c)},b))};pL=function(a,b){return $APP.Je.A(kG,$APP.Vg.B(iG,a,b))};g_a=function(a,b){return pL(qL.j(a),b)};
sL=function(a,b){return rL(a,b)?pL(a,b):$APP.k(function(){return $APP.k(!0)?!0:!RZa(a,b)&&$APP.Ge(function(c){return rL(a,c)},b)}())?f_a(a,b):AD(["Incompatible multiplication: ",$APP.m.j(a),$APP.m.j(b)].join(""))};tL=function(a,b){var c=mL(a);return rL(c,b)?pL(c,b):AD(["incompatible structures: dot-product ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))};h_a=function(a,b){return kL.C(function(c){return kL.C(function(d){return iG.A(c,d)},$APP.y([a]))},$APP.y([b]))};
i_a=function(a,b){($APP.qg.A($APP.Tc(a),3)||$APP.qg.A($APP.Tc(b),3))&&AD("cross product only works on two elements of ^3");var c=$APP.x.B(a,0,null),d=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);var g=$APP.x.B(b,0,null),l=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return uL.C($APP.y([RF.A(iG.A(d,b),iG.A(a,l)),RF.A(iG.A(a,g),iG.A(c,b)),RF.A(iG.A(c,l),iG.A(d,g))]))};j_a=function(a,b,c){return $APP.Uc.A($APP.Tc(b),$APP.Tc(c))?QK(TK(b),$APP.Fl.B(a,b,c),null):CD([$APP.m.j(a)," provided arguments of differing length"].join(""))};
vL=function(a,b,c){this.arity=a;this.Ra=b;this.ca=c;this.O=2158362625;this.U=0};wL=function(a,b,c){return new vL(a,b,c)};xL=function(a){return a instanceof vL};yL=function(a,b){if($APP.hd(b))return 0;if($APP.Uc.A($APP.Tc(b),1)&&$APP.hd(vI($APP.x.A(b,0)))){var c=wI($APP.x.A(b,0));return xL(c)?wL(a,b,null):c}return wL(a,b,null)};AL=function(a){return $APP.Vg.A(function(b){return zL.A(a,b)},$APP.Hj.A(0,a))};k_a=function(a){return bG.j(oXa(a,zL.J()))};
l_a=function(a,b,c){if($APP.k(KF.j(b)))return b;if(0===c)return BL.A(a,b);b=xI.A(yI.A?yI.A(0,c):yI.call(null,0,c),b);return wL(a,new $APP.H(null,1,5,$APP.I,[b],null),null)};CL=function(a){return xL(a)?a.arity:0};m_a=function(a){return xL(a)?a.Ra:$APP.od(a)?a:$APP.k(KF.j(a))?$APP.sf:new $APP.H(null,1,5,$APP.I,[xI.j(a)],null)};
n_a=function(a,b){var c=xL(a),d=xL(b);return c&&d?(a=a.arity,b=b.arity,$APP.Uc.A(a,b)?a:CD(["mismatched polynomial arity: ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))):c?a.arity:d?b.arity:0};o_a=function(a,b){return 0<=b&&b<CL(a)};p_a=function(a,b){return o_a(a,b)?b:CD(["Supplied i ",$APP.m.j(b)," outside the bounds of arity ",$APP.m.j(CL(a))," for input ",$APP.m.j(a)].join(""))};
DL=function(a,b){if(b instanceof vL){var c=$APP.Uc.A(a.arity,b.arity);return c?fG.A(a.Ra,b.Ra):c}a=a.Ra;return(c=1>=$APP.Tc(a))?(c=$APP.fd(a),(a=$APP.hd(vI(c)))?fG.A(b,wI(c)):a):c};EL=function(a){return xL(a)?$APP.Vg.A(wI,m_a(a)):$APP.k(KF.j(a))?$APP.sf:new $APP.H(null,1,5,$APP.I,[a],null)};FL=function(a){a=$APP.fd(m_a(a));return $APP.k(a)?a:new $APP.H(null,2,5,$APP.I,[sI,0],null)};GL=function(a){return xL(a)?wI($APP.fd(a.Ra)):a};q_a=function(a){for(;;)if(xL(a))a=GL(a);else return a};
r_a=function(a){return!xL(a)||$APP.Uc.A(1,$APP.Tc(a.Ra))};s_a=function(a){return xL(a)&&$APP.Uc.A(a.arity,1)};t_a=function(a){return xL(a)&&1<a.arity};HL=function(a){return qG.j(q_a(a))};IL=function(a,b){return xL(b)?yL(b.arity,iXa(a,b.Ra)):a.j?a.j(b):a.call(null,b)};u_a=function(a,b){return $APP.k(KF.j(b))?b:IL(function(c){return iG.A(c,b)},a)};v_a=function(a,b){return $APP.k(KF.j(a))?a:IL(function(c){return iG.A(a,c)},b)};w_a=function(a){if(xL(a)){var b=a.arity;a=$APP.gd(a.Ra);return yL(b,a)}return 0};
y_a=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=4<b.length?new $APP.Bc(b.slice(4),0,null):null;return x_a(arguments[0],arguments[1],arguments[2],arguments[3],b)};
x_a=function(a,b,c,d,g){g=$APP.qe(g);g=$APP.C.B(g,z_a,yL);var l=xL(a),n=xL(b);return l&&n?(c=n_a(a,b),l=function(){var p=a.Ra,v=b.Ra;return d.A?d.A(p,v):d.call(null,p,v)}(),g.A?g.A(c,l):g.call(null,c,l)):l?(c=a.arity,l=function(){var p=a.Ra,v=fXa(b);return d.A?d.A(p,v):d.call(null,p,v)}(),g.A?g.A(c,l):g.call(null,c,l)):n?(c=b.arity,l=function(){var p=fXa(a),v=b.Ra;return d.A?d.A(p,v):d.call(null,p,v)}(),g.A?g.A(c,l):g.call(null,c,l)):c.A?c.A(a,b):c.call(null,a,b)};JL=function(a){return IL(PF,a)};
A_a=function(a){return $APP.k(HL(a))?JL(a):a};KL=function(a,b){return y_a(a,b,eH,jXa)};LL=function(a,b){return y_a(a,b,yG,kXa)};ML=function(a,b){return y_a(a,b,MF,mXa)};NL=function(a){return ML(a,a)};OL=function(a){return ML(a,ML(a,a))};
PL=function(a,b){if(xL(a))if($APP.xd(b))if(0>b)a=AD(["No inverse -- FPF:EXPT:",$APP.m.j(a),$APP.m.j(b)].join(""));else{if(!$APP.k(sG.j(a)))if($APP.k(KF.j(a)))a=$APP.k(KF.j(b))?CD("poly 0^0"):a;else a:for(var c=1;;){if(0===b){a=c;break a}if($APP.Ie(b))a=ML(a,a),b=$APP.Pd(b,2);else{var d=a;--b;c=ML(a,c);a=d}}}else a=AD(["Can only raise an FPF to an exact integer power: ",$APP.m.j(a),$APP.m.j(b)].join(""));else a=rI.A(a,b);return a};
QL=function(a,b){return $APP.k(KF.j(b))?AD("internal polynomial division by zero"):$APP.k(function(){var c=KF.j(a);return $APP.k(c)?c:sG.j(b)}())?new $APP.H(null,2,5,$APP.I,[a,0],null):x_a(a,b,function(c,d){return new $APP.H(null,2,5,$APP.I,[qI.A(c,d),AG.A(c,d)],null)},nXa,$APP.y([z_a,function(c,d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return new $APP.H(null,2,5,$APP.I,[yL(c,g),yL(c,d)],null)}]))};
RL=function(a,b){if($APP.k(sG.j(b)))return a;var c=QL(a,b),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);$APP.k(KF.j(c))||BD(["expected even division left a remainder! ",$APP.m.j(a)," / ",$APP.m.j(b)," r ",$APP.m.j(c)].join(""));return d};B_a=function(a){return CF(a)?BigInt(a):a};
C_a=function(a,b){var c=FL(b),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);c=B_a(c);d=tI(d);for(var g=0;;){var l=SL.j(a),n=GL(a);n=B_a(n);if(l<d)return new $APP.H(null,2,5,$APP.I,[a,g],null);a=bG.j(LL(u_a(a,c),ML(l_a(1,n,l-d),b)));g+=1}};D_a=function(a,b){return o_a(a,b)&&0===SL.A(a,b)};
E_a=function(a){function b(d){return TL.A(c-1,function(){return function n(l){return new $APP.de(null,function(){for(;;){var p=$APP.r(l);if(p){if($APP.pd(p)){var v=$APP.lc(p),t=$APP.Tc(v),A=$APP.fe(t);a:for(var B=0;;)if(B<t){var G=$APP.bd(v,B),J=$APP.x.B(G,0,null);G=$APP.x.B(G,1,null);$APP.je(A,new $APP.H(null,2,5,$APP.I,[YWa(J,0),G],null));B+=1}else{v=!0;break a}return v?$APP.ie($APP.ke(A),n($APP.mc(p))):$APP.ie($APP.ke(A),null)}v=$APP.u(p);A=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);return $APP.Yd(new $APP.H(null,
2,5,$APP.I,[YWa(A,0),v],null),n($APP.Fc(p)))}return null}},null,null)}(d)}())}var c=a.arity;return TL.A(1,$APP.Vg.A(function(d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);g=0===g?sI:yI.A?yI.A(0,g):yI.call(null,0,g);return xI.A(g,b(d))},$APP.oh(function(d){return uI(vI(d),0)},a.Ra)))};
F_a=function(a,b){if(xL(a)){var c=hXa(function(){return function l(g){return new $APP.de(null,function(){for(var n=g;;){var p=$APP.r(n);if(p){var v=p,t=$APP.u(v),A=$APP.x.B(t,0,null),B=$APP.x.B(t,1,null);if(p=$APP.r(function(G,J,O,Q,W,Z){return function ja(ha){return new $APP.de(null,function(ta,ua,ca){return function(){for(;;){var V=$APP.r(ha);if(V){if($APP.pd(V)){var da=$APP.lc(V),Y=$APP.Tc(da),ea=$APP.fe(Y);a:for(var ya=0;;)if(ya<Y){var wa=$APP.bd(da,ya),Ba=$APP.x.B(wa,0,null);wa=$APP.x.B(wa,1,
null);Ba=ZWa(Ba,0,uI(ca,0));$APP.je(ea,xI.A(Ba,wa));ya+=1}else{da=!0;break a}return da?$APP.ie($APP.ke(ea),ja($APP.mc(V))):$APP.ie($APP.ke(ea),null)}da=$APP.u(V);ea=$APP.x.B(da,0,null);da=$APP.x.B(da,1,null);ea=ZWa(ea,0,uI(ca,0));return $APP.Yd(xI.A(ea,da),ja($APP.Fc(V)))}return null}}}(G,J,O,Q,W,Z),null,null)}}(n,t,A,B,v,p)(m_a(B))))return $APP.N.A(p,l($APP.Fc(n)));n=$APP.Fc(n)}else return null}},null,null)}(a.Ra)}());return wL(b,c,$APP.ed(a))}return BL.A(b,a)};
G_a=function(a,b,c){var d=n_a(a,b);a=E_a(a);b=E_a(b);c=c.A?c.A(a,b):c.call(null,a,b);return xL(c)?F_a(c,d):c};H_a=function(a,b){if(xL(a)){a=a.Ra;for(var c=0,d=1,g=0;;){var l=$APP.x.A(a,0);if($APP.k(l)){var n=l;l=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);l=uI(l,0);d=iG.A(d,rI.A(b,l-g));a=$APP.w(a);c=kG.A(c,iG.A(n,d));g=l}else return c}}else return a};
UL=function(a,b){for(;;)if(xL(a)){var c=a.arity;if($APP.hd(b))return a;if($APP.k(KF.j(a)))return 0;var d=$APP.u(b);d=xL(d)&&1<c?BL.A(c-1,d):d;if($APP.Uc.A(c,1))return H_a(a,d);a=H_a(E_a(a),d);if(xL(a))b=$APP.w(b);else return a}else return a};I_a=function(a,b){return UL(a,$APP.Vg.B(ML,b,AL(CL(a))))};J_a=function(a,b){return UL(a,$APP.Vg.B(KL,b,AL(CL(a))))};
VL=function(a,b){return xL(a)?(p_a(a,b),TL.A(a.arity,function(){return function g(d){return new $APP.de(null,function(){for(var l=d;;)if(l=$APP.r(l)){if($APP.pd(l)){var n=$APP.lc(l),p=$APP.Tc(n),v=$APP.fe(p);return function(){for(var J=0;;)if(J<p){var O=$APP.bd(n,J),Q=$APP.x.B(O,0,null),W=$APP.x.B(O,1,null),Z=Q.A?Q.A(b,0):Q.call(null,b,0);$APP.qg.A(0,Z)&&(O=v,Q=$APP.Uc.A(1,Z)?$APP.Oi.A(Q,b):$APP.Fj.B(Q,b,$APP.Ld),W=iG.A(Z,W),Q=xI.A(Q,W),O.add(Q));J+=1}else return!0}()?$APP.ie($APP.ke(v),g($APP.mc(l))):
$APP.ie($APP.ke(v),null)}var t=$APP.u(l),A=$APP.x.B(t,0,null),B=$APP.x.B(t,1,null),G=A.A?A.A(b,0):A.call(null,b,0);if($APP.qg.A(0,G))return $APP.Yd(function(){var J=$APP.Uc.A(1,G)?$APP.Oi.A(A,b):$APP.Fj.B(A,b,$APP.Ld),O=iG.A(G,B);return xI.A(J,O)}(),g($APP.Fc(l)));l=$APP.Fc(l)}else return null},null,null)}(a.Ra)}())):0};
K_a=function(a){return xL(a)?function d(c){return new $APP.de(null,function(){for(;;){var g=$APP.r(c);if(g){if($APP.pd(g)){var l=$APP.lc(g),n=$APP.Tc(l),p=$APP.fe(n);a:for(var v=0;;)if(v<n){var t=$APP.bd(l,v);$APP.je(p,VL(a,t));v+=1}else{l=!0;break a}return l?$APP.ie($APP.ke(p),d($APP.mc(g))):$APP.ie($APP.ke(p),null)}p=$APP.u(g);return $APP.Yd(VL(a,p),d($APP.Fc(g)))}return null}},null,null)}($APP.Hj.j(a.arity)):$APP.sf};
WL=function(a,b){if(xL(a)){var c=$APP.Vg.j(function(d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return $APP.Vs.M($APP.gp.j(function(l,n){l=uI(g,l);return L_a.A?L_a.A(n,l):L_a.call(null,n,l)}),M_a,YF(d),b)});a=$APP.Qb(a.Ra);return $APP.Vs.B(c,N_a,a)}return YF(a)};
ZL=function(a,b){for(var c=new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[XL,XL],null),new $APP.H(null,2,5,$APP.I,[YL,XL],null),new $APP.H(null,2,5,$APP.I,[XL,YL],null)],null),d=$APP.r(c),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n),v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[v,t],null),function(){return function(G,J){return b.A?b.A(G,J):b.call(null,G,J)}}(d,g,l,n,p,v,t,c));n+=1}else{var A=$APP.r(d);if(A){p=A;if($APP.pd(p))d=$APP.lc(p),n=$APP.mc(p),g=d,l=
$APP.Tc(d),d=n;else{var B=$APP.u(p);v=$APP.x.B(B,0,null);t=$APP.x.B(B,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[v,t],null),function(){return function(G,J){return b.A?b.A(G,J):b.call(null,G,J)}}(d,g,l,n,B,v,t,p,A,c));d=$APP.w(p);g=null;l=0}n=0}else break}};O_a=function(){var a=(new Date).getTime();return function(){return 1E6*((new Date).getTime()-a)}};
P_a=function(a){if(null!=a&&null!=a.Cf)a=a.Cf(a);else{var b=P_a[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=P_a._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IStopwatch.start",a);}return a};$L=function(a,b){if(null!=a&&null!=a.Mg)a=a.Mg(a,b);else{var c=$L[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=$L._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("IStopwatch.-elapsed",a);}return a};
aM=function(a){if(null!=a&&null!=a.Bf)a=a.Bf(a);else{var b=aM[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=aM._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IStopwatch.repr",a);}return a};
Q_a=function(a,b){return a/function(){switch(b instanceof $APP.E?b.ga:null){case "nanos":return 1;case "micros":return 1E3;case "millis":return 1E6;case "seconds":return 1E9;case "minutes":return 6E10;case "hours":return 36E11;case "days":return 864E11;default:return AD(["Unknown unit: ",$APP.m.j(b)].join(""))}}()};
T_a=function(a){var b=$APP.u($APP.df.A($APP.Hl.A(function(c){return 1<c},$APP.u),$APP.Vg.A($APP.wi.A(function(c){return Q_a(a,c)},$APP.Kd),$APP.Wd(R_a))));return $APP.k(b)?b:new $APP.H(null,2,5,$APP.I,[0,S_a],null)};bM=function(a,b,c){this.Ig=a;this.offset=b;this.gi=c};
W_a=function(a){var b=$APP.kh.j(a);if("undefined"===typeof cM||"undefined"===typeof U_a||"undefined"===typeof V_a||"undefined"===typeof dM)dM=function(c,d,g){this.Xk=c;this.gf=d;this.nk=g;this.O=393216;this.U=0},dM.prototype.da=function(c,d){return new dM(this.Xk,this.gf,d)},dM.prototype.ba=function(){return this.nk},dM.prototype.Cf=function(){$APP.lh.A(this.gf,P_a);return this},dM.prototype.Mg=function(c,d){return $L($APP.Fb(this.gf),d)},dM.prototype.Bf=function(){return aM($APP.Fb(this.gf))},dM.prototype.toString=
function(){return aM($APP.Fb(this.gf))},dM.cb=!0,dM.Ya="emmy.util.stopwatch/t_emmy$util$stopwatch47082",dM.gb=function(c){return $APP.Vb(c,"emmy.util.stopwatch/t_emmy$util$stopwatch47082")};return new dM(a,b,$APP.F)};Y_a=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=0<b.length?new $APP.Bc(b.slice(0),0,null):null;b=$APP.qe(b);b=$APP.C.B(b,X_a,!0);c=new bM(null,0,!1);return W_a($APP.k(b)?c.Cf(null):c)};
Z_a=function(a,b,c){if($APP.k(!1)){c=$APP.Vg.A($APP.m,c);b=$APP.Lf.A(new $APP.H(null,2,5,$APP.I,[b,a],null),c);var d=$APP.Il.A(" ",b),g=$APP.Je.A($APP.m,$APP.Uj.A(a,"  "));$G($APP.xu,"emmy.polynomial.gcd",90,new $APP.bh(function(){return new $APP.H(null,2,5,$APP.I,[g,d],null)},null),117156733)}};$_a=function(){var a=eM;if($APP.k(a)){var b=fM;a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return $L(eM,b)>a}return a};
a0a=function(a){if($APP.k($_a())){var b=HG("Timed out: %s after %s",a,aM(eM));$G($APP.hw,"emmy.polynomial.gcd",108,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,[b],null)},null),663336066);cOa(b)}};b0a=function(a,b){var c=fM,d=eM,g=Y_a();fM=a;eM=g;try{return b.J?b.J():b.call(null)}finally{eM=d,fM=c}};
f0a=function(a,b,c){if($APP.k(!0)){var d=new $APP.H(null,2,5,$APP.I,[b,c],null);var g=$APP.Fb(c0a);d=g.j?g.j(d):g.call(null,d)}else d=!0;if($APP.k(d))return $APP.lh.A(d0a,$APP.Lc),d;a=a.A?a.A(b,c):a.call(null,b,c);$APP.k(!0)&&($APP.lh.A(e0a,$APP.Lc),$APP.lh.M(c0a,$APP.rg,new $APP.H(null,2,5,$APP.I,[b,c],null),a));return a};
g0a=function(a,b,c){if(t_a(a)||t_a(b)){var d=$APP.Lf.A(xL(a)?a.Ra:$APP.sf,xL(b)?b.Ra:$APP.sf);d=1>=$APP.Tc(d)?new $APP.H(null,2,5,$APP.I,[$APP.Kd,$APP.Kd],null):$Wa($APP.Vs.B($APP.Vg.j(vI),gM,d));var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var l=hM.A;a=hM.A(g,a);b=hM.A(g,b);c=c.A?c.A(a,b):c.call(null,a,b);return l.call(hM,d,c)}return c.A?c.A(a,b):c.call(null,a,b)};
h0a=function(a,b){var c=EL(a);if($APP.Uc.A(1,$APP.Tc(c))){var d=$APP.u(c);a=IL(function(){return 1},a)}else d=$APP.Je.A(b,c),a=$APP.k(sG.j(d))?a:IL(function(g){return iM.A(g,d)},a);return new $APP.H(null,2,5,$APP.I,[d,a],null)};i0a=function(a){return function(b,c,d){var g=h0a(b,a);b=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var l=h0a(c,a);c=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);b=a.A?a.A(b,c):a.call(null,b,c);d=d.A?d.A(g,l):d.call(null,g,l);d=xL(d)?d:BL.A(1,d);return v_a(b,d)}};
k0a=function(){var a=jM;return function(b,c,d){var g=$APP.Id.A($APP.Lf,$APP.Vg.A($APP.Hl.A(tD,vI),b.Ra)),l=$APP.Id.A($APP.Lf,$APP.Vg.A($APP.Hl.A(tD,vI),c.Ra));return $APP.hd($APP.kz.A(g,l))?($APP.lh.A(j0a,$APP.Lc),$APP.Je.A(a,$APP.N.A(EL(b),EL(c)))):d.A?d.A(b,c):d.call(null,b,c)}};kM=function(a,b){return $APP.Je.B(jM,b,EL(a))};l0a=function(a,b){return $APP.k(KF.j(a))?hG.j(b):$APP.k(KF.j(b))?hG.j(a):xL(a)?xL(b)?$APP.Uc.A(a,b)?A_a(a):null:kM(a,b):xL(b)?kM(b,a):jM(a,b)};
n0a=function(a,b){var c=$APP.x.A(a.Ra,0),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);d=$APP.Vs.M($APP.Vg.j(vI),lM,d,b.Ra);b=kM(b,c);$APP.lh.A(m0a,$APP.Lc);return yL(a.arity,new $APP.H(null,1,5,$APP.I,[xI.A(d,b)],null))};o0a=function(a){return function(b,c){for(;;){a0a("euclid inner loop");var d=l0a(b,c);if($APP.k(d))return d;b=C_a(b,c);d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);if($APP.k(KF.j(d)))return hG.j(c);b=h0a(d,a);$APP.x.B(b,0,null);d=$APP.x.B(b,1,null);b=c;c=d}}};
p0a=function(a,b){return mM.B(new $APP.H(null,2,5,$APP.I,[a,b],null),i0a(jM),o0a(jM))};q0a=function(a,b){return mM.C(new $APP.H(null,2,5,$APP.I,[a,b],null),k0a(),g0a,$APP.y([nM]))};r0a=function(a,b){var c=l0a(a,b);return $APP.k(c)?c:b0a(fM,function(){return q0a(a,b)})};s0a=function(a,b){if(xL(a)||xL(b)){var c=r0a(a,b);return A_a(ML(RL(a,c),b))}return oM.A(a,b)};t0a=function(a){return xL(a)?$APP.Vs.B($APP.$t.j(sG),pM,K_a(a)):1};
u0a=function(a){for(var b=0,c=a,d=$APP.sf,g=a,l=1;;){if($APP.k(sG.j(b)))return b=$APP.fd(d),EF(b)?$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[b],null),$APP.oi.A($APP.Vd.A($APP.gd(d),1),1)):$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[c],null),$APP.oi.A(d,1));a=t0a(c);b=RL(c,pM.A?pM.A(c,a):pM.call(null,c,a));a=pM.A?pM.A(a,b):pM.call(null,a,b);g=RL(g,b);l=pM.A?pM.A(g,l):pM.call(null,g,l);var n=RL(b,a);g=a;c=RL(c,ML(a,b));d=$APP.Vd.C(d,l,$APP.y([n]));l=b;b=g;g=l;l=a}};
v0a=function(a){var b=DH(DJ);return $APP.Yd($APP.Ev,$APP.gp.A(function(c,d){return 0===c?d:b.A?b.A(d,c):b.call(null,d,c)},a))};
x0a=function(a){for(var b=function(){var B=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a));return qM.j?qM.j(B):qM.call(null,B)}(),c=DH(DJ),d=DH($APP.Ev),g=DH(FJ),l=$APP.k(hH(b))?$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b):new $APP.H(null,1,5,$APP.I,[b],null),n=b=1;;){if($APP.hd(l))return $APP.Uc.A(n,1)||EJ.A($APP.T.j($APP.r($APP.N.A(new $APP.D(null,rM,null,1,null),new $APP.D(null,n,null,1,null)))),w0a),g=g.j?g.j(b):g.call(null,b),b=n,d.A?d.A(g,b):d.call(null,g,b);var p=$APP.r(l);l=$APP.u(p);p=
$APP.w(p);if($APP.k(bH(l))){var v=$APP.Fc.j?$APP.Fc.j(l):$APP.Fc.call(null,l),t=$APP.x.B(v,0,null),A=$APP.x.B(v,1,null);$APP.xd(A)&&$APP.Ie(A)?(l=p,n=p=function(){var B=$APP.Pd(A,2);if(1<B){var G=n;B=c.A?c.A(t,B):c.call(null,t,B);return d.A?d.A(G,B):d.call(null,G,B)}return $APP.Uc.A(B,1)?d.A?d.A(n,t):d.call(null,n,t):n}()):(b=d.A?d.A(l,b):d.call(null,l,b),v=n,l=p,n=v)}else b=d.A?d.A(l,b):d.call(null,l,b),v=n,l=p,n=v}};z0a=function(a){return $APP.nz(function(b){return $APP.k(y0a(b))?x0a(b):b},a)};
A0a=function(a,b){return function l(d,g){if($APP.hd(d))return 0;if($APP.Uc.A(1,$APP.Tc(d)))return g=$APP.x.B(d,0,null),$APP.x.B(g,0,null),$APP.x.B(g,1,null);var n=$APP.gd(d),p=$APP.oi.A(d,1),v=$APP.gd(p),t=$APP.u(d);t=$APP.x.B(t,0,null);d=$APP.fd(d);d=$APP.x.B(d,0,null);n=l(n,g);p=l(p,g);v=l(v,g);n=RF.A(p,n);g=RF.A(iG.A(QF.A(RF.A(g,t),RF.A(g,d)),RF.A(1,QF.A(n,RF.A(p,v)))),1);return kG.A(p,QF.A(n,g))}($APP.tf(a),b)};
B0a=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,4,5,$APP.I,[b,b,0,a],null)};C0a=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);$APP.x.B(b,2,null);b=$APP.x.B(b,3,null);$APP.x.B(c,0,null);var g=$APP.x.B(c,1,null),l=$APP.x.B(c,2,null);c=$APP.x.B(c,3,null);var n=c-b;return new $APP.H(null,4,5,$APP.I,[d,g,b,c+n/((a-d)/(a-g)*(1-n/(c-l))-1)],null)}};
D0a=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,4,5,$APP.I,[b,b,a,a],null)};
E0a=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);$APP.x.B(b,2,null);b=$APP.x.B(b,3,null);$APP.x.B(c,0,null);var g=$APP.x.B(c,1,null),l=$APP.x.B(c,2,null);$APP.x.B(c,3,null);c=l-b;var n=(a-d)/(a-g)*b,p=n-l;return 0===p?($G($APP.Wu,"emmy.rational-function.interpolate",190,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["zero denominator!"],null)},null),-993265357),new $APP.H(null,4,5,$APP.I,[d,g,l,b],null)):new $APP.H(null,4,5,$APP.I,[d,g,n*c/p,l*c/p],null)}};
F0a=function(a){return CI(B0a,C0a(a),function(b){return $APP.fd($APP.$c(b))})};G0a=function(a){return CI(D0a,E0a(a),xXa)};H0a=function(a){return EI.j(G0a(a))};sM=function(a,b,c,d){this.arity=a;this.Kb=b;this.v=c;this.ca=d;this.O=2158362625;this.U=0};tM=function(a,b,c,d){return new sM(a,b,c,d)};uM=function(a){return a instanceof sM};I0a=function(a){return!uM(a)&&!xL(a)};J0a=function(a){return uM(a)?a.arity:CL(a)};
K0a=function(a,b){var c=J0a(a),d=J0a(b);return 0===c?d:0===d?c:$APP.Uc.A(c,d)?c:AD(["Unequal arities: ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))};L0a=function(a){return uM(a)?HL(a.Kb):HL(a)};vM=function(a,b){if(b instanceof sM){var c=$APP.Uc.A(a.arity,b.arity);return c?(c=fG.A(a.Kb,b.Kb),$APP.k(c)?fG.A(a.v,b.v):c):c}c=fG.A(a.v,CG(b));return $APP.k(c)?fG.A(a.Kb,BG(b)):c};M0a=function(a,b,c){return $APP.k(KF.j(b))?0:$APP.k(sG.j(c))?b:xL(b)||xL(c)?tM(a,b,c,null):zG.A(b,c)};
xM=function(a,b){if(I0a(a)&&I0a(b))var c=zG.A(a,b);else{$APP.k(KF.j(b))&&CD(["Can't form rational function with zero denominator: ",$APP.m.j(b)].join(""));c=K0a(a,b);var d=$APP.Hl.A($APP.Mt.J(),$APP.Vg.j(CG)),g=$APP.N.A(EL(a),EL(b));d=$APP.Vs.M(d,$APP.Us.j(oM),1,g);g=$APP.Uc;var l=g.A;var n=GL(b);n=DF(n)?$APP.k(qG.j(n))?-1:1:vG(n)?$APP.k(qG.j(xH.j(n)))?-1:1:1;d=l.call(g,1,n)?d:PF.j(d);b=$APP.k(sG.j(d))?new $APP.H(null,2,5,$APP.I,[a,b],null):new $APP.H(null,2,5,$APP.I,[MF.A(d,a),MF.A(d,b)],null);a=
$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);d=wM.A(a,b);b=$APP.k(sG.j(d))?new $APP.H(null,2,5,$APP.I,[a,b],null):new $APP.H(null,2,5,$APP.I,[RL(a,d),RL(b,d)],null);a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);c=M0a(c,a,b)}return c};
N0a=function(a,b,c,d){var g=K0a(a,b),l=BG(a);a=CG(a);var n=BG(b);b=CG(b);var p=sG.j(a);p=$APP.k(p)?sG.j(b):p;d=$APP.k(p)?new $APP.H(null,2,5,$APP.I,[c.A?c.A(l,n):c.call(null,l,n),1],null):d.M?d.M(l,a,n,b):d.call(null,l,a,n,b);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return M0a(g,c,d)};
O0a=function(a,b,c,d){function g(n,p){if($APP.k(KF.j(n)))return new $APP.H(null,2,5,$APP.I,[0,1],null);var v=wM.A(p,n);return $APP.k(sG.j(v))?new $APP.H(null,2,5,$APP.I,[n,p],null):new $APP.H(null,2,5,$APP.I,[RL(n,v),RL(p,v)],null)}if($APP.k(fG.A(b,d)))return a=KL(a,c),g(a,b);var l=wM.A(b,d);if($APP.k(sG.j(l)))return g(KL(ML(a,d),ML(b,c)),ML(b,d));b=RL(b,l);l=RL(d,l);return g(KL(ML(a,l),ML(b,c)),ML(b,d))};P0a=function(a,b,c,d){return O0a(a,b,JL(c),d)};
Q0a=function(a,b,c,d){var g=KF.j(a);g=$APP.k(g)?g:KF.j(c);if($APP.k(g))return new $APP.H(null,2,5,$APP.I,[0,1],null);g=wM.A(a,d);var l=wM.A(b,c);a=ML(RL(a,g),RL(c,l));b=ML(RL(b,l),RL(d,g));return new $APP.H(null,2,5,$APP.I,[a,b],null)};R0a=function(a,b,c,d){a=wM.A(a,c);b=oM.A(b,d);b=xM(a,b);return new $APP.H(null,2,5,$APP.I,[BG(b),CG(b)],null)};S0a=function(a){return uM(a)?tM(a.arity,JL(a.Kb),a.v,$APP.ed(a)):JL(a)};T0a=function(a){return $APP.k(L0a(a))?S0a(a):a};
U0a=function(a,b){return $APP.k(KF.j(a))?b:$APP.k(KF.j(b))?a:N0a(a,b,KL,O0a)};V0a=function(a,b){return $APP.k(KF.j(a))?S0a(b):$APP.k(KF.j(b))?a:N0a(a,b,LL,P0a)};W0a=function(a,b){return $APP.k(KF.j(a))?a:$APP.k(KF.j(b))?b:$APP.k(sG.j(a))?b:$APP.k(sG.j(b))?a:N0a(a,b,ML,Q0a)};X0a=function(a){return uM(a)?tM(a.arity,NL(a.Kb),NL(a.v),$APP.ed(a)):NL(a)};Y0a=function(a){return uM(a)?tM(a.arity,OL(a.Kb),OL(a.v),$APP.ed(a)):OL(a)};
Z0a=function(a,b){if(uM(a)){var c=a.Kb,d=a.v;d=0>b?new $APP.H(null,3,5,$APP.I,[d,c,-b],null):new $APP.H(null,3,5,$APP.I,[c,d,b],null);b=$APP.x.B(d,0,null);c=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return tM(a.arity,PL(b,d),PL(c,d),$APP.ed(a))}return PL(a,b)};$0a=function(a){if(uM(a)){var b=a.Kb,c=a.v;return $APP.k(KF.j(b))?CD("Can't form rational function with zero denominator."):$APP.k(qG.j(b))?tM(a.arity,PF.j(c),PF.j(b),$APP.ed(a)):tM(a.arity,c,b,$APP.ed(a))}return OF.j(a)};
yM=function(a,b){return W0a(a,$0a(b))};a1a=function(a,b){return N0a(a,b,wM,R0a)};zM=function(a,b){return uM(a)?zG.A(UL(a.Kb,b),UL(a.v,b)):UL(a,b)};AM=function(a,b){if(uM(a)){var c=a.Kb;a=a.v;return yM(LL(ML(VL(c,b),a),ML(c,VL(a,b))),NL(a))}return VL(a,b)};
b1a=function(a){return uM(a)?function d(c){return new $APP.de(null,function(){for(;;){var g=$APP.r(c);if(g){if($APP.pd(g)){var l=$APP.lc(g),n=$APP.Tc(l),p=$APP.fe(n);a:for(var v=0;;)if(v<n){var t=$APP.bd(l,v);$APP.je(p,AM(a,t));v+=1}else{l=!0;break a}return l?$APP.ie($APP.ke(p),d($APP.mc(g))):$APP.ie($APP.ke(p),null)}p=$APP.u(g);return $APP.Yd(AM(a,p),d($APP.Fc(g)))}return null}},null,null)}($APP.Hj.j(a.arity)):K_a(a)};
c1a=function(a,b){if(uM(a)){var c=WL(a.Kb,b);a=WL(a.v,b);b=DH($APP.rj);return b.A?b.A(c,a):b.call(null,c,a)}return WL(a,b)};
CM=function(a,b){for(var c=new $APP.H(null,5,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[BM,BM],null),new $APP.H(null,2,5,$APP.I,[XL,BM],null),new $APP.H(null,2,5,$APP.I,[YL,BM],null),new $APP.H(null,2,5,$APP.I,[BM,XL],null),new $APP.H(null,2,5,$APP.I,[BM,YL],null)],null),d=$APP.r(c),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n),v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[v,t],null),function(){return function(G,J){return b.A?b.A(G,J):b.call(null,G,J)}}(d,g,l,n,p,v,t,c));
n+=1}else{var A=$APP.r(d);if(A){p=A;if($APP.pd(p))d=$APP.lc(p),n=$APP.mc(p),g=d,l=$APP.Tc(d),d=n;else{var B=$APP.u(p);v=$APP.x.B(B,0,null);t=$APP.x.B(B,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[v,t],null),function(){return function(G,J){return b.A?b.A(G,J):b.call(null,G,J)}}(d,g,l,n,B,v,t,p,A,c));d=$APP.w(p);g=null;l=0}n=0}else break}};
d1a=function(a){return function(b){try{return a.j?a.j(b):a.call(null,b)}catch(c){if(c instanceof Error)return $G($APP.hw,"emmy.simplify",22,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["simplifier timed out: must have been a complicated expression"],null)},null),-2037906775),b;throw c;}}};f1a=function(){var a=DM.A(16,"-s-");return EM.A(e1a,a)};h1a=function(){var a=DM.A(16,"-r-");return EM.A(g1a,a)};HM=function(a){return FM.call(null,GM.call(null,a))};
IM=function(a){return function(b){for(;;){var c=a.j?a.j(b):a.call(null,b);if($APP.Uc.A(b,c))return b;c=HM.j?HM.j(c):HM.call(null,c);if($APP.Uc.A(c,b))return b;if($APP.k(LF(FM.call(null,new $APP.D(null,$APP.Gv,new $APP.D(null,b,new $APP.D(null,c,null,1,null),2,null),3,null)))))return c;b=c}}};JM=function(a){return function(b){var c=a.j?a.j(b):a.call(null,b);return $APP.Uc.A(b,c)?b:HM.j?HM.j(c):HM.call(null,c)}};KM=function(a,b){return $APP.k(a)?b:$APP.Kd};
z1a=function(a){var b=ZF(a),c=zK(new $APP.ug(null,new $APP.f(null,1,[FJ,null],null),null),b),d=$APP.k(!0)?zK(new $APP.ug(null,new $APP.f(null,1,[FJ,null],null),null),b):!0,g=zK(new $APP.ug(null,new $APP.f(null,2,[BJ,null,zJ,null],null),null),b),l=zK(new $APP.ug(null,new $APP.f(null,6,[kH,null,lK,null,sH,null,LM,null,MM,null,NM,null],null),null),b);b=zK(new $APP.ug(null,new $APP.f(null,1,[$APP.Rw,null],null),null),b);return $APP.Hl.C(KM(!0,i1a),KM(c,j1a),KM(d,$APP.Hl.B(IM($APP.Hl.A(OM,k1a)),j1a,IM(l1a))),
$APP.y([KM(l,$APP.Hl.C(JM($APP.Hl.A(OM,m1a)),JM(n1a),JM(o1a),$APP.y([IM(p1a),JM(q1a),JM(r1a),KM(!1,JM(s1a)),JM(OM),IM(p1a),JM(q1a),JM(r1a)]))),KM(g,$APP.Hl.B(JM(OM),IM($APP.Hl.A(t1a,u1a)),IM($APP.Hl.A(v1a,w1a)))),IM($APP.Hl.B(OM,KM(g,$APP.Hl.A(t1a,u1a)),KM(c,k1a))),KM(l,JM(o1a)),JM(x1a),KM(b,JM(y1a)),HM]))(a)};QM=function(a){return ZSa(PM,a)};A1a=function(a){return XF(a)&&$APP.Uc.A(aTa(a),PM)};
SM=function(a,b){var c=DH(b);$APP.k(c)?a.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(d){var g=function(){var l=YF(d);return c.j?c.j(l):c.call(null,l)}();return QM(function(){var l=RM;return $APP.k(l)?l.j?l.j(g):l.call(null,g):g}())}):a.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(d){return $Sa(PM,b,new $APP.H(null,1,5,$APP.I,[d],null))})};
UM=function(a,b){var c=new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[PM,PM],null),new $APP.H(null,2,5,$APP.I,[TM,PM],null),new $APP.H(null,2,5,$APP.I,[PM,TM],null)],null),d=DH(b);if($APP.k(d))for(var g=$APP.r(c),l=null,n=0,p=0;;)if(p<n){var v=l.aa(null,p),t=$APP.x.B(v,0,null),A=$APP.x.B(v,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[t,A],null),function(J,O,Q,W,Z,fa,ha,ja){return function(ta,ua){var ca=function(){var V=YF(ta),da=YF(ua);return ja.A?ja.A(V,da):ja.call(null,V,da)}();return QM(function(){var V=
RM;return $APP.k(V)?V.j?V.j(ca):V.call(null,ca):ca}())}}(g,l,n,p,v,t,A,d,d,c));p+=1}else if(v=$APP.r(g)){var B=v;if($APP.pd(B))t=$APP.lc(B),v=$APP.mc(B),A=t,t=$APP.Tc(t),g=v,l=A,n=t;else{var G=$APP.u(B);t=$APP.x.B(G,0,null);A=$APP.x.B(G,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[t,A],null),function(J,O,Q,W,Z,fa,ha,ja,ta,ua){return function(ca,V){var da=function(){var Y=YF(ca),ea=YF(V);return ua.A?ua.A(Y,ea):ua.call(null,Y,ea)}();return QM(function(){var Y=RM;return $APP.k(Y)?Y.j?Y.j(da):Y.call(null,
da):da}())}}(g,l,n,p,G,t,A,B,v,d,d,c));g=$APP.w(B);l=null;n=0}p=0}else break;else for(g=$APP.r(c),l=null,p=n=0;;)if(p<n)v=l.aa(null,p),t=$APP.x.B(v,0,null),A=$APP.x.B(v,1,null),a.F(null,new $APP.H(null,2,5,$APP.I,[t,A],null),function(){return function(J,O){return $Sa(PM,b,new $APP.H(null,2,5,$APP.I,[J,O],null))}}(g,l,n,p,v,t,A,d,c)),p+=1;else if(v=$APP.r(g))B=v,$APP.pd(B)?(t=$APP.lc(B),v=$APP.mc(B),A=t,t=$APP.Tc(t),g=v,l=A,n=t):(G=$APP.u(B),t=$APP.x.B(G,0,null),A=$APP.x.B(G,1,null),a.F(null,new $APP.H(null,
2,5,$APP.I,[t,A],null),function(){return function(J,O){return $Sa(PM,b,new $APP.H(null,2,5,$APP.I,[J,O],null))}}(g,l,n,p,G,t,A,B,v,d,c)),g=$APP.w(B),l=null,n=0),p=0;else break};C1a=function(a){return A1a(a)?B1a(a):a};VM=function(a,b,c,d){this.tag=a;this.id=b;this.xc=c;this.Ud=d;this.U=2048;this.O=2147483648};D1a=function(a,b,c,d){return new VM(a,b,c,d)};WM=function(a){return a instanceof VM};E1a=function(a,b){return D1a(a,$APP.Nj.J(),b,$APP.sf)};F1a=function(a,b,c){return D1a(a,$APP.Nj.J(),b,c)};
XM=function(a){return WM(a)?a.xc:a};G1a=function(a,b){return WM(a)&&$APP.Uc.A(b,a.tag)?a.xc:a};H1a=function(a,b){return HF(XM(a),XM(b))};
I1a=function(a){function b(c,d){var g=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);if($APP.Bd(g,d.id))return new $APP.H(null,2,5,$APP.I,[g,c],null);g=$APP.Vd.A(g,d.id);var l=d.Ud;g=$APP.Vs.M($APP.Vg.j($APP.u),$APP.Us.j(b),new $APP.H(null,2,5,$APP.I,[g,c],null),l);c=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return new $APP.H(null,2,5,$APP.I,[c,$APP.Yd(d,g)],null)}return $APP.Xc(b(new $APP.H(null,2,5,$APP.I,[$APP.vg,$APP.sf],null),a))};
J1a=function(a,b){var c=$APP.C.A(a,b.id);return $APP.Id.B(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);l=l.id;g=iG.A(c,g);var n=$APP.C.A(d,l);g=$APP.k(n)?kG.A(n,g):g;return $APP.rg.B(d,l,g)},a,b.Ud)};K1a=function(a){var b=I1a(a);a=$APP.pe([a.id,1]);return AWa($APP.Id.B(J1a,a,b))};
L1a=function(a,b){return function(){function c(g){$APP.r(b)&&!VK(g)&&AD(["Selectors ",$APP.m.j(b)," not allowed for non-structural input ",$APP.m.j(g)].join(""));var l=JH(),n=$APP.Zl.A(g,b);g=$APP.k(n)?$APP.hd(b)?YM(n,l):$APP.am(g,b,YM(n,l)):AD(["Bad selectors ",$APP.m.j(b)," for structure ",$APP.m.j(g)].join(""));n=OH(l,a,new $APP.H(null,1,5,$APP.I,[g],null));n=GH(n,l,ZM);return $M($APP.Zl.A(g,b),n,l)}var d=null;d=function(g){switch(arguments.length){case 0:return 0;case 1:return c.call(this,g)}throw Error("Invalid arity: "+
arguments.length);};d.J=function(){return 0};d.j=c;return d}()};aN=function(a){for(;;)if(WM(a))a=XM(a);else if(LH(a))a=PH.j(a);else return a};M1a=function(a,b){return function g(d){if(WM(d)){var l=XM(d);return F1a(d.tag,g(l),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[d,b.j?b.j(l):b.call(null,l)],null)],null))}if(LH(d)){l=bN.j(d);var n=$APP.x.B(l,0,null),p=$APP.x.B(l,1,null);l=g(n);n=iG.A(b.j?b.j(n):b.call(null,n),p);return QH.B(l,n,MH(d))}return a.j?a.j(d):a.call(null,d)}};
O1a=function(a){var b=a.j?a.j(cN):a.call(null,cN),c=a.j?a.j(dN):a.call(null,dN);return $APP.k($APP.k(b)?c:b)?N1a(a,b,c):AD("No df:dx, df:dy supplied for `f` or registered generically.")};
N1a=function(a,b,c){return function n(g,l){function p(B){var G=G1a(g,B),J=G1a(l,B),O=WM(g)&&$APP.Uc.A(B,g.tag)?new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[g,b.A?b.A(G,J):b.call(null,G,J)],null)],null):$APP.sf,Q=WM(l)&&$APP.Uc.A(B,l.tag)?new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[l,c.A?c.A(G,J):c.call(null,G,J)],null)],null):$APP.sf;return F1a(B,n(G,J),$APP.Lf.A(O,Q))}function v(B){var G=bN.A(g,B),J=$APP.x.B(G,0,null);G=$APP.x.B(G,1,null);var O=bN.A(l,B),Q=$APP.x.B(O,0,null),
W=$APP.x.B(O,1,null);O=n(J,Q);J=kG.A($APP.k(LF(G))?G:iG.A(b.A?b.A(J,Q):b.call(null,J,Q),G),$APP.k(LF(W))?W:iG.A(c.A?c.A(J,Q):c.call(null,J,Q),W));return QH.B(O,J,B)}var t=eN.C($APP.y([g,l]));if($APP.k(t)){var A=$APP.x.B(t,0,null);t=$APP.x.B(t,1,null);return WM(t)?p(A):LH(t)?v(A):AD("Non-tape or dual perturbation!")}return a.A?a.A(g,l):a.call(null,g,l)}};gN=function(a){var b=fN;var c=a.j?a.j(cN):a.call(null,cN);c=$APP.k(c)?M1a(a,c):AD("No df:dx supplied for `f` or registered generically.");b(a,c)};
fN=function(a,b){a.F(null,new $APP.H(null,1,5,$APP.I,[hN],null),function(c){return b.j?b.j(c):b.call(null,c)});return a.F(null,new $APP.H(null,1,5,$APP.I,[iN],null),function(c){return b.j?b.j(c):b.call(null,c)})};kN=function(a){jN(a,O1a(a))};
jN=function(a,b){for(var c=$APP.r(new $APP.H(null,8,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[iN,iN],null),new $APP.H(null,2,5,$APP.I,[hN,hN],null),new $APP.H(null,2,5,$APP.I,[iN,hN],null),new $APP.H(null,2,5,$APP.I,[hN,iN],null),new $APP.H(null,2,5,$APP.I,[FF,iN],null),new $APP.H(null,2,5,$APP.I,[FF,hN],null),new $APP.H(null,2,5,$APP.I,[iN,FF],null),new $APP.H(null,2,5,$APP.I,[hN,FF],null)],null)),d=null,g=0,l=0;;)if(l<g){var n=d.aa(null,l);a.F(null,n,function(){return function(t,A){return b.A?b.A(t,
A):b.call(null,t,A)}}(c,d,g,l,n));l+=1}else{var p=$APP.r(c);if(p){var v=p;$APP.pd(v)?(c=$APP.lc(v),g=$APP.mc(v),d=c,v=$APP.Tc(c),c=g,g=v):(n=$APP.u(v),a.F(null,n,function(){return function(t,A){return b.A?b.A(t,A):b.call(null,t,A)}}(c,d,g,l,n,v,p)),c=$APP.w(v),d=null,g=0);l=0}else break}};
lN=function(a){return function(){function b(g,l){g=aN(g);l=aN(l);return a.A?a.A(g,l):a.call(null,g,l)}function c(g){g=aN(g);return a.j?a.j(g):a.call(null,g)}var d=null;d=function(g,l){switch(arguments.length){case 1:return c.call(this,g);case 2:return b.call(this,g,l)}throw Error("Invalid arity: "+arguments.length);};d.j=c;d.A=b;return d}()};
P1a=function(a,b){var c=M1a(a,function(){return b}),d=aG.j(c);return function(g){return CF(aN(g))?AD(["Derivative of g/",$APP.m.j(d)," undefined at integral points."].join("")):c(g)}};mN=function(a,b,c){this.r=a;this.c=b;this.v=c;this.O=2174747415;this.U=0};nN=function(a,b,c){return new mN(a,b,c)};oN=function(a){return a instanceof mN};pN=function(a){return oN(a)?a.r:AD(["non-matrix supplied: ",$APP.m.j(a)].join(""))};qN=function(a){return oN(a)?a.c:AD(["non-matrix supplied: ",$APP.m.j(a)].join(""))};
Q1a=function(a){return $APP.od(a)?a:oN(a)?a.v:AD(["non-matrix supplied: ",$APP.m.j(a)].join(""))};rN=function(a){return oN(a)&&$APP.Uc.A(pN(a),qN(a))};R1a=function(a){return oN(a)&&$APP.Uc.A(qN(a),1)};S1a=function(a){return oN(a)&&$APP.Uc.A(pN(a),1)};sN=function(a,b){var c=b instanceof mN;return c?(c=$APP.Uc.A(a.r,b.r))?(c=$APP.Uc.A(a.c,b.c))?fG.A(a.v,b.v):c:c:c};T1a=function(a,b){var c=$APP.Zl.A(a,b);return R1a(a)&&$APP.Uc.A(1,$APP.Tc(b))?c.j?c.j(0):c.call(null,0):c};
tN=function(a,b){return nN(pN(b),qN(b),$APP.Fl.A(function(c){return $APP.Fl.A(a,c)},b))};U1a=function(a,b){var c=$APP.Lf.A($APP.sf,$APP.gp.A(function(d,g){return $APP.Lf.A($APP.sf,$APP.gp.A(function(l,n){return a.B?a.B(n,d,l):a.call(null,n,d,l)},g))},b));return nN(pN(b),qN(b),c)};V1a=function(a){var b=$APP.Vg.A($APP.Tc,a);return $APP.Ge(function(c){return $APP.Uc.A(c,$APP.u(b))},$APP.w(b))};W1a=function(a){return V1a(a)?nN($APP.Tc(a),$APP.Tc($APP.u(a)),$APP.Fl.A($APP.tf,a)):AD("malformed matrix")};
X1a=function(a){return V1a(a)?nN($APP.Tc($APP.u(a)),$APP.Tc(a),$APP.Je.B($APP.Fl,$APP.ns,a)):AD("malformed matrix")};Y1a=function(a){return nN(1,$APP.Tc(a),new $APP.H(null,1,5,$APP.I,[$APP.tf(a)],null))};uN=function(a){return nN($APP.Tc(a),1,$APP.Fl.A($APP.ns,a))};wN=function(a){return vN.B(qN(a),pN(a),function(b,c){return $APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[c,b],null))})};Z1a=function(a){return $K($APP.Vg.A(function(b){return oN(b)?xN.j(b):b},a))};
$1a=function(a,b){var c=pN(a),d=pN(b),g=qN(a),l=qN(b);$APP.Uc.A(g,d)||AD("matrices incompatible for multiplication");return vN.B(c,l,function(n,p){return $APP.Id.A(kG,function(){return function A(t){return new $APP.de(null,function(){for(;;){var B=$APP.r(t);if(B){if($APP.pd(B)){var G=$APP.lc(B),J=$APP.Tc(G),O=$APP.fe(J);a:for(var Q=0;;)if(Q<J){var W=$APP.bd(G,Q);$APP.je(O,iG.A($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[n,W],null)),$APP.Zl.A(b,new $APP.H(null,2,5,$APP.I,[W,p],null))));Q+=1}else{G=!0;
break a}return G?$APP.ie($APP.ke(O),A($APP.mc(B))):$APP.ie($APP.ke(O),null)}O=$APP.u(B);return $APP.Yd(iG.A($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[n,O],null)),$APP.Zl.A(b,new $APP.H(null,2,5,$APP.I,[O,p],null))),A($APP.Fc(B)))}return null}},null,null)}($APP.Hj.j(g))}())})};a2a=function(a,b){return tN(function(c){return iG.A(a,c)},b)};b2a=function(a,b){return tN(function(c){return iG.A(c,b)},a)};
yN=function(a,b,c){var d=pN(b),g=pN(c),l=qN(b),n=qN(c);($APP.qg.A(d,g)||$APP.qg.A(l,n))&&AD("matrices incompatible for operation");return vN.B(d,l,function(p,v){var t=$APP.Zl.A(b,new $APP.H(null,2,5,$APP.I,[p,v],null));p=$APP.Zl.A(c,new $APP.H(null,2,5,$APP.I,[p,v],null));return a.A?a.A(t,p):a.call(null,t,p)})};
zN=function(a,b){var c=YK(a);if($APP.k(c)){c=$APP.qe(c);var d=$APP.C.A(c,VZa),g=$APP.C.A(c,UZa),l=$APP.C.A(c,TZa),n=$APP.C.A(c,SZa),p=$APP.Uc.A(l,SK);d=p?new $APP.H(null,2,5,$APP.I,[d,g],null):new $APP.H(null,2,5,$APP.I,[g,d],null);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);c=vN.B(c,d,function(v,t){return $APP.Zl.A(a,p?new $APP.H(null,2,5,$APP.I,[t,v],null):new $APP.H(null,2,5,$APP.I,[v,t],null))});d=function(v){return xN.M(v,n,l,p)};return b.A?b.A(c,d):b.call(null,c,d)}return AD(["structure ",$APP.m.j(a),
" is not a 2-tensor"].join(""))};c2a=function(a,b){return zN(a,function(c,d){c=b.j?b.j(c):b.call(null,c);return d.j?d.j(c):d.call(null,c)})};d2a=function(a,b){$APP.qg.A(qN(a),$APP.Tc(b))&&AD("matrix and tuple incompatible for multiplication");return $K($APP.Vg.A(function(c){function d(l){return iG.A($APP.x.A(g,l),$APP.x.A(b,l))}var g=$APP.x.A(a,c);c=qN(a);return hL.B?hL.B(d,0,c):hL.call(null,d,0,c)},$APP.Hj.j(pN(a))))};
e2a=function(a,b){$APP.qg.A($APP.Tc(a),pN(b))&&AD("matrix and tuple incompatible for multiplication");return aL($APP.Vg.A(function(c){function d(l){return iG.A($APP.C.A(a,l),$APP.Zl.A(b,new $APP.H(null,2,5,$APP.I,[l,c],null)))}var g=pN(b);return hL.B?hL.B(d,0,g):hL.call(null,d,0,g)},$APP.Hj.j(qN(b))))};f2a=function(a,b){return aL($APP.C.A(a,b))};AN=function(a,b){return $K($APP.Vg.A(function(c){return c.j?c.j(b):c.call(null,b)},a))};
g2a=function(a){var b=pN(a);return $K($APP.Vg.A(function(c){return $APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[c,c],null))},$APP.Hj.A(0,b)))};h2a=function(a){return uN(a)};BN=function(a){return AN(a,0)};i2a=function(a){return $APP.Fl.A($APP.u,a)};j2a=function(a){return CN.C($APP.y([RK(a)]))};DN=function(a){return f2a(a,0)};EN=function(a){return $APP.x.A(a,0)};
GN=function(a,b,c){var d=qN(b),g=oL(a);return FN.A(function(){return function p(n){return new $APP.de(null,function(){for(;;){var v=$APP.r(n);if(v){if($APP.pd(v)){var t=$APP.lc(v),A=$APP.Tc(t),B=$APP.fe(A);a:for(var G=0;;)if(G<A){var J=$APP.bd(t,G);$APP.je(B,FN.A(AN(b,J),g));G+=1}else{t=!0;break a}return t?$APP.ie($APP.ke(B),p($APP.mc(v))):$APP.ie($APP.ke(B),null)}B=$APP.u(v);return $APP.Yd(FN.A(AN(b,B),g),p($APP.Fc(v)))}return null}},null,null)}($APP.Hj.j(d))}(),oL(c))};
k2a=function(a){a=c2a(a,HN);return $APP.Uc.A(TK(a),TK($APP.u(a)))?mL(a):a};IN=function(a,b){if($APP.od(a))return $APP.Lf.A($APP.oi.B(a,0,b),$APP.oi.A(a,b+1));a=$APP.Lf.A($APP.sf,a);return IN.A?IN.A(a,b):IN.call(null,a,b)};l2a=function(a,b,c){return $APP.rg.B(a,b,c)};m2a=function(a,b,c,d,g){var l=VK(a)?zN(a,function(n){return n}):a;return vN.B(c-b+1,g-d+1,function(n,p){return $APP.Zl.A(l,new $APP.H(null,2,5,$APP.I,[n+b,p+d],null))})};
n2a=function(a,b,c){return nN(pN(a)-1,qN(a)-1,$APP.Fl.A(function(d){return IN(d,c)},IN(Q1a(a),b)))};o2a=function(a){var b=pN(a);return $APP.Vs.B($APP.Vg.j(function(c){return $APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[c,c],null))}),kG,$APP.Hj.A(0,b))};
p2a=function(a,b,c,d){var g=a.J?a.J():a.call(null);return function(l){var n=$APP.kh.j(null);$APP.Ne(n,$APP.mh(function(t,A){var B=$APP.r(A),G=$APP.u(B);B=$APP.w(B);if($APP.eb(B))return $APP.Zl.A(l,new $APP.H(null,2,5,$APP.I,[t,G],null));G=0;B=A;for(var J=g;;){if($APP.eb($APP.r(B)))return J;var O=$APP.Zl.A(l,new $APP.H(null,2,5,$APP.I,[t,$APP.u(B)],null));if($APP.k(d.j?d.j(O):d.call(null,O)))G+=1,B=$APP.Fc(B);else{var Q=IN(A,G);var W=t+1;var Z=$APP.Fb(n);W=Z.A?Z.A(W,Q):Z.call(null,W,Q);W=c.A?c.A(O,
W):c.call(null,O,W);O=G+1;B=$APP.Fc(B);J=$APP.Ie(G)?a.A?a.A(J,W):a.call(null,J,W):b.A?b.A(J,W):b.call(null,J,W);G=O}}}));var p=$APP.Hj.j(pN(l)),v=$APP.Fb(n);return v.A?v.A(0,p):v.call(null,0,p)}};
q2a=function(a,b,c,d,g){var l=p2a(a,b,c,g);return function(n){var p=pN(n);if($APP.Uc.A(p,1))return nN(1,1,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[function(){var A=$APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[0,0],null));return d.j?d.j(A):d.call(null,A)}()],null)],null));var v=l(n),t=b.j?b.j(v):b.call(null,v);return vN.B(p,p,function(A,B){var G=$APP.Ie(A+B)?v:t;A=l(n2a(n,B,A));return d.A?d.A(A,G):d.call(null,A,G)})}};r2a=function(a,b){var c=oL(b),d=oL(sL(c,a));return sL(JN.B(c,a,d),b)};
s2a=function(a,b){var c=oL(a),d=oL(sL(b,c));return sL(a,JN.B(d,b,c))};KN=function(a){return vN.B(a,a,MZa)};t2a=function(a){return rN(a)?U1a(function(b,c,d){return $APP.Uc.A(c,d)?NF.j(b):tG.j(b)},a):AD("identity-like on non-square")};
u2a=function(a){var b=rN(a);if(b){var c=pN(a);return $APP.Ge($APP.rd,function(){return function l(g){return new $APP.de(null,function(){for(var n=g;;){var p=$APP.r(n);if(p){var v=p,t=$APP.u(v);if(p=$APP.r(function(A,B,G,J,O,Q){return function fa(Z){return new $APP.de(null,function(ha,ja){return function(){for(;;){var ta=$APP.r(Z);if(ta){if($APP.pd(ta)){var ua=$APP.lc(ta),ca=$APP.Tc(ua),V=$APP.fe(ca);a:for(var da=0;;)if(da<ca){var Y=$APP.bd(ua,da),ea=$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[ja,Y],null));
$APP.je(V,$APP.Uc.A(ja,Y)?sG.j(ea):KF.j(ea));da+=1}else{ua=!0;break a}return ua?$APP.ie($APP.ke(V),fa($APP.mc(ta))):$APP.ie($APP.ke(V),null)}V=$APP.u(ta);ua=$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[ja,V],null));return $APP.Yd($APP.Uc.A(ja,V)?sG.j(ua):KF.j(ua),fa($APP.Fc(ta)))}return null}}}(A,B,G,J,O,Q),null,null)}}(n,t,v,p,c,b)($APP.Hj.j(c))))return $APP.N.A(p,l($APP.Fc(n)));n=$APP.Fc(n)}else return null}},null,null)}($APP.Hj.j(c))}())}return b};
v2a=function(a,b,c,d,g){var l=p2a(a,b,c,g);return function(n,p){var v=AN(p,0);p=pN(p);var t=l(n),A=wN(n);return uN($APP.Fl.A(function(B){B=l(l2a(A,B,v));return d.A?d.A(B,t):d.call(null,B,t)},$APP.Hj.j(p)))}};MN=function(a,b){return WK(a)?BN(LN(b,uN(a))):R1a(a)?LN(b,a):PZa(a)?DN(wN(LN(wN(b),wN(j2a(a))))):S1a(a)?wN(LN(wN(b),wN(a))):AD(["I don't know how to solve:",$APP.m.j(a),$APP.m.j(b)].join(""))};
PN=function(a){if($APP.Uc.A(a,NN))return 0;if($APP.kd(a)){a=$APP.r(a);var b=$APP.u(a),c=$APP.w(a);if($APP.Uc.A(ON,b))return $APP.Fl.A(PN,c);if($APP.Uc.A(w2a,b))return $APP.Je.A(uL,$APP.Vg.A(PN,c));if($APP.Uc.A(x2a,b))return $APP.Je.A(QN,$APP.Vg.A(PN,c));if($APP.Uc.A(RN,b))return $APP.Je.A(uL,$APP.Uj.A($APP.Xc(c),function(){var d=$APP.u(c);return PN.j?PN.j(d):PN.call(null,d)}()));if($APP.Uc.A(y2a,b))return $APP.Je.A(QN,$APP.Uj.A($APP.Xc(c),function(){var d=$APP.u(c);return PN.j?PN.j(d):PN.call(null,
d)}()));if($APP.Uc.A(z2a,b))return $APP.Lf.A($APP.sf,$APP.Uj.A($APP.Xc(c),function(){var d=$APP.u(c);return PN.j?PN.j(d):PN.call(null,d)}()));throw Error(["No matching clause: ",$APP.m.j(b)].join(""));}return null};
A2a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null);$APP.k(function(){var g=$APP.Uc.A($APP.dv,b);return g?$APP.k(c)?d:c:g}())||AD(["A SICM signature is of the form '(-\x3e domain range), got: ",$APP.m.j(b),$APP.m.j(c),$APP.m.j(d)].join(""));return new $APP.H(null,2,5,$APP.I,[function(){var g=PN(c);return $APP.od(g)?g:new $APP.H(null,1,5,$APP.I,[g],null)}(),PN(d)],null)};
B2a=function(a,b,c,d){this.qd=a;this.arity=b;this.domain=c;this.range=d;this.O=2149580801;this.U=0};SN=function(a,b,c,d){return new B2a(a,b,c,d)};C2a=function(a){return a instanceof B2a};D2a=function(a,b){return C2a(b)&&$APP.Uc.A(a.qd,b.qd)&&$APP.Uc.A(a.domain,b.domain)&&$APP.Uc.A(a.range,b.range)};
TN=function(a){switch(arguments.length){case 1:return TN.j(arguments[0]);case 2:return TN.A(arguments[0],arguments[1]);case 3:return TN.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
E2a=function(a){return $APP.Fl.A(function(b){var c=$APP.I,d=b instanceof $APP.q?b:$APP.u(b);if(b instanceof $APP.q)var g=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,UN,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null))));else if($APP.kd(b)&&$APP.Uc.A($APP.Tc(b),3)){g=$APP.x.B(b,0,null);var l=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);g=$APP.T.j($APP.r($APP.N.C(new $APP.D(null,UN,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
$APP.K,null,1,null),new $APP.D(null,g,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,l,null,1,null),new $APP.D(null,b,null,1,null)]))))}else g=AD(["unknown literal function type",$APP.m.j(b)].join(""));return new $APP.H(null,2,5,c,[d,g],null)},a)};VN=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=3<b.length?new $APP.Bc(b.slice(3),0,null):null;return VN.C(arguments[0],arguments[1],arguments[2],b)};
F2a=function(a,b){b=$APP.Uc.A(SH(a),new $APP.H(null,2,5,$APP.I,[fI,1],null))?$APP.Uc.A($APP.u(b),0)?$APP.Uc.A($APP.Tc(b),1)?oWa(a.qd):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Rw,null,1,null),$APP.w(b)))),null,1,null),new $APP.D(null,a.qd,null,1,null)))):AD("wrong indices"):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Rw,null,1,null),b))),null,1,null),new $APP.D(null,a.qd,null,1,null))));return SN(b,SH(a),a.domain,
a.range)};G2a=function(a,b,c){return function(){function d(n,p){var v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);$APP.x.B(p,2,null);p=WN.A(v,c);if($APP.k(LF(p)))return n;t=F2a(a,t);return kG.A(n,iG.A(XN.A?XN.A(t,b):XN.call(null,t,b),p))}function g(n){return QH.B($APP.Je.A(a,b),n,c)}var l=null;l=function(n,p){switch(arguments.length){case 0:return 0;case 1:return g.call(this,n);case 2:return d.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.J=function(){return 0};l.j=g;l.A=d;return l}()};
H2a=function(a,b,c){return function(){function d(n,p){var v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);$APP.x.B(p,2,null);return WM(v)&&$APP.Uc.A(c,v.tag)?(p=F2a(a,t),$APP.Vd.A(n,new $APP.H(null,2,5,$APP.I,[v,XN.A?XN.A(p,b):XN.call(null,p,b)],null))):n}function g(n){return F1a(c,$APP.Je.A(a,b),n)}var l=null;l=function(n,p){switch(arguments.length){case 0:return $APP.sf;case 1:return g.call(this,n);case 2:return d.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.J=function(){return $APP.sf};
l.j=g;l.A=d;return l}()};I2a=function(a,b,c,d){d=WM(d)?H2a:LH(d)?G2a:AD("No tape or differential inputs.");var g=kL.C(function(l){return WM(l)?G1a(l,c):LH(l)?PH.A(l,c):l},$APP.y([b]));return YN.A(d.B?d.B(a,g,c):d.call(null,a,g,c),b)};
ZN=function(a,b,c,d){if("number"===typeof c)return GF(b)?null:AD(["expected numerical quantity in argument ",$APP.m.j(d)," of function call ",$APP.m.j(a)," but got ",$APP.m.j(b)].join(""));if(VK(c)){(VK(b)||$APP.kd(b))&&$APP.Uc.A(TK(b),TK(c))&&$APP.Uc.A($APP.Tc(b),$APP.Tc(c))||AD(["expected structure matching ",$APP.m.j(c)," but got ",$APP.m.j(b)].join(""));b=$APP.r($APP.Vg.M($APP.M,b,c,$APP.Hj.J()));for(var g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n),v=$APP.x.B(p,0,null);c=$APP.x.B(p,1,null);p=$APP.x.B(p,
2,null);var t=a;p=$APP.Vd.A(d,p);ZN.M?ZN.M(t,v,c,p):ZN.call(null,t,v,c,p);n+=1}else if(b=$APP.r(b))$APP.pd(b)?(p=$APP.lc(b),b=$APP.mc(b),c=p,p=$APP.Tc(p),g=c,l=p):(p=$APP.u(b),v=$APP.x.B(p,0,null),c=$APP.x.B(p,1,null),p=$APP.x.B(p,2,null),g=a,l=v,p=$APP.Vd.A(d,p),ZN.M?ZN.M(g,l,c,p):ZN.call(null,g,l,c,p),b=$APP.w(b),g=null,l=0),n=0;else return null}else return c instanceof $APP.E?$APP.Uc.A(BF(b),c)?null:AD(["expected argument of type ",$APP.m.j(c)," but got ",$APP.m.j(BF(b))," in call to function ",
$APP.m.j(a)].join("")):AD(["unexpected argument example. got ",$APP.m.j(b)," want ",$APP.m.j(c)].join(""))};
XN=function(a,b){ZN(a,b,a.domain,new $APP.H(null,1,5,$APP.I,[0],null));var c=Z1a(b),d=YN.A(function(){function g(p,v){v=$APP.x.B(v,0,null);return $APP.Vd.A(p,v)}function l(p){return $APP.Je.A(eN,p)}var n=null;n=function(p,v){switch(arguments.length){case 0:return $APP.sf;case 1:return l.call(this,p);case 2:return g.call(this,p,v)}throw Error("Invalid arity: "+arguments.length);};n.J=function(){return $APP.sf};n.j=l;n.A=g;return n}(),c);return $APP.k(d)?(b=$APP.x.B(d,0,null),d=$APP.x.B(d,1,null),I2a(a,
c,b,d)):QM($APP.T.j($APP.r($APP.N.A(new $APP.D(null,a.qd,null,1,null),$APP.Vg.A(aG,b)))))};J2a=function(){};$N=function(a,b){if(null!=a&&null!=a.$h)a=a.$h(a,b);else{var c=$N[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=$N._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("IFrame.coords-\x3eevent",a);}return a};
aO=function(a,b){if(null!=a&&null!=a.ai)a=a.ai(a,b);else{var c=aO[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=aO._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("IFrame.event-\x3ecoords",a);}return a};K2a=function(a){if(null!=a&&null!=a.Xj)a=a.Jd;else{var b=K2a[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=K2a._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IFrame.ancestor-frame",a);}return a};
bO=function(a){if(null!=a&&null!=a.Yj)a=a.name;else{var b=bO[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=bO._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IFrame.frame-name",a);}return a};cO=function(a){if(null!=a&&null!=a.Zj)a=a.params;else{var b=cO[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=cO._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IFrame.params",a);}return a};
L2a=function(a){return null!=a?$APP.xc===a.Wj?!0:a.$c?!1:$APP.gb(J2a,a):$APP.gb(J2a,a)};N2a=function(a){return $APP.Xj.M(a,$APP.rg,M2a,!0)};O2a=function(a){return M2a.A($APP.ed(a),!1)};Q2a=function(a){return P2a.j($APP.ed(a))};R2a=function(a,b){var c=Q2a(a);return $APP.k(c)?$APP.Uc.A(c,b)?a:AD(["Someone else owns these coords: ",$APP.m.j(a),$APP.m.j(b)].join("")):$APP.Xj.M(a,$APP.rg,P2a,b)};
U2a=function(a,b){return function(){function c(n,p,v){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof S2a||"undefined"===typeof eO)eO=function(t,A,B,G,J,O,Q){this.pf=t;this.yf=A;this.call=B;this.name=G;this.Jd=J;this.params=O;this.sk=Q;this.O=393216;this.U=0},eO.prototype.da=function(t,A){return new eO(this.pf,this.yf,this.call,this.name,this.Jd,this.params,A)},eO.prototype.ba=function(){return this.sk},eO.prototype.Wj=$APP.xc,eO.prototype.Xj=function(){return this.Jd},eO.prototype.Yj=
function(){return this.name},eO.prototype.Zj=function(){return this.params},eO.prototype.$h=function(t,A){t=this.pf.B?this.pf.B(this.Jd,this,this.params):this.pf.call(null,this.Jd,this,this.params);return t.j?t.j(A):t.call(null,A)},eO.prototype.ai=function(t,A){t=this.yf.B?this.yf.B(this.Jd,this,this.params):this.yf.call(null,this.Jd,this,this.params);return t.j?t.j(A):t.call(null,A)},eO.cb=!0,eO.Ya="emmy.calculus.frame/t_emmy$calculus$frame49289",eO.gb=function(t){return $APP.Vb(t,"emmy.calculus.frame/t_emmy$calculus$frame49289")},
T2a=function(t,A,B,G,J,O,Q){return new eO(t,A,B,G,J,O,Q)};return new eO(a,b,l,n,p,v,$APP.F)}function d(n,p){return l.B(n,p,$APP.F)}function g(n){return l.B(n,null,$APP.F)}var l=null;l=function(n,p,v){switch(arguments.length){case 1:return g.call(this,n);case 2:return d.call(this,n,p);case 3:return c.call(this,n,p,v)}throw Error("Invalid arity: "+arguments.length);};l.j=g;l.A=d;l.B=c;return l}()};
V2a=function(a,b){a=$APP.r($APP.We.A(a,b));b=null;for(var c=0,d=0;;)if(d<c){var g=b.aa(null,d);$APP.Xt.C($APP.y([bG.j(g)]));d+=1}else if(a=$APP.r(a))b=a,$APP.pd(b)?(a=$APP.lc(b),c=$APP.mc(b),b=a,g=$APP.Tc(a),a=c,c=g):(g=$APP.u(b),$APP.Xt.C($APP.y([bG.j(g)])),a=$APP.w(b),b=null,c=0),d=0;else return null};
W2a=function(a,b){a=$APP.r($APP.We.A(a,b));b=null;for(var c=0,d=0;;)if(d<c){var g=b.aa(null,d);$APP.ZA.j(bG.j(g));d+=1}else if(a=$APP.r(a))b=a,$APP.pd(b)?(a=$APP.lc(b),c=$APP.mc(b),b=a,g=$APP.Tc(a),a=c,c=g):(g=$APP.u(b),$APP.ZA.j(bG.j(g)),a=$APP.w(b),b=null,c=0),d=0;else return null};X2a=function(a,b){return $APP.Fl.A(b,$APP.Hj.j(a))};Y2a=function(a){return function(b,c){return hG.j(b-c)<=.5*a*(2+hG.j(b)+hG.j(c))}};
Z2a=function(a,b){return CN.C($APP.y([new $APP.H(null,3,5,$APP.I,[1,0,0],null),new $APP.H(null,3,5,$APP.I,[0,a,RF.j(b)],null),new $APP.H(null,3,5,$APP.I,[0,b,a],null)]))};hO=function(a){return Z2a(fO.j(a),gO.j(a))};$2a=function(a,b){return CN.C($APP.y([new $APP.H(null,3,5,$APP.I,[a,0,b],null),new $APP.H(null,3,5,$APP.I,[0,1,0],null),new $APP.H(null,3,5,$APP.I,[RF.j(b),0,a],null)]))};iO=function(a){return $2a(fO.j(a),gO.j(a))};
a3a=function(a,b){return CN.C($APP.y([new $APP.H(null,3,5,$APP.I,[a,RF.j(b),0],null),new $APP.H(null,3,5,$APP.I,[b,a,0],null),new $APP.H(null,3,5,$APP.I,[0,0,1],null)]))};jO=function(a){return a3a(fO.j(a),gO.j(a))};b3a=function(a,b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);b=kO.j(b);c=rG.A(d,c);return iG.C(jO(c),iO(b),$APP.y([jO(a),wN(iO(b)),wN(jO(c))]))};c3a=function(a){var b=fO.j(a);a=gO.j(a);return GN(gL(lO,3),Z2a(b,a),fL($APP.mO,3))};
d3a=function(a){var b=fO.j(a);a=gO.j(a);return GN(gL(lO,3),$2a(b,a),fL($APP.mO,3))};e3a=function(a){var b=fO.j(a);a=gO.j(a);return GN(gL(lO,3),a3a(b,a),fL($APP.mO,3))};f3a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=fO.j(a),l=gO.j(a);return uL.C($APP.y([c,RF.A(iG.A(g,d),iG.A(l,b)),kG.A(iG.A(l,d),iG.A(g,b))]))}};
g3a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=fO.j(a),l=gO.j(a);return uL.C($APP.y([kG.A(iG.A(g,c),iG.A(l,b)),d,RF.A(iG.A(g,b),iG.A(l,c))]))}};h3a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=fO.j(a),l=gO.j(a);return uL.C($APP.y([RF.A(iG.A(g,c),iG.A(l,d)),kG.A(iG.A(l,c),iG.A(g,d)),b]))}};
i3a=function(a){return uL.C($APP.y([$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[1,2],null)),$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[2,0],null)),$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[0,1],null))]))};nO=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return iG.C(jO(c),hO(b),$APP.y([jO(a)]))};k3a=function(a){return $APP.Uc.A(BF(a),j3a)};l3a=function(a){return $APP.Uc.A(BF(a),oO)};o3a=function(a){return $APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[m3a,n3a],null))};
pO=function(a){return l3a(a)?a:oO.j($APP.ed(a))};rO=function(a,b){return $APP.am(a,new $APP.H(null,2,5,$APP.I,[qO,b],null),new $APP.f(null,2,[$APP.R,b,p3a,$APP.F],null))};q3a=function(a){return tD($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[m3a,qO],null)))};t3a=function(a,b){var c=$APP.Zl.A(a,new $APP.H(null,3,5,$APP.I,[m3a,qO,b],null));if($APP.k(c))return $APP.rg.B(c,r3a,a);throw $APP.Zi.A("Unknown patch.",new $APP.f(null,2,[s3a,b,r3a,a],null));};
sO=function(a,b,c,d){return $APP.am(a,new $APP.H(null,4,5,$APP.I,[qO,c,p3a,b],null),d)};u3a=function(a){return tD(p3a.j(a))};tO=function(a,b,c){c=t3a(a,c);var d=$APP.Zl.A(c,new $APP.H(null,2,5,$APP.I,[p3a,b],null));if($APP.k(d))b=d;else throw $APP.Zi.A("Unknown coordinate system.",new $APP.f(null,2,[v3a,b,w3a,c],null));return b.j?b.j(a):b.call(null,a)};z3a=function(a,b){return new $APP.f(null,4,[$APP.Ti,x3a,zUa,a,r3a,b,y3a,$APP.kh.j($APP.F)],null)};
vO=function(a,b,c,d){a=z3a(a,b);b=y3a.j(a);$APP.lh.M(b,$APP.rg,uO.j?uO.j(c):uO.call(null,c),d);return a};wO=function(a){return zUa.j(a)};A3a=function(a){return r3a.j(a)};B3a=function(a){return $APP.Uc.A(BF(a),x3a)};xO=function(a,b){return B3a(a)&&$APP.Uc.A(A3a(a),b)};yO=function(a,b,c){a=y3a.j(a);b=uO.j?uO.j(b):uO.call(null,b);var d=$APP.Fb(a);d=d.j?d.j(b):d.call(null,b);if($APP.k(d))return d;c=kL.C(C1a,$APP.y([c.J?c.J():c.call(null)]));$APP.lh.M(a,$APP.rg,b,c);return c};C3a=function(){};
D3a=function(a,b){if(null!=a&&null!=a.Cc)a=a.Cc(a,b);else{var c=D3a[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=D3a._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICoordinateSystem.check-coordinates",a);}return a};
E3a=function(a,b){if(null!=a&&null!=a.Mc)a=a.Mc(a,b);else{var c=E3a[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=E3a._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICoordinateSystem.check-point",a);}return a};
zO=function(a,b){if(null!=a&&null!=a.Nc)a=a.Nc(a,b);else{var c=zO[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=zO._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICoordinateSystem.coords-\x3epoint",a);}return a};
AO=function(a,b){if(null!=a&&null!=a.Oc)a=a.Oc(a,b);else{var c=AO[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=AO._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICoordinateSystem.point-\x3ecoords",a);}return a};uO=function(a){if(null!=a&&null!=a.dd)a=a.id;else{var b=uO[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=uO._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("ICoordinateSystem.uuid",a);}return a};
F3a=function(a){return null!=a?$APP.xc===a.cd?!0:a.$c?!1:$APP.gb(C3a,a):$APP.gb(C3a,a)};CO=function(a){return BO.j($APP.ed(a))};DO=function(a){return L2a(a)?function(b){return aO(a,b)}:function(b){return AO(a,b)}};EO=function(a){return L2a(a)?function(b){return $N(a,b)}:function(b){return zO(a,b)}};G3a=function(a){return kL.C($APP.Nj,$APP.y([CO(a)]))};H3a=function(a){var b=G3a(a);return zO(a,b)};I3a=function(a,b){pO(a);var c=pO(b);return function(d){return z3a(wO(d),c)}};
J3a=function(a){return kL.C(function(b){return $APP.Zg.j(["v:",$APP.m.j(b)].join(""))},$APP.y([a]))};HO=function(a,b){var c=FO.j(pO(b));c=$K($APP.Uj.A(c,0));return $APP.Xj.C(WH.C($APP.y([TN.B(a,c,0),DO(b)])),$APP.rg,$APP.R,$APP.Ag,GO,b,$APP.y([$APP.Ti,K3a]))};L3a=function(){return 0};M3a=function(){return 1};N3a=function(a){return function(){return a}};O3a=function(a,b,c){return $APP.Uc.A(a,1)?c.j?c.j(0):c.call(null,0):cL(a,b,c)};
IO=function(a){a=FO.j(a);return O3a(a,SK,function(b){return $APP.Zg.j(["x",$APP.m.j(b)].join(""))})};
R3a=function(a){var b=OF.j(a);return function(){function c(l,n){var p=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof KO)KO=function(v,t,A,B,G,J,O){this.orientation=v;this.fi=t;this.ctor=A;this.Pa=B;this.Ub=G;this.id=J;this.yk=O;this.O=393216;this.U=0},KO.prototype.da=function(v,t){return new KO(this.orientation,this.fi,this.ctor,this.Pa,this.Ub,this.id,t)},KO.prototype.ba=function(){return this.yk},KO.prototype.cd=$APP.xc,
KO.prototype.Cc=function(v,t){return WK(t)&&$APP.Uc.A(LO.j(t),2)&&(!EF(t)||0<=$APP.x.A(t,0))},KO.prototype.Mc=function(v,t){return xO(t,this.Pa)},KO.prototype.Nc=function(v,t){v=$APP.x.B(t,0,null);var A=$APP.x.B(t,1,null);return vO(iG.A(this.orientation,uL.C($APP.y([iG.A(gO.j(v),fO.j(A)),iG.A(gO.j(v),gO.j(A)),fO.j(v)]))),this.Pa,this,t)},KO.prototype.Oc=function(v,t){var A=this;return yO(t,this,function(){var B=iG.A(A.fi,wO(t));if(WK(B)&&$APP.Uc.A(LO.j(B),P3a.j(A.Pa))){var G=$APP.x.B(B,0,null),J=
$APP.x.B(B,1,null);B=$APP.x.B(B,2,null);return uL.C($APP.y([kO.j(B),rG.A(J,G)]))}return AD("S2-coordinates bad point")})},KO.prototype.dd=function(){return this.id},KO.cb=!0,KO.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40782",KO.gb=function(v){return $APP.Vb(v,"emmy.calculus.manifold/t_emmy$calculus$manifold40782")};return new KO(a,b,g,l,n,p,$APP.F)}(),new $APP.f(null,2,[BO,n,oO,l],null))}function d(l){var n=IO(l);return g.A(l,n)}var g=null;g=function(l,n){switch(arguments.length){case 1:return d.call(this,
l);case 2:return c.call(this,l,n)}throw Error("Invalid arity: "+arguments.length);};g.j=d;g.A=c;return g}()};
T3a=function(a){function b(c){return $APP.N.A(new $APP.de(null,function(){return $APP.Fc(c)},null,null),new $APP.de(null,function(){return new $APP.H(null,1,5,$APP.I,[$APP.u(c)],null)},null,null))}return function(){function c(l,n){var p=FO.j(l),v=function(){var B=p+1;return a.j?a.j(B):a.call(null,B)}(),t=OF.j(v),A=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof MO)MO=function(B,G,J,O,Q,W,Z,fa,ha,ja){this.$d=B;this.ctor=
G;this.Ze=J;this.n=O;this.Pa=Q;this.id=W;this.Fd=Z;this.Gd=fa;this.Ub=ha;this.zk=ja;this.O=393216;this.U=0},MO.prototype.da=function(B,G){return new MO(this.$d,this.ctor,this.Ze,this.n,this.Pa,this.id,this.Fd,this.Gd,this.Ub,G)},MO.prototype.ba=function(){return this.zk},MO.prototype.cd=$APP.xc,MO.prototype.Cc=function(B,G){var J=this;B=LO.j(G);return $APP.Uc.A(J.n,1)&&$APP.Uc.A(B,1)||WK(G)&&$APP.Uc.A(B,J.n)&&$APP.Ge($APP.gp.j(function(O,Q){return $APP.Uc.A(O+1,J.n)||!EF(Q)||$APP.eb(qG.j(Q))}),G)},
MO.prototype.Mc=function(B,G){return xO(G,this.Pa)},MO.prototype.Nc=function(B,G){var J=this;if($APP.Uc.A(J.n,1))B=uL.C($APP.y([fO.j(G),gO.j(G)]));else{var O=$APP.Vg.A(gO,G),Q=$APP.Vg.A(fO,G);B=$K(function(){var W=$APP.Vg.A(function(Z){return $APP.Uc.A(Z,J.n)?$APP.Je.A(iG,O):$APP.Je.A(iG,$APP.Yd($APP.x.A(Q,Z),$APP.We.A(Z,O)))},$APP.Hj.j(J.n+1));return J.$d.j?J.$d.j(W):J.$d.call(null,W)}())}return vO(iG.A(J.Gd,B),J.Pa,this,G)},MO.prototype.Oc=function(B,G){var J=this;return yO(G,this,function(){function O(ja,
ta){$APP.k(function(){var ua="number"===typeof ja;return ua?(ua="number"===typeof ta)?(ua=KF.j(ja),$APP.k(ua)?KF.j(ta):ua):ua:ua}())&&$G($APP.hw,"emmy.calculus.manifold",866,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["Sn-coordinates singular!"],null)},null),-2120377979);return rG.A(ja,ta)}var Q=function(){var ja=$APP.Wd(iG.A(J.Fd,wO(G)));return J.$d.j?J.$d.j(ja):J.$d.call(null,ja)}();if($APP.Uc.A(J.n,1))return O($APP.x.A(Q,1),$APP.x.A(Q,0));for(var W=$APP.u(Q),Z=$APP.Fc(Q),fa=new $APP.H(null,
1,5,$APP.I,[O($APP.u(Q),$APP.Xc(Q))],null);;){if($APP.eb($APP.w(Z)))return $K(fa);var ha=jG.j(kG.A(lG.j($APP.u(Z)),lG.j(W)));W=ha;Q=$APP.Fc(Z);fa=$APP.Yd(O(ha,$APP.Xc(Z)),fa);Z=Q}})},MO.prototype.dd=function(){return this.id},MO.cb=!0,MO.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40792",MO.gb=function(B){return $APP.Vb(B,"emmy.calculus.manifold/t_emmy$calculus$manifold40792")};return new MO(b,g,a,p,l,A,t,v,n,$APP.F)}(),new $APP.f(null,2,[BO,n,oO,l],null))}function d(l){var n=IO(l);return g.A(l,
n)}var g=null;g=function(l,n){switch(arguments.length){case 1:return d.call(this,l);case 2:return c.call(this,l,n)}throw Error("Invalid arity: "+arguments.length);};g.j=d;g.A=c;return g}()};
V3a=function(a){return function(){function b(g,l){var n=FO.j(g),p=function(){var A=n+1;return a.j?a.j(A):a.call(null,A)}(),v=OF.j(p),t=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof NO)NO=function(A,B,G,J,O,Q,W,Z,fa){this.Ze=A;this.ctor=B;this.Pa=G;this.Ub=J;this.n=O;this.Gd=Q;this.Fd=W;this.id=Z;this.Ak=fa;this.O=393216;this.U=0},NO.prototype.da=function(A,B){return new NO(this.Ze,this.ctor,this.Pa,this.Ub,this.n,this.Gd,
this.Fd,this.id,B)},NO.prototype.ba=function(){return this.Ak},NO.prototype.cd=$APP.xc,NO.prototype.Cc=function(A,B){return $APP.Uc.A(this.n,1)&&$APP.Uc.A(LO.j(B),1)||WK(B)&&$APP.Uc.A(LO.j(B),this.n)},NO.prototype.Mc=function(A,B){return xO(B,this.Pa)},NO.prototype.Nc=function(A,B){var G=this,J=$APP.Uc.A(G.n,1)?uL.C($APP.y([B])):B,O=BH.A(J,J),Q=function(){var W=RF.A(O,1),Z=kG.A(1,O);return QF.A?QF.A(W,Z):QF.call(null,W,Z)}();A=cL(G.n+1,SK,function(W){if($APP.Uc.A(W,G.n))return Q;W=iG.A(2,$APP.x.A(J,
W));var Z=kG.A(1,O);return QF.A?QF.A(W,Z):QF.call(null,W,Z)});return vO(iG.A(G.Gd,A),G.Pa,this,B)},NO.prototype.Oc=function(A,B){var G=this;return yO(B,this,function(){var J=iG.A(G.Fd,wO(B));EF($APP.x.A(J,G.n))&&$APP.Uc.A($APP.x.A(J,G.n),1)&&BD("S^n stereographic singular");var O=cL(G.n,SK,function(Q){Q=$APP.x.A(J,Q);var W=RF.A(1,$APP.x.A(J,G.n));return QF.A?QF.A(Q,W):QF.call(null,Q,W)});return $APP.Uc.A(G.n,1)?$APP.u(O):O})},NO.prototype.dd=function(){return this.id},NO.cb=!0,NO.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40800",
NO.gb=function(A){return $APP.Vb(A,"emmy.calculus.manifold/t_emmy$calculus$manifold40800")};return new NO(a,d,g,l,n,p,v,t,$APP.F)}(),new $APP.f(null,2,[BO,l,oO,g],null))}function c(g){var l=IO(g);return d.A(g,l)}var d=null;d=function(g,l){switch(arguments.length){case 1:return c.call(this,g);case 2:return b.call(this,g,l)}throw Error("Invalid arity: "+arguments.length);};d.j=c;d.A=b;return d}()};
X3a=function(a){return function(){function b(g,l){var n=FO.j(g),p=function(){var A=n+1;return a.j?a.j(A):a.call(null,A)}(),v=OF.j(p),t=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof OO)OO=function(A,B,G,J,O,Q,W,Z,fa){this.Ze=A;this.ctor=B;this.Pa=G;this.Ub=J;this.n=O;this.Gd=Q;this.Fd=W;this.id=Z;this.Bk=fa;this.O=393216;this.U=0},OO.prototype.da=function(A,B){return new OO(this.Ze,this.ctor,this.Pa,this.Ub,this.n,this.Gd,
this.Fd,this.id,B)},OO.prototype.ba=function(){return this.Bk},OO.prototype.cd=$APP.xc,OO.prototype.Cc=function(A,B){return $APP.Uc.A(this.n,1)&&$APP.Uc.A(LO.j(B),1)||WK(B)&&$APP.Uc.A(LO.j(B),this.n)},OO.prototype.Mc=function(A,B){return xO(B,this.Pa)},OO.prototype.Nc=function(A,B){var G=this,J=$APP.Uc.A(G.n,1)?uL.C($APP.y([B])):B;A=BH.A(J,J);var O=jG.j(kG.A(1,A)),Q=QF.A(1,O);A=cL(kG.A(G.n,1),SK,function(W){return $APP.Uc.A(W,G.n)?Q:QF.A($APP.x.A(J,W),O)});return vO(iG.A(G.Gd,A),G.Pa,this,J)},OO.prototype.Oc=
function(A,B){var G=this,J=this;return yO(B,J,function(){var O=iG.A(G.Fd,wO(B)),Q=$APP.x.A(O,G.n);if($APP.k(function(){var Z=EF(Q);return Z?(Z=qG.j(Q),$APP.k(Z)?Z:KF.j(Q)):Z}()))throw $APP.Zi.A("Point not covered by S^n-gnomic coordinate patch.",new $APP.f(null,2,[$APP.PO,B,GO,J],null));var W=cL(G.n,SK,function(Z){return QF.A($APP.x.A(O,Z),Q)});return $APP.Uc.A(G.n,1)?$APP.x.A(W,0):W})},OO.prototype.dd=function(){return this.id},OO.cb=!0,OO.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40810",
OO.gb=function(A){return $APP.Vb(A,"emmy.calculus.manifold/t_emmy$calculus$manifold40810")};return new OO(a,d,g,l,n,p,v,t,$APP.F)}(),new $APP.f(null,2,[BO,l,oO,g],null))}function c(g){var l=IO(g);return d.A(g,l)}var d=null;d=function(g,l){switch(arguments.length){case 1:return c.call(this,g);case 2:return b.call(this,g,l)}throw Error("Invalid arity: "+arguments.length);};d.j=c;d.A=b;return d}()};
Y3a=function(a,b,c,d){return GF(d)?FWa(function(g){g=$APP.am(b,c,g);return a.j?a.j(g):a.call(null,g)})(d):AD(["non-numerical entry ",$APP.m.j(d)," at path ",$APP.m.j(c)," in input structure ",$APP.m.j(b)].join(""))};Z3a=function(a,b,c){var d=$APP.Zl.A(b,c);return $APP.k(d)?(d=mL(d),iL(function(g,l){l=$APP.hd(c)?l:$APP.Lf.A(c,l);return Y3a(a,b,l,g)},d)):AD(["Bad selectors ",$APP.m.j(c)," for structure ",$APP.m.j(b)].join(""))};
$3a=function(a,b){var c=$APP.tf(b);return function(d){return VK(d)?Z3a(a,d,c):$APP.hd(c)?FWa(a)(d):AD(["Selectors ",$APP.m.j(c)," not allowed for non-structural input ",$APP.m.j(d)].join(""))}};a4a=function(a,b){return QO(function(c){return $3a(c,b)},a)};b4a=function(a){return function(b){var c=RO.B,d=oL(a.j?a.j(b):a.call(null,b));var g=SO.j?SO.j(a):SO.call(null,a);g=g.j?g.j(b):g.call(null,b);return c.call(RO,d,g,b)}};UO=function(a){return DK(a)&&$APP.Uc.A(MK.j(HK(a)),TO)};
WO=function(a,b){return JK.B(a,b,new $APP.f(null,4,[MK,TO,$APP.c4a,d4a,HWa,e4a,VO,new $APP.H(null,1,5,$APP.I,[TH],null)],null))};f4a=function(a,b){return function(c){var d=WH,g=d.C,l=iG.A;c=WH.C($APP.y([c,EO(b)]));c=SO.j?SO.j(c):SO.call(null,c);return g.call(d,$APP.y([l.call(iG,c,a),DO(b)]))}};g4a=function(a,b){var c=WH,d=c.C,g=DO(b);a=a.j?a.j(g):a.call(null,g);return d.call(c,$APP.y([a,EO(b)]))};h4a=function(){return L3a};e4a=function(a){return JK.B(h4a,i4a,HK(a))};
d4a=function(a){return UO(a)&&$APP.Uc.A(EK(a),h4a)};j4a=function(a,b){var c=FO.j(pO(b)),d=$APP.Uc.A(c,1)?0:$K($APP.Uj.A(c,0));c=$APP.Uc.A(c,1)?new $APP.H(null,1,5,$APP.I,[0],null):d;return XO.B(TN.B(a,d,c),b,a)};k4a=function(a){return $APP.Zg.j(["d:d",$APP.m.j(a)].join(""))};ZO=function(a){return mL(iL(function(b,c){b=k4a(b);return $APP.Je.M(YO,a,b,c)},CO(a)))};
l4a=function(a,b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Fv,null,1,null),$APP.Vg.B(function(d,g){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,aG.j(d),null,1,null),$APP.y([new $APP.D(null,aG.j(g),null,1,null)]))))},$APP.ef(a),$APP.ef(b)))));return WO(function(d){var g=b.j?b.j(d):b.call(null,d);return function(l){return iG.A(g.j?g.j(l):g.call(null,l),a.j?a.j(l):a.call(null,l))}},c)};
m4a=function(a,b){return kL.C(function(c){return c.j?c.j(a):c.call(null,a)},$APP.y([b]))};o4a=function(a,b){return JK.A(function(c){return function(d){var g=WH.C($APP.y([function(){var l=DO(b);return a.j?a.j(l):a.call(null,l)}(),EO(b)]));return iG.A(function(){var l=SO.j?SO.j(c):SO.call(null,c);return l.j?l.j(d):l.call(null,d)}(),g.j?g.j(d):g.call(null,d))}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,n4a,null,1,null),new $APP.D(null,GK(a),null,1,null)))))};
p4a=function(a){return function(b,c){return function(d){return function(g){var l=oG.j(iG.A(b,c));l=l.j?l.j(d):l.call(null,d);g=l.j?l.j(g):l.call(null,g);return TXa(g,a)}}}};q4a=function(a,b){function c(g,l){if($APP.hd(g))return l;var n=$APP.u(g),p=$APP.Fc($APP.Ig.A(function(v){return $APP.qg.A(v,n)},b));g=$APP.Fc(g);return d(l,p,g,g,0)}var d=function A(l,n,p,v,t){return $APP.hd(v)?c(p,l+t):A(l,n,p,$APP.Fc(v),$APP.eb($APP.He($APP.wg([$APP.u(v)]),n))?t+1:t)};return c(a,0)};
r4a=function(a){function b(d,g){if($APP.hd(d))return g;var l=$APP.r(d);d=$APP.u(l);l=$APP.w(l);return c(g,d,l,l,0)}var c=function t(g,l,n,p,v){return $APP.hd(p)?b(n,g+v):t(g,l,n,$APP.Fc(p),$APP.u(p)>=l?v:v+1)};return b(a,0)};s4a=function(a,b){var c=$APP.tf(b);return $APP.Vg.A(function(d){return $APP.C.A(c,d)},a)};
v4a=function(a,b){var c=new $APP.Ac(function(){return $APP.Ss},t4a,$APP.fg([$APP.Lo,$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.hy,$APP.zj,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[!0,$APP.yn,u4a,"cljs/core.cljs",16,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.ux,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.ux,$APP.Vv,$APP.Bw],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ux,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,
[$APP.ux,$APP.Vv,$APP.Bw],null)),$APP.zx,$APP.M(null,null)],null),1,1544,1544,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ux,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.ux,$APP.Vv,$APP.Bw],null)),null,$APP.k($APP.Ss)?$APP.Ss.Z:null]));return c.A?c.A(a,b):c.call(null,a,b)};
A4a=function(a){function b(B,G){for(;;){var J=l[B]+n[B]|0;if(0>J)n[B]=-n[B]|0,J=G,--B,G=J;else if($APP.Uc.A(J,B+1)){if(0===B)return!1;n[B]=-n[B]|0;J=G+1;--B;G=J}else{var O=G+(B-l[B]);G+=B-J;var Q=g[O];g[O]=g[G];g[G]=Q;l[B]=J;return!0}}}function c(B){return $APP.Lf.A($APP.sf,B)}var d=$APP.Tc(a),g=$APP.Fi.j(a),l=$APP.nt.A(d,$APP.Uj.j(0)),n=$APP.nt.A(d,$APP.Uj.j(1)),p=$APP.kh.j(c(g)),v=$APP.kh.j(!0),t=function(){if("undefined"===typeof cM||"undefined"===typeof U_a||"undefined"===typeof w4a||"undefined"===
typeof $O)$O=function(B,G,J,O,Q,W,Z,fa,ha,ja){this.step=B;this.a=G;this.jh=J;this.o=O;this.Pf=Q;this.n=W;this.as=Z;this.Pg=fa;this.c=ha;this.tk=ja;this.O=393216;this.U=131072},$O.prototype.da=function(B,G){return new $O(this.step,this.a,this.jh,this.o,this.Pf,this.n,this.as,this.Pg,this.c,G)},$O.prototype.ba=function(){return this.tk},$O.prototype.hasNext=function(){return $APP.Fb(this.Pg)},$O.prototype.next=function(){var B=$APP.Fb(this.jh),G=this.Pg;var J=this.n-1;J=this.step.A?this.step.A(J,0):
this.step.call(null,J,0);$APP.Ne(G,J);$APP.Ne(this.jh,this.Pf.j?this.Pf.j(this.a):this.Pf.call(null,this.a));return B},$O.prototype.Qa=function(){return this},$O.cb=!0,$O.Ya="emmy.util.permute/t_emmy$util$permute49487",$O.gb=function(B){return $APP.Vb(B,"emmy.util.permute/t_emmy$util$permute49487")},x4a=function(B,G,J,O,Q,W,Z,fa,ha,ja){return new $O(B,G,J,O,Q,W,Z,fa,ha,ja)};return new $O(b,g,p,n,c,d,a,v,l,$APP.F)}(),A=new $APP.Ac(function(){return $APP.tt},y4a,$APP.fg([$APP.Lo,$APP.wl,$APP.R,$APP.Wi,
$APP.Lr,$APP.zj,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[!0,$APP.yn,z4a,"cljs/core.cljs",24,1,4176,4176,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.rya],null)),null,$APP.k($APP.tt)?$APP.tt.Z:null]));return A.j?A.j(t):A.call(null,t)};B4a=function(){return L3a};aP=function(a){if(DK(a)){var b=C4a.j(HK(a));return $APP.k(b)?b:AD(["operator, but not a differential form: ",$APP.m.j(a)].join(""))}return UH(a)?0:AD(["not a differential form: ",$APP.m.j(a)].join(""))};
cP=function(a){var b=DK(a);return b?(a=MK.j(HK(a)),$APP.vh(a,bP)):b};D4a=function(a,b){return cP(a)&&$APP.Uc.A(b,aP(a))};E4a=function(a){return D4a(a,1)};dP=function(a,b,c){if($APP.Uc.A(b,0))return a.J?a.J():a.call(null);var d=$APP.Lf.A($APP.sf,$APP.Uj.A(b,TO));return JK.B(a,c,$APP.Ni.C($APP.y([F4a,new $APP.f(null,4,[MK,bP,XH,new $APP.H(null,2,5,$APP.I,[fI,b],null),C4a,b,VO,d],null)])))};
fP=function(a,b){return JK.B(a,b,$APP.Ni.C($APP.y([F4a,new $APP.f(null,4,[MK,eP,XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),C4a,1,VO,new $APP.H(null,1,5,$APP.I,[TO],null)],null)])))};G4a=function(a,b){return function(c){return kL.C(function(d){return WH.C($APP.y([iG.A(a,g4a(d,b)),DO(b)]))},$APP.y([c]))}};H4a=function(a,b){var c=ZO(b);return WH.C($APP.y([a.j?a.j(c):a.call(null,c),EO(b)]))};
I4a=function(a,b){var c=FO.j(pO(b)),d=$APP.Uc.A(c,1)?0:$K($APP.Uj.A(c,0));c=aL($APP.Uj.A(c,0));return gP.B(TN.B(a,d,c),b,a)};J4a=function(a){return $APP.Zg.j(["d",$APP.m.j(a)].join(""))};iP=function(a){return iL(function(b,c){b=J4a(b);return $APP.Je.M(hP,a,b,c)},CO(a))};L4a=function(a,b){return fP(function(c){return iG.A(a,b.j?b.j(c):b.call(null,c))},K4a)};M4a=function(a,b){return kL.C(a,$APP.y([b]))};
kP=function(a){var b=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.jP,null,1,null),new $APP.D(null,aG.j(a),null,1,null))));return fP(function(c){return kL.C(function(d){return function(g){var l=d.j?d.j(a):d.call(null,a);return l.j?l.j(g):l.call(null,g)}},$APP.y([c]))},b)};
O4a=function(a,b){var c=aP(a),d=aP(b);if(0===c||0===d)return iG.A(a,b);var g=c+d,l=1/(FI(c)*FI(d));d=function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=new $APP.Bc(B,0,null)}return v.call(this,A)}function v(t){return iG.A(l,$APP.Je.A(kG,$APP.Vg.B(function(A,B){var G=$APP.Ye(c,A);A=$APP.x.B(G,0,null);G=$APP.x.B(G,1,null);return iG.C(B,$APP.Je.A(a,A),$APP.y([$APP.Je.A(b,G)]))},A4a(t),$APP.Ve(new $APP.H(null,2,5,$APP.I,
[1,-1],null)))))}p.G=0;p.K=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}();var n=$APP.T.j($APP.r($APP.N.C(new $APP.D(null,N4a,null,1,null),new $APP.D(null,aG.j(a),null,1,null),$APP.y([new $APP.D(null,aG.j(b),null,1,null)]))));return dP(d,g,n)};
Q4a=function(a){var b=aP(a);return 0===b?a:dP(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return iG.A(1/FI(b),function(){var l=$APP.Vg.B(function(n,p){return iG.A(p,$APP.Je.A(a,n))},A4a(g),$APP.Ve(new $APP.H(null,2,5,$APP.I,[1,-1],null)));return hL.j?hL.j(l):hL.call(null,l)}())}c.G=0;c.K=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),b,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
P4a,null,1,null),new $APP.D(null,aG.j(a),null,1,null)))))};
S4a=function(a,b){var c=aP(a),d=aP(b);return 0===c||0===d?iG.A(a,b):dP(function(){function g(n){var p=null;if(0<arguments.length){p=0;for(var v=Array(arguments.length-0);p<v.length;)v[p]=arguments[p+0],++p;p=new $APP.Bc(v,0,null)}return l.call(this,p)}function l(n){var p=$APP.Ye(c,n);n=$APP.x.B(p,0,null);p=$APP.x.B(p,1,null);return iG.A($APP.Je.A(a,n),$APP.Je.A(b,p))}g.G=0;g.K=function(n){n=$APP.r(n);return l(n)};g.C=l;return g}(),c+d,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,R4a,null,1,null),new $APP.D(null,
aG.j(a),null,1,null),$APP.y([new $APP.D(null,aG.j(b),null,1,null)])))))};lP=function(a){var b=ZO(a),c=iP(a);return new $APP.f(null,5,[$APP.Ti,T4a,FO,FO.j(pO(a)),U4a,b,V4a,c,GO,a],null)};W4a=function(a){return $APP.vh(BF(a),T4a)};X4a=function(a){return GO.j(a)};Z4a=function(a,b){var c=$APP.Tc($APP.ef(a));return new $APP.f(null,4,[$APP.Ti,Y4a,FO,c,U4a,a,V4a,b],null)};$4a=function(a){return $APP.vh(BF(a),Y4a)};mP=function(a){return V4a.j(a)};nP=function(a){return U4a.j(a)};a5a=function(a){return FO.j(a)};
pP=function(a,b){var c=nP(b);b=mP(b);return oP.C(a,$APP.y([c,b]))};b5a=function(a,b){function c(l){var n=oL(d);return qP.B(n,JN.B(n,kL.C(function(p){return p.j?p.j(l):p.call(null,l)},$APP.y([g])),d),d)}var d=CO(b),g=kL.C(function(l){return g4a(l,b)},$APP.y([a]));a=O3a(FO.j(pO(b)),SK,function(l){return $APP.Hl.A(rP.C($APP.y([l])),c)});return kL.C(function(l){return gP.A(l,b)},$APP.y([a]))};
c5a=function(a,b){return function(c){return function(d){var g=nP(a),l=mP(a);return iG.A(g.j?g.j(d):g.call(null,d),kL.C(function(n){return function(){var p=n.j?n.j(c):n.call(null,c);return p.j?p.j(b):p.call(null,b)}},$APP.y([l])))}}};d5a=function(a,b){return kL.C(mP(a),$APP.y([nP(b)]))};e5a=function(a,b){var c=$APP.sf;if(DK(a))return a=HK(a),b.A?b.A(a,c):b.call(null,a,c);a=$APP.ed(a);return b.A?b.A(a,c):b.call(null,a,c)};
f5a=function(a,b){return DK(a)?IK(a,$APP.Je.B($APP.rg,HK(a),b)):$APP.Je.M($APP.Xj,a,$APP.rg,b)};sP=function(a){return e5a(a,VO)};tP=function(a,b){b=$APP.Lf.A($APP.sf,b);return f5a(a,$APP.y([VO,b,XH,new $APP.H(null,2,5,$APP.I,[fI,$APP.Tc(b)],null)]))};uP=function(a){return e5a(a,g5a)};vP=function(a,b){b=$APP.Lf.A($APP.sf,b);return f5a(a,$APP.y([g5a,b,XH,new $APP.H(null,2,5,$APP.I,[fI,$APP.Tc(b)],null)]))};
h5a=function(a,b){var c=sP(a),d=nP(b),g=mP(b);b=$APP.Vg.A(function(l){return $APP.vh(l,TO)?wP:xP},c);return vP(function(l){l=$APP.Fl.B(function(n,p){return $APP.vh(n,TO)?$APP.C.A(d,p):$APP.C.A(g,p)},c,l);return $APP.Je.A(a,l)},b)};
i5a=function(a,b){var c=uP(a),d=nP(b),g=mP(b),l=a5a(b),n=$APP.Fl.A(new $APP.f(null,2,[xP,eP,wP,TO],null),c);return tP(function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=new $APP.Bc(B,0,null)}return v.call(this,A)}function v(t){var A=$APP.Wd($APP.Hj.j(l)),B=yP(function(){return function Q(O){return new $APP.de(null,function(){for(;;){var W=$APP.r(O);if(W){var Z=W;if($APP.pd(Z)){var fa=$APP.lc(Z),ha=$APP.Tc(fa),ja=
$APP.fe(ha);return function(){for(var ua=0;;)if(ua<ha){var ca=$APP.bd(fa,ua);$APP.je(ja,$APP.Vg.B(function(V,da,Y,ea,ya,wa,Ba,Qa,Va,cb){return function(pb,rb){return new $APP.H(null,2,5,$APP.I,[pb,UO(rb)?function(){var yb=$APP.C.A(cb,pb);return yb.j?yb.j(rb):yb.call(null,rb)}():function(){var yb=$APP.C.A(Va,pb);return rb.j?rb.j(yb):rb.call(null,yb)}()],null)}}(ua,ca,fa,ha,ja,Z,W,A,d,g,l,n,c),A,$APP.Uj.j(ca)));ua+=1}else return!0}()?$APP.ie($APP.ke(ja),Q($APP.mc(Z))):$APP.ie($APP.ke(ja),null)}var ta=
$APP.u(Z);return $APP.Yd($APP.Vg.B(function(ua,ca,V,da,Y,ea){return function(ya,wa){return new $APP.H(null,2,5,$APP.I,[ya,UO(wa)?function(){var Ba=$APP.C.A(ea,ya);return Ba.j?Ba.j(wa):Ba.call(null,wa)}():function(){var Ba=$APP.C.A(Y,ya);return wa.j?wa.j(Ba):wa.call(null,Ba)}()],null)}}(ta,Z,W,A,d,g,l,n,c),A,$APP.Uj.j(ta)),Q($APP.Fc(Z)))}return null}},null,null)}(t)}()),G=function(){return function Q(O){return new $APP.de(null,function(){for(;;){var W=$APP.r(O);if(W){if($APP.pd(W)){var Z=$APP.lc(W),
fa=$APP.Tc(Z),ha=$APP.fe(fa);a:for(var ja=0;;)if(ja<fa){var ta=$APP.bd(Z,ja),ua=$APP.Vg.A($APP.u,ta);ta=$APP.Vg.A($APP.fd,ta);$APP.je(ha,$APP.Je.B(iG,a.j?a.j(ua):a.call(null,ua),$APP.Wd(ta)));ja+=1}else{Z=!0;break a}return Z?$APP.ie($APP.ke(ha),Q($APP.mc(W))):$APP.ie($APP.ke(ha),null)}Z=$APP.u(W);ha=$APP.Vg.A($APP.u,Z);Z=$APP.Vg.A($APP.fd,Z);return $APP.Yd($APP.Je.B(iG,a.j?a.j(ha):a.call(null,ha),$APP.Wd(Z)),Q($APP.Fc(W)))}return null}},null,null)}(B)}();return hL.j?hL.j(G):hL.call(null,G)}p.G=0;
p.K=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}(),n)};
j5a=function(a,b){var c=uP(a),d=uP(b);c=$APP.Kg(c);c=$APP.qe(c);var g=$APP.C.A(c,xP);c=$APP.C.A(c,wP);d=$APP.Kg(d);var l=$APP.qe(d);d=$APP.C.A(l,xP);l=$APP.C.A(l,wP);var n=kG.A($APP.k(g)?g:0,$APP.k(d)?d:0);d=kG.A($APP.k(c)?c:0,$APP.k(l)?l:0);var p=kG.A(n,d),v=kG.A(n,c);return vP(function(t){var A=$APP.Lf.A($APP.sf,t);return iG.A(function(){var B=$APP.Lf.A($APP.oi.B(A,0,g),$APP.oi.B(A,n,v));return a.j?a.j(B):a.call(null,B)}(),function(){var B=$APP.Lf.A($APP.oi.B(A,g,n),$APP.oi.B(A,v,p));return b.j?
b.j(B):b.call(null,B)}())},$APP.N.A($APP.Uj.A(n,xP),$APP.Uj.A(d,wP)))};k5a=function(a,b,c){var d=$APP.oi.B(a,0,b);a=$APP.oi.A(a,b);return $APP.Je.M($APP.Vd,d,c,a)};
l5a=function(a,b,c,d){var g=uP(a);g=$APP.Kg(g);var l=$APP.qe(g);g=$APP.C.A(l,xP);l=$APP.C.A(l,wP);var n=g-1;g=l-1;return vP(function(p){function v(A){A=$APP.N.A(k5a($APP.oi.B(t,0,n),b,A),k5a($APP.oi.A(t,n),c,A));return a.j?a.j(A):a.call(null,A)}var t=$APP.Lf.A($APP.sf,p);return hL.B?hL.B(v,0,d):hL.call(null,v,0,d)},$APP.N.A($APP.Uj.A(n,xP),$APP.Uj.A(g,wP)))};
m5a=function(a,b){var c=nP(b),d=mP(b);return function p(l,n){if($APP.hd(l))return $APP.Je.A(a,n);l=$APP.r(l);var v=$APP.u(l),t=$APP.w(l);return kL.C(function(A){return p(t,$APP.Vd.A(n,A))},$APP.y([$APP.vh(v,TO)?c:$APP.vh(v,eP)?d:AD(["Invalid argument type: ",$APP.jh.C($APP.y([v])),". Every arg must be a vector field or oneform field."].join(""))]))}(sP(a),$APP.sf)};
n5a=function(a,b){var c=nP(b),d=mP(b),g=function(){for(var l=a,n=$APP.sf;;)if(VK(l)){var p=function(){var A=TK(l);return zP.j?zP.j(A):zP.call(null,A)}(),v=function(){var A=p;A=A instanceof $APP.E?A.ga:null;switch(A){case "emmy.structure/up":return TO;case "emmy.structure/down":return eP;default:throw Error(["No matching clause: ",$APP.m.j(A)].join(""));}}(),t=$APP.x.A(l,0);n=$APP.Vd.A(n,v);l=t}else return n}();return tP(function(){function l(p){var v=null;if(0<arguments.length){v=0;for(var t=Array(arguments.length-
0);v<t.length;)t[v]=arguments[v+0],++v;v=new $APP.Bc(t,0,null)}return n.call(this,v)}function n(p){return iG.A(function B(t,A){if($APP.hd(t))return M3a;var G=$APP.u(t),J=$APP.u(A);return $APP.vh(J,TO)?kL.C(function(O){return iG.A(O.j?O.j(G):O.call(null,G),B($APP.Fc(t),$APP.Fc(A)))},$APP.y([d])):$APP.vh(J,eP)?kL.C(function(O){return iG.A(G.j?G.j(O):G.call(null,O),B($APP.Fc(t),$APP.Fc(A)))},$APP.y([c])):null}(p,g),a)}l.G=0;l.K=function(p){p=$APP.r(p);return n(p)};l.C=n;return l}(),g)};
o5a=function(a){return function(b){return WH.C($APP.y([b,a]))}};p5a=function(a){return function(b){return WH.C($APP.y([b,a]))}};AP=function(a){return function(b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.jP,null,1,null),new $APP.D(null,aG.j(a),null,1,null)))),null,1,null),new $APP.D(null,aG.j(b),null,1,null))));return WO(function(d){d=WH.C($APP.y([d,a]));return b.j?b.j(d):b.call(null,d)},c)}};
r5a=function(a,b){return function(c){var d=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,q5a,null,1,null),new $APP.D(null,aG.j(a),null,1,null)))),null,1,null),new $APP.D(null,aG.j(c),null,1,null))));return WO(function(g){var l=WH,n=l.C;g=WH.C($APP.y([g,a]));g=c.j?c.j(g):c.call(null,g);return n.call(l,$APP.y([g,b]))},d)}};
s5a=function(a,b,c){var d=FO.j(pO(b)),g=FO.j(pO(c));d=$APP.Uc.A(d,1)?0:$K($APP.Uj.A(d,0));g=$K($APP.Uj.A(g,0));return WH.C($APP.y([EO(c),TN.B(a,d,g),DO(b)]))};u5a=function(a){return function(b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,t5a,null,1,null),new $APP.D(null,aG.j(a),null,1,null)))),null,1,null),new $APP.D(null,aG.j(b),null,1,null))));return WO(function(d){return WH.C($APP.y([b.j?b.j(d):b.call(null,d),a]))},c)}};
BP=function(a){return function(b){function c(n,p){return WO(function(v){return function(){var t=n.j?n.j(v):n.call(null,v);return t.j?t.j(p):t.call(null,p)}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,v5a,null,1,null),new $APP.D(null,aG.j(n),null,1,null)))))}var d=function(){function n(v){var t=null;if(0<arguments.length){t=0;for(var A=Array(arguments.length-0);t<A.length;)A[t]=arguments[t+0],++t;t=new $APP.Bc(A,0,null)}return p.call(this,t)}function p(v){return function(t){var A=a.j?a.j(t):a.call(null,
t),B=$APP.Je.A(b,$APP.Vg.A(function(G){return c(G,t)},v));return B.j?B.j(A):B.call(null,A)}}n.G=0;n.K=function(v){v=$APP.r(v);return p(v)};n.C=p;return n}(),g=aP(b),l=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,w5a,null,1,null),new $APP.D(null,aG.j(a),null,1,null)))),null,1,null),new $APP.D(null,aG.j(b),null,1,null))));return dP(d,g,l)}};x5a=function(a,b){var c=nP(b);b=mP(b);return Z4a(kL.C(u5a(a),$APP.y([c])),kL.C(BP(a),$APP.y([b])))};
z5a=function(a){return function(b){var c=aP(b);if(0===c)return o5a(a)(b);var d=function(){function l(p){var v=null;if(0<arguments.length){v=0;for(var t=Array(arguments.length-0);v<t.length;)t[v]=arguments[v+0],++v;v=new $APP.Bc(t,0,null)}return n.call(this,v)}function n(p){return $APP.Je.A(BP(a)(b),$APP.Vg.A(AP.j?AP.j(a):AP.call(null,a),p))}l.G=0;l.K=function(p){p=$APP.r(p);return n(p)};l.C=n;return l}(),g=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,y5a,null,
1,null),new $APP.D(null,aG.j(a),null,1,null)))),null,1,null),new $APP.D(null,aG.j(b),null,1,null))));return dP(d,c,g)}};A5a=function(a,b){return r5a(b,a)};C5a=function(a){return JK.A(function(b){return iG.A(SO.j?SO.j(b):SO.call(null,b),a)},new $APP.D(null,B5a,new $APP.D(null,aG.j(a),null,1,null),2,null))};
E5a=function(a){return function(b){var c=aP(b);return dP(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return $APP.Je.B(b,a,l)}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),c-1,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,D5a,null,1,null),new $APP.D(null,aG.j(a),null,1,null)))),null,1,null),new $APP.D(null,
aG.j(b),null,1,null)))))}};EP=function(a,b){return new $APP.f(null,3,[$APP.Ti,F5a,CP,a,DP,b],null)};G5a=function(a){return $APP.Uc.A(BF(a),F5a)};FP=function(a){return CP.j(a)};GP=function(a){return DP.j(a)};HP=function(a,b){return new $APP.f(null,3,[$APP.Ti,H5a,I5a,a,DP,b],null)};J5a=function(a){return $APP.Uc.A(BF(a),H5a)};K5a=function(a){return I5a.j(a)};L5a=function(a){return DP.j(a)};M5a=function(a){var b=GP(a);a=FP(a);return HP(kL.C(a,$APP.y([nP(b)])),b)};
N5a=function(a){var b=L5a(a);a=K5a(a);return EP(iG.A(a,mP(b)),b)};O5a=function(a){var b=K5a(a);return HP(iG.A(QF.A(1,2),kG.A(b,d_a(b))),L5a(a))};P5a=function(a){return N5a(O5a(M5a(a)))};R5a=function(a,b){var c=GP(a),d=FP(a);a=mP(b);var g=nP(b),l=nP(c);c=mP(c);var n=kL.C(c,$APP.y([g])),p=kL.C(a,$APP.y([l]));c=fP(function(v){return kG.A(iG.A(p,v.j?v.j(n):v.call(null,n)),iG.A(p,iG.A(d.j?d.j(v):d.call(null,v),n)))},Q5a);return EP(c,b)};
S5a=function(a,b){var c=x5a(b,GP(a));a=kL.C(BP(b),$APP.y([FP(a)]));return EP(a,c)};
T5a=function(a){var b=GP(a),c=FP(a),d=nP(b),g=mP(b);return function(l){var n=c.j?c.j(l):c.call(null,l);return function(p){var v=g.j?g.j(p):g.call(null,p),t=kG.A(l.j?l.j(v):l.call(null,v),iG.A(n,v));return WO(function(A){return iG.A(d.j?d.j(A):d.call(null,A),t)},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,IP,null,1,null),new $APP.D(null,aG.j(l),null,1,null)))),null,1,null),new $APP.D(null,aG.j(p),null,1,null)))))}}};
U5a=function(a){return function(b){return function(c){var d=aP(c),g=T5a(a)(b),l=function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=new $APP.Bc(B,0,null)}return v.call(this,A)}function v(t){var A=$APP.Lf.A($APP.sf,t);return RF.A(function(){var B=$APP.Je.A(c,A);return b.j?b.j(B):b.call(null,B)}(),function(){function B(G){G=$APP.Fj.B(A,G,g);return $APP.Je.A(c,G)}return hL.B?hL.B(B,0,d):hL.call(null,B,0,d)}())}p.G=0;
p.K=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}(),n=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,IP,null,1,null),new $APP.D(null,aG.j(b),null,1,null)))),null,1,null),new $APP.D(null,aG.j(c),null,1,null))));return dP(l,d,n)}}};
V5a=function(a){var b=GP(a),c=nP(b),d=mP(b),g=FP(a);return function(l){var n=g.j?g.j(l):g.call(null,l);return function(p){var v=sP(p),t=function Q(B,G,J,O){return $APP.hd(B)?iG.A(function(){var W=$APP.Je.A(p,J);return l.j?l.j(W):l.call(null,W)}(),$APP.Je.A(iG,O)):pP(function(W,Z){return $APP.vh($APP.u(B),TO)?Q($APP.Fc(B),$APP.Fc(G),$APP.Vd.A(J,W),$APP.Vd.A(O,function(){var fa=$APP.u(G);return Z.j?Z.j(fa):Z.call(null,fa)}())):$APP.vh($APP.u(B),eP)?Q($APP.Fc(B),$APP.Fc(G),$APP.Vd.A(J,Z),$APP.Vd.A(O,
function(){var fa=$APP.u(G);return fa.j?fa.j(W):fa.call(null,W)}())):null},b)};return tP(function(){function B(J){var O=null;if(0<arguments.length){O=0;for(var Q=Array(arguments.length-0);O<Q.length;)Q[O]=arguments[O+0],++O;O=new $APP.Bc(Q,0,null)}return G.call(this,O)}function G(J){var O=$APP.Lf.A($APP.sf,J);J=t(v,O,$APP.sf,$APP.sf);var Q=function(){var W=$APP.gp.A(function(Z,fa){return $APP.vh(fa,eP)?iG.A(iG.A(kL.C(function(ha){var ja=$APP.x.A(O,Z);return ja.j?ja.j(ha):ja.call(null,ha)},$APP.y([c])),
n),kL.C(function(ha){return $APP.Je.A(p,$APP.rg.B(O,Z,ha))},$APP.y([d]))):$APP.vh(fa,TO)?PF.j(iG.A(kL.C(function(ha){return $APP.Je.A(p,$APP.rg.B(O,Z,ha))},$APP.y([c])),iG.A(n,kL.C(function(ha){var ja=$APP.x.A(O,Z);return ha.j?ha.j(ja):ha.call(null,ja)},$APP.y([d]))))):null},v);return hL.j?hL.j(W):hL.call(null,W)}();return kG.A(J,Q)}B.G=0;B.K=function(J){J=$APP.r(J);return G(J)};B.C=G;return B}(),v)}}};
W5a=function(a){return function(b){return function(c){return function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){var n=$APP.Je.A(JP,l);if($APP.Uc.A($APP.Tc(l),1)&&B3a($APP.u(l))){var p=tP(c,n);l=$APP.u(l);n=b.j?b.j(p):b.call(null,p);return n.j?n.j(l):n.call(null,l)}return $APP.Ge(function(v){return UO(v)||E4a(v)},l)?(p=tP(c,n),$APP.Je.A(function(){var v=V5a(a)(b);
return v.j?v.j(p):v.call(null,p)}(),l)):AD("Bad function or arguments to covariant derivative")}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}()}}};
X5a=function(a){return function(b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,IP,null,1,null),new $APP.D(null,aG.j(b),null,1,null))));return JK.A(function l(g){if(UO(g)){var n=T5a(a)(b);return n.j?n.j(g):n.call(null,g)}return cP(g)?(n=U5a(a)(b),n.j?n.j(g):n.call(null,g)):$APP.vd($APP.r(sP(g)))?(n=V5a(a)(b),n.j?n.j(g):n.call(null,g)):UH(g)?(n=W5a(a)(b),n.j?n.j(g):n.call(null,g)):VK(g)?kL.C(l,$APP.y([g])):yD(["Can't do this kind of covariant derivative yet ",$APP.m.j(aG.j(b))," @ ",$APP.m.j(aG.j(g))].join(""))},
c)}};Y5a=function(a){return function(b){return function(c){c=KP.j(a)(c);return c.j?c.j(b):c.call(null,b)}}};Z5a=function(a,b,c){return function(d){return function(g){var l=ZO(a);var n=DO(b);var p=AP.j?AP.j(d):AP.call(null,d);p=p.j?p.j(l):p.call(null,l);l=KP.A(c,d)(l);l=l.j?l.j(p):l.call(null,p);n=l.j?l.j(n):l.call(null,n);return n.j?n.j(g):n.call(null,g)}}};
$5a=function(a,b,c){return function(d){return function(g){return function(l){var n=ZO(a);var p=DO(b);n=KP.A(c,d)(n);n=n.j?n.j(g):n.call(null,g);p=n.j?n.j(p):n.call(null,p);return p.j?p.j(l):p.call(null,l)}}}};a6a=function(a){var b=CO(a);return iL(function(c,d){return $APP.z(function(g){return $APP.Zl.A(AO(a,g),d)},new $APP.f(null,1,[$APP.R,c],null))},b)};
b6a=function(a){return function d(c){var g;if(g=$APP.kd(c)){g=$APP.u(c);var l=new $APP.ug(null,new $APP.f(null,2,[wP,"null",xP,"null"],null),null);g=l.j?l.j(g):l.call(null,g)}return $APP.k(g)?(g=$APP.u(c),g=$APP.Uc.A(g,xP)?LP:MP,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,g,null,1,null),$APP.Vg.A(d,$APP.Fc(c)))))):$APP.od(c)?$APP.Fl.A(d,c):c instanceof $APP.q?new $APP.D(null,$APP.K,new $APP.D(null,c,null,1,null),2,null):AD("Invalid coordinate prototype")}(a)};
c6a=function(a,b){function c(g,l){return WH.C($APP.y([function(n){return $APP.C.A(n,l)},g]))}var d=SO.j?SO.j(b):SO.call(null,b);return $APP.Uc.A(a,1)?QN.C($APP.y([QN.C($APP.y([BH.A(d,d)]))])):cL(a,XK,function(g){return cL(a,XK,function(l){return BH.A(c(d,g),c(d,l))})})};NP=function(a){var b=FO.j(pO(a));a=WH.C($APP.y([wO,EO(a)]));return c6a(b,a)};
d6a=function(a){var b=lP(a),c=mP(b),d=NP(a),g=DO(a);return tP(function(l,n){return function(p){var v=function(){var t=g(p);return d.j?d.j(t):d.call(null,t)}();return iG.A(iG.A(v,function(){var t=c.j?c.j(l):c.call(null,l);return t.j?t.j(p):t.call(null,p)}()),function(){var t=c.j?c.j(n):c.call(null,n);return t.j?t.j(p):t.call(null,p)}())}},new $APP.H(null,2,5,$APP.I,[TO,TO],null))};
e6a=function(a){var b=lP(a),c=nP(b),d=QF.A(1,NP(a)),g=DO(a);return tP(function(l,n){return function(p){var v=function(){var t=g(p);return d.j?d.j(t):d.call(null,t)}();return iG.A(iG.A(v,kL.C(function(t){t=l.j?l.j(t):l.call(null,t);return t.j?t.j(p):t.call(null,p)},$APP.y([c]))),kL.C(function(t){t=n.j?n.j(t):n.call(null,t);return t.j?t.j(p):t.call(null,p)},$APP.y([c])))}},new $APP.H(null,2,5,$APP.I,[eP,eP],null))};
f6a=function(a,b){return function l(d,g){return d<=g?HO($APP.Zg.j([$APP.m.j(a),"_",$APP.m.j(d),$APP.m.j(g)].join("")),b):l(g,d)}};g6a=function(a,b){var c=lP(b),d=mP(c),g=f6a(a,b),l=LO.j(d),n=cL(l,XK,function(p){return cL(l,XK,function(v){return g(p,v)})});return tP(function(p,v){return iG.A(iG.A(n,d.j?d.j(p):d.call(null,p)),d.j?d.j(v):d.call(null,v))},new $APP.H(null,2,5,$APP.I,[TO,TO],null))};
h6a=function(a,b){var c=mP(b);return function(d,g){return iG.A(c.j?c.j(d):c.call(null,d),iG.A(a,c.j?c.j(g):c.call(null,g)))}};i6a=function(a,b){var c=nP(b);return kL.C(function(d){return kL.C(function(g){return a.A?a.A(d,g):a.call(null,d,g)},$APP.y([c]))},$APP.y([c]))};j6a=function(a,b){return function(c){var d=i6a(a,b);c=d.j?d.j(c):d.call(null,c);d=mP(b);d=lL(d);return JN.B(d,c,d)}};
OP=function(a,b){return tP(function(c,d){var g=nP(b);return iG.A(iG.A(j6a(a,b),kL.C(c,$APP.y([g]))),kL.C(d,$APP.y([g])))},new $APP.H(null,2,5,$APP.I,[eP,eP],null))};
k6a=function(a,b){function c(d,g){return WO(function(l){return function(){var n=d.j?d.j(l):d.call(null,l);return n.j?n.j(g):n.call(null,g)}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,v5a,null,1,null),new $APP.D(null,aG.j(d),null,1,null)))))}return tP(function(d,g){return function(l){var n=a.j?a.j(l):a.call(null,l);var p=c(d,l);l=c(g,l);p=b.A?b.A(p,l):b.call(null,p,l);return p.j?p.j(n):p.call(null,n)}},new $APP.H(null,2,5,$APP.I,[TO,TO],null))};
PP=function(a){return function(b){return fP(function(c){return a.A?a.A(c,b):a.call(null,c,b)},$APP.T.j($APP.r($APP.N.C(new $APP.D(null,l6a,null,1,null),new $APP.D(null,aG.j(b),null,1,null),$APP.y([new $APP.D(null,aG.j(a),null,1,null)])))))}};
QP=function(a,b){var c=OP(a,b);return function(d){var g=pP(function(l,n){return iG.A(c.A?c.A(d,n):c.call(null,d,n),l)},b);return WO(g,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,m6a,null,1,null),new $APP.D(null,aG.j(d),null,1,null),$APP.y([new $APP.D(null,aG.j(a),null,1,null)])))))}};
n6a=function(a,b){return function(c){return tP(function(d,g){return pP(function(l,n){return pP(function(p,v){return iG.C(a.A?a.A(d,l):a.call(null,d,l),c.A?c.A(n,v):c.call(null,n,v),$APP.y([a.A?a.A(p,g):a.call(null,p,g)]))},b)},b)},new $APP.H(null,2,5,$APP.I,[TO,TO],null))}};
o6a=function(a,b){var c=OP(a,b);return function(d){return tP(function(g,l){return pP(function(n,p){return pP(function(v,t){return iG.C(c.A?c.A(g,p):c.call(null,g,p),d.A?d.A(n,v):d.call(null,n,v),$APP.y([c.A?c.A(t,l):c.call(null,t,l)]))},b)},b)},new $APP.H(null,2,5,$APP.I,[eP,eP],null))}};
p6a=function(a,b){var c=OP(a,b);return function(d){var g=pP(function(l,n){return pP(function(p,v){return iG.A(c.A?c.A(n,v):c.call(null,n,v),d.A?d.A(l,p):d.call(null,l,p))},b)},b);return tP(g,new $APP.H(null,1,5,$APP.I,[TH],null))}};q6a=function(a,b){return function(c){var d=pP(function(g,l){return pP(function(n,p){return iG.A(a.A?a.A(g,n):a.call(null,g,n),c.A?c.A(l,p):c.call(null,l,p))},b)},b);return tP(d,new $APP.H(null,1,5,$APP.I,[TH],null))}};
r6a=function(a,b,c){var d=j6a(a,b)(c),g=nP(b);return function(l){var n=kL.C(function(p){p=l.j?l.j(p):l.call(null,p);return p.j?p.j(c):p.call(null,c)},$APP.y([g]));n=iG.A(d,n);return oP.C(iG,$APP.y([n,g]))}};t6a=function(a,b){return new $APP.f(null,3,[$APP.Ti,s6a,I5a,a,DP,b],null)};
u6a=function(a,b){var c=nP(b),d=QF.A(1,2);return t6a(kL.C(function(g){return kL.C(function(l){return kL.C(function(n){return iG.A(d,RF.A(kG.A(function(){var p=a.A?a.A(n,l):a.call(null,n,l);return g.j?g.j(p):g.call(null,p)}(),function(){var p=a.A?a.A(n,g):a.call(null,n,g);return l.j?l.j(p):l.call(null,p)}()),function(){var p=a.A?a.A(l,g):a.call(null,l,g);return n.j?n.j(p):n.call(null,p)}()))},$APP.y([c]))},$APP.y([c]))},$APP.y([c])),b)};
v6a=function(a,b){var c=YH($APP.Hl.A(YH,a)),d=OP(c,b),g=nP(b),l=mP(b),n=QF.A(1,2);return HP(kL.C(function(p){return kL.C(function(v){return kL.C(function(t){return pP(function(A,B){return iG.A(d.A?d.A(t,B):d.call(null,t,B),iG.A(n,RF.A(kG.A(function(){var G=c.A?c.A(A,v):c.call(null,A,v);return p.j?p.j(G):p.call(null,G)}(),function(){var G=c.A?c.A(A,p):c.call(null,A,p);return v.j?v.j(G):v.call(null,G)}()),function(){var G=c.A?c.A(v,p):c.call(null,v,p);return A.j?A.j(G):A.call(null,G)}())))},b)},$APP.y([l]))},
$APP.y([g]))},$APP.y([g])),b)};w6a=function(a,b,c){function d(p){p=dL.j?dL.j(p):dL.call(null,p);return $APP.k(p)?p:AD(["Bad scripts: ",$APP.m.j(b)].join(""))}var g=$APP.x.B(b,0,null),l=$APP.x.B(b,1,null),n=$APP.x.B(b,2,null);return cL(c,g,function(p){return cL(c,l,function(v){return cL(c,n,function(t){return $APP.Zg.j([$APP.m.j(a),$APP.m.j(d(g)),$APP.m.j(p),$APP.m.j(v),$APP.m.j(d(n)),$APP.m.j(t)].join(""))})})})};
x6a=function(a,b){var c=FO.j(pO(b));return t6a(kL.C(function(d){return HO(d,b)},$APP.y([w6a(a,new $APP.H(null,3,5,$APP.I,[XK,XK,XK],null),c)])),lP(b))};y6a=function(a,b){var c=FO.j(pO(b));return HP(kL.C(function(d){return HO(d,b)},$APP.y([w6a(a,new $APP.H(null,3,5,$APP.I,[XK,XK,SK],null),c)])),lP(b))};z6a=function(a,b){return N5a(y6a(a,b))};RP=function(a,b,c,d,g){return pP(function(l,n){var p=iG.A;l=g.A?g.A(c,l):g.call(null,c,l);var v=NK(a,b);n=n.j?n.j(v):n.call(null,v);return p.call(iG,l,n)},d)};
A6a=function(a,b){var c=nP(b),d=QF.A(1,2);return HP(kL.C(function(g){return kL.C(function(l){return kL.C(function(n){return iG.A(d,kG.A(RF.A(kG.A(function(){var p=a.A?a.A(n,l):a.call(null,n,l);return g.j?g.j(p):g.call(null,p)}(),function(){var p=a.A?a.A(n,g):a.call(null,n,g);return l.j?l.j(p):l.call(null,p)}()),function(){var p=a.A?a.A(l,g):a.call(null,l,g);return n.j?n.j(p):n.call(null,p)}()),RF.A(kG.A(RP(n,l,g,b,a),RP(n,g,l,b,a)),RP(l,g,n,b,a))))},$APP.y([c]))},$APP.y([c]))},$APP.y([c])),b)};
B6a=function(a,b){var c=nP(b),d=mP(b),g=OP(a,b),l=QF.A(1,2);return HP(kL.C(function(n){return kL.C(function(p){return kL.C(function(v){return pP(function(t,A){return iG.A(g.A?g.A(v,A):g.call(null,v,A),iG.A(l,kG.A(RF.A(kG.A(function(){var B=a.A?a.A(t,p):a.call(null,t,p);return n.j?n.j(B):n.call(null,B)}(),function(){var B=a.A?a.A(t,n):a.call(null,t,n);return p.j?p.j(B):p.call(null,B)}()),function(){var B=a.A?a.A(p,n):a.call(null,p,n);return t.j?t.j(B):t.call(null,B)}()),RF.A(kG.A(RP(t,p,n,b,a),RP(t,
n,p,b,a)),RP(p,n,t,b,a)))))},b)},$APP.y([d]))},$APP.y([c]))},$APP.y([c])),b)};C6a=function(a){return function(b,c){var d=RF.A,g=NK(a.j?a.j(b):a.call(null,b),a.j?a.j(c):a.call(null,c));b=NK(b,c);b=a.j?a.j(b):a.call(null,b);return d.call(RF,g,b)}};D6a=function(a){return tP(function(b,c,d,g){d=C6a(a)(d,g);c=d.j?d.j(c):d.call(null,c);return b.j?b.j(c):b.call(null,c)},new $APP.H(null,4,5,$APP.I,[eP,TO,TO,TO],null))};
E6a=function(a,b){return tP(function(c,d){return pP(function(g,l){var n=D6a(a);return n.M?n.M(l,c,g,d):n.call(null,l,c,g,d)},b)},new $APP.H(null,2,5,$APP.I,[TO,TO],null))};F6a=function(a){return function(b,c){return kG.C(function(){var d=a.j?a.j(b):a.call(null,b);return d.j?d.j(c):d.call(null,c)}(),iG.A(-1,function(){var d=a.j?a.j(c):a.call(null,c);return d.j?d.j(b):d.call(null,b)}()),$APP.y([iG.A(-1,NK(b,c))]))}};
G6a=function(a){return tP(function(b,c,d){c=F6a(a)(c,d);return b.j?b.j(c):b.call(null,c)},new $APP.H(null,3,5,$APP.I,[eP,TO,TO],null))};H6a=function(a,b){var c=ZO(b),d=iP(b);b=EO(b)(uL.C($APP.y([$APP.Vv,$APP.SP,$APP.TP])));d=kL.C(function(g){return kL.C(function(l){return kL.C(function(n){return kL.C(function(p){p=C6a(a)(n,p);p=p.j?p.j(l):p.call(null,l);return g.j?g.j(p):g.call(null,p)},$APP.y([c]))},$APP.y([c]))},$APP.y([c]))},$APP.y([d]));return d.j?d.j(b):d.call(null,b)};
I6a=function(a,b){function c(p){return iG.A(QF.A(1,jG.j(jG.j(lG.j(b.A?b.A(p,p):b.call(null,p,p))))),p)}a=$APP.ef(a);for(var d=c($APP.u(a)),g=$APP.Fc(a),l=new $APP.H(null,1,5,$APP.I,[d],null);;){if($APP.hd(g))return aL(l);var n=$APP.Fc(g);l=$APP.Vd.A(l,c(RF.A($APP.u(g),$APP.Je.A(kG,$APP.Vg.A(function(p){return function(v){var t=iG.A;var A=$APP.u(p);A=b.A?b.A(A,v):b.call(null,A,v);return t.call(iG,A,v)}}(g,l,a,d),l)))));g=n}};J6a=function(a,b,c){a=I6a(nP(a),b);return Z4a(a,b5a(a,c))};
K6a=function(a,b){return WH.C($APP.y([QP(a,b),UP]))};L6a=function(a,b){var c=VP(a,b);b=QP(a,b);return WH.C($APP.y([b,c,UP,PP(a)]))};M6a=function(a,b){return WH.C($APP.y([WP.A(a,b),K6a(a,b)]))};N6a=function(a){var b=NP(a);a=FO.j(pO(a));return cL(a,XK,function(c){return jG.j($APP.Zl.A(b,new $APP.H(null,2,5,$APP.I,[c,c],null)))})};R6a=function(a,b){return $APP.z(new $APP.H(null,2,5,$APP.I,[b,null],null),new $APP.f(null,3,[O6a,$APP.td,P6a,$APP.Kd,Q6a,a],null))};
S6a=function(a){return R6a(function(b,c){return $APP.z(c,$APP.ed(b))},a)};XP=function(a){return a.j?a.j(0):a.call(null,0)};YP=function(a){var b=XP(a);a=O6a.j($APP.ed(a));return a.j?a.j(b):a.call(null,b)};T6a=function(a){return $APP.ZP.j(a.j?a.j(1):a.call(null,1))};
aQ=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.qe(c),g=$APP.C.A(d,$P);c=$APP.C.A(d,U6a);var l=$APP.C.A(d,V6a),n=$APP.C.A(d,$APP.ZP);d=$APP.C.A(d,W6a);return $APP.k(l)?(l=$APP.fd(l),$APP.k(d)?(d=$APP.I,b=$APP.N.A(g,$APP.Yd(b,n)),g=Q6a.j($APP.ed(a)),b=g.A?g.A(l,b):g.call(null,l,b),c=new $APP.H(null,2,5,d,[b,$APP.k(c)?$APP.rg.B(c,W6a,!0):c],null)):c=new $APP.H(null,2,5,$APP.I,[l,c],null),$APP.z(c,$APP.ed(a))):null};
X6a=function(a){for(;;){if($APP.Uc.A($APP.qq,a.j?a.j(1):a.call(null,1)))return XP(a);var b=aQ(a);if($APP.k(b))a=b;else return XP(a)}};bQ=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);c=$APP.qe(c);var d=$APP.C.A(c,$P),g=$APP.C.A(c,$APP.ZP),l=$APP.r(g),n=$APP.u(l);l=$APP.w(l);return $APP.k($APP.k(c)?g:c)?$APP.z(new $APP.H(null,2,5,$APP.I,[n,$APP.rg.C(c,$P,$APP.Vd.A(d,b),$APP.y([$APP.ZP,l]))],null),$APP.ed(a)):null};
cQ=function(a,b){$APP.x.B(a,0,null);var c=$APP.x.B(a,1,null);return $APP.z(new $APP.H(null,2,5,$APP.I,[b,$APP.rg.B(c,W6a,!0)],null),$APP.ed(a))};Y6a=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=2<b.length?new $APP.Bc(b.slice(2),0,null):null;c=arguments[0];return cQ(c,$APP.Je.B(arguments[1],XP(c),b))};
dQ=function(a){if($APP.Uc.A($APP.qq,a.j?a.j(1):a.call(null,1)))return a;var b=YP(a);if($APP.k(b))if($APP.k(YP(a))){b=$APP.x.B(a,0,null);var c=$APP.x.B(a,1,null);if($APP.k(YP(a))){var d=XP(a);var g=P6a.j($APP.ed(a));d=g.j?g.j(d):g.call(null,d)}else throw"called children on a leaf node";var l=$APP.r(d);g=$APP.u(l);l=$APP.w(l);b=$APP.k(d)?$APP.z(new $APP.H(null,2,5,$APP.I,[g,new $APP.f(null,4,[$P,$APP.sf,V6a,$APP.k(c)?$APP.Vd.A(V6a.j(c),b):new $APP.H(null,1,5,$APP.I,[b],null),U6a,c,$APP.ZP,l],null)],
null),$APP.ed(a)):null}else b=null;if($APP.k(b))return b;b=bQ(a);if($APP.k(b))return b;for(;;)if($APP.k(aQ(a))){b=bQ(aQ(a));if($APP.k(b))return b;a=aQ(a)}else return new $APP.H(null,2,5,$APP.I,[XP(a),$APP.qq],null)};Z6a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.Tc(a);return $APP.Uc.A(a,1)&&CF(b)?["1/",$APP.m.j(b)].join(""):$APP.Uc.A(a,2)&&CF(b)&&CF(c)?[$APP.m.j(b),"/",$APP.m.j(c)].join(""):null};
m7a=function(a){function b(Z,fa){return l(Z)>l(fa)}function c(Z){var fa=$APP.k(Q)?$6a(XP(Z)):Q;return $APP.k(fa)?cQ(Z,fa):Z}function d(Z,fa){return $APP.k(Z)?J.j?J.j(fa):J.call(null,fa):fa}function g(Z){var fa=G.j?G.j(Z):G.call(null,Z);return $APP.k(fa)?fa:Z}function l(Z){for(;;){var fa=O.j?O.j(Z):O.call(null,Z);if($APP.k(fa))return fa;if($APP.td(Z))if($APP.Uc.A(3,$APP.Tc(Z))&&$APP.Uc.A(DJ,$APP.u(Z)))Z=$APP.Xc(Z);else return $APP.Uc.A($APP.Rw,$APP.u(Z))?(Z=cH,O.j?O.j(Z):O.call(null,Z)):O.j?O.j(eQ):
O.call(null,eQ);else return Z instanceof $APP.q?O.j?O.j(eQ):O.call(null,eQ):0}}function n(Z,fa,ha){return $APP.Uc.A($APP.Fv,Z)?$APP.m.j(fa):$APP.Uc.A($APP.Ev,Z)?$APP.m.j(fa):$APP.Uc.A(fQ,Z)?$APP.Uc.A(ha,$APP.Fv)?new $APP.f(null,2,[a7a,b7a,c7a,fa],null):["- ",$APP.m.j(fa)].join(""):$APP.Uc.A($APP.rj,Z)?CF(fa)?["1/",$APP.m.j(fa)].join(""):["1 / ",$APP.m.j(fa)].join(""):[$APP.m.j(Z)," ",$APP.m.j(fa)].join("")}function p(Z){var fa=XP(Z);fa=d7a.j?d7a.j(fa):d7a.call(null,fa);return Z===fa?Z:cQ(Z,fa)}a=
$APP.qe(a);var v=$APP.C.B(a,e7a," * "),t=$APP.C.B(a,f7a,$APP.F),A=$APP.C.B(a,g7a,$APP.F),B=$APP.C.A(a,h7a),G=$APP.C.B(a,i7a,$APP.F),J=$APP.C.B(a,j7a,function(Z){return["(",$APP.m.j(Z),")"].join("")}),O=$APP.C.A(a,k7a),Q=$APP.C.B(a,l7a,!1),W=function ha(fa){if($APP.k(YP(fa))){var ja=dQ(c(p(fa))),ta=function(){for(var Y=bQ(ja);;){Y=cQ(Y,ha(Y));var ea=bQ(Y);if($APP.k(ea))Y=ea;else return aQ(Y)}}();fa=XP(ta);fa=$APP.r(fa);var ua=$APP.u(fa),ca=$APP.w(fa),V=function(){var Y=aQ(ta);if($APP.k(Y)){Y=$APP.x.B(ta,
0,null);var ea=$APP.x.B(ta,1,null);ea=$APP.qe(ea);var ya=$APP.C.A(ea,$P),wa=$APP.C.A(ea,$APP.ZP);Y=$APP.k($APP.k(ea)?$APP.r(ya):ea)?$APP.z(new $APP.H(null,2,5,$APP.I,[$APP.u(ya),$APP.rg.C(ea,$P,$APP.sf,$APP.y([$APP.ZP,$APP.N.C($APP.Fc(ya),new $APP.H(null,1,5,$APP.I,[Y],null),$APP.y([wa]))]))],null),$APP.ed(ta)):ta;Y=XP(Y)}return Y}();return $APP.k(A.j?A.j(ua):A.call(null,ua))?d(function(){var Y=A.j?A.j(V):A.call(null,V);if($APP.k(Y)){Y=$APP.eb(b(ua,V));if($APP.k(Y)){Y=$APP.Uc.A(ua,$APP.Ev)&&$APP.Uc.A(V,
fQ);if(!Y){Y=$APP.x.B(ca,0,null);var ea=$APP.x.B(ca,1,null);Y=$APP.Uc.A($APP.rj,ua)&&CF(Y)&&(null==ea||CF(ea))}Y=$APP.eb(Y)}return Y}return Y}(),function(){var Y=function(){var wa=t.j?t.j(ua):t.call(null,ua);return $APP.k(wa)?wa.j?wa.j(ca):wa.call(null,ca):null}();if($APP.k(Y))return Y;if($APP.Uc.A($APP.Tc(ca),1))return n(ua,$APP.u(ca),V);if($APP.Uc.A(ua,$APP.Fv)){Y=$APP.Vg.A(function(wa){var Ba=$APP.qe(wa),Qa=$APP.C.A(Ba,a7a);Ba=$APP.C.A(Ba,c7a);return $APP.k(Qa)?new $APP.H(null,2,5,$APP.I,[$APP.Uc.A(Qa,
b7a)?"-":"+",Ba],null):new $APP.H(null,2,5,$APP.I,["+",wa],null)},ca);Y=$APP.r(Y);var ea=$APP.u(Y),ya=$APP.w(Y);Y=$APP.Yd($APP.Uc.A($APP.u(ea),"+")?$APP.oi.A(ea,1):$APP.Uc.A($APP.u(ea),"-")?$APP.rg.B(ea,0,"- "):ea,function(){return function Qa(Ba){return new $APP.de(null,function(){for(;;){var Va=$APP.r(Ba);if(Va){if($APP.pd(Va)){var cb=$APP.lc(Va),pb=$APP.Tc(cb),rb=$APP.fe(pb);a:for(var yb=0;;)if(yb<pb){var Ub=$APP.bd(cb,yb),Db=$APP.x.B(Ub,0,null);Ub=$APP.x.B(Ub,1,null);$APP.je(rb,new $APP.H(null,
2,5,$APP.I,[[" ",$APP.m.j(Db)," "].join(""),Ub],null));yb+=1}else{cb=!0;break a}return cb?$APP.ie($APP.ke(rb),Qa($APP.mc(Va))):$APP.ie($APP.ke(rb),null)}cb=$APP.u(Va);rb=$APP.x.B(cb,0,null);cb=$APP.x.B(cb,1,null);return $APP.Yd(new $APP.H(null,2,5,$APP.I,[[" ",$APP.m.j(rb)," "].join(""),cb],null),Qa($APP.Fc(Va)))}return null}},null,null)}(ya)}());return $APP.Vs.B($APP.eh,$APP.m,Y)}Y=$APP.Uc.A($APP.Ev,ua)?$APP.k(v)?v:" * ":$APP.Uc.A(DJ,ua)?"^":[" ",$APP.m.j(ua)," "].join("");return $APP.Vs.B($APP.Ri.j(Y),
$APP.m,ca)}()):d(function(){if($APP.k(V)){var Y=A.j?A.j(V):A.call(null,V);return $APP.k(Y)?$APP.eb(b(ua,V)):Y}return V}(),function(){var Y=function(){var ea=t.j?t.j(ua):t.call(null,ua);return $APP.k(ea)?(ea=t.j?t.j(ua):t.call(null,ua),ea.j?ea.j(ca):ea.call(null,ca)):ea}();return $APP.k(Y)?Y:[$APP.m.j(d(function(){var ea=YP(ja);return $APP.k(ea)?b(eQ,XP(dQ(ja))):ea}(),g(ha(dQ(ta))))),$APP.m.j(d(function(){var ea=$APP.eb(b(ua,eQ));return $APP.k(ea)?ea:(ea=1<$APP.Tc(ca))?ea:YP(bQ(ja))}(),$APP.Il.A(", ",
ca)))].join("")}())}fa=XP(fa);var da=$APP.k(B)?B.j?B.j(fa):B.call(null,fa):B;return $APP.k(da)?da:fa};return function(fa){fa=W(S6a(aG.j(fa)));return"string"===typeof fa?fa:$APP.m.j(fa)}};n7a=function(a,b){return $APP.Je.A($APP.m,$APP.Vg.A(function(c){c=parseInt(c);return b.j?b.j(c):b.call(null,c)},$APP.m.j(a)))};gQ=function(a){return["{",$APP.m.j(a),"}"].join("")};hQ=function(a){return"string"===typeof a&&$APP.Uc.A($APP.Tc(a),1)?a:gQ(a)};o7a=function(a){return["\\displaystyle{",$APP.m.j(a),"}"].join("")};
p7a=function(a,b){return $APP.Fl.B($APP.wr,a,b)};iQ=function(a,b){return $APP.Fl.B($APP.Ck,a,b)};jQ=function(a,b){return $APP.Fl.A(function(c){return a*c},b)};s7a=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,q7a,.05),d=$APP.C.B(b,r7a,2.5E-4),g=$APP.tf(a),l=c+1;return $APP.Lf.A(new $APP.H(null,1,5,$APP.I,[g],null),$APP.gp.A(function(n,p){return $APP.rg.B(g,n,0===p?d:l*p)},g))};
t7a=function(a){var b=$APP.x.B(a,0,null);a=$APP.kd(b)?$APP.bf.C(function(c){return iQ(c,b)},$APP.y([a])):$APP.Vg.A(function(c){return c-b},a);return $APP.Id.A($APP.Gj,$APP.Vg.A(kQ,a))};u7a=function(a){var b=$APP.kh.j(0);return new $APP.H(null,2,5,$APP.I,[b,function(c){$APP.lh.A(b,$APP.Lc);return a.j?a.j(c):a.call(null,c)}],null)};v7a=function(a,b,c){c=$APP.Ts.A($APP.Pi.A($APP.x,b),$APP.Hj.A(0,c+1));a=$APP.Fl.A(a,c);b=$APP.Fl.A(b,c);return new $APP.H(null,2,5,$APP.I,[a,b],null)};
B7a=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,w7a,!0);return $APP.Ni.C($APP.y([$APP.k(c)?new $APP.f(null,4,[x7a,1,y7a,1+2/a,z7a,.75-1/(2*a),A7a,1-1/a],null):new $APP.f(null,4,[x7a,1,y7a,2,z7a,.5,A7a,.5],null),$APP.sg(b,new $APP.H(null,4,5,$APP.I,[x7a,y7a,z7a,A7a],null))]))};
C7a=function(a,b,c){function d(G){G=$APP.r(G);var J=$APP.u(G);G=$APP.w(G);G=$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[J],null),$APP.Vg.A(function(O){return p7a(J,jQ(A,iQ(O,J)))},G));return v7a(G,$APP.Fl.A(a,G),b)}function g(G,J){return p7a(jQ(1-B,J),jQ(B,$APP.fd(G)))}function l(G,J){return iQ(jQ(B*v+1,J),jQ(B*v,$APP.fd(G)))}function n(G,J){return iQ(jQ(v*t+1,J),jQ(v*t,$APP.fd(G)))}function p(G,J){return iQ(jQ(v+1,J),jQ(v,$APP.fd(G)))}c=B7a(b,c);c=$APP.qe(c);var v=$APP.C.A(c,x7a),t=$APP.C.A(c,y7a),A=$APP.C.A(c,
A7a),B=$APP.C.A(c,z7a);return function(G,J){var O=$APP.x.B(J,0,null);return function(){function Q(ta,ua){ta=$APP.Vd.A($APP.gd(G),ta);ua=$APP.Vd.A($APP.gd(J),ua);return v7a(ta,ua,b)}var W=$APP.fd(J),Z=$APP.fd($APP.gd(J)),fa=jQ(1/b,$APP.Id.A(p7a,$APP.gd(G))),ha=p(G,fa),ja=a.j?a.j(ha):a.call(null,ha);if(ja<O)return W=n(G,fa),Z=a.j?a.j(W):a.call(null,W),Z<ja?Q(W,Z):Q(ha,ja);if(ja<Z)return Q(ha,ja);if(ja<W)return W=l(G,fa),ha=a.j?a.j(W):a.call(null,W),ha<=ja?Q(W,ha):d(G);ja=g(G,fa);ha=a.j?a.j(ja):a.call(null,
ja);return ha<W?Q(ja,ha):d(G)}()}};F7a=function(a){a=$APP.qe(a);var b=$APP.C.B(a,D7a,1E-4),c=$APP.C.B(a,E7a,1E-4);return function(d,g){return t7a(d)<=b&&t7a(g)<=c}};G7a=function(a,b,c){var d=$APP.qe(c);c=$APP.C.A(d,lQ);d=$APP.C.A(d,mQ);var g=$APP.k(c)?c:200*b,l=$APP.k(d)?d:200*b;return function(n){return n>g||$APP.Fb(a)>l}};
H7a=function(a,b,c){var d=$APP.qe(c);c=$APP.C.A(d,$APP.Uw);c=$APP.k(c)?c:$APP.Le(null);var g=$APP.Tc(b),l=u7a(a);a=$APP.x.B(l,0,null);var n=$APP.x.B(l,1,null);l=C7a(n,g,d);var p=F7a(d),v=G7a(a,g,d);b=s7a(b,d);d=$APP.Fl.A(n,b);b=v7a(b,d,g);g=$APP.x.B(b,0,null);$APP.x.B(g,0,null);g=$APP.x.B(b,1,null);$APP.x.B(g,0,null);for(n=0;;){d=b;g=$APP.x.B(d,0,null);b=$APP.x.B(g,0,null);var t=$APP.x.B(d,1,null);d=$APP.x.B(t,0,null);c.B?c.B(n,b,d):c.call(null,n,b,d);var A=p(g,t);var B=A;B=$APP.k(B)?B:v(n);if($APP.k(B))return new $APP.f(null,
5,[nQ,b,$APP.fw,d,oQ,A,pQ,n,qQ,$APP.Fb(a)],null);b=l.A?l.A(g,t):l.call(null,g,t);n=g=n+1}};rQ=function(a,b){return I7a*a+J7a*b};sQ=function(a,b){return a+K7a*(a-b)};
L7a=function(a,b,c,d,g){var l=$APP.x.B(b,0,null),n=$APP.x.B(c,0,null),p=$APP.x.B(c,1,null),v=$APP.x.B(d,0,null),t=$APP.x.B(d,1,null),A=$APP.x.B(g,0,null);return p<t?function(){var B=rQ(v,l);return B<n?new $APP.H(null,4,5,$APP.I,[b,new $APP.H(null,2,5,$APP.I,[B,a.j?a.j(B):a.call(null,B)],null),c,d],null):new $APP.H(null,4,5,$APP.I,[b,c,new $APP.H(null,2,5,$APP.I,[B,a.j?a.j(B):a.call(null,B)],null),d],null)}():function(){var B=rQ(n,A);return v<B?new $APP.H(null,4,5,$APP.I,[c,d,new $APP.H(null,2,5,$APP.I,
[B,a.j?a.j(B):a.call(null,B)],null),g],null):new $APP.H(null,4,5,$APP.I,[c,new $APP.H(null,2,5,$APP.I,[B,a.j?a.j(B):a.call(null,B)],null),d,g],null)}()};M7a=function(a){var b=IF(a);return function(c,d,g,l){$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);return b(c>l?c:l,d<g?d:g)}};
N7a=function(a){var b=IF(a);return function(c,d,g,l){d=$APP.x.B(c,0,null);$APP.x.B(c,1,null);c=$APP.x.B(l,0,null);$APP.x.B(l,1,null);return b(d,c)}};O7a=function(a){return function(b,c,d,g,l){return a<l}};
Q7a=function(a){a=$APP.qe(a);var b=$APP.C.A(a,oQ),c=$APP.C.A(a,E7a),d=$APP.C.A(a,P7a);return function(){function g(n){var p=null;if(0<arguments.length){p=0;for(var v=Array(arguments.length-0);p<v.length;)v[p]=arguments[p+0],++p;p=new $APP.Bc(v,0,null)}return l.call(this,p)}function l(n){return $APP.He(function(p){return $APP.Je.A(p,n)},new $APP.H(null,3,5,$APP.I,[$APP.k(b)?b:$APP.Le(!1),N7a(d),M7a(c)],null))}g.G=0;g.K=function(n){n=$APP.r(n);return l(n)};g.C=l;return g}()};
S7a=function(a){a=$APP.qe(a);var b=$APP.C.A(a,lQ),c=$APP.C.A(a,mQ),d=$APP.C.A(a,R7a);return function(){function g(n){var p=null;if(0<arguments.length){p=0;for(var v=Array(arguments.length-0);p<v.length;)v[p]=arguments[p+0],++p;p=new $APP.Bc(v,0,null)}return l.call(this,p)}function l(n){return $APP.He(function(p){return $APP.Je.A(p,n)},new $APP.H(null,2,5,$APP.I,[function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=
new $APP.Bc(B,0,null)}return v.call(this,A)}function v(){return $APP.Fb(d)>c}p.G=0;p.K=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}(),O7a(b)],null))}g.G=0;g.K=function(n){n=$APP.r(n);return l(n)};g.C=l;return g}()};
T7a=function(a,b,c){var d=a.j?a.j(b):a.call(null,b);a=a.j?a.j(c):a.call(null,c);return d<a?new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[b,d],null),new $APP.H(null,2,5,$APP.I,[c,a],null)],null):new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[c,a],null),new $APP.H(null,2,5,$APP.I,[b,d],null)],null)};
U7a=function(a,b,c){var d=$APP.x.B(a,0,null),g=$APP.x.B(a,1,null);a=$APP.x.B(b,0,null);var l=$APP.x.B(b,1,null);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);c=(a-d)*(l-c);g=(a-b)*(l-g);d=(a-b)*g-(a-d)*c;a=2*(g-c);return 0<a?new $APP.H(null,2,5,$APP.I,[PF.j(d),a],null):new $APP.H(null,2,5,$APP.I,[d,hG.j(a)],null)};V7a=function(a,b,c){var d=$APP.x.B(b,0,null);b=U7a(a,b,c);a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return d+a/(2E-21>b?2E-21:b)};
X7a=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,W7a,110);return function(d,g,l){var n=$APP.x.B(g,0,null),p=$APP.x.B(g,1,null),v=$APP.x.B(l,0,null),t=$APP.x.B(l,1,null),A=n+c*(v-n),B=V7a(d,g,l);if(n<=B&&B<=v){A=a.j?a.j(B):a.call(null,B);if(A<t)return new $APP.H(null,3,5,$APP.I,[g,new $APP.H(null,2,5,$APP.I,[B,A],null),l],null);if(A>p)return new $APP.H(null,3,5,$APP.I,[d,g,new $APP.H(null,2,5,$APP.I,[B,A],null)],null);d=sQ(v,n);return new $APP.H(null,3,5,$APP.I,[g,l,new $APP.H(null,2,5,$APP.I,[d,a.j?
a.j(d):a.call(null,d)],null)],null)}if(v<=B&&B<=A)return A=a.j?a.j(B):a.call(null,B),A<t?(d=sQ(B,v),new $APP.H(null,3,5,$APP.I,[l,new $APP.H(null,2,5,$APP.I,[B,A],null),new $APP.H(null,2,5,$APP.I,[d,a.j?a.j(d):a.call(null,d)],null)],null)):new $APP.H(null,3,5,$APP.I,[g,l,new $APP.H(null,2,5,$APP.I,[B,A],null)],null);if(v<=A&&A<=B)return new $APP.H(null,3,5,$APP.I,[g,l,new $APP.H(null,2,5,$APP.I,[A,a.j?a.j(A):a.call(null,A)],null)],null);d=sQ(v,n);return new $APP.H(null,3,5,$APP.I,[g,l,new $APP.H(null,
2,5,$APP.I,[d,a.j?a.j(d):a.call(null,d)],null)],null)}};Y7a=function(a,b,c){a=b>=.5*(a+c)?a-b:c-b;return new $APP.H(null,2,5,$APP.I,[a,I7a*a],null)};Z7a=function(a,b,c,d){a=$APP.Hl.A(PF,a);return $APP.Fj.B(tQ.M(a,b,c,d),$APP.fw,PF)};
$7a=function(a){var b=new $APP.ug(null,new $APP.f(null,2,[$APP.Ev,"null",$APP.Fv,"null"],null),null);return function g(d){if($APP.td(d)){var l=$APP.u(d);l=b.j?b.j(l):b.call(null,l);if($APP.eb(l)||4>$APP.Tc(d))return $APP.Vg.A(g,d);l=$APP.r(d);d=$APP.u(l);l=$APP.w(l);return $APP.Id.A($APP.Pi.A($APP.M,d),$APP.Vg.A(g,l))}return d}(a)};
a8a=function(){function a(g){var l=$APP.Fb(c);l=l.j?l.j(g):l.call(null,g);if($APP.k(l))return l;l=$APP.lh.A(b,$APP.Lc);$APP.lh.M(c,$APP.rg,g,l);return l}var b=$APP.kh.j(-1),c=$APP.kh.j($APP.F),d=function n(l){return $APP.td(l)?a($APP.Lf.B(new $APP.H(null,1,5,$APP.I,[$APP.u(l)],null),$APP.Vg.j(n),$APP.w(l))):"number"===typeof l?a(l):l};return function(){function l(v){return d($7a(v))}function n(){return $APP.Vg.A($APP.u,$APP.Ts.A($APP.Xc,$APP.Fb(c)))}var p=null;p=function(v){switch(arguments.length){case 0:return n.call(this);
case 1:return l.call(this,v)}throw Error("Invalid arity: "+arguments.length);};p.J=n;p.j=l;return p}()};
d8a=function(a,b,c){function d(){var v=$APP.r(a);$APP.u(v);v=$APP.w(v);var t=$APP.u(v),A=$APP.w(v),B=$APP.Dj.j(function(){return function O(J){return new $APP.de(null,function(){for(;;){var Q=$APP.r(J);if(Q){if($APP.pd(Q)){var W=$APP.lc(Q),Z=$APP.Tc(W),fa=$APP.fe(Z);a:for(var ha=0;;)if(ha<Z){var ja=$APP.bd(W,ha);$APP.x.B(ja,0,null);var ta=$APP.x.B(ja,1,null);ja=$APP.x.B(ja,2,null);$APP.je(fa,new $APP.H(null,2,5,$APP.I,[ta,p.j?p.j(ja):p.call(null,ja)],null));ha+=1}else{W=!0;break a}return W?$APP.ie($APP.ke(fa),
O($APP.mc(Q))):$APP.ie($APP.ke(fa),null)}W=$APP.u(Q);$APP.x.B(W,0,null);fa=$APP.x.B(W,1,null);W=$APP.x.B(W,2,null);return $APP.Yd(new $APP.H(null,2,5,$APP.I,[fa,p.j?p.j(W):p.call(null,W)],null),O($APP.Fc(Q)))}return null}},null,null)}(A)}());return l(function(G,J){var O=$APP.T.j($APP.r($APP.N.C(new $APP.D(null,b8a,null,1,null),new $APP.D(null,t,null,1,null),$APP.y([$APP.Vg.A(function(Q){var W=$APP.x.B(Q,0,null);Q=$APP.x.B(Q,1,null);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Dv,null,1,null),
new $APP.D(null,W,null,1,null),$APP.y([new $APP.D(null,$APP.xd(Q)?G.j?G.j(Q):G.call(null,Q):Q,null,1,null)]))))},B)]))));J=$APP.Vg.B($APP.ns,G,J);return b.A?b.A(O,J):b.call(null,O,J)})}function g(){p.j?p.j(a):p.call(null,a);return l(function(v,t){var A=$APP.$c(v);v=$APP.Vg.B($APP.ns,v,t);return b.A?b.A(A,v):b.call(null,A,v)})}function l(v){function t(J){return $APP.xd(J)?G.j?G.j(J):G.call(null,J):J}var A=p.J?p.J():p.call(null),B=$APP.Tc(A),G=$APP.Lf.A($APP.sf,$APP.Nn.A(B,n));B=function(){return function Q(O){return new $APP.de(null,
function(){for(;;){var W=$APP.r(O);if(W){if($APP.pd(W)){var Z=$APP.lc(W),fa=$APP.Tc(Z),ha=$APP.fe(fa);a:for(var ja=0;;)if(ja<fa){var ta=$APP.bd(Z,ja);$APP.je(ha,$APP.od(ta)?$APP.Kn.A($APP.u(ta),$APP.Vg.A(t,$APP.w(ta))):ta);ja+=1}else{Z=!0;break a}return Z?$APP.ie($APP.ke(ha),Q($APP.mc(W))):$APP.ie($APP.ke(ha),null)}ha=$APP.u(W);return $APP.Yd($APP.od(ha)?$APP.Kn.A($APP.u(ha),$APP.Vg.A(t,$APP.w(ha))):ha,Q($APP.Fc(W)))}return null}},null,null)}(A)}();return v.A?v.A(G,B):v.call(null,G,B)}c=$APP.qe(c);
var n=$APP.C.B(c,c8a,DM.A(8,"_")),p=a8a();return $APP.kd(a)?$APP.Uc.A($APP.u(a),b8a)?d():g():b.A?b.A(a,null):b.call(null,a,null)};f8a=function(a){return $APP.yo(function(b){if(DF(b))return xD(b);if($APP.kd(b)){var c=$APP.r(b),d=$APP.u(c);c=$APP.w(c);var g=$APP.Ge($APP.Baa,c);d=g?e8a.j?e8a.j(d):e8a.call(null,d):g;return $APP.k(d)?xD($APP.Je.A($APP.Dy.j(d),c)):b}return b},a)};
h8a=function(a){var b=uQ.j?uQ.j(a):uQ.call(null,a);if($APP.k(b))return b;throw $APP.Zi.A(["Invalid compilation mode supplied: ",$APP.m.j(a),". Please supply (or bind to `*mode*`) one of ",$APP.m.j(uQ)].join(""),new $APP.f(null,2,[$APP.fq,a,g8a,uQ],null));};i8a=function(a){return $APP.Fl.A(function(b){return $APP.z(b,new $APP.f(null,1,[$APP.sj,$APP.gqa],null))},$APP.Nn.A(3,a))};
k8a=function(a,b){a=$APP.qe(a);var c=$APP.C.A(a,$APP.vQ),d=$APP.C.A(a,$APP.dm),g=$APP.C.A(a,j8a),l=function(){switch(c instanceof $APP.E?c.ga:null){case "primitive":return i8a(function(){return b.j?b.j("a"):b.call(null,"a")});case "structure":return new $APP.H(null,1,5,$APP.I,[$APP.Lf.A($APP.sf,g)],null);case "native":return g;default:throw $APP.Zi.A("Invalid calling convention supplied",new $APP.f(null,1,[$APP.vQ,c],null));}}();return $APP.rg.B(a,wQ,$APP.k($APP.k(d)?$APP.qg.A(c,$APP.xQ):d)?$APP.Vd.A(l,
$APP.Lf.A($APP.sf,d)):l)};l8a=function(a,b){return d8a($APP.em.j(a),function(c,d){return $APP.rg.B(a,$APP.em,$APP.r(d)?yQ(c,d):c)},new $APP.f(null,1,[c8a,b],null))};
n8a=function(a){function b(n,p){return $APP.gp.A(function(v,t){return new $APP.H(null,2,5,$APP.I,[t,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Eu,null,1,null),new $APP.D(null,n,null,1,null),$APP.y([new $APP.D(null,v,null,1,null)]))))],null)},p)}a=$APP.qe(a);var c=$APP.C.A(a,wQ),d=$APP.C.A(a,$APP.vQ),g=$APP.C.A(a,j8a),l=$APP.C.A(a,$APP.dm);switch(d instanceof $APP.E?d.ga:null){case "primitive":return d=$APP.x.B(c,0,null),$APP.x.B(c,1,null),c=$APP.x.B(c,2,null),$APP.Fj.S(a,$APP.em,yQ,$APP.N.A(b(d,
$APP.ef(g)),b(c,l)),m8a);default:return a}};
o8a=function(a){function b(l,n){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Dv,null,1,null),new $APP.D(null,l,null,1,null),$APP.y([new $APP.D(null,n,null,1,null)]))))}function c(l){var n=$APP.kd(l);return n?(l=$APP.u(l),n=new $APP.ug(null,new $APP.f(null,3,[wP,"null",$APP.su,"null",xP,"null"],null),null),n.j?n.j(l):n.call(null,l)):n}a=$APP.qe(a);var d=$APP.C.A(a,$APP.vQ),g=$APP.C.A(a,wQ);return $APP.Uc.A(d,$APP.xQ)?$APP.Fj.B(a,$APP.em,function(l){if($APP.k(c(l))){var n=$APP.x.A(g,1);l=$APP.sn.A(c,
$APP.Fc($APP.cf(c,$APP.Fc,l)));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,b8a,null,1,null),new $APP.D(null,n,null,1,null),$APP.y([$APP.gp.A(b,l)]))))}return l}):a};p8a=function(a){return $APP.yo(function(b){return $APP.kd(b)?$APP.r(b)?["[",$APP.Il.A(", ",b),"]"].join(""):"_":$APP.m.j(b)},a)};q8a=function(a){return $APP.jka(XNa(),a)};
s8a=function(a){var b=$APP.qe(a);a=$APP.C.A(b,wQ);b=$APP.C.A(b,$APP.em);return $APP.zo(r8a,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Yx,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(a)))),null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))))};
u8a=function(a){var b=$APP.qe(a);a=$APP.C.A(b,wQ);b=$APP.C.A(b,$APP.em);a=$APP.Fl.A(p8a,a);var c=$APP.kh.j($APP.sf);(function(d){if($APP.k(function(){var J=YP(d);return $APP.k(J)?$APP.Uc.A(XP(dQ(d)),b8a):J}())){var g=dQ(dQ(d)),l=XP(g);if(!(l instanceof $APP.q))throw $APP.Zi.A("Expecting a symbol (referring to a primitive array)",new $APP.f(null,1,[t8a,l],null));for(var n=$APP.r(T6a(g)),p=null,v=0,t=0;;)if(t<v){var A=p.aa(null,t),B=$APP.x.B(A,0,null),G=$APP.x.B(A,1,null);A=$APP.x.B(A,2,null);if(!$APP.Uc.A(B,
$APP.Dv))throw $APP.Zi.A("Expecting an aset statement",new $APP.f(null,1,[t8a,B],null));$APP.lh.B(c,$APP.Vd,["  ",$APP.m.j(l),"[",$APP.m.j(G),"] \x3d ",$APP.m.j(zQ.j?zQ.j(A):zQ.call(null,A)),";"].join(""));t+=1}else if(n=$APP.r(n)){if($APP.pd(n))v=$APP.lc(n),n=$APP.mc(n),p=v,v=$APP.Tc(v);else{t=$APP.u(n);p=$APP.x.B(t,0,null);v=$APP.x.B(t,1,null);t=$APP.x.B(t,2,null);if(!$APP.Uc.A(p,$APP.Dv))throw $APP.Zi.A("Expecting an aset statement",new $APP.f(null,1,[t8a,p],null));$APP.lh.B(c,$APP.Vd,["  ",$APP.m.j(l),
"[",$APP.m.j(v),"] \x3d ",$APP.m.j(zQ.j?zQ.j(t):zQ.call(null,t)),";"].join(""));n=$APP.w(n);p=null;v=0}t=0}else break;return dQ(g)}return $APP.lh.B(c,$APP.Vd,["  return ",$APP.m.j(function(){var J=XP(d);return zQ.j?zQ.j(J):zQ.call(null,J)}()),";"].join(""))})(function(d){var g=YP(d);g=$APP.k(g)?$APP.Uc.A(XP(dQ(d)),$APP.fm):g;if($APP.k(g)){d=dQ(dQ(d));g=$APP.r($APP.Jl.A(2,XP(d)));for(var l=null,n=0,p=0;;)if(p<n){var v=l.aa(null,p),t=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);$APP.td(v)&&$APP.Uc.A($APP.u(v),
$APP.Eu)?$APP.lh.B(c,$APP.Vd,["  const ",$APP.m.j(t)," \x3d ",$APP.m.j($APP.x.A(v,1)),"[",$APP.m.j($APP.x.A(v,2)),"];"].join("")):$APP.lh.B(c,$APP.Vd,["  const ",$APP.m.j(t)," \x3d ",$APP.m.j(zQ.j?zQ.j(v):zQ.call(null,v)),";"].join(""));p+=1}else if(g=$APP.r(g))$APP.pd(g)?(n=$APP.lc(g),g=$APP.mc(g),l=n,n=$APP.Tc(n)):(n=$APP.u(g),l=$APP.x.B(n,0,null),n=$APP.x.B(n,1,null),$APP.td(n)&&$APP.Uc.A($APP.u(n),$APP.Eu)?$APP.lh.B(c,$APP.Vd,["  const ",$APP.m.j(l)," \x3d ",$APP.m.j($APP.x.A(n,1)),"[",$APP.m.j($APP.x.A(n,
2)),"];"].join("")):$APP.lh.B(c,$APP.Vd,["  const ",$APP.m.j(l)," \x3d ",$APP.m.j(zQ.j?zQ.j(n):zQ.call(null,n)),";"].join("")),g=$APP.w(g),l=null,n=0),p=0;else break;return dQ(d)}return d}(S6a(b)));return $APP.Vd.A(a,$APP.Il.A("\n",$APP.Fb(c)))};v8a=function(a){var b=$APP.Je.A(Function,u8a(a));return $APP.Uc.A($APP.vQ.j(a),$APP.xQ)?b:$APP.Hl.A($APP.eu,b)};w8a=function(a){return q8a(s8a(a))};x8a=function(a,b){return function g(d){return VK(d)?$APP.Fl.A(g,d):b.j?b.j($APP.SP):b.call(null,$APP.SP)}(a)};
y8a=function(a){$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,2,5,$APP.I,[AQ,a],null)};z8a=function(a){var b=$APP.x.B(a,0,null);$APP.x.B(a,1,null);return new $APP.H(null,2,5,$APP.I,[b,AQ],null)};A8a=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,2,5,$APP.I,[a,b],null)};C8a=function(a){var b=$APP.rg.B;var c=$APP.C.B(a,$APP.BQ,B8a);c=A8a.j?A8a.j(c):A8a.call(null,c);return b.call($APP.rg,a,$APP.BQ,c)};
D8a=function(a,b,c){var d=Math.abs(a)+Math.abs(b);return d<=c||Math.abs(b-a)<=c*d};
EQ=function(a,b){return function(){function c(l,n,p,v){v=$APP.qe(v);var t=$APP.C.B(v,E8a,1E-14);return D8a(n,p,t)?($G($APP.Wu,"emmy.numerical.quadrature.common",136,new $APP.bh(function(){return new $APP.H(null,3,5,$APP.I,["Integrating narrow slice: ",n,p],null)},null),2009675594),new $APP.f(null,3,[oQ,!0,CQ,1,nQ,a.B?a.B(l,n,p):a.call(null,l,n,p)],null)):DQ.A(b.M?b.M(l,n,p,v):b.call(null,l,n,p,v),v)}function d(l,n,p){return g.M(l,n,p,$APP.F)}var g=null;g=function(l,n,p,v){switch(arguments.length){case 3:return d.call(this,
l,n,p);case 4:return c.call(this,l,n,p,v)}throw Error("Invalid arity: "+arguments.length);};g.B=d;g.M=c;return g}()};F8a=function(a,b,c){var d=Math.pow(b,c),g=d-1;return $APP.Vg.B(function(l,n){return(d*n-l)/g},a,$APP.Fc(a))};G8a=function(a,b,c){return $APP.Hg.A($APP.r,$APP.Vg.A($APP.u,$APP.af(function(d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var l=$APP.r(d);d=$APP.u(l);l=$APP.w(l);return new $APP.H(null,2,5,$APP.I,[F8a(g,b,d),l],null)},new $APP.H(null,2,5,$APP.I,[a,c],null))))};
H8a=function(a,b,c){return function(d){d=$APP.N.A($APP.Hj.B(b,c,(c-b)/d),new $APP.H(null,1,5,$APP.I,[c],null));return FQ.j($APP.Vg.B(a,d,$APP.Fc(d)))}};I8a=function(a,b,c){var d=c-b;return function(g){var l=d/g;return l*FQ.B(function(n){n=b+n*l;return a.j?a.j(n):a.call(null,n)},0,g)}};J8a=function(a,b,c){var d=c-b;return function(g){var l=d/g,n=b+l;return l*FQ.B(function(p){p=n+p*l;return a.j?a.j(p):a.call(null,p)},0,g)}};
K8a=function(a,b,c){return H8a(function(d,g){var l=a.j?a.j(d):a.call(null,d),n=a.j?a.j(g):a.call(null,g);return(g-d)*(l>n?l:n)},b,c)};L8a=function(a,b,c){return H8a(function(d,g){var l=a.j?a.j(d):a.call(null,d),n=a.j?a.j(g):a.call(null,g);return(g-d)*(l<n?l:n)},b,c)};N8a=function(a,b){var c=$APP.qe(b);b=$APP.C.B(c,$APP.rr,1);c=$APP.C.A(c,M8a);return $APP.k($APP.k(c)?"number"===typeof b:c)?GQ.M(a,2,1,1):a};
O8a=function(a,b,c){var d=c-b;return function(g){var l=d/g,n=b+l/2;return l*FQ.B(function(p){p=n+p*l;return a.j?a.j(p):a.call(null,p)},0,g)}};P8a=function(a,b,c){var d=O8a(a,b,c);return function(g,l){return(g+d(l))/2}};Q8a=function(a,b,c,d){a=a.j?a.j(d):a.call(null,d);c=HQ.A(c,d);return $APP.St.B(b,a,c)};
R8a=function(a,b,c,d){return $APP.Fc($APP.Vg.A($APP.Xc,$APP.St.B(function(g,l){var n=$APP.x.B(g,0,null);$APP.x.B(g,1,null);if(0===$APP.Qd(l,c)){g=$APP.Pd(l,c);var p=$APP.C.A(n,g);g=$APP.k(p)?b.A?b.A(p,g):b.call(null,p,g):a.j?a.j(l):a.call(null,l)}else g=a.j?a.j(l):a.call(null,l);return new $APP.H(null,2,5,$APP.I,[$APP.rg.B(n,l,g),g],null)},new $APP.H(null,2,5,$APP.I,[$APP.F,null],null),d)))};S8a=function(a,b,c,d){var g="number"===typeof d?Q8a:R8a;return g.M?g.M(a,b,c,d):g.call(null,a,b,c,d)};
IQ=function(a,b,c){return QF.A(iG.A(RF.A(c,b),kG.A(a.j?a.j(b):a.call(null,b),a.j?a.j(c):a.call(null,c))),2)};T8a=function(a,b,c){var d=c-b;return function(g){var l=d/g;return l*(((a.j?a.j(b):a.call(null,b))+(a.j?a.j(c):a.call(null,c)))/2+FQ.B(function(n){n=b+n*l;return a.j?a.j(n):a.call(null,n)},1,g))}};U8a=function(a,b,c){c=RF.A(c,b);var d=QF.A(c,2);b=kG.A(b,d);return iG.A(c,a.j?a.j(b):a.call(null,b))};
V8a=function(a,b,c){var d=c-b;return function(g,l){var n=d/l,p=n/6,v=b+p,t=b+5*p;return(g+n*FQ.B(function(A){var B=A*n;return function(){var G=v+B;return a.j?a.j(G):a.call(null,G)}()+function(){var G=t+B;return a.j?a.j(G):a.call(null,G)}()},0,l))/3}};W8a=function(a,b){var c=b-a;return function(d){return c/d}};
$8a=function(a){return function(){function b(g,l,n,p){p=$APP.Ni.C($APP.y([new $APP.f(null,1,[$APP.rr,X8a],null),p]));var v=$APP.qe(p),t=$APP.C.A(v,$APP.rr);p=$APP.Uc.A(Y8a,Z8a.j(v))?zXa(0):H0a(0);t=$APP.Vg.A(function(A){return A*A},$APP.Vg.A(W8a(l,n),t));g=a.M?a.M(g,l,n,v):a.call(null,g,l,n,v);g=$APP.Vg.B($APP.ns,t,g);return p.j?p.j(g):p.call(null,g)}function c(g,l,n){return d.M(g,l,n,new $APP.f(null,1,[$APP.rr,X8a],null))}var d=null;d=function(g,l,n,p){switch(arguments.length){case 3:return c.call(this,
g,l,n);case 4:return b.call(this,g,l,n,p)}throw Error("Invalid arity: "+arguments.length);};d.B=c;d.M=b;return d}()};
a9a=function(a){return function(){function b(g,l,n,p){function v(t){var A=1/t;return(g.j?g.j(A):g.call(null,A))/(t*t)}n=$APP.k(mG.j(n))?0:1/n;l=$APP.k(mG.j(l))?0:1/l;p=C8a(p);return a.M?a.M(v,n,l,p):a.call(null,v,n,l,p)}function c(g,l,n){return d.M(g,l,n,$APP.F)}var d=null;d=function(g,l,n,p){switch(arguments.length){case 3:return c.call(this,g,l,n);case 4:return b.call(this,g,l,n,p)}throw Error("Invalid arity: "+arguments.length);};d.B=c;d.M=b;return d}()};
f9a=function(a){return function(){function b(g,l,n,p){function v(ea,ya,wa,Ba){Ba=$APP.rg.B(t,$APP.BQ,Ba);ea=ea.M?ea.M(g,ya,wa,Ba):ea.call(null,g,ya,wa,Ba);return nQ.j(ea)}p=$APP.Ni.C($APP.y([new $APP.f(null,1,[b9a,1],null),p]));var t=$APP.qe(p),A=$APP.C.A(t,b9a);p=$APP.C.B(t,$APP.BQ,B8a);var B=$APP.Pi.A(v,a),G=$APP.Pi.A(v,a9a(a));A=Math.abs(A);var J=-A,O=new $APP.H(null,2,5,$APP.I,[l,n],null);try{if($APP.od(O)&&2===$APP.Tc(O))try{var Q=$APP.x.A(O,0);if(-Infinity===Q)try{var W=$APP.x.A(O,1);if(-Infinity===
W)return new $APP.f(null,3,[oQ,!0,CQ,0,nQ,0],null);throw JQ;}catch(ea){if(ea instanceof Error){var Z=ea;if(Z===JQ)throw JQ;throw Z;}throw ea;}else throw JQ;}catch(ea){if(ea instanceof Error)if(Z=ea,Z===JQ)try{if(Q=$APP.x.A(O,0),Infinity===Q)try{W=$APP.x.A(O,1);if(Infinity===W)return new $APP.f(null,3,[oQ,!0,CQ,0,nQ,0],null);throw JQ;}catch(ya){if(ya instanceof Error){var fa=ya;if(fa===JQ)throw JQ;throw fa;}throw ya;}else throw JQ;}catch(ya){if(ya instanceof Error)if(fa=ya,fa===JQ)try{if(Q=$APP.x.A(O,
0),-Infinity===Q)try{W=$APP.x.A(O,1);if(-Infinity===W)return $APP.Fj.B(d.M(g,n,l,t),nQ,$APP.Ck);throw JQ;}catch(wa){if(wa instanceof Error){var ha=wa;if(ha===JQ)throw JQ;throw ha;}throw wa;}else throw JQ;}catch(wa){if(wa instanceof Error)if(ha=wa,ha===JQ)try{if(Q=$APP.x.A(O,0),Infinity===Q)try{W=$APP.x.A(O,1);if(Infinity===W)return $APP.Fj.B(d.M(g,n,l,t),nQ,$APP.Ck);throw JQ;}catch(Ba){if(Ba instanceof Error){var ja=Ba;if(ja===JQ)throw JQ;throw ja;}throw Ba;}else throw JQ;}catch(Ba){if(Ba instanceof
Error)if(ja=Ba,ja===JQ)try{if(Q=$APP.x.A(O,0),-Infinity===Q)try{W=$APP.x.A(O,1);if(Infinity===W){var ta=G(l,J,c9a),ua=B(J,A,d9a),ca=G(A,n,e9a);return new $APP.f(null,2,[oQ,!0,nQ,ta+ua+ca],null)}throw JQ;}catch(Qa){if(Qa instanceof Error){var V=Qa;if(V===JQ){if(n<=J)return G(l,n,p);ta=G(l,J,c9a);var da=B(J,n,y8a(p));return new $APP.f(null,2,[oQ,!0,nQ,ta+da],null)}throw V;}throw Qa;}else throw JQ;}catch(Qa){if(Qa instanceof Error)if(V=Qa,V===JQ)try{W=$APP.x.A(O,1);if(Infinity===W){if(l>=A)return G(l,
n,p);var Y=B(l,A,z8a(p));ca=G(A,n,e9a);return new $APP.f(null,2,[oQ,!0,nQ,Y+ca],null)}throw JQ;}catch(Va){if(Va instanceof Error){Q=Va;if(Q===JQ)throw JQ;throw Q;}throw Va;}else throw V;else throw Qa;}else throw ja;else throw Ba;}else throw ha;else throw wa;}else throw fa;else throw ya;}else throw Z;else throw ea;}else throw JQ;}catch(ea){if(ea instanceof Error){Z=ea;if(Z===JQ)return a.M?a.M(g,l,n,t):a.call(null,g,l,n,t);throw Z;}throw ea;}}function c(g,l,n){return d.M(g,l,n,$APP.F)}var d=null;d=
function(g,l,n,p){switch(arguments.length){case 3:return c.call(this,g,l,n);case 4:return b.call(this,g,l,n,p)}throw Error("Invalid arity: "+arguments.length);};d.B=c;d.M=b;return d}()};KQ=function(a){return $APP.x.A(a,0)};$APP.LQ=function(a){return $APP.x.A(a,1)};MQ=function(a){return $APP.x.A(a,2)};NQ=function(a){return $APP.x.A(a,3)};g9a=function(a){a=$APP.x.A(a,1);return WK(a)?$APP.Tc(a):1};h9a=function(a){return uL.C($APP.y([$APP.Nj.j($APP.Rv),fL($APP.Nj.j($APP.Vv),a),fL($APP.Nj.j($APP.Tv),a)]))};
$APP.i9a=function(a){return function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return iG.C(QF.A(1,2),a,$APP.y([lG.j(b)]))}};j9a=function(a){return function(b){$APP.x.B(b,0,null);var c=$APP.x.B(b,1,null);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return uL.C($APP.y([uL.C($APP.y([b,0])),uL.C($APP.y([kG.A(b,iG.A(a,gO.j(c))),iG.C(-1,a,$APP.y([fO.j(c)]))]))]))}};
k9a=function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null),l=$APP.x.B(g,0,null);$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);g=$APP.x.B(g,1,null);$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var n=$APP.x.B(d,2,null);d=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);return RF.A(iG.A(QF.A(1,2),kG.A(iG.A(a,lG.j(d)),iG.A(b,lG.j(n)))),iG.A(c,kG.A(iG.A(a,l),iG.A(b,g))))}};
l9a=function(a,b){return function(c){var d=a.j?a.j(c):a.call(null,c),g=b.j?b.j(c):b.call(null,c);return OQ.B?OQ.B(c,d,g):OQ.call(null,c,d,g)}};m9a=function(a){return function(b,c){b=l9a(b,c);return RF.A(SO.j?SO.j(b):SO.call(null,b),WH.C($APP.y([$APP.PQ.j(a),b])))}};n9a=function(a){var b=QQ.j?QQ.j(2):QQ.call(null,2);b=b.j?b.j(a):b.call(null,a);return RF.A(iG.A(b,MQ),a)};o9a=function(a){return function(b){b=WH.C($APP.y([n9a(a),RQ.j(b)]));return SO.j?SO.j(b):SO.call(null,b)}};
p9a=function(a){return function(b){$APP.x.B(b,0,null);var c=$APP.x.B(b,1,null),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);var g=$APP.x.B(b,2,null);b=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);return iG.C(QF.A(1,2),a,$APP.y([kG.C(lG.j(b),lG.j(iG.A(d,l)),$APP.y([lG.j(iG.C(d,gO.j(c),$APP.y([g])))]))]))}};
q9a=function(a,b,c){c+=1;var d=QF.A(RF.A(b,a),c);return function n(l){return new $APP.de(null,function(){for(;;){var p=$APP.r(l);if(p){if($APP.pd(p)){var v=$APP.lc(p),t=$APP.Tc(v),A=$APP.fe(t);a:for(var B=0;;)if(B<t){var G=$APP.bd(v,B);$APP.je(A,kG.A(a,iG.A(G,d)));B+=1}else{v=!0;break a}return v?$APP.ie($APP.ke(A),n($APP.mc(p))):$APP.ie($APP.ke(A),null)}A=$APP.u(p);return $APP.Yd(kG.A(a,iG.A(A,d)),n($APP.Fc(p)))}return null}},null,null)}($APP.Hj.A(1,c))};
r9a=function(a,b){return k_a($APP.Vg.B($APP.ns,b,a))};s9a=function(a,b,c,d,g){var l=$APP.Tc(g);l=q9a(a,c,l);return r9a($APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,b,null,1,null),g,$APP.y([new $APP.D(null,d,null,1,null)]))))),$APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,a,null,1,null),l,$APP.y([new $APP.D(null,c,null,1,null)]))))))};u9a=function(a,b,c,d,g){return function(l){l=s9a(b,c,d,g,l);return SQ.S(a,l,b,d,new $APP.f(null,1,[t9a,!1],null))}};
v9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.Tc(a);return function(g){g=RF.A(g,b);for(var l=2,n=c,p=g;;){if($APP.Uc.A(l,d))return n;var v=l+1;n=kG.A(n,iG.A($APP.x.A(a,l),p));p=QF.A(iG.A(p,g),l);l=v}}};TQ=function(a){return function(b){var c=$APP.u(b);b=v9a(b);b=a.j?a.j(b):a.call(null,b);return b.j?b.j(c):b.call(null,c)}};w9a=function(a){return function(b){var c=$APP.Tc(b);return TQ(function(d){d=WH.C($APP.y([a,RQ.A(d,c-1)]));return SO.j?SO.j(d):SO.call(null,d)})(b)}};x9a=function(a){return $K($APP.gd(RK(a)))};
y9a=function(a){return RF.A(function(){var b=QQ.j?QQ.j(2):QQ.call(null,2);b=b.j?b.j(a):b.call(null,a);return UQ.j?UQ.j(b):UQ.call(null,b)}(),WH.C($APP.y([function(){var b=QQ.j?QQ.j(1):QQ.call(null,1);return b.j?b.j(a):b.call(null,a)}(),x9a])))};
z9a=function(a){return function(b){var c=$APP.Tc(b);return function n(g,l){if(0===g)g=0;else{var p=RF.A;var v=QQ.j?QQ.j(g):QQ.call(null,g);v=v.j?v.j(a):v.call(null,a);var t=rI.A(UQ,g-1);v=t.j?t.j(v):t.call(null,v);v=v.j?v.j(l):v.call(null,l);g=p.call(RF,v,n(g-1,x9a(l)))}return g}($APP.Pd(c,2),b)}};$APP.VQ=function(a){return function(b){var c=$APP.Tc(b);return TQ(function(d){d=WH.C($APP.y([a,RQ.j(d)]));return RQ.A(d,c)})(b)}};
A9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=jG.j(kG.A(lG.j(b),lG.j(c)));b=rG.A(c,b);return uL.C($APP.y([a,b]))};B9a=function(a){return A9a($APP.LQ(a))};C9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=iG.A(b,fO.j(c));b=iG.A(b,gO.j(c));return uL.C($APP.y([a,b]))};D9a=function(a){return C9a($APP.LQ(a))};
E9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null);a=iG.C(b,gO.j(c),$APP.y([fO.j(d)]));d=iG.C(b,gO.j(c),$APP.y([gO.j(d)]));b=iG.A(b,fO.j(c));return uL.B?uL.B(a,d,b):uL.call(null,a,d,b)};F9a=function(a){return E9a($APP.LQ(a))};G9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null);a=jG.j(kG.C(lG.j(b),lG.j(c),$APP.y([lG.j(d)])));d=kO.j(QF.A(d,a));b=rG.A(c,b);return uL.B?uL.B(a,d,b):uL.call(null,a,d,b)};H9a=function(a){return G9a($APP.LQ(a))};
I9a=function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.dv,$APP.r(new $APP.H(null,4,5,$APP.I,[w2a,NN,$APP.r(new $APP.H(null,3,5,$APP.I,[RN,NN,a],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[y2a,NN,a],null))],null)),NN],null)))?a:dJ(a)};WQ=function(a,b,c){return uL.C($APP.y([a,b,c]))};J9a=function(a){var b=WK(a);if(b){if(b=$APP.Uc.A($APP.Tc(a),3)){b=$APP.x.B(a,0,null);var c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return GF(b)&&(GF(c)&&GF(a)||WK(c)&&PZa(a)&&$APP.Uc.A(UK(c),UK(a)))}return b}return b};
XQ=function(a){return $APP.x.A(a,2)};K9a=function(a,b){return function(c){return WQ(c,a.j?a.j(c):a.call(null,c),b.j?b.j(c):b.call(null,c))}};L9a=function(a,b){return kG.A(a,b)};$APP.YQ=function(a){return function(b){return WQ(1,function(){var c=QQ.j?QQ.j(2):QQ.call(null,2);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}(),RF.j(function(){var c=QQ.j?QQ.j(1):QQ.call(null,1);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}()))}};
M9a=function(a){return function(b,c){b=K9a(b,c);c=$APP.YQ(a);return RF.A(SO.j?SO.j(b):SO.call(null,b),WH.C($APP.y([c,b])))}};N9a=function(a){return function(b){return uL.C($APP.y([0,function(){var c=QQ.j?QQ.j(2):QQ.call(null,2);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}(),RF.j(function(){var c=QQ.j?QQ.j(1):QQ.call(null,1);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}())]))}};
P9a=function(a){function b(l){var n=nL(l),p=d.j?d.j(n):d.call(null,n);n=c.j?c.j(n):c.call(null,n);if($APP.k($APP.k(!1)?KF.j(bG.j(ZQ.j(p))):!1))throw $APP.Zi.A("Legendre Transform Failure: determinant \x3d 0",new $APP.f(null,2,[O9a,a,$APP.mr,l],null));p=XSa(p,RF.A(l,n));return RF.A(iG.A(l,p),a.j?a.j(p):a.call(null,p))}var c=SO.j?SO.j(a):SO.call(null,a),d=SO.j?SO.j(c):SO.call(null,c),g=SO.j?SO.j(b):SO.call(null,b);return function(l){if($APP.k(!1)){var n=lL(l);var p=fG.A,v=bG.j;var t=g.j?g.j(n):g.call(null,
n);t=c.j?c.j(t):c.call(null,t);n=$APP.eb(p.call(fG,n,v.call(bG,t)))}else n=!1;if($APP.k(n))throw $APP.Zi.A("Legendre Transform Failure: not quadratic",new $APP.f(null,2,[O9a,a,$APP.mr,l],null));return b(l)}};Q9a=function(a){return JK.A(function(b){return $Q(b,a)},new $APP.D(null,aR,new $APP.D(null,a,null,1,null),2,null))};
S9a=function(a){return JK.A(function(b){var c=kG.A;var d=QQ.j?QQ.j(0):QQ.call(null,0);d=d.j?d.j(b):d.call(null,b);return c.call(kG,d,$Q(b,a))},new $APP.D(null,R9a,new $APP.D(null,a,null,1,null),2,null))};U9a=function(a,b){return JK.A(oG.j(iG.A(b,bR.j(a))),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,T9a,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))))};
V9a=function(a){var b=USa(JF);return function(c,d,g){d=b(d+a*Math.sin(c));c=b(c+d);return g.A?g.A(c,d):g.call(null,c,d)}};W9a=function(a,b){var c=$APP.Le(null);return function(d,g,l,n){var p=g;for(g=b;;){if($APP.Uc.A(g,0))return l.A?l.A(d,p):l.call(null,d,p);d=a.M?a.M(d,p,$APP.ns,c):a.call(null,d,p,$APP.ns,c);if($APP.k(d))p=d,d=$APP.x.B(p,0,null),p=$APP.x.B(p,1,null),--g;else return n.J?n.J():n.call(null)}}};
X9a=function(a){return function(b){var c=$APP.x.B(b,0,null);$APP.x.B(b,1,null);var d=$APP.x.B(b,2,null),g=uL.C,l=a.j?a.j(b):a.call(null,b),n=cR.A;var p=QQ.j?QQ.j(1):QQ.call(null,1);p=p.j?p.j(a):p.call(null,a);b=p.j?p.j(b):p.call(null,b);return g.call(uL,$APP.y([c,l,n.call(cR,d,b)]))}};Y9a=function(a,b,c){return RF.A(WH.C($APP.y([$APP.YQ(b),a])),iG.A(SO.j?SO.j(a):SO.call(null,a),$APP.YQ(c)))};Z9a=function(a,b){return Y9a(a,b,WH.C($APP.y([b,a])))};
dR=function(a){return uL.C($APP.y([0,$APP.x.A(a,2),RF.j($APP.x.A(a,1))]))};$9a=function(a){return uL.C($APP.y([1,tG.j($APP.LQ.j?$APP.LQ.j(a):$APP.LQ.call(null,a)),tG.j(XQ.j?XQ.j(a):XQ.call(null,a))]))};a$a=function(a,b){a=SO.j?SO.j(a):SO.call(null,a);return a.j?a.j(b):a.call(null,b)};b$a=function(a){return function(b){return iG.A(a,b)}};c$a=function(a){return function(b){return iG.A(b,a)}};
d$a=function(a){return function(b){var c=oL(b),d=RF.A(dR,WH.C($APP.y([b$a(function(){var g=SO.j?SO.j(a):SO.call(null,a);return g.j?g.j(b):g.call(null,b)}()),dR,c$a(function(){var g=SO.j?SO.j(a):SO.call(null,a);return g.j?g.j(b):g.call(null,b)}())])));return d.j?d.j(c):d.call(null,c)}};e$a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null),g=$APP.x.B(b,2,null);b=iG.A(jG.j(QF.A(iG.A(2,g),a)),gO.j(d));d=iG.A(jG.j(iG.C(2,a,$APP.y([g]))),fO.j(d));return uL.C($APP.y([c,b,d]))}};
f$a=function(a){return function(b){return iG.A(b,a)}};g$a=function(a){var b=iG.A(2,a)+1;return vN.B(b,b,function(c,d){return 0===c?0:0===d?0:$APP.Uc.A(c+a,d)?1:$APP.Uc.A(d+a,c)?-1:0})};h$a=function(a){var b=iG.A(2,a);return vN.B(b,b,function(c,d){return $APP.Uc.A(kG.A(c,a),d)?1:$APP.Uc.A(kG.A(d,a),c)?-1:0})};j$a=function(a){var b=pN(a);if(!$APP.Ie(b))throw $APP.Zi.A("Wrong type -- symplectic-matrix?",new $APP.f(null,1,[i$a,a],null));b=h$a($APP.Pd(b,2));return RF.A(b,iG.C(a,b,$APP.y([eR.j(a)])))};
k$a=function(a){return n2a(a,0,0)};l$a=function(a){return function(b){return j$a(k$a(b4a(a)(b)))}};fR=function(a,b,c,d,g){this.r=a;this.i=b;this.Ma=c;this.k=d;this.ca=g;this.O=2310931231;this.U=131072};gR=function(a,b,c,d,g){return new fR(a,b,c,d,g)};m$a=function(a){return a instanceof fR};n$a=function(a){return wG.A(a.r,a.i)};o$a=function(a){return wG.A(a.Ma,a.k)};p$a=function(a){return new $APP.H(null,4,5,$APP.I,[a.r,a.i,a.Ma,a.k],null)};
hR=function(a){return new $APP.H(null,3,5,$APP.I,[a.i,a.Ma,a.k],null)};iR=function(a){var b=KF.j(a.i);return $APP.k(b)?(b=KF.j(a.Ma),$APP.k(b)?KF.j(a.k):b):b};q$a=function(a){var b=iR(a);return $APP.k(b)?KF.j(a.r):b};r$a=function(a){var b=iR(a);return $APP.k(b)?sG.j(a.r):b};
jR=function(a,b){var c=a===b;if(c)return c;var d=a.r,g=a.i,l=a.Ma;c=a.k;if(m$a(b))return a=fG.A(d,b.r),$APP.k(a)?(a=fG.A(g,b.i),$APP.k(a)?(l=fG.A(l,b.Ma),$APP.k(l)?fG.A(c,b.k):l):a):a;if(vG(b))return a=fG.A(d,b.ha),$APP.k(a)?(a=fG.A(g,b.ia),$APP.k(a)?(l=KF.j(l),$APP.k(l)?KF.j(c):l):a):a;if($APP.kd(b))return $APP.Uc.A($APP.Tc(b),4)&&$APP.Uc.A(d,$APP.x.A(b,0))&&$APP.Uc.A(g,$APP.x.A(b,1))&&$APP.Uc.A(l,$APP.x.A(b,2))&&$APP.Uc.A(c,$APP.x.A(b,3));a=iR(a);return $APP.k(a)?fG.A(d,b):a};s$a=function(a){return NWa(p$a(a))};
lR=function(a,b){return kR.M($APP.Je.A(a.r,b),$APP.Je.A(a.i,b),$APP.Je.A(a.Ma,b),$APP.Je.A(a.k,b))};t$a=function(a,b){return kR.M(mR.A(a.r,b),mR.A(a.i,b),mR.A(a.Ma,b),mR.A(a.k,b))};nR=function(a){return kR.M(PF.j(a.r),PF.j(a.i),PF.j(a.Ma),PF.j(a.k))};u$a=function(a,b){return kR.M(iG.A(a,b.r),iG.A(a,b.i),iG.A(a,b.Ma),iG.A(a,b.k))};v$a=function(a,b){return kR.M(iG.A(a.r,b),iG.A(a.i,b),iG.A(a.Ma,b),iG.A(a.k,b))};w$a=function(a){return kR.M(a.r,PF.j(a.i),PF.j(a.Ma),PF.j(a.k))};
oR=function(a,b){return kR.M(QF.A(a.r,b),QF.A(a.i,b),QF.A(a.Ma,b),QF.A(a.k,b))};x$a=function(a,b){var c=$APP.x.B(a,0,null),d=$APP.x.B(a,1,null),g=$APP.x.B(a,2,null);a=$APP.x.B(a,3,null);var l=$APP.x.B(b,0,null),n=$APP.x.B(b,1,null),p=$APP.x.B(b,2,null);b=$APP.x.B(b,3,null);return kG.C(iG.A(c,l),iG.A(d,n),$APP.y([iG.A(g,p),iG.A(a,b)]))};y$a=function(a,b){return kR.A(0,i_a(hR(a),hR(b)))};z$a=function(a){return oR(w$a(a),pR.j?pR.j(a):pR.call(null,a))};
pR=function(a){return kG.C(lG.j(a.r),lG.j(a.i),$APP.y([lG.j(a.Ma),lG.j(a.k)]))};qR=function(a){return jG.j(pR(a))};A$a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null),g=$APP.x.B(a,3,null);d=KF.j(d);g=$APP.k(d)?KF.j(g):d;if($APP.k(g))return $APP.k(KF.j(c))?kR.j(pG.j(b)):kR.M(pG.j(hG.j(new $APP.H(null,2,5,$APP.I,[b,c],null))),rG.A(c,b),0,0);c=qR(a);a=hR(a);g=hG.j(a);return kR.A(pG.j(c),MF.A(kO.j(zG.A(b,c)),zG.A(a,g)))};
sR=function(a){var b=oG.j(a.r);a=hR(a);var c=hG.j(a);return $APP.k(KF.j(c))?kR.M(b,0,0,0):kR.A(iG.A(b,fO.j(c)),iG.C(b,rR.j(c),$APP.y([a])))};B$a=function(a){var b=a.r;a=hR(a);var c=hG.j(a);return kR.A(iG.A(fO.j(b),tH.j(c)),iG.A(iG.A(RF.j(gO.j(b)),tR.j(c)),a))};C$a=function(a){var b=a.r;a=hR(a);var c=hG.j(a);return kR.A(iG.A(gO.j(b),tH.j(c)),iG.A(iG.A(fO.j(b),tR.j(c)),a))};D$a=function(a){return uR.A(C$a(a),B$a(a))};E$a=function(a){return oR(vR.A(sR(a),sR(nR(a))),2)};
F$a=function(a){return oR(wR.A(sR(a),sR(nR(a))),2)};G$a=function(a){return uR.A(F$a(a),E$a(a))};H$a=function(a,b){return $APP.xd(b)?VSa(a,b):sR(m$a(b)?xR.A(A$a(a),b):v$a(A$a(a),b))};I$a=function(a){var b=a.r;if($APP.k(iR(a)))return $APP.k(qG.j(b))?kR.M(0,jG.j(hG.j(b)),0,0):kR.M(jG.j(b),0,0,0);b=jG.j(kG.A(b,qR(a)));var c=jG.j(2);return kR.A(QF.A(b,c),QF.A(hR(a),iG.A(b,c)))};
yR=function(a,b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);a=zG.A(a,2);var g=gO.j(a);return kR.M(fO.j(a),iG.A(g,c),iG.A(g,d),iG.A(g,b))};
K$a=function(a){var b=a.r,c=a.i,d=a.Ma;a=a.k;var g=lG.j(b),l=lG.j(c),n=lG.j(d),p=lG.j(a),v=bG.j(kG.C(g,l,$APP.y([n,p])));EJ.A(new $APP.D(null,$APP.Zv,new $APP.D(null,v,new $APP.D(null,1,null,1,null),2,null),3,null),J$a);return CN.C($APP.y([new $APP.H(null,3,5,$APP.I,[QF.A(kG.C(g,l,$APP.y([PF.j(n),PF.j(p)])),v),QF.A(iG.A(2,RF.A(iG.A(c,d),iG.A(b,a))),v),QF.A(iG.A(2,kG.A(iG.A(c,a),iG.A(b,d))),v)],null),new $APP.H(null,3,5,$APP.I,[QF.A(iG.A(2,kG.A(iG.A(c,d),iG.A(b,a))),v),QF.A(kG.C(g,PF.j(l),$APP.y([n,
PF.j(p)])),v),QF.A(iG.A(2,RF.A(iG.A(d,a),iG.A(b,c))),v)],null),new $APP.H(null,3,5,$APP.I,[QF.A(iG.A(2,RF.A(iG.A(c,a),iG.A(b,d))),v),QF.A(iG.A(2,kG.A(iG.A(d,a),iG.A(b,c))),v),QF.A(kG.C(g,PF.j(l),$APP.y([PF.j(n),p])),v)],null)]))};L$a=function(a){return zR.C($APP.y([$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[2,1],null)),$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[0,2],null)),$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[1,0],null))]))};
M$a=function(a){return function(b){var c=WH.C($APP.y([a,b]));return function(d){var g=iG.A;var l=SO.j?SO.j(c):SO.call(null,c);l=l.j?l.j(d):l.call(null,d);return L$a(g.call(iG,l,wN(c.j?c.j(d):c.call(null,d))))}}};N$a=function(a){return function(b){return function(c){return iG.A(wN(function(){var d=b.j?b.j(c):b.call(null,c);return a.j?a.j(d):a.call(null,d)}()),function(){var d=M$a(a)(b);return d.j?d.j(c):d.call(null,c)}())}}};
O$a=function(a,b,c){return function(d){var g=$APP.x.B(d,0,null),l=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return iG.A(QF.A(1,2),kG.C(iG.A(a,lG.j(g)),iG.A(b,lG.j(l)),$APP.y([iG.A(c,lG.j(d))])))}};P$a=function(a,b,c){return function(d){var g=$APP.x.B(d,0,null),l=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return QN.C($APP.y([iG.A(a,g),iG.A(b,l),iG.A(c,d)]))}};
Q$a=function(a){return function(b){function c(d){return nO(a.j?a.j(d):a.call(null,d))}return L$a(function(d){var g=iG.A;var l=SO.j?SO.j(c):SO.call(null,c);l=l.j?l.j(d):l.call(null,d);return g.call(iG,l,eR.j(c(d)))}(b))}};
R$a=function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null),c=$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var d=$APP.x.B(a,2,null),g=$APP.x.B(d,0,null);a=$APP.x.B(d,1,null);var l=$APP.x.B(d,2,null);d=kG.A(iG.C(gO.j(b),gO.j(c),$APP.y([a])),iG.A(fO.j(b),g));b=kG.A(iG.C(fO.j(b),gO.j(c),$APP.y([a])),iG.C(-1,gO.j(b),$APP.y([g])));c=kG.A(iG.A(fO.j(c),a),l);return uL.C($APP.y([d,b,c]))};AR=function(a,b,c){return function(d){return O$a(a,b,c)(R$a(d))}};
S$a=function(a,b,c){return function(d){return P$a(a,b,c)(R$a(d))}};T$a=function(a,b,c){return function(d){var g=$APP.LQ(d);return iG.A(S$a(a,b,c)(d),eR.j(nO(g)))}};U$a=function(a,b,c){return function(d){$APP.x.B(d,0,null);$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return P$a(a,b,c)(d)}};V$a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return WQ(kG.A(c,a),d,b)}};
W$a=function(a,b){return function(c){return(function(){var d=b+c;return a.j?a.j(d):a.call(null,d)}()-function(){var d=b-c;return a.j?a.j(d):a.call(null,d)}())/(2*c)}};
Y$a=function(a,b,c,d){switch(a instanceof $APP.E?a.ga:null){case "forward":return new $APP.f(null,4,[WG,1,BR,1,CR,DR.B(b,c,d),ER,function(g){g=c+g;g=b.j?b.j(g):b.call(null,g);return d/(g-d)}],null);case "central":return new $APP.f(null,4,[WG,2,BR,2,CR,W$a(b,c),ER,function(g){return d/(function(){var l=c+g;return b.j?b.j(l):b.call(null,l)}()-function(){var l=c-g;return b.j?b.j(l):b.call(null,l)}())}],null);case "backward":return new $APP.f(null,4,[WG,1,BR,1,CR,FR.B(b,c,d),ER,function(g){g=c-g;g=b.j?
b.j(g):b.call(null,g);return d/(d-g)}],null);case "central-d2":return new $APP.f(null,4,[WG,2,BR,2,CR,GR.B(b,c,d),ER,function(g){return function(){var l=c+g;return b.j?b.j(l):b.call(null,l)}()+function(){var l=c-g;return b.j?b.j(l):b.call(null,l)}()-2*d}],null);default:return AD(["Invalid method: ",$APP.m.j(a),". Please try one of ",$APP.m.j(X$a)].join(""))}};aab=function(a){a=$APP.Ni.C($APP.y([new $APP.f(null,2,[Z$a,HR,$APP.ky,$$a],null),a]));a=$APP.qe(a);$APP.C.A(a,$APP.ky);return a};
dab=function(a,b,c){if($APP.md(c))return $APP.Jb(c,a,b);if(null==c)return b;if($APP.db(c)){var d=new $APP.Ac(function(){return $APP.Rs},bab,$APP.fg([$APP.Lo,$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.hy,$APP.zj,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[!0,$APP.yn,cab,"cljs/core.cljs",20,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.ey,$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.ey,$APP.Kv,$APP.wy],null),new $APP.H(null,4,5,$APP.I,
[$APP.ey,$APP.Kv,$APP.wy,$APP.jx],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ey,$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.ey,$APP.Kv,$APP.wy],null),new $APP.H(null,4,5,$APP.I,[$APP.ey,$APP.Kv,$APP.wy,$APP.jx],null)),$APP.zx,$APP.M(null,null,null)],null),1,1503,1503,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ey,$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.ey,$APP.Kv,$APP.wy],null),new $APP.H(null,4,5,$APP.I,[$APP.ey,$APP.Kv,$APP.wy,$APP.jx],null)),null,$APP.k($APP.Rs)?$APP.Rs.Z:
null]));return d.B?d.B(c,a,b):d.call(null,c,a,b)}return $APP.Ns(c,a,b)};
hab=function(a,b){if("undefined"===typeof eab||"undefined"===typeof fab||"undefined"===typeof gab||"undefined"===typeof IR)IR=function(c,d,g){this.Cd=c;this.Xb=d;this.Ek=g;this.O=917504;this.U=0},IR.prototype.da=function(c,d){return new IR(this.Cd,this.Xb,d)},IR.prototype.ba=function(){return this.Ek},IR.prototype.fb=function(c,d){return $APP.Ns(this.Cd,this.Xb.j?this.Xb.j(d):this.Xb.call(null,d),d.J?d.J():d.call(null))},IR.prototype.bb=function(c,d,g){return $APP.Ns(this.Cd,this.Xb.j?this.Xb.j(d):
this.Xb.call(null,d),g)},IR.cb=!0,IR.Ya="clojure.core.reducers/t_clojure$core$reducers60648",IR.gb=function(c){return $APP.Vb(c,"clojure.core.reducers/t_clojure$core$reducers60648")};return new IR(a,b,$APP.F)};
iab=function(a){return hab(a,function(b){return function(){function c(l,n){return $APP.kd(n)?$APP.Ns(iab(n),b,l):b.A?b.A(l,n):b.call(null,l,n)}function d(){return b.J?b.J():b.call(null)}var g=null;g=function(l,n){switch(arguments.length){case 0:return d.call(this);case 2:return c.call(this,l,n)}throw Error("Invalid arity: "+arguments.length);};g.J=d;g.A=c;return g}()})};jab=function(a,b){var c=$APP.kh.j(-1);return dab(function(d,g){d[$APP.lh.A(c,$APP.Kba)]=g;return d},b,iab(a))};
mab=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,$APP.JR,1E-8);g=$APP.C.B(g,kab,!1);var l=$APP.Tc(c);a=(new $APP.lab.Solver(a,l,{absoluteTolerance:d,relativeTolerance:d,rawFunction:!0})).integrate(b,$APP.pt.j(c));return $APP.k(g)?a:$APP.Hl.A($APP.eu,a)};
nab=function(a,b,c,d){d=$APP.qe(d);var g=$APP.C.B(d,t9a,!0),l=$APP.ef(c),n=$APP.pt.j(b),p=$APP.k(g)?$APP.KR.M(a,b,c,new $APP.f(null,1,[$APP.vQ,$APP.xQ],null)):function(){$G($APP.hw,"emmy.numerical.ode",195,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["Not compiling function for ODE analysis"],null)},null),-2088371585);var v=$APP.Je.A(a,b);return function(t,A){t=FN.A(t,c);t=v.j?v.j(t):v.call(null,t);return jab(t,A)}}();return mab(function(v,t,A){return p.B?p.B(t,A,n):p.call(null,t,A,n)},
0,l,d)};
qab=function(a,b){return function(){function c(l,n,p,v){function t(W){var Z=FN.A(G.j?G.j(W):G.call(null,W),l);$APP.k(A)&&(A.A?A.A(W,Z):A.call(null,W,Z));return $APP.Ne(B,new $APP.H(null,2,5,$APP.I,[W,Z],null))}v=$APP.qe(v);var A=$APP.C.A(v,oab),B=$APP.kh.j(new $APP.H(null,2,5,$APP.I,[0,null],null)),G=nab(a,b,l,v);if($APP.k(A)){n=$APP.r($APP.Hj.B(0,p,n));v=null;for(var J=0,O=0;;)if(O<J){var Q=v.aa(null,O);t(Q);O+=1}else if(n=$APP.r(n))v=n,$APP.pd(v)?(n=$APP.lc(v),O=$APP.mc(v),v=n,J=$APP.Tc(n),n=O):
(n=$APP.u(v),t(n),n=$APP.w(v),v=null,J=0),O=0;else break}$APP.eb(pab(p,$APP.x.A($APP.Fb(B),0)))&&t(p);G.J?G.J():G.call(null);return $APP.x.A($APP.Fb(B),1)}function d(l,n,p){return g.M(l,n,p,$APP.F)}var g=null;g=function(l,n,p,v){switch(arguments.length){case 3:return d.call(this,l,n,p);case 4:return c.call(this,l,n,p,v)}throw Error("Invalid arity: "+arguments.length);};g.B=d;g.M=c;return g}()};
rab=function(a,b,c,d,g){a=nab(a,b,c,new $APP.f(null,2,[$APP.JR,1E-6,t9a,!0],null));try{return $APP.Fl.A(a,function(){return function p(n){return new $APP.de(null,function(){for(var v=n;;)if(v=$APP.r(v)){if($APP.pd(v)){var t=$APP.lc(v),A=$APP.Tc(t),B=$APP.fe(A);a:for(var G=0;;)if(G<A){var J=$APP.bd(t,G);J<d+g/2&&B.add(J);G+=1}else{t=!0;break a}return t?$APP.ie($APP.ke(B),p($APP.mc(v))):$APP.ie($APP.ke(B),null)}B=$APP.u(v);if(B<d+g/2)return $APP.Yd(B,p($APP.Fc(v)));v=$APP.Fc(v)}else return null},null,
null)}($APP.Hj.B(0,d+g,g))}())}finally{a.J?a.J():a.call(null)}};
LR=function(a,b,c){var d=1/3,g=1/24,l=3/44,n=1/14;(0>function(){var Q=a<b?a:b;return Q<c?Q:c}()||1.5E-38>function(){var Q=a+b;var W=a+c;Q=Q<W?Q:W;W=b+c;return Q<W?Q:W}()||3E37<function(){var Q=a>b?a:b;return Q>c?Q:c}())&&AD("Carlson R_F");for(var p=a,v=b,t=c;;){var A=Math.sqrt(v),B=Math.sqrt(t);A=Math.sqrt(p)*(A+B)+A*B;p=.25*(p+A);v=.25*(v+A);A=.25*(t+A);t=d*(p+v+A);var G=(t-p)/t,J=(t-v)/t,O=(t-A)/t;if(.0025<function(){var Q=Math.abs(G);var W=Math.abs(J);Q=Q>W?Q:W;W=Math.abs(O);return Q>W?Q:W}())t=
A;else return d=G*J-O*O,p=G*J*O,(1+(g*d-.1-l*p)*d+n*p)/Math.sqrt(t)}};
sab=function(a,b,c){var d=3/14,g=1/6,l=9/22,n=3/26,p=.25*l,v=1.5*n;(0>(a<b?a:b)||1E-25>function(){var ha=a+b;return ha<c?ha:c}()||4.5E21<function(){var ha=a>b?a:b;return ha>c?ha:c}())&&AD("Carlson R_D");for(var t=a,A=b,B=c,G=0,J=1;;){var O=Math.sqrt(A),Q=Math.sqrt(B);O=Math.sqrt(t)*(O+Q)+O*Q;G+=J/(Q*(B+O));J*=.25;t=.25*(t+O);Q=.25*(A+O);B=.25*(B+O);A=.2*(t+Q+3*B);var W=(A-t)/A,Z=(A-Q)/A,fa=(A-B)/A;if(.0015<function(){var ha=Math.abs(W);var ja=Math.abs(Z);ha=ha>ja?ha:ja;ja=Math.abs(fa);return ha>ja?
ha:ja}())A=Q;else return t=W*Z,O=fa*fa,B=t-O,O=t-6*O,Q=O+B+B,3*G+J*(1+O*(p*O-v*fa*Q-d)+fa*(g*Q+fa*(l*B-fa*n*t)))/(A*Math.sqrt(A))}};
tab=function(a,b){var c=2.236/1.3E-19,d=.257049/25,g=1/3,l=1/7,n=9/22;(0>a||$APP.Uc.A(b,0)||1.69E-38>a+Math.abs(b)||3E37<a+Math.abs(b)||b<-c&&0<a&&a<d)&&AD("Carlson R_C");0<b?a=new $APP.H(null,3,5,$APP.I,[a,b,1],null):(c=a-b,a=new $APP.H(null,3,5,$APP.I,[c,-b,Math.sqrt(a)/Math.sqrt(c)],null));b=$APP.x.B(a,0,null);c=$APP.x.B(a,1,null);for(a=$APP.x.B(a,2,null);;){d=2*Math.sqrt(b)*Math.sqrt(c)+c;b=.25*(b+d);c=.25*(c+d);d=g*(b+c+c);var p=(c-d)/d;if(!(.0012<Math.abs(p)))return(1+p*p*(.3+p*(l+p*(.375+p*
n))))/Math.sqrt(d)*a}};
uab=function(a,b,c,d){var g=3/14,l=1/3,n=3/22,p=3/26,v=.75*n,t=1.5*p,A=.5*l,B=n+n;(0>function(){var wa=a<b?a:b;return wa<c?wa:c}()||2.5E-13>function(){var wa=a+b;var Ba=a+c;wa=wa<Ba?wa:Ba;Ba=b+c;wa=wa<Ba?wa:Ba;Ba=Math.abs(d);return wa<Ba?wa:Ba}()||9E11<function(){var wa=a>b?a:b;wa=wa>c?wa:c;var Ba=Math.abs(d);return wa>Ba?wa:Ba}())&&AD("Carlson R_J");var G=0<d?new $APP.H(null,4,5,$APP.I,[a,b,c,d],null):function(){var wa=function(){var yb=a<b?a:b;return yb<c?yb:c}(),Ba=function(){var yb=a>b?a:b;return yb>
c?yb:c}(),Qa=a+b+c-wa-Ba,Va=1/(Qa-d),cb=Va*(Ba-Qa)*(Qa-wa),pb=Qa+cb,rb=tab(wa*Ba/Qa,d*pb/Qa);return new $APP.H(null,7,5,$APP.I,[wa,Qa,Ba,pb,Va,cb,rb],null)}(),J=$APP.x.B(G,0,null),O=$APP.x.B(G,1,null),Q=$APP.x.B(G,2,null),W=$APP.x.B(G,3,null),Z=$APP.x.B(G,4,null),fa=$APP.x.B(G,5,null);G=$APP.x.B(G,6,null);var ha=Q,ja=W;W=0;for(Q=1;;){var ta=Math.sqrt(J),ua=Math.sqrt(O),ca=Math.sqrt(ha),V=ta*(ua+ca)+ua*ca;W+=Q*tab(Math.pow(ja*(ta+ua+ca)+ta*ua*ca,2),ja*Math.pow(ja+V,2));Q*=.25;J=.25*(J+V);O=.25*(O+
V);ha=.25*(ha+V);V=.25*(ja+V);ja=.2*(J+O+ha+V+V);var da=(ja-J)/ja,Y=(ja-O)/ja,ea=(ja-ha)/ja,ya=(ja-V)/ja;if(.0015<function(){var wa=Math.abs(da);var Ba=Math.abs(Y);wa=wa>Ba?wa:Ba;Ba=Math.abs(ea);wa=wa>Ba?wa:Ba;Ba=Math.abs(ya);return wa>Ba?wa:Ba}())ja=V;else return V=da*(Y+ea)+Y*ea,ta=da*Y*ea,ua=ya*ya,ca=V-3*ua,g=3*W+Q*(1+ca*(v*ca-t*(ta+2*ya*(V-ua))-g)+ta*(A+ya*(ya*p-B))+ya*V*(l-ya*n)+-(l*ya*ua))/(ja*Math.sqrt(ja)),0>=d?Z*(fa*g+3*(G-LR(J,O,ha))):g}};
vab=function(a,b){var c=Math.sin(a);b*=c;return c*LR(Math.pow(Math.cos(a),2),(1-b)*(1+b),1)};wab=function(a,b){if($APP.Uc.A(a,1))return b.A?b.A(Infinity,1):b.call(null,Infinity,1);var c=1,d=Math.sqrt(1-a*a),g=a;a=0;for(var l=1;;){if(Math.abs(g)<MR)return c=d=Math.PI/2/c,d*=1-a/2,b.A?b.A(c,d):b.call(null,c,d);var n=Math.sqrt(c*d),p=(c-d)/2;a+=g*g*l;l*=2;c=(c+d)/2;d=n;g=p}};
xab=function(a,b){var c=0>a;if(c){var d=1-a,g=Math.sqrt(d);return new $APP.H(null,4,5,$APP.I,[c,-(a/d),b*g,g],null)}return new $APP.H(null,4,5,$APP.I,[c,a,b,1],null)};NR=function(a,b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return uL.C($APP.y([a,c,d,b]))};OR=function(a){return $APP.x.B(a,0,null)};PR=function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null),c=$APP.x.B(a,2,null);a=$APP.x.B(a,3,null);return uL.C($APP.y([b,c,a]))};
yab=function(a){return jG.j(RF.A(lG.j(OR(a)),lG.j(PR(a))))};zab=function(a){return jG.j(RF.A(lG.j(PR(a)),lG.j(OR(a))))};Aab=function(a){return function(b){var c=QF.A(1,jG.j(RF.A(1,lG.j(a)))),d=QF.A(kG.A(-1,c),lG.j(a)),g=OR(b);b=PR(b);var l=BH.A(a,b);return NR(iG.A(c,kG.A(g,l)),kG.C(iG.C(c,a,$APP.y([g])),b,$APP.y([iG.C(d,a,$APP.y([l]))])))}};
Bab=function(a,b){return function(c){var d=OR(c);c=PR(c);var g=lG.j(b),l=BH.A(a,c),n=QF.A(1,jG.j(RF.A(1,g))),p=RF.A(n,1);g=iG.A(n,kG.A(d,iG.A(l,b)));d=kG.C(iG.C(n,b,$APP.y([a,d])),c,$APP.y([iG.C(p,a,$APP.y([l]))]));return NR(g,d)}};Cab=function(a){return function(b){var c=OR(b);b=PR(b);b=a.j?a.j(b):a.call(null,b);return NR(c,b)}};QR=function(a,b){return R2a($APP.Xj.M(b,$APP.rg,Dab,!0),a)};Eab=function(a){return Dab.A($APP.ed(a),!1)};Fab=function(a){return bO(Q2a(a))};
Jab=function(a,b,c,d,g){return Gab(a,b,new $APP.f(null,3,[Hab,c,Iab,d,RR,g],null))};Kab=function(){return function(a){return N2a(a)}};Lab=function(a,b){return function(c){return QR(b,c)}};Mab=function(a){return Hab.j(cO(a))};Nab=function(a){return Iab.j(cO(a))};Oab=function(a){return RR.j(cO(a))};Pab=function(a,b){return QF.A(kG.A(a,b),kG.A(1,iG.A(a,b)))};Qab=function(a,b){return QF.A(kG.A(a,b),kG.A(1,iG.A(QF.A(a,SR),QF.A(b,SR))))};$APP.qa.prototype.Xe=$APP.ba(3,function(a){return this.Wc(this.div(a).multiply(a))});
$APP.za.prototype.Xe=$APP.ba(2,function(a){return $APP.Ga(this,a).remainder});$APP.qa.prototype.Ve=$APP.ba(1,function(){return 1==(this.jb&1)});$APP.za.prototype.Ve=$APP.ba(0,function(){return 0==this.pb.length&&-1==this.lc||0<this.pb.length&&0!=(this.pb[0]&1)});var rD=null,eab={};oD.prototype.getName=function(){return this.name};oD.prototype.toString=function(){return $APP.m.j(this.name)};oD.prototype.Y=function(a,b){return b instanceof oD?$APP.Uc.A(this.name,b.name):!1};oD.prototype.ka=function(){return $APP.yc(this.name)};
Rab=new $APP.q("emmy.mechanics.lagrange","generalized-LE","emmy.mechanics.lagrange/generalized-LE",1641199781,null);Sab=new $APP.q(null,"matcher","matcher",1187762532,null);Tab=new $APP.q(null,"two-tensor-info","two-tensor-info",-594608408,null);Uab=new $APP.q("emmy.pattern.match","match","emmy.pattern.match/match",-1752583918,null);Vab=new $APP.q("emmy.env","vector-field?","emmy.env/vector-field?",1750013183,null);Wab=new $APP.q("emmy.env","ancestor-frame","emmy.env/ancestor-frame",-750459580,null);
TR=new $APP.q(null,"delta-t","delta-t",1769095452,null);Xab=new $APP.q("emmy.calculus.manifold","R2-polar","emmy.calculus.manifold/R2-polar",1688944980,null);Yab=new $APP.q("emmy.function","arg-shift","emmy.function/arg-shift",606567391,null);Zab=new $APP.q(null,"from","from",-839142725,null);$ab=new $APP.q(null,"find-path","find-path",-63940675,null);abb=new $APP.q("emmy.env","raise1","emmy.env/raise1",-1052717631,null);bbb=new $APP.q("emmy.env","raise2","emmy.env/raise2",-205139274,null);
cbb=new $APP.q("emmy.rational-function","abs","emmy.rational-function/abs",-1087782177,null);dbb=new $APP.q(null,"golden-cut","golden-cut",1058787306,null);ebb=new $APP.q("cljs.core","checked-aset'","cljs.core/checked-aset'",163859714,null);XK=new $APP.E("emmy.structure","down","emmy.structure/down",-1744668711);fbb=new $APP.q("emmy.mechanics.hamilton","flow-transform","emmy.mechanics.hamilton/flow-transform",-1174545373,null);hK=new $APP.q(null,"atan","atan",-1026550135,null);
A7a=new $APP.E(null,"sigma","sigma",-63715703);gbb=new $APP.q("emmy.expression","fmap","emmy.expression/fmap",957815726,null);hbb=new $APP.q(null,"combine-arities","combine-arities",-1180435548,null);ibb=new $APP.q(null,"trace2up","trace2up",522966671,null);jbb=new $APP.q("emmy.env","frame-params","emmy.env/frame-params",2045928944,null);kbb=new $APP.q("emmy.rational-function","add","emmy.rational-function/add",2076598657,null);qRa=new $APP.E(null,"protocol-prop","protocol-prop",-58388138);
lbb=new $APP.q("emmy.polynomial","reciprocal","emmy.polynomial/reciprocal",142220435,null);mbb=new $APP.q("emmy.generic","asec","emmy.generic/asec",-941957938,null);nbb=new $APP.q(null,"definite-integral","definite-integral",760619981,null);obb=new $APP.q(null,"oneform-field?","oneform-field?",-1326324759,null);vSa=new $APP.E(null,"with-meta","with-meta",-1566856820);pbb=new $APP.q("emmy.env","D-numeric","emmy.env/D-numeric",-590583872,null);
qbb=new $APP.q("emmy.matrix","s:transpose","emmy.matrix/s:transpose",351992212,null);rbb=new $APP.q("emmy.special.factorial","rising-factorial","emmy.special.factorial/rising-factorial",611783975,null);sbb=new $APP.q("emmy.env","Cartan-\x3eforms","emmy.env/Cartan-\x3eforms",307556946,null);tbb=new $APP.q(null,"within","within",1563704062,null);ubb=new $APP.q(null,"ruleset","ruleset",-504741885,null);
vbb=new $APP.q("emmy.special.factorial","stirling-second-kind","emmy.special.factorial/stirling-second-kind",303684776,null);wbb=new $APP.q("emmy.matrix","invert","emmy.matrix/invert",2070206201,null);xbb=new $APP.q("emmy.value","kind","emmy.value/kind",402745879,null);PPa=new $APP.q("cljs.core","PersistentHashMap","cljs.core/PersistentHashMap",-454120575,null);ybb=new $APP.q(null,"extract-tangent","extract-tangent",-1785612646,null);
zbb=new $APP.q("emmy.calculus.derivative","symbolic-taylor-series","emmy.calculus.derivative/symbolic-taylor-series",900301948,null);Abb=new $APP.q(null,"emmy.calculus.frame","emmy.calculus.frame",-1927354137,null);Bbb=new $APP.q("emmy.modint","chinese-remainder","emmy.modint/chinese-remainder",989096339,null);Cbb=new $APP.q("emmy.generic","integer-part","emmy.generic/integer-part",-1536207222,null);Dbb=new $APP.q("emmy.env","F-\x3eCT","emmy.env/F-\x3eCT",485081,null);
Ebb=new $APP.q("emmy.calculus.connection","make-Christoffel-1","emmy.calculus.connection/make-Christoffel-1",-1898172660,null);Fbb=new $APP.q("emmy.matrix","row-matrix-\x3evector","emmy.matrix/row-matrix-\x3evector",1051960094,null);Gbb=new $APP.q(null,"H-state-\x3ematrix","H-state-\x3ematrix",859345923,null);Hbb=new $APP.q("emmy.rational-function","negative?","emmy.rational-function/negative?",711662223,null);F5a=new $APP.E("emmy.calculus.covariant","Cartan","emmy.calculus.covariant/Cartan",-529045012);
Ibb=new $APP.q(null,"exponent-contract","exponent-contract",1372913958,null);Jbb=new $APP.q(null,"literal-function?","literal-function?",-391290455,null);Kbb=new $APP.q(null,"map-vals","map-vals",-818445670,null);Lbb=new $APP.q(null,"coefficients","coefficients",1939272705,null);Mbb=new $APP.q(null,"fold-\x3escan-fn","fold-\x3escan-fn",1897258390,null);Nbb=new $APP.q(null,"the-next","the-next",-1182032600,null);Obb=new $APP.q(null,"L-free-particle","L-free-particle",51383692,null);
Pbb=new $APP.q("emmy.pattern.syntax","compile-pattern","emmy.pattern.syntax/compile-pattern",-1933550162,null);UR=new $APP.E(null,"tilted","tilted",-1077184052);Qbb=new $APP.q("emmy.env","alternate-angles","emmy.env/alternate-angles",-1503638556,null);Rbb=new $APP.q("emmy.env","velocity","emmy.env/velocity",-92745197,null);Sbb=new $APP.q("emmy.dual","tangent","emmy.dual/tangent",-1107810866,null);t9a=new $APP.E(null,"compile?","compile?",-826687650);
Tbb=new $APP.q("emmy.special.factorial","subfactorial","emmy.special.factorial/subfactorial",1441604625,null);Ubb=new $APP.q(null,"define-coordinates","define-coordinates",785984378,null);Vbb=new $APP.q(null,"symplectic?","symplectic?",-1923699789,null);VR=new $APP.E(null,"skip-protocol-flag","skip-protocol-flag",-1426798630);Wbb=new $APP.q("emmy.structure","component","emmy.structure/component",-513246212,null);Xbb=new $APP.E(null,"micros","micros",420024622);
Ybb=new $APP.q("emmy.series","power-series*","emmy.series/power-series*",-1275455499,null);Zbb=new $APP.q("emmy.calculus.hodge-star","Hodge-star","emmy.calculus.hodge-star/Hodge-star",-972449625,null);$bb=new $APP.q("emmy.series","power-series?","emmy.series/power-series?",1083572761,null);acb=new $APP.q(null,"p1__59152#","p1__59152#",51429529,null);bcb=new $APP.q(null,"diagonal","diagonal",-329457619,null);ccb=new $APP.q("emmy.pattern.rule","top-down","emmy.pattern.rule/top-down",-421921957,null);
dcb=new $APP.q("emmy.series","identity","emmy.series/identity",-1687183655,null);ecb=new $APP.q("emmy.quaternion","real-part","emmy.quaternion/real-part",1487460155,null);fcb=new $APP.q("emmy.pattern.syntax","restriction","emmy.pattern.syntax/restriction",-1325345598,null);gcb=new $APP.q("emmy.env","S3-stereographic","emmy.env/S3-stereographic",-419602625,null);Q3a=new $APP.q("emmy.calculus.manifold","attach-patch","emmy.calculus.manifold/attach-patch",-1143415289,null);
icb=new $APP.q("emmy.expression","-\x3eLiteral","emmy.expression/-\x3eLiteral",-768118032,null);jcb=new $APP.E(null,"millis","millis",-1338288387);WR=new $APP.q(null,"phi","phi",113733223,null);kcb=new $APP.q("emmy.env","indexed-\x3etyped","emmy.env/indexed-\x3etyped",798465885,null);lcb=new $APP.q(null,"lowest-degree","lowest-degree",1042665898,null);mcb=new $APP.q("emmy.mechanics.rotation","rotate-x-tuple","emmy.mechanics.rotation/rotate-x-tuple",1209966635,null);
ncb=new $APP.q("emmy.quaternion","J-tensor","emmy.quaternion/J-tensor",2007933375,null);ocb=new $APP.q("emmy.env","interior-product","emmy.env/interior-product",1038623856,null);pcb=new $APP.q("emmy.env","vector-field-\x3ebasis-components","emmy.env/vector-field-\x3ebasis-components",-1281813315,null);qcb=new $APP.q(null,"flush-obvious-ones","flush-obvious-ones",1647447327,null);rcb=new $APP.q("emmy.util.logic","*log-assumptions?*","emmy.util.logic/*log-assumptions?*",-1434219461,null);
$APP.vQ=new $APP.E(null,"calling-convention","calling-convention",-1148806156);scb=new $APP.q("emmy.env","make-four-tuple","emmy.env/make-four-tuple",1211887888,null);tcb=new $APP.q("emmy.env","zero?","emmy.env/zero?",1552443374,null);ucb=new $APP.q("emmy.mechanics.hamilton","H-state?","emmy.mechanics.hamilton/H-state?",1455823230,null);vcb=new $APP.q("Math","asinh","Math/asinh",-1387635973,null);
wcb=new $APP.q("emmy.numerical.ode","state-advancer","emmy.numerical.ode/state-advancer",-1066425555,null);YR=new $APP.E("emmy.value","seq","emmy.value/seq",2124022964);xcb=new $APP.q("emmy.function","*strict-arity-checks*","emmy.function/*strict-arity-checks*",64089365,null);ycb=new $APP.q("emmy.env","denominator","emmy.env/denominator",-227464344,null);zcb=new $APP.q(null,"emmy.expression.cse","emmy.expression.cse",-423533766,null);Acb=new $APP.q(null,"powers","powers",311385535,null);
Bcb=new $APP.q("emmy.env","S2p-Riemann","emmy.env/S2p-Riemann",-1296230970,null);Ccb=new $APP.q(null,"carlson-rd","carlson-rd",-1185982603,null);Dcb=new $APP.q(null,"carlson-rc","carlson-rc",-572153565,null);Ecb=new $APP.q("emmy.env","patch-names","emmy.env/patch-names",1713205312,null);ZR=new $APP.q(null,"manifold","manifold",-299796682,null);Fcb=new $APP.q(null,"log1-x-series","log1-x-series",-1278924827,null);Gcb=new $APP.q("emmy.env","tex$$","emmy.env/tex$$",1405245746,null);
Hcb=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer-recursive","emmy.rational-function.interpolate/bulirsch-stoer-recursive",1004634018,null);Icb=new $APP.q("emmy.special.factorial","-\x3ebigint","emmy.special.factorial/-\x3ebigint",-2032215075,null);Jcb=new $APP.E(null,"primal","primal",-1668271542);Kcb=new $APP.q("emmy.pattern.match","fail","emmy.pattern.match/fail",175383078,null);
Lcb=new $APP.q("emmy.polynomial.interpolate","neville-incremental","emmy.polynomial.interpolate/neville-incremental",-1468130221,null);Mcb=new $APP.q(null,"patch-names","patch-names",-1547977741,null);Ncb=new $APP.q("emmy.mechanics.lagrange","spherical-\x3erectangular","emmy.mechanics.lagrange/spherical-\x3erectangular",718057911,null);$R=new $APP.q(null,"simplify","simplify",1041318062,null);eJ=new $APP.q("emmy.pattern.consequence","succeed","emmy.pattern.consequence/succeed",-2134737526,null);
Ocb=new $APP.q(null,"emmy.structure","emmy.structure",-1841347423,null);Pcb=new $APP.q("emmy.calculus.covariant","Cartan-\x3eCartan-over-map","emmy.calculus.covariant/Cartan-\x3eCartan-over-map",705943493,null);Qcb=new $APP.q("emmy.calculus.form-field","exterior-derivative","emmy.calculus.form-field/exterior-derivative",-377546215,null);Rcb=new $APP.q("emmy.matrix","column","emmy.matrix/column",-1629830083,null);Scb=new $APP.q("emmy.env","one-like","emmy.env/one-like",-707832446,null);
Tcb=new $APP.q("emmy.env","D-reverse","emmy.env/D-reverse",-1572294824,null);Ucb=new $APP.q("emmy.util","re-matches?","emmy.util/re-matches?",48524176,null);JUa=new $APP.E(null,"output_","output_",-36797880);Vcb=new $APP.q("emmy.calculus.connection","literal-Cartan","emmy.calculus.connection/literal-Cartan",-747501442,null);Wcb=new $APP.q(null,"emmy.dual","emmy.dual",-1682107932,null);Xcb=new $APP.q("emmy.generic","asin","emmy.generic/asin",-27711941,null);
Ycb=new $APP.q("emmy.numerical.unimin.bracket","parabolic-pieces","emmy.numerical.unimin.bracket/parabolic-pieces",-467891697,null);Zcb=new $APP.q(null,"sincos-\x3etrig","sincos-\x3etrig",23955403,null);$cb=new $APP.q(null,"carlson-rf","carlson-rf",1245654373,null);adb=new $APP.q(null,"carlson-rj","carlson-rj",-1303485699,null);aS=new $APP.E("emmy.structure","structure","emmy.structure/structure",1597503132);bdb=new $APP.q(null,"reverse-segment?","reverse-segment?",-1059328125,null);
cdb=new $APP.E(null,"backward","backward",554036364);ddb=new $APP.q("emmy.numsymb","sqrt?","emmy.numsymb/sqrt?",1819733409,null);edb=new $APP.q("emmy.numsymb","quotient?","emmy.numsymb/quotient?",-293049979,null);fdb=new $APP.q("emmy.numerical.unimin.bracket","bracket-max-scmutils","emmy.numerical.unimin.bracket/bracket-max-scmutils",-624944250,null);gdb=new $APP.q("emmy.pattern.rule","choice*","emmy.pattern.rule/choice*",-1389094849,null);
hdb=new $APP.q("emmy.matrix","down-\x3erow-matrix","emmy.matrix/down-\x3erow-matrix",-1472370279,null);idb=new $APP.q("emmy.generic","abs","emmy.generic/abs",2145223455,null);jdb=new $APP.q("emmy.generic","dimension","emmy.generic/dimension",1450492416,null);kdb=new $APP.q(null,"subfactorial","subfactorial",-515124997,null);T4a=new $APP.E("emmy.calculus.basis","coordinate-basis","emmy.calculus.basis/coordinate-basis",1695407987);ldb=new $APP.q(null,"theta2","theta2",381749589,null);
mdb=new $APP.q(null,"one","one",-1719427865,null);ndb=new $APP.q(null,"theta1","theta1",7117474,null);NRa=new $APP.E(null,"fexpr","fexpr",-122857150);odb=new $APP.q("emmy.polynomial","touchard","emmy.polynomial/touchard",-1968715026,null);pdb=new $APP.q(null,"monomial?","monomial?",-1156841196,null);qdb=new $APP.q("emmy.simplify.rules","log-expand","emmy.simplify.rules/log-expand",-318543072,null);rdb=new $APP.q(null,"S2p-Riemann","S2p-Riemann",1897909555,null);
sdb=new $APP.q("emmy.generic","log10","emmy.generic/log10",157064456,null);tdb=new $APP.q(null,"seq-\x3e","seq-\x3e",-877593267,null);udb=new $APP.q(null,"coeff-functions","coeff-functions",825348842,null);bS=new $APP.q(null,"method","method",1696235119,null);vdb=new $APP.q(null,"update-some","update-some",-1531449476,null);wdb=new $APP.q("emmy.modint","residue","emmy.modint/residue",234165167,null);xdb=new $APP.q(null,"s:solve-linear-left","s:solve-linear-left",682916545,null);
ydb=new $APP.q(null,"state-\x3eqddot","state-\x3eqddot",-108844324,null);zdb=new $APP.q(null,"R4-cyl","R4-cyl",-1631843753,null);Adb=new $APP.q(null,"coordinate-system-\x3eLame-coefficients","coordinate-system-\x3eLame-coefficients",-1264922352,null);FD=new $APP.E(null,"as-aliases","as-aliases",1485064798);Bdb=new $APP.q("emmy.env","arity","emmy.env/arity",-1218544587,null);Cdb=new $APP.q(null,"iterated-bottom-up","iterated-bottom-up",86068982,null);
Ddb=new $APP.q("emmy.mechanics.lagrange","coordinates","emmy.mechanics.lagrange/coordinates",-965732825,null);Edb=new $APP.q(null,"-\x3eangle-axis","-\x3eangle-axis",-837358946,null);cS=new $APP.q(null,"ops","ops",-1417105706,null);Fdb=new $APP.q(null,"product?","product?",242454523,null);Gdb=new $APP.q(null,"valid-methods","valid-methods",2063472095,null);Hdb=new $APP.q("cljs.core","qualified-ident?","cljs.core/qualified-ident?",-1863492566,null);
Idb=new $APP.q(null,"emmy.util.def","emmy.util.def",-349640323,null);Jdb=new $APP.q("emmy.env","basis-\x3edimension","emmy.env/basis-\x3edimension",-87447731,null);dS=new $APP.E(null,"protocol-info","protocol-info",1471745843);Kdb=new $APP.q("emmy.generic","solve-linear-right","emmy.generic/solve-linear-right",1371907076,null);Ldb=new $APP.q(null,"make-four-tuple","make-four-tuple",-2053785145,null);
Mdb=new $APP.q("emmy.calculus.basis","basis-\x3evector-basis","emmy.calculus.basis/basis-\x3evector-basis",860063458,null);Ndb=new $APP.q(null,"Rz-matrix","Rz-matrix",-1387146081,null);CRa=new $APP.E(null,"types","types",590030639);Odb=new $APP.q(null,"basis-prime","basis-prime",1652370905,null);Pdb=new $APP.q(null,"-\x3einfix","-\x3einfix",347316576,null);JOa=new $APP.E(null,"undeclared-var","undeclared-var",-1624364944);Qdb=new $APP.q(null,"ONE-matrix","ONE-matrix",-294443349,null);
Rdb=new $APP.q("emmy.expression.render","-\x3eTeX","emmy.expression.render/-\x3eTeX",-865227985,null);Sdb=new $APP.q(null,"initial-count","initial-count",530024616,null);eS=new $APP.q(null,"remainder","remainder",-1608248897,null);Tdb=new $APP.q(null,"trivial-gcd","trivial-gcd",-1471361134,null);Udb=new $APP.q("emmy.simplify.rules","trig-\x3esincos","emmy.simplify.rules/trig-\x3esincos",2105950818,null);S3a=new $APP.q(null,"c:generate","c:generate",1080088399,null);
Wdb=new $APP.q(null,"divisible?","divisible?",721956434,null);cSa=new $APP.q("cljs.core","ns-special-form","cljs.core/ns-special-form",1585185745,null);Xdb=new $APP.q("emmy.mechanics.hamilton","canonical?","emmy.mechanics.hamilton/canonical?",-1898264293,null);Ydb=new $APP.q("emmy.mechanics.hamilton","state-\x3ep","emmy.mechanics.hamilton/state-\x3ep",-521522917,null);Zdb=new $APP.q(null,"unquote?","unquote?",1120794638,null);
$db=new $APP.q("emmy.env","with-literal-functions","emmy.env/with-literal-functions",1083267414,null);eRa=new $APP.E(null,"pmasks","pmasks",-871416698);aeb=new $APP.q(null,"modified-bulirsch-stoer-sum","modified-bulirsch-stoer-sum",-651883568,null);beb=new $APP.q(null,"old","old",-184691163,null);ceb=new $APP.q("cljs.core","true?","cljs.core/true?",-77973136,null);deb=new $APP.q(null,"Rayleigh-dissipation","Rayleigh-dissipation",387785803,null);
eeb=new $APP.q("emmy.complex","complex?","emmy.complex/complex?",730887307,null);feb=new $APP.q("emmy.env","divide","emmy.env/divide",450475901,null);geb=new $APP.q("emmy.env","column-matrix-\x3eup","emmy.env/column-matrix-\x3eup",945546204,null);heb=new $APP.q("emmy.env","brent-min","emmy.env/brent-min",-544244635,null);ieb=new $APP.q(null,"beta","beta",2096137419,null);jeb=new $APP.q(null,"permutation","permutation",-1081825529,null);keb=new $APP.q(null,"fresh-tag","fresh-tag",622887910,null);
leb=new $APP.q(null,"acceleration-tuple","acceleration-tuple",1955295370,null);fS=new $APP.q(null,"?factor","?factor",598737740,null);gS=new $APP.q(null,"four-tuple","four-tuple",1220782365,null);meb=new $APP.q(null,"careful-def","careful-def",1574540304,null);neb=new $APP.q("emmy.env","manifold-point?","emmy.env/manifold-point?",1446354379,null);oeb=new $APP.q("emmy.mechanics.rotation","angle-axis-\x3erotation-matrix","emmy.mechanics.rotation/angle-axis-\x3erotation-matrix",33550409,null);
peb=new $APP.q(null,"expression","expression",1842843403,null);qeb=new $APP.q("emmy.util","biginteger","emmy.util/biginteger",1646410917,null);reb=new $APP.E(null,"polar-cylindrical","polar-cylindrical",-803036371);seb=new $APP.q(null,"replace-tag","replace-tag",1531237472,null);teb=new $APP.E("emmy.expression","abstract-down","emmy.expression/abstract-down",22046591);ueb=new $APP.q(null,"sqrt?","sqrt?",-1493021640,null);U3a=new $APP.E(null,"check-point","check-point",-951160144);
web=new $APP.q("emmy.env","coordinate-system-\x3ebasis","emmy.env/coordinate-system-\x3ebasis",713194691,null);hS=new $APP.q("emmy.calculus.coordinate","coordinate-functions","emmy.calculus.coordinate/coordinate-functions",388209362,null);xeb=new $APP.q("emmy.polynomial","eq","emmy.polynomial/eq",1834358746,null);yeb=new $APP.q(null,"series*","series*",-172585970,null);$APP.zeb=new $APP.q(null,"vector-field","vector-field",1291054264,null);
Aeb=new $APP.q("emmy.numerical.unimin.golden","extend-pt","emmy.numerical.unimin.golden/extend-pt",-1264405405,null);Beb=new $APP.q(null,"expression-simplifier","expression-simplifier",-1365588802,null);Ceb=new $APP.q("emmy.calculus.manifold","one-manifold-function","emmy.calculus.manifold/one-manifold-function",2042659286,null);iS=new $APP.q(null,"partial-derivative","partial-derivative",-1901056819,null);
Deb=new $APP.q("emmy.polynomial","-\x3epower-series","emmy.polynomial/-\x3epower-series",654679288,null);Eeb=new $APP.q("emmy.calculus.basis","basis-\x3eoneform-basis","emmy.calculus.basis/basis-\x3eoneform-basis",1230504834,null);Feb=new $APP.q("emmy.simplify.rules","divide-numbers-through","emmy.simplify.rules/divide-numbers-through",569667771,null);Geb=new $APP.q("emmy.env","elliptic-f","emmy.env/elliptic-f",-1150997741,null);
Heb=new $APP.q(null,"basis-\x3eoneform-basis","basis-\x3eoneform-basis",150278774,null);jS=new $APP.q(null,"identity?","identity?",-1064576891,null);Ieb=new $APP.q(null,"series?","series?",733908051,null);kS=new $APP.q(null,"cache?","cache?",38577578,null);Jeb=new $APP.q("emmy.polynomial","monomial?","emmy.polynomial/monomial?",1804095046,null);CPa=new $APP.E(null,"goog-module","goog-module",-767061656);Keb=new $APP.q("emmy.env","evolution","emmy.env/evolution",-658829369,null);
Leb=new $APP.q("emmy.env","complex","emmy.env/complex",1972060261,null);lS=new $APP.q("cljs.core","IMeta","cljs.core/IMeta",-1459057517,null);Meb=new $APP.q("emmy.mechanics.hamilton","two-particle-center-of-mass","emmy.mechanics.hamilton/two-particle-center-of-mass",1019311275,null);Neb=new $APP.q("emmy.matrix","get-in","emmy.matrix/get-in",1305824368,null);Oeb=new $APP.q("emmy.mechanics.lagrange","Lagrangian-\x3eacceleration","emmy.mechanics.lagrange/Lagrangian-\x3eacceleration",-1247094327,null);
Peb=new $APP.q("emmy.operator","context","emmy.operator/context",1970178364,null);Qeb=new $APP.q("emmy.env","integer-part","emmy.env/integer-part",-852364132,null);Reb=new $APP.q(null,"Qdot","Qdot",48449280,null);Seb=new $APP.E(null,"identity?","identity?",1589858878);Teb=new $APP.q("emmy.pattern.rule","fail","emmy.pattern.rule/fail",-1207554483,null);Ueb=new $APP.q(null,"map-coefficients","map-coefficients",1799565654,null);
Veb=new $APP.q("emmy.pattern.rule","rule","emmy.pattern.rule/rule",1557507652,null);Web=new $APP.q(null,"stream-integrator","stream-integrator",662343416,null);jTa=new $APP.E(null,"input","input",556931961);Xeb=new $APP.q(null,"maxterms","maxterms",-1702656166,null);Yeb=new $APP.E(null,"extend-type","extend-type",-517175606);Zeb=new $APP.q("cljs.core","checked-aget","cljs.core/checked-aget",24024561,null);$eb=new $APP.q("emmy.env","square","emmy.env/square",-677973359,null);
afb=new $APP.q("emmy.env","compatible-shape","emmy.env/compatible-shape",999757184,null);bfb=new $APP.E(null,"fname","fname",1500291491);cfb=new $APP.q(null,"fail","fail",-948220839,null);dfb=new $APP.q("emmy.mechanics.hamilton","polar-canonical-inverse","emmy.mechanics.hamilton/polar-canonical-inverse",177955478,null);FVa=new $APP.E(null,"error-level?","error-level?",778415885);efb=new $APP.q(null,"nth-col","nth-col",510012518,null);mS=new $APP.q(null,"?theta","?theta",-893896091,null);
ffb=new $APP.q("emmy.calculus.metric","metric-\x3einverse-components","emmy.calculus.metric/metric-\x3einverse-components",-619552361,null);LVa=new $APP.E(null,"id!","id!",218090956);nS=new $APP.q(null,"quaternion?","quaternion?",1626848711,null);gfb=new $APP.q("emmy.calculus.form-field","function-\x3eoneform-field","emmy.calculus.form-field/function-\x3eoneform-field",-1387840999,null);hfb=new $APP.q(null,"rsolve","rsolve",108587268,null);
ifb=new $APP.q("emmy.calculus.manifold","corresponding-velocities","emmy.calculus.manifold/corresponding-velocities",944974871,null);jfb=new $APP.q("emmy.util.def","defgeneric","emmy.util.def/defgeneric",-1292804047,null);oS=new $APP.q(null,"indices","indices",422393184,null);kfb=new $APP.q("emmy.env","numerator","emmy.env/numerator",-1634321984,null);lfb=new $APP.q(null,"emmy.function","emmy.function",1327532696,null);mfb=new $APP.q("Math","tanh","Math/tanh",479074141,null);
FF=new $APP.E("emmy.value","scalar","emmy.value/scalar",1964041514);UN=new $APP.q("emmy.abstract.function","literal-function","emmy.abstract.function/literal-function",869741704,null);nfb=new $APP.q(null,"rule","rule",-1924462512,null);ofb=new $APP.q("emmy.mechanics.lagrange","Lagrange-interpolation-function","emmy.mechanics.lagrange/Lagrange-interpolation-function",983357370,null);LPa=new $APP.E(null,"js-fn-var","js-fn-var",-565665358);
pfb=new $APP.q("emmy.generic","tanhc","emmy.generic/tanhc",-271568193,null);qfb=new $APP.q("emmy.quaternion","pure?","emmy.quaternion/pure?",112156834,null);TOa=new $APP.E(null,"global-goog-object\x26array","global-goog-object\x26array",907046210);pS=new $APP.q("b","coordinate-basis?","b/coordinate-basis?",-1009472899,null);rfb=new $APP.q("emmy.simplify.rules","logexp","emmy.simplify.rules/logexp",-1658944749,null);
sfb=new $APP.q("emmy.mechanics.lagrange","L-central-rectangular","emmy.mechanics.lagrange/L-central-rectangular",-2050374616,null);tfb=new $APP.q(null,"matrix-\x3evector","matrix-\x3evector",1354067238,null);tK=new $APP.q(null,"??a1","??a1",2070706636,null);ufb=new $APP.q(null,"richardson-scan","richardson-scan",768006724,null);vfb=new $APP.q(null,"touchard","touchard",1495467264,null);uK=new $APP.q(null,"??a2","??a2",-73012434,null);vK=new $APP.q(null,"??a3","??a3",-1861674627,null);
qS=new $APP.q(null,"ancestor-frame","ancestor-frame",-1796645653,null);rS=new $APP.q("cljs.core","ISeqable","cljs.core/ISeqable",137437203,null);wfb=new $APP.q("emmy.env","make-Christoffel-1","emmy.env/make-Christoffel-1",1238138931,null);nZa=new $APP.q(null,"acos-cos","acos-cos",-652558231,null);xfb=new $APP.q(null,"metric-\x3econnection-1","metric-\x3econnection-1",1270458170,null);yfb=new $APP.q(null,"metric-\x3econnection-2","metric-\x3econnection-2",413672956,null);
zfb=new $APP.q("emmy.env","pullback-function","emmy.env/pullback-function",1996156673,null);Afb=new $APP.q("emmy.abstract.number","abstract-number?","emmy.abstract.number/abstract-number?",694084185,null);$APP.sS=new $APP.q(null,"points","points",153934644,null);Bfb=new $APP.q("emmy.polynomial","-\x3eterms","emmy.polynomial/-\x3eterms",-1215301159,null);Cfb=new $APP.q("emmy.structure","unflatten","emmy.structure/unflatten",-1050431230,null);
Dfb=new $APP.q(null,"two-tensor-operation","two-tensor-operation",-1277856915,null);Efb=new $APP.q("emmy.series","tanh-series","emmy.series/tanh-series",1397818974,null);APa=new $APP.q(null,"checked-aset'","checked-aset'",-510930777,null);rE=new $APP.E(null,"uses","uses",232664692);Ffb=new $APP.q("emmy.util","machine-epsilon","emmy.util/machine-epsilon",896368496,null);Gfb=new $APP.q(null,"known-operation?","known-operation?",-1185030050,null);
Hfb=new $APP.q("emmy.polynomial","with-lower-arity","emmy.polynomial/with-lower-arity",-1979164496,null);Ifb=new $APP.E(null,"protocol-with-overwriting-method","protocol-with-overwriting-method",319993011);Jfb=new $APP.q(null,"meta49488","meta49488",1983700564,null);Kfb=new $APP.q("emmy.polynomial","map-coefficients","emmy.polynomial/map-coefficients",448776324,null);$APP.c4a=new $APP.E(null,"zero?","zero?",-1314772630);QPa=new $APP.q("cljs.core","List","cljs.core/List",1708954352,null);
Lfb=new $APP.q("emmy.mechanics.lagrange","parametric-path-action","emmy.mechanics.lagrange/parametric-path-action",1421787236,null);Mfb=new $APP.q("emmy.rational-function","coeff?","emmy.rational-function/coeff?",-736056791,null);Nfb=new $APP.q("emmy.calculus.manifold","spacetime-rect","emmy.calculus.manifold/spacetime-rect",146933710,null);Ofb=new $APP.q(null,"point-\x3ecoords","point-\x3ecoords",-1341974162,null);Pfb=new $APP.q(null,"constant-elimination","constant-elimination",444082136,null);
Qfb=new $APP.q("emmy.env","-\x3eL-state","emmy.env/-\x3eL-state",-2084350364,null);tS=new $APP.E(null,"stereographic","stereographic",-1557537208);Rfb=new $APP.q("emmy.env","manifold-type","emmy.env/manifold-type",-994601464,null);Sfb=new $APP.q("emmy.mechanics.lagrange","linear-interpolants","emmy.mechanics.lagrange/linear-interpolants",438848742,null);Tfb=new $APP.q("emmy.calculus.frame","claim","emmy.calculus.frame/claim",2042144609,null);uS=new $APP.q(null,"??d1","??d1",1286203826,null);
vS=new $APP.q(null,"??d2","??d2",525254907,null);Ufb=new $APP.q(null,"patch","patch",2021306636,null);Vfb=new $APP.q("emmy.env","generalized-LE","emmy.env/generalized-LE",233003866,null);rOa=new $APP.E("cljs.analyzer","constant-table","cljs.analyzer/constant-table",-114131889);Wfb=new $APP.q(null,"nform-field?","nform-field?",-822258039,null);Xfb=new $APP.q("emmy.env","oneform-field?","emmy.env/oneform-field?",1913890886,null);Yfb=new $APP.q(null,"SR-coordinates?","SR-coordinates?",-159254540,null);
Zfb=new $APP.E(null,"extract-tangent","extract-tangent",868823123);$fb=new $APP.q("emmy.generic","atan","emmy.generic/atan",-149083958,null);wS=new $APP.q(null,"coordinate-basis?","coordinate-basis?",-1009472993,null);agb=new $APP.q("emmy.env","binomial-series","emmy.env/binomial-series",-408596039,null);bgb=new $APP.q("emmy.pattern.rule","bottom-up","emmy.pattern.rule/bottom-up",764915180,null);cgb=new $APP.q("emmy.algebra.fold","kahan","emmy.algebra.fold/kahan",-304103572,null);
BUa=new $APP.E(null,"whitelist","whitelist",-979294437);xS=new $APP.q(null,"pattern","pattern",1882666950,null);QS=new $APP.q(null,"primal","primal",-27740015,null);xK=new $APP.q(null,"??b1","??b1",-1771260238,null);TTa=new $APP.q("cljs.core","reduce","cljs.core/reduce",2025430439,null);yK=new $APP.q(null,"??b2","??b2",1805392567,null);dgb=new $APP.q("emmy.env","up","emmy.env/up",-1663352095,null);egb=new $APP.q("cljs.core","float?","cljs.core/float?",-941017745,null);
fgb=new $APP.q(null,"metric-\x3einverse-components","metric-\x3einverse-components",-804339491,null);ggb=new $APP.q("emmy.special.factorial","stirling-first-kind","emmy.special.factorial/stirling-first-kind",-1622973223,null);hgb=new $APP.q("emmy.sr.frames","make-SR-frame","emmy.sr.frames/make-SR-frame",809775584,null);igb=new $APP.q(null,"compatible-H-state?","compatible-H-state?",-1949500168,null);jgb=new $APP.q("emmy.env","sech","emmy.env/sech",1861563112,null);
kgb=new $APP.q("emmy.polynomial","trailing-coefficient","emmy.polynomial/trailing-coefficient",-43718303,null);lgb=new $APP.q("emmy.env","integrate-state-derivative","emmy.env/integrate-state-derivative",107604274,null);mgb=new $APP.q(null,"bundle-element","bundle-element",-1923897958,null);ngb=new $APP.q("emmy.mechanics.lagrange","Lagrangian-\x3estate-derivative","emmy.mechanics.lagrange/Lagrangian-\x3estate-derivative",765260420,null);ogb=new $APP.q(null,"velocities","velocities",1008302579,null);
pgb=new $APP.q(null,"exact-zero?","exact-zero?",357843816,null);ED=new $APP.E(null,"libspec","libspec",1228503756);RS=new $APP.q(null,"??fs","??fs",-1640556976,null);qgb=new $APP.q("emmy.env","Cartan-transform","emmy.env/Cartan-transform",1356321911,null);rgb=new $APP.q("emmy.mechanics.rotation","rotate-y-tuple","emmy.mechanics.rotation/rotate-y-tuple",-327120368,null);sgb=new $APP.q("emmy.structure","opposite-orientation","emmy.structure/opposite-orientation",-898302298,null);
tgb=new $APP.E(null,"compile-syntax-check","compile-syntax-check",-1865080468);ugb=new $APP.q(null,"emmy.expression","emmy.expression",-1323234745,null);vgb=new $APP.q(null,"Euler-\x3eomega","Euler-\x3eomega",1655711102,null);wgb=new $APP.q(null,"coordinate-system-\x3ebasis","coordinate-system-\x3ebasis",-316169058,null);NG=new $APP.E(null,"?err","?err",549653299);xgb=new $APP.q(null,"basis-components-\x3evector-field","basis-components-\x3evector-field",-2054657112,null);
x2a=new $APP.q(null,"DOWN","DOWN",-1166138822,null);ygb=new $APP.q("emmy.calculus.form-field","get-rank","emmy.calculus.form-field/get-rank",-993270681,null);bK=new $APP.q(null,"??f1","??f1",-1548442439,null);cK=new $APP.q(null,"??f2","??f2",745277317,null);SS=new $APP.q("cljs.core","ICounted","cljs.core/ICounted",-1299011378,null);eK=new $APP.q(null,"??f3","??f3",-1809203400,null);fK=new $APP.q(null,"??f4","??f4",1817370441,null);zgb=new $APP.q(null,"standard-map","standard-map",1530905855,null);
Agb=new $APP.q("emmy.structure","dimension","emmy.structure/dimension",1128670244,null);Bgb=new $APP.q("emmy.calculus.basis","coordinate-system-\x3ebasis","emmy.calculus.basis/coordinate-system-\x3ebasis",731026722,null);Cgb=new $APP.q("emmy.env","wedge","emmy.env/wedge",1904030125,null);KOa=new $APP.E(null,"macro-present?","macro-present?",-1397713205);Dgb=new $APP.q("emmy.env","coordinate-basis-oneform-field","emmy.env/coordinate-basis-oneform-field",873833783,null);
Egb=new $APP.q("emmy.env","bigint?","emmy.env/bigint?",-697598861,null);EVa=new $APP.E(null,"config","config",994861415);Fgb=new $APP.q(null,"polar-\x3erectangular","polar-\x3erectangular",723200704,null);Ggb=new $APP.q("emmy.env","brent-max","emmy.env/brent-max",-2073178861,null);Hgb=new $APP.q(null,"R3-rect","R3-rect",-421879293,null);Igb=new $APP.q(null,"emmy.mechanics.time-evolution","emmy.mechanics.time-evolution",500695545,null);Jgb=new $APP.q("emmy.env","pe","emmy.env/pe",207379544,null);
Kgb=new $APP.q("emmy.env","pi","emmy.env/pi",-919890821,null);Lgb=new $APP.q("emmy.matrix","by-cols*","emmy.matrix/by-cols*",842080009,null);TS=new $APP.q(null,"??n1","??n1",-1325838299,null);US=new $APP.q(null,"??n2","??n2",-1403574689,null);Mgb=new $APP.q("emmy.mechanics.rotation","Rz-matrix","emmy.mechanics.rotation/Rz-matrix",1697461158,null);Ngb=new $APP.q(null,"with-frame","with-frame",1995405727,null);JVa=new $APP.E(null,"vargs_","vargs_",552132148);
ROa=new $APP.E(null,"global-exports","global-exports",-1644865592);Ogb=new $APP.q("emmy.simplify.rules","exp-\x3esincos","emmy.simplify.rules/exp-\x3esincos",188967388,null);Pgb=new $APP.q(null,"asin-series","asin-series",-191286736,null);Qgb=new $APP.q("emmy.calculus.vector-calculus","gradient","emmy.calculus.vector-calculus/gradient",51457926,null);Rgb=new $APP.q(null,"emmy.autodiff","emmy.autodiff",1051420705,null);Sgb=new $APP.q("emmy.dual","compare","emmy.dual/compare",-1123148781,null);
Tgb=new $APP.q("emmy.matrix","I","emmy.matrix/I",196338887,null);VS=new $APP.E(null,"at-least","at-least",267196846);Ugb=new $APP.q("emmy.env","add-v:cs","emmy.env/add-v:cs",1969141461,null);Vgb=new $APP.q("emmy.env","pullback-vector-field","emmy.env/pullback-vector-field",-1320189142,null);Wgb=new $APP.q("emmy.util.aggregate","monoid","emmy.util.aggregate/monoid",-1637277535,null);Y8a=new $APP.E(null,"polynomial","polynomial",-832765162);
Xgb=new $APP.q(null,"*TeX-sans-serif-symbols*","*TeX-sans-serif-symbols*",-854063910,null);b8a=new $APP.q("cljs.core","doto","cljs.core/doto",-1284816239,null);Ygb=new $APP.q(null,"Cartan-\x3eCartan-over-map","Cartan-\x3eCartan-over-map",-1216564554,null);$APP.PO=new $APP.E(null,"point","point",1813198264);Zgb=new $APP.q("emmy.polynomial","lower-arity","emmy.polynomial/lower-arity",-1280777346,null);$gb=new $APP.q(null,"kronecker","kronecker",-759603946,null);
ahb=new $APP.q("emmy.generic","sec","emmy.generic/sec",936938387,null);bhb=new $APP.q("emmy.env","frame?","emmy.env/frame?",833425375,null);chb=new $APP.q(null,"indexed","indexed",2031290151,null);kab=new $APP.E(null,"js?","js?",731848670);DPa=new $APP.E(null,"node","node",581201198);dhb=new $APP.q(null,"differential-of-map","differential-of-map",1243517525,null);ehb=new $APP.q(null,"Boolean","Boolean",1661141587,null);
fhb=new $APP.q("emmy.pattern.rule","choice","emmy.pattern.rule/choice",-548605100,null);WS=new $APP.q(null,"analyzer","analyzer",-578676386,null);ghb=new $APP.q("emmy.function","get","emmy.function/get",-1793923368,null);hhb=new $APP.q(null,"IKind","IKind",-1122621827,null);ihb=new $APP.q("emmy.pattern.match","foreach-matcher","emmy.pattern.match/foreach-matcher",-1357230120,null);jhb=new $APP.q("emmy.simplify.rules","even?","emmy.simplify.rules/even?",1406673330,null);
khb=new $APP.q("series","power-series?","series/power-series?",-1037667389,null);oQa=new $APP.E(null,"binding-form?","binding-form?",1728940169);lhb=new $APP.q("emmy.pattern.rule","consequence","emmy.pattern.rule/consequence",-1340910887,null);mhb=new $APP.q("emmy.util.aggregate","sum","emmy.util.aggregate/sum",-1909275822,null);nhb=new $APP.q("emmy.quaternion","I-tensor","emmy.quaternion/I-tensor",1368886547,null);XS=new $APP.q(null,"acot","acot",1103016569,null);
$APP.OD=new $APP.E(null,"options","options",99638489);ohb=new $APP.q("emmy.calculus.form-field","wedge","emmy.calculus.form-field/wedge",1109134517,null);phb=new $APP.q("emmy.env","vector:generate","emmy.env/vector:generate",-1936462599,null);qhb=new $APP.q(null,"assume!","assume!",1219209121,null);rhb=new $APP.q("emmy.calculus.manifold","S2p-stereographic","emmy.calculus.manifold/S2p-stereographic",233343695,null);shb=new $APP.q("emmy.env","boost-direction","emmy.env/boost-direction",782295390,null);
thb=new $APP.q("emmy.polynomial","from-power-series","emmy.polynomial/from-power-series",-552872100,null);FOa=new $APP.E("clojure.error","symbol","clojure.error/symbol",1544821994);uhb=new $APP.q(null,"components-\x3emetric","components-\x3emetric",-1449192205,null);XH=new $APP.E(null,"arity","arity",-1808556135);kK=new $APP.q(null,"acos","acos",353741763,null);vhb=new $APP.q("emmy.polynomial","leading-exponents","emmy.polynomial/leading-exponents",134917691,null);
whb=new $APP.q(null,"sincos-\x3eexp1","sincos-\x3eexp1",-1351286233,null);xhb=new $APP.q(null,"sincos-\x3eexp2","sincos-\x3eexp2",935948490,null);YS=new $APP.q(null,"constant","constant",1260922224,null);yhb=new $APP.q("emmy.calculus.manifold","S3-gnomonic","emmy.calculus.manifold/S3-gnomonic",-987625972,null);zhb=new $APP.q("emmy.env","Lagrangian-\x3eenergy","emmy.env/Lagrangian-\x3eenergy",-1192894669,null);Ahb=new $APP.q("emmy.util","compute-expt","emmy.util/compute-expt",107701436,null);
ZS=new $APP.q(null,"e-\x3ec","e-\x3ec",-1459982439,null);Bhb=new $APP.q("emmy.series","binomial-series","emmy.series/binomial-series",-57585989,null);Chb=new $APP.q("emmy.polynomial.interpolate","modified-neville-fold","emmy.polynomial.interpolate/modified-neville-fold",-1720995209,null);Dhb=new $APP.q(null,"canonical?","canonical?",-942586428,null);Ehb=new $APP.q("emmy.mechanics.lagrange","acceleration-tuple","emmy.mechanics.lagrange/acceleration-tuple",-708335570,null);
Fhb=new $APP.E(null,"lower-riemann","lower-riemann",-418483901);Ghb=new $APP.q("emmy.mechanics.hamilton","polar-canonical","emmy.mechanics.hamilton/polar-canonical",1768890995,null);Hhb=new $APP.q("emmy.calculus.covariant","make-Cartan","emmy.calculus.covariant/make-Cartan",1902493329,null);Ihb=new $APP.q(null,"acsch","acsch",-1449651634,null);Jhb=new $APP.q(null,"emmy.rational-function.interpolate","emmy.rational-function.interpolate",231242309,null);
EOa=new $APP.E("clojure.error","phase","clojure.error/phase",275140358);Khb=new $APP.E(null,"known-operation?","known-operation?",1469405719);Lhb=new $APP.q(null,"rotate-left","rotate-left",-1088090459,null);s6a=new $APP.E("emmy.calculus.connection","Christoffel-1","emmy.calculus.connection/Christoffel-1",-714777450);Mhb=new $APP.q("emmy.matrix","nth-row","emmy.matrix/nth-row",-1981439469,null);Nhb=new $APP.q("emmy.generic","floor","emmy.generic/floor",607506297,null);
Ohb=new $APP.q("emmy.calculus.metric","trace2up","emmy.calculus.metric/trace2up",607614917,null);Phb=new $APP.q("emmy.calculus.manifold","R2-rect","emmy.calculus.manifold/R2-rect",-1423078140,null);cPa=new $APP.E(null,"js-provide","js-provide",1052912493);Qhb=new $APP.q(null,"leading-coefficient","leading-coefficient",-1229509395,null);Rhb=new $APP.q("emmy.env","Riemann","emmy.env/Riemann",-219712800,null);Shb=new $APP.q(null,"derivative?","derivative?",1454715490,null);
Thb=new $APP.q("emmy.structure","literal-down","emmy.structure/literal-down",-211692452,null);Uhb=new $APP.q("emmy.env","symplectic-unit","emmy.env/symplectic-unit",2091030165,null);Vhb=new $APP.E(null,"warning-type","warning-type",1711103595);Whb=new $APP.q("emmy.complex","parse-complex","emmy.complex/parse-complex",-1556002796,null);uRa=new $APP.E(null,"host-call","host-call",1059629755);
Xhb=new $APP.q("emmy.env","Lagrange-interpolation-function","emmy.env/Lagrange-interpolation-function",1187854249,null);Yhb=new $APP.q("emmy.pattern.match","not","emmy.pattern.match/not",-45534106,null);W3a=new $APP.q("emmy.calculus.manifold","uuid","emmy.calculus.manifold/uuid",-1498777606,null);$hb=new $APP.E(null,"nodes","nodes",-2099585805);aib=new $APP.q(null,"acsc","acsc",-1149851176,null);bib=new $APP.q("emmy.env","coordinate-functions","emmy.env/coordinate-functions",-1770294271,null);
cib=new $APP.q("emmy.mechanics.hamilton","D-phase-space","emmy.mechanics.hamilton/D-phase-space",1553636618,null);dib=new $APP.q("emmy.value","set-js-meta!","emmy.value/set-js-meta!",-322342388,null);eib=new $APP.q(null,"fn-counter","fn-counter",245142765,null);fib=new $APP.q(null,"*poly-simplify*","*poly-simplify*",710366657,null);$S=new $APP.q("cljs.core","IIndexed","cljs.core/IIndexed",-436490749,null);gib=new $APP.q(null,"compositional-canonical?","compositional-canonical?",-235019959,null);
hib=new $APP.q("emmy.expression","sorted?","emmy.expression/sorted?",-283398484,null);iib=new $APP.q("emmy.calculus.curvature","Riemann","emmy.calculus.curvature/Riemann",-439852890,null);aT=new $APP.q(null,"square","square",-1842001092,null);jib=new $APP.q(null,"differential","differential",1372034786,null);kib=new $APP.q("emmy.generic","acsch","emmy.generic/acsch",-27957245,null);lib=new $APP.q(null,"two-down?","two-down?",640100597,null);
mib=new $APP.q("emmy.env","column-matrix-\x3evector","emmy.env/column-matrix-\x3evector",1058526148,null);nib=new $APP.q("emmy.mechanics.hamilton","Phi*","emmy.mechanics.hamilton/Phi*",-653609790,null);oib=new $APP.q("emmy.mechanics.lagrange","Euler-Lagrange-operator","emmy.mechanics.lagrange/Euler-Lagrange-operator",656873984,null);pib=new $APP.q("emmy.util.permute","number-of-permutations","emmy.util.permute/number-of-permutations",280089544,null);
qib=new $APP.q("emmy.generic","one-like","emmy.generic/one-like",-90952804,null);rib=new $APP.q(null,"Lagrangian-\x3eRouthian","Lagrangian-\x3eRouthian",222397111,null);sib=new $APP.q(null,"all-results","all-results",-1415580986,null);bT=new $APP.q(null,"floor","floor",-772394748,null);tib=new $APP.q(null,"emmy.calculus.manifold","emmy.calculus.manifold",-1044647599,null);uib=new $APP.q("emmy.env","coordinatize","emmy.env/coordinatize",-952232144,null);
DUa=new $APP.E(null,"allow-spec","allow-spec",448749872);vib=new $APP.q(null,"T-body-Euler","T-body-Euler",92639401,null);wib=new $APP.q("emmy.expression","expression-of","emmy.expression/expression-of",8468966,null);xib=new $APP.E(null,"invalid-protocol-symbol","invalid-protocol-symbol",86246948);yib=new $APP.q(null,"seq:print","seq:print",-1136490111,null);pZa=new $APP.q(null,"atan-sin-cos","atan-sin-cos",-761958387,null);zib=new $APP.q(null,"-\x3etex-equation","-\x3etex-equation",-121272119,null);
Aib=new $APP.q(null,"p-\x3er","p-\x3er",1864824186,null);Bib=new $APP.q("emmy.operator","make-operator","emmy.operator/make-operator",1283966800,null);Cib=new $APP.q("emmy.generic","sin","emmy.generic/sin",1382432478,null);Dib=new $APP.E(null,"minterms","minterms",-1267652170);Eib=new $APP.q("emmy.calculus.metric","oneform-field-\x3evector-field","emmy.calculus.metric/oneform-field-\x3evector-field",-1279709088,null);Fib=new $APP.q(null,"Ry-matrix","Ry-matrix",-110991524,null);
hcb=new $APP.q("emmy.calculus.manifold","literal-scalar-field","emmy.calculus.manifold/literal-scalar-field",903642531,null);Hib=new $APP.E(null,"letfn","letfn",-2121022354);Iib=new $APP.q("emmy.quaternion","quaternion?","emmy.quaternion/quaternion?",1358205183,null);Jib=new $APP.E("cljs.analyzer","protocol-impl","cljs.analyzer/protocol-impl",-1523935409);wWa=new $APP.E(null,"simplify","simplify",-599213465);Kib=new $APP.E(null,"in-\x3epartial","in-\x3epartial",1608898855);
Lib=new $APP.q("emmy.simplify.rules","trig:special","emmy.simplify.rules/trig:special",-38160197,null);Mib=new $APP.q("emmy.env","sumr","emmy.env/sumr",-777336054,null);Nib=new $APP.q("emmy.pattern.rule","\x3d\x3e","emmy.pattern.rule/\x3d\x3e",2133377795,null);Oib=new $APP.q("emmy.env","make-event","emmy.env/make-event",194949656,null);Pib=new $APP.q(null,"emmy.calculus.hodge-star","emmy.calculus.hodge-star",-847911522,null);
Qib=new $APP.q("emmy.calculus.covariant","geodesic-equation","emmy.calculus.covariant/geodesic-equation",-1084034565,null);TM=new $APP.E("emmy.value","number","emmy.value/number",547788979);Rib=new $APP.q(null,"M-\x3eEuler","M-\x3eEuler",-1777835457,null);Sib=new $APP.q(null,"parse-ratio","parse-ratio",1768923063,null);Tib=new $APP.q(null,"literal","literal",-989660164,null);Uib=new $APP.q("emmy.env","bigint","emmy.env/bigint",-1121715661,null);
Vib=new $APP.q(null,"coordinate-system-\x3evector-basis","coordinate-system-\x3evector-basis",-1896061788,null);Wib=new $APP.q(null,"S3-tilted","S3-tilted",-1815929529,null);Xib=new $APP.q("emmy.polynomial","drop-leading-term","emmy.polynomial/drop-leading-term",-1571502755,null);DP=new $APP.E(null,"basis","basis",1865819339);Yib=new $APP.q("emmy.polynomial.gcd","*clock*","emmy.polynomial.gcd/*clock*",-549484565,null);
Zib=new $APP.q("emmy.matrix","*careful-conversion*","emmy.matrix/*careful-conversion*",1533133483,null);$ib=new $APP.q("emmy.sr.boost","four-tuple-\x3espace","emmy.sr.boost/four-tuple-\x3espace",285734132,null);ajb=new $APP.q("emmy.simplify.rules","sincos-\x3eexp2","emmy.simplify.rules/sincos-\x3eexp2",2006247798,null);bjb=new $APP.q("emmy.simplify.rules","sincos-\x3eexp1","emmy.simplify.rules/sincos-\x3eexp1",-284517749,null);
cjb=new $APP.q("emmy.mechanics.rigid","M-\x3eomega","emmy.mechanics.rigid/M-\x3eomega",964883892,null);djb=new $APP.q("emmy.polynomial.interpolate","modified-neville-sum","emmy.polynomial.interpolate/modified-neville-sum",-843531547,null);ejb=new $APP.q("emmy.env","S2p-tilted","emmy.env/S2p-tilted",-1327641631,null);fjb=new $APP.q(null,"Lagrange-interpolation-function","Lagrange-interpolation-function",-1682964898,null);gjb=new $APP.q(null,"indexed-\x3etyped","indexed-\x3etyped",-495593490,null);
hjb=new $APP.q("emmy.simplify.rules","odd?","emmy.simplify.rules/odd?",1769749773,null);ijb=new $APP.q(null,"elliptic-integrals","elliptic-integrals",892634708,null);COa=new $APP.E("clojure.error","line","clojure.error/line",-1816287471);Vdb=new $APP.q(null,"ICoordinateSystem","ICoordinateSystem",131120782,null);kjb=new $APP.q(null,"euler-gamma","euler-gamma",1811527439,null);VVa=new $APP.E(null,"async?","async?",1523057758);$APP.cT=new $APP.E(null,"size","size",1098693007);
ljb=new $APP.q("emmy.env","S2-type","emmy.env/S2-type",-26303570,null);mjb=new $APP.q(null,"tag-active?","tag-active?",-1542800383,null);ZM=new $APP.E("emmy.dual","reverse","emmy.dual/reverse",-1140830856);YNa=new $APP.q(null,"cljs.spec.alpha","cljs.spec.alpha",505122844,null);njb=new $APP.q("emmy.calculus.metric","raise2","emmy.calculus.metric/raise2",-1222669361,null);ojb=new $APP.q("emmy.calculus.metric","raise1","emmy.calculus.metric/raise1",-2060807002,null);
pjb=new $APP.q("emmy.series","cos-series","emmy.series/cos-series",-1482945835,null);qjb=new $APP.q("emmy.calculus.form-field","oneform-field-\x3ecomponents","emmy.calculus.form-field/oneform-field-\x3ecomponents",-1686561511,null);rjb=new $APP.q("emmy.pattern.rule","iterated-bottom-up","emmy.pattern.rule/iterated-bottom-up",-729308934,null);dT=new $APP.q(null,"convergence-fn","convergence-fn",1483169014,null);
sjb=new $APP.q("emmy.pattern.match","-\x3eFailure","emmy.pattern.match/-\x3eFailure",730202035,null);tjb=new $APP.E(null,"valid?","valid?",-212412379);ujb=new $APP.q("emmy.env","frame-name","emmy.env/frame-name",1776401029,null);vjb=new $APP.q("emmy.env","oneform-field-\x3evector-field","emmy.env/oneform-field-\x3evector-field",-135296695,null);eT=new $APP.q(null,"acc","acc",-1815869457,null);wjb=new $APP.E(null,"coords-\x3eevent","coords-\x3eevent",-1002790988);
fT=new $APP.E("emmy.complex","complex","emmy.complex/complex",-886041869);xjb=new $APP.q("emmy.numerical.unimin.bracket","ascending-by","emmy.numerical.unimin.bracket/ascending-by",-1264323100,null);yjb=new $APP.q(null,"ref","ref",-1364538802,null);QYa=new $APP.q(null,"?ab","?ab",-380882607,null);zjb=new $APP.q(null,"column-matrix","column-matrix",977710190,null);Ajb=new $APP.q("emmy.simplify.rules","expand-multiangle","emmy.simplify.rules/expand-multiangle",555994743,null);
Bjb=new $APP.q(null,"-\x3eQuaternion","-\x3eQuaternion",2119310605,null);Cjb=new $APP.q(null,"seq-arity","seq-arity",-1795913505,null);Djb=new $APP.q("emmy.calculus.manifold","typical-point","emmy.calculus.manifold/typical-point",-974567133,null);Ejb=new $APP.q(null,"SO3-type","SO3-type",-259399070,null);Fjb=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer-scan","emmy.rational-function.interpolate/bulirsch-stoer-scan",-262640161,null);
Gjb=new $APP.q(null,"monoid","monoid",1982407932,null);$APP.gT=new $APP.q(null,"add","add",1875819266,null);Hjb=new $APP.q("emmy.algebra.fold","constant","emmy.algebra.fold/constant",2003621841,null);hT=new $APP.q(null,"?c1","?c1",-268581185,null);GPa=new $APP.E(null,"externs","externs",221720677);NUa=new $APP.E(null,"?meta","?meta",-793560773);Ijb=new $APP.q(null,"Jacobian","Jacobian",-1342622555,null);Jjb=new $APP.q(null,"leading-exponents","leading-exponents",-1198630583,null);
Kjb=new $APP.q("emmy.quaternion","spherical","emmy.quaternion/spherical",-1292829121,null);Ljb=new $APP.q("emmy.env","lcm","emmy.env/lcm",1481971313,null);Mjb=new $APP.q("emmy.matrix","column?","emmy.matrix/column?",-579607826,null);Njb=new $APP.q("emmy.quaternion","-\x3ecomplex-pair","emmy.quaternion/-\x3ecomplex-pair",-2112365939,null);iT=new $APP.q(null,"compare-fn","compare-fn",233034889,null);jRa=new $APP.E("cljs.analyzer","property","cljs.analyzer/property",1113330886);
Ojb=new $APP.q(null,"sharpen","sharpen",1323878487,null);Pjb=new $APP.q("emmy.matrix","column*","emmy.matrix/column*",-2008125406,null);Qjb=new $APP.q("emmy.env","coordinate-system-\x3emetric","emmy.env/coordinate-system-\x3emetric",-1184237821,null);jT=new $APP.E("emmy.modint","modint","emmy.modint/modint",128115973);Rjb=new $APP.q(null,"T-rigid-body","T-rigid-body",1643981749,null);Sjb=new $APP.q("emmy.calculus.covariant","Lie-D","emmy.calculus.covariant/Lie-D",-455776798,null);
Tjb=new $APP.q(null,"contractible?","contractible?",-624316069,null);Ujb=new $APP.q(null,"odd-integer?","odd-integer?",-1780439963,null);Vjb=new $APP.q("emmy.calculus.indexed","outer-product","emmy.calculus.indexed/outer-product",685783821,null);Wjb=new $APP.q(null,"from-angle-normal-axis","from-angle-normal-axis",2091071901,null);Xjb=new $APP.q("emmy.function","seq-arity","emmy.function/seq-arity",-1006791443,null);kT=new $APP.q(null,"coordsys","coordsys",1968681528,null);
Yjb=new $APP.q("Math","cosh","Math/cosh",-1954958918,null);UE=new $APP.E(null,"field","field",-1302436500);Zjb=new $APP.q(null,"quaternion-state-\x3eomega-space","quaternion-state-\x3eomega-space",97984525,null);$jb=new $APP.q(null,"*warn-on-infer*","*warn-on-infer*",1890277318,null);akb=new $APP.q("emmy.env","factor","emmy.env/factor",650837576,null);bkb=new $APP.q("emmy.mechanics.lagrange","L-pendulum","emmy.mechanics.lagrange/L-pendulum",2048699930,null);
w5a=new $APP.q(null,"form-field-\x3eform-field-over-map","form-field-\x3eform-field-over-map",1700913758,null);ckb=new $APP.q("emmy.env","covariant-differential","emmy.env/covariant-differential",1265332708,null);rZa=new $APP.q(null,"acos-sin","acos-sin",1513257305,null);dkb=new $APP.q("emmy.mechanics.rotation","Ry-matrix","emmy.mechanics.rotation/Ry-matrix",24184875,null);ekb=new $APP.q("emmy.env","freeze","emmy.env/freeze",519536865,null);
fkb=new $APP.q("emmy.numerical.unimin.brent","brent-min","emmy.numerical.unimin.brent/brent-min",412015145,null);gkb=new $APP.q(null,"let-coordinates","let-coordinates",1678927597,null);XL=new $APP.E("emmy.polynomial","polynomial","emmy.polynomial/polynomial",-18826324);KVa=new $APP.E(null,"hash_","hash_",-827203612);hkb=new $APP.q("emmy.env","coordinate-system-\x3eoneform-basis","emmy.env/coordinate-system-\x3eoneform-basis",397293752,null);ikb=new $APP.q(null,"inflate","inflate",577869908,null);
aRa=new $APP.q(null,"__meta","__meta",-946752628,null);jkb=new $APP.q("emmy.numerical.quadrature","available-methods","emmy.numerical.quadrature/available-methods",-667133907,null);kkb=new $APP.q("emmy.polynomial","scale-l","emmy.polynomial/scale-l",-780812859,null);lkb=new $APP.E(null,"impls","impls",-1314014853);mkb=new $APP.q("emmy.env","-\x3etex-equation","emmy.env/-\x3etex-equation",-1172062182,null);nkb=new $APP.q("emmy.series","fib-series","emmy.series/fib-series",1239574556,null);
okb=new $APP.q(null,"Phi","Phi",679137412,null);lT=new $APP.E("emmy.series","coseries","emmy.series/coseries",1116504415);pkb=new $APP.q(null,"modified-neville-sum","modified-neville-sum",-1873943260,null);qkb=new $APP.q(null,"symplectic-two-form","symplectic-two-form",-501487260,null);rkb=new $APP.q("emmy.util","int","emmy.util/int",-925020463,null);skb=new $APP.q("emmy.env","S2-spherical","emmy.env/S2-spherical",1341414941,null);
tkb=new $APP.q("emmy.env","manifold?","emmy.env/manifold?",975413107,null);ukb=new $APP.E(null,"macros-ns","macros-ns",1626844933);P6a=new $APP.E("zip","children","zip/children",-940194589);vkb=new $APP.q("emmy.calculus.manifold","R3-spherical","emmy.calculus.manifold/R3-spherical",-51209951,null);wkb=new $APP.q(null,"emmy.util","emmy.util",777632628,null);xkb=new $APP.q(null,"matrix-by-cols","matrix-by-cols",-1933276979,null);ykb=new $APP.E(null,"missing","missing",362507769);
zkb=new $APP.q("emmy.env","coordinate-system-at","emmy.env/coordinate-system-at",-1903743214,null);Akb=new $APP.q("emmy.calculus.map","pullback-vector-field","emmy.calculus.map/pullback-vector-field",-1827175707,null);Bkb=new $APP.q("emmy.util","parse-double","emmy.util/parse-double",1389014485,null);Ckb=new $APP.q(null,"twopi","twopi",1500974612,null);kZa=new $APP.q(null,"aggressive-atan-1","aggressive-atan-1",-730258103,null);
lZa=new $APP.q(null,"aggressive-atan-2","aggressive-atan-2",-628426094,null);mT=new $APP.q(null,"?im","?im",120320525,null);w7a=new $APP.E(null,"adaptive?","adaptive?",-259268570);Dkb=new $APP.q("emmy.env","up-\x3ecolumn-matrix","emmy.env/up-\x3ecolumn-matrix",-1349682481,null);c8a=new $APP.E(null,"gensym-fn","gensym-fn",-883485832);Ekb=new $APP.q(null,"emmy.numerical.unimin.golden","emmy.numerical.unimin.golden",1703295274,null);
Fkb=new $APP.q("emmy.structure","dual-zero","emmy.structure/dual-zero",2070935638,null);Gkb=new $APP.E(null,"module-type","module-type",1392760304);Hkb=new $APP.q("emmy.calculus.derivative","*mode*","emmy.calculus.derivative/*mode*",1903158697,null);Ikb=new $APP.q("emmy.simplify.rules","non-negative-factors!","emmy.simplify.rules/non-negative-factors!",1177918175,null);Jkb=new $APP.q("emmy.env","negative?","emmy.env/negative?",1404352869,null);
Kkb=new $APP.q("emmy.env","Hamiltonian-\x3estate-derivative","emmy.env/Hamiltonian-\x3estate-derivative",-814043599,null);Lkb=new $APP.q("emmy.dual","bundle-element","emmy.dual/bundle-element",-1169646684,null);Mkb=new $APP.E(null,"central-d2","central-d2",1063418821);nT=new $APP.q("cljs.core","IWithMeta","cljs.core/IWithMeta",-1981666051,null);Nkb=new $APP.q(null,"make-constant-vector-field","make-constant-vector-field",-71514147,null);
Okb=new $APP.q("emmy.expression","pe","emmy.expression/pe",831779257,null);Pkb=new $APP.q(null,"semipolar","semipolar",-145327529,null);Qkb=new $APP.E(null,"undeclared-ns-form","undeclared-ns-form",-248024137);Rkb=new $APP.q("emmy.env","general-boost","emmy.env/general-boost",-1813259114,null);Skb=new $APP.q(null,"orthonormalize","orthonormalize",-931386057,null);Tkb=new $APP.q("emmy.mechanics.lagrange","make-path","emmy.mechanics.lagrange/make-path",-2065309011,null);
Ukb=new $APP.q("emmy.env","SR-coordinates?","emmy.env/SR-coordinates?",946028419,null);Vkb=new $APP.q(null,"converged?","converged?",-875375793,null);J$a=new $APP.q(null,"-\x3erotation-matrix","-\x3erotation-matrix",1030542807,null);Wkb=new $APP.q("emmy.numerical.derivative","backward-difference","emmy.numerical.derivative/backward-difference",2113152218,null);Xkb=new $APP.q("emmy.generic","real-part","emmy.generic/real-part",1558748796,null);
Ykb=new $APP.q(null,"quotient?","quotient?",895716076,null);iPa=new $APP.q(null,"Function","Function",-749895448,null);Zkb=new $APP.q("emmy.modint","modulus","emmy.modint/modulus",-2094361453,null);$kb=new $APP.q("emmy.expression.analyze","auxiliary-variable-fetcher","emmy.expression.analyze/auxiliary-variable-fetcher",-1848744273,null);alb=new $APP.q("emmy.simplify.rules","*sqrt-factor-simplify?*","emmy.simplify.rules/*sqrt-factor-simplify?*",2073057927,null);
blb=new $APP.q("emmy.mechanics.hamilton","H-central","emmy.mechanics.hamilton/H-central",275169501,null);clb=new $APP.q("emmy.util","parse-bigint","emmy.util/parse-bigint",1326751331,null);oT=new $APP.q(null,"boost-direction","boost-direction",-335370591,null);dlb=new $APP.q("cljs.core","uuid?","cljs.core/uuid?",-15131116,null);elb=new $APP.q("emmy.util.permute","subpermute","emmy.util.permute/subpermute",246773707,null);pT=new $APP.q(null,"frame","frame",-70551061,null);
flb=new $APP.q("emmy.quaternion","add","emmy.quaternion/add",1070196234,null);glb=new $APP.q("emmy.expression","literal?","emmy.expression/literal?",750576800,null);hlb=new $APP.q("emmy.special.elliptic","jacobi-elliptic-functions","emmy.special.elliptic/jacobi-elliptic-functions",-81540406,null);ilb=new $APP.q(null,"index-types","index-types",-1276115991,null);jlb=new $APP.q(null,"phidot","phidot",-1040914891,null);n4a=new $APP.q(null,"coordinatized","coordinatized",1447215710,null);
klb=new $APP.q("emmy.generic","negate","emmy.generic/negate",-1058220643,null);llb=new $APP.q("emmy.value","principal-value","emmy.value/principal-value",-2039467858,null);mlb=new $APP.q("emmy.env","inner-product","emmy.env/inner-product",-912328867,null);qT=new $APP.E("emmy.series","series","emmy.series/series",1817174773);nlb=new $APP.q("emmy.function","function?","emmy.function/function?",673009327,null);olb=new $APP.q(null,"*monomial-order*","*monomial-order*",-1705265536,null);
plb=new $APP.q(null,"that","that",828965210,null);qlb=new $APP.E(null,"alternate","alternate",-931038644);rlb=new $APP.q(null,"Symbol","Symbol",716452869,null);NN=new $APP.q(null,"Real","Real",374292741,null);yWa=new $APP.E(null,"simplify-expression","simplify-expression",-473287731);slb=new $APP.E(null,"seconds","seconds",-445266194);tlb=new $APP.q(null,"make-Lagrangian","make-Lagrangian",1190262545,null);ulb=new $APP.q(null,"rotate-z-matrix","rotate-z-matrix",1997537548,null);
rT=new $APP.q(null,"plus","plus",1852072188,null);vlb=new $APP.q("emmy.polynomial","leading-term","emmy.polynomial/leading-term",1083872270,null);wlb=new $APP.q(null,"complex?","complex?",-1119689323,null);xlb=new $APP.q(null,"basis-\x3edimension","basis-\x3edimension",1009774354,null);ylb=new $APP.q("cljs.core","sorted-map","cljs.core/sorted-map",-1196662760,null);zlb=new $APP.q("emmy.util","compute-sqrt","emmy.util/compute-sqrt",1940358593,null);
Alb=new $APP.q(null,"-\x3estructure","-\x3estructure",1110609707,null);Blb=new $APP.q(null,"parabolic-pieces","parabolic-pieces",1967742243,null);Clb=new $APP.q("emmy.generic","exact?","emmy.generic/exact?",-623886372,null);Dlb=new $APP.q("emmy.quaternion","J-matrix","emmy.quaternion/J-matrix",-655831157,null);Elb=new $APP.q("emmy.simplify.rules","unary-elimination","emmy.simplify.rules/unary-elimination",1775341255,null);Flb=new $APP.E(null,"munged-namespace","munged-namespace",-101986199);
Glb=new $APP.E(null,"trapezoid","trapezoid",114840675);Hlb=new $APP.q(null,"H-central","H-central",1534229930,null);Ilb=new $APP.q(null,"T-body","T-body",1409086972,null);veb=new $APP.q("emmy.calculus.manifold","coordinate-prototype","emmy.calculus.manifold/coordinate-prototype",-2134738891,null);Klb=new $APP.q("emmy.generic","modulo","emmy.generic/modulo",125436899,null);Llb=new $APP.q("emmy.value","seqtype","emmy.value/seqtype",-1345949868,null);
e7a=new $APP.E(null,"juxtapose-multiply","juxtapose-multiply",-1262547042);w3a=new $APP.E(null,"patch","patch",380775109);Mlb=new $APP.q("emmy.calculus.coordinate","let-coordinates","emmy.calculus.coordinate/let-coordinates",1490647267,null);KPa=new $APP.E(null,"js-shadowed-by-local","js-shadowed-by-local",198048291);Nlb=new $APP.E(null,"romberg-open","romberg-open",-200805328);Olb=new $APP.q("emmy.function","memoize","emmy.function/memoize",-2056935645,null);
Plb=new $APP.q(null,"fail-r","fail-r",-488260749,null);Qlb=new $APP.q(null,"literal-Hamiltonian-state","literal-Hamiltonian-state",94824489,null);Rlb=new $APP.q(null,"rising-factorial","rising-factorial",-1445656103,null);Slb=new $APP.q(null,"trig:sum-\x3eproduct","trig:sum-\x3eproduct",1941161330,null);Tlb=new $APP.q(null,"sym-\x3evar","sym-\x3evar",-1699261063,null);sT=new $APP.q(null,"sech","sech",-1403979131,null);Ulb=new $APP.q(null,"*commute-partials?*","*commute-partials?*",549147281,null);
Vlb=new $APP.q("emmy.env","mapr","emmy.env/mapr",-1584594995,null);Wlb=new $APP.q("emmy.generic","almost-integral?","emmy.generic/almost-integral?",-566969131,null);yPa=new $APP.q(null,"checked-aset","checked-aset",1556136760,null);Xlb=new $APP.q(null,"polynomial","polynomial",807766365,null);Ylb=new $APP.q("emmy.pattern.syntax","reverse-segment-name","emmy.pattern.syntax/reverse-segment-name",-2008361478,null);Zlb=new $APP.q("emmy.quaternion","semipolar","emmy.quaternion/semipolar",123019087,null);
$lb=new $APP.q("emmy.structure","same-orientation?","emmy.structure/same-orientation?",-590443222,null);amb=new $APP.q("emmy.expression.analyze","monotonic-symbol-generator","emmy.expression.analyze/monotonic-symbol-generator",-926866228,null);bmb=new $APP.q("emmy.special.factorial","bell","emmy.special.factorial/bell",-160776725,null);cmb=new $APP.q(null,"coordinate-basis-vector-field","coordinate-basis-vector-field",928502764,null);
dmb=new $APP.q(null,"standard-map-inverse","standard-map-inverse",1527044725,null);emb=new $APP.q(null,"S2-tilted","S2-tilted",875853010,null);fmb=new $APP.q("emmy.generic","trace","emmy.generic/trace",1962665587,null);gmb=new $APP.q("emmy.matrix","with-substituted-row","emmy.matrix/with-substituted-row",-63338969,null);hmb=new $APP.q(null,"transpose-outer","transpose-outer",248243056,null);imb=new $APP.q(null,"*expt-half-\x3esqrt?*","*expt-half-\x3esqrt?*",-1454481314,null);
jmb=new $APP.q("emmy.matrix","by-cols","emmy.matrix/by-cols",-1087232333,null);kmb=new $APP.q("emmy.env","orthonormalize","emmy.env/orthonormalize",-1914772032,null);xQa=new $APP.E(null,"js-globals","js-globals",1670394727);lmb=new $APP.q("emmy.mechanics.hamilton","*validate-Legendre-transform?*","emmy.mechanics.hamilton/*validate-Legendre-transform?*",1367316148,null);mmb=new $APP.q("emmy.pattern.consequence","unwrap","emmy.pattern.consequence/unwrap",-1920991018,null);
nmb=new $APP.q("emmy.env","R1-rect","emmy.env/R1-rect",-1224779121,null);omb=new $APP.q(null,"-\x3eSeries","-\x3eSeries",2145681101,null);pmb=new $APP.q(null,"literal-manifold-map","literal-manifold-map",915017254,null);IP=new $APP.q(null,"nabla","nabla",1447510358,null);qmb=new $APP.q(null,"jacobi-elliptic-functions","jacobi-elliptic-functions",-617861797,null);rmb=new $APP.q("emmy.calculus.frame","ancestor-frame","emmy.calculus.frame/ancestor-frame",-755747916,null);
smb=new $APP.q("emmy.env","coordinate-system-\x3emetric-components","emmy.env/coordinate-system-\x3emetric-components",429161738,null);tmb=new $APP.q("matrix","num-rows","matrix/num-rows",-1162348928,null);umb=new $APP.q("emmy.calculus.manifold","S2-tilted","emmy.calculus.manifold/S2-tilted",-84281672,null);vmb=new $APP.q(null,"abstract-number?","abstract-number?",740601180,null);wmb=new $APP.E(null,"weeks","weeks",1844596125);
xmb=new $APP.q("emmy.env","euler-gamma","emmy.env/euler-gamma",895975420,null);j7a=new $APP.E(null,"parenthesize","parenthesize",-1945667578);ymb=new $APP.q("emmy.structure","compatible-shape","emmy.structure/compatible-shape",643765646,null);zmb=new $APP.q("emmy.env","acceleration","emmy.env/acceleration",1422673655,null);Amb=new $APP.q("emmy.env","let-coordinates","emmy.env/let-coordinates",670150288,null);
Bmb=new $APP.q("emmy.calculus.manifold","S1-gnomonic","emmy.calculus.manifold/S1-gnomonic",897465245,null);Cmb=new $APP.q(null,"nth-row","nth-row",1256930440,null);Dmb=new $APP.q("emmy.calculus.form-field","alt-wedge","emmy.calculus.form-field/alt-wedge",2085730765,null);CQa=new $APP.E(null,"statement","statement",-32780863);Emb=new $APP.q(null,"emmy.mechanics.hamilton","emmy.mechanics.hamilton",-1632324516,null);D5a=new $APP.q(null,"interior-product","interior-product",1619499933,null);
EPa=new $APP.E(null,"global","global",93595047);Fmb=new $APP.q(null,"opposite","opposite",-720147765,null);Gmb=new $APP.q(null,"equiv","equiv",992570171,null);Hmb=new $APP.q(null,"claim","claim",665172358,null);Imb=new $APP.q(null,"fold-chain","fold-chain",-753757507,null);Jmb=new $APP.q(null,"Hprime","Hprime",-2140990051,null);bPa=new $APP.E(null,"ns-sym","ns-sym",-1696101605);Kmb=new $APP.q("emmy.value","add-object-symbols!","emmy.value/add-object-symbols!",1431521820,null);
Lmb=new $APP.E(null,"done","done",-889844188);Mmb=new $APP.q("emmy.env","S1-gnomonic","emmy.env/S1-gnomonic",243490852,null);tT=new $APP.q(null,"derivs","derivs",1777840707,null);Nmb=new $APP.q(null,"central-difference","central-difference",1344231377,null);Omb=new $APP.q(null,"literal-down","literal-down",-1340662285,null);Pmb=new $APP.E(null,"cljc","cljc",-1728400583);Qmb=new $APP.q("emmy.mechanics.lagrange","L3-central","emmy.mechanics.lagrange/L3-central",-1028329062,null);
mH=new $APP.q(null,"-pi","-pi",-613600448,null);Rmb=new $APP.q(null,"ulist","ulist",-427264443,null);Smb=new $APP.q("emmy.mechanics.rotation","M-\x3eEuler","emmy.mechanics.rotation/M-\x3eEuler",-1375269112,null);Tmb=new $APP.q(null,"triginv","triginv",-535102478,null);Umb=new $APP.q("emmy.util.aggregate","merge-fn","emmy.util.aggregate/merge-fn",-1131039703,null);Vmb=new $APP.q(null,"classical-gcd","classical-gcd",-1805676176,null);Wmb=new $APP.E(null,"milne","milne",110782965);
Xmb=new $APP.q("emmy.env","state-\x3et","emmy.env/state-\x3et",-573214061,null);uT=new $APP.E("emmy.matrix","square-matrix","emmy.matrix/square-matrix",-857272006);Ymb=new $APP.q("emmy.pattern.match","foreach","emmy.pattern.match/foreach",197469065,null);Zmb=new $APP.q(null,"half-angle","half-angle",584327215,null);$mb=new $APP.q("emmy.expression.cse","extract-common-subexpressions","emmy.expression.cse/extract-common-subexpressions",-18214444,null);
anb=new $APP.q(null,"unflatten","unflatten",527019,null);bnb=new $APP.q(null,"timeout-ex","timeout-ex",1608520355,null);vT=new $APP.q("emmy.calculus.form-field","coordinate-system-\x3eoneform-basis","emmy.calculus.form-field/coordinate-system-\x3eoneform-basis",659366848,null);cnb=new $APP.q("cljs.core","simple-ident?","cljs.core/simple-ident?",1674885558,null);dnb=new $APP.q(null,"differential-of-function","differential-of-function",997752521,null);
enb=new $APP.q("emmy.numsymb","sqrt","emmy.numsymb/sqrt",1370402951,null);fnb=new $APP.q(null,"logexp-\x3especfun","logexp-\x3especfun",2100487617,null);gnb=new $APP.q("emmy.matrix","seq-\x3e","emmy.matrix/seq-\x3e",-1903344984,null);hnb=new $APP.q("emmy.polynomial","analyzer","emmy.polynomial/analyzer",-1945120724,null);inb=new $APP.q("emmy.structure","vector-\x3eup","emmy.structure/vector-\x3eup",782926436,null);jnb=new $APP.q("emmy.env","state-advancer","emmy.env/state-advancer",163396960,null);
knb=new $APP.q(null,"???","???",1210272185,null);lnb=new $APP.q("emmy.value","compare","emmy.value/compare",-1087601004,null);mnb=new $APP.q("emmy.util.def","var-meta","emmy.util.def/var-meta",438546164,null);nnb=new $APP.q("emmy.mechanics.hamilton","compositional-canonical?","emmy.mechanics.hamilton/compositional-canonical?",-926323202,null);onb=new $APP.q("emmy.simplify.rules","idempotent","emmy.simplify.rules/idempotent",844979137,null);
pnb=new $APP.q(null,"components-\x3evector-field","components-\x3evector-field",-1160967663,null);qnb=new $APP.q("emmy.mechanics.hamilton","Hamilton-equations","emmy.mechanics.hamilton/Hamilton-equations",-303713702,null);rnb=new $APP.q(null,"associative","associative",1021237616,null);snb=new $APP.E(null,"undeclared-protocol-symbol","undeclared-protocol-symbol",462882867);tnb=new $APP.q("emmy.pattern.rule","return","emmy.pattern.rule/return",-1581836238,null);
unb=new $APP.q("cljs.core","integer?","cljs.core/integer?",1710697810,null);vnb=new $APP.q("emmy.env","R2-rect","emmy.env/R2-rect",-1568258147,null);wnb=new $APP.q("emmy.env","R4-cyl","emmy.env/R4-cyl",1344160736,null);xnb=new $APP.q(null,"arg-tolerance","arg-tolerance",-973251989,null);wT=new $APP.q(null,"??f","??f",-94026515,null);WJ=new $APP.q(null,"??d","??d",-581862453,null);ynb=new $APP.q(null,"psidot","psidot",-265477541,null);VJ=new $APP.q(null,"??c","??c",1219586074,null);
znb=new $APP.q(null,"interrupted","interrupted",-1654482530,null);Anb=new $APP.q(null,"vector-basis-\x3edual","vector-basis-\x3edual",-54882730,null);UJ=new $APP.q(null,"??b","??b",254504576,null);TJ=new $APP.q(null,"??a","??a",-294068510,null);PJ=new $APP.q(null,"??p","??p",1112654910,null);Bnb=new $APP.q(null,"solve","solve",636252852,null);Cnb=new $APP.q(null,"complex-rules","complex-rules",1594824372,null);xT=new $APP.q(null,"??j","??j",1098328567,null);
Dnb=new $APP.q(null,"S2-gnomonic","S2-gnomonic",876138980,null);yT=new $APP.q(null,"??i","??i",-474049037,null);zT=new $APP.q(null,"??x","??x",-1924511736,null);Enb=new $APP.q("emmy.env","tex$","emmy.env/tex$",2073166013,null);AT=new $APP.q(null,"??w","??w",1245275022,null);OJ=new $APP.q(null,"??v","??v",2028946795,null);NJ=new $APP.q(null,"??u","??u",788654559,null);Fnb=new $APP.q(null,"specfun-\x3elogexp","specfun-\x3elogexp",-540007439,null);QJ=new $APP.q(null,"??q","??q",253374785,null);
Gnb=new $APP.q("emmy.env","spacetime-rect","emmy.env/spacetime-rect",392527447,null);Hnb=new $APP.q(null,"qp-\x3eH-state-path","qp-\x3eH-state-path",1616022316,null);Inb=new $APP.q("emmy.calculus.manifold","R4-rect","emmy.calculus.manifold/R4-rect",-1765223590,null);BT=new $APP.q(null,"??y","??y",-1087769442,null);Jnb=new $APP.q("emmy.polynomial","contractible?","emmy.polynomial/contractible?",1782998533,null);Knb=new $APP.q(null,"drop1","drop1",648703478,null);
Lnb=new $APP.q(null,"drop2","drop2",1353441554,null);Mnb=new $APP.E(null,"unsupported-js-module-type","unsupported-js-module-type",1806206180);Nnb=new $APP.q(null,"Christoffel-\x3ebasis","Christoffel-\x3ebasis",817417876,null);Onb=new $APP.q("emmy.expression.analyze","initializer","emmy.expression.analyze/initializer",685932787,null);Pnb=new $APP.q(null,"exp-contract","exp-contract",1533009748,null);Qnb=new $APP.q("emmy.env","spacetime","emmy.env/spacetime",528609609,null);
BVa=new $APP.E(null,"report","report",1394055010);Rnb=new $APP.q(null,"-\x3et_emmy$util$permute49487","-\x3et_emmy$util$permute49487",185566082,null);CT=new $APP.E("emmy.value","floating-point","emmy.value/floating-point",919866091);Snb=new $APP.q(null,"tanhc","tanhc",991235322,null);Tnb=new $APP.q("emmy.numerical.quadrature","get-integrator","emmy.numerical.quadrature/get-integrator",158462799,null);
Unb=new $APP.q("emmy.simplify.rules","sincos-\x3etrig","emmy.simplify.rules/sincos-\x3etrig",1098989247,null);Vnb=new $APP.q(null,"torsion-vector","torsion-vector",-479497882,null);Wnb=new $APP.q("emmy.polynomial","abs","emmy.polynomial/abs",43142284,null);Xnb=new $APP.q("emmy.polynomial","scale","emmy.polynomial/scale",-457727360,null);Ynb=new $APP.q(null,"illegal","illegal",1626781480,null);Znb=new $APP.q(null,"coordinate-tuple","coordinate-tuple",-1161946955,null);
$nb=new $APP.q(null,"asec","asec",-81933685,null);aob=new $APP.q(null,"literal-Cartan","literal-Cartan",757080022,null);kRa=new $APP.E("cljs.analyzer","symbol","cljs.analyzer/symbol",933248902);bob=new $APP.q(null,"Literal","Literal",998711045,null);cob=new $APP.q("emmy.value","argument-kind","emmy.value/argument-kind",940335956,null);VRa=new $APP.q(null,"cljs.repl","cljs.repl",1767065658,null);dob=new $APP.E(null,"tangent","tangent",720915821);eob=new $APP.E(null,"mins","mins",467369676);
fob=new $APP.q(null,"emmy.tape","emmy.tape",1939677624,null);gob=new $APP.q("emmy.series","-\x3ePowerSeries","emmy.series/-\x3ePowerSeries",1728975685,null);DT=new $APP.q(null,"make-polar","make-polar",2147326621,null);hob=new $APP.q("emmy.env","make-Christoffel","emmy.env/make-Christoffel",445740966,null);eP=new $APP.E("emmy.calculus.form-field","oneform-field","emmy.calculus.form-field/oneform-field",790058519);ET=new $APP.q(null,"minus","minus",-43029965,null);
iob=new $APP.q("emmy.util","timeout-ex","emmy.util/timeout-ex",-1367120633,null);job=new $APP.q("cljs.core","seqable?","cljs.core/seqable?",-745394886,null);kob=new $APP.q(null,"log10","log10",891257803,null);lob=new $APP.q(null,"literal-function","literal-function",-1466238050,null);mob=new $APP.q(null,"frame?","frame?",-229419232,null);nob=new $APP.q(null,"state-\x3et","state-\x3et",460567876,null);oob=new $APP.q(null,"state-\x3eq","state-\x3eq",68587681,null);
pob=new $APP.q(null,"state-\x3ep","state-\x3ep",-1751204370,null);qob=new $APP.q("emmy.quaternion","cosh","emmy.quaternion/cosh",-1157111862,null);m6a=new $APP.q(null,"raise","raise",1824672588,null);rob=new $APP.q(null,"L3-central","L3-central",-1545087426,null);sob=new $APP.q("emmy.mechanics.hamilton","symplectic-unit","emmy.mechanics.hamilton/symplectic-unit",-95628681,null);tob=new $APP.q("emmy.env","pullback-form","emmy.env/pullback-form",34856191,null);
uob=new $APP.q("emmy.polynomial.factor","-\x3et_emmy$polynomial$factor49020","emmy.polynomial.factor/-\x3et_emmy$polynomial$factor49020",1777800549,null);vob=new $APP.q("emmy.mechanics.hamilton","H-harmonic","emmy.mechanics.hamilton/H-harmonic",-8379886,null);jK=new $APP.q(null,"asin","asin",-904130570,null);wob=new $APP.q("emmy.structure","typical-object","emmy.structure/typical-object",-1719684405,null);LD=new $APP.E(null,"init","init",-1875481434);
xob=new $APP.q(null,"segment?","segment?",1234224398,null);FT=new $APP.q(null,"continue","continue",1433184974,null);yob=new $APP.q(null,"-\x3eModInt","-\x3eModInt",-1177394650,null);zob=new $APP.q(null,"cos-half-angle-formula","cos-half-angle-formula",-1744663300,null);Aob=new $APP.q("emmy.env","curl","emmy.env/curl",1104521556,null);Bob=new $APP.q("emmy.pattern.rule","guard","emmy.pattern.rule/guard",2098710200,null);Cob=new $APP.q(null,"H-state?","H-state?",-1647143223,null);
Dob=new $APP.q(null,"state-\x3en-dof","state-\x3en-dof",766036380,null);Eob=new $APP.q(null,"principal-value","principal-value",-344542783,null);GT=new $APP.q(null,"Christoffel?","Christoffel?",977826934,null);oSa=new $APP.q("cljs.core","IVector","cljs.core/IVector",1711112835,null);pH=new $APP.q(null,"-two-pi","-two-pi",-50550974,null);Fob=new $APP.q("emmy.calculus.manifold","R2","emmy.calculus.manifold/R2",1557152115,null);
Gob=new $APP.q("emmy.calculus.manifold","R3","emmy.calculus.manifold/R3",619595120,null);Hob=new $APP.q("emmy.calculus.manifold","R4","emmy.calculus.manifold/R4",878101290,null);Iob=new $APP.q("emmy.calculus.manifold","Euler-angles","emmy.calculus.manifold/Euler-angles",1727658450,null);Job=new $APP.q("emmy.polynomial.richardson","richardson-sum","emmy.polynomial.richardson/richardson-sum",970645537,null);Kob=new $APP.q("emmy.calculus.manifold","R1","emmy.calculus.manifold/R1",-2040681754,null);
Lob=new $APP.q("emmy.pattern.rule","as-attempt","emmy.pattern.rule/as-attempt",72612861,null);P2a=new $APP.E("emmy.calculus.frame","owner","emmy.calculus.frame/owner",-1563689470);Mob=new $APP.q("emmy.env","Jacobian","emmy.env/Jacobian",1834978546,null);Nob=new $APP.q("emmy.mechanics.rigid","L-space","emmy.mechanics.rigid/L-space",2064820792,null);Oob=new $APP.q(null,"p-sequence","p-sequence",1101946304,null);Pob=new $APP.q(null,"covariant-differential","covariant-differential",-1899447919,null);
$APP.HT=new $APP.q(null,"present","present",415886062,null);Qob=new $APP.q(null,"three-vector-components-\x3eantisymmetric","three-vector-components-\x3eantisymmetric",690977266,null);Rob=new $APP.q("emmy.mechanics.lagrange","momentum-tuple","emmy.mechanics.lagrange/momentum-tuple",564528094,null);Sob=new $APP.q("emmy.calculus.manifold","patch-names","emmy.calculus.manifold/patch-names",2101754329,null);Tob=new $APP.q(null,"consequence","consequence",1638527189,null);
IT=new $APP.q(null,"maxiter","maxiter",-226692227,null);Uob=new $APP.q("emmy.env","S2-gnomonic","emmy.env/S2-gnomonic",1989839257,null);Vob=new $APP.q(null,"operator","operator",-220343811,null);Wob=new $APP.E(null,"protocol-deprecated","protocol-deprecated",103233497);Xob=new $APP.q("emmy.env","infinite?","emmy.env/infinite?",-1352545046,null);Yob=new $APP.q("emmy.quaternion","three-vector","emmy.quaternion/three-vector",829450905,null);
Zob=new $APP.q("emmy.calculus.manifold","Rn","emmy.calculus.manifold/Rn",-1207694986,null);$ob=new $APP.q(null,"colat","colat",-1900781322,null);apb=new $APP.q(null,"L-pendulum","L-pendulum",501843390,null);bpb=new $APP.q(null,"L-rectangular","L-rectangular",32091286,null);cpb=new $APP.q("emmy.polynomial.interpolate","modified-neville","emmy.polynomial.interpolate/modified-neville",-541175015,null);dpb=new $APP.q(null,"raise2","raise2",-1138595067,null);
epb=new $APP.q(null,"raise1","raise1",-2109852308,null);fpb=new $APP.q("emmy.env","Hodge-star","emmy.env/Hodge-star",1320905112,null);gpb=new $APP.q("emmy.calculus.manifold","S3","emmy.calculus.manifold/S3",892737402,null);hpb=new $APP.q("emmy.calculus.manifold","S1","emmy.calculus.manifold/S1",94678692,null);ipb=new $APP.q("emmy.calculus.manifold","S2","emmy.calculus.manifold/S2",-1354477707,null);
jpb=new $APP.q("emmy.polynomial.gcd","*poly-gcd-time-limit*","emmy.polynomial.gcd/*poly-gcd-time-limit*",-1624888697,null);kpb=new $APP.q("emmy.numerical.ode","evolve","emmy.numerical.ode/evolve",-220785197,null);lpb=new $APP.q(null,"richardson-column","richardson-column",1067781891,null);yYa=new $APP.E("emmy.pattern.rule","attempt?","emmy.pattern.rule/attempt?",1709760667);mpb=new $APP.q("emmy.quaternion","ONE","emmy.quaternion/ONE",-302160831,null);
npb=new $APP.q(null,"make-Christoffel","make-Christoffel",1480535635,null);JT=new $APP.q(null,"*rf-simplify*","*rf-simplify*",-1292516740,null);opb=new $APP.q("emmy.polynomial.richardson","richardson-sequence","emmy.polynomial.richardson/richardson-sequence",254452593,null);ppb=new $APP.q("emmy.env","log2","emmy.env/log2",1380937864,null);qpb=new $APP.q("emmy.env","coordinate-tuple","emmy.env/coordinate-tuple",-128064702,null);lSa=new $APP.q("cljs.core","IMap","cljs.core/IMap",1407777598,null);
KT=new $APP.q(null,"mu:N-\x3eM","mu:N-\x3eM",-1564575384,null);rpb=new $APP.q(null,"*divide-numbers-through-simplify?*","*divide-numbers-through-simplify?*",276306313,null);spb=new $APP.q("emmy.series","sinh-series","emmy.series/sinh-series",1317522346,null);tpb=new $APP.E(null,"preprocess","preprocess",1208285012);upb=new $APP.q("emmy.pattern.rule","iterated","emmy.pattern.rule/iterated",-253441051,null);vpb=new $APP.q("emmy.calculus.manifold","Sn","emmy.calculus.manifold/Sn",-1449239589,null);
LT=new $APP.q("cljs.core","IReversible","cljs.core/IReversible",-1422278012,null);wpb=new $APP.q(null,"bell","bell",2060210813,null);xpb=new $APP.q("emmy.series","sin-series","emmy.series/sin-series",-425555923,null);ypb=new $APP.q(null,"s-map","s-map",732813964,null);zpb=new $APP.q("emmy.env","r-\x3es","emmy.env/r-\x3es",-753530099,null);Apb=new $APP.q("emmy.env","r-\x3ep","emmy.env/r-\x3ep",-1093607092,null);Bpb=new $APP.q(null,"ONE","ONE",-1107326119,null);
Cpb=new $APP.q(null,"permute","permute",-199300448,null);PRa=new $APP.E(null,"invoke","invoke",1145927159);Dpb=new $APP.q("emmy.env","asinh","emmy.env/asinh",-742095466,null);p3a=new $APP.E(null,"coordinate-systems","coordinate-systems",-642340545);MT=new $APP.q(null,"orthonormalize?","orthonormalize?",1628658775,null);NT=new $APP.q(null,"relative-threshold","relative-threshold",-225607443,null);Epb=new $APP.q(null,"old-tag","old-tag",-1527675795,null);
Fpb=new $APP.q(null,"metric:invert","metric:invert",-709738857,null);Gpb=new $APP.q(null,"...","...",-1926939749,null);Hpb=new $APP.q(null,"Euler-Lagrange-operator","Euler-Lagrange-operator",-2048146756,null);Ipb=new $APP.q("emmy.special.elliptic","elliptic-pi","emmy.special.elliptic/elliptic-pi",-615608420,null);Jpb=new $APP.q(null,"proper-time-interval","proper-time-interval",-304271527,null);Kpb=new $APP.q(null,"up-\x3ecolumn-matrix","up-\x3ecolumn-matrix",1793835676,null);
V6a=new $APP.E(null,"pnodes","pnodes",1739080565);Lpb=new $APP.q("emmy.calculus.manifold","constant-manifold-function","emmy.calculus.manifold/constant-manifold-function",1049674971,null);Mpb=new $APP.q("emmy.calculus.manifold","S2-gnomonic","emmy.calculus.manifold/S2-gnomonic",268263198,null);Npb=new $APP.q(null,"keyvals","keyvals",-2067234787,null);Opb=new $APP.q("emmy.generic","sech","emmy.generic/sech",-1751135034,null);OT=new $APP.q(null,"orientation-matrix","orientation-matrix",-591482625,null);
Ppb=new $APP.q(null,"with-literal-functions","with-literal-functions",-1921576455,null);Qpb=new $APP.q(null,"multivariate?","multivariate?",-1200676278,null);Rpb=new $APP.q("cljs.core","ident?","cljs.core/ident?",1567441535,null);Spb=new $APP.q(null,"-\x3eLiteral","-\x3eLiteral",-67051922,null);Tpb=new $APP.q("emmy.sr.boost","four-tuple-\x3ect","emmy.sr.boost/four-tuple-\x3ect",251091581,null);Upb=new $APP.E(null,"suggested-symbol","suggested-symbol",-1329631875);
Vpb=new $APP.q("emmy.mechanics.hamilton","linear-function-\x3emultiplier","emmy.mechanics.hamilton/linear-function-\x3emultiplier",-1110494963,null);Wpb=new $APP.q(null,"qw-state-\x3eL-body","qw-state-\x3eL-body",31958610,null);Xpb=new $APP.q(null,"richardson-fold","richardson-fold",-768238887,null);Ypb=new $APP.q(null,"one-like","one-like",-1767302049,null);Zpb=new $APP.q(null,"L-space","L-space",-174468754,null);AE=new $APP.E(null,"macros","macros",811339431);
i4a=new $APP.q(null,"vf:zero","vf:zero",-742903868,null);$pb=new $APP.q("emmy.env","F-\x3eC","emmy.env/F-\x3eC",39292458,null);aqb=new $APP.q(null,"dual-zero","dual-zero",973357295,null);bqb=new $APP.q("emmy.env","Hamilton-equations","emmy.env/Hamilton-equations",1685848060,null);cqb=new $APP.q("emmy.expression.analyze","default-simplifier","emmy.expression.analyze/default-simplifier",-1029400406,null);
dqb=new $APP.q("emmy.expression.compile","compiler-mode","emmy.expression.compile/compiler-mode",2050922658,null);eqb=new $APP.E(null,"bulirsch-stoer-closed","bulirsch-stoer-closed",-1579787828);Zhb=new $APP.q("emmy.calculus.manifold","check-point","emmy.calculus.manifold/check-point",1850769069,null);PT=new $APP.q(null,"absolute-threshold","absolute-threshold",-1812236055,null);gqb=new $APP.q(null,"M-\x3eomega-body","M-\x3eomega-body",983228556,null);
hqb=new $APP.q("emmy.mechanics.rigid","M-of-q-\x3eomega-of-t","emmy.mechanics.rigid/M-of-q-\x3eomega-of-t",2073112316,null);iqb=new $APP.q("emmy.expression","compare","emmy.expression/compare",-1460444273,null);QT=new $APP.q(null,"selectors","selectors",959789759,null);jqb=new $APP.q("emmy.generic","-","emmy.generic/-",-1086485521,null);kqb=new $APP.q("emmy.generic","/","emmy.generic//",-2106270570,null);lqb=new $APP.q("emmy.generic","*","emmy.generic/*",1624468586,null);
mqb=new $APP.q("emmy.generic","+","emmy.generic/+",-2019921249,null);RT=new $APP.E(null,"open","open",-1763596448);nqb=new $APP.q(null,"local-state-derivative","local-state-derivative",-161819186,null);oqb=new $APP.q("emmy.rational-function","arg-shift","emmy.rational-function/arg-shift",-1657281136,null);pqb=new $APP.q(null,"*unchecked-arrays*","*unchecked-arrays*",-381849911,null);ST=new $APP.E(null,"positional","positional",-203580463);
qqb=new $APP.q("emmy.series","integral","emmy.series/integral",1400052131,null);rqb=new $APP.q("emmy.structure","basis-unit","emmy.structure/basis-unit",-186104379,null);sqb=new $APP.q(null,"update-frame","update-frame",-509780921,null);hF=new $APP.E(null,"fn-arity","fn-arity",-403576501);tqb=new $APP.q(null,"catalan-series","catalan-series",695607563,null);uqb=new $APP.q(null,"almost-integral?","almost-integral?",66142864,null);
vqb=new $APP.q("emmy.mechanics.lagrange","L-central-polar","emmy.mechanics.lagrange/L-central-polar",64463743,null);wqb=new $APP.q(null,"univariate-gcd","univariate-gcd",-754810104,null);xqb=new $APP.q("emmy.env","Gamma-bar","emmy.env/Gamma-bar",2059096836,null);Dab=new $APP.E("emmy.sr.frames","SR-coordinates?","emmy.sr.frames/SR-coordinates?",-568664156);yqb=new $APP.q(null,"-\x3et_emmy$rational_function48980","-\x3et_emmy$rational_function48980",-1980796130,null);
zqb=new $APP.q(null,"v-over-c","v-over-c",275370392,null);Aqb=new $APP.q("emmy.env","cube","emmy.env/cube",-673085262,null);TT=new $APP.E("emmy.collection","map","emmy.collection/map",-120400283);Bqb=new $APP.q("emmy.simplify.rules","odd-integer?","emmy.simplify.rules/odd-integer?",-709501751,null);Cqb=new $APP.q("emmy.env","R3-spherical","emmy.env/R3-spherical",-233418582,null);Dqb=new $APP.q("emmy.env","magnitude","emmy.env/magnitude",400507352,null);
Eqb=new $APP.q(null,"emmy.expression.analyze","emmy.expression.analyze",-1976783154,null);Fqb=new $APP.q(null,"bracket-min-scmutils","bracket-min-scmutils",1756130332,null);UT=new $APP.q(null,"initial-brent-guess","initial-brent-guess",-1867938358,null);Gib=new $APP.q("emmy.calculus.manifold","coords-\x3epoint","emmy.calculus.manifold/coords-\x3epoint",-505581765,null);Hqb=new $APP.E(null,"no-stacktrace?","no-stacktrace?",1701072694);S_a=new $APP.E(null,"nanos","nanos",-1777059258);
VT=new $APP.q(null,"compile?","compile?",813843877,null);Iqb=new $APP.q("emmy.mechanics.rigid","L-body-Euler","emmy.mechanics.rigid/L-body-Euler",82000386,null);Jqb=new $APP.q("emmy.util","longtype","emmy.util/longtype",1569625982,null);ORa=new $APP.E(null,"invoke-ctor","invoke-ctor",-756052704);oF=new $APP.E(null,"compilation","compilation",-1328774561);Kqb=new $APP.q("emmy.value","number?","emmy.value/number?",-2103383755,null);cRa=new $APP.E(null,"num-fields","num-fields",1529154024);
Lqb=new $APP.q(null,"symplectic-unit","symplectic-unit",54553914,null);WT=new $APP.q(null,"psi","psi",80412671,null);Mqb=new $APP.q("emmy.env","define-coordinates","emmy.env/define-coordinates",-327183607,null);Nqb=new $APP.q("emmy.polynomial.gcd","time-expired?","emmy.polynomial.gcd/time-expired?",98763553,null);Oqb=new $APP.q("v","scalar?","v/scalar?",1570437899,null);Pqb=new $APP.q("emmy.pattern.match","match-when","emmy.pattern.match/match-when",-607337179,null);
TH=new $APP.E("emmy.value","function","emmy.value/function",-1238426744);Qqb=new $APP.q("emmy.mechanics.hamilton","Lie-transform","emmy.mechanics.hamilton/Lie-transform",-1422742182,null);Rqb=new $APP.q("emmy.env","corresponding-velocities","emmy.env/corresponding-velocities",799939472,null);Sqb=new $APP.q("emmy.env","literal-Cartan","emmy.env/literal-Cartan",1749215073,null);Tqb=new $APP.q("emmy.value","numerical?","emmy.value/numerical?",68608154,null);
Uqb=new $APP.q("emmy.env","submatrix","emmy.env/submatrix",-80134854,null);Vqb=new $APP.q(null,"emmy.expression.render","emmy.expression.render",205266842,null);cF=new $APP.E(null,"numeric","numeric",-1495594714);l6a=new $APP.q(null,"lower","lower",-1534114948,null);Wqb=new $APP.q(null,"double-factorial","double-factorial",267781799,null);Xqb=new $APP.q(null,"this-frame","this-frame",797029280,null);Yqb=new $APP.q(null,"general-determinant","general-determinant",-464196132,null);
Zqb=new $APP.q("emmy.calculus.map","pullback","emmy.calculus.map/pullback",1601776300,null);$qb=new $APP.q(null,"L-harmonic","L-harmonic",-1439317414,null);arb=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer-fold","emmy.rational-function.interpolate/bulirsch-stoer-fold",969177736,null);XT=new $APP.q(null,"Christoffel","Christoffel",-408898581,null);brb=new $APP.E(null,"initial-guess","initial-guess",-1883142405);YE=new $APP.E(null,"target","target",253001721);
crb=new $APP.q("emmy.env","matrix-by-cols","emmy.env/matrix-by-cols",-232636262,null);drb=new $APP.q(null,"Hamiltonian-\x3estate-derivative","Hamiltonian-\x3estate-derivative",853341788,null);WYa=new $APP.q(null,"simsqrt2","simsqrt2",-1794028771,null);VYa=new $APP.q(null,"simsqrt1","simsqrt1",-1069513157,null);erb=new $APP.q("emmy.matrix","rsolve","emmy.matrix/rsolve",1132098145,null);frb=new $APP.q("emmy.special.factorial","factorial","emmy.special.factorial/factorial",2087946329,null);
grb=new $APP.q(null,"state-advancer","state-advancer",1461667085,null);hrb=new $APP.q(null,"argument-kind","argument-kind",1292297133,null);NVa=new $APP.E(null,"pattern","pattern",242135423);DVa=new $APP.E(null,"spying?","spying?",1753444487);FO=new $APP.E(null,"dimension","dimension",543254198);irb=new $APP.q(null,"ruleset*","ruleset*",2076462881,null);jrb=new $APP.q("emmy.polynomial","evenly-divide","emmy.polynomial/evenly-divide",-789717990,null);
T9a=new $APP.q(null,"Lie-transform","Lie-transform",1913072017,null);krb=new $APP.q("emmy.generic","determinant","emmy.generic/determinant",-491865139,null);lrb=new $APP.q("emmy.mechanics.lagrange","coordinate-tuple","emmy.mechanics.lagrange/coordinate-tuple",342016849,null);mrb=new $APP.q("cljs.core","regexp?","cljs.core/regexp?",-348418979,null);nrb=new $APP.q(null,"S2p-spherical","S2p-spherical",-596118512,null);orb=new $APP.q(null,"literal-up","literal-up",2121652004,null);
prb=new $APP.q("emmy.pattern.rule","!\x3d\x3e","emmy.pattern.rule/!\x3d\x3e",1335650556,null);qrb=new $APP.q("cljs.core","IChunkedSeq","cljs.core/IChunkedSeq",-892943716,null);rrb=new $APP.q("emmy.mechanics.lagrange","state-\x3eqdot","emmy.mechanics.lagrange/state-\x3eqdot",756716733,null);srb=new $APP.q("emmy.simplify.rules","trig:sum-\x3eproduct","emmy.simplify.rules/trig:sum-\x3eproduct",845041118,null);trb=new $APP.q(null,"template","template",938125843,null);
urb=new $APP.q("emmy.numsymb","operands","emmy.numsymb/operands",-200381602,null);vrb=new $APP.q("emmy.calculus.manifold","S2p-Riemann","emmy.calculus.manifold/S2p-Riemann",-1411756215,null);wrb=new $APP.q(null,"grow-limit","grow-limit",-524226826,null);xrb=new $APP.q(null,"S1-circular","S1-circular",-435145260,null);yrb=new $APP.q(null,"emmy.value","emmy.value",-940670323,null);zrb=new $APP.q("emmy.structure","same","emmy.structure/same",-444962107,null);aI=new $APP.E(null,"from","from",1815293044);
Arb=new $APP.q("emmy.mechanics.hamilton","iterated-map","emmy.mechanics.hamilton/iterated-map",-520393614,null);Brb=new $APP.q(null,"state0","state0",1595451039,null);Crb=new $APP.q("emmy.mechanics.hamilton","phase-space-derivative","emmy.mechanics.hamilton/phase-space-derivative",-2135919912,null);Drb=new $APP.q(null,"unsigned?","unsigned?",1137767373,null);Erb=new $APP.q("emmy.env","Lap","emmy.env/Lap",1550109480,null);Frb=new $APP.q("emmy.env","conjugate","emmy.env/conjugate",-1908388678,null);
Grb=new $APP.q(null,"REVERSE-EMPTY","REVERSE-EMPTY",-66425398,null);Hrb=new $APP.q(null,"qp-canonical?","qp-canonical?",-1589954108,null);Irb=new $APP.q("emmy.series","function-\x3e","emmy.series/function-\x3e",-214623649,null);Jrb=new $APP.q("emmy.env","Lagrangian-\x3eHamiltonian","emmy.env/Lagrangian-\x3eHamiltonian",-329281508,null);Krb=new $APP.q("emmy.dual","primal-tangent-pair","emmy.dual/primal-tangent-pair",-265703521,null);
Lrb=new $APP.q("emmy.series","generate","emmy.series/generate",-1600609312,null);Mrb=new $APP.q("emmy.env","velocity-tuple","emmy.env/velocity-tuple",353575488,null);Nrb=new $APP.q("emmy.env","base-frame-maker","emmy.env/base-frame-maker",2024760385,null);Orb=new $APP.q("emmy.generic","conjugate","emmy.generic/conjugate",-1786958144,null);Prb=new $APP.q(null,"S2p-gnomonic","S2p-gnomonic",-68458035,null);Qrb=new $APP.q("emmy.rational-function","mul","emmy.rational-function/mul",-1330903620,null);
Rrb=new $APP.q("emmy.mechanics.lagrange","Lagrangian-\x3eenergy","emmy.mechanics.lagrange/Lagrangian-\x3eenergy",-1663647966,null);Srb=new $APP.q("emmy.mechanics.lagrange","L-harmonic","emmy.mechanics.lagrange/L-harmonic",151173670,null);Trb=new $APP.q("emmy.env","Euler-\x3eM","emmy.env/Euler-\x3eM",-602689074,null);Urb=new $APP.q("emmy.env","torsion-vector","emmy.env/torsion-vector",-1580647989,null);Vrb=new $APP.E(null,"new","new",-2085437848);Wrb=new $APP.q(null,"-I","-I",-749163958,null);
Xrb=new $APP.q(null,"argument-types","argument-types",-1135318142,null);Yrb=new $APP.q("emmy.env","quotient","emmy.env/quotient",8215747,null);Zrb=new $APP.q("emmy.quaternion","cylindrical","emmy.quaternion/cylindrical",-586938286,null);$rb=new $APP.q(null,"-\x3eFunction","-\x3eFunction",-1491692950,null);asb=new $APP.q("emmy.numerical.unimin.bracket","bracket-min-scmutils","emmy.numerical.unimin.bracket/bracket-min-scmutils",-129617600,null);bsb=new $APP.E(null,"Euler-patch","Euler-patch",-700594077);
csb=new $APP.q(null,"*inhibit-expt-simplify*","*inhibit-expt-simplify*",-2053640743,null);esb=new $APP.q(null,"s:generate","s:generate",1698463663,null);fsb=new $APP.q(null,"stop-fn","stop-fn",1292059281,null);gsb=new $APP.q(null,"num-cols","num-cols",729489141,null);hsb=new $APP.q(null,"emmy.mechanics.rotation","emmy.mechanics.rotation",1705037628,null);isb=new $APP.q("emmy.mechanics.lagrange","literal-Lagrangian-state","emmy.mechanics.lagrange/literal-Lagrangian-state",1384430246,null);
jsb=new $APP.q("emmy.mechanics.lagrange","Gamma","emmy.mechanics.lagrange/Gamma",-1904787378,null);ksb=new $APP.E(null,"forward","forward",-557345303);lsb=new $APP.q("emmy.env","rotate-z-tuple","emmy.env/rotate-z-tuple",1935923167,null);msb=new $APP.q("emmy.value","INumericTower","emmy.value/INumericTower",-780252741,null);YT=new $APP.q(null,"assumption","assumption",-169353111,null);nsb=new $APP.q(null,"seq-limit","seq-limit",474615035,null);
osb=new $APP.q("emmy.sr.frames","coordinate-origin","emmy.sr.frames/coordinate-origin",2034721019,null);psb=new $APP.q("emmy.simplify.rules","log-contract","emmy.simplify.rules/log-contract",587382585,null);qsb=new $APP.q("emmy.simplify.rules","exp-contract","emmy.simplify.rules/exp-contract",455824928,null);rsb=new $APP.q(null,"as-matrix","as-matrix",157934886,null);ssb=new $APP.q("emmy.calculus.frame","make-event","emmy.calculus.frame/make-event",216916168,null);
tsb=new $APP.q(null,"new-frame","new-frame",-1748465223,null);ZT=new $APP.q(null,"arity","arity",-168024608,null);usb=new $APP.q("emmy.expression","make-literal","emmy.expression/make-literal",444883170,null);l7a=new $APP.E(null,"rewrite-trig-squares","rewrite-trig-squares",747917607);vsb=new $APP.q(null,"L-sliding-pend","L-sliding-pend",-21140854,null);wsb=new $APP.q("emmy.mechanics.rotation","rotate-y-matrix","emmy.mechanics.rotation/rotate-y-matrix",-1606320298,null);
xsb=new $APP.q("emmy.env","partial-sums","emmy.env/partial-sums",-781020439,null);ysb=new $APP.E(null,"println","println",1920840330);AQ=new $APP.E("emmy.numerical.quadrature.common","closed","emmy.numerical.quadrature.common/closed",-1976285246);zsb=new $APP.q(null,"basis-\x3evector-basis","basis-\x3evector-basis",-168519818,null);Asb=new $APP.q("emmy.mechanics.hamilton","J-func","emmy.mechanics.hamilton/J-func",552799566,null);
Bsb=new $APP.q("emmy.matrix","generate","emmy.matrix/generate",-1659566826,null);Csb=new $APP.q("emmy.pattern.syntax","unquoted-form","emmy.pattern.syntax/unquoted-form",1530248092,null);Dsb=new $APP.q("emmy.complex","I","emmy.complex/I",1737484988,null);Esb=new $APP.q(null,"S3-gnomonic","S3-gnomonic",-1897888682,null);Fsb=new $APP.q(null,"one-manifold-function","one-manifold-function",117769992,null);Gsb=new $APP.q(null,"log-expand","log-expand",763293820,null);
Hsb=new $APP.q("emmy.env","kind-predicate","emmy.env/kind-predicate",1454672761,null);Isb=new $APP.q("emmy.env","S2-Riemann","emmy.env/S2-Riemann",-5562070,null);Jsb=new $APP.q("emmy.mechanics.routhian","Lagrangian-state-\x3eRouthian-state","emmy.mechanics.routhian/Lagrangian-state-\x3eRouthian-state",765802201,null);$T=new $APP.q(null,"real-part","real-part",-2001752061,null);Ksb=new $APP.q(null,"to-basis","to-basis",1787878908,null);aU=new $APP.q(null,"??more","??more",-1836200365,null);
bU=new $APP.q(null,"stream","stream",-1119494121,null);Lsb=new $APP.q("emmy.mechanics.lagrange","T3-spherical","emmy.mechanics.lagrange/T3-spherical",1318160988,null);Msb=new $APP.q(null,"factorial","factorial",127776047,null);Nsb=new $APP.q(null,"make-SR-coordinates","make-SR-coordinates",-22454532,null);Osb=new $APP.q("emmy.structure","orientation","emmy.structure/orientation",1167918505,null);
Psb=new $APP.q("emmy.calculus.metric","coordinate-system-\x3einverse-metric","emmy.calculus.metric/coordinate-system-\x3einverse-metric",1724882308,null);Qsb=new $APP.q("emmy.env","coordinate-basis-vector-field","emmy.env/coordinate-basis-vector-field",-197518447,null);Rsb=new $APP.q("emmy.calculus.form-field","d","emmy.calculus.form-field/d",1695963856,null);mK=new $APP.q(null,"+pi-over-4","+pi-over-4",-1289502545,null);
Ssb=new $APP.q("emmy.mechanics.hamilton","transpose-function","emmy.mechanics.hamilton/transpose-function",1213459101,null);Tsb=new $APP.q("emmy.env","the-real-line","emmy.env/the-real-line",-777414225,null);Usb=new $APP.q("emmy.env","Christoffel-\x3eCartan","emmy.env/Christoffel-\x3eCartan",-1133165322,null);Vsb=new $APP.q(null,"power-series","power-series",-572905126,null);Wsb=new $APP.q("emmy.calculus.derivative","partial-reverse","emmy.calculus.derivative/partial-reverse",-617370816,null);
Xsb=new $APP.q(null,"rotate-y","rotate-y",1176649417,null);Ysb=new $APP.q(null,"rotate-z","rotate-z",933472,null);Zsb=new $APP.q("emmy.polynomial.gcd","univariate-gcd","emmy.polynomial.gcd/univariate-gcd",2080687552,null);WVa=new $APP.E(null,"appender-id","appender-id",-1917983538);Q6a=new $APP.E("zip","make-node","zip/make-node",1103800591);H5a=new $APP.E("emmy.calculus.covariant","Christoffel","emmy.calculus.covariant/Christoffel",428267637);
$sb=new $APP.q(null,"rotate-x","rotate-x",-1991735296,null);atb=new $APP.q(null,"cylindrospherical","cylindrospherical",893169674,null);btb=new $APP.q("emmy.rational-function","partial-derivative","emmy.rational-function/partial-derivative",-1700046016,null);fRa=new $APP.E(null,"fields","fields",-1932066230);ctb=new $APP.q("emmy.env","vector-field-\x3eoneform-field","emmy.env/vector-field-\x3eoneform-field",-818137644,null);
dtb=new $APP.q("emmy.special.factorial","falling-factorial","emmy.special.factorial/falling-factorial",-651306167,null);etb=new $APP.q("emmy.quaternion","sub","emmy.quaternion/sub",889140518,null);cU=new $APP.q(null,"domain","domain",-807220832,null);ftb=new $APP.q(null,"rotate-y-matrix","rotate-y-matrix",1752319055,null);gtb=new $APP.q("emmy.matrix","diagonal","emmy.matrix/diagonal",794363528,null);htb=new $APP.q("emmy.algebra.fold","count","emmy.algebra.fold/count",630331933,null);
itb=new $APP.q("emmy.quaternion","evaluate","emmy.quaternion/evaluate",1823777220,null);jtb=new $APP.q("emmy.rational-function","analyzer","emmy.rational-function/analyzer",562799325,null);ktb=new $APP.q("emmy.mechanics.rotation","rotate-x","emmy.mechanics.rotation/rotate-x",1094708537,null);ltb=new $APP.q("emmy.mechanics.rotation","rotate-z","emmy.mechanics.rotation/rotate-z",1209918745,null);mtb=new $APP.q("emmy.mechanics.rotation","rotate-y","emmy.mechanics.rotation/rotate-y",506582518,null);
ntb=new $APP.q(null,"add-velocities","add-velocities",1395500614,null);otb=new $APP.E(null,"unsupported-preprocess-value","unsupported-preprocess-value",1635147105);ptb=new $APP.q(null,"fn-tolerance","fn-tolerance",194925363,null);qtb=new $APP.q("emmy.env","dot-product","emmy.env/dot-product",-1392257953,null);OG=new $APP.E(null,"output-fn","output-fn",1600951539);rtb=new $APP.q("emmy.polynomial.gcd","gcd-stats","emmy.polynomial.gcd/gcd-stats",1396556642,null);
stb=new $APP.q("emmy.util.aggregate","pairwise-sum","emmy.util.aggregate/pairwise-sum",-678185942,null);ttb=new $APP.q(null,"*incremental-simplifier*","*incremental-simplifier*",231067924,null);utb=new $APP.q("emmy.expression","abstract-types","emmy.expression/abstract-types",-1816084977,null);vtb=new $APP.q("emmy.mechanics.lagrange","Lagrange-equations-operator","emmy.mechanics.lagrange/Lagrange-equations-operator",29259867,null);
wtb=new $APP.q(null,"basis-components-\x3eoneform-field","basis-components-\x3eoneform-field",785978786,null);xtb=new $APP.q(null,"-\x3et_emmy$polynomial48706","-\x3et_emmy$polynomial48706",678078110,null);ytb=new $APP.q("emmy.pattern.rule","template","emmy.pattern.rule/template",1191187487,null);ztb=new $APP.q(null,"quaternion-state-\x3eomega-body","quaternion-state-\x3eomega-body",1179732597,null);MK=new $APP.E(null,"subtype","subtype",-2092672993);
Atb=new $APP.q("emmy.dual","-\x3eCompleted","emmy.dual/-\x3eCompleted",-43704959,null);Btb=new $APP.q("emmy.mechanics.hamilton","-\x3eH-state","emmy.mechanics.hamilton/-\x3eH-state",1385304134,null);Ctb=new $APP.q(null,"emmy.polynomial.interpolate","emmy.polynomial.interpolate",-1804382523,null);Dtb=new $APP.q(null,"velocity","velocity",1059007172,null);dU=new $APP.q(null,"arg-scale","arg-scale",-828801718,null);Etb=new $APP.q("emmy.env","partial-forward","emmy.env/partial-forward",-526740990,null);
Ftb=new $APP.q("emmy.generic","outer-product","emmy.generic/outer-product",-1055965769,null);Gtb=new $APP.q("emmy.special.elliptic","k-and-deriv","emmy.special.elliptic/k-and-deriv",411204883,null);Htb=new $APP.q("emmy.simplify.rules","*inverse-simplify?*","emmy.simplify.rules/*inverse-simplify?*",1030704636,null);Itb=new $APP.q("emmy.matrix","solve","emmy.matrix/solve",-521544751,null);Jtb=new $APP.q("emmy.rational-function","square","emmy.rational-function/square",-1370743621,null);
Ktb=new $APP.q("emmy.env","solve-linear","emmy.env/solve-linear",-653183971,null);Ltb=new $APP.q(null,"expression-analyzer","expression-analyzer",1165025557,null);Mtb=new $APP.q(null,"H-central-polar","H-central-polar",37104917,null);Ntb=new $APP.q("emmy.env","four-tuple-\x3ect","emmy.env/four-tuple-\x3ect",-610797870,null);Ptb=new $APP.q(null,"F-\x3eCT","F-\x3eCT",-1012552178,null);jjb=new $APP.q(null,"meta57548","meta57548",-1005544700,null);
Jlb=new $APP.q(null,"meta57540","meta57540",395824138,null);Rtb=new $APP.q(null,"F-\x3eCH","F-\x3eCH",404198748,null);eU=new $APP.E(null,"jsdoc","jsdoc",1745183516);Stb=new $APP.q("emmy.polynomial.gcd","gcd","emmy.polynomial.gcd/gcd",-909213703,null);Ttb=new $APP.q("emmy.calculus.basis","vector-basis-\x3edual","emmy.calculus.basis/vector-basis-\x3edual",-1119249214,null);Utb=new $APP.q("emmy.env","partial-derivative","emmy.env/partial-derivative",-841620326,null);
Vtb=new $APP.q(null,"log2","log2",-1850656939,null);Wtb=new $APP.q("emmy.series","series","emmy.series/series",-837260996,null);Xtb=new $APP.q(null,"oneform-field-\x3evector-field","oneform-field-\x3evector-field",-1253191494,null);$APP.fU=new $APP.q(null,"point","point",-841237505,null);Ytb=new $APP.q("emmy.generic","Lie-derivative","emmy.generic/Lie-derivative",-1383110342,null);fqb=new $APP.q(null,"meta57535","meta57535",-1636413105,null);
cab=new $APP.q(null,"array-reduce","array-reduce",154113968,null);$tb=new $APP.q("emmy.simplify.rules","odd-positive-integer?","emmy.simplify.rules/odd-positive-integer?",-47331359,null);aub=new $APP.q("emmy.env","make-SR-coordinates","emmy.env/make-SR-coordinates",860815649,null);Gqb=new $APP.q(null,"meta57525","meta57525",-808360572,null);cub=new $APP.E(null,"midpoint","midpoint",-36269525);dub=new $APP.q("emmy.structure","kronecker","emmy.structure/kronecker",-1820129971,null);
EUa=new $APP.E(null,"deny-spec","deny-spec",-1074984268);eub=new $APP.q("emmy.pattern.syntax","restricted?","emmy.pattern.syntax/restricted?",-1782073038,null);fub=new $APP.q(null,"arithmetic-ex","arithmetic-ex",2003781159,null);gub=new $APP.q("emmy.mechanics.hamilton","Hamiltonian-\x3estate-derivative","emmy.mechanics.hamilton/Hamiltonian-\x3estate-derivative",1170764435,null);iub=new $APP.q(null,"*poly-gcd-cache-enable*","*poly-gcd-cache-enable*",-1934378538,null);
Otb=new $APP.q(null,"meta57517","meta57517",1083982771,null);jub=new $APP.q(null,"k__36707__auto__","k__36707__auto__",-1629528592,null);lQ=new $APP.E(null,"maxiter","maxiter",-1867223754);kub=new $APP.q(null,"curl","curl",213545217,null);lub=new $APP.q("emmy.expression.compile","validate-mode!","emmy.expression.compile/validate-mode!",2085105166,null);mub=new $APP.q(null,"kbn","kbn",-176972830,null);
nub=new $APP.q(null,"coordinate-system-\x3einverse-metric","coordinate-system-\x3einverse-metric",1607613774,null);zE=new $APP.E(null,"use-macros","use-macros",-905638393);oub=new $APP.q("emmy.env","Cartan?","emmy.env/Cartan?",-603061185,null);pub=new $APP.E(null,"hours","hours",58380855);qub=new $APP.q("emmy.env","extended-rotation","emmy.env/extended-rotation",1609247994,null);rub=new $APP.q("emmy.series","tan-series","emmy.series/tan-series",837840721,null);
sub=new $APP.q("emmy.numsymb","symbolic-operator","emmy.numsymb/symbolic-operator",1626790775,null);tub=new $APP.q(null,"object-name-map","object-name-map",-812683425,null);uub=new $APP.q(null,"illegal-state","illegal-state",120680345,null);vub=new $APP.q(null,"emmy.mechanics.lagrange","emmy.mechanics.lagrange",288531855,null);wub=new $APP.q("emmy.env","golden-section-min","emmy.env/golden-section-min",-305772320,null);
xub=new $APP.q("emmy.mechanics.hamilton","standard-map-inverse","emmy.mechanics.hamilton/standard-map-inverse",34690720,null);yub=new $APP.q("emmy.env","Grad","emmy.env/Grad",-411848947,null);zub=new $APP.q("emmy.pattern.rule","rule*","emmy.pattern.rule/rule*",192682942,null);Bub=new $APP.q("emmy.env","Ricci","emmy.env/Ricci",-126627823,null);Qtb=new $APP.q(null,"meta57507","meta57507",1388260149,null);IE=new $APP.E(null,"context","context",-830191113);
Cub=new $APP.q("emmy.env","simplify","emmy.env/simplify",2104690809,null);Dub=new $APP.q(null,"derivative","derivative",-1233120304,null);Eub=new $APP.q("emmy.sr.boost","extended-rotation","emmy.sr.boost/extended-rotation",176702373,null);Fub=new $APP.q("emmy.pattern.rule","ruleset*","emmy.pattern.rule/ruleset*",-886313707,null);qVa=new $APP.E(null,"msg-type","msg-type",-2132567822);Gub=new $APP.q("emmy.env","tanhc","emmy.env/tanhc",-961031083,null);
Hub=new $APP.q("emmy.env","vf:zero","emmy.env/vf:zero",-1860540553,null);Iub=new $APP.q("emmy.expression.analyze","expression-\x3e","emmy.expression.analyze/expression-\x3e",-2017023069,null);gU=new $APP.q(null,"make","make",356488202,null);Jub=new $APP.q("emmy.numerical.derivative","forward-difference","emmy.numerical.derivative/forward-difference",-764307413,null);Kub=new $APP.q("emmy.quaternion","q-div-scalar","emmy.quaternion/q-div-scalar",-1093761009,null);
Lub=new $APP.q(null,"G__42953","G__42953",-760643166,null);Mub=new $APP.q(null,"emmy.ratio","emmy.ratio",1125351397,null);Nub=new $APP.q(null,"literal-apply","literal-apply",-411755029,null);Oub=new $APP.q(null,"*poly-gcd-time-limit*","*poly-gcd-time-limit*",-131795633,null);Pub=new $APP.q("emmy.quaternion","tan","emmy.quaternion/tan",-574658076,null);Qub=new $APP.q("emmy.calculus.connection","metric-\x3econnection-2","emmy.calculus.connection/metric-\x3econnection-2",1719273556,null);
Rub=new $APP.q("emmy.calculus.connection","metric-\x3econnection-1","emmy.calculus.connection/metric-\x3econnection-1",-720939870,null);hU=new $APP.q("emmy.dual","IPerturbed","emmy.dual/IPerturbed",-340126679,null);Sub=new $APP.q(null,"Euler-state-\x3eomega-body","Euler-state-\x3eomega-body",949502059,null);t8a=new $APP.E(null,"unexpected","unexpected",-1137752424);Tub=new $APP.q("cljs.core","volatile?","cljs.core/volatile?",-1122186415,null);
Uub=new $APP.q(null,"typed-\x3estructure","typed-\x3estructure",1731883948,null);Vub=new $APP.q("emmy.mechanics.hamilton","qp-submatrix","emmy.mechanics.hamilton/qp-submatrix",1013050217,null);Wub=new $APP.q("emmy.rational-function","expression-\x3e","emmy.rational-function/expression-\x3e",628800854,null);W6a=new $APP.E(null,"changed?","changed?",-437828330);Xub=new $APP.q("emmy.pattern.match","bind","emmy.pattern.match/bind",507325627,null);
iU=new $APP.q(null,"v-compare","v-compare",-1787498040,null);Yub=new $APP.q("emmy.generic","angle","emmy.generic/angle",-1766806104,null);Zub=new $APP.q("emmy.util.stream","powers","emmy.util.stream/powers",1499305441,null);$ub=new $APP.q("emmy.mechanics.lagrange","velocities","emmy.mechanics.lagrange/velocities",-1648090729,null);avb=new $APP.q(null,"mapr","mapr",-483178594,null);bvb=new $APP.q("emmy.polynomial.interpolate","neville-sum","emmy.polynomial.interpolate/neville-sum",1443576906,null);
YXa=new $APP.q(null,"$$","$$",-1388085599,null);cvb=new $APP.q("emmy.pattern.match","predicate","emmy.pattern.match/predicate",1055232176,null);dvb=new $APP.q("emmy.polynomial","add","emmy.polynomial/add",-549260368,null);evb=new $APP.q("emmy.structure","*allow-incompatible-multiplication*","emmy.structure/*allow-incompatible-multiplication*",872974539,null);fvb=new $APP.q("emmy.calculus.basis","basis-\x3edimension","emmy.calculus.basis/basis-\x3edimension",-34013778,null);
gvb=new $APP.q("emmy.calculus.map","pushforward-vector","emmy.calculus.map/pushforward-vector",-1537800027,null);hvb=new $APP.q(null,"scan","scan",1311631423,null);ivb=new $APP.q(null,"unit?","unit?",-1881833431,null);jvb=new $APP.q(null,"structure-\x3eaccess-chains","structure-\x3eaccess-chains",-204414988,null);Ztb=new $APP.E(null,"point-\x3ecoords","point-\x3ecoords",1312461607);lvb=new $APP.q(null,"from-complex","from-complex",-1001613936,null);
NYa=new $APP.q(null,"logexp2","logexp2",-1768907713,null);mvb=new $APP.q(null,"pullback-vector-field","pullback-vector-field",2082593527,null);nvb=new $APP.q("emmy.calculus.manifold","S2p-gnomonic","emmy.calculus.manifold/S2p-gnomonic",-1302991049,null);ovb=new $APP.q(null,"macroexpand-check","macroexpand-check",699092091,null);pvb=new $APP.q(null,"Christoffel-\x3esymbols","Christoffel-\x3esymbols",-397563291,null);
qvb=new $APP.q("emmy.calculus.vector-field","vector-field-\x3ebasis-components","emmy.calculus.vector-field/vector-field-\x3ebasis-components",-1306923308,null);MJ=new $APP.q(null,"?new-n","?new-n",-1095502685,null);rvb=new $APP.q(null,"oneform-field","oneform-field",119367957,null);svb=new $APP.q(null,"structure-\x3ematrix","structure-\x3ematrix",1147394120,null);$APP.WD=new $APP.E(null,"order","order",-1254677256);
tvb=new $APP.q("emmy.mechanics.rigid","rigid-sysder","emmy.mechanics.rigid/rigid-sysder",-844995161,null);uvb=new $APP.q(null,"basis-\x3ebasis-over-map","basis-\x3ebasis-over-map",-689512767,null);vvb=new $APP.q(null,"exact?","exact?",-2028776167,null);wvb=new $APP.q(null,"patterns-and-consequences","patterns-and-consequences",-675483795,null);xvb=new $APP.q("emmy.ratio","parse-ratio","emmy.ratio/parse-ratio",1512919462,null);
yvb=new $APP.q(null,"Christoffel-\x3eCartan","Christoffel-\x3eCartan",-24052573,null);zvb=new $APP.q("emmy.env","Gamma","emmy.env/Gamma",-368697251,null);Avb=new $APP.q("cljs.core","Inst","cljs.core/Inst",959205835,null);Bvb=new $APP.q("emmy.value","Numerical","emmy.value/Numerical",-531724654,null);QVa=new $APP.E(null,"timestamp-opts","timestamp-opts",-1359534807);Cvb=new $APP.q(null,"literal-column-matrix","literal-column-matrix",-1078794984,null);Dvb=new $APP.q(null,"tex$$","tex$$",275226341,null);
Evb=new $APP.q("emmy.series","series?","emmy.series/series?",1613808352,null);Fvb=new $APP.q("emmy.env","golden-section-max","emmy.env/golden-section-max",-945786394,null);Gvb=new $APP.q(null,"acot-series","acot-series",2130004200,null);Hvb=new $APP.q(null,"coord-sys","coord-sys",-674266314,null);oZa=new $APP.q(null,"atan-tan","atan-tan",-478846145,null);Ivb=new $APP.q(null,"raise-arity","raise-arity",1424406691,null);
Jvb=new $APP.q("emmy.structure","two-tensor-info","emmy.structure/two-tensor-info",-1647106255,null);Kvb=new $APP.q("emmy.env","identity-like","emmy.env/identity-like",425106033,null);Lvb=new $APP.E(null,"mid","mid",-2123385246);Mvb=new $APP.q(null,"mass","mass",-498418519,null);Nvb=new $APP.q("emmy.series","series*","emmy.series/series*",1027930493,null);MYa=new $APP.q(null,"logexp1","logexp1",-1360132001,null);
Ovb=new $APP.q("emmy.numerical.derivative","D-numeric","emmy.numerical.derivative/D-numeric",-1153804284,null);jU=new $APP.E(null,"imported-from","imported-from",1590463704);Pvb=new $APP.q(null,"IPerturbed","IPerturbed",-1705959821,null);Qvb=new $APP.E(null,"exprs","exprs",1795829094);Rvb=new $APP.q(null,"dual?","dual?",-1114580629,null);Svb=new $APP.q("emmy.mechanics.hamilton","T-func","emmy.mechanics.hamilton/T-func",1164287767,null);
Tvb=new $APP.q("emmy.mechanics.hamilton","symplectic-two-form","emmy.mechanics.hamilton/symplectic-two-form",753890769,null);Uvb=new $APP.q("emmy.quaternion","from-angle-axis","emmy.quaternion/from-angle-axis",-35417977,null);Vvb=new $APP.q("emmy.generic","transpose","emmy.generic/transpose",-1456344334,null);Wvb=new $APP.q("emmy.env","sqrt","emmy.env/sqrt",-654878317,null);Xvb=new $APP.q(null,"skeleton","skeleton",-126504426,null);
Yvb=new $APP.q("emmy.mechanics.lagrange","-\x3eL-state","emmy.mechanics.lagrange/-\x3eL-state",-1643104361,null);Zvb=new $APP.q(null,"S2p-stereographic","S2p-stereographic",1252985877,null);$vb=new $APP.q(null,"euler","euler",1830471499,null);VO=new $APP.E(null,"arguments","arguments",-1182834456);Z$a=new $APP.E(null,"tolerance","tolerance",406811818);awb=new $APP.q("emmy.env","exact?","emmy.env/exact?",-1040802314,null);bwb=new $APP.q(null,"meta49021","meta49021",1889202451,null);
cwb=new $APP.q(null,"basis-\x3ecoordinate-system","basis-\x3ecoordinate-system",-1847737797,null);dwb=new $APP.E(null,"no-op","no-op",-93046065);ewb=new $APP.q(null,"symplectic-transform?","symplectic-transform?",-597154357,null);fwb=new $APP.q(null,"LE","LE",1319258661,null);gwb=new $APP.q(null,"sumr","sumr",302547133,null);hwb=new $APP.q("emmy.polynomial.richardson","richardson-column","emmy.polynomial.richardson/richardson-column",1739669134,null);iwb=new $APP.E(null,"simpson38","simpson38",-754529919);
jwb=new $APP.q("emmy.mechanics.lagrange","Dt","emmy.mechanics.lagrange/Dt",-1268615967,null);kwb=new $APP.q(null,"L-central-rectangular","L-central-rectangular",613723220,null);lwb=new $APP.q(null,"foreach","foreach",1221441146,null);mwb=new $APP.q("emmy.env","csch","emmy.env/csch",-914429636,null);nwb=new $APP.q(null,"reverse-segment","reverse-segment",-571699043,null);owb=new $APP.q("emmy.mechanics.lagrange","L-two-particle","emmy.mechanics.lagrange/L-two-particle",971498539,null);
pwb=new $APP.q(null,"polar-canonical","polar-canonical",-1550139768,null);qwb=new $APP.q("emmy.mechanics.lagrange","qv-\x3elocal-path","emmy.mechanics.lagrange/qv-\x3elocal-path",-1275417780,null);rwb=new $APP.q(null,"rotate-z-tuple","rotate-z-tuple",-1312708500,null);swb=new $APP.q("emmy.polynomial","map-exponents","emmy.polynomial/map-exponents",230746221,null);twb=new $APP.q(null,"S2-metric","S2-metric",1081044753,null);uwb=new $APP.q(null,"event-\x3ecoords","event-\x3ecoords",-81360503,null);
vwb=new $APP.q("emmy.env","-\x3elocal","emmy.env/-\x3elocal",10264939,null);wwb=new $APP.q("emmy.series","constant","emmy.series/constant",-2136577855,null);xwb=new $APP.q("emmy.pattern.match","pass","emmy.pattern.match/pass",2021981941,null);ywb=new $APP.q("emmy.calculus.derivative","partial","emmy.calculus.derivative/partial",-920700913,null);zwb=new $APP.q("emmy.generic","asech","emmy.generic/asech",-1327326229,null);
Awb=new $APP.q("emmy.mechanics.lagrange","LE","emmy.mechanics.lagrange/LE",-1352752575,null);Bwb=new $APP.q("matrix","antisymmetric?","matrix/antisymmetric?",-1425081311,null);kU=new $APP.q("cljs.core","IEquiv","cljs.core/IEquiv",-1245752602,null);Cwb=new $APP.q("emmy.polynomial.interpolate","neville","emmy.polynomial.interpolate/neville",1611538742,null);Dwb=new $APP.q("emmy.calculus.manifold","alternate-angles","emmy.calculus.manifold/alternate-angles",-1388506517,null);
LK=new $APP.q(null,"component","component",-1098498987,null);Ewb=new $APP.q(null,"Cartan-transform","Cartan-transform",397778116,null);Fwb=new $APP.q("emmy.mechanics.lagrange","velocity-tuple","emmy.mechanics.lagrange/velocity-tuple",-236731791,null);Gwb=new $APP.q("emmy.mechanics.lagrange","Lagrange-equations-first-order","emmy.mechanics.lagrange/Lagrange-equations-first-order",-647102082,null);v5a=new $APP.q(null,"make-fake-vector-field","make-fake-vector-field",-1146565625,null);
SZa=new $APP.E(null,"outer-orientation","outer-orientation",-985566313);Hwb=new $APP.q("emmy.numerical.unimin.golden","inv-phi","emmy.numerical.unimin.golden/inv-phi",1708835685,null);Iwb=new $APP.q("emmy.mechanics.lagrange","s-\x3er","emmy.mechanics.lagrange/s-\x3er",937839797,null);Jwb=new $APP.q(null,"with-lower-arity","with-lower-arity",2056753154,null);Kwb=new $APP.q(null,"js?","js?",-1922587099,null);Lwb=new $APP.q(null,"var-meta","var-meta",785035777,null);
Mwb=new $APP.E(null,"literal?","literal?",352485871);lU=new $APP.q(null,"fold","fold",753070195,null);Nwb=new $APP.q("emmy.env","acceleration-tuple","emmy.env/acceleration-tuple",-1309226785,null);$APP.BQ=new $APP.E(null,"interval","interval",1708495417);Owb=new $APP.q("emmy.expression","expression-\x3estream","emmy.expression/expression-\x3estream",-1331609557,null);Pwb=new $APP.q("emmy.calculus.derivative","D","emmy.calculus.derivative/D",-645610427,null);
Qwb=new $APP.q("emmy.calculus.curvature","torsion","emmy.calculus.curvature/torsion",1761460222,null);Rwb=new $APP.q(null,"kind-predicate","kind-predicate",336774062,null);Swb=new $APP.q(null,"R1","R1",1595616472,null);Twb=new $APP.q("emmy.generic","exp","emmy.generic/exp",99355250,null);Uwb=new $APP.q(null,"R2","R2",51758745,null);Vwb=new $APP.q(null,"R3","R3",-72629094,null);Wwb=new $APP.q(null,"R4","R4",-879475264,null);VOa=new $APP.E(null,"module","module",1424618191);
Xwb=new $APP.q("emmy.matrix","s:solve-linear-right","emmy.matrix/s:solve-linear-right",2083145779,null);Ywb=new $APP.q(null,"emmy.polynomial.richardson","emmy.polynomial.richardson",-1983697181,null);Zwb=new $APP.q(null,"S1","S1",1013002370,null);mU=new $APP.q(null,"orientation","orientation",-2030878190,null);$wb=new $APP.q(null,"Euler-state-\x3eL-body","Euler-state-\x3eL-body",-1827575539,null);
axb=new $APP.q("emmy.mechanics.lagrange","rectangular-\x3espherical","emmy.mechanics.lagrange/rectangular-\x3espherical",1575230615,null);nU=new $APP.q(null,"coordinate-prototype","coordinate-prototype",-1149174049,null);bxb=new $APP.q(null,"coordinate","coordinate",1527720318,null);cxb=new $APP.q("emmy.mechanics.lagrange","-\x3estate","emmy.mechanics.lagrange/-\x3estate",-74084632,null);dxb=new $APP.q(null,"S2","S2",1434700047,null);exb=new $APP.q(null,"S3","S3",1919527328,null);
fxb=new $APP.q("emmy.expression","variables-in","emmy.expression/variables-in",-1256051564,null);gxb=new $APP.q("emmy.calculus.manifold","S1-slope","emmy.calculus.manifold/S1-slope",-27432147,null);hxb=new $APP.q("emmy.simplify.rules","sin-sq-\x3ecos-sq","emmy.simplify.rules/sin-sq-\x3ecos-sq",542981601,null);ixb=new $APP.q(null,"fork","fork",-1591461534,null);jxb=new $APP.q(null,"bracket-max","bracket-max",-1833956158,null);kxb=new $APP.q(null,"Rn","Rn",1925679884,null);
lxb=new $APP.q(null,"T1","T1",-1863234891,null);mxb=new $APP.q(null,"T2","T2",-986451912,null);nxb=new $APP.q(null,"next-p-fn","next-p-fn",1114419574,null);oxb=new $APP.q(null,"Rx","Rx",410881441,null);oU=new $APP.q("cljs.core","ICollection","cljs.core/ICollection",802638471,null);pxb=new $APP.q("emmy.generic","exact-zero?","emmy.generic/exact-zero?",-116345427,null);qxb=new $APP.q("emmy.calculus.manifold","spacetime-sphere","emmy.calculus.manifold/spacetime-sphere",175578561,null);
rxb=new $APP.q(null,"RationalFunction","RationalFunction",1491561426,null);sxb=new $APP.q(null,"Ry","Ry",249628162,null);txb=new $APP.q(null,"Rz","Rz",-1950648434,null);uxb=new $APP.q(null,"Sn","Sn",-153298683,null);vxb=new $APP.E(null,"open-closed","open-closed",-1293256622);bub=new $APP.q(null,"attach-coordinate-system","attach-coordinate-system",-1382768242,null);xxb=new $APP.q(null,"-\x3elocal","-\x3elocal",1172465974,null);yxb=new $APP.q(null,"make-SR-frame","make-SR-frame",-949574673,null);
zxb=new $APP.q(null,"abstract?","abstract?",1420943811,null);w2a=new $APP.q(null,"UP","UP",-1898089532,null);Axb=new $APP.q(null,"Numerical","Numerical",390792779,null);Bxb=new $APP.q("emmy.calculus.frame","frame?","emmy.calculus.frame/frame?",813579663,null);hub=new $APP.q(null,"meta57498","meta57498",-1099280507,null);Dxb=new $APP.q("emmy.calculus.manifold","manifold-family?","emmy.calculus.manifold/manifold-family?",-1403588078,null);
Exb=new $APP.q("emmy.env","contract","emmy.env/contract",754783939,null);Fxb=new $APP.q("emmy.simplify.rules","*expt-half-\x3esqrt?*","emmy.simplify.rules/*expt-half-\x3esqrt?*",-390949078,null);Gxb=new $APP.E(null,"undeclared-macros-ns","undeclared-macros-ns",-438029430);Hxb=new $APP.q("emmy.env","qp-submatrix","emmy.env/qp-submatrix",-1544308977,null);Ixb=new $APP.q("emmy.env","wcross-\x3ew","emmy.env/wcross-\x3ew",945092694,null);
Jxb=new $APP.q(null,"make-Christoffel-1","make-Christoffel-1",77741028,null);Kxb=new $APP.q(null,"momentum-tuple","momentum-tuple",-27972686,null);Mxb=new $APP.E(null,"romberg","romberg",609723434);Aub=new $APP.q(null,"meta57487","meta57487",925432735,null);aYa=new $APP.E("emmy.pattern.consequence","succeed","emmy.pattern.consequence/succeed",519698243);pU=new $APP.q(null,"","",-210042210,null);Nxb=new $APP.q("emmy.env","S1-slope","emmy.env/S1-slope",-408543850,null);
Oxb=new $APP.q(null,"","",-1396568965,null);kSa=new $APP.E(null,"vals","vals",768058733);Pxb=new $APP.q(null,"symbolic-taylor-series","symbolic-taylor-series",-622675349,null);kvb=new $APP.q(null,"meta57471","meta57471",-430702081,null);Rxb=new $APP.q(null,"*strict-arity-checks*","*strict-arity-checks*",816380251,null);Sxb=new $APP.E(null,"current-symbol","current-symbol",-932381075);z2a=new $APP.q(null,"X*","X*",1047022815,null);Txb=new $APP.q(null,"Vr","Vr",1917258557,null);
Vxb=new $APP.q("emmy.rational-function","make","emmy.rational-function/make",1765232261,null);wxb=new $APP.q(null,"meta57476","meta57476",-559506509,null);Wxb=new $APP.q("emmy.mechanics.hamilton","H-rectangular","emmy.mechanics.hamilton/H-rectangular",-413726828,null);Xxb=new $APP.q(null,"Euler-\x3eomega-body","Euler-\x3eomega-body",84295533,null);Yxb=new $APP.q(null,"sin-sq-\x3ecos-sq","sin-sq-\x3ecos-sq",1625924925,null);
Zxb=new $APP.q("emmy.polynomial.interpolate","neville-recursive","emmy.polynomial.interpolate/neville-recursive",-468921529,null);$xb=new $APP.q("emmy.complex","ONE","emmy.complex/ONE",581834791,null);ayb=new $APP.q(null,"bracket-min","bracket-min",-1880863081,null);dQa=new $APP.q("cljs.core","implements?","cljs.core/implements?",-251485149,null);byb=new $APP.q(null,"qw-state-\x3eL-space","qw-state-\x3eL-space",347488469,null);lRa=new $APP.E("cljs.analyzer","list","cljs.analyzer/list",-539585923);
cyb=new $APP.q("emmy.env","m-\x3es","emmy.env/m-\x3es",220788748,null);dyb=new $APP.q(null,"-\x3eStructure","-\x3eStructure",-1170287724,null);eyb=new $APP.q("emmy.mechanics.rotation","rotate-z-tuple","emmy.mechanics.rotation/rotate-z-tuple",-909229189,null);RR=new $APP.E(null,"origin","origin",1037372088);fyb=new $APP.q(null,"available-methods","available-methods",96037987,null);gyb=new $APP.q("emmy.calculus.vector-field","vf:zero","emmy.calculus.vector-field/vf:zero",-1835394610,null);
hyb=new $APP.q(null,"argument","argument",-1471433928,null);iyb=new $APP.q("emmy.env","log","emmy.env/log",-1068738128,null);jyb=new $APP.q("emmy.env","basis-\x3evector-basis","emmy.env/basis-\x3evector-basis",844291841,null);kyb=new $APP.q("emmy.mechanics.hamilton","time-independent-canonical?","emmy.mechanics.hamilton/time-independent-canonical?",49357688,null);lyb=new $APP.q(null,"Qdotdot","Qdotdot",1384643287,null);myb=new $APP.q("cljs.core","symbol?","cljs.core/symbol?",1422196122,null);
nyb=new $APP.q("emmy.quaternion","ONE-matrix","emmy.quaternion/ONE-matrix",-1099906141,null);oyb=new $APP.q("emmy.calculus.derivative","D-forward","emmy.calculus.derivative/D-forward",427958367,null);pyb=new $APP.q("emmy.matrix","literal-matrix","emmy.matrix/literal-matrix",113887090,null);lVa=new $APP.E(null,"ns-filter","ns-filter",108598448);qyb=new $APP.q(null,"emmy.util.logic","emmy.util.logic",-1309409419,null);
ryb=new $APP.q("emmy.mechanics.rigid","Euler-\x3eomega-body","emmy.mechanics.rigid/Euler-\x3eomega-body",-2038335469,null);syb=new $APP.q("emmy.quaternion","ZERO","emmy.quaternion/ZERO",-1083776647,null);tyb=new $APP.q("emmy.env","literal-oneform-field","emmy.env/literal-oneform-field",560911970,null);uyb=new $APP.q(null,"-\x3eDual","-\x3eDual",-478966744,null);vyb=new $APP.q(null,"trig:special","trig:special",-1108594585,null);
wyb=new $APP.q("emmy.structure","mapr","emmy.structure/mapr",-1572536377,null);xyb=new $APP.q("emmy.calculus.manifold","coordinate-system-at","emmy.calculus.manifold/coordinate-system-at",-2128414549,null);yyb=new $APP.q(null,"literal-number","literal-number",1180750380,null);zyb=new $APP.E(null,"hostname_","hostname_",-2091647379);Ayb=new $APP.q("emmy.quaternion","negate","emmy.quaternion/negate",-1003742118,null);Byb=new $APP.q(null,"subpermute","subpermute",99919407,null);
Cyb=new $APP.E(null,"no-such-method","no-such-method",1087422840);Dyb=new $APP.q("emmy.matrix","structure-\x3ematrix","emmy.matrix/structure-\x3ematrix",191185365,null);$APP.qU=new $APP.q(null,"b","b",-1172211299,null);$APP.jP=new $APP.q(null,"d","d",-682293345,null);Eyb=new $APP.q(null,"emmy.calculus.curvature","emmy.calculus.curvature",-869522506,null);rU=new $APP.q(null,"g","g",-916345864,null);sU=new $APP.q(null,"j","j",242556762,null);lO=new $APP.q(null,"l","l",-1258542346,null);
$APP.tU=new $APP.q(null,"k","k",-505765866,null);$APP.uU=new $APP.q(null,"n","n",-2092305744,null);$APP.mO=new $APP.q(null,"r","r",1169147337,null);Fyb=new $APP.q(null,"\x3c?","\x3c?",-1929864530,null);vU=new $APP.q(null,"q","q",-1965434072,null);Gyb=new $APP.q(null,"numerical?","numerical?",286810593,null);wU=new $APP.q(null,"u","u",483896742,null);Hyb=new $APP.q(null,"w","w",1994700528,null);xU=new $APP.q(null,"vector-basis","vector-basis",770571439,null);
Iyb=new $APP.q("emmy.matrix","s:transpose-orientation","emmy.matrix/s:transpose-orientation",-1509811631,null);Jyb=new $APP.q("emmy.quaternion","multipolar","emmy.quaternion/multipolar",211546978,null);XI=new $APP.q(null,"?","?",-62633706,null);XG=new $APP.E(null,"auto","auto",-566279492);yU=new $APP.q(null,"B","B",218028147,null);zU=new $APP.q(null,"A","A",-48410867,null);cH=new $APP.q(null,"D","D",1632515634,null);CR=new $APP.E(null,"function","function",-2127255473);
SR=new $APP.q(null,"C","C",1466901940,null);AU=new $APP.q(null,"F","F",524988269,null);$APP.BU=new $APP.q(null,"H","H",702383200,null);Kyb=new $APP.q(null,"G","G",901987130,null);Lyb=new $APP.q("cljs.core","number?","cljs.core/number?",-811857295,null);Myb=new $APP.q(null,"J","J",-1259700941,null);CU=new $APP.q(null,"I","I",-827294806,null);$APP.DU=new $APP.q(null,"L","L",602224008,null);EU=new $APP.q(null,"K","K",1641243268,null);FU=new $APP.q(null,"M","M",-115210679,null);
Nyb=new $APP.q(null,"P","P",-985522478,null);$APP.GU=new $APP.q(null,"R","R",703869004,null);Oyb=new $APP.q(null,"Q","Q",-1991115249,null);HU=new $APP.q(null,"T","T",1815772404,null);IU=new $APP.q(null,"V","V",471247521,null);Pyb=new $APP.q(null,"U","U",-1292433725,null);ON=new $APP.q(null,"X","X",-948439456,null);Qyb=new $APP.q(null,"\x3d\x3e","\x3d\x3e",-813269641,null);Ryb=new $APP.E(null,"convergence-fn","convergence-fn",-157362513);eQ=new $APP.E(null,"apply","apply",1320385493);
Syb=new $APP.q("emmy.matrix","-\x3estructure","emmy.matrix/-\x3estructure",-2126763600,null);Tyb=new $APP.q(null,"quotify-coordinate-prototype","quotify-coordinate-prototype",-1299623498,null);Uyb=new $APP.q("emmy.dual","derivative","emmy.dual/derivative",-946247194,null);YRa=new $APP.E(null,"spec-skip-macros","spec-skip-macros",-645015958);Vyb=new $APP.q("emmy.series","partial-sums","emmy.series/partial-sums",-903419413,null);a7a=new $APP.E(null,"hint","hint",439639918);
Wyb=new $APP.q(null,"forward-difference","forward-difference",2142904194,null);Xyb=new $APP.q("emmy.pattern.rule","pass","emmy.pattern.rule/pass",242412252,null);Yyb=new $APP.q(null,"id-\x3epartial","id-\x3epartial",-1276946428,null);Zyb=new $APP.q(null,"k-and-deriv","k-and-deriv",948345568,null);JU=new $APP.E("emmy.quaternion","quaternion","emmy.quaternion/quaternion",1038626106);$APP.TP=new $APP.q(null,"z","z",851004344,null);$APP.SP=new $APP.q(null,"y","y",-117328249,null);
$APP.KU=new $APP.E(null,"state","state",-1988618099);$yb=new $APP.q(null,"iterated-top-down","iterated-top-down",-601519396,null);azb=new $APP.q(null,"Lagrange-equations","Lagrange-equations",-2039149866,null);bzb=new $APP.q("emmy.env","rotate-y-tuple","emmy.env/rotate-y-tuple",1666916204,null);czb=new $APP.E(null,"protocol-inline","protocol-inline",1550487556);dzb=new $APP.q("emmy.quaternion","I-matrix","emmy.quaternion/I-matrix",110675528,null);
ezb=new $APP.q("emmy.env","momentum-tuple","emmy.env/momentum-tuple",1039623149,null);XXa=new $APP.q(null,"??","??",-1097896773,null);fzb=new $APP.q(null,"emmy.mechanics.noether","emmy.mechanics.noether",1242600456,null);gzb=new $APP.q("emmy.quaternion","sin","emmy.quaternion/sin",1453782949,null);LU=new $APP.q(null,"univariate?","univariate?",1606506402,null);hzb=new $APP.q("emmy.mechanics.hamilton","L-state-\x3eH-state","emmy.mechanics.hamilton/L-state-\x3eH-state",-1541198669,null);
izb=new $APP.q("emmy.util","failure-to-converge","emmy.util/failure-to-converge",1451892638,null);jzb=new $APP.q("emmy.util.permute","permutation-sequence","emmy.util.permute/permutation-sequence",-95125419,null);kzb=new $APP.q("emmy.structure","make","emmy.structure/make",-731255583,null);HJ=new $APP.q(null,"?b","?b",1575118075,null);MU=new $APP.q(null,"?c","?c",870679775,null);lzb=new $APP.q("emmy.calculus.map","pushforward-function","emmy.calculus.map/pushforward-function",-1570367866,null);
NU=new $APP.q(null,"?d","?d",-1851543854,null);mzb=new $APP.q(null,"?e","?e",-1194391683,null);GJ=new $APP.q(null,"?a","?a",1314302913,null);OU=new $APP.q(null,"?m","?m",896026745,null);PU=new $APP.q(null,"?f","?f",-1121766265,null);QU=new $APP.q(null,"?u","?u",749886731,null);AJ=new $APP.q(null,"?n","?n",-2053238410,null);nzb=new $APP.q("emmy.env","Curl","emmy.env/Curl",1780544087,null);ozb=new $APP.q("emmy.numerical.unimin.golden","phi","emmy.numerical.unimin.golden/phi",-2045044638,null);
pzb=new $APP.q(null,"?p","?p",-10896580,null);qzb=new $APP.q("emmy.calculus.vector-calculus","coordinate-system-\x3eLame-coefficients","emmy.calculus.vector-calculus/coordinate-system-\x3eLame-coefficients",-1661630614,null);rzb=new $APP.q("emmy.polynomial","negate","emmy.polynomial/negate",-1482358772,null);RU=new $APP.q(null,"?z","?z",711595547,null);szb=new $APP.q(null,"seqtype","seqtype",-1127485523,null);tzb=new $APP.q("emmy.series","-\x3efunction","emmy.series/-\x3efunction",-161120223,null);
uzb=new $APP.q("emmy.env","the-ether","emmy.env/the-ether",891750124,null);CJ=new $APP.q(null,"?x","?x",-555096650,null);JJ=new $APP.q(null,"?y","?y",-1454470631,null);vzb=new $APP.q(null,"vector-\x3edown","vector-\x3edown",595456260,null);wzb=new $APP.q("emmy.polynomial","sub","emmy.polynomial/sub",1465909596,null);xzb=new $APP.q(null,"Gamma-bar","Gamma-bar",941167787,null);yzb=new $APP.q(null,"predicate","predicate",-101970333,null);
zzb=new $APP.q("emmy.series","arg-scale","emmy.series/arg-scale",-2014368231,null);Azb=new $APP.q("emmy.env","iterated-map","emmy.env/iterated-map",1720527068,null);Bzb=new $APP.q(null,"residue","residue",-810505434,null);Czb=new $APP.q("emmy.polynomial","identity","emmy.polynomial/identity",-1838836812,null);$APP.SU=new $APP.q(null,"initial-state","initial-state",-381085279,null);Dzb=new $APP.q("emmy.matrix","fmap-indexed","emmy.matrix/fmap-indexed",1272453632,null);
Ezb=new $APP.q(null,"add-object-symbols!","add-object-symbols!",1079364533,null);Fzb=new $APP.q("emmy.matrix","row-matrix-\x3edown","emmy.matrix/row-matrix-\x3edown",1464939399,null);Gzb=new $APP.q(null,"SR-name","SR-name",1611225963,null);qH=new $APP.q(null,"pi-over-2","pi-over-2",515246065,null);nK=new $APP.q(null,"pi-over-4","pi-over-4",1610173659,null);iRa=new $APP.E("cljs.analyzer","error","cljs.analyzer/error",-65289642);Hzb=new $APP.E(null,"ns*","ns*",200417856);
Izb=new $APP.q(null,"emmy.matrix","emmy.matrix",-1759018144,null);Jzb=new $APP.q("emmy.env","index-types","emmy.env/index-types",1880279110,null);Kzb=new $APP.q("cljs.core","reduced?","cljs.core/reduced?",-1192491371,null);Lzb=new $APP.q(null,"-\x3evector","-\x3evector",-1800052761,null);Mzb=new $APP.q(null,"bulirsch-stoer-sum","bulirsch-stoer-sum",-265874685,null);IVa=new $APP.E(null,"middleware","middleware",1462115504);
Nzb=new $APP.q("emmy.matrix","identity-like","emmy.matrix/identity-like",519402553,null);Ozb=new $APP.q("emmy.generic","sinhc","emmy.generic/sinhc",-980285987,null);Pzb=new $APP.q(null,"rotate-y-tuple","rotate-y-tuple",620058393,null);Qzb=new $APP.q("emmy.calculus.form-field","differential-of-function","emmy.calculus.form-field/differential-of-function",-1262843004,null);TU=new $APP.q(null,"basis","basis",-788616430,null);LQa=new $APP.E(null,"in-loop","in-loop",-187298246);
dRa=new $APP.E(null,"record","record",-779106859);Rzb=new $APP.q(null,"failure-to-converge","failure-to-converge",1638576378,null);Szb=new $APP.q(null,"new-tag","new-tag",-624938805,null);Tzb=new $APP.q("emmy.calculus.vector-calculus","Lap","emmy.calculus.vector-calculus/Lap",-99502815,null);Uzb=new $APP.E(null,"one?","one?",146571376);Vzb=new $APP.q("emmy.util.aggregate","*cutoff*","emmy.util.aggregate/*cutoff*",-1972074086,null);Wzb=new $APP.q(null,"Dt","Dt",389881669,null);
Xzb=new $APP.q(null,"sum?","sum?",1995120931,null);Yzb=new $APP.q("emmy.series","one","emmy.series/one",1613843016,null);Zzb=new $APP.q("emmy.env","Legendre-transform","emmy.env/Legendre-transform",1127756050,null);$zb=new $APP.q("emmy.env","kind","emmy.env/kind",1218716427,null);aAb=new $APP.q(null,"signature","signature",-1190680975,null);bAb=new $APP.q(null,"emmy.calculus.basis","emmy.calculus.basis",-706999681,null);
cAb=new $APP.q("emmy.util.stream","seq-limit","emmy.util.stream/seq-limit",1461539925,null);dAb=new $APP.q(null,"GM","GM",1363569210,null);eAb=new $APP.q(null,"compute-expt","compute-expt",927241808,null);fAb=new $APP.q(null,"velocity-tuple","velocity-tuple",1387588589,null);gAb=new $APP.q(null,"monic?","monic?",-269964245,null);hAb=new $APP.q(null,"D-phase-space","D-phase-space",1736774239,null);iAb=new $APP.q("emmy.generic","square","emmy.generic/square",-294101765,null);
UU=new $APP.q(null,"n-dof","n-dof",148884184,null);jAb=new $APP.q("emmy.env","exact-divide","emmy.env/exact-divide",-1933094893,null);kAb=new $APP.q("emmy.quaternion","tanh","emmy.quaternion/tanh",1285599501,null);lAb=new $APP.q("emmy.calculus.vector-field","literal-vector-field","emmy.calculus.vector-field/literal-vector-field",656282349,null);z4a=new $APP.q(null,"chunkIteratorSeq","chunkIteratorSeq",1822959135,null);mAb=new $APP.q(null,"separatev","separatev",-1127561069,null);
nAb=new $APP.E(null,"choose","choose",1680203305);oAb=new $APP.q(null,"Euler-angles","Euler-angles",-1077969924,null);pAb=new $APP.q("emmy.calculus.manifold","make-manifold","emmy.calculus.manifold/make-manifold",-1747513101,null);qAb=new $APP.q("emmy.rational-function","cube","emmy.rational-function/cube",1011771736,null);rAb=new $APP.q(null,"generalized-LE","generalized-LE",-1073642743,null);sAb=new $APP.q(null,"*clock*","*clock*",876103715,null);
tAb=new $APP.q("emmy.sr.frames","base-frame-chart","emmy.sr.frames/base-frame-chart",-2079801159,null);uAb=new $APP.q("emmy.structure","up*","emmy.structure/up*",-1398422306,null);vAb=new $APP.q("emmy.mechanics.lagrange","polar-\x3erectangular","emmy.mechanics.lagrange/polar-\x3erectangular",-1966599516,null);wAb=new $APP.q(null,"rigid-sysder","rigid-sysder",1244192073,null);xAb=new $APP.q("emmy.special.factorial","pochhammer","emmy.special.factorial/pochhammer",-215994613,null);
yAb=new $APP.q(null,"odd-positive-integer?","odd-positive-integer?",-1115599027,null);zAb=new $APP.q(null,"wildcard?","wildcard?",954487426,null);AAb=new $APP.E(null,"set!","set!",-1389817006);BAb=new $APP.q(null,"zeta1","zeta1",-475321608,null);CAb=new $APP.q(null,"zeta2","zeta2",-1365055378,null);DAb=new $APP.q(null,"new-variables","new-variables",-1065568929,null);VU=new $APP.q(null,"orientation-function","orientation-function",-1851559379,null);
SK=new $APP.E("emmy.structure","up","emmy.structure/up",790281384);EAb=new $APP.q(null,"antisymmetric?","antisymmetric?",-335784736,null);FAb=new $APP.q(null,"typical-point","typical-point",-1087714491,null);GAb=new $APP.q("emmy.calculus.manifold","the-real-line","emmy.calculus.manifold/the-real-line",-655174890,null);HAb=new $APP.E(null,"alternate-patch","alternate-patch",1191317178);IAb=new $APP.q("emmy.structure","up?","emmy.structure/up?",612771628,null);
sVa=new $APP.E(null,"arg-\x3estr-fn","arg-\x3estr-fn",2064845310);JAb=new $APP.q("emmy.series","-\x3eSeries","emmy.series/-\x3eSeries",647407986,null);KAb=new $APP.q(null,"*log-assumptions?*","*log-assumptions?*",-1003046769,null);LAb=new $APP.q(null,"*half-angle-simplify?*","*half-angle-simplify?*",-451115374,null);MAb=new $APP.q(null,"integral","integral",182791804,null);NAb=new $APP.q("emmy.dual","fresh-tag","emmy.dual/fresh-tag",1242274252,null);
WU=new $APP.q(null,"H-state","H-state",766610049,null);OAb=new $APP.q("emmy.calculus.covariant","Cartan?","emmy.calculus.covariant/Cartan?",-230051397,null);$APP.XU=new $APP.q(null,"epsilon","epsilon",910372957,null);PAb=new $APP.q("emmy.expression","print-expression","emmy.expression/print-expression",-1227922809,null);QAb=new $APP.q(null,"Lagrangian-\x3epower-loss","Lagrangian-\x3epower-loss",557159409,null);XVa=new $APP.E(null,"appender","appender",1267426510);
RAb=new $APP.q("emmy.env","phi","emmy.env/phi",-932588012,null);DOa=new $APP.E("clojure.error","column","clojure.error/column",304721553);SAb=new $APP.q(null,"richardson-sum","richardson-sum",296554660,null);TAb=new $APP.q(null,"same","same",-1566530708,null);UAb=new $APP.q(null,"two-tensor-\x3e","two-tensor-\x3e",-2025001390,null);YU=new $APP.q(null,"mul","mul",1285905465,null);VAb=new $APP.q(null,"vector-inner-product","vector-inner-product",-1766536674,null);
WAb=new $APP.q(null,"*careful-conversion*","*careful-conversion*",375806734,null);XAb=new $APP.q(null,"i:contract","i:contract",-1495221968,null);YAb=new $APP.q("emmy.calculus.hodge-star","orthonormalize","emmy.calculus.hodge-star/orthonormalize",357550725,null);ePa=new $APP.q(null,"cljs.core$macros","cljs.core$macros",-2057787548,null);ZAb=new $APP.q("emmy.calculus.map","differential-of-map","emmy.calculus.map/differential-of-map",355752483,null);
$Ab=new $APP.q(null,"inv-phi2","inv-phi2",-1861820731,null);ZU=new $APP.E("emmy.matrix","column-matrix","emmy.matrix/column-matrix",91926350);nPa=new $APP.q(null,"Number","Number",-508146185,null);aBb=new $APP.q("emmy.env","S1-tilted","emmy.env/S1-tilted",-1115919706,null);bBb=new $APP.q(null,"vector-field-\x3eoneform-field","vector-field-\x3eoneform-field",207224065,null);cBb=new $APP.E(null,"recur-frames","recur-frames",-307205196);
dBb=new $APP.q("emmy.sr.boost","proper-space-interval","emmy.sr.boost/proper-space-interval",938798978,null);eBb=new $APP.q("emmy.dual","-\x3eDual","emmy.dual/-\x3eDual",-228949002,null);fBb=new $APP.q("emmy.mechanics.routhian","Lagrangian-\x3eRouthian","emmy.mechanics.routhian/Lagrangian-\x3eRouthian",1200637098,null);gBb=new $APP.q("emmy.polynomial","partial-derivative","emmy.polynomial/partial-derivative",1043846527,null);
hBb=new $APP.q("emmy.pattern.syntax","binding?","emmy.pattern.syntax/binding?",1417270726,null);iBb=new $APP.q("emmy.quaternion","unit?","emmy.quaternion/unit?",1607527633,null);jBb=new $APP.q(null,"*sqrt-factor-simplify?*","*sqrt-factor-simplify?*",-1142636069,null);VZa=new $APP.E(null,"inner-size","inner-size",755766819);kBb=new $APP.q("emmy.env","exp10","emmy.env/exp10",126313462,null);lBb=new $APP.q(null,"symmetrize-Cartan","symmetrize-Cartan",1090588998,null);
mBb=new $APP.q("emmy.mechanics.lagrange","coordinate","emmy.mechanics.lagrange/coordinate",-95160614,null);oab=new $APP.E(null,"observe","observe",-86651450);nBb=new $APP.q("emmy.polynomial","arg-scale","emmy.polynomial/arg-scale",-1629149708,null);oBb=new $APP.q(null,"product","product",-1290961512,null);pBb=new $APP.q(null,"typed-\x3eindexed","typed-\x3eindexed",-1302095155,null);$U=new $APP.E("emmy.series","power-series","emmy.series/power-series",58712418);
qBb=new $APP.q("emmy.env","matrix-by-rows","emmy.env/matrix-by-rows",291838052,null);$APP.aV=new $APP.E(null,"simplify?","simplify?",78948489);rBb=new $APP.q(null,"-\x3ecomplex-matrix","-\x3ecomplex-matrix",37544878,null);sBb=new $APP.q(null,"emmy.pattern.syntax","emmy.pattern.syntax",-1313247869,null);tBb=new $APP.q("emmy.env","Rx","emmy.env/Rx",1536411124,null);uBb=new $APP.q("emmy.env","Ry","emmy.env/Ry",1208139709,null);vBb=new $APP.q("emmy.env","Rz","emmy.env/Rz",-937607197,null);
bV=new $APP.q(null,"name-format","name-format",-680058666,null);wBb=new $APP.q("emmy.function","arity","emmy.function/arity",-956876334,null);xBb=new $APP.q(null,"xi-\x3erectangular","xi-\x3erectangular",-1801725668,null);yBb=new $APP.q(null,"modified-bulirsch-stoer-fold","modified-bulirsch-stoer-fold",258037031,null);zBb=new $APP.q("emmy.env","Sn","emmy.env/Sn",-1339874990,null);ABb=new $APP.q(null,"literal-matrix","literal-matrix",-1009819945,null);
BBb=new $APP.q("emmy.matrix","trace","emmy.matrix/trace",1707194077,null);cV=new $APP.q(null,"vector-field?","vector-field?",921525260,null);sRa=new $APP.E(null,"object","object",1474613949);CBb=new $APP.q("emmy.env","S1","emmy.env/S1",-83658691,null);DBb=new $APP.q(null,"goog","goog",-70603925,null);EBb=new $APP.q("emmy.env","S2","emmy.env/S2",-1763638788,null);FBb=new $APP.q("emmy.env","S3","emmy.env/S3",801890805,null);dV=new $APP.q(null,"equation","equation",1141003782,null);
GBb=new $APP.q(null,"prepare","prepare",190876862,null);HBb=new $APP.q("emmy.env","Rn","emmy.env/Rn",-1218329601,null);wQ=new $APP.E(null,"argv","argv",-1462790895);IBb=new $APP.q(null,"with-limited-time","with-limited-time",-417273310,null);JBb=new $APP.q("emmy.numerical.derivative","valid-methods","emmy.numerical.derivative/valid-methods",-551119034,null);KBb=new $APP.q(null,"initializer","initializer",-427835229,null);LBb=new $APP.q(null,"modified-neville","modified-neville",-477401254,null);
MBb=new $APP.q(null,"Lap","Lap",25592799,null);NBb=new $APP.q(null,"symgen","symgen",-880919559,null);OBb=new $APP.q("emmy.env","R1","emmy.env/R1",-1648827283,null);PBb=new $APP.q("emmy.env","R2","emmy.env/R2",1168883436,null);QBb=new $APP.q("emmy.env","expt","emmy.env/expt",-1338987834,null);RBb=new $APP.q("emmy.env","R3","emmy.env/R3",1026886895,null);SBb=new $APP.q("emmy.env","R4","emmy.env/R4",251272595,null);iF=new $APP.E(null,"argc","argc",-1452839519);
TBb=new $APP.q("emmy.operator","arity","emmy.operator/arity",915557534,null);UBb=new $APP.q(null,"trace2down","trace2down",1832753626,null);VBb=new $APP.E(null,"defined","defined",-1805032318);WBb=new $APP.q("cljs.core","false?","cljs.core/false?",-1660815306,null);XBb=new $APP.q("emmy.series","atanh-series","emmy.series/atanh-series",77583755,null);AUa=new $APP.E(null,"cache?","cache?",-1601953949);
YBb=new $APP.q("emmy.algebra.fold","generic-sum-fold","emmy.algebra.fold/generic-sum-fold",1281400173,null);ZBb=new $APP.q("emmy.special.factorial","double-factorial","emmy.special.factorial/double-factorial",-2108419303,null);$Bb=new $APP.q(null,"roll","roll",1651798526,null);aCb=new $APP.q("emmy.generic","tan","emmy.generic/tan",-645967061,null);bCb=new $APP.q("emmy.abstract.number","literal-number?","emmy.abstract.number/literal-number?",-1703736780,null);
cCb=new $APP.q("emmy.sr.frames","v:c","emmy.sr.frames/v:c",312665889,null);dCb=new $APP.q("emmy.algebra.fold","join","emmy.algebra.fold/join",1937122726,null);eCb=new $APP.q(null,"from-power-series","from-power-series",1871650538,null);h7a=new $APP.E(null,"render-primitive","render-primitive",-529994613);fCb=new $APP.q(null,"goog.array","goog.array",-671977860,null);gCb=new $APP.q("cljs.core","seq?","cljs.core/seq?",-1302056292,null);hCb=new $APP.q("emmy.env","exp2","emmy.env/exp2",1817881551,null);
MRa=new $APP.E(null,"fn-deprecated","fn-deprecated",626877647);iCb=new $APP.q("Math","sinh","Math/sinh",-996945022,null);jCb=new $APP.q("emmy.mechanics.lagrange","L-free-particle","emmy.mechanics.lagrange/L-free-particle",-1574475160,null);wVa=new $APP.E(null,"?ns-str","?ns-str",2012733966);kCb=new $APP.q("emmy.util.permute","permute","emmy.util.permute/permute",-18883492,null);eV=new $APP.E(null,"rectangular","rectangular",193204560);
lCb=new $APP.q(null,"make-manifold-family","make-manifold-family",391146328,null);mCb=new $APP.q("emmy.expression","literal-apply","emmy.expression/literal-apply",-1112935907,null);nCb=new $APP.q("emmy.util","biginttype","emmy.util/biginttype",962719325,null);oCb=new $APP.E("emmy.numerical.quadrature.common","open","emmy.numerical.quadrature.common/open",-708131519);pCb=new $APP.q(null,"-\x3eTeX","-\x3eTeX",-682969935,null);wE=new $APP.E(null,"ret-tag","ret-tag",1705919990);
qCb=new $APP.q(null,"unsupported","unsupported",594924511,null);rCb=new $APP.q("emmy.quaternion","cylindrospherical","emmy.quaternion/cylindrospherical",87659266,null);sCb=new $APP.q("emmy.calculus.metric","components-\x3emetric","emmy.calculus.metric/components-\x3emetric",-1601440343,null);tCb=new $APP.q(null,"eq-fn","eq-fn",923311547,null);uCb=new $APP.q(null,"map-\x3eCompleted","map-\x3eCompleted",1367547234,null);
Cxb=new $APP.q("emmy.calculus.manifold","get-patch","emmy.calculus.manifold/get-patch",817155090,null);wCb=new $APP.q("cljs.core","simple-symbol?","cljs.core/simple-symbol?",-1951205629,null);xCb=new $APP.q("emmy.mechanics.hamilton","Phi","emmy.mechanics.hamilton/Phi",1634621403,null);yCb=new $APP.q("emmy.env","momentum","emmy.env/momentum",1413332238,null);zCb=new $APP.q(null,"kahan-babushka-klein","kahan-babushka-klein",-1129341992,null);
ACb=new $APP.q(null,"pushforward-vector","pushforward-vector",-2017628021,null);BCb=new $APP.q("emmy.mechanics.hamilton","qp-\x3eH-state-path","emmy.mechanics.hamilton/qp-\x3eH-state-path",-1353119773,null);CCb=new $APP.q(null,"using-coordinates","using-coordinates",672518652,null);DCb=new $APP.q(null,"alternate-angles","alternate-angles",-469789615,null);ECb=new $APP.q("emmy.matrix","characteristic-polynomial","emmy.matrix/characteristic-polynomial",1037731882,null);
FCb=new $APP.E("emmy.matrix","down","emmy.matrix/down",-1773528537);GCb=new $APP.q("emmy.util.def","careful-def","emmy.util.def/careful-def",698573189,null);HCb=new $APP.q(null,"evaluate","evaluate",-1129217332,null);ICb=new $APP.q(null,"binomial-coefficient","binomial-coefficient",-1900165027,null);JCb=new $APP.q("emmy.generic","acsc","emmy.generic/acsc",-675575907,null);cXa=new $APP.E(null,"reverse?","reverse?",-1672868474);KCb=new $APP.q(null,"initial-p","initial-p",159948069,null);
LCb=new $APP.q(null,"compatible-shape","compatible-shape",2037767671,null);fV=new $APP.q(null,"emmy.simplify","emmy.simplify",-490367714,null);gV=new $APP.q("cljs.core","IPrintWithWriter","cljs.core/IPrintWithWriter",1349251417,null);MCb=new $APP.q(null,"symplectic-matrix?","symplectic-matrix?",-2132491360,null);NCb=new $APP.q(null,"vector:generate","vector:generate",1316333380,null);hV=new $APP.q(null,"imag-part","imag-part",2028041294,null);
OCb=new $APP.q("emmy.calculus.indexed","index-types","emmy.calculus.indexed/index-types",-1606152014,null);PCb=new $APP.q(null,"Legendre-transform","Legendre-transform",77490623,null);QCb=new $APP.q("emmy.env","typed-\x3estructure","emmy.env/typed-\x3estructure",-1599751679,null);RCb=new $APP.q(null,"pushforward-function","pushforward-function",-2125705580,null);SCb=new $APP.q(null,"restricted?","restricted?",645416471,null);iV=new $APP.E(null,"structure","structure",1563832083);
TCb=new $APP.q("emmy.mechanics.lagrange","L-axisymmetric-top","emmy.mechanics.lagrange/L-axisymmetric-top",-1196620965,null);UCb=new $APP.E(null,"denominator","denominator",-804365096);VCb=new $APP.q(null,"ONE-tensor","ONE-tensor",-1496343602,null);WCb=new $APP.q(null,"compute-sqrt","compute-sqrt",-2067318931,null);XCb=new $APP.q(null,"emmy.env","emmy.env",-2036137056,null);YCb=new $APP.q(null,"sin-series","sin-series",-1391412354,null);
ZCb=new $APP.q("emmy.quaternion","from-rotation-matrix","emmy.quaternion/from-rotation-matrix",-916087243,null);$Cb=new $APP.q("emmy.rational-function.interpolate","modified-bulirsch-stoer-sum","emmy.rational-function.interpolate/modified-bulirsch-stoer-sum",-1017577760,null);aDb=new $APP.q(null,"up-of-downs?","up-of-downs?",43706581,null);bDb=new $APP.q(null,"row-matrix","row-matrix",-2005619498,null);jV=new $APP.q(null,"M-of-q","M-of-q",868515731,null);
cDb=new $APP.q(null,"taylor-series","taylor-series",1018004082,null);t4a=new $APP.q("cljs.core","-indexOf","cljs.core/-indexOf",-1914846785,null);dDb=new $APP.q(null,"polar-canonical-inverse","polar-canonical-inverse",-746066399,null);eDb=new $APP.q(null,"biginttype","biginttype",671497401,null);fDb=new $APP.q("emmy.series","catalan-series","emmy.series/catalan-series",1625824348,null);gDb=new $APP.q("emmy.pattern.match","as-segment-matcher","emmy.pattern.match/as-segment-matcher",452996137,null);
hDb=new $APP.q(null,"make-basis","make-basis",-507384846,null);iDb=new $APP.q(null,"coordinate-system-\x3eoneform-basis","coordinate-system-\x3eoneform-basis",1426882309,null);jDb=new $APP.q("emmy.generic","acos","emmy.generic/acos",568902022,null);kDb=new $APP.q("emmy.env","oneform-field-\x3ebasis-components","emmy.env/oneform-field-\x3ebasis-components",-571671434,null);lDb=new $APP.q("Math","log","Math/log",46490779,null);
mDb=new $APP.q("emmy.numerical.derivative","central-difference","emmy.numerical.derivative/central-difference",-178793090,null);nDb=new $APP.q(null,"emmy.calculus.metric","emmy.calculus.metric",-636969725,null);oDb=new $APP.q("emmy.generic","acot","emmy.generic/acot",-1652695882,null);pDb=new $APP.q("emmy.quaternion","expt","emmy.quaternion/expt",-1365932191,null);qDb=new $APP.q(null,"momentum","momentum",-1755355427,null);
rDb=new $APP.q("emmy.calculus.manifold","S2-spherical","emmy.calculus.manifold/S2-spherical",882058390,null);sDb=new $APP.q(null,"brent-min","brent-min",477201418,null);tDb=new $APP.q("emmy.polynomial","coeff?","emmy.polynomial/coeff?",950343704,null);uDb=new $APP.q(null,"-\x3eOperator","-\x3eOperator",2055658388,null);vDb=new $APP.q(null,"solve-linear-right","solve-linear-right",-1518292405,null);wDb=new $APP.q(null,"zeno","zeno",141272922,null);
xDb=new $APP.q(null,"joint-arity","joint-arity",632178222,null);yDb=new $APP.E(null,"out","out",-910545517);zDb=new $APP.q("emmy.polynomial.richardson","richardson-scan","emmy.polynomial.richardson/richardson-scan",95595215,null);g8a=new $APP.E(null,"valid-mode","valid-mode",1171609710);ADb=new $APP.q("emmy.env","series:sum","emmy.env/series:sum",-546636796,null);BDb=new $APP.q("emmy.env","expression-of","emmy.env/expression-of",769545669,null);
CDb=new $APP.q(null,"spacetime-sphere","spacetime-sphere",-189162513,null);DDb=new $APP.q("emmy.env","m:generate","emmy.env/m:generate",-1863391968,null);EDb=new $APP.q("emmy.quaternion","get-r","emmy.quaternion/get-r",-1374344294,null);FDb=new $APP.q("emmy.quaternion","get-i","emmy.quaternion/get-i",-1036525517,null);GDb=new $APP.q("emmy.quaternion","get-j","emmy.quaternion/get-j",930199151,null);HDb=new $APP.q("emmy.quaternion","get-k","emmy.quaternion/get-k",-440295452,null);
IDb=new $APP.q("emmy.generic","identity?","emmy.generic/identity?",-1656175880,null);kV=new $APP.E("emmy.matrix","matrix","emmy.matrix/matrix",-253656831);JDb=new $APP.q(null,"coerce-to-fn","coerce-to-fn",2129768019,null);lV=new $APP.q(null,"original-list","original-list",1772023851,null);KDb=new $APP.q("emmy.env","d","emmy.env/d",-1808310296,null);LDb=new $APP.q(null,"xpow","xpow",-133471806,null);MDb=new $APP.q("emmy.polynomial","univariate?","emmy.polynomial/univariate?",259891412,null);
NDb=new $APP.q(null,"emmy.calculus.coordinate","emmy.calculus.coordinate",-1739399929,null);ODb=new $APP.q("emmy.mechanics.lagrange","osculating-path","emmy.mechanics.lagrange/osculating-path",-883100340,null);XE=new $APP.E("cljs.analyzer","expr","cljs.analyzer/expr",1708655889);mV=new $APP.q(null,"factors","factors",-1546618389,null);PDb=new $APP.q("emmy.mechanics.lagrange","state-\x3eq","emmy.mechanics.lagrange/state-\x3eq",-1487288291,null);
QDb=new $APP.q("emmy.env","arg-shift","emmy.env/arg-shift",885884926,null);RDb=new $APP.q("emmy.mechanics.lagrange","state-\x3et","emmy.mechanics.lagrange/state-\x3et",-1182493984,null);SDb=new $APP.q("emmy.polynomial","coefficients","emmy.polynomial/coefficients",470957039,null);TDb=new $APP.q(null,"-\x3ecomplex-pair","-\x3ecomplex-pair",-769128571,null);UDb=new $APP.q(null,"cartesian-product","cartesian-product",1232721737,null);VDb=new $APP.E(null,"equation","equation",-499527745);
WDb=new $APP.q("emmy.env","literal-matrix","emmy.env/literal-matrix",2692794,null);XDb=new $APP.q("emmy.structure","transpose","emmy.structure/transpose",-2044556138,null);YDb=new $APP.q(null,"zero","zero",781566951,null);ZDb=new $APP.q("emmy.structure","sumr","emmy.structure/sumr",-706557164,null);$Db=new $APP.q(null,"angles-path","angles-path",1169157124,null);aEb=new $APP.q("emmy.generic","partial-derivative","emmy.generic/partial-derivative",-620815744,null);
bEb=new $APP.q("emmy.structure","structure-\x3eprototype","emmy.structure/structure-\x3eprototype",-157823404,null);cEb=new $APP.q("emmy.calculus.covariant","symmetrize-Christoffel","emmy.calculus.covariant/symmetrize-Christoffel",514310538,null);dEb=new $APP.q("emmy.generic","cos","emmy.generic/cos",-47395634,null);eEb=new $APP.q("emmy.generic","cot","emmy.generic/cot",1929307087,null);fEb=new $APP.q(null,"*cutoff*","*cutoff*",-768308169,null);
gEb=new $APP.q(null,"opposite-orientation","opposite-orientation",-1960888039,null);XTa=new $APP.q("java.lang.Math","abs","java.lang.Math/abs",1272698622,null);hEb=new $APP.q(null,"Grad","Grad",-1533675656,null);iEb=new $APP.q("emmy.simplify.rules","angular-parity","emmy.simplify.rules/angular-parity",726527978,null);jEb=new $APP.q("emmy.matrix","column-matrix-\x3evector","emmy.matrix/column-matrix-\x3evector",951550476,null);kEb=new $APP.q(null,"make-path","make-path",-72172791,null);
lEb=new $APP.q(null,"literal-Lagrangian-state","literal-Lagrangian-state",206160578,null);mEb=new $APP.E(null,"msecs","msecs",1711980553);nV=new $APP.q(null,"outer-orientation","outer-orientation",654965214,null);nEb=new $APP.q("emmy.env","covariant-derivative","emmy.env/covariant-derivative",1221265867,null);oEb=new $APP.q("emmy.function","combine-arities","emmy.function/combine-arities",1994059382,null);pEb=new $APP.q("emmy.env","minimize","emmy.env/minimize",-613445648,null);
qEb=new $APP.q(null,"multiplicative-transpose","multiplicative-transpose",1690205494,null);rEb=new $APP.q("emmy.numsymb","dot-product","emmy.numsymb/dot-product",985201995,null);sEb=new $APP.q("cljs.core","ns-unmap","cljs.core/ns-unmap",-1559056406,null);tEb=new $APP.q(null,"idempotent","idempotent",-220060811,null);uEb=new $APP.q(null,"meta49290","meta49290",-1543439801,null);vEb=new $APP.q("emmy.polynomial","square","emmy.polynomial/square",-1045396918,null);
wEb=new $APP.q("emmy.mechanics.hamilton","momenta","emmy.mechanics.hamilton/momenta",-2115048610,null);xEb=new $APP.q(null,"Rx-matrix","Rx-matrix",547573038,null);yEb=new $APP.E(null,"declared-arglists-mismatch","declared-arglists-mismatch",-496878383);oRa=new $APP.E("cljs.analyzer","call","cljs.analyzer/call",964149800);zEb=new $APP.q("emmy.env","s-\x3er","emmy.env/s-\x3er",1538747556,null);AEb=new $APP.q(null,"get-r","get-r",-31995758,null);
TO=new $APP.E("emmy.calculus.vector-field","vector-field","emmy.calculus.vector-field/vector-field",739612763);BEb=new $APP.q(null,"rule-simplifier","rule-simplifier",-1334565675,null);CEb=new $APP.q(null,"-\x3e4x4-matrix","-\x3e4x4-matrix",-1753309744,null);DEb=new $APP.q("emmy.pattern.syntax","wildcard?","emmy.pattern.syntax/wildcard?",1314957807,null);EEb=new $APP.q(null,"brent-max","brent-max",-942668348,null);
FEb=new $APP.q("emmy.rational-function","from-points","emmy.rational-function/from-points",-1082803325,null);oV=new $APP.q(null,"acosh","acosh",-2005748303,null);GEb=new $APP.q("emmy.env","s-\x3em","emmy.env/s-\x3em",-947460291,null);HEb=new $APP.q(null,"gradient","gradient",-343377444,null);IEb=new $APP.q("cljs.core","IMapEntry","cljs.core/IMapEntry",535941300,null);JEb=new $APP.q("emmy.simplify.rules","logexp-\x3especfun","emmy.simplify.rules/logexp-\x3especfun",1039035517,null);
pV=new $APP.q(null,"local","local",142764803,null);KEb=new $APP.q("emmy.env","*","emmy.env/*",1476276860,null);LEb=new $APP.q(null,"longtype","longtype",1290789410,null);MEb=new $APP.q("emmy.matrix","two-tensor-\x3e","emmy.matrix/two-tensor-\x3e",1078531381,null);NEb=new $APP.q("emmy.env","-","emmy.env/-",-1605964347,null);OEb=new $APP.q("emmy.calculus.covariant","parallel-transport-equation","emmy.calculus.covariant/parallel-transport-equation",2112489694,null);
PEb=new $APP.q("emmy.env","+","emmy.env/+",-1636773707,null);QEb=new $APP.q("emmy.env","/","emmy.env//",1834991288,null);REb=new $APP.q(null,"get-i","get-i",841532219,null);SEb=new $APP.q(null,"get-j","get-j",1199347047,null);TEb=new $APP.q(null,"get-k","get-k",-1782268692,null);UEb=new $APP.q("emmy.structure","fold-chain","emmy.structure/fold-chain",-1830499052,null);VEb=new $APP.q(null,"chart","chart",-1481210344,null);WEb=new $APP.q(null,"G__46224","G__46224",-396649288,null);
XEb=new $APP.E(null,"your-version","your-version",-351781765);YEb=new $APP.q("emmy.env","\x3d","emmy.env/\x3d",1680024316,null);ZEb=new $APP.q("emmy.simplify.rules","*sin-cos-simplify?*","emmy.simplify.rules/*sin-cos-simplify?*",880690826,null);$Eb=new $APP.q("emmy.env","zero-like","emmy.env/zero-like",256583262,null);aFb=new $APP.q(null,"acoth","acoth",1639672811,null);bFb=new $APP.q("emmy.polynomial","-\x3et_emmy$polynomial48706","emmy.polynomial/-\x3et_emmy$polynomial48706",-118003416,null);
cFb=new $APP.q("emmy.env","D-forward","emmy.env/D-forward",1009314329,null);dFb=new $APP.q("emmy.env","D","emmy.env/D",-1574044025,null);eFb=new $APP.q("emmy.env","I","emmy.env/I",1291135,null);fFb=new $APP.q("emmy.env","rotate-z-matrix","emmy.env/rotate-z-matrix",-1166870351,null);gFb=new $APP.q("emmy.calculus.curvature","torsion-vector","emmy.calculus.curvature/torsion-vector",-655479923,null);hFb=new $APP.q(null,"*unchecked-if*","*unchecked-if*",1542408350,null);
iFb=new $APP.q("emmy.env","structure-\x3evector","emmy.env/structure-\x3evector",1597191082,null);jFb=new $APP.q("emmy.env","pushforward-vector","emmy.env/pushforward-vector",-1038153500,null);kFb=new $APP.q(null,"four-tuple-\x3ect","four-tuple-\x3ect",-1670005201,null);lFb=new $APP.q(null,"frame-predicate","frame-predicate",-1552233927,null);mFb=new $APP.q("emmy.env","trace","emmy.env/trace",1671513221,null);nFb=new $APP.q("emmy.env","chinese-remainder","emmy.env/chinese-remainder",1070733639,null);
oFb=new $APP.q("emmy.simplify.rules","triginv","emmy.simplify.rules/triginv",565660742,null);pFb=new $APP.q(null,"commutator","commutator",1038087209,null);qFb=new $APP.q("emmy.polynomial.interpolate","modified-neville-scan","emmy.polynomial.interpolate/modified-neville-scan",1079675519,null);rFb=new $APP.q("emmy.generic","zero-like","emmy.generic/zero-like",643941476,null);TD=new $APP.E("cljs.analyzer","namespaces","cljs.analyzer/namespaces",-260788927);
sFb=new $APP.q(null,"operator?","operator?",1708561462,null);tFb=new $APP.q("emmy.quaternion","roll","emmy.quaternion/roll",845893318,null);uFb=new $APP.q(null,"minimize","minimize",-1647687907,null);vFb=new $APP.q(null,"coordinates","coordinates",415198859,null);wFb=new $APP.q("emmy.env","metric-\x3ecomponents","emmy.env/metric-\x3ecomponents",673896653,null);xFb=new $APP.q(null,"direction","direction",1007172132,null);IUa=new $APP.E(null,"enabled?","enabled?",-1376075057);
yFb=new $APP.q("emmy.quaternion","real?","emmy.quaternion/real?",685934414,null);zFb=new $APP.q(null,"-\x3eRationalFunction","-\x3eRationalFunction",-1916100697,null);AFb=new $APP.q("emmy.env","Hamiltonian","emmy.env/Hamiltonian",395510226,null);BFb=new $APP.E(null,"tests","tests",-1041085625);CFb=new $APP.q("emmy.env","fractional-part","emmy.env/fractional-part",-1484941681,null);DFb=new $APP.q("cljs.core","array?","cljs.core/array?",-1655912448,null);
EFb=new $APP.q(null,"alt-wedge","alt-wedge",-1039108858,null);FFb=new $APP.q("emmy.env","basis-components-\x3evector-field","emmy.env/basis-components-\x3evector-field",-932310019,null);GFb=new $APP.q("emmy.env","tanh","emmy.env/tanh",1392859752,null);HFb=new $APP.q(null,"gcd-stats","gcd-stats",-1203765846,null);IFb=new $APP.q(null,"-\x3eL-state","-\x3eL-state",1029512715,null);JFb=new $APP.q("emmy.env","tanc","emmy.env/tanc",-1921649246,null);
KFb=new $APP.q("emmy.calculus.manifold","R3-cyl","emmy.calculus.manifold/R3-cyl",2008142283,null);LFb=new $APP.q(null,"matrix-by-rows","matrix-by-rows",-1400856559,null);MFb=new $APP.q(null,"factorial-power","factorial-power",-1318084454,null);NFb=new $APP.q("emmy.util","keyset","emmy.util/keyset",270836023,null);qV=new $APP.q(null,"backend","backend",793042403,null);OFb=new $APP.q("emmy.polynomial","univariate-\x3edense","emmy.polynomial/univariate-\x3edense",-2020028363,null);
PFb=new $APP.q("emmy.quaternion","-\x3evector","emmy.quaternion/-\x3evector",-1532462337,null);QFb=new $APP.q("emmy.env","definite-integral","emmy.env/definite-integral",-336307266,null);RFb=new $APP.q("emmy.env","angle","emmy.env/angle",2144718722,null);rV=new $APP.E("emmy.abstract.function","function","emmy.abstract.function/function",878668117);SFb=new $APP.q("emmy.matrix","num-cols","emmy.matrix/num-cols",1953785168,null);TFb=new $APP.q("emmy.env","gradient","emmy.env/gradient",-1389710927,null);
UFb=new $APP.q(null,"print-expression","print-expression",1826868853,null);VFb=new $APP.q("emmy.env","metric-\x3einverse-components","emmy.env/metric-\x3einverse-components",-1632880464,null);WFb=new $APP.q("emmy.calculus.covariant","covariant-derivative","emmy.calculus.covariant/covariant-derivative",-1836804793,null);XFb=new $APP.q("emmy.env","vector-field-\x3ecomponents","emmy.env/vector-field-\x3ecomponents",-678476911,null);YFb=new $APP.q(null,"S3-spherical","S3-spherical",-73265585,null);
ZFb=new $APP.q("s","compatible-for-contraction?","s/compatible-for-contraction?",-50704509,null);$Fb=new $APP.q("emmy.series","bell-series","emmy.series/bell-series",-715401971,null);aGb=new $APP.q("emmy.generic","csc","emmy.generic/csc",440165121,null);JD=new $APP.E(null,"children","children",-940561982);bGb=new $APP.q(null,"native-integral?","native-integral?",1972110620,null);cGb=new $APP.q("emmy.simplify.rules","not-integral?","emmy.simplify.rules/not-integral?",-1471229124,null);
dGb=new $APP.q(null,"monotonic-symbol-generator","monotonic-symbol-generator",1030677660,null);eGb=new $APP.q(null,"emmy.operator","emmy.operator",-1111337305,null);fGb=new $APP.q(null,"cuthigh","cuthigh",-1046878586,null);gGb=new $APP.E(null,"months","months",-45571637);sV=new $APP.q(null,"-\x3eexpression","-\x3eexpression",-1295460418,null);tV=new $APP.q(null,"cube","cube",138920159,null);
hGb=new $APP.q(null,"*allow-incompatible-multiplication*","*allow-incompatible-multiplication*",1994211376,null);iGb=new $APP.q("emmy.quaternion","K-tensor","emmy.quaternion/K-tensor",1466584396,null);jGb=new $APP.q(null,"guard","guard",767383716,null);kGb=new $APP.q("emmy.env","-tau","emmy.env/-tau",-1418132068,null);lGb=new $APP.q(null,"row-matrix-\x3evector","row-matrix-\x3evector",1672763573,null);mGb=new $APP.q("clojure.core","mod","clojure.core/mod",215755142,null);
nGb=new $APP.q(null,"elliptic-k","elliptic-k",625190114,null);oGb=new $APP.q("emmy.env","row-matrix-\x3evector","emmy.env/row-matrix-\x3evector",605163750,null);pGb=new $APP.q("emmy.polynomial.interpolate","tableau-fn","emmy.polynomial.interpolate/tableau-fn",1916732414,null);qGb=new $APP.q(null,"elliptic-e","elliptic-e",1469512221,null);rGb=new $APP.q(null,"elliptic-f","elliptic-f",2039182144,null);sGb=new $APP.q(null,"-\x3ebigint","-\x3ebigint",863817399,null);
tGb=new $APP.q("emmy.env","cross-product","emmy.env/cross-product",59748312,null);PM=new $APP.E("emmy.expression","numeric","emmy.expression/numeric",-181475924);uGb=new $APP.E(null,"overload-arity","overload-arity",823206044);vGb=new $APP.q("emmy.mechanics.rigid","qw-state-\x3eL-body","emmy.mechanics.rigid/qw-state-\x3eL-body",-2090012960,null);wGb=new $APP.q(null,"emmy.simplify.rules","emmy.simplify.rules",1791645636,null);xGb=new $APP.q("emmy.env","rotate-x","emmy.env/rotate-x",-806731691,null);
yGb=new $APP.q("emmy.env","rotate-y","emmy.env/rotate-y",-1735629286,null);zGb=new $APP.q("emmy.env","rotate-z","emmy.env/rotate-z",-948930891,null);AGb=new $APP.q(null,"make-Hamiltonian","make-Hamiltonian",1457755270,null);uV=new $APP.q(null,"family","family",327385835,null);BGb=new $APP.q(null,"emmy.special.elliptic","emmy.special.elliptic",1100074875,null);
CGb=new $APP.q("emmy.calculus.metric","coordinate-system-\x3emetric-components","emmy.calculus.metric/coordinate-system-\x3emetric-components",1577030701,null);DGb=new $APP.q("Math","trunc","Math/trunc",1386774702,null);iN=new $APP.E("emmy.tape","tape","emmy.tape/tape",-747075426);EGb=new $APP.q(null,"tex$","tex$",-1271871282,null);FGb=new $APP.q(null,"from-complex-matrix","from-complex-matrix",-334210528,null);GGb=new $APP.q(null,"multi-factorial","multi-factorial",828671797,null);
HGb=new $APP.q("emmy.sr.frames","base-frame-point","emmy.sr.frames/base-frame-point",1338863497,null);IGb=new $APP.q("emmy.env","solve-linear-right","emmy.env/solve-linear-right",2028141086,null);$APP.JGb=new $APP.q(null,"mag","mag",1689150701,null);Lxb=new $APP.q(null,"point-\x3emanifold","point-\x3emanifold",937995152,null);LGb=new $APP.q(null,"fixed-point","fixed-point",266974883,null);MGb=new $APP.q(null,"*TeX-vertical-down-tuples*","*TeX-vertical-down-tuples*",-1032771622,null);
NGb=new $APP.q("emmy.env","identity?","emmy.env/identity?",-2043797294,null);OGb=new $APP.q(null,"-\x3eJavaScript","-\x3eJavaScript",-417418602,null);PGb=new $APP.q(null,"canonical-transform?","canonical-transform?",1108728387,null);QGb=new $APP.q(null,"fmap-indexed","fmap-indexed",-1932165905,null);hUa=new $APP.E(null,"version","version",425292698);RGb=new $APP.q("emmy.env","phase-space-derivative","emmy.env/phase-space-derivative",1054715770,null);
SGb=new $APP.q("emmy.util","inttype","emmy.util/inttype",-1591430550,null);TGb=new $APP.q("emmy.generic","invert","emmy.generic/invert",1772168795,null);UGb=new $APP.q(null,"failure","failure",-1934019890,null);lE=new $APP.E(null,"anonymous","anonymous",447897231);VGb=new $APP.q(null,"metric-\x3ecomponents","metric-\x3ecomponents",-280457160,null);WGb=new $APP.q("emmy.calculus.manifold","S1-circular","emmy.calculus.manifold/S1-circular",794004458,null);
XGb=new $APP.q("emmy.generic","ceiling","emmy.generic/ceiling",-1790548622,null);YGb=new $APP.q("emmy.function","get-in","emmy.function/get-in",1473231369,null);ZGb=new $APP.q("emmy.expression","substitute","emmy.expression/substitute",-758415210,null);$Gb=new $APP.q("emmy.env","Lie-D","emmy.env/Lie-D",-1995509146,null);aHb=new $APP.q("emmy.simplify.rules","specfun-\x3elogexp","emmy.simplify.rules/specfun-\x3elogexp",-1618126267,null);
bHb=new $APP.q("emmy.numsymb","derivative?","emmy.numsymb/derivative?",-1743154467,null);cHb=new $APP.q("emmy.mechanics.lagrange","Gamma-bar","emmy.mechanics.lagrange/Gamma-bar",1498034999,null);dHb=new $APP.q("emmy.quaternion","-\x3erotation-matrix","emmy.quaternion/-\x3erotation-matrix",1298788575,null);eHb=new $APP.q(null,"re-matches?","re-matches?",-217725652,null);fHb=new $APP.q("emmy.env","curvature-components","emmy.env/curvature-components",1901709916,null);
gHb=new $APP.q("emmy.pattern.syntax","unquote-splice?","emmy.pattern.syntax/unquote-splice?",-306783946,null);ER=new $APP.E(null,"ratio-fn","ratio-fn",1226148920);hHb=new $APP.q(null,"c-systems__58646__auto__","c-systems__58646__auto__",-610202835,null);yE=new $APP.E(null,"renames","renames",343278368);iHb=new $APP.q("emmy.mechanics.lagrange","Lagrange-equations","emmy.mechanics.lagrange/Lagrange-equations",1694519930,null);jHb=new $APP.q("emmy.quaternion","cos","emmy.quaternion/cos",-110326909,null);
kHb=new $APP.q(null,"sin-half-angle-formula","sin-half-angle-formula",1943828750,null);lHb=new $APP.q("emmy.env","row-matrix-\x3edown","emmy.env/row-matrix-\x3edown",1571898431,null);mHb=new $APP.q(null,"emmy.pattern.consequence","emmy.pattern.consequence",1651562694,null);nHb=new $APP.q(null,"leading-term","leading-term",-1876467876,null);oHb=new $APP.q("emmy.calculus.manifold","S3-spherical","emmy.calculus.manifold/S3-spherical",1021348969,null);
pHb=new $APP.q("emmy.env","make-manifold","emmy.env/make-manifold",-1724752278,null);vV=new $APP.q(null,"types","types",-2064405130,null);wV=new $APP.E(null,"id-\x3epartial","id-\x3epartial",1377489341);qHb=new $APP.q("emmy.env","Lagrangian-\x3estate-derivative","emmy.env/Lagrangian-\x3estate-derivative",30380731,null);rHb=new $APP.q("emmy.quaternion","from-angle-normal-axis","emmy.quaternion/from-angle-normal-axis",1285560933,null);xV=new $APP.q(null,"minterms","minterms",372879357,null);
P3a=new $APP.E(null,"embedding-dimension","embedding-dimension",1369585967);sHb=new $APP.q("emmy.util.permute","number-of-combinations","emmy.util.permute/number-of-combinations",-1577246383,null);tHb=new $APP.q("emmy.env","print-expression","emmy.env/print-expression",-1459251546,null);uHb=new $APP.q("emmy.simplify.rules","*log-exp-simplify?*","emmy.simplify.rules/*log-exp-simplify?*",1665754330,null);LP=new $APP.q("emmy.structure","up","emmy.structure/up",-1864154385,null);
yV=new $APP.q(null,"default-relative-threshold","default-relative-threshold",1623766986,null);vHb=new $APP.q(null,"coords-\x3eevent","coords-\x3eevent",637740539,null);wHb=new $APP.q(null,"split-high-degree-sincos","split-high-degree-sincos",-1143884333,null);xHb=new $APP.q("emmy.env","form-field-\x3eform-field-over-map","emmy.env/form-field-\x3eform-field-over-map",-1463567997,null);yHb=new $APP.q("emmy.expression.compile","compile-fn","emmy.expression.compile/compile-fn",-685968567,null);
zHb=new $APP.q(null,"keyset","keyset",2135291099,null);AHb=new $APP.q("emmy.calculus.map","differential","emmy.calculus.map/differential",1880219356,null);BHb=new $APP.q("emmy.env","R4-rect","emmy.env/R4-rect",-1352405565,null);CHb=new $APP.q(null,"harmonic-series","harmonic-series",-909996844,null);DHb=new $APP.q("emmy.expression.render","-\x3einfix","emmy.expression.render/-\x3einfix",-7429898,null);EHb=new $APP.q(null,"list-interchanges","list-interchanges",899634747,null);
qO=new $APP.E(null,"patch-templates","patch-templates",836059143);FHb=new $APP.q("emmy.quaternion","div","emmy.quaternion/div",-255534561,null);GHb=new $APP.q(null,"denominator","denominator",836166431,null);zV=new $APP.q(null,"rows","rows",-1804386089,null);HHb=new $APP.q("cljs.core","Var","cljs.core/Var",2071014443,null);IHb=new $APP.q("emmy.mechanics.time-evolution","shift-t","emmy.mechanics.time-evolution/shift-t",-1958879854,null);
JHb=new $APP.q("emmy.series","sec-series","emmy.series/sec-series",-1117861223,null);TE=new $APP.E(null,"ns-var-clash","ns-var-clash",-280494668);y7a=new $APP.E(null,"beta","beta",455605892);KHb=new $APP.q(null,"as-segment-matcher","as-segment-matcher",1157084158,null);LHb=new $APP.q("emmy.env","seq:pprint","emmy.env/seq:pprint",1222098633,null);MHb=new $APP.q(null,"oneform-basis","oneform-basis",387946054,null);RH=new $APP.E("emmy.dual","forward","emmy.dual/forward",1374847395);
i7a=new $APP.E(null,"rename-functions","rename-functions",-358633973);NHb=new $APP.q(null,"pipe","pipe",1977107376,null);R4a=new $APP.q(null,"tensor-product","tensor-product",553408668,null);OHb=new $APP.q(null,"away-from","away-from",243379524,null);PHb=new $APP.q("emmy.generic","div","emmy.generic/div",-192474278,null);QHb=new $APP.E(null,"maxterms","maxterms",951779603);AV=new $APP.q(null,"structures","structures",1081902171,null);BV=new $APP.q(null,"row?","row?",2035501942,null);
RHb=new $APP.q("emmy.pattern.rule","succeed","emmy.pattern.rule/succeed",1594724563,null);SHb=new $APP.q("f","function?","f/function?",1729250043,null);THb=new $APP.q(null,"row*","row*",1238605271,null);UHb=new $APP.q(null,"by-cols","by-cols",2016712726,null);VHb=new $APP.q(null,"down-\x3erow-matrix","down-\x3erow-matrix",1694498822,null);r7a=new $APP.E(null,"zero-delta","zero-delta",-2009573292);WHb=new $APP.q(null,"from-angle-axis","from-angle-axis",770100623,null);
XHb=new $APP.E(null,"reloads","reloads",610698522);YHb=new $APP.q("emmy.pattern.match","with-frame","emmy.pattern.match/with-frame",905241676,null);ZHb=new $APP.q(null,"real?","real?",-118641994,null);$Hb=new $APP.q("emmy.matrix","nth-col","emmy.matrix/nth-col",-748337469,null);aIb=new $APP.q(null,"match","match",-1434376219,null);bIb=new $APP.q("emmy.env","sinhc","emmy.env/sinhc",-330734025,null);cIb=new $APP.q(null,"R1-rect","R1-rect",-127853232,null);
dIb=new $APP.q(null,"structure?","structure?",-1962489375,null);eIb=new $APP.E("cljs.analyzer","protocol-inline","cljs.analyzer/protocol-inline",-1611519026);mVa=new $APP.E(null,"ns-whitelist","ns-whitelist",-1717299774);fIb=new $APP.E(null,"initializer","initializer",-2068366756);gIb=new $APP.q(null,"linear","linear",-1782167072,null);hIb=new $APP.q("emmy.env","down-\x3erow-matrix","emmy.env/down-\x3erow-matrix",-1549879215,null);
CV=new $APP.q(null,"orthonormal-basis","orthonormal-basis",735254493,null);iIb=new $APP.q("emmy.expression","sort","emmy.expression/sort",-188144105,null);DV=new $APP.q(null,"lcm","lcm",-1699262564,null);jIb=new $APP.q(null,"arities","arities",-140591390,null);kIb=new $APP.q(null,"simplify-expression","simplify-expression",1167243796,null);lIb=new $APP.E(null,"preamble-missing","preamble-missing",220974801);mIb=new $APP.q(null,"map-chain","map-chain",299004316,null);
nIb=new $APP.q("emmy.env","add-velocities","emmy.env/add-velocities",273637877,null);oIb=new $APP.q("emmy.matrix","column-matrix-\x3eup","emmy.matrix/column-matrix-\x3eup",905687444,null);pIb=new $APP.q("emmy.structure","opposite","emmy.structure/opposite",-1762053614,null);qIb=new $APP.q("s","structure?","s/structure?",-1962489518,null);rIb=new $APP.q("emmy.sr.boost","make-four-tuple","emmy.sr.boost/make-four-tuple",1930993077,null);sIb=new $APP.q(null,"diagonal?","diagonal?",2008193921,null);
tIb=new $APP.q(null,"row-matrix-\x3edown","row-matrix-\x3edown",273914986,null);uIb=new $APP.E(null,"case-node","case-node",1016946320);vIb=new $APP.q("emmy.expression.render","*TeX-sans-serif-symbols*","emmy.expression.render/*TeX-sans-serif-symbols*",540739176,null);EV=new $APP.E(null,"spherical","spherical",556747504);FV=new $APP.q(null,"atanh","atanh",-1915750692,null);wIb=new $APP.q("emmy.util","arithmetic-ex","emmy.util/arithmetic-ex",1745810371,null);
xIb=new $APP.q("emmy.env","Dt","emmy.env/Dt",1351832822,null);GV=new $APP.q(null,"ctor","ctor",-903570967,null);Qxb=new $APP.q(null,"manifold-point","manifold-point",1980743222,null);zIb=new $APP.q("emmy.calculus.manifold","S3-tilted","emmy.calculus.manifold/S3-tilted",1493212961,null);AIb=new $APP.q(null,"kinetic-energy","kinetic-energy",1014555443,null);BIb=new $APP.q(null,"asinh-series","asinh-series",1808136764,null);
CIb=new $APP.q("emmy.calculus.form-field","basis-components-\x3eoneform-field","emmy.calculus.form-field/basis-components-\x3eoneform-field",-1625831825,null);HV=new $APP.q(null,"??pre","??pre",-1767241378,null);E8a=new $APP.E(null,"roundoff-cutoff","roundoff-cutoff",1739938187);DIb=new $APP.q(null,"get-rank","get-rank",1510807712,null);EIb=new $APP.q("emmy.calculus.form-field","coordinate-basis-oneform-field","emmy.calculus.form-field/coordinate-basis-oneform-field",1698080815,null);
FIb=new $APP.q(null,"litfns","litfns",1494839179,null);GIb=new $APP.q("emmy.util.logic","assume!","emmy.util.logic/assume!",-1355379731,null);HIb=new $APP.q("emmy.polynomial.gcd","*poly-gcd-cache-enable*","emmy.polynomial.gcd/*poly-gcd-cache-enable*",-441417970,null);CP=new $APP.E(null,"forms","forms",2045992350);IIb=new $APP.q(null,"I-matrix","I-matrix",1453302592,null);BJ=new $APP.q(null,"log","log",45015523,null);JIb=new $APP.q(null,"lon","lon",-2132367332,null);
KIb=new $APP.q(null,"geodesic-equation","geodesic-equation",-872309078,null);IV=new $APP.q(null,"low","low",39169118,null);LIb=new $APP.q(null,"combinations","combinations",2103807122,null);MIb=new $APP.q(null,"abstract-types","abstract-types",-373599555,null);NIb=new $APP.q(null,"F-\x3eC","F-\x3eC",-977930553,null);OIb=new $APP.q("emmy.structure","two-up?","emmy.structure/two-up?",-391574187,null);PIb=new $APP.q("emmy.series","exp-series","emmy.series/exp-series",1727476580,null);
QIb=new $APP.q("emmy.expression.analyze","expression-simplifier","emmy.expression.analyze/expression-simplifier",1677657454,null);RIb=new $APP.q(null,"F-\x3eK","F-\x3eK",-401605312,null);CUa=new $APP.E(null,"blacklist","blacklist",1248093170);SIb=new $APP.q(null,"modulus","modulus",-856269542,null);TIb=new $APP.q(null,"compatible-zero","compatible-zero",-453704180,null);UIb=new $APP.q("emmy.calculus.metric","literal-metric","emmy.calculus.metric/literal-metric",-1683421293,null);
VIb=new $APP.q(null,"T-quaternion-state","T-quaternion-state",-2080111039,null);WIb=new $APP.q(null,"foreach-matcher","foreach-matcher",-233710187,null);XIb=new $APP.q("emmy.polynomial.richardson","richardson-fold","emmy.polynomial.richardson/richardson-fold",167889732,null);YIb=new $APP.q("emmy.numerical.ode","integrate-state-derivative","emmy.numerical.ode/integrate-state-derivative",-600109311,null);ZIb=new $APP.q(null,"log1+x-series","log1+x-series",-1437348439,null);
$Ib=new $APP.q("emmy.calculus.indexed","contract","emmy.calculus.indexed/contract",-13144785,null);aJb=new $APP.q("emmy.expression.analyze","expression-analyzer","emmy.expression.analyze/expression-analyzer",-1864556219,null);bJb=new $APP.q(null,"choice","choice",265360800,null);cJb=new $APP.q("emmy.simplify.rules","exponent-contract","emmy.simplify.rules/exponent-contract",296323466,null);dJb=new $APP.q("emmy.structure","vector-dot-product","emmy.structure/vector-dot-product",1487712319,null);
eJb=new $APP.q("emmy.rational-function","partial-derivatives","emmy.rational-function/partial-derivatives",1971985122,null);fJb=new $APP.q(null,"divergence","divergence",175362438,null);dYa=new $APP.q("cljs.core","rseq","cljs.core/rseq",-238610347,null);gJb=new $APP.q(null,"failed?","failed?",-2114702621,null);hJb=new $APP.q("emmy.function","arg-scale","emmy.function/arg-scale",-1148030600,null);iJb=new $APP.q("emmy.env","ff:zero","emmy.env/ff:zero",1612465500,null);
jJb=new $APP.q("emmy.polynomial","degree","emmy.polynomial/degree",527316293,null);kJb=new $APP.q(null,"split-polynomial","split-polynomial",-1324656555,null);lJb=new $APP.q("emmy.operator","anticommutator","emmy.operator/anticommutator",-718500646,null);mJb=new $APP.q("p","univariate?","p/univariate?",1606506258,null);nJb=new $APP.q("emmy.env","proper-time-interval","emmy.env/proper-time-interval",548627690,null);oJb=new $APP.q(null,"*fold*","*fold*",95822926,null);
$APP.pJb=new $APP.q(null,"stopwatch","stopwatch",-1262782731,null);qJb=new $APP.q("emmy.pattern.rule","while","emmy.pattern.rule/while",883830589,null);vPa=new $APP.E(null,"advanced","advanced",-451287892);rJb=new $APP.q("emmy.quaternion","sqrt","emmy.quaternion/sqrt",-971476234,null);sJb=new $APP.q("emmy.algebra.fold","fold-\x3esum-fn","emmy.algebra.fold/fold-\x3esum-fn",-276179943,null);z_a=new $APP.E(null,"-\x3epoly","-\x3epoly",360305471);JV=new $APP.q(null,"nrows","nrows",-1642567020,null);
tJb=new $APP.q("emmy.generic","sinh","emmy.generic/sinh",-382554945,null);uJb=new $APP.q("emmy.env","asech","emmy.env/asech",-1344784383,null);vJb=new $APP.q("emmy.mechanics.rotation","Rx-matrix","emmy.mechanics.rotation/Rx-matrix",408850487,null);wJb=new $APP.q("emmy.generic","sinc","emmy.generic/sinc",1985312038,null);xJb=new $APP.q(null,"r-\x3ep","r-\x3ep",-80303841,null);yJb=new $APP.q("emmy.value","IReal","emmy.value/IReal",-2003912387,null);
zJb=new $APP.q(null,"-\x3eH-state","-\x3eH-state",-1515806723,null);AJb=new $APP.q("emmy.calculus.manifold","spacetime","emmy.calculus.manifold/spacetime",1764407504,null);BJb=new $APP.q("emmy.generic","one?","emmy.generic/one?",1178660714,null);CJb=new $APP.q(null,"fmap","fmap",55293788,null);DJb=new $APP.q(null,"r-\x3es","r-\x3es",779371230,null);oO=new $APP.E("emmy.calculus.manifold","manifold","emmy.calculus.manifold/manifold",-1013288811);
EJb=new $APP.q("emmy.simplify.rules","half-angle","emmy.simplify.rules/half-angle",-501174445,null);FJb=new $APP.E(null,"protocol-with-variadic-method","protocol-with-variadic-method",-693368178);GJb=new $APP.q("emmy.generic","exp10","emmy.generic/exp10",811434464,null);HJb=new $APP.q("emmy.env","Poisson-bracket","emmy.env/Poisson-bracket",-1197327411,null);IJb=new $APP.q(null,"close-enuf?","close-enuf?",-677240843,null);
JJb=new $APP.q("emmy.util","compute-abs","emmy.util/compute-abs",1040305163,null);KJb=new $APP.q(null,"angular-parity","angular-parity",-340761058,null);LJb=new $APP.q("emmy.calculus.covariant","Christoffel-\x3eCartan","emmy.calculus.covariant/Christoffel-\x3eCartan",1806949234,null);MJb=new $APP.q("emmy.pattern.rule","ruleset","emmy.pattern.rule/ruleset",-1341856137,null);NJb=new $APP.q("emmy.numerical.unimin.golden","best-of","emmy.numerical.unimin.golden/best-of",-76851582,null);
OJb=new $APP.q(null,"base-frame-maker","base-frame-maker",-1120850446,null);PJb=new $APP.q("emmy.function","with-arity","emmy.function/with-arity",-1491928077,null);QJb=new $APP.q(null,"literal-oneform-field","literal-oneform-field",-502718763,null);KV=new $APP.E("emmy.operator","co-operator","emmy.operator/co-operator",-99060495);RJb=new $APP.q("emmy.mechanics.rigid","antisymmetric-\x3ecolumn-matrix","emmy.mechanics.rigid/antisymmetric-\x3ecolumn-matrix",1177730192,null);
SJb=new $APP.q("emmy.matrix","diagonal?","emmy.matrix/diagonal?",-1296565018,null);N4a=new $APP.q(null,"wedge","wedge",868448626,null);SE=new $APP.E(null,"import","import",-1399500709);E7a=new $APP.E(null,"fn-tolerance","fn-tolerance",-1445606164);TJb=new $APP.E(null,"bulirsch-stoer-open","bulirsch-stoer-open",-2130050405);UJb=new $APP.q("emmy.mechanics.lagrange","F-\x3eC","emmy.mechanics.lagrange/F-\x3eC",645967451,null);VJb=new $APP.q("emmy.matrix","s-\x3em","emmy.matrix/s-\x3em",-853133691,null);
WJb=new $APP.q(null,"power-series*","power-series*",-882059100,null);XJb=new $APP.q(null,"Ricci","Ricci",1070475462,null);YJb=new $APP.q("emmy.env","event?","emmy.env/event?",1130559928,null);LV=new $APP.q(null,"power-series?","power-series?",405041482,null);MV=new $APP.q(null,"state-derivative-args","state-derivative-args",-1910752878,null);ZJb=new $APP.q(null,"Polynomial","Polynomial",2054562416,null);$Jb=new $APP.q(null,"from-4x4-matrix","from-4x4-matrix",-733777051,null);
aKb=new $APP.q(null,"IReal","IReal",-443860270,null);bKb=new $APP.q(null,"literal-type","literal-type",-1586719306,null);cKb=new $APP.q("emmy.env","literal-manifold-function","emmy.env/literal-manifold-function",-2016692046,null);NV=new $APP.q(null,"Cartan","Cartan",-1256546560,null);dKb=new $APP.q(null,"S2-type","S2-type",-1290736783,null);eKb=new $APP.q("emmy.env","sharpen","emmy.env/sharpen",-1819606646,null);
fKb=new $APP.q("emmy.mechanics.lagrange","L-coupled-harmonic","emmy.mechanics.lagrange/L-coupled-harmonic",445832,null);gKb=new $APP.q(null,"s-\x3er","s-\x3er",-1726668015,null);hKb=new $APP.q("emmy.env","solve-linear-left","emmy.env/solve-linear-left",-1761402631,null);iKb=new $APP.q(null,"s-\x3em","s-\x3em",137060200,null);yUa=new $APP.E(null,"any","any",1705907423);OV=new $APP.q(null,"form-field?","form-field?",1252796196,null);
jKb=new $APP.q(null,"parametric-path-action","parametric-path-action",863239064,null);kKb=new $APP.q(null,"set-compiler-mode!","set-compiler-mode!",-768746968,null);lKb=new $APP.q("emmy.quaternion","*angle-axis-tolerance*","emmy.quaternion/*angle-axis-tolerance*",-1483012063,null);mKb=new $APP.q(null,"bulirsch-stoer-scan","bulirsch-stoer-scan",-1711062801,null);nKb=new $APP.q("emmy.ratio","IRational","emmy.ratio/IRational",770773424,null);
$E=new $APP.q(null,"constructor","constructor",-313397284,null);oKb=new $APP.q("emmy.env","standard-map","emmy.env/standard-map",-2065875678,null);pKb=new $APP.q("emmy.mechanics.lagrange","find-path","emmy.mechanics.lagrange/find-path",1560510233,null);qKb=new $APP.q(null,"S1-slope","S1-slope",-1191127613,null);rKb=new $APP.q(null,"s:transpose-orientation","s:transpose-orientation",1694629066,null);
sKb=new $APP.q("emmy.rational-function","rational-function?","emmy.rational-function/rational-function?",864024213,null);tKb=new $APP.q(null,"partial-reverse","partial-reverse",1108129073,null);y3a=new $APP.E(null,"coordinate-representations","coordinate-representations",-676047034);uKb=new $APP.q("emmy.mechanics.lagrange","accelerations","emmy.mechanics.lagrange/accelerations",-88277009,null);DRa=new $APP.E(null,"invalid-arithmetic","invalid-arithmetic",1917075065);
pUa=new $APP.E(null,"req-id-fn","req-id-fn",-1580886496);vKb=new $APP.q(null,"pochhammer","pochhammer",-1887028579,null);wKb=new $APP.q("emmy.algebra.fold","kbn","emmy.algebra.fold/kbn",-2000775869,null);xKb=new $APP.q("Math","atan","Math/atan",-1027632159,null);YVa=new $APP.E(null,"timestamp_","timestamp_",-954533417);yKb=new $APP.q("emmy.mechanics.lagrange","r-\x3es","emmy.mechanics.lagrange/r-\x3es",-819500230,null);
zKb=new $APP.q("emmy.calculus.manifold","literal-manifold-function","emmy.calculus.manifold/literal-manifold-function",-261697989,null);AKb=new $APP.q("emmy.mechanics.lagrange","r-\x3ep","emmy.mechanics.lagrange/r-\x3ep",1510064507,null);BKb=new $APP.q(null,"*active-tags*","*active-tags*",-1386974245,null);CKb=new $APP.q("emmy.calculus.frame","-\x3et_emmy$calculus$frame49289","emmy.calculus.frame/-\x3et_emmy$calculus$frame49289",-167679840,null);
DKb=new $APP.q(null,"typical-object","typical-object",-699041232,null);EKb=new $APP.q("emmy.env","constant-series","emmy.env/constant-series",918263055,null);FKb=new $APP.q("emmy.util","illegal-state","emmy.util/illegal-state",1880242933,null);GKb=new $APP.q(null,"backward-difference","backward-difference",-700667341,null);HKb=new $APP.q(null,"embedded","embedded",1525045279,null);PV=new $APP.q(null,"make-rectangular","make-rectangular",-1494662174,null);
QV=new $APP.q(null,"success-pattern","success-pattern",-1825317762,null);IKb=new $APP.q("Math","sin","Math/sin",1723896309,null);JKb=new $APP.q("emmy.polynomial","raise-arity","emmy.polynomial/raise-arity",91943693,null);CQ=new $APP.E(null,"terms-checked","terms-checked",1046419519);KKb=new $APP.q("emmy.quaternion","cross-product","emmy.quaternion/cross-product",-48968835,null);LKb=new $APP.q("emmy.mechanics.rigid","L-space-Euler","emmy.mechanics.rigid/L-space-Euler",962470983,null);
dF=new $APP.E(null,"js-op","js-op",-1046277897);MKb=new $APP.q(null,"Routhian-state-\x3eLagrangian-state","Routhian-state-\x3eLagrangian-state",1553598135,null);NKb=new $APP.q(null,"??terms","??terms",1737460425,null);OKb=new $APP.q(null,"ff:zero","ff:zero",628755951,null);y5a=new $APP.q(null,"pullback","pullback",-1132207426,null);PKb=new $APP.q(null,"K-matrix","K-matrix",-1333593383,null);QKb=new $APP.q("emmy.matrix","literal-column-matrix","emmy.matrix/literal-column-matrix",-255899035,null);
RKb=new $APP.q("emmy.env","basis-\x3ebasis-over-map","emmy.env/basis-\x3ebasis-over-map",268469906,null);SKb=new $APP.q(null,"i:outer-product","i:outer-product",-1864743308,null);TKb=new $APP.q("emmy.generic","tanh","emmy.generic/tanh",1214314566,null);UKb=new $APP.q("emmy.calculus.derivative","D-as-matrix","emmy.calculus.derivative/D-as-matrix",-1135641055,null);VKb=new $APP.q(null,"ascending-by","ascending-by",670443144,null);
WKb=new $APP.q("emmy.env","compatible-zero","emmy.env/compatible-zero",689688283,null);OUa=new $APP.E(null,"msg_","msg_",-1925147E3);XKb=new $APP.q(null,"defgeneric","defgeneric",-1097306948,null);YKb=new $APP.q("emmy.generic","numeric-zero?","emmy.generic/numeric-zero?",-2117490555,null);Z8a=new $APP.E(null,"bs-extrapolator","bs-extrapolator",2042406575);ZKb=new $APP.q(null,"D-as-matrix","D-as-matrix",1433947152,null);oH=new $APP.q(null,"two-pi","two-pi",1398792117,null);
RV=new $APP.q("emmy.function","IArity","emmy.function/IArity",-1048419713,null);$Kb=new $APP.q(null,"*trig-product-to-sum-simplify?*","*trig-product-to-sum-simplify?*",1248606547,null);aLb=new $APP.q("emmy.calculus.manifold","S2-stereographic","emmy.calculus.manifold/S2-stereographic",-1069834302,null);SV=new $APP.q("cljs.core","IKVReduce","cljs.core/IKVReduce",878013381,null);bLb=new $APP.q("emmy.env","ref","emmy.env/ref",-318209511,null);
cLb=new $APP.q(null,"auxiliary-variable-fetcher","auxiliary-variable-fetcher",1143678719,null);dLb=new $APP.q("emmy.calculus.map","form-field-\x3eform-field-over-map","emmy.calculus.map/form-field-\x3eform-field-over-map",1243331136,null);eLb=new $APP.q("emmy.util","counted","emmy.util/counted",1494060608,null);fLb=new $APP.q("emmy.abstract.function","literal-function?","emmy.abstract.function/literal-function?",-1672306465,null);
gLb=new $APP.q("emmy.calculus.form-field","oneform-field?","emmy.calculus.form-field/oneform-field?",20076334,null);hLb=new $APP.q(null,"H-\x3eHp","H-\x3eHp",1522090576,null);iLb=new $APP.q(null,"I-tensor","I-tensor",-2120684949,null);jLb=new $APP.q("emmy.env","abs","emmy.env/abs",284179689,null);vQa=new $APP.E(null,"recurs","recurs",-1959309309);kLb=new $APP.q(null,"expand-multiangle","expand-multiangle",-521128157,null);lLb=new $APP.q("emmy.env","dimension","emmy.env/dimension",1083057198,null);
mLb=new $APP.q(null,"Lagrangian-action","Lagrangian-action",1827700271,null);MD=new $APP.E(null,"ret","ret",-468222814);nLb=new $APP.q("emmy.env","spacetime-sphere","emmy.env/spacetime-sphere",823907256,null);oLb=new $APP.q("emmy.series","log1-x-series","emmy.series/log1-x-series",175576372,null);pLb=new $APP.q("clojure.core","quot","clojure.core/quot",-292848233,null);qLb=new $APP.q("emmy.function","joint-arity","emmy.function/joint-arity",1758939772,null);
rLb=new $APP.q("emmy.numerical.unimin.golden","convergence-fn","emmy.numerical.unimin.golden/convergence-fn",-609005837,null);sLb=new $APP.q("emmy.dual","FORWARD-MODE","emmy.dual/FORWARD-MODE",-857400135,null);tLb=new $APP.q("emmy.env","make-constant-vector-field","emmy.env/make-constant-vector-field",945721088,null);uLb=new $APP.q("emmy.mechanics.rigid","M-of-q-\x3eomega-body-of-t","emmy.mechanics.rigid/M-of-q-\x3eomega-body-of-t",-355693121,null);
vLb=new $APP.q("emmy.env","form-field?","emmy.env/form-field?",-137465975,null);wLb=new $APP.q(null,"inverse-orientation","inverse-orientation",338347381,null);xLb=new $APP.E(null,"event-\x3ecoords","event-\x3ecoords",-1721892030);yLb=new $APP.q("emmy.pattern.match","pattern-\x3ecombinators","emmy.pattern.match/pattern-\x3ecombinators",647621013,null);zLb=new $APP.q(null,"zero-manifold-function","zero-manifold-function",-429657829,null);ALb=new $APP.q(null,"binding?","binding?",568605883,null);
BLb=new $APP.q("cljs.core","IRecord","cljs.core/IRecord",635852E3,null);CLb=new $APP.q("emmy.mechanics.lagrange","velocity","emmy.mechanics.lagrange/velocity",-567545248,null);DLb=new $APP.q("emmy.env","nelder-mead","emmy.env/nelder-mead",397886904,null);ELb=new $APP.q("emmy.polynomial.factor","root-out-squares","emmy.polynomial.factor/root-out-squares",-189763287,null);FLb=new $APP.q("emmy.simplify.rules","sqrt-expand","emmy.simplify.rules/sqrt-expand",2018789844,null);
GLb=new $APP.q("emmy.generic","tanc","emmy.generic/tanc",-200779884,null);HLb=new $APP.q("emmy.quaternion","-\x3ecomplex-matrix","emmy.quaternion/-\x3ecomplex-matrix",842120886,null);ILb=new $APP.q(null,"sqrt-expand","sqrt-expand",-1216298848,null);JLb=new $APP.q("emmy.dual","primal","emmy.dual/primal",-312375937,null);KLb=new $APP.q("emmy.mechanics.hamilton","J-matrix","emmy.mechanics.hamilton/J-matrix",870346702,null);LLb=new $APP.q(null,"fail-pattern","fail-pattern",-762279763,null);
MLb=new $APP.q("emmy.matrix","general-determinant","emmy.matrix/general-determinant",-648645511,null);NLb=new $APP.q(null,"magnitude-sq","magnitude-sq",1337215013,null);OLb=new $APP.q(null,"hermetic-simplify-fixture","hermetic-simplify-fixture",-1682214452,null);PLb=new $APP.q(null,"sequence*","sequence*",-438978911,null);QLb=new $APP.q("emmy.calculus.frame","frame-owner","emmy.calculus.frame/frame-owner",563654146,null);RLb=new $APP.q(null,"nelder-mead","nelder-mead",-737112619,null);
SLb=new $APP.q("emmy.env","ceiling","emmy.env/ceiling",-295499900,null);TLb=new $APP.q("emmy.simplify.rules","constant-elimination","emmy.simplify.rules/constant-elimination",1568976652,null);ULb=new $APP.q(null,"hirow","hirow",-388964312,null);VLb=new $APP.q("emmy.matrix","classical-adjoint-formula","emmy.matrix/classical-adjoint-formula",-1528230048,null);WLb=new $APP.q("emmy.generic","solve-linear-left","emmy.generic/solve-linear-left",-1100374289,null);
XLb=new $APP.q("emmy.util.stream","vector:generate","emmy.util.stream/vector:generate",-2015822602,null);pQ=new $APP.E(null,"iterations","iterations",-1402710890);TV=new $APP.q(null,"annihilate?","annihilate?",-1123484107,null);YLb=new $APP.q(null,"permutation-parity","permutation-parity",915608661,null);ZLb=new $APP.q(null,"all-results-matcher","all-results-matcher",-86570498,null);$Lb=new $APP.q("cljs.core","IFind","cljs.core/IFind",-1727519574,null);
aMb=new $APP.q("emmy.series","cosh-series","emmy.series/cosh-series",-1375263612,null);bMb=new $APP.q(null,"momenta","momenta",-1206749655,null);cMb=new $APP.q("emmy.pattern.rule","predicate","emmy.pattern.rule/predicate",-1468552105,null);mZa=new $APP.q(null,"asin-sin","asin-sin",1881703610,null);dMb=new $APP.E(null,"absolute-threshold","absolute-threshold",842199714);aVa=new $APP.E(null,"given","given",716253602);eSa=new $APP.E("cljs.analyzer","numeric","cljs.analyzer/numeric",1415704188);
eMb=new $APP.q(null,"symmetric?","symmetric?",-57665610,null);yVa=new $APP.E(null,"?line","?line",-631853385);fMb=new $APP.E(null,"unchecked","unchecked",924418378);qQ=new $APP.E(null,"fncalls","fncalls",-71376182);gMb=new $APP.q(null,"integral?","integral?",-2027571295,null);hMb=new $APP.E(null,"console","console",1228072057);BO=new $APP.E("emmy.calculus.manifold","coord-prototype","emmy.calculus.manifold/coord-prototype",1491234441);
iMb=new $APP.q("emmy.env","D-as-matrix","emmy.env/D-as-matrix",-1863961501,null);g5a=new $APP.E(null,"index-types","index-types",1378319778);jMb=new $APP.q(null,"Euler-\x3eM","Euler-\x3eM",464914845,null);kMb=new $APP.q(null,"-\x3epower-series","-\x3epower-series",1468094218,null);lMb=new $APP.q("emmy.value","native-integral?","emmy.value/native-integral?",1753848439,null);mMb=new $APP.q("emmy.matrix","symmetric?","emmy.matrix/symmetric?",1066577107,null);
nMb=new $APP.q(null,"-\x3et_emmy$calculus$frame49289","-\x3et_emmy$calculus$frame49289",940707331,null);oMb=new $APP.q("emmy.operator","operator?","emmy.operator/operator?",1492593972,null);pMb=new $APP.q(null,"state-\x3eqdot","state-\x3eqdot",-1840399599,null);qMb=new $APP.q("emmy.value","object-name-map","emmy.value/object-name-map",-594874490,null);rMb=new $APP.q("emmy.polynomial","divisible?","emmy.polynomial/divisible?",2056050620,null);sMb=new $APP.E(null,"foreign","foreign",990521149);
tMb=new $APP.q("emmy.calculus.vector-calculus","Curl","emmy.calculus.vector-calculus/Curl",-1071808338,null);uMb=new $APP.q("emmy.matrix","some","emmy.matrix/some",544981599,null);vMb=new $APP.q("emmy.special.elliptic","elliptic-integrals","emmy.special.elliptic/elliptic-integrals",1429465819,null);wMb=new $APP.q("emmy.simplify","simplify-expression","emmy.simplify/simplify-expression",1181016553,null);xMb=new $APP.q(null,"multipolar","multipolar",-56699270,null);
yMb=new $APP.q("cljs.core","sequential?","cljs.core/sequential?",1777854658,null);zMb=new $APP.q(null,"v:make-basis-unit","v:make-basis-unit",381319342,null);AMb=new $APP.q("emmy.polynomial.factor","factor-expression","emmy.polynomial.factor/factor-expression",-1612667005,null);UZa=new $APP.E(null,"outer-size","outer-size",705588E3);BMb=new $APP.q("emmy.simplify.rules","log-extra","emmy.simplify.rules/log-extra",-642709194,null);
CMb=new $APP.q("emmy.numerical.minimize","multidimensional-minimize","emmy.numerical.minimize/multidimensional-minimize",-1097077005,null);DMb=new $APP.q("emmy.env","nform-field?","emmy.env/nform-field?",-1944080678,null);EMb=new $APP.q("emmy.calculus.manifold","R3-rect","emmy.calculus.manifold/R3-rect",404693097,null);FMb=new $APP.q(null,"sort-and-permute","sort-and-permute",-501389748,null);GMb=new $APP.q(null,"succeed-r","succeed-r",2090866930,null);
HMb=new $APP.q(null,"permutation-sequence","permutation-sequence",-182988279,null);IMb=new $APP.q("emmy.rational-function.interpolate","bs-merge","emmy.rational-function.interpolate/bs-merge",-1114663297,null);JMb=new $APP.q("emmy.mechanics.lagrange","L-uniform-acceleration","emmy.mechanics.lagrange/L-uniform-acceleration",1261170057,null);KMb=new $APP.q(null,"chinese-remainder","chinese-remainder",-54537496,null);LMb=new $APP.q("emmy.sr.frames","the-ether","emmy.sr.frames/the-ether",1000657076,null);
MMb=new $APP.q(null,"throwable?","throwable?",2142132606,null);NMb=new $APP.q(null,"Lagrangian-\x3eHamiltonian","Lagrangian-\x3eHamiltonian",570239049,null);OMb=new $APP.q(null,"logexp","logexp",1571978223,null);PMb=new $APP.E(null,"get-var-\x3eexpr","get-var-\x3eexpr",201158735);QMb=new $APP.q(null,"from-basis","from-basis",-1326422435,null);RMb=new $APP.q("emmy.rational-function.interpolate","bs-prepare","emmy.rational-function.interpolate/bs-prepare",-2112100550,null);
zVa=new $APP.E(null,"location","location",1815599388);Uxb=new $APP.q(null,"literal-scalar-field","literal-scalar-field",1822360517,null);$APP.TMb=new $APP.q(null,"Array","Array",-423496279,null);UMb=new $APP.q("emmy.mechanics.rigid","L-body","emmy.mechanics.rigid/L-body",-1977479615,null);UV=new $APP.q(null,"Hamiltonian","Hamiltonian",-802031359,null);VMb=new $APP.q("emmy.env","basis-\x3eoneform-basis","emmy.env/basis-\x3eoneform-basis",1247242917,null);
VV=new $APP.q(null,"components","components",567342585,null);WMb=new $APP.q(null,"ZERO","ZERO",-1889270687,null);XMb=new $APP.q("emmy.calculus.indexed","argument-types","emmy.calculus.indexed/argument-types",-903324821,null);YMb=new $APP.q(null,"tableau-fn","tableau-fn",-1503017027,null);ZMb=new $APP.q("emmy.generic","make-rectangular","emmy.generic/make-rectangular",-1708893731,null);WV=new $APP.q(null,"integer-part","integer-part",-1884537015,null);
$Mb=new $APP.q("emmy.mechanics.lagrange","Lagrangian","emmy.mechanics.lagrange/Lagrangian",450869303,null);aNb=new $APP.q(null,"Cartan-\x3ebasis","Cartan-\x3ebasis",-113570833,null);bNb=new $APP.q("emmy.series","zero","emmy.series/zero",1964707476,null);cNb=new $APP.q("emmy.generic","inner-product","emmy.generic/inner-product",-23047757,null);jI=new $APP.E("emmy.function","cofunction","emmy.function/cofunction",-944520219);dNb=new $APP.q("cljs.core","vector","cljs.core/vector",720641726,null);
eNb=new $APP.q(null,"sincos-random","sincos-random",1576329430,null);fNb=new $APP.q("emmy.calculus.manifold","typical-coords","emmy.calculus.manifold/typical-coords",-1249724224,null);gNb=new $APP.q("emmy.algebra.fold","fold-\x3escan-fn","emmy.algebra.fold/fold-\x3escan-fn",225103671,null);hNb=new $APP.q("emmy.env","coth","emmy.env/coth",-2052877033,null);iNb=new $APP.q("emmy.sr.boost","proper-time-interval","emmy.sr.boost/proper-time-interval",2052197263,null);
jNb=new $APP.q(null,"frame-maker","frame-maker",1417055762,null);kNb=new $APP.q(null,"FORWARD-MODE","FORWARD-MODE",-587068717,null);vCb=new $APP.q("emmy.calculus.manifold","attach-coordinate-system","emmy.calculus.manifold/attach-coordinate-system",1691756532,null);$APP.mNb=new $APP.q(null,"evolve","evolve",2074557427,null);nNb=new $APP.E(null,"get-expr-\x3evar","get-expr-\x3evar",-224197397);oNb=new $APP.q("emmy.env","cosh","emmy.env/cosh",-908004761,null);
XV=new $APP.q(null,"integration-opts","integration-opts",185824687,null);pNb=new $APP.q("emmy.series","xpow","emmy.series/xpow",1067226227,null);qNb=new $APP.q(null,"series","series",-2053725075,null);rNb=new $APP.q(null,"L-two-particle","L-two-particle",-625685417,null);sNb=new $APP.q("emmy.rational-function","arg-scale","emmy.rational-function/arg-scale",-480127035,null);tNb=new $APP.q(null,"order","order",385854271,null);
uNb=new $APP.q("emmy.simplify.rules","*half-angle-simplify?*","emmy.simplify.rules/*half-angle-simplify?*",-1515708850,null);vNb=new $APP.q("emmy.numerical.minimize","minimize","emmy.numerical.minimize/minimize",807990955,null);wNb=new $APP.q(null,"modified-bulirsch-stoer-scan","modified-bulirsch-stoer-scan",1926311504,null);xNb=new $APP.q("emmy.mechanics.hamilton","two-particle-center-of-mass-canonical","emmy.mechanics.hamilton/two-particle-center-of-mass-canonical",-1024015249,null);
yNb=new $APP.q("emmy.expression","abstract?","emmy.expression/abstract?",988104029,null);zNb=new $APP.q(null,"exterior-derivative","exterior-derivative",465479974,null);ANb=new $APP.q(null,"neville-incremental","neville-incremental",-1672797294,null);BNb=new $APP.q(null,"compute-abs","compute-abs",224551279,null);CNb=new $APP.q("emmy.env","time-independent-canonical?","emmy.env/time-independent-canonical?",-2059145314,null);
DNb=new $APP.q("emmy.env","angle-axis-\x3erotation-matrix","emmy.env/angle-axis-\x3erotation-matrix",-1974985499,null);ENb=new $APP.q("emmy.quaternion","-\x3eQuaternion","emmy.quaternion/-\x3eQuaternion",1314177045,null);FNb=new $APP.q("emmy.mechanics.lagrange","path-\x3estate-path","emmy.mechanics.lagrange/path-\x3estate-path",-1022435313,null);GNb=new $APP.q("emmy.complex","round","emmy.complex/round",1115486733,null);iK=new $APP.q(null,"gcd","gcd",1659909537,null);
HNb=new $APP.E(null,"protocol-impl-recur-with-target","protocol-impl-recur-with-target",-1648321574);INb=new $APP.q("emmy.calculus.form-field","ff:zero","emmy.calculus.form-field/ff:zero",-1824687948,null);JNb=new $APP.E(null,"upper-riemann","upper-riemann",1525159164);KNb=new $APP.q(null,"*poly-gcd-debug*","*poly-gcd-debug*",-407696875,null);LNb=new $APP.E(null,"name-format","name-format",1974377103);MNb=new $APP.q(null,"literal-manifold-function","literal-manifold-function",-894930843,null);
NNb=new $APP.q("Math","asin","Math/asin",-889681202,null);ONb=new $APP.q("emmy.polynomial.gcd","classical-gcd","emmy.polynomial.gcd/classical-gcd",2136820552,null);PNb=new $APP.q("emmy.calculus.map","vector-field-\x3evector-field-over-map","emmy.calculus.map/vector-field-\x3evector-field-over-map",421796679,null);QNb=new $APP.q("emmy.structure","two-tensor?","emmy.structure/two-tensor?",-758378215,null);RNb=new $APP.q(null,"tableau-fold-fn","tableau-fold-fn",521156139,null);
SNb=new $APP.q("emmy.env","-pi","emmy.env/-pi",-1729037675,null);TNb=new $APP.q("emmy.quaternion","eq","emmy.quaternion/eq",216611588,null);UNb=new $APP.q("emmy.matrix","antisymmetric?","emmy.matrix/antisymmetric?",788081991,null);VG=new $APP.E(null,"output-opts","output-opts",-793411325);VNb=new $APP.q(null,"angle-axis-\x3erotation-matrix","angle-axis-\x3erotation-matrix",1240127312,null);WNb=new $APP.q("emmy.pattern.match","map-\x3eFailure","emmy.pattern.match/map-\x3eFailure",-1100208696,null);
XNb=new $APP.q(null,"J-matrix","J-matrix",-388525949,null);YNb=new $APP.q(null,"attempt","attempt",-1042674461,null);ZNb=new $APP.q("cljs.core","map-entry?","cljs.core/map-entry?",465406728,null);$Nb=new $APP.q(null,"coordinate-functions","coordinate-functions",736537820,null);aOb=new $APP.q("cljs.core","IUUID","cljs.core/IUUID",-1606521379,null);bOb=new $APP.q(null,"gMR","gMR",1369866139,null);cOb=new $APP.q("emmy.polynomial.gcd","full-gcd","emmy.polynomial.gcd/full-gcd",1390497954,null);
$APP.JR=new $APP.E(null,"epsilon","epsilon",-730158570);dOb=new $APP.q("emmy.calculus.indexed","typed-\x3estructure","emmy.calculus.indexed/typed-\x3estructure",-1855045003,null);eOb=new $APP.q("emmy.quaternion","-\x3eangle-axis","emmy.quaternion/-\x3eangle-axis",504744342,null);fOb=new $APP.q(null,"term-rewriting","term-rewriting",-1893529052,null);gOb=new $APP.q("emmy.env","zero-manifold-function","emmy.env/zero-manifold-function",-1459603288,null);
hOb=new $APP.q("Math","floor","Math/floor",-774722964,null);iOb=new $APP.q(null,"characteristic-polynomial","characteristic-polynomial",-86494513,null);jOb=new $APP.q(null,"Div","Div",2085306215,null);kOb=new $APP.q("emmy.mechanics.time-evolution","H-\x3eHp","emmy.mechanics.time-evolution/H-\x3eHp",794464900,null);lOb=new $APP.q(null,"emmy.calculus.form-field","emmy.calculus.form-field",1897032132,null);
mOb=new $APP.q("emmy.calculus.manifold","SO3-type","emmy.calculus.manifold/SO3-type",-1219795580,null);ME=new $APP.E(null,"return","return",-1891502105);nOb=new $APP.q("emmy.matrix","identity?","emmy.matrix/identity?",-2087816678,null);rUa=new $APP.E("rl","reset","rl/reset",-800926172);qUa=new $APP.E(null,"gc-every","gc-every",-1661544691);oOb=new $APP.q("emmy.numerical.unimin.golden","inv-phi2","emmy.numerical.unimin.golden/inv-phi2",511323338,null);
pOb=new $APP.q("emmy.quaternion","normalize","emmy.quaternion/normalize",542684508,null);qOb=new $APP.q("emmy.calculus.basis","basis-\x3ecoordinate-system","emmy.calculus.basis/basis-\x3ecoordinate-system",1403958191,null);uUa=new $APP.E(null,"command","command",-894540724);YV=new $APP.q(null,"kind","kind",923265724,null);rOb=new $APP.q("emmy.calculus.vector-calculus","divergence","emmy.calculus.vector-calculus/divergence",853081072,null);ZV=new $APP.q(null,"??factors","??factors",1906330792,null);
sOb=new $APP.q("Math","abs","Math/abs",1400569394,null);$V=new $APP.q(null,"fns","fns",-1469296983,null);tOb=new $APP.q(null,"Lagrange-equations-operator","Lagrange-equations-operator",-1568036865,null);uOb=new $APP.q(null,"atan-series","atan-series",755642859,null);vOb=new $APP.q("emmy.env","make-SR-frame","emmy.env/make-SR-frame",985930680,null);HD=new $APP.E(null,"refer-clojure","refer-clojure",813784440);
wOb=new $APP.q("emmy.env","one-manifold-function","emmy.env/one-manifold-function",1080774493,null);aW=new $APP.q(null,"state-derivative","state-derivative",-1453255724,null);bW=new $APP.q(null,"observe","observe",1553880077,null);xOb=new $APP.q("emmy.calculus.covariant","Cartan-\x3eforms","emmy.calculus.covariant/Cartan-\x3eforms",-7442898,null);yOb=new $APP.q("emmy.env","coordinate-system-\x3einverse-metric","emmy.env/coordinate-system-\x3einverse-metric",-1657682781,null);
tRa=new $APP.E(null,"host-field","host-field",-72662140);zOb=new $APP.q("emmy.quaternion","partial-derivative","emmy.quaternion/partial-derivative",-557923899,null);AOb=new $APP.q(null,"metric-over-map","metric-over-map",-1970394890,null);BOb=new $APP.q(null,"spacetime","spacetime",1382825726,null);COb=new $APP.q(null,"branch","branch",1565897602,null);DOb=new $APP.E(null,"existing","existing",-340796094);
EOb=new $APP.q("emmy.simplify","hermetic-simplify-fixture","emmy.simplify/hermetic-simplify-fixture",-1739515729,null);FOb=new $APP.q(null,"qv-\x3elocal-path","qv-\x3elocal-path",313422824,null);GOb=new $APP.q("emmy.env","vector-field-\x3evector-field-over-map","emmy.env/vector-field-\x3evector-field-over-map",2070682500,null);HOb=new $APP.q(null,"make-Cartan","make-Cartan",-461348288,null);
IOb=new $APP.q("emmy.calculus.vector-calculus","Laplacian","emmy.calculus.vector-calculus/Laplacian",-1453304654,null);JOb=new $APP.q(null,"reciprocal","reciprocal",-654944955,null);KOb=new $APP.q("emmy.env","structure?","emmy.env/structure?",1235517874,null);$APP.xQ=new $APP.E(null,"primitive","primitive",1884541424);bab=new $APP.q("cljs.core","array-reduce","cljs.core/array-reduce",569260567,null);m8a=new $APP.E(null,"prepend","prepend",342616040);
LOb=new $APP.q("emmy.series","fmap","emmy.series/fmap",1525964941,null);MOb=new $APP.q("emmy.env","with-index-types","emmy.env/with-index-types",1164135777,null);NOb=new $APP.q("emmy.mechanics.hamilton","momentum","emmy.mechanics.hamilton/momentum",-827596440,null);OOb=new $APP.q(null,"golden-section-min","golden-section-min",-1566310259,null);HVa=new $APP.E(null,"fatal","fatal",1874419888);POb=new $APP.q(null,"oneform-field-\x3ecomponents","oneform-field-\x3ecomponents",154814502,null);
cW=new $APP.q(null,"*mode*","*mode*",-1741124710,null);C4a=new $APP.E(null,"rank","rank",-1706728502);QOb=new $APP.q("emmy.generic","asinh","emmy.generic/asinh",-118937728,null);ROb=new $APP.q("emmy.util.permute","permutation-parity","emmy.util.permute/permutation-parity",861029993,null);SOb=new $APP.q(null,"-\x3econtent+primitive","-\x3econtent+primitive",-2054346989,null);uQa=new $APP.E(null,"fn-method","fn-method",236100839);
TOb=new $APP.q("emmy.mechanics.hamilton","H-central-polar","emmy.mechanics.hamilton/H-central-polar",992127210,null);UOb=new $APP.q(null,"Laplacian","Laplacian",-1308705980,null);VOb=new $APP.q(null,"neville","neville",1283153265,null);WOb=new $APP.q(null,"default-simplifier","default-simplifier",2144884890,null);XOb=new $APP.q("emmy.util","illegal","emmy.util/illegal",1939333508,null);STa=new $APP.q(null,"accs__38715__auto__","accs__38715__auto__",-1790262291,null);
dW=new $APP.q(null,"over","over",1833084578,null);YOb=new $APP.q(null,"two-tensor?","two-tensor?",269900542,null);ZOb=new $APP.q("emmy.mechanics.lagrange","Lagrangian-\x3epower-loss","emmy.mechanics.lagrange/Lagrangian-\x3epower-loss",1321794453,null);eW=new $APP.q(null,"csch","csch",-1950330545,null);$Ob=new $APP.q("emmy.calculus.frame","frame-name","emmy.calculus.frame/frame-name",1846629717,null);aPb=new $APP.q(null,"operands","operands",1252182965,null);
bPb=new $APP.q("emmy.env","Riemann-curvature","emmy.env/Riemann-curvature",-635246067,null);cPb=new $APP.q("emmy.env","Lagrange-equations","emmy.env/Lagrange-equations",2043900427,null);M2a=new $APP.E("emmy.calculus.frame","event?","emmy.calculus.frame/event?",-489879263);dPb=new $APP.q("emmy.polynomial","from-points","emmy.polynomial/from-points",351153616,null);ePb=new $APP.q("s","down?","s/down?",-953416421,null);fPb=new $APP.q(null,"golden-section-max","golden-section-max",-2130564727,null);
gPb=new $APP.q("emmy.quaternion","complex-2","emmy.quaternion/complex-2",758302746,null);hPb=new $APP.q("emmy.quaternion","complex-1","emmy.quaternion/complex-1",-1850455712,null);iPb=new $APP.E(null,"case-test","case-test",-213512472);jPb=new $APP.q("emmy.calculus.map","pullback-form","emmy.calculus.map/pullback-form",1613487422,null);kPb=new $APP.q("emmy.env","dual-zero","emmy.env/dual-zero",2091382876,null);KGb=new $APP.q(null,"check-point","check-point",689371383,null);
mPb=new $APP.q("emmy.mechanics.hamilton","symplectic?","emmy.mechanics.hamilton/symplectic?",-1235079964,null);nPb=new $APP.q(null,"sci-eval","sci-eval",-372056164,null);k7a=new $APP.E(null,"precedence-map","precedence-map",1892598799);oPb=new $APP.q("emmy.structure","structure-\x3eaccess-chains","emmy.structure/structure-\x3eaccess-chains",757760029,null);pPb=new $APP.q("emmy.polynomial.factor","poly-\x3efactored-expression","emmy.polynomial.factor/poly-\x3efactored-expression",-1937864867,null);
yIb=new $APP.q(null,"get-coordinates","get-coordinates",1704799803,null);x3a=new $APP.E("emmy.calculus.manifold","manifold-point","emmy.calculus.manifold/manifold-point",1526969857);rPb=new $APP.q("emmy.dual","equiv","emmy.dual/equiv",1278240065,null);sPb=new $APP.q("emmy.env","coordinate-system-names","emmy.env/coordinate-system-names",1781460769,null);tPb=new $APP.q("emmy.util.aggregate","*fold*","emmy.util.aggregate/*fold*",-311027229,null);
uPb=new $APP.q("emmy.expression","expression-\x3estring","emmy.expression/expression-\x3estring",559255347,null);vPb=new $APP.q("emmy.dual","tag-active?","emmy.dual/tag-active?",-1256082837,null);wPb=new $APP.q(null,"emmy.numerical.unimin.bracket","emmy.numerical.unimin.bracket",913531879,null);fW=new $APP.q(null,"asinh","asinh",-1398350397,null);xPb=new $APP.q("emmy.polynomial","c*xn","emmy.polynomial/c*xn",-412553423,null);
yPb=new $APP.q("emmy.util","sqrt-machine-epsilon","emmy.util/sqrt-machine-epsilon",-534779844,null);zPb=new $APP.q("emmy.quaternion","dot-product","emmy.quaternion/dot-product",-1008288780,null);APb=new $APP.E(null,"identity-like","identity-like",-98546347);gW=new $APP.q(null,"patch-name","patch-name",433729698,null);hW=new $APP.q(null,"metric","metric",2049329604,null);BPb=new $APP.q("emmy.env","literal-manifold-map","emmy.env/literal-manifold-map",-215370101,null);
CPb=new $APP.q("emmy.quaternion","exp","emmy.quaternion/exp",36458809,null);DPb=new $APP.q(null,"H-rectangular","H-rectangular",745243481,null);EPb=new $APP.q("emmy.env","ratio?","emmy.env/ratio?",564201594,null);v3a=new $APP.E(null,"coordinate-system-name","coordinate-system-name",-2088953179);FPb=new $APP.q("emmy.special.elliptic","carlson-rd","emmy.special.elliptic/carlson-rd",-1723075846,null);GPb=new $APP.E(null,"extract-id","extract-id",-1627068623);
HPb=new $APP.q("emmy.series","harmonic-series","emmy.series/harmonic-series",45400839,null);IPb=new $APP.q("emmy.util.permute","-\x3et_emmy$util$permute49487","emmy.util.permute/-\x3et_emmy$util$permute49487",105795006,null);JPb=new $APP.q(null,"m-\x3es","m-\x3es",1355461087,null);KPb=new $APP.q("emmy.special.elliptic","carlson-rf","emmy.special.elliptic/carlson-rf",1780713972,null);LPb=new $APP.q("emmy.special.elliptic","carlson-rc","emmy.special.elliptic/carlson-rc",-40319854,null);
MPb=new $APP.q(null,"permutations","permutations",-1558265014,null);NPb=new $APP.q(null,"constant-series","constant-series",-1961271942,null);OPb=new $APP.q("emmy.special.elliptic","carlson-rj","emmy.special.elliptic/carlson-rj",1380517454,null);PPb=new $APP.q("emmy.env","make-basis","emmy.env/make-basis",1052746631,null);QPb=new $APP.q("emmy.calculus.form-field","literal-oneform-field","emmy.calculus.form-field/literal-oneform-field",273665418,null);
RPb=new $APP.q("emmy.env","typed-\x3eindexed","emmy.env/typed-\x3eindexed",2013024880,null);SPb=new $APP.q(null,"manifold-type","manifold-type",-2024681051,null);TPb=new $APP.q("emmy.quaternion","arity","emmy.quaternion/arity",-973930344,null);UPb=new $APP.q("emmy.value","integral?","emmy.value/integral?",-366463480,null);VPb=new $APP.q(null,"J-tensor","J-tensor",129006775,null);jZa=new $APP.q(null,"positive?","positive?",1455224686,null);
WPb=new $APP.q("emmy.pattern.rule","iterated-top-down","emmy.pattern.rule/iterated-top-down",213838048,null);FJ=new $APP.q(null,"sqrt","sqrt",370479598,null);XPb=new $APP.q("emmy.numsymb","expt?","emmy.numsymb/expt?",-792689429,null);iW=new $APP.q(null,"best-of","best-of",2077533321,null);YPb=new $APP.q(null,"path-\x3estate-path","path-\x3estate-path",769505451,null);ZPb=new $APP.q("emmy.env","frame-owner","emmy.env/frame-owner",777518162,null);
$Pb=new $APP.q(null,"meta48981","meta48981",1675963418,null);aQb=new $APP.q("emmy.rational-function","-\x3et_emmy$rational_function48980","emmy.rational-function/-\x3et_emmy$rational_function48980",-1244158621,null);bQb=new $APP.q(null,"bs-merge","bs-merge",1465164655,null);cQb=new $APP.q(null,"L-coupled-harmonic","L-coupled-harmonic",-1590553116,null);dQb=new $APP.q(null,"frame-owner","frame-owner",1672840447,null);eQb=new $APP.q(null,"T3-spherical","T3-spherical",692408880,null);
fQb=new $APP.E(null,"protocol-invalid-method","protocol-invalid-method",522647516);gQb=new $APP.q("emmy.pattern.rule","pipe*","emmy.pattern.rule/pipe*",1424593420,null);hQb=new $APP.E(null,"sci","sci",-1317785218);jW=new $APP.q("cljs.core","ILookup","cljs.core/ILookup",-150575073,null);iQb=new $APP.q("emmy.simplify.rules","*trig-product-to-sum-simplify?*","emmy.simplify.rules/*trig-product-to-sum-simplify?*",-1967083481,null);jQb=new $APP.q(null,"generate","generate",1477078705,null);
kQb=new $APP.q(null,"partial-derivatives","partial-derivatives",1773356385,null);lQb=new $APP.q("emmy.mechanics.hamilton","H-state-\x3eL-state","emmy.mechanics.hamilton/H-state-\x3eL-state",-1276312507,null);mQb=new $APP.E("emmy.collection","set","emmy.collection/set",957963842);nQb=new $APP.q("emmy.polynomial.gcd","*poly-gcd-debug*","emmy.polynomial.gcd/*poly-gcd-debug*",246756429,null);
oQb=new $APP.q("emmy.mechanics.rigid","Euler-state-\x3eL-body","emmy.mechanics.rigid/Euler-state-\x3eL-body",278635227,null);pQb=new $APP.q("emmy.calculus.basis","Jacobian","emmy.calculus.basis/Jacobian",1840129489,null);qQb=new $APP.q(null,"Gamma","Gamma",681602978,null);rQb=new $APP.q("matrix","num-cols","matrix/num-cols",-354109770,null);SMb=new $APP.q("emmy.calculus.manifold","c:generate","emmy.calculus.manifold/c:generate",-2027726687,null);
tQb=new $APP.q(null,"coordinate-system-\x3emetric-components","coordinate-system-\x3emetric-components",1424635351,null);uQb=new $APP.q("emmy.simplify.rules","sqrt-contract","emmy.simplify.rules/sqrt-contract",-104035596,null);vQb=new $APP.q("emmy.mechanics.rigid","quaternion-state-\x3eomega-body","emmy.mechanics.rigid/quaternion-state-\x3eomega-body",-992738393,null);wQb=new $APP.q(null,"exp2","exp2",603509626,null);
xQb=new $APP.q("emmy.calculus.vector-field","components-\x3evector-field","emmy.calculus.vector-field/components-\x3evector-field",-80800745,null);kW=new $APP.q(null,"mode","mode",-2000032078,null);yQb=new $APP.q("emmy.generic","magnitude","emmy.generic/magnitude",682992694,null);zQb=new $APP.q(null,"sqrt-contract","sqrt-contract",958414240,null);AQb=new $APP.q(null,"rationalize","rationalize",290767001,null);BQb=new $APP.q(null,"*log-exp-simplify?*","*log-exp-simplify?*",587076366,null);
CQb=new $APP.q(null,"parse-int","parse-int",-742710469,null);DQb=new $APP.q("emmy.calculus.map","basis-\x3ebasis-over-map","emmy.calculus.map/basis-\x3ebasis-over-map",-137853229,null);lNb=new $APP.q("emmy.calculus.manifold","check-coordinates","emmy.calculus.manifold/check-coordinates",-1371793201,null);FQb=new $APP.q("emmy.polynomial.factor","split-polynomial","emmy.polynomial.factor/split-polynomial",-1396317750,null);GQb=new $APP.q(null,"return","return",-250970578,null);
mPa=new $APP.q(null,"Window","Window",-138860255,null);lW=new $APP.q(null,"permuted-list","permuted-list",-1279209469,null);z7a=new $APP.E(null,"gamma","gamma",1883969687);mW=new $APP.q("emmy.calculus.manifold","ICoordinateSystem","emmy.calculus.manifold/ICoordinateSystem",1561476964,null);HQb=new $APP.q(null,"expt?","expt?",370959426,null);IQb=new $APP.E(null,"inferred-ret-tag","inferred-ret-tag",798934347);KD=new $APP.E(null,"statements","statements",600349855);
JQb=new $APP.q(null,"*aggressive-atan-simplify?*","*aggressive-atan-simplify?*",1507641140,null);KQb=new $APP.q("emmy.env","drop1","emmy.env/drop1",-83315327,null);LQb=new $APP.q(null,"call","call",1120531661,null);MQb=new $APP.q(null,"Curl","Curl",797096696,null);hN=new $APP.E("emmy.dual","dual","emmy.dual/dual",-433931216);tOa=new $APP.E(null,"seen","seen",-518999789);NQb=new $APP.q("emmy.env","using-coordinates","emmy.env/using-coordinates",1801984337,null);
$APP.nW=new $APP.q(null,"coords","coords",1041102415,null);OQb=new $APP.q("Math","acos","Math/acos",357181099,null);PQb=new $APP.q(null,"metric-\x3eChristoffel-2","metric-\x3eChristoffel-2",-1477146051,null);QQb=new $APP.E(null,"protocol-multiple-impls","protocol-multiple-impls",794179260);RQb=new $APP.q(null,"emmy.expression.compile","emmy.expression.compile",553210407,null);SQb=new $APP.q(null,"metric-\x3eChristoffel-1","metric-\x3eChristoffel-1",1888246415,null);
TQb=new $APP.q("emmy.rational-function","negate","emmy.rational-function/negate",3708381,null);UQb=new $APP.q("emmy.polynomial","multivariate?","emmy.polynomial/multivariate?",267086580,null);VQb=new $APP.q(null,"emmy.calculus.vector-calculus","emmy.calculus.vector-calculus",-96871050,null);WQb=new $APP.q(null,"outer-product","outer-product",491531252,null);
XQb=new $APP.q("emmy.mechanics.routhian","Routhian-state-\x3eLagrangian-state","emmy.mechanics.routhian/Routhian-state-\x3eLagrangian-state",-1983362902,null);YQb=new $APP.q(null,"from-rotation-matrix","from-rotation-matrix",-1184842963,null);j8a=new $APP.E(null,"state-model","state-model",371967018);AK=new $APP.q(null,"magnitude","magnitude",-730161547,null);ZQb=new $APP.q("emmy.util","without-symbol-namespaces","emmy.util/without-symbol-namespaces",603109555,null);
VTa=new $APP.q("emmy.util.def","fork","emmy.util.def/fork",1565339133,null);$Qb=new $APP.E(null,"secs","secs",1532330091);aRb=new $APP.q("emmy.algebra.fold","kahan-babushka-neumaier","emmy.algebra.fold/kahan-babushka-neumaier",1973146121,null);bRb=new $APP.q("emmy.quaternion","make","emmy.quaternion/make",624604930,null);$APP.KK=new $APP.q(null,"compose","compose",1144740903,null);CVa=new $APP.E(null,"instant","instant",655498374);DJ=new $APP.q(null,"expt","expt",2123850345,null);
zJ=new $APP.q(null,"exp","exp",1378825265,null);cRb=new $APP.q("emmy.generic","fractional-part","emmy.generic/fractional-part",-1114623815,null);dRb=new $APP.q("emmy.calculus.indexed","with-argument-types","emmy.calculus.indexed/with-argument-types",2022391465,null);eRb=new $APP.q("emmy.util","nan?","emmy.util/nan?",-368462937,null);fRb=new $APP.q(null,"bulirsch-stoer-fold","bulirsch-stoer-fold",59460024,null);EE=new $APP.E(null,"then","then",460598070);
gRb=new $APP.q("emmy.pattern.match","segment","emmy.pattern.match/segment",-313761778,null);hRb=new $APP.q(null,"expn","expn",381067956,null);iRb=new $APP.q("emmy.env","drop2","emmy.env/drop2",307571047,null);jRb=new $APP.q(null,"match-when","match-when",516405072,null);kRb=new $APP.q("emmy.env","rotate-x-tuple","emmy.env/rotate-x-tuple",-713804553,null);lRb=new $APP.q(null,"D-reverse","D-reverse",2091570853,null);mRb=new $APP.q(null,"rotate-x-tuple","rotate-x-tuple",-1878274782,null);
qZa=new $APP.q(null,"asin-cos","asin-cos",-28391344,null);nRb=new $APP.q("emmy.calculus.manifold","coordinate-system-names","emmy.calculus.manifold/coordinate-system-names",1643324840,null);oRb=new $APP.q("v","integral?","v/integral?",-2027571413,null);pRb=new $APP.q("emmy.env","with-argument-types","emmy.env/with-argument-types",-1461885187,null);qRb=new $APP.q("emmy.env","differential","emmy.env/differential",-1839604067,null);rRb=new $APP.q("emmy.env","R3-rect","emmy.env/R3-rect",595094224,null);
sRb=new $APP.q("emmy.value","make-es6-callable","emmy.value/make-es6-callable",-509054717,null);tRb=new $APP.q("emmy.series","revert","emmy.series/revert",1823595145,null);lPb=new $APP.q(null,"attach-patch","attach-patch",1619352669,null);zQa=new $APP.E(null,"fn-self-name","fn-self-name",1461143531);vRb=new $APP.q("emmy.expression.compile","valid-modes","emmy.expression.compile/valid-modes",112938506,null);nE=new $APP.q(null,"clj-nil","clj-nil",1321798654,null);ERa=new $APP.E(null,"segs","segs",-1940299576);
wRb=new $APP.q(null,"variables","variables",-1090754955,null);xRb=new $APP.q(null,"has-next","has-next",-1971250537,null);$APP.yRb=new $APP.q("cljs.core","mapv","cljs.core/mapv",433728488,null);zRb=new $APP.q(null,"nan?","nan?",-76931893,null);ARb=new $APP.q(null,"bracket-max-scmutils","bracket-max-scmutils",1979643050,null);BRb=new $APP.q(null,"goog.string","goog.string",-2055533048,null);CRb=new $APP.q("emmy.env","evolve","emmy.env/evolve",-1140657274,null);
DRb=new $APP.q(null,"emmy.calculus.indexed","emmy.calculus.indexed",-759277111,null);ERb=new $APP.q(null,"structure-constant","structure-constant",-1401802547,null);oW=new $APP.q(null,"coordinate-system","coordinate-system",342184256,null);FRb=new $APP.q(null,"IRational","IRational",1043551137,null);GRb=new $APP.q(null,"Riemann","Riemann",809872061,null);HRb=new $APP.q(null,"factor-expression","factor-expression",-2061580046,null);IRb=new $APP.E(null,"the-var","the-var",1428415613);
JRb=new $APP.q(null,"event?","event?",-2038386683,null);KRb=new $APP.q(null,"with-index-types","with-index-types",-2000554538,null);LRb=new $APP.q(null,"time-expired?","time-expired?",1826704121,null);MRb=new $APP.q(null,"M-\x3eomega","M-\x3eomega",-1205879070,null);u4a=new $APP.q(null,"-indexOf","-indexOf",-442719214,null);pW=new $APP.q("v","native-integral?","v/native-integral?",1972110486,null);NRb=new $APP.q("emmy.env","series","emmy.env/series",-1019970502,null);
ORb=new $APP.q("emmy.dual","REVERSE-MODE","emmy.dual/REVERSE-MODE",1927323520,null);PRb=new $APP.q("emmy.value","scalar?","emmy.value/scalar?",1318943466,null);QRb=new $APP.q("emmy.calculus.map","literal-manifold-map","emmy.calculus.map/literal-manifold-map",-773736888,null);RRb=new $APP.q("emmy.matrix","s:divide-by-structure","emmy.matrix/s:divide-by-structure",595723922,null);SRb=new $APP.q("emmy.series","sum","emmy.series/sum",-1370679882,null);
qW=new $APP.q(null,"valid-orientation?","valid-orientation?",1508041189,null);TRb=new $APP.q("emmy.calculus.derivative","partial-forward","emmy.calculus.derivative/partial-forward",-973257536,null);URb=new $APP.q(null,"pitch","pitch",-1159309069,null);VRb=new $APP.q(null,"map-\x3eFailure","map-\x3eFailure",-77899845,null);WRb=new $APP.E(null,"nodejs","nodejs",321212524);rW=new $APP.q(null,"dual-basis","dual-basis",-73332233,null);
XRb=new $APP.q("emmy.mechanics.rotation","Euler-\x3eM","emmy.mechanics.rotation/Euler-\x3eM",1665737322,null);YRb=new $APP.q(null,"g-on-M","g-on-M",168796354,null);R9a=new $APP.q(null,"flow-derivative","flow-derivative",-2031576450,null);rQa=new $APP.E(null,"arg","arg",-1747261837);sW=new $APP.q(null,"Cartan-on-target","Cartan-on-target",1638424227,null);ZRb=new $APP.q("emmy.rational-function","invert","emmy.rational-function/invert",-1434786149,null);
$Rb=new $APP.q("emmy.mechanics.hamilton","Poisson-bracket","emmy.mechanics.hamilton/Poisson-bracket",842528623,null);aSb=new $APP.q("emmy.pattern.rule","rule-simplifier","emmy.pattern.rule/rule-simplifier",261720809,null);bSb=new $APP.q(null,"x-degree","x-degree",1170692253,null);cSb=new $APP.q(null,"same-orientation?","same-orientation?",-1650887357,null);dSb=new $APP.q(null,"emmy.mechanics.rigid","emmy.mechanics.rigid",-48431844,null);
eSb=new $APP.q("emmy.calculus.form-field","oneform-field-\x3ebasis-components","emmy.calculus.form-field/oneform-field-\x3ebasis-components",-326137970,null);fSb=new $APP.q("emmy.env","SO3","emmy.env/SO3",-494454810,null);gSb=new $APP.q(null,"is","is",2009660525,null);tW=new $APP.q(null,"coth","coth",1130257730,null);hSb=new $APP.q(null,"without-symbol-namespaces","without-symbol-namespaces",814869975,null);iSb=new $APP.q(null,"covariant-derivative","covariant-derivative",95007126,null);
jSb=new $APP.q("emmy.series","acos-series","emmy.series/acos-series",-58407659,null);kSb=new $APP.q(null,"D-numeric","D-numeric",509796205,null);lSb=new $APP.q(null,"determinant","determinant",-580156910,null);mSb=new $APP.q("emmy.env","literal-down","emmy.env/literal-down",-138816442,null);nSb=new $APP.q("emmy.env","transfer-point","emmy.env/transfer-point",-489683007,null);oSb=new $APP.q("emmy.env","proper-space-interval","emmy.env/proper-space-interval",-891878801,null);
pSb=new $APP.q("emmy.env","components-\x3eoneform-field","emmy.env/components-\x3eoneform-field",-65060581,null);uH=new $APP.q(null,"cosh","cosh",-1962788142,null);qSb=new $APP.q(null,"simplify-square-roots","simplify-square-roots",320711438,null);rSb=new $APP.q(null,"emmy.special.factorial","emmy.special.factorial",-488164136,null);uW=new $APP.q(null,"m0","m0",142676688,null);vW=new $APP.q(null,"m1","m1",1532436901,null);sSb=new $APP.q(null,"m2","m2",1053528221,null);
tSb=new $APP.q("emmy.generic","negative?","emmy.generic/negative?",1788861263,null);uSb=new $APP.q(null,"number-of-permutations","number-of-permutations",401663020,null);wW=new $APP.q(null,"ks","ks",-754231827,null);xW=new $APP.q(null,"fractional-part","fractional-part",-505422086,null);vSb=new $APP.q("emmy.algebra.fold","max","emmy.algebra.fold/max",-1590307144,null);wSb=new $APP.q("emmy.env","cot","emmy.env/cot",1529068977,null);xSb=new $APP.q("emmy.env","cos","emmy.env/cos",-422859036,null);
ySb=new $APP.q("emmy.env","Alt","emmy.env/Alt",2089654732,null);zSb=new $APP.q("emmy.calculus.frame","frame-maker","emmy.calculus.frame/frame-maker",373551543,null);ASb=new $APP.q("emmy.calculus.manifold","S2p","emmy.calculus.manifold/S2p",-898919664,null);yW=new $APP.q(null,"ls","ls",-1458647179,null);BSb=new $APP.q("emmy.env","negate","emmy.env/negate",-1446561801,null);CSb=new $APP.q(null,"pairwise-sum","pairwise-sum",1070838009,null);
DSb=new $APP.q("emmy.calculus.indexed","typed-\x3eindexed","emmy.calculus.indexed/typed-\x3eindexed",1203218980,null);ESb=new $APP.q("emmy.mechanics.lagrange","L-sliding-pend","emmy.mechanics.lagrange/L-sliding-pend",1500414486,null);zW=new $APP.q(null,"ms","ms",487821794,null);FSb=new $APP.q("cljs.core","boolean?","cljs.core/boolean?",1400713761,null);GSb=new $APP.q("emmy.matrix","without","emmy.matrix/without",1858472872,null);
HSb=new $APP.q("emmy.simplify.rules","cos-sq-\x3esin-sq","emmy.simplify.rules/cos-sq-\x3esin-sq",-71509844,null);ISb=new $APP.q(null,"emmy.numerical.minimize","emmy.numerical.minimize",-1131862948,null);JSb=new $APP.q("emmy.polynomial","expt","emmy.polynomial/expt",-837641413,null);KSb=new $APP.q(null,"Hodge-star","Hodge-star",219488309,null);qPb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57547","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57547",-663621798,null);
MSb=new $APP.q("emmy.simplify.rules","*exponent-product-simplify?*","emmy.simplify.rules/*exponent-product-simplify?*",-180144893,null);NSb=new $APP.q("emmy.matrix","square?","emmy.matrix/square?",-146341292,null);OSb=new $APP.q(null,"M-of-q-\x3eomega-body-of-t","M-of-q-\x3eomega-body-of-t",1800029441,null);PSb=new $APP.q(null,"not-integral?","not-integral?",1746552960,null);QSb=new $APP.q("emmy.dual","*active-tags*","emmy.dual/*active-tags*",-2102560287,null);
RSb=new $APP.q(null,"get-integrator","get-integrator",-285958527,null);AW=new $APP.q(null,"q0","q0",1970367567,null);BW=new $APP.q(null,"q1","q1",1804441001,null);CW=new $APP.q(null,"q2","q2",282479025,null);DW=new $APP.q(null,"op","op",-242456428,null);SSb=new $APP.q("emmy.env","constant-manifold-function","emmy.env/constant-manifold-function",624278880,null);TSb=new $APP.q("emmy.mechanics.hamilton","Hamiltonian-\x3eLagrangian","emmy.mechanics.hamilton/Hamiltonian-\x3eLagrangian",-500988453,null);
j3a=new $APP.E("emmy.calculus.manifold","manifold-family","emmy.calculus.manifold/manifold-family",-1074374215);USb=new $APP.q(null,"pe","pe",-876735477,null);sE=new $APP.E(null,"js-var","js-var",-1177899142);VSb=new $APP.q(null,"splice-reduce","splice-reduce",-2065693385,null);WSb=new $APP.q("emmy.calculus.metric","embedding-map-\x3emetric-components","emmy.calculus.metric/embedding-map-\x3emetric-components",-828910261,null);
XSb=new $APP.q("emmy.pattern.rule","fixed-point","emmy.pattern.rule/fixed-point",-1602956137,null);YSb=new $APP.q(null,"acos-series","acos-series",-1542810012,null);ZSb=new $APP.E(null,"variadic-max-arity","variadic-max-arity",-14288402);nH=new $APP.q(null,"pi","pi",176774184,null);$Sb=new $APP.q(null,"r1","r1",-1963460869,null);aTb=new $APP.q(null,"r2","r2",1893375701,null);bTb=new $APP.q("emmy.env","csc","emmy.env/csc",550666523,null);
cTb=new $APP.q("emmy.calculus.frame","coords-\x3eevent","emmy.calculus.frame/coords-\x3eevent",-399635368,null);dTb=new $APP.q("emmy.operator","procedure","emmy.operator/procedure",556856273,null);HOa=new $APP.E("cljs","analysis-error","cljs/analysis-error",-420526349);eTb=new $APP.q("emmy.env","vector-\x3edown","emmy.env/vector-\x3edown",1847298409,null);sQb=new $APP.q(null,"get-patch","get-patch",-636344,null);EW=new $APP.E("emmy.operator","operator","emmy.operator/operator",1412891316);
gTb=new $APP.E(null,"unprovided","unprovided",-652330764);hTb=new $APP.q("emmy.env","factorial","emmy.env/factorial",1249115292,null);iTb=new $APP.q(null,"contract","contract",-1856283024,null);jTb=new $APP.q("emmy.pattern.match","all-results-matcher","emmy.pattern.match/all-results-matcher",-1110526029,null);kE=new $APP.E(null,"excludes","excludes",-1791725945);FW=new $APP.q(null,"tangent","tangent",-1933519948,null);kTb=new $APP.q(null,"qs","qs",-260156164,null);
MVa=new $APP.E(null,"hash","hash",-13781596);lTb=new $APP.q("emmy.sr.boost","general-boost","emmy.sr.boost/general-boost",2127263857,null);mTb=new $APP.q(null,"state-\x3eqp","state-\x3eqp",185160363,null);nTb=new $APP.q(null,"make-operator","make-operator",329621074,null);GW=new $APP.q(null,"re","re",1869207729,null);RYa=new $APP.q(null,"??fs1*","??fs1*",1798735663,null);oTb=new $APP.q(null,"*validate-Legendre-transform?*","*validate-Legendre-transform?*",-2006767239,null);
pTb=new $APP.q("emmy.calculus.metric","vector-field-\x3eoneform-field","emmy.calculus.metric/vector-field-\x3eoneform-field",191536335,null);qTb=new $APP.q(null,"divide-numbers-through","divide-numbers-through",1612965991,null);rTb=new $APP.q("emmy.env","seq:print","emmy.env/seq:print",2045210942,null);GG=new $APP.E(null,"clj","clj",-660495428);HW=new $APP.q(null,"t0","t0",-534273234,null);IW=new $APP.q(null,"t1","t1",1665503971,null);JW=new $APP.q(null,"t2","t2",891676305,null);
sTb=new $APP.q(null,"rv","rv",-860258924,null);tTb=new $APP.q(null,"q-div-scalar","q-div-scalar",-1899125481,null);uTb=new $APP.q(null,"curvature-components","curvature-components",-1275395345,null);vTb=new $APP.q("emmy.polynomial","extend","emmy.polynomial/extend",-1095019845,null);KW=new $APP.q(null,"rs","rs",-1740853800,null);wTb=new $APP.q(null,"t?","t?",-2042555639,null);g7a=new $APP.E(null,"infix?","infix?",41062120);xTb=new $APP.q(null,"potential-energy","potential-energy",-990216810,null);
yTb=new $APP.q(null,"Lagrange-equations-first-order","Lagrange-equations-first-order",975370522,null);zTb=new $APP.q("emmy.mechanics.hamilton","state-\x3eqp","emmy.mechanics.hamilton/state-\x3eqp",-1006186532,null);ATb=new $APP.q("emmy.polynomial","divide","emmy.polynomial/divide",687310746,null);$Ra=new $APP.E(null,"macro-syntax-check","macro-syntax-check",2072602373);fQ=new $APP.q(null,"u-","u-",1997472866,null);BTb=new $APP.E(null,"simpson","simpson",-1546685398);
CTb=new $APP.q(null,"compiler-mode","compiler-mode",-1594269719,null);DTb=new $APP.q(null,"coordinate-origin","coordinate-origin",-1339747644,null);ETb=new $APP.q("emmy.env","vector-\x3eup","emmy.env/vector-\x3eup",719487598,null);FTb=new $APP.q(null,"stirling-first-kind","stirling-first-kind",329338979,null);GTb=new $APP.q("emmy.env","multidimensional-minimize","emmy.env/multidimensional-minimize",-1541103218,null);
HTb=new $APP.q("emmy.mechanics.hamilton","make-Hamiltonian","emmy.mechanics.hamilton/make-Hamiltonian",268374131,null);ITb=new $APP.q(null,"the-ether","the-ether",-259961165,null);JTb=new $APP.q(null,"literal?","literal?",1993017398,null);KTb=new $APP.q(null,"-\x3eCompleted","-\x3eCompleted",-1940126805,null);$APP.LW=new $APP.q(null,"v1","v1",-2141311508,null);LTb=new $APP.q(null,"to","to",1832630534,null);$APP.MW=new $APP.q(null,"v2","v2",1875554983,null);
MTb=new $APP.q("emmy.calculus.vector-field","coordinatize","emmy.calculus.vector-field/coordinatize",-927084903,null);UOa=new $APP.E(null,"goog","goog",-1711135452);NTb=new $APP.q(null,"coeff?","coeff?",-398863446,null);fI=new $APP.E(null,"exactly","exactly",1304099233);OTb=new $APP.q("emmy.operator","exp","emmy.operator/exp",-1395745485,null);PTb=new $APP.q("emmy.env","S2p-stereographic","emmy.env/S2p-stereographic",67978312,null);xP=new $APP.q(null,"up","up",1370819414,null);
cN=new $APP.E(null,"dfdx","dfdx",-1523879512);dN=new $APP.E(null,"dfdy","dfdy",-434788201);W7a=new $APP.E(null,"grow-limit","grow-limit",2130208943);QTb=new $APP.q("emmy.simplify.rules","negative-number?","emmy.simplify.rules/negative-number?",-1495251167,null);RTb=new $APP.q("emmy.env","make-polar","emmy.env/make-polar",-1184935190,null);STb=new $APP.q("emmy.env","exterior-derivative","emmy.env/exterior-derivative",-568827535,null);
TTb=new $APP.q("emmy.matrix","make-zero","emmy.matrix/make-zero",115811654,null);$APP.NW=new $APP.q(null,"x0","x0",2051374914,null);$APP.OW=new $APP.q(null,"x1","x1",-223390720,null);UTb=new $APP.q(null,"commutative","commutative",-77507576,null);VTb=new $APP.q(null,"polynomial?","polynomial?",-1721156532,null);WTb=new $APP.q(null,"numerator","numerator",1479770423,null);XTb=new $APP.q("emmy.rational-function","expt","emmy.rational-function/expt",1788741868,null);
YTb=new $APP.q(null,"seq-print","seq-print",-2118969658,null);ZTb=new $APP.q(null,"y0","y0",1751986334,null);PYa=new $APP.q(null,"exponent-product","exponent-product",134982023,null);$Tb=new $APP.q("emmy.util.stream","zeno","emmy.util.stream/zeno",-1055068504,null);aUb=new $APP.q(null,"xc","xc",-1246828562,null);bUb=new $APP.q("emmy.calculus.form-field","components-\x3eoneform-field","emmy.calculus.form-field/components-\x3eoneform-field",-1388426189,null);
cUb=new $APP.q("emmy.rational-function","gcd","emmy.rational-function/gcd",251347748,null);dUb=new $APP.q("emmy.calculus.manifold","coordinate-system?","emmy.calculus.manifold/coordinate-system?",-1926114138,null);eUb=new $APP.q("emmy.dual","replace-tag","emmy.dual/replace-tag",1781391258,null);PW=new $APP.q(null,"xa","xa",1388612750,null);fUb=new $APP.q("emmy.env","metric-over-map","emmy.env/metric-over-map",1210605861,null);QW=new $APP.q(null,"xb","xb",-765832,null);
gUb=new $APP.q("emmy.env","Christoffel?","emmy.env/Christoffel?",2099919873,null);hUb=new $APP.q(null,"z1","z1",-635827689,null);iUb=new $APP.q(null,"z2","z2",-752480244,null);jUb=new $APP.q("emmy.generic","gcd","emmy.generic/gcd",1292829540,null);kUb=new $APP.q(null,"emmy.calculus.map","emmy.calculus.map",1333546993,null);lUb=new $APP.q("emmy.env","basis-\x3ecoordinate-system","emmy.env/basis-\x3ecoordinate-system",1421810382,null);
RW=new $APP.q("cljs.core","IAssociative","cljs.core/IAssociative",-1700920611,null);mUb=new $APP.E(null,"adaptive-neighborhood-width","adaptive-neighborhood-width",791007094);nUb=new $APP.q(null,"frame-sym","frame-sym",1690428135,null);oUb=new $APP.q(null,"modint","modint",-1355832379,null);pUb=new $APP.q("emmy.polynomial","expression-\x3e","emmy.polynomial/expression-\x3e",-1176034683,null);qUb=new $APP.q(null,"ys","ys",1606115702,null);rUb=new $APP.q(null,"Phi*","Phi*",-2105657447,null);
sUb=new $APP.q("emmy.calculus.coordinate","define-coordinates","emmy.calculus.coordinate/define-coordinates",1830166904,null);eYa=new $APP.q(null,"r__45996__auto__","r__45996__auto__",1523135004,null);tUb=new $APP.q(null,"L-axisymmetric-top","L-axisymmetric-top",-966661177,null);uUb=new $APP.q("emmy.env","Christoffel-\x3esymbols","emmy.env/Christoffel-\x3esymbols",-1246502376,null);SW=new $APP.q("cljs.core","IFn","cljs.core/IFn",-920223129,null);
vUb=new $APP.q(null,"Routh-equations","Routh-equations",-1119256779,null);wUb=new $APP.q("cljs.core","list?","cljs.core/list?",-684796618,null);xUb=new $APP.q("emmy.polynomial.factor","factor","emmy.polynomial.factor/factor",-295805940,null);yUb=new $APP.q("emmy.quaternion","from-complex-matrix","emmy.quaternion/from-complex-matrix",1008303928,null);zUb=new $APP.q("emmy.env","-\x3einfix","emmy.env/-\x3einfix",1376852277,null);
AUb=new $APP.q(null,"coordinate-basis-oneform-field","coordinate-basis-oneform-field",-68149918,null);HWa=new $APP.E(null,"zero-like","zero-like",1759410522);BUb=new $APP.q("emmy.structure","generate","emmy.structure/generate",-1690511640,null);CUb=new $APP.q("emmy.util.permute","sort-and-permute","emmy.util.permute/sort-and-permute",-405653616,null);DUb=new $APP.q("cljs.core","list*","cljs.core/list*",357627358,null);
EUb=new $APP.q(null,"antisymmetric-\x3ecolumn-matrix","antisymmetric-\x3ecolumn-matrix",-1061685310,null);FUb=new $APP.q(null,"ratio?","ratio?",-498643049,null);UQa=new $APP.E(null,"include-macros","include-macros",1228110289);GUb=new $APP.q("emmy.mechanics.hamilton","symplectic-transform?","emmy.mechanics.hamilton/symplectic-transform?",312254588,null);HUb=new $APP.q("emmy.expression.analyze","*inhibit-expt-simplify*","emmy.expression.analyze/*inhibit-expt-simplify*",1358114281,null);
IUb=new $APP.q("emmy.env","expression-\x3estring","emmy.env/expression-\x3estring",94331728,null);JUb=new $APP.E(null,"analyze-expression","analyze-expression",870894091);KUb=new $APP.q("emmy.env","lower","emmy.env/lower",-416117813,null);LUb=new $APP.q(null,"Riemann-curvature","Riemann-curvature",-1648319560,null);MUb=new $APP.q("emmy.env","basis-components-\x3eoneform-field","emmy.env/basis-components-\x3eoneform-field",-332083849,null);
NUb=new $APP.q(null,"parabolic-step","parabolic-step",720135352,null);OUb=new $APP.q("emmy.env","tan","emmy.env/tan",-531624639,null);PUb=new $APP.q("Math","pow","Math/pow",193807960,null);QUb=new $APP.q("emmy.numerical.unimin.bracket","parabolic-step","emmy.numerical.unimin.bracket/parabolic-step",-610651676,null);qQa=new $APP.E(null,"binding","binding",539932593);EQb=new $APP.q("emmy.calculus.manifold","point-\x3emanifold","emmy.calculus.manifold/point-\x3emanifold",2099914878,null);
SUb=new $APP.q("emmy.mechanics.hamilton","compatible-H-state?","emmy.mechanics.hamilton/compatible-H-state?",-587695837,null);TUb=new $APP.q(null,"M-of-q-\x3eomega-of-t","M-of-q-\x3eomega-of-t",-467896766,null);UUb=new $APP.q("emmy.env","literal-number","emmy.env/literal-number",184945361,null);VUb=new $APP.q("emmy.numerical.multimin.nelder-mead","nelder-mead","emmy.numerical.multimin.nelder-mead/nelder-mead",-1878246548,null);YL=new $APP.E("emmy.polynomial","coeff","emmy.polynomial/coeff",972797864);
WUb=new $APP.q("emmy.generic","freeze","emmy.generic/freeze",131755723,null);XUb=new $APP.q(null,"literal-row-matrix","literal-row-matrix",-1031962807,null);$APP.TW=new $APP.E(null,"label","label",1718410804);YUb=new $APP.q("emmy.calculus.derivative","taylor-series","emmy.calculus.derivative/taylor-series",-1000016831,null);ZUb=new $APP.q(null,"s:inverse","s:inverse",-1336873639,null);$Ub=new $APP.q("cljs.core","inst?","cljs.core/inst?",1216133710,null);
aVb=new $APP.q(null,"hicol","hicol",413945288,null);bVb=new $APP.q(null,"proper-space-interval","proper-space-interval",-2056140240,null);cVb=new $APP.q(null,"Noether-integral","Noether-integral",-1527698590,null);dVb=new $APP.q(null,"emmy.calculus.derivative","emmy.calculus.derivative",-955806891,null);eVb=new $APP.q(null,"S2-spherical","S2-spherical",173450952,null);fVb=new $APP.E(null,"years","years",-1298579689);gVb=new $APP.q(null,"IFrame","IFrame",1542387647,null);
hVb=new $APP.q("emmy.env","tau","emmy.env/tau",-1598211860,null);iVb=new $APP.q(null,"-\x3eFailure","-\x3eFailure",1824260484,null);jVb=new $APP.q("emmy.polynomial","valid-arity?","emmy.polynomial/valid-arity?",-596836818,null);uRb=new $APP.E(null,"coords-\x3epoint","coords-\x3epoint",1186490070);lVb=new $APP.q("emmy.polynomial","-\x3ePolynomial","emmy.polynomial/-\x3ePolynomial",1862159190,null);mVb=new $APP.q("emmy.structure","expt","emmy.structure/expt",-1074222400,null);
UW=new $APP.q(null,"calling-convention","calling-convention",491725371,null);nVb=new $APP.q("emmy.pattern.match","frame-predicate","emmy.pattern.match/frame-predicate",1617798150,null);oVb=new $APP.q("emmy.util.aggregate","generic-sum","emmy.util.aggregate/generic-sum",-160417773,null);pVb=new $APP.q("emmy.quaternion","scale","emmy.quaternion/scale",-2079416714,null);qVb=new $APP.q(null,"with-argument-types","with-argument-types",1782525454,null);
rVb=new $APP.q("emmy.numerical.unimin.golden","stop-fn","emmy.numerical.unimin.golden/stop-fn",-889753428,null);sVb=new $APP.q("emmy.sr.frames","SR-coordinates?","emmy.sr.frames/SR-coordinates?",1071867371,null);jPa=new $APP.E(null,"ctor","ctor",1750864802);tVb=new $APP.q(null,"K-tensor","K-tensor",-2023182764,null);$Va=new $APP.E(null,"appenders","appenders",1245583998);uVb=new $APP.q("emmy.mechanics.hamilton","standard-map","emmy.mechanics.hamilton/standard-map",36927812,null);
LSb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57516","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57516",-648534954,null);cZa=new $APP.q(null,"c1","c1",-1521904966,null);wVb=new $APP.q("emmy.polynomial","-\x3estr","emmy.polynomial/-\x3estr",-1253774430,null);xVb=new $APP.q("emmy.matrix","matrix?","emmy.matrix/matrix?",-1906544740,null);dZa=new $APP.q(null,"c2","c2",78651156,null);eZa=new $APP.q(null,"c3","c3",468715789,null);
fZa=new $APP.q(null,"c4","c4",-1626390159,null);gZa=new $APP.q(null,"c5","c5",1025457982,null);yVb=new $APP.q(null,"as","as",-1505746128,null);zVb=new $APP.q(null,"extend-pt","extend-pt",936827516,null);VW=new $APP.q(null,"Cartan?","Cartan?",1638685802,null);AVb=new $APP.q("emmy.env","sum","emmy.env/sum",-1424949064,null);BVb=new $APP.q(null,"R3-cyl","R3-cyl",-1317838879,null);
fTb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57506","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57506",2051866250,null);WW=new $APP.E(null,"south-pole","south-pole",-663994324);DVb=new $APP.q("emmy.env","compare","emmy.env/compare",-1886789744,null);XW=new $APP.E("emmy.matrix","row-matrix","emmy.matrix/row-matrix",1672054134);EVb=new $APP.q(null,"degree","degree",1877638555,null);FVb=new $APP.q("emmy.env","complex?","emmy.env/complex?",35925448,null);
GVb=new $APP.q("emmy.rational-function.interpolate","modified-bulirsch-stoer","emmy.rational-function.interpolate/modified-bulirsch-stoer",1530047077,null);HVb=new $APP.q("emmy.pattern.rule","until","emmy.pattern.rule/until",1268378413,null);YYa=new $APP.q(null,"e1","e1",-732861271,null);RUb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57539","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57539",753905089,null);ZYa=new $APP.q(null,"e2","e2",1288255343,null);
$Ya=new $APP.q(null,"e3","e3",980159791,null);JVb=new $APP.q("emmy.env","transpose","emmy.env/transpose",-2112189284,null);kVb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57534","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57534",641796624,null);LVb=new $APP.q(null,"Cartan-\x3eforms","Cartan-\x3eforms",1353403135,null);aZa=new $APP.q(null,"e4","e4",-714258248,null);sOa=new $APP.E("cljs.analyzer","constants","cljs.analyzer/constants",1697083770);
MVb=new $APP.q(null,"cs","cs",-117024463,null);YW=new $APP.q(null,"ct","ct",-517996828,null);NVb=new $APP.q("emmy.polynomial","evaluate","emmy.polynomial/evaluate",255708542,null);OVb=new $APP.q("emmy.polynomial.interpolate","lagrange","emmy.polynomial.interpolate/lagrange",1122070272,null);PVb=new $APP.E(null,"right-riemann","right-riemann",1357460560);QVb=new $APP.q("emmy.polynomial.interpolate","tableau-fold-fn","emmy.polynomial.interpolate/tableau-fold-fn",1663563242,null);
$APP.ZW=new $APP.q(null,"f'","f'",1671336495,null);RVb=new $APP.q("emmy.calculus.vector-field","vector-field-\x3ecomponents","emmy.calculus.vector-field/vector-field-\x3ecomponents",-703620554,null);SVb=new $APP.q("emmy.quaternion","magnitude","emmy.quaternion/magnitude",611614077,null);TVb=new $APP.q(null,"manifold-point-representation","manifold-point-representation",-630647746,null);
vVb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57524","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57524",-1042455601,null);VVb=new $APP.q(null,"the-real-line","the-real-line",319574384,null);$W=new $APP.q(null,"dx","dx",1258734795,null);WVb=new $APP.q(null,"String","String",-2070057435,null);$APP.aX=new $APP.q(null,"dt","dt",1272086768,null);XVb=new $APP.q("emmy.value","kind-predicate","emmy.value/kind-predicate",118964741,null);
YVb=new $APP.q(null,"emmy.pattern.match","emmy.pattern.match",-1379218803,null);ZVb=new $APP.q("emmy.env","literal-vector-field","emmy.env/literal-vector-field",647911606,null);bX=new $APP.q(null,"eq","eq",1021992460,null);$Vb=new $APP.q(null,"acceleration","acceleration",426643106,null);aWb=new $APP.q("emmy.structure","literal","emmy.structure/literal",132658007,null);bWb=new $APP.q(null,"-\x3eterms","-\x3eterms",104047239,null);nOa=new $APP.E(null,"loop-lets","loop-lets",2036794185);
cWb=new $APP.q(null,"fa","fa",2125512710,null);dWb=new $APP.q(null,"fb","fb",308862205,null);eWb=new $APP.q(null,"fc","fc",1492155206,null);fWb=new $APP.q("emmy.abstract.function","with-literal-functions","emmy.abstract.function/with-literal-functions",379735791,null);gWb=new $APP.q("emmy.pattern.rule","attempt?","emmy.pattern.rule/attempt?",-944675102,null);hWb=new $APP.q(null,"ff","ff",-1993208340,null);
iWb=new $APP.q("emmy.mechanics.lagrange","make-Lagrangian","emmy.mechanics.lagrange/make-Lagrangian",-408756363,null);sUa=new $APP.E("rl","all","rl/all",892118056);jWb=new $APP.q("emmy.matrix","num-rows","emmy.matrix/num-rows",956302826,null);kWb=new $APP.q(null,"miscsimp","miscsimp",2008821660,null);cX=new $APP.q(null,"fx","fx",402701955,null);lWb=new $APP.q("emmy.env","metric-\x3econnection-1","emmy.env/metric-\x3econnection-1",202899343,null);
mWb=new $APP.q("emmy.util","interrupted","emmy.util/interrupted",-369019014,null);nWb=new $APP.q("emmy.env","metric-\x3econnection-2","emmy.env/metric-\x3econnection-2",-582324945,null);oWb=new $APP.q(null,"S2p-tilted","S2p-tilted",-205552708,null);dX=new $APP.q(null,"cont","cont",1063431313,null);pWb=new $APP.q(null,"two-up?","two-up?",-1449212662,null);qWb=new $APP.q(null,"s:transpose","s:transpose",-671608823,null);rWb=new $APP.q(null,"??args","??args",-2100991912,null);
sWb=new $APP.q("emmy.matrix","as-matrix","emmy.matrix/as-matrix",-865116285,null);tWb=new $APP.q(null,"n-times","n-times",-1654271223,null);PE=new $APP.E(null,"fn-var","fn-var",1086204730);uWb=new $APP.q("emmy.structure","down-of-ups?","emmy.structure/down-of-ups?",1044675597,null);vWb=new $APP.q(null,"function-\x3e","function-\x3e",-1430532114,null);wWb=new $APP.q("emmy.simplify.rules","sincos-random","emmy.simplify.rules/sincos-random",505442210,null);
xWb=new $APP.q(null,"restriction","restriction",260296615,null);yWb=new $APP.q(null,"extended-rotation","extended-rotation",-1676844009,null);zWb=new $APP.q("emmy.calculus.manifold","with-coordinate-prototype","emmy.calculus.manifold/with-coordinate-prototype",-636709634,null);eX=new $APP.q(null,"im","im",506870084,null);AWb=new $APP.q(null,"make-es6-callable","make-es6-callable",-860688214,null);fX=new $APP.q(null,"cols","cols",-274269768,null);
BWb=new $APP.q(null,"falling-factorial","falling-factorial",1649395235,null);CWb=new $APP.q(null,"modint?","modint?",-46333612,null);DWb=new $APP.q("emmy.simplify.rules","trig:product-\x3esum","emmy.simplify.rules/trig:product-\x3esum",-1786356564,null);CVb=new $APP.q(null,"with-coordinate-prototype","with-coordinate-prototype",-1647439344,null);FWb=new $APP.q("emmy.calculus.map","pullback-function","emmy.calculus.map/pullback-function",1353904066,null);
GWb=new $APP.q("emmy.series","inflate","emmy.series/inflate",1711269509,null);HWb=new $APP.q("emmy.env","partial-reverse","emmy.env/partial-reverse",-5571198,null);IWb=new $APP.q(null,"thetadot","thetadot",1584260463,null);jF=new $APP.q("cljs.core","Symbol","cljs.core/Symbol",292989338,null);JWb=new $APP.q(null,"structure-\x3etyped","structure-\x3etyped",-1854577176,null);IVb=new $APP.q("emmy.calculus.manifold","point-\x3ecoords","emmy.calculus.manifold/point-\x3ecoords",2036243080,null);
KVb=new $APP.q("emmy.calculus.manifold","get-coordinates","emmy.calculus.manifold/get-coordinates",-1554273251,null);UVb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57486","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57486",-477537235,null);s3a=new $APP.E(null,"patch-name","patch-name",-1206801829);NWb=new $APP.q("emmy.env","pullback","emmy.env/pullback",1897998867,null);OWb=new $APP.E(null,"-\x3eexpression","-\x3eexpression",1358975351);
PWb=new $APP.q(null,"substitute","substitute",-1998578400,null);QWb=new $APP.q("emmy.env","coordinate-origin","emmy.env/coordinate-origin",2009553427,null);EWb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57475","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57475",292971108,null);SWb=new $APP.q(null,"flow-transform","flow-transform",1928355832,null);
KWb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57470","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57470",-962622048,null);UWb=new $APP.q("emmy.numsymb","*incremental-simplifier*","emmy.numsymb/*incremental-simplifier*",-888049217,null);oE=new $APP.q(null,"prototype","prototype",519166522,null);VWb=new $APP.q("emmy.mechanics.rigid","T-rigid-body","emmy.mechanics.rigid/T-rigid-body",-477732325,null);
WWb=new $APP.q("emmy.quaternion","yaw","emmy.quaternion/yaw",-960135622,null);XWb=new $APP.q("emmy.numerical.unimin.bracket","bracket-min","emmy.numerical.unimin.bracket/bracket-min",547264931,null);YWb=new $APP.q("emmy.calculus.basis","basis?","emmy.calculus.basis/basis?",142229276,null);ZWb=new $APP.q("emmy.env","argument-types","emmy.env/argument-types",-67750953,null);$Wb=new $APP.q(null,"Dt-procedure","Dt-procedure",-1264845613,null);
aXb=new $APP.q(null,"INumericTower","INumericTower",-60503966,null);LWb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57497","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57497",127549312,null);cXb=new $APP.q(null,"evenly-divide","evenly-divide",-2140597052,null);iUa=new $APP.E(null,"qualifier","qualifier",125841738);dXb=new $APP.q("emmy.pattern.match","matcher","emmy.pattern.match/matcher",197340969,null);eXb=new $APP.q(null,"log-contract","log-contract",-590272403,null);
fXb=new $APP.q(null,"emmy.calculus.connection","emmy.calculus.connection",-560921033,null);bP=new $APP.E("emmy.calculus.form-field","form-field","emmy.calculus.form-field/form-field",1983687851);gXb=new $APP.q(null,"validate-mode!","validate-mode!",-1971203371,null);hXb=new $APP.q("emmy.env","down","emmy.env/down",-34406874,null);iXb=new $APP.q("emmy.structure","-\x3eStructure","emmy.structure/-\x3eStructure",-43709489,null);jXb=new $APP.q(null,"C-\x3eCp","C-\x3eCp",-896239631,null);
kXb=new $APP.q(null,"manifold-family?","manifold-family?",-175083464,null);lXb=new $APP.q(null,"canonical-K?","canonical-K?",1986971077,null);gX=new $APP.q(null,"ncols","ncols",1256712774,null);c7a=new $APP.E(null,"term","term",-1817390416);nRa=new $APP.E(null,"dot-action","dot-action",-1460119601);mXb=new $APP.q("cljs.core","checked-aset","cljs.core/checked-aset",-2080232353,null);nXb=new $APP.q("emmy.util","bigint?","emmy.util/bigint?",-2014820488,null);
oXb=new $APP.q("emmy.env","log10","emmy.env/log10",1987722014,null);pXb=new $APP.q(null,"-tau","-tau",-286798365,null);qXb=new $APP.q(null,"-\x3ePowerSeries","-\x3ePowerSeries",-1598045772,null);rXb=new $APP.q("emmy.numerical.unimin.golden","golden-cut","emmy.numerical.unimin.golden/golden-cut",-1076889107,null);sXb=new $APP.q(null,"*angle-axis-tolerance*","*angle-axis-tolerance*",2006721849,null);tXb=new $APP.q("emmy.mechanics.lagrange","Q","emmy.mechanics.lagrange/Q",1745129875,null);
uXb=new $APP.q(null,"L-body-Euler","L-body-Euler",-2040106128,null);vXb=new $APP.q(null,"canonical-H?","canonical-H?",-405611558,null);wXb=new $APP.q("emmy.env","Lagrangian-action","emmy.env/Lagrangian-action",695056082,null);xXb=new $APP.q(null,"attempt?","attempt?",-1773174546,null);yXb=new $APP.q(null,"s:solve-linear-right","s:solve-linear-right",1060089768,null);zXb=new $APP.q("emmy.env","S2p","emmy.env/S2p",-259630439,null);
AXb=new $APP.q("emmy.generic","cosh","emmy.generic/cosh",-1228467059,null);BXb=new $APP.q("emmy.calculus.curvature","curvature-components","emmy.calculus.curvature/curvature-components",-1904819046,null);CXb=new $APP.q(null,"Routhian-\x3eacceleration","Routhian-\x3eacceleration",1211175498,null);DXb=new $APP.q(null,"transfer-point","transfer-point",-1401040996,null);EXb=new $APP.q("emmy.calculus.covariant","Cartan-\x3ebasis","emmy.calculus.covariant/Cartan-\x3ebasis",1780360992,null);
FXb=new $APP.q(null,"machine-epsilon","machine-epsilon",437133340,null);GXb=new $APP.q(null,"cylindrical","cylindrical",218572202,null);HXb=new $APP.q(null,"biginteger","biginteger",1355108809,null);IXb=new $APP.q(null,"gcd-Dp","gcd-Dp",-1099248144,null);JXb=new $APP.q("emmy.value","within","emmy.value/within",1077000489,null);KXb=new $APP.q("emmy.generic","coth","emmy.generic/coth",-1398977791,null);
LXb=new $APP.q(null,"two-particle-center-of-mass-canonical","two-particle-center-of-mass-canonical",-102541166,null);MXb=new $APP.q(null,"tanc","tanc",-1009303983,null);NXb=new $APP.q(null,"leading-base-coefficient","leading-base-coefficient",1172071111,null);OXb=new $APP.q("emmy.env","manifold-family?","emmy.env/manifold-family?",-1225639795,null);PXb=new $APP.q("emmy.env","four-tuple-\x3espace","emmy.env/four-tuple-\x3espace",1009030027,null);
QXb=new $APP.q("emmy.env","Gram-Schmidt","emmy.env/Gram-Schmidt",-317937621,null);RXb=new $APP.q(null,"tan-series","tan-series",-96331392,null);SXb=new $APP.q("emmy.env","sec","emmy.env/sec",-554488407,null);rH=new $APP.q(null,"-pi-over-2","-pi-over-2",-1344612268,null);TXb=new $APP.q("emmy.polynomial","contract","emmy.polynomial/contract",1054811430,null);oK=new $APP.q(null,"-pi-over-4","-pi-over-4",-640936368,null);
UXb=new $APP.q("emmy.series","atan-series","emmy.series/atan-series",1786308410,null);hX=new $APP.q(null,"invert","invert",-1100858266,null);VXb=new $APP.q(null,"REVERSE-MODE","REVERSE-MODE",1173981818,null);$APP.iX=new $APP.q(null,"scale","scale",1410104174,null);WXb=new $APP.q("emmy.mechanics.rigid","Euler-state-\x3eL-space","emmy.mechanics.rigid/Euler-state-\x3eL-space",1878812671,null);
XXb=new $APP.q("emmy.calculus.covariant","Christoffel-\x3ebasis","emmy.calculus.covariant/Christoffel-\x3ebasis",-979638843,null);YXb=new $APP.E("cljs.analyzer","access","cljs.analyzer/access",-1639036494);ZXb=new $APP.q("emmy.sr.frames","boost-direction","emmy.sr.frames/boost-direction",622867622,null);jX=new $APP.E(null,"adaptive-bulirsch-stoer","adaptive-bulirsch-stoer",1102962876);$Xb=new $APP.E(null,"protocol-duped-method","protocol-duped-method",15128166);
aYb=new $APP.q(null,"stirling-second-kind","stirling-second-kind",-1632116686,null);bYb=new $APP.q("emmy.pattern.rule","term-rewriting","emmy.pattern.rule/term-rewriting",542746664,null);cYb=new $APP.q("emmy.mechanics.routhian","Routh-equations","emmy.mechanics.routhian/Routh-equations",1721729330,null);dYb=new $APP.q("emmy.value","twopi","emmy.value/twopi",1284081997,null);eYb=new $APP.q(null,"fold-\x3esum-fn","fold-\x3esum-fn",323282874,null);
fYb=new $APP.q(null,"trig:product-\x3esum","trig:product-\x3esum",-715536960,null);kX=new $APP.q(null,"Quaternion","Quaternion",-1494551228,null);gYb=new $APP.q("emmy.env","raise","emmy.env/raise",-1855157007,null);hYb=new $APP.q("emmy.env","Christoffel-\x3ebasis","emmy.env/Christoffel-\x3ebasis",-270700167,null);iYb=new $APP.q("emmy.env","sin","emmy.env/sin",-1422271296,null);jYb=new $APP.E(null,"spherical-cylindrical","spherical-cylindrical",-1256191895);
kYb=new $APP.q("emmy.mechanics.lagrange","local-state-derivative","emmy.mechanics.lagrange/local-state-derivative",1351499178,null);lYb=new $APP.q(null,"sinh-series","sinh-series",-143264485,null);mYb=new $APP.q(null,"general-boost2","general-boost2",317456793,null);nYb=new $APP.q("emmy.util","throwable?","emmy.util/throwable?",1821279386,null);oYb=new $APP.q("emmy.modint","make","emmy.modint/make",-680305517,null);pYb=new $APP.q(null,"with-active-tag","with-active-tag",-1658062207,null);
qYb=new $APP.q("emmy.env","S3-tilted","emmy.env/S3-tilted",1353557674,null);rYb=new $APP.q(null,"sec-series","sec-series",1948327208,null);lX=new $APP.q(null,"quotient","quotient",-1029733218,null);sYb=new $APP.q(null,"rule*","rule*",-1143211614,null);tYb=new $APP.q(null,"corresponding-velocities","corresponding-velocities",-250568131,null);uYb=new $APP.q(null,"tanh-series","tanh-series",-1681700087,null);$APP.vYb=new $APP.E(null,"generic-params?","generic-params?",918310827);
wYb=new $APP.q("emmy.function","I","emmy.function/I",834238296,null);xYb=new $APP.q(null,"symbolic-operator","symbolic-operator",-644006930,null);mX=new $APP.q(null,"modints","modints",-142681111,null);yYb=new $APP.q(null,"make-analyzer","make-analyzer",1003266453,null);zYb=new $APP.q(null,"components-\x3eoneform-field","components-\x3eoneform-field",997325256,null);AYb=new $APP.q(null,"function?","function?",1729250129,null);rVa=new $APP.E(null,"?msg-fmt","?msg-fmt",-852453891);
BYb=new $APP.q("emmy.structure","valid-orientation?","emmy.structure/valid-orientation?",-1697867716,null);CYb=new $APP.q(null,"numeric-zero?","numeric-zero?",-636661046,null);DYb=new $APP.q("emmy.env","claim","emmy.env/claim",2051797457,null);EYb=new $APP.q("emmy.env","symmetrize-Christoffel","emmy.env/symmetrize-Christoffel",-253603322,null);nX=new $APP.q(null,"rules","rules",-1455523403,null);oX=new $APP.q(null,"tanh","tanh",480481797,null);
FYb=new $APP.q("emmy.quaternion","-\x3e4x4-matrix","emmy.quaternion/-\x3e4x4-matrix",-948191528,null);GYb=new $APP.q("emmy.env","literal-function","emmy.env/literal-function",-303807549,null);HYb=new $APP.q("emmy.polynomial","linear","emmy.polynomial/linear",-96337642,null);IYb=new $APP.q(null,"emmy.numerical.unimin.brent","emmy.numerical.unimin.brent",1839875438,null);V4a=new $APP.E(null,"oneform-basis","oneform-basis",-1252585473);
JYb=new $APP.q(null,"bracket-step-fn","bracket-step-fn",2063745685,null);pX=new $APP.q(null,"target-coordsys","target-coordsys",-1758011714,null);KYb=new $APP.q(null,"n-terms","n-terms",670229723,null);LYb=new $APP.q("emmy.calculus.vector-field","basis-components-\x3evector-field","emmy.calculus.vector-field/basis-components-\x3evector-field",-957459114,null);MYb=new $APP.q("emmy.mechanics.rotation","rotate-z-matrix","emmy.mechanics.rotation/rotate-z-matrix",1057448981,null);
NYb=new $APP.q("emmy.quaternion","from-4x4-matrix","emmy.quaternion/from-4x4-matrix",610184733,null);OYb=new $APP.q("emmy.numsymb","arctan?","emmy.numsymb/arctan?",1979965424,null);PYb=new $APP.E(null,"extending-base-js-type","extending-base-js-type",432787264);QYb=new $APP.q(null,"constant-promotion","constant-promotion",-1000242423,null);RYb=new $APP.q("emmy.calculus.frame","params","emmy.calculus.frame/params",-1036035145,null);
SYb=new $APP.q("emmy.numsymb","iterated-derivative?","emmy.numsymb/iterated-derivative?",1569175162,null);wPa=new $APP.E(null,"optimizations","optimizations",-2047476854);TYb=new $APP.q(null,"tolerance-in-ulps","tolerance-in-ulps",-736814321,null);UYb=new $APP.q(null,"yaw","yaw",-151366862,null);VYb=new $APP.q("cljs.core","record?","cljs.core/record?",1307655860,null);WYb=new $APP.q("emmy.numerical.unimin.bracket","bracket-step-fn","emmy.numerical.unimin.bracket/bracket-step-fn",-328691295,null);
XYb=new $APP.E(null,"deftype","deftype",340294561);BM=new $APP.E("emmy.rational-function","rational-function","emmy.rational-function/rational-function",282911607);YYb=new $APP.q("emmy.simplify.rules","magnitude","emmy.simplify.rules/magnitude",346952065,null);ZYb=new $APP.q(null,"column-matrix-\x3evector","column-matrix-\x3evector",2109025131,null);qX=new $APP.q(null,"c-\x3ee","c-\x3ee",366611773,null);$Yb=new $APP.q("emmy.quaternion","scale-l","emmy.quaternion/scale-l",838633755,null);
NE=new $APP.E(null,"body?","body?",-1333761917);aZb=new $APP.q(null,"R4-rect","R4-rect",1343116656,null);bZb=new $APP.q("emmy.algebra.fold","kahan-babushka-klein","emmy.algebra.fold/kahan-babushka-klein",1088587135,null);RVa=new $APP.E(null,"inherit","inherit",-1840815422);cZb=new $APP.q(null,"univariate-\x3edense","univariate-\x3edense",1461492071,null);dZb=new $APP.q("emmy.env","symplectic-transform?","emmy.env/symplectic-transform?",-1727337058,null);
eZb=new $APP.q(null,"*inverse-simplify?*","*inverse-simplify?*",2101097792,null);fZb=new $APP.q(null,"emmy.calculus.vector-field","emmy.calculus.vector-field",-119658085,null);gZb=new $APP.q("emmy.util.permute","permutations","emmy.util.permute/permutations",-1504080722,null);hZb=new $APP.q(null,"neville-recursive","neville-recursive",-641526016,null);iZb=new $APP.q("emmy.polynomial.gcd","with-limited-time","emmy.polynomial.gcd/with-limited-time",237969530,null);
DG=new $APP.E("emmy.value","real","emmy.value/real",-1508349404);jZb=new $APP.q(null,"emmy.generic","emmy.generic",-958738397,null);kZb=new $APP.q("emmy.mechanics.lagrange","Rayleigh-dissipation","emmy.mechanics.lagrange/Rayleigh-dissipation",1981989847,null);lZb=new $APP.q("clojure.core","rem","clojure.core/rem",-160175829,null);mZb=new $APP.q(null,"terms","terms",83553549,null);nZb=new $APP.q(null,"unquoted-form","unquoted-form",-910654799,null);
rX=new $APP.q(null,"inner-product","inner-product",-1963110418,null);oZb=new $APP.q(null,"target","target",1893533248,null);K4a=new $APP.q(null,"unnamed-1form-field","unnamed-1form-field",-518922876,null);sX=new $APP.q(null,"maxfun","maxfun",1590229713,null);pZb=new $APP.q("emmy.matrix","s:solve-linear-left","emmy.matrix/s:solve-linear-left",397138982,null);qZb=new $APP.q(null,"four-tuple-\x3espace","four-tuple-\x3espace",-4527322,null);
tX=new $APP.q(null,"embedding-dimension","embedding-dimension",-1284849802,null);rZb=new $APP.q(null,"emmy.rational-function","emmy.rational-function",1375834807,null);sZb=new $APP.q(null,"-\x3estate","-\x3estate",-1734302196,null);tZb=new $APP.q("emmy.dual","with-active-tag","emmy.dual/with-active-tag",-1374483221,null);uZb=new $APP.q("emmy.env","function-\x3eoneform-field","emmy.env/function-\x3eoneform-field",2116304673,null);
uX=new $APP.q("cljs.core","IIterable","cljs.core/IIterable",178674073,null);vX=new $APP.q("emmy.calculus.frame","IFrame","emmy.calculus.frame/IFrame",-1712074664,null);vZb=new $APP.q("emmy.calculus.manifold","SO3","emmy.calculus.manifold/SO3",-601633155,null);wZb=new $APP.q("emmy.env","Lie-transform","emmy.env/Lie-transform",883253732,null);xZb=new $APP.q("emmy.simplify.rules","*commute-partials?*","emmy.simplify.rules/*commute-partials?*",1616304717,null);
yZb=new $APP.q("emmy.pattern.rule","n-times","emmy.pattern.rule/n-times",747549053,null);mQ=new $APP.E(null,"maxfun","maxfun",-50301814);zZb=new $APP.q(null,"procedure","procedure",1817254099,null);wX=new $APP.E(null,"ns-name","ns-name",-2077346323);AZb=new $APP.q("emmy.env","determinant","emmy.env/determinant",-1685568089,null);BZb=new $APP.q(null,"merge-fn","merge-fn",-2066368428,null);eQa=new $APP.q("cljs.core","instance?","cljs.core/instance?",2044751870,null);
CZb=new $APP.q("emmy.env","metric:invert","emmy.env/metric:invert",392005322,null);DZb=new $APP.q("emmy.calculus.metric","S2-metric","emmy.calculus.metric/S2-metric",1230212191,null);EZb=new $APP.q(null,"numsymb-atan","numsymb-atan",-1523379191,null);FZb=new $APP.q("emmy.env","oneform-field-\x3ecomponents","emmy.env/oneform-field-\x3ecomponents",1251479665,null);GZb=new $APP.q("emmy.calculus.connection","structure-constant","emmy.calculus.connection/structure-constant",901785429,null);
HZb=new $APP.E(null,"step","step",1288888124);IZb=new $APP.q(null,"frame-name","frame-name",738489072,null);JZb=new $APP.q("emmy.env","vector-basis-\x3edual","emmy.env/vector-basis-\x3edual",-1302841887,null);KZb=new $APP.q("emmy.env","column-matrix","emmy.env/column-matrix",2099472349,null);LZb=new $APP.q(null,"time-independent-canonical?","time-independent-canonical?",-605708243,null);MZb=new $APP.q("emmy.env","SO3-type","emmy.env/SO3-type",-1376896483,null);
NZb=new $APP.q("emmy.algebra.fold","min","emmy.algebra.fold/min",-1610507122,null);xX=new $APP.q("cljs.core","IEmptyableCollection","cljs.core/IEmptyableCollection",5045035,null);OZb=new $APP.q("emmy.util","map-vals","emmy.util/map-vals",-28018698,null);PZb=new $APP.q(null,"down-of-ups?","down-of-ups?",2140316834,null);KQa=new $APP.E(null,"loop","loop",-395552849);QZb=new $APP.q("emmy.polynomial","negative?","emmy.polynomial/negative?",1104586968,null);
RZb=new $APP.q("emmy.numerical.unimin.bracket","bracket-max","emmy.numerical.unimin.bracket/bracket-max",1650860334,null);SZb=new $APP.q("emmy.env","make-Cartan","emmy.env/make-Cartan",-1490146795,null);TZb=new $APP.q("emmy.pattern.match","match-if","emmy.pattern.match/match-if",1603702515,null);UZb=new $APP.q("emmy.mechanics.noether","Noether-integral","emmy.mechanics.noether/Noether-integral",147652014,null);VZb=new $APP.q("emmy.env","general-boost2","emmy.env/general-boost2",1569638698,null);
WZb=new $APP.q(null,"make-diagonal","make-diagonal",-970636127,null);WTa=new $APP.q("cljs.core","\x3e\x3d","cljs.core/\x3e\x3d",350096541,null);XZb=new $APP.q("emmy.calculus.metric","metric-over-map","emmy.calculus.metric/metric-over-map",1937934396,null);YZb=new $APP.q(null,"Hamilton-equations","Hamilton-equations",655898383,null);ZZb=new $APP.q(null,"expression-\x3estring","expression-\x3estring",-956224851,null);$Zb=new $APP.q(null,"f-name","f-name",-825059691,null);
a_b=new $APP.q("emmy.ratio","ratio?","emmy.ratio/ratio?",-242905704,null);RRa=new $APP.E(null,"quoted?","quoted?",1464649621);mYa=new $APP.E("emmy.pattern.match","segment?","emmy.pattern.match/segment?",-1563429454);b_b=new $APP.q(null,"num-rows","num-rows",2047176513,null);c_b=new $APP.q(null,"Euler-state-\x3eL-space","Euler-state-\x3eL-space",-378458455,null);d_b=new $APP.q("emmy.util","uuid","emmy.util/uuid",-24411268,null);
e_b=new $APP.q("emmy.env","structure-\x3etyped","emmy.env/structure-\x3etyped",-757645765,null);f_b=new $APP.q("emmy.pattern.consequence","compile-skeleton","emmy.pattern.consequence/compile-skeleton",1472561534,null);g_b=new $APP.q(null,"cos-sq-\x3esin-sq","cos-sq-\x3esin-sq",990466072,null);yX=new $APP.q(null,"negative?","negative?",374534410,null);h_b=new $APP.q(null,"-\x3estr","-\x3estr",-457137396,null);zX=new $APP.E(null,"sci?","sci?",2029704845);
i_b=new $APP.q(null,"R3-spherical","R3-spherical",934549319,null);j_b=new $APP.q(null,"generic-sum","generic-sum",800077806,null);xVa=new $APP.E(null,"?file","?file",1533429675);k_b=new $APP.q(null,"pullback-form","pullback-form",1098147136,null);l_b=new $APP.q(null,"neville-sum","neville-sum",-1107691511,null);QOa=new $APP.E(null,"js-dependency-index","js-dependency-index",-1887042131);m_b=new $APP.q(null,"choice*","choice*",-40649013,null);aPa=new $APP.E(null,"undeclared-ns","undeclared-ns",-1589012812);
n_b=new $APP.q(null,"transpose-function","transpose-function",45049194,null);o_b=new $APP.q("emmy.calculus.covariant","Christoffel-\x3esymbols","emmy.calculus.covariant/Christoffel-\x3esymbols",1533974164,null);YPa=new $APP.q(null,".-cljs$lang$test",".-cljs$lang$test",718963148,null);AX=new $APP.q("emmy.simplify","*rf-simplify*","emmy.simplify/*rf-simplify*",-1340102255,null);p_b=new $APP.q("emmy.mechanics.lagrange","time","emmy.mechanics.lagrange/time",1463162485,null);
q_b=new $APP.q("Math","acosh","Math/acosh",-2007025431,null);r_b=new $APP.q("emmy.env","coordinate","emmy.env/coordinate",497866413,null);s_b=new $APP.q(null,"pseudo-remainder","pseudo-remainder",-1008273201,null);t_b=new $APP.E(null,"Euler","Euler",-773634476);u_b=new $APP.q("s","valid-orientation?","s/valid-orientation?",1508040722,null);v_b=new $APP.q("cljs.core","ITaggedLiteral","cljs.core/ITaggedLiteral",-1236965094,null);w_b=new $APP.E(null,"frame","frame",-1711082588);
UTa=new $APP.q(null,"sum__38704__auto__","sum__38704__auto__",-1684026281,null);x_b=new $APP.q("emmy.rational-function","-\x3eRationalFunction","emmy.rational-function/-\x3eRationalFunction",-1177410016,null);y_b=new $APP.q(null,"literal-number?","literal-number?",-1668954321,null);z_b=new $APP.q("emmy.simplify.rules","*aggressive-atan-simplify?*","emmy.simplify.rules/*aggressive-atan-simplify?*",443502472,null);
A_b=new $APP.q("emmy.calculus.vector-field","coordinate-basis-vector-field","emmy.calculus.vector-field/coordinate-basis-vector-field",-155853334,null);$APP.BX=new $APP.q(null,"axis","axis",425140705,null);B_b=new $APP.q("emmy.generic","cube","emmy.generic/cube",-54907240,null);sSa=new $APP.E(null,"js-object","js-object",1830199158);C_b=new $APP.q("emmy.generic","divide","emmy.generic/divide",62869867,null);zUa=new $APP.E(null,"spec","spec",347520401);
D_b=new $APP.q("emmy.env","acsch","emmy.env/acsch",-415577575,null);E_b=new $APP.q(null,"-\x3efunction","-\x3efunction",267614160,null);F_b=new $APP.q("emmy.env","typical-coords","emmy.env/typical-coords",-1155038391,null);G_b=new $APP.q("emmy.env","rotate-x-matrix","emmy.env/rotate-x-matrix",-2058569071,null);H_b=new $APP.q("emmy.simplify.rules","*sqrt-expt-simplify?*","emmy.simplify.rules/*sqrt-expt-simplify?*",713867908,null);
I_b=new $APP.q("emmy.calculus.manifold","S1-tilted","emmy.calculus.manifold/S1-tilted",-1260834007,null);$APP.CX=new $APP.q("cljs.core","map","cljs.core/map",-338988913,null);J_b=new $APP.q("emmy.calculus.manifold","S2p-spherical","emmy.calculus.manifold/S2p-spherical",355633914,null);K_b=new $APP.q(null,"add-v:cs","add-v:cs",939327354,null);L_b=new $APP.q(null,"s:divide-by-structure","s:divide-by-structure",-459494025,null);M_b=new $APP.q(null,"solve-linear","solve-linear",481545288,null);
N_b=new $APP.q("emmy.structure","two-down?","emmy.structure/two-down?",-452398802,null);O_b=new $APP.q("emmy.calculus.metric","invert","emmy.calculus.metric/invert",-1249976488,null);P_b=new $APP.q("emmy.env","SR-name","emmy.env/SR-name",594445252,null);Q_b=new $APP.q(null,"pipe*","pipe*",-1519243240,null);R_b=new $APP.q("emmy.pattern.syntax","reverse-segment?","emmy.pattern.syntax/reverse-segment?",1834546852,null);S_b=new $APP.q(null,"general-boost","general-boost",-313944893,null);
T_b=new $APP.q("emmy.util.stream","separatev","emmy.util.stream/separatev",-147050291,null);U_b=new $APP.q("emmy.env","Cartan-\x3eChristoffel","emmy.env/Cartan-\x3eChristoffel",585019648,null);V_b=new $APP.q("emmy.polynomial","monic?","emmy.polynomial/monic?",1080857753,null);W_b=new $APP.q(null,"bulirsch-stoer","bulirsch-stoer",-1970651209,null);X_b=new $APP.q("emmy.series","arg-shift","emmy.series/arg-shift",833721084,null);Y_b=new $APP.q(null,"sinhc","sinhc",-1445515294,null);
Z_b=new $APP.q("emmy.env","exp","emmy.env/exp",747203716,null);$_b=new $APP.q("emmy.calculus.manifold","S2-Riemann","emmy.calculus.manifold/S2-Riemann",-154789983,null);a0b=new $APP.q("emmy.pattern.rule","branch","emmy.pattern.rule/branch",-1395715698,null);b0b=new $APP.q("emmy.env","S3-gnomonic","emmy.env/S3-gnomonic",-867872885,null);c0b=new $APP.q("emmy.mechanics.lagrange","L-Kepler-polar","emmy.mechanics.lagrange/L-Kepler-polar",-824230560,null);d0b=new $APP.q(null,"ccs","ccs",2099570085,null);
e0b=new $APP.q("emmy.env","numerical?","emmy.env/numerical?",-675960418,null);f0b=new $APP.q("emmy.simplify.rules","split-high-degree-sincos","emmy.simplify.rules/split-high-degree-sincos",-92455769,null);b7a=new $APP.E(null,"unary-minus","unary-minus",737624832);g0b=new $APP.q("emmy.util.aggregate","scan","emmy.util.aggregate/scan",644736072,null);h0b=new $APP.q("emmy.env","torsion","emmy.env/torsion",1073906108,null);
i0b=new $APP.q("emmy.calculus.manifold","manifold?","emmy.calculus.manifold/manifold?",592406266,null);j0b=new $APP.q("emmy.pattern.match","failure","emmy.pattern.match/failure",1236312317,null);k0b=new $APP.q("emmy.expression.compile","sci-eval","emmy.expression.compile/sci-eval",270375637,null);l0b=new $APP.q("emmy.pattern.rule","pattern*","emmy.pattern.rule/pattern*",1606954511,null);m0b=new $APP.q(null,"emmy.mechanics.routhian","emmy.mechanics.routhian",-18871499,null);
n0b=new $APP.q("emmy.mechanics.hamilton","canonical-transform?","emmy.mechanics.hamilton/canonical-transform?",184573576,null);o0b=new $APP.q("emmy.env","components-\x3emetric","emmy.env/components-\x3emetric",-462332794,null);p0b=new $APP.q("emmy.simplify.rules","flush-obvious-ones","emmy.simplify.rules/flush-obvious-ones",-1550927165,null);q0b=new $APP.q("js","RegExp","js/RegExp",1778210562,null);r0b=new $APP.q("emmy.env","typical-point","emmy.env/typical-point",-57933656,null);
s0b=new $APP.q(null,"SO3","SO3",-1478144109,null);t0b=new $APP.q(null,"pullback-function","pullback-function",811870172,null);u0b=new $APP.q(null,"structure-\x3eprototype","structure-\x3eprototype",927102475,null);v0b=new $APP.q("emmy.complex","-I","emmy.complex/-I",1778981724,null);w0b=new $APP.q("emmy.operator","name","emmy.operator/name",-1936818318,null);x0b=new $APP.q(null,"objects","objects",-554722035,null);y0b=new $APP.q(null,"D-forward","D-forward",-20106674,null);
z0b=new $APP.q(null,"Hamiltonian-\x3eLagrangian","Hamiltonian-\x3eLagrangian",-1691416956,null);A0b=new $APP.q("emmy.calculus.indexed","structure-\x3etyped","emmy.calculus.indexed/structure-\x3etyped",-2094967225,null);MM=new $APP.q(null,"cot","cot",-1635649012,null);sH=new $APP.q(null,"cos","cos",-1452677493,null);B0b=new $APP.q(null,"S1-tilted","S1-tilted",1914352915,null);C0b=new $APP.q(null,"as-attempt","as-attempt",-1258923575,null);
D0b=new $APP.q("emmy.env","derivative","emmy.env/derivative",-236606619,null);E0b=new $APP.q(null,"qp-submatrix","qp-submatrix",1695903452,null);DX=new $APP.q(null,"symbols","symbols",1641743270,null);F0b=new $APP.q("emmy.sr.frames","SR-name","emmy.sr.frames/SR-name",971953516,null);G0b=new $APP.q(null,"emmy.polynomial.gcd","emmy.polynomial.gcd",-949784554,null);P4a=new $APP.q(null,"Alt","Alt",-1183702663,null);
H0b=new $APP.q(null,"emmy.numerical.multimin.nelder-mead","emmy.numerical.multimin.nelder-mead",-97174390,null);BE=new $APP.E(null,"rename-macros","rename-macros",1076432512);I0b=new $APP.q("emmy.env","S2-stereographic","emmy.env/S2-stereographic",-1165975109,null);J0b=new $APP.q("emmy.env","linear-interpolants","emmy.env/linear-interpolants",1045998745,null);K0b=new $APP.q("emmy.rational-function","arity","emmy.rational-function/arity",165977631,null);
L0b=new $APP.q("emmy.calculus.manifold","R1-rect","emmy.calculus.manifold/R1-rect",-2128452746,null);M0b=new $APP.q(null,"compare-full","compare-full",-1384935832,null);EX=new $APP.q(null,"tqv","tqv",-1233922921,null);N0b=new $APP.q(null,"quaternion","quaternion",-808610151,null);FX=new $APP.q(null,"arg-shift","arg-shift",-382841075,null);BOa=new $APP.E("clojure.error","source","clojure.error/source",-2011936397);JWa=new $APP.E(null,"one-like","one-like",887133720);
O0b=new $APP.q("emmy.env","S1-circular","emmy.env/S1-circular",968818019,null);P0b=new $APP.q(null,"H-harmonic","H-harmonic",881633245,null);rRa=new $APP.E(null,"warn-type","warn-type",-790105219);Q0b=new $APP.q(null,"log-extra","log-extra",-1713077798,null);R0b=new $APP.q(null,"elliptic-pi","elliptic-pi",-78943475,null);S0b=new $APP.q(null,"bs-prepare","bs-prepare",-1806775766,null);SRa=new $APP.E(null,"def-var","def-var",-698214377);
T0b=new $APP.q("emmy.util","exception","emmy.util/exception",-1125365357,null);U0b=new $APP.q("emmy.env","literal-Christoffel-1","emmy.env/literal-Christoffel-1",-1177081599,null);V0b=new $APP.q("emmy.env","-\x3eJavaScript","emmy.env/-\x3eJavaScript",-1569654075,null);W0b=new $APP.q("emmy.env","literal-Christoffel-2","emmy.env/literal-Christoffel-2",1611336401,null);GX=new $APP.q(null,"dot-product","dot-product",-203055892,null);
X0b=new $APP.q(null,"emmy.pattern.rule","emmy.pattern.rule",1311400615,null);Y0b=new $APP.q("emmy.calculus.indexed","with-index-types","emmy.calculus.indexed/with-index-types",-1256331971,null);Z0b=new $APP.q(null,"by-cols*","by-cols*",1865655980,null);$0b=new $APP.q(null,"vector-dot-product","vector-dot-product",433547396,null);a1b=new $APP.q(null,"revert","revert",656545594,null);b1b=new $APP.q("emmy.pattern.rule","attempt","emmy.pattern.rule/attempt",-1854835985,null);
c1b=new $APP.q("emmy.operator","expn","emmy.operator/expn",1368721850,null);d1b=new $APP.E(null,"numerator","numerator",-160761104);e1b=new $APP.q(null,"emmy.series","emmy.series",1477801845,null);f1b=new $APP.q(null,"Gram-Schmidt","Gram-Schmidt",-1549606410,null);g1b=new $APP.q("emmy.matrix","dimension","emmy.matrix/dimension",1160671846,null);h1b=new $APP.q(null,"derivative-args","derivative-args",1022399972,null);
i1b=new $APP.q("emmy.expression.analyze","-\x3eexpression","emmy.expression.analyze/-\x3eexpression",128259950,null);j1b=new $APP.E(null,"dep-path","dep-path",723826558);k1b=new $APP.q(null,"phase-space-derivative","phase-space-derivative",-105121875,null);WPa=new $APP.q(null,"clj","clj",980036099,null);l1b=new $APP.E(null,"single-segment-namespace","single-segment-namespace",-491924469);m3a=new $APP.E(null,"family","family",-1313145692);
m1b=new $APP.q("emmy.env","floor","emmy.env/floor",324561235,null);HX=new $APP.q(null,"??post","??post",1092296697,null);n1b=new $APP.q("emmy.env","components-\x3evector-field","emmy.env/components-\x3evector-field",-105983410,null);o1b=new $APP.q(null,"non-negative-factors!","non-negative-factors!",106433803,null);p1b=new $APP.q(null,"cofactors","cofactors",-589984987,null);IX=new $APP.q(null,"expression-\x3e","expression-\x3e",-916231213,null);q1b=new $APP.E(null,"var-ast","var-ast",1200379319);
$APP.JX=new $APP.q(null,"sub","sub",-453228498,null);r1b=new $APP.q(null,"modified-neville-scan","modified-neville-scan",1947157950,null);s1b=new $APP.q(null,"atanh-series","atanh-series",-1138222374,null);t1b=new $APP.q(null,"rectangular-\x3epolar","rectangular-\x3epolar",937043161,null);u1b=new $APP.q(null,"sum","sum",1777518341,null);v1b=new $APP.q("emmy.generic","acosh","emmy.generic/acosh",-1531863054,null);
w1b=new $APP.q("emmy.calculus.manifold","zero-manifold-function","emmy.calculus.manifold/zero-manifold-function",-1079676127,null);x1b=new $APP.q(null,"parse-bigint","parse-bigint",2129948991,null);KX=new $APP.q("emmy.ratio","rationalize","emmy.ratio/rationalize",2140571274,null);LX=new $APP.q("emmy.calculus.vector-field","coordinate-system-\x3evector-basis","emmy.calculus.vector-field/coordinate-system-\x3evector-basis",-807504210,null);
MX=new $APP.q(null,"metric-tensor","metric-tensor",201092848,null);y1b=new $APP.q(null,"trig-\x3esincos","trig-\x3esincos",1047780302,null);z1b=new $APP.q("emmy.generic","acoth","emmy.generic/acoth",905314862,null);A1b=new $APP.q("emmy.env","v:make-basis-unit","emmy.env/v:make-basis-unit",1498955603,null);B1b=new $APP.E(null,"frame-name","frame-name",-902042455);C1b=new $APP.q(null,"oneform-field-\x3ebasis-components","oneform-field-\x3ebasis-components",524891333,null);
D1b=new $APP.q("emmy.dual","map-\x3eCompleted","emmy.dual/map-\x3eCompleted",1086089032,null);NX=new $APP.E(null,"between","between",1131099276);E1b=new $APP.q("emmy.value","real?","emmy.value/real?",233515503,null);F1b=new $APP.q("emmy.calculus.curvature","Ricci","emmy.calculus.curvature/Ricci",-1017978157,null);G1b=new $APP.q("emmy.calculus.coordinate","using-coordinates","emmy.calculus.coordinate/using-coordinates",340839422,null);
H1b=new $APP.q("emmy.calculus.covariant","Cartan-transform","emmy.calculus.covariant/Cartan-transform",2058003451,null);OX=new $APP.q(null,"alpha","alpha",65549086,null);I1b=new $APP.q("emmy.mechanics.lagrange","Lagrangian-action","emmy.mechanics.lagrange/Lagrangian-action",222123715,null);PX=new $APP.q(null,"negate","negate",337772450,null);J1b=new $APP.q("emmy.structure","compatible-zero","emmy.structure/compatible-zero",633589477,null);K1b=new $APP.q(null,"exp-series","exp-series",965017655,null);
L1b=new $APP.q("emmy.env","Lagrange-equations-first-order","emmy.env/Lagrange-equations-first-order",-46063249,null);M1b=new $APP.q("emmy.mechanics.rigid","qw-state-\x3eL-space","emmy.mechanics.rigid/qw-state-\x3eL-space",-1775007301,null);N1b=new $APP.q(null,"constant-manifold-function","constant-manifold-function",-128826051,null);TPa=new $APP.q(null,"ignore","ignore",8989494,null);O1b=new $APP.q(null,"make-manifold","make-manifold",1553241629,null);
P1b=new $APP.q("emmy.mechanics.lagrange","rectangular-\x3epolar","emmy.mechanics.lagrange/rectangular-\x3epolar",-702186331,null);Q1b=new $APP.q("emmy.generic","imag-part","emmy.generic/imag-part",-1809478125,null);R1b=new $APP.q("emmy.env","one?","emmy.env/one?",-1356116672,null);S1b=new $APP.q("emmy.env","sinh","emmy.env/sinh",-2046226859,null);QX=new $APP.q(null,"tolerance","tolerance",2047343345,null);T1b=new $APP.q("emmy.env","sinc","emmy.env/sinc",1560810312,null);
U1b=new $APP.q(null,"freeze","freeze",-610969460,null);V1b=new $APP.q("emmy.ratio","numerator","emmy.ratio/numerator",1333610278,null);W1b=new $APP.q(null,"L-body","L-body",346543391,null);X1b=new $APP.q(null,"parallel-transport-equation","parallel-transport-equation",-355914355,null);Y1b=new $APP.q(null,"partial-sums","partial-sums",-1831543974,null);Z1b=new $APP.q(null,"S2p","S2p",220470602,null);
$1b=new $APP.q("emmy.expression.compile","set-compiler-mode!","emmy.expression.compile/set-compiler-mode!",223681889,null);MUa=new $APP.E(null,"raw-console?","raw-console?",-2061489061);pQa=new $APP.E(null,"arg-id","arg-id",-767177868);a2b=new $APP.q("emmy.util","long","emmy.util/long",1152494126,null);b2b=new $APP.q(null,"negative-number?","negative-number?",1763499605,null);c2b=new $APP.q("emmy.pattern.match","failed?","emmy.pattern.match/failed?",1191158064,null);
d2b=new $APP.q(null,"generic-sum-fold","generic-sum-fold",136678028,null);e2b=new $APP.q("emmy.calculus.basis","coordinate-basis?","emmy.calculus.basis/coordinate-basis?",16882539,null);f2b=new $APP.q("emmy.simplify","*poly-simplify*","emmy.simplify/*poly-simplify*",741964388,null);RX=new $APP.q(null,"mu-inverse:M-\x3eN","mu-inverse:M-\x3eN",1931872757,null);g2b=new $APP.q("emmy.env","literal-up","emmy.env/literal-up",869470067,null);h2b=new $APP.E(null,"redef-in-file","redef-in-file",-476530788);
i2b=new $APP.q(null,"v2:c","v2:c",1724311857,null);j2b=new $APP.q(null,"neville-fold","neville-fold",-291266752,null);k2b=new $APP.q("emmy.env","event-\x3ecoords","emmy.env/event-\x3ecoords",965005798,null);l2b=new $APP.q("emmy.util.stream","pprint","emmy.util.stream/pprint",1702116860,null);m2b=new $APP.q("emmy.calculus.metric","drop2","emmy.calculus.metric/drop2",1505706076,null);n2b=new $APP.q("emmy.calculus.metric","drop1","emmy.calculus.metric/drop1",1068830376,null);
o2b=new $APP.E("emmy.calculus.derivative","multi","emmy.calculus.derivative/multi",-1645123100);p2b=new $APP.q(null,"kbk-n","kbk-n",-118508308,null);q2b=new $APP.q("u","sqrt-machine-epsilon","u/sqrt-machine-epsilon",-243376683,null);r2b=new $APP.q("emmy.polynomial","lowest-degree","emmy.polynomial/lowest-degree",1856604792,null);s2b=new $APP.q("cljs.core","tagged-literal?","cljs.core/tagged-literal?",-1159666987,null);
t2b=new $APP.q("emmy.pattern.match","update-frame","emmy.pattern.match/update-frame",613740042,null);lK=new $APP.q(null,"tan","tan",-1380825876,null);u2b=new $APP.q("emmy.mechanics.hamilton","canonical-H?","emmy.mechanics.hamilton/canonical-H?",-588882291,null);v2b=new $APP.q("emmy.generic","exact-divide","emmy.generic/exact-divide",-1779568007,null);w2b=new $APP.q(null,"tau","tau",1730314431,null);x2b=new $APP.E(null,"throw","throw",-1044625833);
y2b=new $APP.q(null,"match-if","match-if",-2104618812,null);z2b=new $APP.q(null,"by-rows","by-rows",1662495500,null);A2b=new $APP.q("emmy.env","taylor-series","emmy.env/taylor-series",-473286137,null);SX=new $APP.q(null,"theta","theta",1213021269,null);B2b=new $APP.q(null,"contract-expt-trig","contract-expt-trig",-294579507,null);C2b=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer-sum","emmy.rational-function.interpolate/bulirsch-stoer-sum",-957607949,null);
D2b=new $APP.q(null,"down*","down*",813038101,null);E2b=new $APP.q("Math","exp","Math/exp",1383313257,null);tSa=new $APP.E(null,"js-array","js-array",-1210185421);F2b=new $APP.q("emmy.calculus.derivative","gradient","emmy.calculus.derivative/gradient",-2143065137,null);G2b=new $APP.q(null,"spacetime-rect","spacetime-rect",-779647580,null);$APP.qF=new $APP.E(null,"items","items",1031954938);H2b=new $APP.q(null,"down?","down?",-953416276,null);
DE=new $APP.E(null,"protocol-symbol","protocol-symbol",1279552198);I2b=new $APP.q(null,"fib-series","fib-series",41134027,null);J2b=new $APP.q("emmy.series","power-series","emmy.series/power-series",1699243945,null);K2b=new $APP.q("emmy.polynomial.gcd","-\x3econtent+primitive","emmy.polynomial.gcd/-\x3econtent+primitive",1552903515,null);L2b=new $APP.q(null,"from-points","from-points",-882765250,null);
M2b=new $APP.q("emmy.simplify.rules","sincos-flush-ones","emmy.simplify.rules/sincos-flush-ones",1279089513,null);vUa=new $APP.E(null,"req-id","req-id",-471642231);N2b=new $APP.q("emmy.mechanics.hamilton","canonical-K?","emmy.mechanics.hamilton/canonical-K?",962806032,null);O2b=new $APP.q("emmy.env","principal-value","emmy.env/principal-value",-1240139374,null);P2b=new $APP.q(null,"osculating-path","osculating-path",677457360,null);
Q2b=new $APP.q("emmy.env","Laplacian","emmy.env/Laplacian",-149101911,null);R2b=new $APP.q("emmy.numsymb","product?","emmy.numsymb/product?",1361897618,null);S2b=new $APP.E(null,"case","case",1143702196);T2b=new $APP.q(null,"emmy.numerical.derivative","emmy.numerical.derivative",297292057,null);U2b=new $APP.q("emmy.calculus.metric","metric-\x3ecomponents","emmy.calculus.metric/metric-\x3ecomponents",-463638042,null);
V2b=new $APP.q("emmy.pattern.rule","pattern","emmy.pattern.rule/pattern",592549338,null);TX=new $APP.q(null,"coordinate-system-name","coordinate-system-name",-448421652,null);aR=new $APP.q(null,"Lie-derivative","Lie-derivative",-641072185,null);W2b=new $APP.q("emmy.series","asin-series","emmy.series/asin-series",1277951367,null);LM=new $APP.q(null,"sec","sec",60154974,null);wOa=new $APP.E(null,"root-source-info","root-source-info",-1436144912);X2b=new $APP.q(null,"lowrow","lowrow",829607435,null);
Y2b=new $APP.q("emmy.mechanics.rotation","rotate-x-matrix","emmy.mechanics.rotation/rotate-x-matrix",403786189,null);Z2b=new $APP.q(null,"emmy.complex","emmy.complex",-827099193,null);$2b=new $APP.q(null,"coordinate-system-names","coordinate-system-names",793552790,null);MWb=new $APP.q("emmy.calculus.manifold","manifold","emmy.calculus.manifold/manifold",627242716,null);b3b=new $APP.q(null,"typical-coords","typical-coords",-29279558,null);
MP=new $APP.q("emmy.structure","down","emmy.structure/down",-104137184,null);c3b=new $APP.E(null,"hi","hi",-1821422114);d3b=new $APP.q("emmy.mechanics.lagrange","L-rectangular","emmy.mechanics.lagrange/L-rectangular",-281349062,null);e3b=new $APP.q("emmy.dual","eq","emmy.dual/eq",770908386,null);f3b=new $APP.q("emmy.env","orientation","emmy.env/orientation",1213531559,null);g3b=new $APP.q("emmy.generic","infinite?","emmy.generic/infinite?",-1270410512,null);
h3b=new $APP.q("emmy.simplify.rules","constant-promotion","emmy.simplify.rules/constant-promotion",-2078995235,null);i3b=new $APP.q("emmy.polynomial.impl","*monomial-order*","emmy.polynomial.impl/*monomial-order*",1553049184,null);j3b=new $APP.q("emmy.sr.frames","add-velocities","emmy.sr.frames/add-velocities",433017933,null);k3b=new $APP.q(null,"iterated-derivative?","iterated-derivative?",-1758259757,null);
l3b=new $APP.q("emmy.polynomial.factor","analyzer","emmy.polynomial.factor/analyzer",-766467377,null);m3b=new $APP.q("emmy.calculus.curvature","Riemann-curvature","emmy.calculus.curvature/Riemann-curvature",-1319246385,null);n3b=new $APP.q(null,"Lagrange-equations-1","Lagrange-equations-1",-1918067853,null);o3b=new $APP.q("emmy.rational-function","div","emmy.rational-function/div",-1259121510,null);p3b=new $APP.q("emmy.matrix","submatrix","emmy.matrix/submatrix",-1051104126,null);
q3b=new $APP.q(null,"emmy.modint","emmy.modint",216958365,null);r3b=new $APP.q(null,"const","const",-944505927,null);s3b=new $APP.q(null,"emmy.calculus.covariant","emmy.calculus.covariant",-709530597,null);t3b=new $APP.q("emmy.numerical.derivative","central-difference-d2","emmy.numerical.derivative/central-difference-d2",-45922657,null);u3b=new $APP.q("emmy.env","structure-constant","emmy.env/structure-constant",-287324128,null);UX=new $APP.q(null,"basis?","basis?",1311714792,null);
v3b=new $APP.q(null,"emmy.polynomial","emmy.polynomial",1304101377,null);w3b=new $APP.q(null,"S2-Riemann","S2-Riemann",940087751,null);x3b=new $APP.q("emmy.generic","zero?","emmy.generic/zero?",1202030068,null);y3b=new $APP.q("emmy.calculus.vector-calculus","Div","emmy.calculus.vector-calculus/Div",-2082339375,null);z3b=new $APP.E(null,"kind","kind",-717265803);A3b=new $APP.q("emmy.rational-function","-\x3eexpression","emmy.rational-function/-\x3eexpression",-1497272771,null);
TZa=new $APP.E(null,"inner-orientation","inner-orientation",-728775897);B3b=new $APP.E(null,"initial-h","initial-h",213105060);C3b=new $APP.q(null,"Lagrangian-\x3eenergy","Lagrangian-\x3eenergy",-73689250,null);D3b=new $APP.q("emmy.env","Cartan-\x3eCartan-over-map","emmy.env/Cartan-\x3eCartan-over-map",-187077823,null);E3b=new $APP.q("emmy.env","Lagrangian-\x3epower-loss","emmy.env/Lagrangian-\x3epower-loss",1654119300,null);$APP.VX=new $APP.q(null,"transpose","transpose",1165804847,null);
gF=new $APP.q("cljs.core","Keyword","cljs.core/Keyword",-451434488,null);F3b=new $APP.q(null,"pure?","pure?",1991394218,null);G3b=new $APP.q("emmy.mechanics.lagrange","Qdot","emmy.mechanics.lagrange/Qdot",-535548756,null);H3b=new $APP.q("emmy.polynomial","new-variables","emmy.polynomial/new-variables",-1814008275,null);I3b=new $APP.q(null,"R2-polar","R2-polar",-1569929362,null);$APP.J3b=new $APP.E(null,"dt","dt",-368444759);K3b=new $APP.E(null,"do","do",46310725);
PG=new $APP.E(null,"vargs","vargs",-966597273);B5a=new $APP.q(null,"Lie-D","Lie-D",1269840403,null);L3b=new $APP.q(null,"rotate-x-matrix","rotate-x-matrix",-1071484222,null);M3b=new $APP.q(null,"unary-elimination","unary-elimination",696583795,null);N3b=new $APP.q("cljs.core","checked-aget'","cljs.core/checked-aget'",1960922245,null);O3b=new $APP.q("emmy.matrix","fmap","emmy.matrix/fmap",1078467015,null);P3b=new $APP.E(null,"extend-type-invalid-method-shape","extend-type-invalid-method-shape",1424103549);
q5a=new $APP.q(null,"pushforward","pushforward",-683343030,null);Q3b=new $APP.q(null,"inttype","inttype",-1877271282,null);$APP.R3b=new $APP.q(null,"group","group",-2071839637,null);S3b=new $APP.q("emmy.polynomial","-\x3eexpression","emmy.polynomial/-\x3eexpression",222600204,null);T3b=new $APP.q(null,"multidimensional-minimize","multidimensional-minimize",448428381,null);U3b=new $APP.E(null,"replace-tag","replace-tag",-109294055);
V3b=new $APP.q("emmy.quaternion","pitch","emmy.quaternion/pitch",-1964701701,null);WX=new $APP.q(null,"choose","choose",-974232464,null);W3b=new $APP.q("emmy.dual","extract-tangent","emmy.dual/extract-tangent",-2069345116,null);X3b=new $APP.q("emmy.util.permute","combinations","emmy.util.permute/combinations",1176682102,null);Y3b=new $APP.q(null,"asech","asech",-316284500,null);jE=new $APP.E(null,"defs","defs",1398449717);
Z3b=new $APP.q("emmy.env","compositional-canonical?","emmy.env/compositional-canonical?",844867868,null);$3b=new $APP.q(null,"compile-fn","compile-fn",-1899745280,null);wK=new $APP.q(null,"?other-op","?other-op",-881473313,null);a4b=new $APP.q("emmy.matrix","cramers-rule","emmy.matrix/cramers-rule",-1466485203,null);b4b=new $APP.q("emmy.env","osculating-path","emmy.env/osculating-path",-158362333,null);c4b=new $APP.q(null,"with-substituted-row","with-substituted-row",-1155079974,null);
d4b=new $APP.q(null,"extract-common-subexpressions","extract-common-subexpressions",-1840588961,null);e4b=new $APP.E(null,"protocol-impl-with-variadic-method","protocol-impl-with-variadic-method",-319321217);XX=new $APP.q("emmy.expression.analyze","ICanonicalize","emmy.expression.analyze/ICanonicalize",433117116,null);f4b=new $APP.q(null,"complex-2","complex-2",490677522,null);g4b=new $APP.q("emmy.rational-function","eq","emmy.rational-function/eq",-925728373,null);
h4b=new $APP.q(null,"complex-1","complex-1",-1582732184,null);i4b=new $APP.q("emmy.polynomial.interpolate","neville-scan","emmy.polynomial.interpolate/neville-scan",-406731484,null);YX=new $APP.q(null,"modulo","modulo",725580254,null);j4b=new $APP.q("emmy.polynomial","leading-base-coefficient","emmy.polynomial/leading-base-coefficient",-1789383243,null);ZX=new $APP.E(null,"internal-ctor","internal-ctor",937392560);n3a=new $APP.E(null,"over","over",192553051);
k4b=new $APP.q("emmy.matrix","s:inverse","emmy.matrix/s:inverse",2136163490,null);$X=new $APP.q(null,"Lagrangian","Lagrangian",-1148415573,null);l4b=new $APP.q("emmy.env","S2p-gnomonic","emmy.env/S2p-gnomonic",-1190620738,null);oQ=new $APP.E(null,"converged?","converged?",1779059976);m4b=new $APP.q(null,"Dual","Dual",-234231465,null);n4b=new $APP.q(null,"solve-linear-left","solve-linear-left",1437395114,null);o4b=new $APP.q(null,"iterated","iterated",1073898993,null);
p4b=new $APP.q(null,"submatrix","submatrix",73135469,null);q4b=new $APP.q(null,"sqrt-machine-epsilon","sqrt-machine-epsilon",-243376808,null);r4b=new $APP.E(null,"redef","redef",1032704258);aY=new $APP.q(null,"trace","trace",557784112,null);s4b=new $APP.q("emmy.generic","identity-like","emmy.generic/identity-like",1873486939,null);t4b=new $APP.q("emmy.env","s:generate","emmy.env/s:generate",-1478588552,null);u4b=new $APP.q(null,"bell-series","bell-series",-1645672484,null);
v4b=new $APP.q("emmy.env","trace2up","emmy.env/trace2up",-510812446,null);w4b=new $APP.q(null,"emmy.util.permute","emmy.util.permute",2100059640,null);x4b=new $APP.q(null,"c*xn","c*xn",-1209260317,null);y4b=new $APP.E(null,"ancestor-frame","ancestor-frame",857790116);z4b=new $APP.q("emmy.calculus.covariant","symmetrize-Cartan","emmy.calculus.covariant/symmetrize-Cartan",-1243337097,null);A4b=new $APP.q(null,"variables-in","variables-in",-1894872826,null);
bY=new $APP.q("s","up?","s/up?",1718386486,null);B4b=new $APP.q(null,"column-matrix-\x3eup","column-matrix-\x3eup",-84333969,null);kH=new $APP.q(null,"sin","sin",1721439389,null);C4b=new $APP.q(null,"arctan?","arctan?",167558251,null);QQa=new $APP.E(null,"fns","fns",1185138786);GO=new $APP.E(null,"coordinate-system","coordinate-system",-1298347271);D4b=new $APP.q("cljs.core","Volatile","cljs.core/Volatile",-1098692185,null);
E4b=new $APP.q(null,"Lagrangian-\x3estate-derivative","Lagrangian-\x3estate-derivative",1286195816,null);F4b=new $APP.q(null,"expression-of","expression-of",1790811504,null);G4b=new $APP.q("emmy.mechanics.routhian","Routhian-\x3estate-derivative","emmy.mechanics.routhian/Routhian-\x3estate-derivative",-1454098679,null);H4b=new $APP.q("emmy.env","outer-product","emmy.env/outer-product",-668310695,null);I4b=new $APP.q("emmy.mechanics.hamilton","P","emmy.mechanics.hamilton/P",207000495,null);
J4b=new $APP.E(null,"lo","lo",-931799889);K4b=new $APP.q("emmy.structure","structure-\x3evector","emmy.structure/structure-\x3evector",-1553255508,null);L4b=new $APP.E(null,"catches","catches",-1478797617);M4b=new $APP.q(null,"symbol-generator","symbol-generator",-2079948609,null);N4b=new $APP.q("emmy.env","pushforward-function","emmy.env/pushforward-function",2083395271,null);O4b=new $APP.q(null,"L-central-polar","L-central-polar",-454329389,null);lOa=new $APP.E(null,"if","if",-458814265);
P4b=new $APP.q("emmy.env","up?","emmy.env/up?",684599062,null);cY=new $APP.q(null,"info?","info?",2002457080,null);ZQa=new $APP.E(null,"unsynchronized-mutable","unsynchronized-mutable",-164143950);Q4b=new $APP.E(null,"in","in",-1531184865);R4b=new $APP.q("emmy.simplify.rules","complex-trig","emmy.simplify.rules/complex-trig",-1420552587,null);S4b=new $APP.q("emmy.env","-\x3eH-state","emmy.env/-\x3eH-state",-402598880,null);
T4b=new $APP.q("emmy.util.permute","permutation-interchanges","emmy.util.permute/permutation-interchanges",1491483874,null);$APP.qE=new $APP.E(null,"js","js",1768080579);dY=new $APP.q(null,"complex","complex",-1238824944,null);U4b=new $APP.q("emmy.mechanics.hamilton","F-\x3eK","emmy.mechanics.hamilton/F-\x3eK",-1290116723,null);V4b=new $APP.q(null,"bottom-up","bottom-up",-2111255600,null);W4b=new $APP.q("emmy.pattern.syntax","variable-name","emmy.pattern.syntax/variable-name",533204310,null);
X4b=new $APP.q("emmy.simplify.rules","universal-reductions","emmy.simplify.rules/universal-reductions",418703513,null);Y4b=new $APP.q("emmy.matrix","row*","emmy.matrix/row*",-2066319758,null);VE=new $APP.E(null,"protocols","protocols",-5615896);Z4b=new $APP.q("emmy.simplify.rules","exp-expand","emmy.simplify.rules/exp-expand",-1011480890,null);$4b=new $APP.q(null,"modified-bulirsch-stoer","modified-bulirsch-stoer",1854691701,null);
a5b=new $APP.q(null,"coordinate-system-\x3eorthonormal-vector-basis","coordinate-system-\x3eorthonormal-vector-basis",1168548313,null);b5b=new $APP.q(null,"drop-leading-term","drop-leading-term",-203911633,null);c5b=new $APP.E(null,"xa","xa",-251918777);d5b=new $APP.E(null,"xb","xb",-1641297359);qK=new $APP.q(null,"?op","?op",-135731883,null);e5b=new $APP.E(null,"relative-threshold","relative-threshold",-1866138970);eY=new $APP.q(null,"thunk","thunk",74255732,null);
f5b=new $APP.q("emmy.matrix","row?","emmy.matrix/row?",911532509,null);fY=new $APP.q(null,"simplify?","simplify?",1719480016,null);g5b=new $APP.E("cljs.analyzer","type","cljs.analyzer/type",478749742);gY=new $APP.q(null,"inner-orientation","inner-orientation",911755630,null);RWb=new $APP.q("emmy.calculus.manifold","make-manifold-family","emmy.calculus.manifold/make-manifold-family",-778835266,null);JE=new $APP.E(null,"shadow","shadow",873231803);
i5b=new $APP.q("emmy.calculus.metric","trace2down","emmy.calculus.metric/trace2down",1647409792,null);j5b=new $APP.E(null,"boole","boole",-148416687);k5b=new $APP.q("emmy.dual","dual?","emmy.dual/dual?",-894708927,null);l5b=new $APP.q(null,"horner-with-error","horner-with-error",-233784998,null);m5b=new $APP.q("emmy.generic","cross-product","emmy.generic/cross-product",-86703562,null);n5b=new $APP.q(null,"sicm-signature","sicm-signature",-432435845,null);
o5b=new $APP.q(null,"emmy.abstract.number","emmy.abstract.number",71713944,null);p5b=new $APP.q("emmy.abstract.function","-\x3eFunction","emmy.abstract.function/-\x3eFunction",405361520,null);q5b=new $APP.q(null,"J-func","J-func",1541898649,null);Iab=new $APP.E(null,"vc","vc",194349650);gK=new $APP.q(null,"?s1","?s1",-1174751069,null);r5b=new $APP.q("emmy.env","S2-tilted","emmy.env/S2-tilted",-212419551,null);U4a=new $APP.E(null,"vector-basis","vector-basis",-869960088);
s5b=new $APP.q(null,"cos-series","cos-series",1863186724,null);t5b=new $APP.q(null,"emmy.numerical.quadrature","emmy.numerical.quadrature",1468850284,null);y4a=new $APP.q("cljs.core","chunkIteratorSeq","cljs.core/chunkIteratorSeq",74875524,null);u5b=new $APP.E(null,"cblocks","cblocks",-1769978138);hY=new $APP.q(null,"?re","?re",118270068,null);v5b=new $APP.q(null,"pattern-\x3ecombinators","pattern-\x3ecombinators",2073187402,null);
w5b=new $APP.q("emmy.generic","log2","emmy.generic/log2",1299455634,null);x5b=new $APP.q("emmy.rational-function","evaluate","emmy.rational-function/evaluate",-1598465215,null);iY=new $APP.q(null,"gensym-fn","gensym-fn",757045695,null);y5b=new $APP.q(null,"round","round",-645002441,null);OOa=new $APP.E(null,"js-module-index","js-module-index",2072061931);z5b=new $APP.q("emmy.calculus.manifold","S3-stereographic","emmy.calculus.manifold/S3-stereographic",-249386586,null);
ZVa=new $APP.E(null,"middleware-fn","middleware-fn",-61585752);A5b=new $APP.q(null,"Poisson-bracket","Poisson-bracket",-79662190,null);B5b=new $APP.q(null,"symmetrize-Christoffel","symmetrize-Christoffel",-1388254507,null);C5b=new $APP.q("emmy.util","unsupported","emmy.util/unsupported",311764091,null);D5b=new $APP.E(null,"minutes","minutes",1319166394);lPa=new $APP.E("cljs.analyzer","externs","cljs.analyzer/externs",893359239);
E5b=new $APP.q(null,"linear-interpolants","linear-interpolants",-117737654,null);F5b=new $APP.q("emmy.mechanics.rigid","Euler-\x3eomega","emmy.mechanics.rigid/Euler-\x3eomega",-535954388,null);jY=new $APP.q(null,"ceiling","ceiling",-1593475279,null);G5b=new $APP.q("emmy.value","\x3d","emmy.value/\x3d",1401841144,null);H5b=new $APP.q("emmy.env","p-\x3er","emmy.env/p-\x3er",-1597723383,null);I5b=new $APP.E(null,"deps","deps",1883360319);J5b=new $APP.q(null,"folds","folds",1449129970,null);
K5b=new $APP.q(null,"vector-\x3eup","vector-\x3eup",1833229019,null);L5b=new $APP.q("emmy.numerical.ode","make-integrator","emmy.numerical.ode/make-integrator",-665599475,null);WE=new $APP.q("cljs.core","Object","cljs.core/Object",-345545431,null);M5b=new $APP.q("emmy.series","asinh-series","emmy.series/asinh-series",-749269107,null);N5b=new $APP.q(null,"iterated-map","iterated-map",-1443897207,null);O5b=new $APP.q(null,"lower-arity","lower-arity",37018640,null);
P5b=new $APP.q("emmy.calculus.vector-calculus","curl","emmy.calculus.vector-calculus/curl",-467591349,null);Q5b=new $APP.q(null,"make-zero","make-zero",-1008366341,null);R5b=new $APP.q(null,"coordinate-system?","coordinate-system?",-697018728,null);S5b=new $APP.q(null,"bigint?","bigint?",-1865894876,null);T5b=new $APP.q(null,"manifold?","manifold?",-57809116,null);$J=new $APP.q(null,"?x4","?x4",94899597,null);YJ=new $APP.q(null,"?x2","?x2",1502785613,null);
TWb=new $APP.q("emmy.calculus.manifold","manifold-point-representation","emmy.calculus.manifold/manifold-point-representation",10786532,null);V5b=new $APP.q("emmy.mechanics.lagrange","state-\x3eqddot","emmy.mechanics.lagrange/state-\x3eqddot",450232944,null);W5b=new $APP.q("emmy.env","v:c","emmy.env/v:c",153262841,null);X5b=new $APP.q("emmy.calculus.vector-field","evolution","emmy.calculus.vector-field/evolution",-616873570,null);
Y5b=new $APP.q("emmy.dual","compare-full","emmy.dual/compare-full",1584170050,null);TYa=new $APP.q(null,"?y2","?y2",731715171,null);Z5b=new $APP.q("Math","ceil","Math/ceil",-186204017,null);SYa=new $APP.q(null,"?y1","?y1",1237029156,null);$5b=new $APP.q(null,"emmy.quaternion","emmy.quaternion",1427904557,null);a6b=new $APP.q(null,"coordinatize","coordinatize",-1986275097,null);kY=new $APP.q(null,"patterns","patterns",-1490353745,null);
b6b=new $APP.q("emmy.env","rotate-y-matrix","emmy.env/rotate-y-matrix",720342002,null);M8a=new $APP.E(null,"accelerate?","accelerate?",-29657518);c6b=new $APP.q("emmy.operator","-\x3eOperator","emmy.operator/-\x3eOperator",-1080554350,null);d6b=new $APP.q("emmy.env","S2p-spherical","emmy.env/S2p-spherical",534101091,null);e6b=new $APP.q(null,"exception","exception",1305254463,null);f6b=new $APP.E(null,"min-version","min-version",-1697197126);
g6b=new $APP.q("emmy.env","coordinate-system-\x3evector-basis","emmy.env/coordinate-system-\x3evector-basis",-849429161,null);h6b=new $APP.q(null,"emmy.algebra.fold","emmy.algebra.fold",-459207822,null);i6b=new $APP.q("emmy.quaternion","invert","emmy.quaternion/invert",1851875614,null);j6b=new $APP.q(null,"classical-adjoint-formula","classical-adjoint-formula",-471551995,null);lY=new $APP.q("a","monotonic-symbol-generator","a/monotonic-symbol-generator",1030677375,null);
k6b=new $APP.q("emmy.series","compose","emmy.series/compose",195899350,null);l6b=new $APP.q(null,"pattern*","pattern*",-294286221,null);m6b=new $APP.E(null,"recur","recur",-437573268);n6b=new $APP.q("emmy.util.aggregate","group","emmy.util.aggregate/group",1556218004,null);o6b=new $APP.q("emmy.env","partial","emmy.env/partial",763774669,null);p6b=new $APP.q("emmy.calculus.frame","event-\x3ecoords","emmy.calculus.frame/event-\x3ecoords",962323286,null);
q6b=new $APP.q(null,"owner","owner",1247919588,null);bRa=new $APP.q(null,"__extmap","__extmap",-1435580931,null);r6b=new $APP.q(null,"-\x3et_emmy$polynomial$factor49020","-\x3et_emmy$polynomial$factor49020",1740194804,null);s6b=new $APP.q("emmy.matrix","matrix-\x3evector","emmy.matrix/matrix-\x3evector",365660035,null);t6b=new $APP.q("emmy.generic","simplify","emmy.generic/simplify",1649699427,null);
t5a=new $APP.q(null,"vector-field-\x3evector-field-over-map","vector-field-\x3evector-field-over-map",969823025,null);u6b=new $APP.q("emmy.generic","quotient","emmy.generic/quotient",524483293,null);v6b=new $APP.q("emmy.env","Euler-angles","emmy.env/Euler-angles",2019373643,null);w6b=new $APP.q(null,"basis-unit","basis-unit",-1238004324,null);x6b=new $APP.q(null,"S1-gnomonic","S1-gnomonic",1277278711,null);y6b=new $APP.q(null,"modified-neville-fold","modified-neville-fold",1163820724,null);
z6b=new $APP.q("emmy.mechanics.rigid","quaternion-state-\x3eomega-space","emmy.mechanics.rigid/quaternion-state-\x3eomega-space",-2092144257,null);A6b=new $APP.q("emmy.numerical.unimin.brent","brent-max","emmy.numerical.unimin.brent/brent-max",997414695,null);B6b=new $APP.E(null,"expression-\x3e","expression-\x3e",1738204556);C6b=new $APP.q("emmy.rational-function.interpolate","modified-bulirsch-stoer-fold","emmy.rational-function.interpolate/modified-bulirsch-stoer-fold",824068631,null);
D6b=new $APP.q("emmy.quaternion","ONE-tensor","emmy.quaternion/ONE-tensor",-154616122,null);E6b=new $APP.q(null,"cosh-series","cosh-series",1737878103,null);F6b=new $APP.q("emmy.env","compose","emmy.env/compose",110695636,null);G6b=new $APP.q(null,"exact-divide","exact-divide",-836167490,null);H6b=new $APP.E("emmy.expression","abstract-matrix","emmy.expression/abstract-matrix",-842157179);I6b=new $APP.q("emmy.structure","literal-up","emmy.structure/literal-up",1068175229,null);
tQa=new $APP.E(null,"flag","flag",1088647881);J6b=new $APP.q("emmy.env","R3-cyl","emmy.env/R3-cyl",2115831730,null);K6b=new $APP.q("emmy.env","alt-wedge","emmy.env/alt-wedge",225882805,null);L6b=new $APP.q(null,"sym-\x3ef","sym-\x3ef",-671768860,null);M6b=new $APP.q("emmy.simplify.rules","canonicalize-partials","emmy.simplify.rules/canonicalize-partials",-442645,null);N6b=new $APP.q("emmy.mechanics.lagrange","Dt-procedure","emmy.mechanics.lagrange/Dt-procedure",357311615,null);
O6b=new $APP.q("emmy.mechanics.rigid","T-body-Euler","emmy.mechanics.rigid/T-body-Euler",-2078352517,null);P6b=new $APP.q("emmy.mechanics.hamilton","literal-Hamiltonian-state","emmy.mechanics.hamilton/literal-Hamiltonian-state",1319857380,null);w0a=new $APP.q(null,"root-out-squares","root-out-squares",-278750312,null);Q6b=new $APP.q(null,"linear-function-\x3emultiplier","linear-function-\x3emultiplier",-185354560,null);
R6b=new $APP.q("emmy.matrix","-\x3eMatrix","emmy.matrix/-\x3eMatrix",2061981237,null);S6b=new $APP.q("emmy.env","make-rectangular","emmy.env/make-rectangular",-481625545,null);T6b=new $APP.q("emmy.mechanics.lagrange","acceleration","emmy.mechanics.lagrange/acceleration",-1206049082,null);U6b=new $APP.q(null,"emmy.numsymb","emmy.numsymb",-1063329930,null);V6b=new $APP.q(null,"emmy.util.aggregate","emmy.util.aggregate",-615679461,null);
W6b=new $APP.q("emmy.env","find-path","emmy.env/find-path",961683438,null);X6b=new $APP.q("emmy.env","parallel-transport-equation","emmy.env/parallel-transport-equation",665642074,null);f7a=new $APP.E(null,"special-handlers","special-handlers",-582917928);Y6b=new $APP.q("emmy.calculus.manifold","R4-cyl","emmy.calculus.manifold/R4-cyl",1744537705,null);Z6b=new $APP.q("emmy.simplify.rules","simplify-square-roots","emmy.simplify.rules/simplify-square-roots",-743431262,null);
$6b=new $APP.q("emmy.structure","structure?","emmy.structure/structure?",1283227976,null);a7b=new $APP.q(null,"rectangular-\x3espherical","rectangular-\x3espherical",1020736763,null);b7b=new $APP.E(null,"private-var-access","private-var-access",967536101);mY=new $APP.q(null,"?x1","?x1",697080023,null);c7b=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer","emmy.rational-function.interpolate/bulirsch-stoer",1615277191,null);d7b=new $APP.q(null,"_if-false","_if-false",-353608572,null);
e7b=new $APP.q("emmy.pattern.match","and","emmy.pattern.match/and",1489121481,null);f7b=new $APP.q("emmy.env","Lie-derivative","emmy.env/Lie-derivative",-1767257328,null);nY=new $APP.q(null,"conjugate","conjugate",-1063123193,null);g7b=new $APP.q("emmy.polynomial","horner-with-error","emmy.polynomial/horner-with-error",-2120970616,null);oY=new $APP.q(null,"column?","column?",510745491,null);LJ=new $APP.q(null,"??fs1","??fs1",-1584583474,null);h7b=new $APP.q(null,"shift-t","shift-t",-681669434,null);
KJ=new $APP.q(null,"??fs3","??fs3",1216174751,null);IJ=new $APP.q(null,"??fs2","??fs2",1129791247,null);i7b=new $APP.E(null,"info?","info?",361925553);j7b=new $APP.q("emmy.env","geodesic-equation","emmy.env/geodesic-equation",-2102442369,null);pY=new $APP.E(null,"north-pole","north-pole",-1543616402);k7b=new $APP.q(null,"accelerations","accelerations",-1678530805,null);l7b=new $APP.q("emmy.polynomial.gcd","gcd-Dp","emmy.polynomial.gcd/gcd-Dp",-445086920,null);
m7b=new $APP.q("emmy.env","coordinate-basis?","emmy.env/coordinate-basis?",7762508,null);n7b=new $APP.q("emmy.sr.frames","base-frame-maker","emmy.sr.frames/base-frame-maker",1982767097,null);o7b=new $APP.q("emmy.quaternion","conjugate","emmy.quaternion/conjugate",-1866635233,null);p7b=new $APP.q(null,"column*","column*",1968036749,null);q7b=new $APP.q("emmy.env","Cartan-\x3ebasis","emmy.env/Cartan-\x3ebasis",1146663772,null);zPa=new $APP.q(null,"checked-aget'","checked-aget'",212330530,null);
qY=new $APP.E(null,"gnomonic","gnomonic",-1350375895);r7b=new $APP.q("emmy.matrix","row","emmy.matrix/row",-53588903,null);s7b=new $APP.q(null,"DHs","DHs",-78081496,null);t7b=new $APP.q(null,"unquote-splice?","unquote-splice?",1580318811,null);u7b=new $APP.q(null,"emmy.polynomial.impl","emmy.polynomial.impl",-1886265419,null);v7b=new $APP.q("emmy.polynomial","pseudo-remainder","emmy.polynomial/pseudo-remainder",308457853,null);b9a=new $APP.E(null,"infinite-breakpoint","infinite-breakpoint",1403428770);
w7b=new $APP.q("emmy.env","modulo","emmy.env/modulo",1755424269,null);x7b=new $APP.q(null,"S3-stereographic","S3-stereographic",731850624,null);y7b=new $APP.q("cljs.core","IComparable","cljs.core/IComparable",1166626940,null);z7b=new $APP.q("emmy.mechanics.lagrange","state-\x3en-dof","emmy.mechanics.lagrange/state-\x3en-dof",-862592928,null);A7b=new $APP.q(null,"complex-trig","complex-trig",1797292313,null);B7b=new $APP.q(null,"primal-tangent-pair","primal-tangent-pair",-514796111,null);
C7b=new $APP.q("emmy.quaternion","magnitude-sq","emmy.quaternion/magnitude-sq",-1616288467,null);D7b=new $APP.q("emmy.numsymb","operator","emmy.numsymb/operator",-1418543548,null);rY=new $APP.q(null,"source-coordsys","source-coordsys",1671917495,null);E7b=new $APP.q(null,"binomial-series","binomial-series",-1526523436,null);F7b=new $APP.q(null,"*exponent-product-simplify?*","*exponent-product-simplify?*",893369951,null);G7b=new $APP.E(null,"spacetime-spherical","spacetime-spherical",-751929014);
H7b=new $APP.q("emmy.pattern.rule","pipe","emmy.pattern.rule/pipe",88270244,null);I7b=new $APP.q("emmy.env","atanh","emmy.env/atanh",-928399829,null);bXb=new $APP.q(null,"check-coordinates","check-coordinates",-511993179,null);Q5a=new $APP.q(null,"omega-prime-forms","omega-prime-forms",1304696268,null);K7b=new $APP.q("emmy.env","invert","emmy.env/invert",1891927217,null);L7b=new $APP.q("emmy.special.factorial","binomial-coefficient","emmy.special.factorial/binomial-coefficient",1002691827,null);
M7b=new $APP.q(null,"variable-name","variable-name",-2125665669,null);x7a=new $APP.E(null,"alpha","alpha",-1574982441);sY=new $APP.q(null,"orientation-inverse-matrix","orientation-inverse-matrix",1827755966,null);N7b=new $APP.q(null,"make-literal","make-literal",886054236,null);O7b=new $APP.q(null,"structure-\x3evector","structure-\x3evector",-530711689,null);P7b=new $APP.q("emmy.dual","REVERSE-EMPTY","emmy.dual/REVERSE-EMPTY",-852657380,null);Q7b=new $APP.q(null,"divide","divide",-545489112,null);
R7b=new $APP.q("emmy.special.elliptic","elliptic-k","emmy.special.elliptic/elliptic-k",89065331,null);S7b=new $APP.q("emmy.special.elliptic","elliptic-e","emmy.special.elliptic/elliptic-e",932398830,null);T7b=new $APP.q("emmy.special.elliptic","elliptic-f","emmy.special.elliptic/elliptic-f",1502517041,null);U7b=new $APP.q(null,"map-exponents","map-exponents",-1135861601,null);V7b=new $APP.q(null,"expts-\x3ecoef","expts-\x3ecoef",-214884486,null);yQa=new $APP.E(null,"fn-scope","fn-scope",-865664859);
W7b=new $APP.q("emmy.expression","evaluate","emmy.expression/evaluate",1514546874,null);X7b=new $APP.E(null,"days","days",-1394072564);Y7b=new $APP.q(null,"reverse-segment-name","reverse-segment-name",1073216529,null);Z7b=new $APP.q("emmy.mechanics.routhian","Routhian-\x3eacceleration","emmy.mechanics.routhian/Routhian-\x3eacceleration",2103893071,null);$7b=new $APP.q("emmy.mechanics.rigid","Euler-state-\x3eomega-body","emmy.mechanics.rigid/Euler-state-\x3eomega-body",-1189770823,null);
a8b=new $APP.q("emmy.calculus.derivative","D-reverse","emmy.calculus.derivative/D-reverse",-2016156522,null);b8b=new $APP.q("emmy.env","polar-canonical","emmy.env/polar-canonical",-520263971,null);tY=new $APP.q("cljs.core","IReduce","cljs.core/IReduce",-577837345,null);c8b=new $APP.q("emmy.function","coerce-to-fn","emmy.function/coerce-to-fn",1308144045,null);$APP.d8b=new $APP.q(null,"spherical","spherical",-2097688265,null);
e8b=new $APP.q("emmy.simplify.rules","complex-rules","emmy.simplify.rules/complex-rules",-1616667200,null);f8b=new $APP.q("emmy.mechanics.hamilton","flow-derivative","emmy.mechanics.hamilton/flow-derivative",1608980401,null);uY=new $APP.q("cljs.core","ISequential","cljs.core/ISequential",-950981796,null);g8b=new $APP.q(null,"base-frame-chart","base-frame-chart",1026208390,null);h8b=new $APP.q(null,"poly-\x3efactored-expression","poly-\x3efactored-expression",-158535444,null);
i8b=new $APP.q("emmy.util.def","update-some","emmy.util.def/update-some",-1331757873,null);vY=new $APP.q(null,"dissipation-fn","dissipation-fn",1979250288,null);j8b=new $APP.q("emmy.env","coordinate-system?","emmy.env/coordinate-system?",-1815474643,null);P7a=new $APP.E(null,"arg-tolerance","arg-tolerance",1681183780);$APP.wY=new $APP.q(null,"size","size",-1555742762,null);k8b=new $APP.q(null,"origin","origin",-1617063681,null);
l8b=new $APP.q("emmy.calculus.form-field","Alt","emmy.calculus.form-field/Alt",1336710836,null);m8b=new $APP.q("emmy.calculus.basis","make-constant-vector-field","emmy.calculus.basis/make-constant-vector-field",961663073,null);n8b=new $APP.q("emmy.calculus.manifold","manifold-point?","emmy.calculus.manifold/manifold-point?",1306028620,null);a3b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57470","-\x3et_emmy$calculus$manifold57470",31198106,null);
p8b=new $APP.q("emmy.matrix","up-\x3ecolumn-matrix","emmy.matrix/up-\x3ecolumn-matrix",-1444074745,null);q8b=new $APP.q("emmy.operator","identity","emmy.operator/identity",2060804,null);r8b=new $APP.q("emmy.structure","down*","emmy.structure/down*",-275012676,null);s8b=new $APP.q("emmy.calculus.metric","raise","emmy.calculus.metric/raise",1429662218,null);t8b=new $APP.E(null,"msg-fn","msg-fn",-1873033940);
u8b=new $APP.q("emmy.env","metric-\x3eChristoffel-1","emmy.env/metric-\x3eChristoffel-1",-1305606788,null);v8b=new $APP.q("emmy.env","metric-\x3eChristoffel-2","emmy.env/metric-\x3eChristoffel-2",-447528048,null);w8b=new $APP.q(null,"literal-vector-field","literal-vector-field",1681711331,null);x8b=new $APP.q(null,"cramers-rule","cramers-rule",-1785048704,null);y8b=new $APP.q("cljs.core","double?","cljs.core/double?",1757455529,null);z8b=new $APP.q(null,"without","without",-1547399081,null);
xY=new $APP.q(null,"square?","square?",-1270504145,null);A8b=new $APP.q("emmy.generic","sqrt","emmy.generic/sqrt",-1009239123,null);h5b=new $APP.q(null,"coords-\x3epoint","coords-\x3epoint",-1467945699,null);C8b=new $APP.q(null,"torsion","torsion",492861929,null);D8b=new $APP.q("emmy.env","R2-polar","emmy.env/R2-polar",1561231069,null);E8b=new $APP.q(null,"series:sum","series:sum",-1714640975,null);F8b=new $APP.q(null,"matrix-\x3eH-state","matrix-\x3eH-state",1619175641,null);
G8b=new $APP.q(null,"vector-field-\x3ebasis-components","vector-field-\x3ebasis-components",-247472946,null);H8b=new $APP.q("emmy.pattern.rule","trace","emmy.pattern.rule/trace",-262557148,null);I8b=new $APP.q(null,"emmy.util.stream","emmy.util.stream",1561123960,null);J8b=new $APP.q("emmy.env","acsc","emmy.env/acsc",-24092233,null);K8b=new $APP.q(null,"universal-reductions","universal-reductions",1476944709,null);
U5b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57486","-\x3et_emmy$calculus$manifold57486",718264839,null);M8b=new $APP.q(null,"number-of-combinations","number-of-combinations",-1363476619,null);yY=new $APP.q(null,"shifts","shifts",-704758268,null);N8b=new $APP.E(null,"unsigned?","unsigned?",-502764154);O8b=new $APP.q("emmy.structure","down?","emmy.structure/down?",67554565,null);P8b=new $APP.E(null,"fblock","fblock",-1236607426);
fF=new $APP.E("cljs.analyzer","analyzed","cljs.analyzer/analyzed",-735094162);J7b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57475","-\x3et_emmy$calculus$manifold57475",1446046810,null);R8b=new $APP.q("emmy.pattern.rule","failed?","emmy.pattern.rule/failed?",-795759401,null);S8b=new $APP.q(null,"neville-scan","neville-scan",-738395933,null);xPa=new $APP.q(null,"checked-aget","checked-aget",950823006,null);
T8b=new $APP.q(null,"Lagrangian-\x3eacceleration","Lagrangian-\x3eacceleration",345497709,null);dSa=new $APP.E(null,"macroexpansion","macroexpansion",706274075);U8b=new $APP.q("emmy.matrix","make-diagonal","emmy.matrix/make-diagonal",187096326,null);TVa=new $APP.E(null,"rate-limit","rate-limit",1748082022);V8b=new $APP.E(null,"export","export",214356590);$Qa=new $APP.E(null,"defrecord","defrecord",-1367493418);kVa=new $APP.E(null,"min-level","min-level",1634684919);
W8b=new $APP.q("emmy.dual","tag","emmy.dual/tag",666261038,null);X8b=new $APP.q(null,"central-difference-d2","central-difference-d2",403360240,null);Y8b=new $APP.q("emmy.env","acot","emmy.env/acot",-2045740340,null);Z8b=new $APP.q("emmy.env","acos","emmy.env/acos",1454596988,null);$8b=new $APP.q(null,"o-\x3esyms","o-\x3esyms",-25830305,null);nVa=new $APP.E(null,"ns-blacklist","ns-blacklist",1957763142);RN=new $APP.q(null,"UP*","UP*",294235991,null);
LRa=new $APP.E(null,"deprecation-nowarn","deprecation-nowarn",-1762828044);a9b=new $APP.q(null,"env","env",-175281708,null);b9b=new $APP.q("emmy.mechanics.rigid","T-body","emmy.mechanics.rigid/T-body",-713675446,null);o8b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57497","-\x3et_emmy$calculus$manifold57497",1092991406,null);y2a=new $APP.q(null,"DOWN*","DOWN*",1300864675,null);d9b=new $APP.q(null,"L-space-Euler","L-space-Euler",-1490948843,null);
uG=new $APP.q("emmy.complex","complex","emmy.complex/complex",754489658,null);e9b=new $APP.q("emmy.expression.render","*TeX-vertical-down-tuples*","emmy.expression.render/*TeX-vertical-down-tuples*",-1525401240,null);SVa=new $APP.E(null,"trace","trace",-1082747415);f9b=new $APP.q(null,"new-arity","new-arity",-1624480576,null);g9b=new $APP.q("emmy.mechanics.hamilton","Hamiltonian","emmy.mechanics.hamilton/Hamiltonian",-1725596596,null);h9b=new $APP.E(null,"dblock","dblock",-1325623381);
i9b=new $APP.q("emmy.generic","dot-product","emmy.generic/dot-product",-1004113231,null);j9b=new $APP.q(null,"compile-state-fn","compile-state-fn",-2216916,null);k9b=new $APP.q(null,"ICanonicalize","ICanonicalize",-1572005940,null);l9b=new $APP.q("emmy.util.permute","list-interchanges","emmy.util.permute/list-interchanges",-824277049,null);m9b=new $APP.q("emmy.generic","csch","emmy.generic/csch",-410694894,null);n9b=new $APP.q("emmy.modint","-\x3eModInt","emmy.modint/-\x3eModInt",1202662049,null);
o9b=new $APP.q("emmy.mechanics.lagrange","p-\x3er","emmy.mechanics.lagrange/p-\x3er",-871117546,null);p9b=new $APP.q(null,"F-tilde","F-tilde",996598782,null);q9b=new $APP.q("emmy.numerical.unimin.golden","golden-section-min","emmy.numerical.unimin.golden/golden-section-min",601364146,null);r9b=new $APP.q("emmy.calculus.hodge-star","Gram-Schmidt","emmy.calculus.hodge-star/Gram-Schmidt",1956616544,null);
s9b=new $APP.q("emmy.calculus.indexed","indexed-\x3etyped","emmy.calculus.indexed/indexed-\x3etyped",533604105,null);t9b=new $APP.q("emmy.polynomial","arity","emmy.polynomial/arity",-1518834610,null);u9b=new $APP.q("emmy.rational-function","sub","emmy.rational-function/sub",-253444189,null);v9b=new $APP.q(null,"L-state-\x3eH-state","L-state-\x3eH-state",-46880312,null);w9b=new $APP.q("emmy.mechanics.rigid","T-quaternion-state","emmy.mechanics.rigid/T-quaternion-state",193580823,null);
x9b=new $APP.q(null,"-\x3eMatrix","-\x3eMatrix",635711640,null);y9b=new $APP.q("emmy.function","compose","emmy.function/compose",389171445,null);z9b=new $APP.q("emmy.series","log1+x-series","emmy.series/log1+x-series",-756965640,null);A9b=new $APP.q("emmy.generic","expt","emmy.generic/expt",-1429583700,null);B9b=new $APP.q(null,"basis-on-M","basis-on-M",1714569456,null);C9b=new $APP.q(null,"kahan","kahan",-1458265841,null);D9b=new $APP.q("emmy.env","divergence","emmy.env/divergence",1223453163,null);
E9b=new $APP.q("emmy.simplify.rules","commutative","emmy.simplify.rules/commutative",991285212,null);F9b=new $APP.q("emmy.calculus.connection","literal-Christoffel-1","emmy.calculus.connection/literal-Christoffel-1",-255341526,null);G9b=new $APP.q("emmy.calculus.connection","literal-Christoffel-2","emmy.calculus.connection/literal-Christoffel-2",-1619286076,null);H9b=new $APP.q("emmy.generic","remainder","emmy.generic/remainder",-1930884158,null);I9b=new $APP.q(null,"f-form","f-form",309693281,null);
J9b=new $APP.q("emmy.polynomial.gcd","trivial-gcd","emmy.polynomial.gcd/trivial-gcd",256546410,null);K9b=new $APP.q(null,"two-particle-center-of-mass","two-particle-center-of-mass",-171051168,null);L9b=new $APP.q(null,"counted","counted",1189969060,null);zY=new $APP.q(null,"high","high",-627137961,null);M9b=new $APP.E(null,"native","native",-613060878);N9b=new $APP.q("emmy.complex","ZERO","emmy.complex/ZERO",-432695973,null);
O9b=new $APP.q("emmy.expression","literal-type","emmy.expression/literal-type",-1957201608,null);P9b=new $APP.q("emmy.expression.render","-\x3eJavaScript","emmy.expression.render/-\x3eJavaScript",-1057115132,null);TRa=new $APP.E(null,"const-expr","const-expr",-1379382292);Q9b=new $APP.E("emmy.expression","vector","emmy.expression/vector",-1823391456);R9b=new $APP.E(null,"catch","catch",1038065524);S9b=new $APP.q("emmy.structure","vector-\x3edown","emmy.structure/vector-\x3edown",1649641827,null);
T9b=new $APP.q("emmy.mechanics.rigid","three-vector-components-\x3eantisymmetric","emmy.mechanics.rigid/three-vector-components-\x3eantisymmetric",-1412059008,null);U9b=new $APP.q(null,"partial-forward","partial-forward",755260127,null);V9b=new $APP.q(null,"embedding","embedding",-2043869411,null);W9b=new $APP.q("emmy.calculus.metric","sharpen","emmy.calculus.metric/sharpen",1476241581,null);X9b=new $APP.q("emmy.simplify.rules","associative","emmy.simplify.rules/associative",2104123948,null);
Y9b=new $APP.q("cljs.core","qualified-symbol?","cljs.core/qualified-symbol?",1570873476,null);Z9b=new $APP.q("cljs.core","delay?","cljs.core/delay?",2099859324,null);$9b=new $APP.q(null,"permutation-interchanges","permutation-interchanges",1436643038,null);a$b=new $APP.q("emmy.mechanics.hamilton","Lagrangian-\x3eHamiltonian","emmy.mechanics.hamilton/Lagrangian-\x3eHamiltonian",1995549950,null);b$b=new $APP.q("emmy.dual","extract-id","emmy.dual/extract-id",841639758,null);
$APP.AY=new $APP.q(null,"dimension","dimension",-2111181571,null);c$b=new $APP.q(null,"compile-skeleton","compile-skeleton",-668513117,null);d$b=new $APP.q(null,"coordinate-system-at","coordinate-system-at",-933140671,null);e$b=new $APP.q(null,"infix-sym-\x3eunicode","infix-sym-\x3eunicode",721754064,null);BY=new $APP.q(null,"vars","vars",-406425690,null);f$b=new $APP.q("emmy.pattern.syntax","segment?","emmy.pattern.syntax/segment?",1005334251,null);
g$b=new $APP.q("emmy.calculus.manifold","chart","emmy.calculus.manifold/chart",-588054402,null);CY=new $APP.q(null,"angle","angle",-1032341515,null);h$b=new $APP.q("emmy.env","S3-spherical","emmy.env/S3-spherical",625231346,null);i$b=new $APP.q("emmy.generic","exp2","emmy.generic/exp2",389925301,null);j$b=new $APP.q("emmy.calculus.manifold","point","emmy.calculus.manifold/point",342112725,null);qSa=new $APP.q("cljs.core","ISet","cljs.core/ISet",2003412810,null);
k$b=new $APP.q(null,"identity-like","identity-like",1541985180,null);DY=new $APP.q(null,"manifold-point?","manifold-point?",-1801722474,null);bF=new $APP.E(null,"property","property",-1114278232);l$b=new $APP.q("emmy.ratio","denominator","emmy.ratio/denominator",571780366,null);m$b=new $APP.q("emmy.mechanics.time-evolution","C-\x3eCp","emmy.mechanics.time-evolution/C-\x3eCp",-21551299,null);
n$b=new $APP.q("emmy.mechanics.hamilton","matrix-\x3eH-state","emmy.mechanics.hamilton/matrix-\x3eH-state",697183236,null);o$b=new $APP.q("emmy.polynomial","normalize","emmy.polynomial/normalize",12681494,null);p$b=new $APP.q(null,"Complex","Complex",1443317787,null);q$b=new $APP.q("emmy.matrix","m-\x3es","emmy.matrix/m-\x3es",398995012,null);r$b=new $APP.q("emmy.expression.render","infix-sym-\x3eunicode","emmy.expression.render/infix-sym-\x3eunicode",-1067313886,null);
s$b=new $APP.q("emmy.mechanics.hamilton","symplectic-matrix?","emmy.mechanics.hamilton/symplectic-matrix?",-909030147,null);t$b=new $APP.q("emmy.env","real-part","emmy.env/real-part",1259206742,null);K3a=new $APP.E("emmy.calculus.manifold","manifold-function","emmy.calculus.manifold/manifold-function",-1023992517);u$b=new $APP.q("emmy.pattern.syntax","unquote?","emmy.pattern.syntax/unquote?",-246759071,null);
v$b=new $APP.q("emmy.simplify.rules","*divide-numbers-through-simplify?*","emmy.simplify.rules/*divide-numbers-through-simplify?*",1355588149,null);wJ=new $APP.q(null,"??xs","??xs",-2083850977,null);aF=new $APP.E(null,"infer-warning","infer-warning",-1600671410);w$b=new $APP.q("emmy.calculus.manifold","transfer-point","emmy.calculus.manifold/transfer-point",-348435014,null);x$b=new $APP.q(null,"multichoose","multichoose",337768353,null);
y$b=new $APP.q("emmy.modint","modint?","emmy.modint/modint?",863521491,null);EY=new $APP.q(null,"??y1","??y1",-1969315695,null);FY=new $APP.q(null,"??y2","??y2",-796250797,null);z$b=new $APP.q("cljs.core","flatten","cljs.core/flatten",-237795822,null);A$b=new $APP.q("Math","sqrt","Math/sqrt",377394374,null);B$b=new $APP.q("emmy.quaternion","mul","emmy.quaternion/mul",2091367217,null);C$b=new $APP.q("cljs.core","keyword?","cljs.core/keyword?",713156450,null);
D$b=new $APP.q(null,"one?","one?",1787102903,null);E$b=new $APP.q("emmy.mechanics.hamilton","F-\x3eCH","emmy.mechanics.hamilton/F-\x3eCH",1105336723,null);GY=new $APP.E("emmy.value","native-integral","emmy.value/native-integral",-1286161061);nQ=new $APP.E(null,"result","result",1415092211);F$b=new $APP.q(null,"emmy.numerical.ode","emmy.numerical.ode",-66413745,null);wH=new $APP.q(null,"sinh","sinh",-990423302,null);XJ=new $APP.q(null,"??x1","??x1",-1923305193,null);
dK=new $APP.q(null,"??x2","??x2",169445330,null);ZJ=new $APP.q(null,"??x3","??x3",-411077265,null);G$b=new $APP.q("emmy.quaternion","I","emmy.quaternion/I",1052597922,null);H$b=new $APP.q("emmy.mechanics.hamilton","F-\x3eCT","emmy.mechanics.hamilton/F-\x3eCT",-1699667269,null);I$b=new $APP.q(null,"wcross-\x3ew","wcross-\x3ew",-80334599,null);aK=new $APP.q(null,"??x5","??x5",1822045235,null);J$b=new $APP.q("emmy.quaternion","K","emmy.quaternion/K",-1309915252,null);
$APP.HY=new $APP.q(null,"label","label",-936024965,null);K$b=new $APP.q("emmy.quaternion","J","emmy.quaternion/J",1692883003,null);L$b=new $APP.q(null,"until","until",451365137,null);M$b=new $APP.q(null,"S2-stereographic","S2-stereographic",-100853268,null);N$b=new $APP.q(null,"scalar?","scalar?",1570438077,null);O$b=new $APP.q(null,"sinc","sinc",60189925,null);P$b=new $APP.q("emmy.calculus.frame","event?","emmy.calculus.frame/event?",1150652264,null);
Q$b=new $APP.q("emmy.env","remainder","emmy.env/remainder",-444421652,null);R$b=new $APP.q(null,"spherical-\x3erectangular","spherical-\x3erectangular",1409390107,null);S$b=new $APP.q("Math","cos","Math/cos",-1454544429,null);T$b=new $APP.q(null,"by-rows*","by-rows*",1156495609,null);U$b=new $APP.E(null,"closed","closed",-919675359);V$b=new $APP.E(null,"multiple-variadic-overloads","multiple-variadic-overloads",1110059837);W$b=new $APP.q(null,"exp-expand","exp-expand",-2082275726,null);
X$b=new $APP.q("emmy.pattern.syntax","splice-reduce","emmy.pattern.syntax/splice-reduce",913308744,null);Y$b=new $APP.q("emmy.util.permute","multichoose","emmy.util.permute/multichoose",317111693,null);Z$b=new $APP.q("emmy.env","atan","emmy.env/atan",-1674162468,null);$$b=new $APP.q("emmy.calculus.metric","coordinate-system-\x3emetric","emmy.calculus.metric/coordinate-system-\x3emetric",2092059672,null);aac=new $APP.q(null,"bigint","bigint",-70405490,null);
bac=new $APP.q("emmy.calculus.basis","make-basis","emmy.calculus.basis/make-basis",1068287334,null);cac=new $APP.q(null,"succeed","succeed",207632095,null);dac=new $APP.q("emmy.sr.boost","general-boost2","emmy.sr.boost/general-boost2",1615930831,null);eac=new $APP.q(null,"R2-rect","R2-rect",1642598370,null);fac=new $APP.q(null,"s:invert","s:invert",-889536282,null);gac=new $APP.q(null,"Routhian-\x3estate-derivative","Routhian-\x3estate-derivative",1713797386,null);
hac=new $APP.q("cljs.core","qualified-keyword?","cljs.core/qualified-keyword?",-308091478,null);iac=new $APP.E(null,"numerical?","numerical?",-1353720934);jac=new $APP.q("emmy.env","rationalize","emmy.env/rationalize",-1345779476,null);kac=new $APP.q("emmy.util","double","emmy.util/double",-2015033650,null);IY=new $APP.q(null,"generic-params?","generic-params?",-1736124942,null);lac=new $APP.E(null,"closed-open","closed-open",-1821164567);
mac=new $APP.q("emmy.special.factorial","factorial-power","emmy.special.factorial/factorial-power",-976374300,null);nac=new $APP.q(null,"e_j","e_j",-204646387,null);oac=new $APP.q(null,"e_i","e_i",-907547744,null);pac=new $APP.q(null,"??zs","??zs",1863806627,null);qac=new $APP.q("emmy.env","gcd","emmy.env/gcd",-1538065038,null);rac=new $APP.q("cljs.core","Reduced","cljs.core/Reduced",971663396,null);sac=new $APP.q("emmy.pattern.match","sequence","emmy.pattern.match/sequence",-603330194,null);
tac=new $APP.q(null,"e_k","e_k",-1989044598,null);uac=new $APP.q("emmy.calculus.covariant","make-Christoffel","emmy.calculus.covariant/make-Christoffel",-992163038,null);rM=new $APP.q(null,"non-negative?","non-negative?",1248641804,null);vac=new $APP.q("emmy.matrix","transpose","emmy.matrix/transpose",-1736760748,null);wac=new $APP.q("emmy.mechanics.hamilton","Legendre-transform","emmy.mechanics.hamilton/Legendre-transform",-846467344,null);
xac=new $APP.q(null,"four-matrix","four-matrix",2083177250,null);yac=new $APP.q(null,"seq:pprint","seq:pprint",-160078278,null);SJ=new $APP.q(null,"??ys","??ys",1180811471,null);zac=new $APP.q(null,"make-event","make-event",-855573915,null);Aac=new $APP.q(null,"full-gcd","full-gcd",-1142748438,null);Bac=new $APP.q(null,"integrate-state-derivative","integrate-state-derivative",1154163041,null);Cac=new $APP.E(null,"error-fn","error-fn",-171437615);
Dac=new $APP.q("emmy.polynomial","arg-shift","emmy.polynomial/arg-shift",984324003,null);Eac=new $APP.q(null,"expression-\x3estream","expression-\x3estream",1834298297,null);mQa=new $APP.q(null,"cljs.user","cljs.user",877795071,null);Fac=new $APP.q("emmy.calculus.covariant","interior-product","emmy.calculus.covariant/interior-product",-677203764,null);Gac=new $APP.q("emmy.env","power-series","emmy.env/power-series",-1738248017,null);Hac=new $APP.q("g","zero?","g/zero?",325758938,null);
Iac=new $APP.q("emmy.mechanics.lagrange","Lagrange-equations-1","emmy.mechanics.lagrange/Lagrange-equations-1",-276843753,null);Jac=new $APP.q("emmy.numsymb","sum?","emmy.numsymb/sum?",160859848,null);Kac=new $APP.q("emmy.env","commutator","emmy.env/commutator",2017279100,null);$APP.Lac=new $APP.q(null,"normalize","normalize",-263858524,null);Mac=new $APP.q("emmy.util.permute","cartesian-product","emmy.util.permute/cartesian-product",1119553197,null);
R7a=new $APP.E(null,"fn-counter","fn-counter",-1395388762);Nac=new $APP.E(null,"non-dynamic-earmuffed-var","non-dynamic-earmuffed-var",-202005643);Oac=new $APP.q("emmy.pattern.match","reverse-segment","emmy.pattern.match/reverse-segment",-1629158578,null);Pac=new $APP.q(null,"Lagrangian-state-\x3eRouthian-state","Lagrangian-state-\x3eRouthian-state",1611386074,null);Qac=new $APP.q("emmy.env","trace2down","emmy.env/trace2down",-1369714327,null);
Rac=new $APP.q("emmy.calculus.coordinate","quotify-coordinate-prototype","emmy.calculus.coordinate/quotify-coordinate-prototype",-289125452,null);Sac=new $APP.q("emmy.simplify.rules","miscsimp","emmy.simplify.rules/miscsimp",1212725056,null);Tac=new $APP.E(null,"def-emits-var","def-emits-var",-1551927320);Uac=new $APP.q(null,"richardson-sequence","richardson-sequence",1960734964,null);Vac=new $APP.q(null,"lowcol","lowcol",-1417324880,null);
Wac=new $APP.q("emmy.matrix","s:invert","emmy.matrix/s:invert",234858361,null);Xac=new $APP.q(null,"TapeCell","TapeCell",-1115833436,null);Yac=new $APP.q(null,"sincos-flush-ones","sincos-flush-ones",227136733,null);B8b=new $APP.E(null,"uuid","uuid",-2145095719);$ac=new $APP.q(null,"set-js-meta!","set-js-meta!",-540544347,null);abc=new $APP.q(null,"make-integrator","make-integrator",1359161389,null);JY=new $APP.q(null,"div","div",-1597244137,null);
bbc=new $APP.q("emmy.mechanics.rotation","Rx","emmy.mechanics.rotation/Rx",541610072,null);cbc=new $APP.q(null,"emmy.abstract.function","emmy.abstract.function",-1169683343,null);dbc=new $APP.q("emmy.env","i:contract","emmy.env/i:contract",-464699005,null);ebc=new $APP.q(null,"function-\x3eoneform-field","function-\x3eoneform-field",596015058,null);fbc=new $APP.q(null,"IArity","IArity",-158622163,null);gbc=new $APP.q("emmy.env","asin","emmy.env/asin",-1754119131,null);
hbc=new $APP.q("emmy.matrix","determinant","emmy.matrix/determinant",-1872172177,null);ibc=new $APP.q("emmy.mechanics.rotation","Ry","emmy.mechanics.rotation/Ry",-152294631,null);jbc=new $APP.q("emmy.mechanics.rotation","Rz","emmy.mechanics.rotation/Rz",1137068167,null);kbc=new $APP.q(null,"dense-coefficients","dense-coefficients",-384887247,null);lbc=new $APP.q(null,"rational-function?","rational-function?",-545892330,null);mbc=new $APP.q("emmy.polynomial","mul","emmy.polynomial/mul",472422219,null);
nbc=new $APP.q("emmy.pattern.match","or","emmy.pattern.match/or",-1428347965,null);obc=new $APP.q(null,"cljs","cljs",-1162018140,null);pbc=new $APP.E(null,"invalid-array-access","invalid-array-access",-1747132236);qbc=new $APP.q("emmy.matrix","by-rows*","emmy.matrix/by-rows*",166732610,null);rbc=new $APP.q(null,"emmy.polynomial.factor","emmy.polynomial.factor",-654922990,null);sbc=new $APP.q("emmy.generic","lcm","emmy.generic/lcm",1332899931,null);
tbc=new $APP.q("emmy.calculus.form-field","nform-field?","emmy.calculus.form-field/nform-field?",2101256690,null);ubc=new $APP.q("emmy.env","coords-\x3eevent","emmy.env/coords-\x3eevent",-392340088,null);vbc=new $APP.q("emmy.mechanics.lagrange","Qdotdot","emmy.mechanics.lagrange/Qdotdot",-203746645,null);wbc=new $APP.q("emmy.matrix","two-tensor-operation","emmy.matrix/two-tensor-operation",-154084714,null);xbc=new $APP.q("emmy.polynomial","make","emmy.polynomial/make",-978068300,null);
r3a=new $APP.E(null,"manifold","manifold",-1940328209);ybc=new $APP.q("emmy.special.factorial","multi-factorial","emmy.special.factorial/multi-factorial",-1161369505,null);L8b=new $APP.q(null,"coordinate-system-ctor","coordinate-system-ctor",301188674,null);Abc=new $APP.q("emmy.quaternion","from-complex","emmy.quaternion/from-complex",340768920,null);Bbc=new $APP.q("emmy.sr.frames","make-SR-coordinates","emmy.sr.frames/make-SR-coordinates",701443321,null);
Cbc=new $APP.q("emmy.env","S2-metric","emmy.env/S2-metric",-2062952604,null);Dbc=new $APP.q("emmy.pattern.match","sequence*","emmy.pattern.match/sequence*",584918258,null);Ebc=new $APP.q(null,"scale-l","scale-l",33154067,null);Fbc=new $APP.q("emmy.polynomial.gcd","lcm","emmy.polynomial.gcd/lcm",-1011771964,null);Gbc=new $APP.q("emmy.quaternion","log","emmy.quaternion/log",-761068821,null);KY=new $APP.q(null,"the-rule","the-rule",58807572,null);
Hbc=new $APP.q("emmy.expression.analyze","known-operation?","emmy.expression.analyze/known-operation?",102835086,null);OVa=new $APP.E(null,"iso8601","iso8601",609352650);Ibc=new $APP.q(null,"pass","pass",-1080275776,null);Jbc=new $APP.q(null,"compile-pattern","compile-pattern",424625475,null);Kbc=new $APP.q(null,"literal-Christoffel-1","literal-Christoffel-1",2054549682,null);Lbc=new $APP.q(null,"literal-Christoffel-2","literal-Christoffel-2",632148524,null);
Mbc=new $APP.q(null,"Cartan-\x3eChristoffel","Cartan-\x3eChristoffel",-466028067,null);Nbc=new $APP.q("emmy.env","asec","emmy.env/asec",-1132449064,null);Obc=new $APP.q("emmy.abstract.number","literal-number","emmy.abstract.number/literal-number",1151999273,null);Pbc=new $APP.q("emmy.calculus.connection","metric-\x3eChristoffel-1","emmy.calculus.connection/metric-\x3eChristoffel-1",-346132889,null);
Qbc=new $APP.q("emmy.calculus.vector-calculus","coordinate-system-\x3eorthonormal-vector-basis","emmy.calculus.vector-calculus/coordinate-system-\x3eorthonormal-vector-basis",-1404078301,null);Rbc=new $APP.q("emmy.calculus.connection","metric-\x3eChristoffel-2","emmy.calculus.connection/metric-\x3eChristoffel-2",1011000965,null);Sbc=new $APP.q("emmy.structure","map-chain","emmy.structure/map-chain",1328036341,null);
Tbc=new $APP.q("emmy.matrix","literal-row-matrix","emmy.matrix/literal-row-matrix",123782868,null);Ubc=new $APP.q("emmy.env","component","emmy.env/component",-48202874,null);Vbc=new $APP.q(null,"extract-id","extract-id",13462904,null);Wbc=new $APP.q(null,"emmy.sr.frames","emmy.sr.frames",1823371956,null);Xbc=new $APP.q("Math","tan","Math/tan",-1378236364,null);Ybc=new $APP.q(null,"pairs","pairs",-2039825990,null);Zbc=new $APP.q("cljs.core","string?","cljs.core/string?",-2072921719,null);
$$a=new $APP.E(null,"central","central",467059073);$bc=new $APP.q("emmy.generic","log","emmy.generic/log",-647758938,null);I5a=new $APP.E(null,"symbols","symbols",1211743);acc=new $APP.q(null,"parse-complex","parse-complex",941088514,null);bcc=new $APP.q("emmy.generic","solve-linear","emmy.generic/solve-linear",-1065954809,null);nSa=new $APP.q("cljs.core","IList","cljs.core/IList",1015168964,null);ccc=new $APP.q("emmy.pattern.match","all-results","emmy.pattern.match/all-results",1753481397,null);
dcc=new $APP.q("emmy.pattern.match","eq","emmy.pattern.match/eq",2043848955,null);ecc=new $APP.q(null,"*sqrt-expt-simplify?*","*sqrt-expt-simplify?*",-352822736,null);fcc=new $APP.q(null,"evolution","evolution",-1709615212,null);gcc=new $APP.q(null,"valid-modes","valid-modes",-813432109,null);hcc=new $APP.q("emmy.rational-function.interpolate","modified-bulirsch-stoer-scan","emmy.rational-function.interpolate/modified-bulirsch-stoer-scan",1730821408,null);
icc=new $APP.E(null,"left-riemann","left-riemann",-330641680);jcc=new $APP.q("emmy.env","acosh","emmy.env/acosh",1339324932,null);kcc=new $APP.q("emmy.env","differential-of-map","emmy.env/differential-of-map",939285474,null);lcc=new $APP.q("emmy.generic","make-polar","emmy.generic/make-polar",1111002320,null);mcc=new $APP.q(null,"base-frame-point","base-frame-point",908107138,null);wP=new $APP.q(null,"down","down",-1089190199,null);
ncc=new $APP.q("emmy.polynomial","partial-derivatives","emmy.polynomial/partial-derivatives",-650670957,null);occ=new $APP.q("emmy.env","euler","emmy.env/euler",-1346592994,null);pcc=new $APP.q("emmy.quaternion","K-matrix","emmy.quaternion/K-matrix",-2139117615,null);qcc=new $APP.q("emmy.env","acoth","emmy.env/acoth",572107844,null);EG=new $APP.E("emmy.value","integral","emmy.value/integral",-970970786);rcc=new $APP.q(null,"T-func","T-func",476643498,null);
scc=new $APP.q("emmy.env","literal-metric","emmy.env/literal-metric",1472684204,null);tcc=new $APP.q("emmy.env","chart","emmy.env/chart",-447426825,null);ucc=new $APP.q(null,"trailing-coefficient","trailing-coefficient",217002391,null);vcc=new $APP.q(null,"-\x3ePolynomial","-\x3ePolynomial",511280004,null);wcc=new $APP.q(null,"frame-params","frame-params",-951014115,null);xcc=new $APP.q(null,"top-down","top-down",-1237101201,null);ycc=new $APP.q("emmy.env","Div","emmy.env/Div",959379402,null);
zcc=new $APP.q("emmy.env","i:outer-product","emmy.env/i:outer-product",1436815015,null);Acc=new $APP.q("emmy.operator","commutator","emmy.operator/commutator",-119463125,null);Bcc=new $APP.q(null,"zero-like","zero-like",-895025247,null);LY=new $APP.q("emmy.value","IKind","emmy.value/IKind",-1473468716,null);Ccc=new $APP.q("emmy.quaternion","commutator","emmy.quaternion/commutator",1304432849,null);Dcc=new $APP.q(null,"cartan","cartan",1692318531,null);
Ecc=new $APP.q("emmy.env","literal-Lagrangian-state","emmy.env/literal-Lagrangian-state",1324063383,null);Fcc=new $APP.q("emmy.polynomial","leading-coefficient","emmy.polynomial/leading-coefficient",-432834753,null);Gcc=new $APP.q("emmy.expression.analyze","make-analyzer","emmy.expression.analyze/make-analyzer",-295571899,null);Hcc=new $APP.q(null,"bulirsch-stoer-recursive","bulirsch-stoer-recursive",1302097042,null);tUa=new $APP.E("rl","peek","rl/peek",-291391771);
Icc=new $APP.q("emmy.env","expression-\x3estream","emmy.env/expression-\x3estream",-1342794740,null);Jcc=new $APP.q("emmy.env","symmetrize-Cartan","emmy.env/symmetrize-Cartan",-2086446341,null);Kcc=new $APP.q("emmy.util","parse-int","emmy.util/parse-int",-1027318049,null);Lcc=new $APP.q(null,"up*","up*",1811123313,null);MY=new $APP.q(null,"up?","up?",1718386499,null);Mcc=new $APP.q("cljs.core","simple-keyword?","cljs.core/simple-keyword?",39474330,null);
Ncc=new $APP.q(null,"cross-product","cross-product",-823528331,null);Occ=new $APP.q(null,"skel","skel",-840013828,null);Pcc=new $APP.q(null,"emmy.sr.boost","emmy.sr.boost",1325352729,null);GVa=new $APP.E(null,"?err_","?err_",789480858);Qcc=new $APP.q("emmy.sr.frames","add-v:cs","emmy.sr.frames/add-v:cs",1860125053,null);b_a=new $APP.E(null,"orientations","orientations",146962442);Hab=new $APP.E(null,"boost-direction","boost-direction",-1975902118);
Rcc=new $APP.q("emmy.calculus.manifold","S2-type","emmy.calculus.manifold/S2-type",-187537129,null);Scc=new $APP.q("emmy.numerical.quadrature","definite-integral","emmy.numerical.quadrature/definite-integral",-1059883113,null);Tcc=new $APP.q(null,"exp-\x3esincos","exp-\x3esincos",-887623320,null);Ucc=new $APP.q(null,"valid-arity?","valid-arity?",233342812,null);Vcc=new $APP.q("emmy.quaternion","sinh","emmy.quaternion/sinh",-185436686,null);
Wcc=new $APP.q("emmy.env","frame-maker","emmy.env/frame-maker",387237479,null);X_a=new $APP.E(null,"started?","started?",-1301062863);Q8b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57506","-\x3et_emmy$calculus$manifold57506",-1291157644,null);Ycc=new $APP.q("emmy.polynomial","polynomial?","emmy.polynomial/polynomial?",1238725886,null);Zcc=new $APP.q("emmy.mechanics.rotation","wcross-\x3ew","emmy.mechanics.rotation/wcross-\x3ew",-2094852622,null);$APP.$cc=new $APP.E(null,"v","v",21465059);
$APP.ZP=new $APP.E(null,"r","r",-471384190);$APP.gRa=new $APP.E(null,"t","t",-1397832519);GD=new $APP.E(null,"libspecs","libspecs",59807195);BR=new $APP.E(null,"q","q",689001697);NY=new $APP.q(null,"v:c","v:c",1270894894,null);WG=new $APP.E(null,"p","p",151049309);adc=new $APP.q("emmy.calculus.manifold","S2p-tilted","emmy.calculus.manifold/S2p-tilted",-1979695782,null);bdc=new $APP.q(null,"kahan-babushka-neumaier","kahan-babushka-neumaier",-1310408534,null);
cdc=new $APP.q("emmy.env","imag-part","emmy.env/imag-part",-1123865539,null);ddc=new $APP.q(null,"meta48707","meta48707",-2107145454,null);edc=new $APP.q(null,"canonicalize-partials","canonicalize-partials",1040991839,null);YTa=new $APP.q(null,".abs",".abs",1832478636,null);fdc=new $APP.q("emmy.env","arg-scale","emmy.env/arg-scale",-1942276833,null);gdc=new $APP.q(null,"p-seq","p-seq",-1578923571,null);c9b=new $APP.E(null,"check-coordinates","check-coordinates",2142442590);
Y4a=new $APP.E("emmy.calculus.basis","basis","emmy.calculus.basis/basis",-1395050689);$P=new $APP.E(null,"l","l",1395893423);q7a=new $APP.E(null,"nonzero-delta","nonzero-delta",-794646863);idc=new $APP.q(null,"default-epsilon","default-epsilon",167984498,null);jdc=new $APP.q(null,"exp10","exp10",-1005012445,null);D7a=new $APP.E(null,"simplex-tolerance","simplex-tolerance",1524945145);kdc=new $APP.q("emmy.calculus.manifold","manifold-type","emmy.calculus.manifold/manifold-type",-32288893,null);
ldc=new $APP.q("emmy.polynomial","cube","emmy.polynomial/cube",-641467543,null);Zac=new $APP.q(null,"-\x3et_emmy$calculus$manifold57524","-\x3et_emmy$calculus$manifold57524",513416469,null);ndc=new $APP.q(null,"with-arity","with-arity",1915481989,null);odc=new $APP.q(null,"consequent-fn","consequent-fn",381611694,null);pdc=new $APP.q(null,"H-state-\x3eL-state","H-state-\x3eL-state",-455042562,null);
qdc=new $APP.q("emmy.mechanics.lagrange","-\x3elocal","emmy.mechanics.lagrange/-\x3elocal",615465306,null);i$a=new $APP.E(null,"M","M",-1755742206);zbc=new $APP.q(null,"-\x3et_emmy$calculus$manifold57516","-\x3et_emmy$calculus$manifold57516",-526538872,null);O9a=new $APP.E(null,"F","F",-1115543258);$APP.sdc=new $APP.q(null,"segment","segment",675610331,null);tdc=new $APP.q("emmy.structure","vector-inner-product","emmy.structure/vector-inner-product",1474392821,null);
udc=new $APP.q(null,"splice?","splice?",1977106547,null);vdc=new $APP.q("emmy.numerical.unimin.golden","golden-section-max","emmy.numerical.unimin.golden/golden-section-max",28195764,null);wdc=new $APP.q(null,"vector-field-\x3ecomponents","vector-field-\x3ecomponents",-1993765828,null);xdc=new $APP.q("cljs.core","*","cljs.core/*",-857794892,null);FG=new $APP.q("cljs.core","+","cljs.core/+",-342754435,null);
ydc=new $APP.q(null,"-\x3et_emmy$calculus$manifold57547","-\x3et_emmy$calculus$manifold57547",62156220,null);zdc=new $APP.q(null,"m:generate","m:generate",-746017331,null);Adc=new $APP.q("emmy.calculus.metric","lower","emmy.calculus.metric/lower",-1550311246,null);Bdc=new $APP.q(null,"anticommutator","anticommutator",369809372,null);Xcc=new $APP.q(null,"-\x3et_emmy$calculus$manifold57539","-\x3et_emmy$calculus$manifold57539",-718524437,null);
hdc=new $APP.q(null,"-\x3et_emmy$calculus$manifold57534","-\x3et_emmy$calculus$manifold57534",-318274502,null);NM=new $APP.q(null,"csc","csc",-427853492,null);Edc=new $APP.q("emmy.calculus.vector-calculus","Grad","emmy.calculus.vector-calculus/Grad",-1657004746,null);Fdc=new $APP.q("emmy.env","Euler-Lagrange-operator","emmy.env/Euler-Lagrange-operator",990394897,null);Gdc=new $APP.q("cljs.core","char?","cljs.core/char?",416405281,null);Hdc=new $APP.q(null,"inv-phi","inv-phi",-425271954,null);
Idc=new $APP.E(null,"case-then","case-then",2107591745);Jdc=new $APP.q("emmy.util.stream","seq-print","emmy.util.stream/seq-print",-1184485848,null);Kdc=new $APP.q("emmy.structure","up-of-downs?","emmy.structure/up-of-downs?",-38784916,null);Ldc=new $APP.q("emmy.matrix","cofactors","emmy.matrix/cofactors",533870010,null);Mdc=new $APP.q("emmy.calculus.covariant","Christoffel?","emmy.calculus.covariant/Christoffel?",-2022725499,null);ZTa=new $APP.q("js","Math","js/Math",2033291075,null);
Ndc=new $APP.E(null,"orthonormalize?","orthonormalize?",-11872752);Odc=new $APP.q(null,"factor","factor",-462641221,null);Pdc=new $APP.q("emmy.expression.compile","compile-state-fn","emmy.expression.compile/compile-state-fn",907497701,null);Qdc=new $APP.q("emmy.simplify.rules","contract-expt-trig","emmy.simplify.rules/contract-expt-trig",799206241,null);U6a=new $APP.E(null,"ppath","ppath",-1758182784);Rdc=new $APP.q(null,"literal-metric","literal-metric",-1799706791,null);
OY=new $APP.q(null,"default-absolute-threshold","default-absolute-threshold",986519052,null);Sdc=new $APP.q("emmy.series","acot-series","emmy.series/acot-series",-1503167911,null);Tdc=new $APP.q(null,"Routhian","Routhian",-451266995,null);Udc=new $APP.q(null,"lagrange","lagrange",1990996687,null);KE=new $APP.E(null,"protocol-impl","protocol-impl",2101328365);Vdc=new $APP.q("emmy.calculus.covariant","covariant-differential","emmy.calculus.covariant/covariant-differential",299230560,null);
Wdc=new $APP.q("emmy.env","-\x3eTeX","emmy.env/-\x3eTeX",-1847038738,null);Xdc=new $APP.q("Math","atanh","Math/atanh",-1910277884,null);PY=new $APP.q(null,"initial-guess","initial-guess",-242610878,null);Ydc=new $APP.q("emmy.polynomial.interpolate","neville-fold","emmy.polynomial.interpolate/neville-fold",-630269823,null);Zdc=new $APP.q("emmy.env","-\x3estate","emmy.env/-\x3estate",-674926849,null);
$dc=new $APP.q("emmy.mechanics.hamilton","multiplicative-transpose","emmy.mechanics.hamilton/multiplicative-transpose",-1614087805,null);aec=new $APP.q("emmy.structure","transpose-outer","emmy.structure/transpose-outer",-812532823,null);bec=new $APP.q("emmy.calculus.covariant","Cartan-\x3eChristoffel","emmy.calculus.covariant/Cartan-\x3eChristoffel",388236940,null);cec=new $APP.q(null,"!\x3d\x3e","!\x3d\x3e",527534792,null);
dec=new $APP.q(null,"embedding-map-\x3emetric-components","embedding-map-\x3emetric-components",-1000114547,null);eec=new $APP.q("emmy.calculus.basis","contract","emmy.calculus.basis/contract",804023804,null);fec=new $APP.q("emmy.generic","atanh","emmy.generic/atanh",-779953135,null);gec=new $APP.q("emmy.numerical.ode","stream-integrator","emmy.numerical.ode/stream-integrator",-1398101800,null);hec=new $APP.q(null,"*sin-cos-simplify?*","*sin-cos-simplify?*",-187838922,null);
iec=new $APP.q(null,"matrix?","matrix?",1297778417,null);jec=new $APP.q("cljs.core","/","cljs.core//",-696756880,null);QY=new $APP.q("emmy.util","bigint","emmy.util/bigint",-894648022,null);kec=new $APP.q("emmy.env","basis?","emmy.env/basis?",189457469,null);O6a=new $APP.E("zip","branch?","zip/branch?",-998880862);lec=new $APP.q("emmy.pattern.rule","failure","emmy.pattern.rule/failure",1057133778,null);mec=new $APP.q("emmy.env","row-matrix","emmy.env/row-matrix",-892177403,null);
nec=new $APP.E(null,"goog-define","goog-define",-1048305441);oec=new $APP.E(null,"nodejs-rt","nodejs-rt",-512437071);pec=new $APP.q("emmy.algebra.fold","kbk-n","emmy.algebra.fold/kbk-n",-1261394355,null);RY=new $APP.q(null,"qdot","qdot",-754984603,null);qec=new $APP.q(null,"L-Kepler-polar","L-Kepler-polar",-1377249844,null);rec=new $APP.q("emmy.polynomial","constant","emmy.polynomial/constant",-1683198938,null);sec=new $APP.q("emmy.matrix","by-rows","emmy.matrix/by-rows",537461417,null);
tec=new $APP.q(null,"v1:c","v1:c",-1611587706,null);uec=new $APP.q(null,"coordinate-system-\x3emetric","coordinate-system-\x3emetric",2009542622,null);vec=new $APP.q(null,"L-uniform-acceleration","L-uniform-acceleration",-369576403,null);wec=new $APP.q("emmy.env","point","emmy.env/point",45740882,null);xec=new $APP.q("emmy.mechanics.rigid","M-\x3eomega-body","emmy.mechanics.rigid/M-\x3eomega-body",-1138673574,null);yec=new $APP.q("emmy.env","anticommutator","emmy.env/anticommutator",1424531377,null);
zec=new $APP.q("emmy.mechanics.hamilton","H-state-\x3ematrix","emmy.mechanics.hamilton/H-state-\x3ematrix",-131131554,null);Aec=new $APP.E(null,"invalid-arity","invalid-arity",1335461949);Bec=new $APP.q(null,"three-vector","three-vector",-512585855,null);Cec=new $APP.q("emmy.calculus.form-field","form-field?","emmy.calculus.form-field/form-field?",-990940063,null);Dec=new $APP.q("emmy.mechanics.hamilton","qp-canonical?","emmy.mechanics.hamilton/qp-canonical?",1748483215,null);
SY=new $APP.q(null,"values","values",2013177083,null);Eec=new $APP.q("emmy.calculus.vector-field","vector-field?","emmy.calculus.vector-field/vector-field?",2010073622,null);Fec=new $APP.q("emmy.series","value","emmy.series/value",-1131696377,null);ND=new $APP.E(null,"locals","locals",535295783);var cM={},U_a={},TY=function TY(a){switch(arguments.length){case 1:return TY.j(arguments[0]);case 2:return TY.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};TY.j=function(a){return TY.A(a,0)};TY.A=function(a,b){var c=$APP.kh.j(b);return new $APP.H(null,2,5,$APP.I,[c,function(d){$APP.lh.A(c,$APP.Lc);return a.j?a.j(d):a.call(null,d)}],null)};TY.G=2;var Gec=Math.sqrt,UY=Math.pow,kQ=Math.abs,Hec=BigInt,MR;
a:for(var Iec=1;;){if($APP.Uc.A(1,Iec+1)){MR=2*Iec;break a}Iec/=2}var HR=Math.sqrt(MR);var VY,VPa,UPa;$APP.HEa={};VPa=new $APP.ug(null,new $APP.f(null,2,[$APP.Xx,"null",$APP.wv,"null"],null),null);UPa=new $APP.ug(null,new $APP.f(null,2,[WPa,"null",$APP.HAa,"null"],null),null);var jOa=new $APP.ug(null,new $APP.f(null,9,[$APP.qE,null,tRa,null,$APP.Kw,null,$APP.Ek,null,$APP.Mk,null,PRa,null,sE,null,uRa,null,$APP.zl,null],null),null);$APP.z($APP.vg,new $APP.f(null,1,[j1b,$APP.sf],null));var rF=null,CE=!1;$APP.kh.j(!1);
var aE=$APP.fg([ORa,PYb,otb,r4b,KPa,Mnb,xib,b7b,$Xb,Flb,l1b,hF,aF,ZSb,FJb,MRa,JOa,yEb,lIb,snb,Ifb,$APP.gm,pbc,gTb,TE,aPa,Nac,Qkb,DRa,Wob,PE,HNb,uGb,QQb,h2b,fQb,P3b,V$b,e4b],[!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!1,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0]),Jec=new $APP.ug(null,new $APP.f(null,63,["typeof",null,"float",null,"implements",null,"else",null,"boolean",null,"abstract",null,"int",null,"static",null,"package",null,"this",null,"await",null,"yield",null,"interface",
null,"void",null,"delete",null,"class",null,"export",null,"var",null,"try",null,"long",null,"null",null,"return",null,"methods",null,"native",null,"private",null,"new",null,"for",null,"catch",null,"extends",null,"short",null,"protected",null,"throws",null,"synchronized",null,"transient",null,"super",null,"if",null,"let",null,"import",null,"char",null,"switch",null,"const",null,"case",null,"break",null,"volatile",null,"function",null,"continue",null,"final",null,"do",null,"double",null,"while",null,
"public",null,"arguments",null,"debugger",null,"with",null,"instanceof",null,"default",null,"throw",null,"goto",null,"finally",null,"byte",null,"constructor",null,"in",null,"enum",null],null),null),QD={},mF=function(){var a=$APP.kh.j($APP.F),b=$APP.kh.j($APP.F),c=$APP.kh.j($APP.F),d=$APP.kh.j($APP.F),g=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));return new $APP.Ch($APP.Zg.A("cljs.analyzer","error-message"),function(){function l(n,p){if(1<arguments.length)for(var v=0,t=Array(arguments.length-
1);v<t.length;)t[v]=arguments[v+1],++v;return n}l.G=1;l.K=function(n){var p=$APP.u(n);$APP.Fc(n);return p};l.C=function(n){return n};return l}(),$APP.xj,g,a,b,c,d)}();mF.F(null,lIb,function(a,b){return["Preamble resource file not found: ",$APP.Il.A(" ",ykb.j(b))].join("")});mF.F(null,gTb,function(a,b){return["Required namespace not provided for ",$APP.Il.A(" ",gTb.j(b))].join("")});
mF.F(null,JOa,function(a,b){return[$APP.k(KOa.j(b))?"Can't take value of macro ":"Use of undeclared Var ",$APP.m.j($APP.Av.j(b)),"/",$APP.m.j($APP.pq.j(b))].join("")});mF.F(null,b7b,function(a,b){return["var: ",$APP.m.j($APP.ix.j(b))," is not public"].join("")});
mF.F(null,aPa,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,bPa);b=$APP.C.A(b,cPa);return["No such namespace: ",$APP.m.j(a),", could not locate ",VD(a,$APP.Su),", ",VD(a,Pmb),', or JavaScript source providing "',$APP.m.j(b),'"',$APP.Tda(VD(a,$APP.Su),"_")?" (Please check that namespaces with dashes use underscores in the ClojureScript file name)":null].join("")});
mF.F(null,Gxb,function(a,b){a=$APP.qe(b);b=$APP.C.A(a,bPa);$APP.C.A(a,cPa);return["No such macros namespace: ",$APP.m.j(b),", could not locate ",VD(b,GG)," or ",VD(b,Pmb)].join("")});mF.F(null,$APP.gm,function(a,b){return[$APP.m.j($APP.R.j(b))," not declared ^:dynamic"].join("")});mF.F(null,r4b,function(a,b){return[$APP.m.j($APP.ix.j(b))," already refers to: ",$APP.m.j($APP.Zg.A($APP.m.j($APP.wl.j(b)),$APP.m.j($APP.ix.j(b))))," being replaced by: ",$APP.m.j($APP.Zg.A($APP.m.j(wX.j(b)),$APP.m.j($APP.ix.j(b))))].join("")});
mF.F(null,h2b,function(a,b){return[$APP.m.j($APP.ix.j(b))," at line ",$APP.m.j($APP.Xi.j(b))," is being replaced"].join("")});mF.F(null,PE,function(a,b){return[$APP.m.j($APP.Zg.A($APP.m.j(wX.j(b)),$APP.m.j($APP.ix.j(b))))," no longer fn, references are stale"].join("")});mF.F(null,hF,function(a,b){a=$APP.m.j(iF.j(b));var c=$APP.m,d=c.j,g=jPa.j(b);b=$APP.k(g)?g:$APP.R.j(b);return["Wrong number of args (",a,") passed to ",d.call(c,b)].join("")});
mF.F(null,MRa,function(a,b){return[$APP.m.j($APP.R.j($APP.Wu.j(NRa.j(b))))," is deprecated"].join("")});mF.F(null,yEb,function(a,b){return[$APP.m.j($APP.Zg.A($APP.m.j(wX.j(b)),$APP.m.j($APP.ix.j(b))))," declared arglists ",$APP.m.j($APP.Pu.j(b))," mismatch defined arglists ",$APP.m.j(VBb.j(b))].join("")});mF.F(null,Qkb,function(a,b){return["Invalid :refer, ",$APP.m.j($APP.Ti.j(b))," ",$APP.m.j($APP.zfa.j(b)),"/",$APP.m.j($APP.ix.j(b))," does not exist"].join("")});
mF.F(null,Wob,function(a,b){return["Protocol ",$APP.m.j($APP.Nm.j(b))," is deprecated"].join("")});mF.F(null,snb,function(a,b){return["Can't resolve protocol symbol ",$APP.m.j($APP.Nm.j(b))].join("")});mF.F(null,xib,function(a,b){return["Symbol ",$APP.m.j($APP.Nm.j(b))," is not a protocol"].join("")});
mF.F(null,fQb,function(a,b){return $APP.k(Cyb.j(b))?["Bad method signature in protocol implementation, ",$APP.m.j($APP.Nm.j(b))," does not declare method called ",$APP.m.j(bfb.j(b))].join(""):["Bad method signature in protocol implementation, ",$APP.m.j($APP.Nm.j(b))," ",$APP.m.j(bfb.j(b))," does not declare arity ",$APP.m.j(Aec.j(b))].join("")});mF.F(null,$Xb,function(a,b){return["Duplicated methods in protocol implementation ",$APP.m.j($APP.Nm.j(b))," ",$APP.m.j(bfb.j(b))].join("")});
mF.F(null,QQb,function(a,b){return["Protocol ",$APP.m.j($APP.Nm.j(b))," implemented multiple times"].join("")});mF.F(null,FJb,function(a,b){return["Protocol ",$APP.m.j($APP.Nm.j(b))," declares method ",$APP.m.j($APP.R.j(b))," with variadic signature (\x26)"].join("")});mF.F(null,Ifb,function(a,b){a=$APP.Nm.j(DOb.j(b));return["Protocol ",$APP.m.j($APP.Nm.j(b))," is overwriting ",$APP.k(a)?"method":"function"," ",$APP.m.j($APP.R.j(b)),$APP.k(a)?[" of protocol ",$APP.Ag(a)].join(""):null].join("")});
mF.F(null,e4b,function(a,b){return["Protocol ",$APP.m.j($APP.Nm.j(b))," implements method ",$APP.m.j($APP.R.j(b))," with variadic signature (\x26)"].join("")});mF.F(null,HNb,function(a,b){return['Ignoring target object "',$APP.jh.C($APP.y([$APP.Nw.j(b)])),'" passed in recur to protocol method head'].join("")});mF.F(null,V$b,function(a,b){return[$APP.m.j($APP.R.j(b)),": Can't have more than 1 variadic overload"].join("")});mF.F(null,ZSb,function(a,b){return[$APP.m.j($APP.R.j(b)),": Can't have fixed arity function with more params than variadic function"].join("")});
mF.F(null,uGb,function(a,b){return[$APP.m.j($APP.R.j(b)),": Can't have 2 overloads with same arity"].join("")});mF.F(null,PYb,function(a,b){return["Extending an existing JavaScript type - use a different symbol name instead of ",$APP.m.j(Sxb.j(b))," e.g ",$APP.m.j(Upb.j(b))].join("")});mF.F(null,DRa,function(a,b){return[$APP.m.j(dF.j(b)),", all arguments must be numbers, got ",$APP.m.j(CRa.j(b))," instead"].join("")});
mF.F(null,pbc,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,$APP.R);b=$APP.C.A(b,CRa);if($APP.Uc.A(Zeb,a)||$APP.Uc.A(N3b,a))return["cljs.core/aget, arguments must be an array followed by numeric indices, got ",$APP.m.j(b)," instead",$APP.Uc.A($APP.ay,$APP.u(b))||$APP.Ge(new $APP.ug(null,new $APP.f(null,1,[$APP.Fy,null],null),null),$APP.Fc(b))?[" (consider ",2===$APP.Tc(b)?"goog.object/get":"goog.object/getValueByKeys"," for object access)"].join(""):null].join("");if($APP.Uc.A(mXb,a)||$APP.Uc.A(ebb,a))return["cljs.core/aset, arguments must be an array, followed by numeric indices, followed by a value, got ",
$APP.m.j(b)," instead",$APP.Uc.A($APP.ay,$APP.u(b))||$APP.Ge(new $APP.ug(null,new $APP.f(null,1,[$APP.Fy,null],null),null),$APP.zg($APP.Fc(b)))?" (consider goog.object/set for object access)":null].join("");throw Error(["No matching clause: ",$APP.m.j(a)].join(""));});mF.F(null,ORa,function(a,b){return["Cannot invoke type constructor ",$APP.m.j($APP.R.j($APP.Wu.j(NRa.j(b))))," as function "].join("")});mF.F(null,l1b,function(a,b){return[$APP.m.j($APP.R.j(b))," is a single segment namespace"].join("")});
mF.F(null,Flb,function(a,b){a=$APP.qe(b);a=$APP.C.A(a,$APP.R);b=$APP.hi($APP.Il.A(".",$APP.Vg.A(function(c){return $APP.k(Jec.j?Jec.j(c):Jec.call(null,c))?[$APP.m.j(c),"$"].join(""):c},$APP.qi.A($APP.Ag(a),/\./))));return["Namespace ",$APP.m.j(a)," contains a reserved JavaScript keyword, the corresponding Google Closure namespace will be munged to ",$APP.m.j(b)].join("")});
mF.F(null,TE,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,$APP.wl);b=$APP.C.A(b,$APP.Ek);return["Namespace ",$APP.m.j(a)," clashes with var ",$APP.m.j(b)].join("")});mF.F(null,Nac,function(a,b){a=$APP.qe(b);a=$APP.C.A(a,$APP.Ek);return[$APP.m.j(a)," not declared dynamic and thus is not dynamically rebindable, but its name suggests otherwise. Please either indicate ^:dynamic ",$APP.m.j(a)," or change the name"].join("")});
mF.F(null,P3b,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,$APP.Nm);b=$APP.C.A(b,$APP.ky);return["Bad extend-type method shape for protocol ",$APP.m.j(a)," method ",$APP.m.j(b),", method arities must be grouped together"].join("")});mF.F(null,Mnb,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,Gkb);b=$APP.C.A(b,$APP.Wi);return["Unsupported JavaScript module type ",$APP.m.j(a)," for foreign library ",$APP.m.j(b),"."].join("")});
mF.F(null,otb,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,tpb);b=$APP.C.A(b,$APP.Wi);return["Unsupported preprocess value ",$APP.m.j(a)," for foreign library ",$APP.m.j(b),"."].join("")});mF.F(null,KPa,function(a,b){a=$APP.qe(b);a=$APP.C.A(a,$APP.R);return[$APP.m.j(a)," is shadowed by a local"].join("")});
mF.F(null,aF,function(a,b){var c=$APP.qe(b),d=$APP.C.A(c,rRa);a=$APP.C.A(c,$APP.Nw);b=$APP.C.A(c,$APP.Ti);c=$APP.C.A(c,bF);d=d instanceof $APP.E?d.ga:null;switch(d){case "target":return["Cannot infer target type in expression ",$APP.m.j(a),""].join("");case "property":return["Cannot resolve property ",$APP.m.j(c)," for inferred type ",$APP.m.j(b)," in expression ",$APP.m.j(a)].join("");case "object":return["Adding extern to Object for property ",$APP.m.j(c)," due to ambiguous expression ",$APP.m.j(a)].join("");
default:throw Error(["No matching clause: ",$APP.m.j(d)].join(""));}});
var yOa=new $APP.H(null,1,5,$APP.I,[function(a,b,c){if($APP.k(a.j?a.j(aE):a.call(null,aE)))if(a=mF.A(a,c),$APP.k(a)){c=$APP.ab;$APP.ab=$APP.yaa;try{var d=$APP.Wt.C,g=["WARNING: ",$APP.m.j(a)].join("");var l=xOa.A?xOa.A(b,g):xOa.call(null,b,g);return d.call($APP.Wt,$APP.y([l]))}finally{$APP.ab=c}}else return null;else return null}],null),Kec=new $APP.f(null,2,[$APP.yn,new $APP.f(null,1,[$APP.R,$APP.yn],null),mQa,new $APP.f(null,1,[$APP.R,mQa],null)],null);
if("undefined"===typeof $APP.se||"undefined"===typeof $APP.HEa||"undefined"===typeof VY)VY=function(a){this.mk=a;this.O=425984;this.U=0},VY.prototype.da=function(a,b){return new VY(b)},VY.prototype.ba=function(){return this.mk},VY.prototype.Wa=function(){return Kec},VY.cb=!0,VY.Ya="cljs.analyzer/t_cljs$analyzer35099",VY.gb=function(a){return $APP.Vb(a,"cljs.analyzer/t_cljs$analyzer35099")};new VY($APP.F);
var $Oa=new $APP.ug(null,new $APP.f(null,6,[WVb,"null",BRb,"null",DBb,"null",$APP.Cza,"null",$APP.Xw,"null",fCb,"null"],null),null),NOa=$APP.mh(function(a,b){return $APP.Bd($APP.Lf.B($APP.vg,$APP.bf.j(function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return new $APP.H(null,2,5,$APP.I,[d,$APP.R.j(c)],null)}),a),$APP.m.j(b))}),fE=function fE(a){switch(arguments.length){case 3:return fE.B(arguments[0],arguments[1],arguments[2]);case 4:return fE.M(arguments[0],arguments[1],arguments[2],arguments[3]);
default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};fE.B=function(a,b,c){return fE.M(a,b,c,LOa())};
fE.M=function(a,b,c,d){var g=$APP.m.j(c);c=".."!==g&&/\./.test(g)?$APP.u($APP.qi.A(g,/\./)):c;c=$APP.Zg.j(c);(g=$APP.Bd($Oa,b))||($APP.k(RD($APP.Fb(null),TD,b))?g=null:(g=$APP.wl.j(a),g=null!=$APP.C.A($APP.ak.j(g),b)||null!=$APP.C.A($APP.sm.j(g),b)),g=g||$APP.Uc.A($APP.yn,b)&&$APP.Uc.A($APP.qxa,c)||null!=UD($APP.Fb(null),b,jE,c)||!$APP.eb(eE(b)));return g?null:d.B?d.B(a,b,c):d.call(null,a,b,c)};fE.G=4;
var WY=function WY(a){switch(arguments.length){case 0:return WY.J();case 1:return WY.j(arguments[0]);case 2:return WY.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return WY.C(arguments[0],arguments[1],c)}};WY.J=function(){return $APP.gy};WY.j=function(a){return a};WY.A=function(a,b){return null==a||null==b?$APP.gy:hPa($APP.jz.A(DD(a)?a:$APP.wg([a]),DD(b)?b:$APP.wg([b])))};
WY.C=function(a,b,c){return $APP.Je.B(WY,WY.A(a,b),c)};WY.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};WY.G=2;
var qPa=new $APP.f(null,7,[$APP.ay,$APP.Gx,$APP.Fy,WVb,$APP.Yu,nPa,$APP.Px,$APP.TMb,$APP.gx,iPa,$APP.wv,ehb,$APP.kza,rlb],null),xE=function(){var a=$APP.kh.j($APP.F),b=$APP.kh.j($APP.F),c=$APP.kh.j($APP.F),d=$APP.kh.j($APP.F),g=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));return new $APP.Ch($APP.Zg.A("cljs.analyzer","resolve*"),function(l,n,p){return FPa(p)},$APP.xj,g,a,b,c,d)}();
xE.F(null,$APP.qE,function(a,b,c){return new $APP.f(null,3,[$APP.R,$APP.Zg.A($APP.m.j(c),$APP.Ag(b)),$APP.$x,sE,$APP.wl,c],null)});
xE.F(null,DPa,function(a,b,c,d){a=PD();a=$APP.Uc.A(WRb,YE.j(a))&&!1===oec.j(a);return $APP.k(a)?(a=HPa(b,d),new $APP.f(null,5,[$APP.wl,d,$APP.R,$APP.Zg.A($APP.m.j(d),[sPa(c),".",$APP.Ag(b)].join("")),$APP.$x,sE,$APP.sj,$APP.z($APP.Zw,new $APP.f(null,1,[$APP.Av,a],null)),sMb,!0],null)):new $APP.f(null,4,[$APP.wl,d,$APP.R,$APP.Zg.A($APP.m.j(d),[sPa(c),".",$APP.Ag(b)].join("")),$APP.$x,sE,sMb,!0],null)});
xE.F(null,CPa,function(a,b,c,d){return new $APP.f(null,3,[$APP.R,$APP.Zg.A($APP.m.j(d),[tPa(c),".",$APP.Ag(b)].join("")),$APP.wl,d,$APP.$x,$APP.Ek],null)});xE.F(null,EPa,function(a,b,c,d){a=HPa(b,d);return new $APP.f(null,5,[$APP.wl,d,$APP.R,$APP.Zg.A($APP.m.j(d),[uPa(c),".",$APP.Ag(b)].join("")),$APP.$x,sE,$APP.sj,$APP.z($APP.Zw,new $APP.f(null,1,[$APP.Av,a],null)),sMb,!0],null)});var Lec=new $APP.ug(null,new $APP.f(null,4,[ebb,"null",N3b,"null",Zeb,"null",mXb,"null"],null),null);
xE.F(null,$APP.xj,function(a,b,c,d){var g=UD($APP.Fb(null),c,jE,$APP.Zg.j($APP.Ag(b)));b=$APP.Zg.A($APP.m.j(c),$APP.Ag(b));if(d=$APP.qg.A(d,c))d=$APP.Lo.j(g),d=$APP.k(d)?$APP.eb(CE)&&!$APP.Bd(Lec,b):d;$APP.k(d)&&$D(b7b,a,new $APP.f(null,1,[$APP.ix,b],null));return $APP.Ni.C($APP.y([g,new $APP.f(null,3,[$APP.R,b,$APP.$x,$APP.Ek,$APP.wl,c],null)]))});
var cQa=new $APP.ug(null,new $APP.f(null,22,[$APP.Lh,"null",$APP.Mh,"null",$APP.sda,"null",$APP.Nh,"null",$APP.tda,"null",$APP.Ph,"null",$APP.Qh,"null",$APP.uda,"null",$APP.Rh,"null",$APP.Sh,"null",$APP.Th,"null",$APP.vda,"null",$APP.Uh,"null",$APP.Wh,"null",$APP.Xh,"null",$APP.Yh,"null",$APP.Zh,"null",$APP.$h,"null",$APP.ai,"null",$APP.K,"null",$APP.ci,"null",$APP.di,"null"],null),null),LE=null,OE=$APP.Ec,XY=!1,YY=!0,FE=function FE(a,b){var d=$APP.sj.j($APP.ed($APP.Nw.j(b)));null==d&&(d=$APP.sj.j(b),
d=null==d?$APP.sj.j($APP.Wu.j(b)):d);if(null==d)switch(d=$APP.$x.j(b),d instanceof $APP.E?d.ga:null){case "recur":return TPa;case "throw":return TPa;case "let":return b=$APP.em.j(b),FE.A?FE.A(a,b):FE.call(null,a,b);case "loop":return b=$APP.em.j(b),FE.A?FE.A(a,b):FE.call(null,a,b);case "do":return b=MD.j(b),FE.A?FE.A(a,b):FE.call(null,a,b);case "fn-method":return b=$APP.em.j(b),FE.A?FE.A(a,b):FE.call(null,a,b);case "def":return b=LD.j(b),FE.A?FE.A(a,b):FE.call(null,a,b);case "invoke":return d=$APP.qe(b),
b=$APP.C.A(d,$APP.Fk),d=$APP.C.A(d,$APP.Wj),d=$APP.rg.B(OPa(b,d),$APP.$x,uQa),a=FE.A?FE.A(a,d):FE.call(null,a,d),null==a&&(a=$APP.qe(b),b=$APP.C.A(a,$APP.Wu),a=$APP.k(PE.j(b))?wE.j(b):$APP.k(LPa.j(b))?wE.j(b):$APP.Uc.A(sE,$APP.$x.j($APP.Wu.j(a)))?$APP.Zw:$APP.Uc.A($APP.Zw,$APP.wl.j(b))?$APP.Zw:null,a=null==a?$APP.gy:a),a;case "if":return XPa(a,b);case "const":return a=$APP.Nw.j(b),$APP.Uc.A(!0,a)?$APP.wv:$APP.Uc.A(!1,a)?$APP.wv:$APP.gy;case "quote":return b=$APP.Bk.j(b),FE.A?FE.A(a,b):FE.call(null,
a,b);case "var":case "local":case "js-var":case "binding":return d=LD.j(b),null==d?(b=$APP.Wu.j(b),FE.A?FE.A(a,b):FE.call(null,a,b)):FE.A?FE.A(a,d):FE.call(null,a,d);case "host-field":case "host-call":return $APP.gy;case "js":return $APP.gy;default:return null}else return d},pF=function(){var a=$APP.kh.j($APP.F),b=$APP.kh.j($APP.F),c=$APP.kh.j($APP.F),d=$APP.kh.j($APP.F),g=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));return new $APP.Ch($APP.Zg.A("cljs.analyzer","parse"),function(){function l(n,
p){if(1<arguments.length)for(var v=0,t=Array(arguments.length-1);v<t.length;)t[v]=arguments[v+1],++v;return n}l.G=1;l.K=function(n){var p=$APP.u(n);$APP.Fc(n);return p};l.C=function(n){return n};return l}(),$APP.xj,g,a,b,c,d)}();
pF.F(null,$APP.ai,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);if($APP.qg.A(2,$APP.Tc(c)))throw cE(b,"Wrong number of args to var");if(!(a instanceof $APP.q))throw cE(b,"Argument to var must be symbol");return $APP.Ni.C($APP.y([new $APP.f(null,4,[$APP.Vl,b,$APP.$x,IRb,JD,new $APP.H(null,3,5,$APP.I,[$APP.Ek,$APP.ix,$APP.h],null),$APP.Nw,c],null),$Pa(b,a)]))});
var aQa=$APP.fg([DFb,FSb,Gdc,yMb,C$b,wCb,Y9b,$APP.zsa,ZNb,y8b,Zbc,Hdb,hac,$Ub,egb,ceb,Lyb,Tub,unb,$APP.Bua,$APP.mva,dlb,VYb,Kzb,s2b,$APP.hv,$APP.vCa,WBb,wUb,cnb,Mcc,job,myb,gCb,Z9b,mrb,Rpb,$APP.$xa],[$APP.Px,$APP.wv,$APP.Fy,uY,gF,jF,jF,HHb,IEb,$APP.Yu,$APP.Fy,new $APP.ug(null,new $APP.f(null,2,[gF,"null",jF,"null"],null),null),gF,Avb,$APP.Yu,$APP.wv,$APP.Yu,D4b,$APP.Yu,$APP.Yu,nE,aOb,BLb,rac,v_b,nE,$APP.Yu,$APP.wv,nSa,new $APP.ug(null,new $APP.f(null,2,[gF,"null",jF,"null"],null),null),gF,new $APP.ug(null,
new $APP.f(null,3,[rS,"null",$APP.Px,"null",$APP.Fy,"null"],null),null),jF,$APP.Xx,$APP.fsa,q0b,new $APP.ug(null,new $APP.f(null,2,[gF,"null",jF,"null"],null),null),qrb]);
pF.F(null,$APP.Rh,function(a,b,c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(c,2,null),l=$APP.x.B(c,3,null);if(3>$APP.Tc(c))throw $APP.Zi.B(null,bE(b,tgb,$APP.Rh),Error("Too few arguments to if"));if(4<$APP.Tc(c))throw $APP.Zi.B(null,bE(b,tgb,$APP.Rh),Error("Too many arguments to if"));a=function(){var v=LE;LE=$APP.Yd(null,LE);try{var t=$APP.rg.B(b,IE,$APP.Bk);return GE?GE(t,d):HE.call(null,t,d)}finally{LE=v}}();var n=function(){var v=XY;XY=!0;try{var t=hQa(b,d);return GE?GE(t,g):HE.call(null,
t,g)}finally{XY=v}}(),p=function(){var v=XY;XY=!0;try{return GE?GE(b,l):HE.call(null,b,l)}finally{XY=v}}();return new $APP.f(null,8,[$APP.Vl,b,$APP.$x,lOa,$APP.Nw,c,$APP.Nr,a,EE,n,$APP.tr,p,fMb,!1,JD,new $APP.H(null,3,5,$APP.I,[$APP.Nr,EE,$APP.tr],null)],null)});
pF.F(null,$APP.Mh,function(a,b,c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(c,2,null),l=$APP.x.B(c,3,null),n=$APP.x.B(c,4,null),p=$APP.rg.B(b,IE,$APP.Bk);a=function(){var v=LE;LE=$APP.Yd(null,LE);try{return GE?GE(p,d):HE.call(null,p,d)}finally{LE=v}}();g=$APP.Fl.A(function(v){return $APP.Fl.A(function(t){return GE?GE(p,t):HE.call(null,p,t)},v)},g);l=$APP.Fl.A(function(v){return GE?GE(b,v):HE.call(null,b,v)},l);l=$APP.Fl.B(function(v,t){return new $APP.f(null,5,[$APP.$x,uIb,$APP.Vl,b,
BFb,$APP.Fl.A(function(A){return new $APP.f(null,5,[$APP.$x,iPb,$APP.Nw,$APP.Nw.j(A),$APP.Vl,p,$APP.Nr,A,JD,new $APP.H(null,1,5,$APP.I,[$APP.Nr],null)],null)},v),EE,new $APP.f(null,5,[$APP.$x,Idc,$APP.Nw,$APP.Nw.j(t),$APP.Vl,b,EE,t,JD,new $APP.H(null,1,5,$APP.I,[EE],null)],null),JD,new $APP.H(null,2,5,$APP.I,[BFb,EE],null)],null)},g,l);n=GE?GE(b,n):HE.call(null,b,n);return new $APP.f(null,7,[$APP.Vl,b,$APP.$x,S2b,$APP.Nw,c,$APP.Nr,a,$hb,l,$APP.xj,n,JD,new $APP.H(null,3,5,$APP.I,[$APP.Nr,$hb,$APP.xj],
null)],null)});
pF.F(null,$APP.ci,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);if($APP.Uc.A(1,$APP.Tc(c)))throw cE(b,"Too few arguments to throw, throw expects a single Error instance");if(2<$APP.Tc(c))throw cE(b,"Too many arguments to throw, throw expects a single Error instance");a:{var d=LE;LE=$APP.Yd(null,LE);try{var g=$APP.rg.B(b,IE,$APP.Bk);var l=GE?GE(g,a):HE.call(null,g,a);break a}finally{LE=d}l=void 0}return new $APP.f(null,5,[$APP.Vl,b,$APP.$x,x2b,$APP.Nw,c,$APP.Fx,l,JD,new $APP.H(null,1,5,$APP.I,
[$APP.Fx],null)],null)});
pF.F(null,$APP.Nh,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a),g=$APP.Li.B(b,new $APP.H(null,1,5,$APP.I,[IE],null),function(Z){return $APP.Uc.A($APP.Bk,Z)?ME:Z}),l=$APP.vt.A($APP.td,function(Z){return $APP.Uc.A($APP.u(Z),$APP.bi)}),n=$APP.vt.A(l,function(Z){return $APP.Uc.A($APP.Xc(Z),$APP.xj)}),p=$APP.vt.A($APP.td,function(Z){return $APP.Uc.A($APP.u(Z),$APP.Oh)});a=function(){for(var Z=new $APP.f(null,6,[$APP.KU,$APP.nq,CP,d,$APP.em,$APP.sf,u5b,$APP.sf,h9b,null,P8b,null],null);;)if($APP.td(CP.j(Z))){var fa=
CP.j(Z),ha=$APP.r(fa);fa=$APP.u(ha);ha=$APP.w(ha);ha=$APP.rg.B(Z,CP,ha);var ja=$APP.KU.j(Z);ja=ja instanceof $APP.E?ja.ga:null;switch(ja){case "start":Z=$APP.k(l(fa))?$APP.rg.B(Z,$APP.KU,L4b):$APP.k(p(fa))?$APP.rg.B(Z,$APP.KU,$APP.Tx):$APP.Li.M(ha,new $APP.H(null,1,5,$APP.I,[$APP.em],null),$APP.Vd,fa);continue;case "catches":if($APP.k(n(fa))){Z=$APP.rg.C(ha,h9b,fa,$APP.y([$APP.KU,$APP.Tx]));continue}else if($APP.k(l(fa))){Z=$APP.Li.M(ha,new $APP.H(null,1,5,$APP.I,[u5b],null),$APP.Vd,fa);continue}else if($APP.k(p(fa))){Z=
$APP.rg.B(Z,$APP.KU,$APP.Tx);continue}else throw cE(b,"Invalid try form");case "finally":Z=$APP.rg.C(ha,P8b,fa,$APP.y([$APP.KU,Lmb]));continue;case "done":throw cE(b,"Unexpected form after finally");default:throw Error(["No matching clause: ",$APP.m.j(ja)].join(""));}}else return Z}();a=$APP.qe(a);var v=$APP.C.A(a,$APP.em),t=$APP.C.A(a,u5b),A=$APP.C.A(a,h9b),B=$APP.C.A(a,P8b),G=$APP.r(B)?$APP.rg.B(function(){var Z=LE;LE=$APP.Yd(null,LE);try{var fa=$APP.rg.B(b,IE,CQa),ha=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
$APP.Qh,null,1,null),$APP.Fc(B))));return GE?GE(fa,ha):HE.call(null,fa,ha)}finally{LE=Z}}(),NE,!0):null,J=$APP.k(function(){var Z=$APP.r(t);return Z?Z:A}())?$APP.Nj.j("e"):null;a=function(){if($APP.k(A)){var Z=$APP.r(A);$APP.u(Z);Z=$APP.w(Z);$APP.u(Z);var fa=$APP.w(Z);Z=$APP.u(fa);fa=$APP.w(fa);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.fm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,Z,null,1,null),new $APP.D(null,J,null,1,null))))),null,1,null),$APP.y([fa]))))}return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,
$APP.ci,null,1,null),new $APP.D(null,J,null,1,null))))}();var O=$APP.r(t)?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.PDa,null,1,null),$APP.bf.C(function(Z){Z=$APP.r(Z);$APP.u(Z);var fa=$APP.w(Z);Z=$APP.u(fa);var ha=$APP.w(fa);fa=$APP.u(ha);ha=$APP.w(ha);return $APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,eQa,null,1,null),new $APP.D(null,Z,null,1,null),$APP.y([new $APP.D(null,J,null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.fm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,fa,null,1,null),new $APP.D(null,J,null,1,null))))),null,1,null),$APP.y([ha])))),null,1,null)))))},$APP.y([t])),$APP.y([new $APP.D(null,$APP.tr,null,1,null),new $APP.D(null,a,null,1,null)])))):a;a=ND.j(g);var Q=$APP.k(J)?$APP.rg.B(a,J,new $APP.f(null,3,[$APP.R,J,$APP.Xi,XD(J,b),$APP.zj,YD(J,b)],null)):a;a=$APP.k(O)?function(){var Z=LE;LE=$APP.Yd(null,LE);try{var fa=$APP.rg.B(g,ND,Q);return GE?GE(fa,O):HE.call(null,
fa,O)}finally{LE=Z}}():null;var W=function(){var Z=LE;LE=$APP.Yd(null,LE);try{var fa=$APP.k($APP.k(J)?J:G)?g:b,ha=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Qh,null,1,null),v)));return GE?GE(fa,ha):HE.call(null,fa,ha)}finally{LE=Z}}();return new $APP.f(null,8,[$APP.Vl,b,$APP.$x,$APP.Ria,$APP.Nw,c,$APP.em,$APP.rg.B(W,NE,!0),$APP.Tx,G,$APP.R,J,R9b,a,JD,$APP.tf($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.em],null),$APP.k(a)?new $APP.H(null,1,5,$APP.I,[R9b],null):null,$APP.y([$APP.k(G)?new $APP.H(null,
1,5,$APP.I,[$APP.Tx],null):null])))],null)});var Mec=function Mec(a){a=$APP.qe(a);var c=$APP.C.A(a,$APP.$x),d=function(){var g=new $APP.ug(null,new $APP.f(null,2,[$APP.Kw,null,$APP.Mk,null],null),null);return g.j?g.j(c):g.call(null,c)}();if($APP.k(d))return d;d=function(){var g=new $APP.ug(null,new $APP.f(null,3,[$APP.mj,null,$APP.tj,null,$APP.nj,null],null),null);return g.j?g.j(c):g.call(null,c)}();return $APP.k(d)?$APP.Ge(Mec,kQa(a)):d};
pF.F(null,$APP.di,function(a,b,c){if(4<$APP.Tc(c))throw cE(b,"Too many arguments to def");var d=$APP.Je.A(function(){function ha(ca,V,da,Y){return new $APP.f(null,3,[$APP.ix,V,$APP.P,da,LD,Y],null)}function ja(ca,V,da){return new $APP.f(null,2,[$APP.ix,V,LD,da],null)}function ta(ca,V){return new $APP.f(null,1,[$APP.ix,V],null)}var ua=null;ua=function(ca,V,da,Y){switch(arguments.length){case 2:return ta.call(this,ca,V);case 3:return ja.call(this,ca,V,da);case 4:return ha.call(this,ca,V,da,Y)}throw Error("Invalid arity: "+
arguments.length);};ua.A=ta;ua.B=ja;ua.M=ha;return ua}(),c),g=$APP.ix.j(d);a=$APP.Kw.j($APP.ed(g));var l=$APP.ed(g),n=$APP.sj.j($APP.ed(g)),p=iQa($APP.Nm.j($APP.ed(g))),v=$APP.gm.j($APP.ed(g)),t=$APP.R.j($APP.wl.j(b));ND.j(b);var A=$APP.Zg.j([$APP.m.j(t),".",$APP.m.j(g)].join("")),B=$APP.ae(g);if($APP.k($APP.k(B)?!qD($APP.Zg.j(B),t):B))throw cE(b,["Can't def ns-qualified name in namespace ",B].join(""));var G=null!=B?$APP.Zg.j($APP.Ag(g)):g;null!=$APP.Zl.A($APP.Fb(null),new $APP.H(null,2,5,$APP.I,
[TD,A],null))&&$D(TE,b,new $APP.f(null,2,[$APP.wl,$APP.Zg.j([$APP.m.j(t),".",$APP.m.j(G)].join("")),$APP.Ek,$APP.Zg.A($APP.m.j(t),$APP.m.j(G))],null));if(null!=$APP.Kw.j(vE($APP.Oi.A(b,ND),G)))throw cE(b,"Can't redefine a constant");g=$APP.P.j(d);if(null!=g&&"string"!==typeof g)throw cE(b,"Too many arguments to def");$APP.eb(v)&&lQa(G)&&!nQa(t)&&$D(Nac,b,new $APP.f(null,1,[$APP.Ek,$APP.m.j(G)],null));var J=$APP.Zl.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[TD,t,jE,G],null));null!=J&&($APP.k(function(){var ha=
$APP.eb(XY);return ha?(ha=$APP.eb($APP.Pu.j(J)))?(ha=$APP.eb($APP.Pu.j(l)))?$APP.k(null)?$APP.C.A($APP.Fb(null),G):null:ha:ha:ha}())&&$D(h2b,b,new $APP.f(null,2,[$APP.ix,G,$APP.Xi,$APP.Xi.j(J)],null)),$APP.k(function(){var ha=$APP.Pu.j(J);return $APP.k(ha)?(ha=$APP.U.j(J),$APP.k(ha)?$APP.qg.A($APP.U.j(J),$APP.U.j(l)):ha):ha}())&&$D(yEb,b,new $APP.f(null,4,[wX,t,$APP.ix,G,$APP.Pu,$APP.Xc($APP.U.j(J)),VBb,$APP.Xc($APP.U.j(l))],null)));var O=$APP.qg.A(t,$APP.yn)&&fPa(b,G)||null!=$APP.Zl.A($APP.Fb(null),
new $APP.H(null,4,5,$APP.I,[TD,t,rE,G],null))?function(){var ha=MPa($APP.Oi.A(b,ND),$APP.z(G,new $APP.f(null,1,[$APP.mw,!0],null))),ja=$APP.dn.A($APP.Vd,$APP.vg);gPa($APP.wl.j(ha),G)&&$D(r4b,b,new $APP.f(null,3,[$APP.ix,G,$APP.wl,$APP.wl.j(ha),wX,t],null));$APP.lh.C(null,$APP.Li,new $APP.H(null,3,5,$APP.I,[TD,t,kE],null),ja,$APP.y([G]));return $APP.Li.M(b,new $APP.H(null,2,5,$APP.I,[$APP.wl,kE],null),ja,G)}():b,Q=$APP.R.j(vE($APP.Oi.A(O,ND),G)),W=$APP.Bd(d,LD)?function(){$APP.lh.M(null,$APP.am,new $APP.H(null,
4,5,$APP.I,[TD,t,jE,G],null),$APP.Ni.C($APP.y([new $APP.f(null,1,[$APP.R,Q],null),l,!0===v?new $APP.f(null,1,[$APP.gm,!0],null):null,ZD(Q,O)])));var ha=LE;LE=$APP.Yd(null,LE);try{var ja=YY;YY=!1;try{var ta=$APP.rg.B(O,IE,$APP.Bk),ua=LD.j(d);return zSa?zSa(ta,ua,G):HE.call(null,ta,ua,G)}finally{YY=ja}}finally{LE=ha}}():null;A=(g=null!=W&&$APP.Uc.A($APP.$x.j(W),$APP.Fk))?function(){var ha=wE.j(W);return $APP.k(ha)?ha:$APP.k(n)?n:IQb.j(W)}():$APP.k(n)?n:$APP.k(v)?$APP.gy:$APP.sj.j(W);B=function(){var ha=
V8b.j($APP.ed(G));return $APP.k(ha)?$APP.Uc.A(!0,ha)?Q:ha:null}();var Z=function(){var ha=$APP.P.j(d);return $APP.k(ha)?ha:$APP.P.j($APP.ed(G))}(),fa=$APP.Zl.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[TD,t,jE,G],null));null!=fa&&$APP.eb($APP.Pu.j($APP.ed(G)))&&!0===PE.j(fa)&&!g&&$D(PE,O,new $APP.f(null,2,[wX,t,$APP.ix,G],null));if(null==$APP.Zl.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[TD,t,jE,G],null))||$APP.eb($APP.Pu.j(l)))$APP.k(null)&&$APP.lh.B(null,$APP.Vd,G),$APP.lh.M(null,$APP.am,new $APP.H(null,
4,5,$APP.I,[TD,t,jE,G],null),$APP.Ni.C($APP.y([new $APP.f(null,1,[$APP.R,Q],null),$APP.k($APP.Nr.j(l))?$APP.rg.B(l,$APP.Nr,!0):l,new $APP.f(null,1,[$APP.h,$APP.Li.B($APP.Oi.A(l,$APP.Nr),new $APP.H(null,1,5,$APP.I,[$APP.Wi],null),function(ha){return $APP.Uc.A($APP.R.j($APP.wl.j(O)),$APP.yn)?"cljs/core.cljs":ha})],null),$APP.k(Z)?new $APP.f(null,1,[$APP.P,Z],null):null,$APP.k(a)?function(){a:{var ha=rF;rF=$APP.Vd.A(rF,jQa());try{var ja=LD.j(d);var ta=GE?GE(O,ja):HE.call(null,O,ja);break a}finally{rF=
ha}ta=void 0}return $APP.k(Mec(ta))?new $APP.f(null,1,[TRa,ta],null):null}():null,!0===v?new $APP.f(null,1,[$APP.gm,!0],null):null,ZD(Q,O),$APP.k(p)?new $APP.f(null,1,[$APP.Nm,p],null):null,function(){var ha=DE.j($APP.ed(G));return $APP.k(ha)?new $APP.f(null,3,[DE,ha,$APP.Wu,dS.j($APP.ed(ha)),lkb,$APP.vg],null):null}(),g?function(){var ha=$APP.Vg.A(function(ja){return $APP.tf($APP.Vg.A($APP.R,$APP.dm.j(ja)))},$APP.Mm.j(W));return $APP.Ni.C($APP.y([new $APP.f(null,3,[PE,$APP.eb($APP.Bl.j(l)),KE,KE.j(W),
czb,czb.j(W)],null),function(){var ja=$APP.hy.j(l);return null==ja?new $APP.f(null,5,[$APP.ru,$APP.ru.j(W),$APP.nw,$APP.nw.j(W),$APP.ty,ha,$APP.U,$APP.U.j(l),$APP.zx,$APP.Dj.j($APP.Vg.A($APP.ed,$APP.U.j(l)))],null):ja}()]))}():null,$APP.k(function(){var ha=$APP.Pu.j(l);return $APP.k(ha)?$APP.U.j(l):ha}())?new $APP.f(null,3,[$APP.Pu,!0,PE,!0,$APP.ty,$APP.Xc($APP.U.j(l))],null):null,g&&null!=A?new $APP.f(null,1,[wE,A],null):$APP.k(A)?new $APP.f(null,1,[$APP.sj,A],null):null])));return $APP.Ni.C($APP.y([new $APP.f(null,
8,[$APP.Vl,O,$APP.$x,$APP.Gr,$APP.Nw,c,$APP.wl,t,$APP.R,Q,$APP.Ek,$APP.rg.B(function(){var ha=$APP.rg.B($APP.rg.B($APP.Oi.A(O,ND),IE,$APP.Bk),SRa,!0);return GE?GE(ha,G):HE.call(null,ha,G)}(),$APP.$x,$APP.Ek),$APP.P,Z,eU,eU.j(l)],null),function(){var ha=nec.j(l);return $APP.k(ha)?new $APP.f(null,1,[nec,ha],null):null}(),!0===Tac.j(O)?new $APP.f(null,1,[q1b,$Pa(O,G)],null):null,function(){var ha=$APP.Nr.j(l);if(null==ha)ha=null;else{var ja=$APP.rg.B(O,IE,$APP.Bk);ha=GE?GE(ja,ha):HE.call(null,ja,ha);
ha=new $APP.f(null,1,[$APP.Nr,ha],null)}return ha}(),null!=A?g?new $APP.f(null,1,[wE,A],null):new $APP.f(null,1,[$APP.sj,A],null):null,!0===v?new $APP.f(null,1,[$APP.gm,!0],null):null,null!=B?new $APP.f(null,1,[V8b,B],null):null,null!=W?new $APP.f(null,2,[LD,W,JD,new $APP.H(null,2,5,$APP.I,[$APP.Ek,LD],null)],null):new $APP.f(null,1,[JD,new $APP.H(null,1,5,$APP.I,[$APP.Ek],null)],null)]))});
pF.F(null,$APP.Xh,function(a,b,c,d){a=$APP.r(c);$APP.u(a);var g=$APP.w(a);d=(a=$APP.u(g)instanceof $APP.q)?new $APP.H(null,2,5,$APP.I,[$APP.u(g),$APP.w(g)],null):new $APP.H(null,2,5,$APP.I,[d,$APP.r(g)],null);var l=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var n=$APP.od($APP.u(d))?new $APP.D(null,d,null,1,null):d;g=ND.j(b);d=AQa(b,g,l);var p=null!=l?$APP.Li.M(b,new $APP.H(null,1,5,$APP.I,[yQa],null),$APP.Vd,d):b,v=null!=g&&a?$APP.rg.B(g,l,d):g;b=$APP.ed(c);var t=g5b.j(b);g=Jib.j(b);var A=eIb.j(b),B=
$APP.Ni.C($APP.y([$APP.Oi.A(1<$APP.Tc(n)?$APP.rg.B(p,IE,$APP.Bk):p,LQa),new $APP.f(null,2,[KE,g,czb,A],null)])),G=$APP.Vg.A(function(Z){var fa=YY;YY=!1;try{return wQa(B,v,Z,t,null==l)}finally{YY=fa}},n);b=$APP.Vs.M($APP.Vg.j($APP.Sn),$APP.Gj,0,G);var J=$APP.vd($APP.He($APP.ru,G)),O=a?$APP.Li.C(v,new $APP.H(null,1,5,$APP.I,[l],null),$APP.rg,PE,!0,$APP.ru,$APP.y([J,$APP.nw,b,$APP.ty,$APP.Vg.A($APP.dm,G)])):v,Q=null!=l?function(){var Z=YY;YY=!1;try{return BQa(B,O,t,n)}finally{YY=Z}}():$APP.tf(G);c=$APP.Xj.S(c,
$APP.Oi,Jib,eIb,g5b);a=!0===J?"@param {...*} var_args":null;G=null!=d?new $APP.H(null,2,5,$APP.I,[$APP.zl,$APP.Mm],null):new $APP.H(null,1,5,$APP.I,[$APP.Mm],null);var W=function(){var Z=$APP.Vg.A($APP.Pi.A(FE,p),$APP.Vg.A($APP.em,Q));return $APP.k($APP.Je.A($APP.Uc,Z))?$APP.u(Z):null}();c=$APP.Ni.C($APP.y([$APP.fg([JD,czb,$APP.R,nOa,IQb,KE,$APP.$x,$APP.Vl,$APP.ru,$APP.Mm,cBb,$APP.nw,$APP.Nw,$APP.sj,LQa,eU],[G,A,d,OE,W,g,$APP.Fk,p,J,Q,LE,b,c,$APP.gx,LQa.j(p),new $APP.H(null,1,5,$APP.I,[a],null)]),
null!=d?new $APP.f(null,1,[$APP.zl,d],null):null]));a=$APP.Lf.B($APP.sf,$APP.Hl.A($APP.df.j($APP.ru),$APP.We.j(1)),Q);g=0<$APP.Tc(a)?$APP.Tc($APP.dm.j($APP.x.A(a,0))):0;A=$APP.Lf.B($APP.sf,$APP.Vg.j($APP.Hl.A($APP.Tc,$APP.dm)),Q);1<$APP.Tc(a)&&$D(V$b,p,new $APP.f(null,1,[$APP.R,d],null));0!==g&&g!==1+b&&$D(ZSb,p,new $APP.f(null,1,[$APP.R,d],null));$APP.qg.A($APP.Mt.j(A),A)&&$D(uGb,p,new $APP.f(null,1,[$APP.R,d],null));return kF.j?kF.j(c):kF.call(null,c)});
pF.F(null,$APP.uda,function(a,b,c){a=$APP.r(c);$APP.u(a);a=$APP.w(a);var d=$APP.u(a),g=$APP.w(a);if(!$APP.od(d)||!$APP.Ie($APP.Tc(d)))throw cE(b,"bindings must be vector of even number of elements");var l=$APP.Lf.A($APP.F,$APP.Vg.A($APP.wi.A($APP.u,$APP.Xc),$APP.Jl.A(2,d)));a=$APP.ng(l);var n=IE.j(b);d=$APP.Id.B(function(v,t){var A=$APP.x.B(v,0,null),B=$APP.qe(A),G=$APP.C.A(B,ND);v=$APP.x.B(v,1,null);var J=$APP.sj.j($APP.ed(t)),O=function(){var Q=aE;aE=$APP.Bg($APP.ng(aE),$APP.Uj.j(!1));try{var W=
l.j?l.j(t):l.call(null,t);return GE?GE(B,W):HE.call(null,B,W)}finally{aE=Q}}();A=function(){var Q=$APP.fg([$APP.R,$APP.ty,$APP.$x,$APP.zj,$APP.ru,$APP.Xi,$APP.nw,PE,JE,$APP.zl],[t,$APP.Vg.A($APP.dm,$APP.Mm.j(O)),qQa,YD(t,B),$APP.ru.j(O),XD(t,B),$APP.nw.j(O),!0,tE(t,G.j?G.j(t):G.call(null,t)),Hib]);return $APP.k(J)?$APP.rg.B(Q,wE,J):Q}();return new $APP.H(null,2,5,$APP.I,[$APP.am(B,new $APP.H(null,2,5,$APP.I,[ND,t],null),A),$APP.Vd.A(v,A)],null)},new $APP.H(null,2,5,$APP.I,[b,$APP.sf],null),a);a=$APP.x.B(d,
0,null);d=$APP.x.B(d,1,null);a=$APP.rg.B(a,IE,$APP.Bk);a=$APP.Id.B(function(v,t){var A=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);var B=$APP.qe(t);t=$APP.C.A(B,$APP.R);var G=$APP.C.A(B,JE);A=$APP.am(A,new $APP.H(null,2,5,$APP.I,[ND,t],null),G);G=l.j?l.j(t):l.call(null,t);G=GE?GE(A,G):HE.call(null,A,G);B=$APP.rg.C(B,LD,G,$APP.y([$APP.ru,$APP.ru.j(G),$APP.nw,$APP.nw.j(G),$APP.ty,$APP.Vg.A($APP.dm,$APP.Mm.j(G)),JD,new $APP.H(null,1,5,$APP.I,[LD],null)]));return new $APP.H(null,2,5,$APP.I,[$APP.am(A,new $APP.H(null,
2,5,$APP.I,[ND,t],null),B),$APP.Vd.A(v,B)],null)},new $APP.H(null,2,5,$APP.I,[a,$APP.sf],null),d);var p=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);d=$APP.rg.B(function(){var v=$APP.rg.B(p,IE,$APP.Uc.A($APP.Bk,n)?ME:n),t=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Qh,null,1,null),g)));return GE?GE(v,t):HE.call(null,v,t)}(),NE,!0);return new $APP.f(null,6,[$APP.Vl,b,$APP.$x,Hib,$APP.Tl,a,$APP.em,d,$APP.Nw,c,JD,new $APP.H(null,2,5,$APP.I,[$APP.Tl,$APP.em],null)],null)});
pF.F(null,$APP.Qh,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a);a=EQa(b,d);if(1>=$APP.Tc(d))var g=function(){var p=$APP.u(d);return GE?GE(b,p):HE.call(null,b,p)}(),l=new $APP.H(null,2,5,$APP.I,[KD,MD],null);else{var n=$APP.Uc.A(CQa,IE.j(b))?$APP.rg.B(b,IE,CQa):$APP.rg.B(b,IE,ME);g=function(){var p=$APP.$c(d);return GE?GE(n,p):HE.call(null,n,p)}();l=new $APP.H(null,2,5,$APP.I,[KD,MD],null)}return new $APP.f(null,6,[$APP.$x,K3b,$APP.Vl,b,$APP.Nw,c,KD,a,MD,g,JD,l],null)});
pF.F(null,$APP.Uh,function(a,b,c){return MQa(b,c,!1)});pF.F(null,$APP.Ph,function(a,b,c){return MQa(b,c,!0)});
pF.F(null,$APP.Yh,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a);IE.j(b);var g=$APP.u(LE),l=function(){var v=KE.j(g);return $APP.k(v)?$APP.Uc.A($APP.Tc(d),$APP.Tc($APP.dm.j(g))-1):v}(),n=$APP.k(l)?$APP.Yd(null,d):d,p=function(){var v=LE;LE=$APP.Yd(null,LE);try{return $APP.tf($APP.Vg.A(function(t){var A=$APP.rg.B(b,IE,$APP.Bk);return GE?GE(A,t):HE.call(null,A,t)},n))}finally{LE=v}}();if(!$APP.k(g))throw cE(b,"Can't recur here");if(!$APP.Uc.A($APP.Tc(p),$APP.Tc($APP.dm.j(g))))throw cE(b,["recur argument count mismatch, expected: ",
$APP.m.j($APP.Tc($APP.dm.j(g)))," args, got: ",$APP.m.j($APP.Tc(p))].join(""));$APP.k(function(){var v=KE.j(g);return $APP.k(v)?$APP.eb(l):v}())&&$D(HNb,b,new $APP.f(null,1,[$APP.Nw,$APP.Nw.j($APP.u(p))],null));$APP.Ne(tQa.j(g),!0);$APP.lh.A($APP.Ay.j(g),function(v){return $APP.Fl.B(function(t,A){return $APP.Uc.A(KQa,$APP.zl.j(A))?$APP.gy:WY.A(t,$APP.sj.j(A))},v,p)});return $APP.rg.C(new $APP.f(null,3,[$APP.Vl,b,$APP.$x,m6b,$APP.Nw,c],null),w_b,g,$APP.y([Qvb,p,JD,new $APP.H(null,1,5,$APP.I,[Qvb],
null)]))});pF.F(null,$APP.K,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);if($APP.qg.A(2,$APP.Tc(c)))throw cE(b,"Wrong number of args to quote");var d=$APP.rg.B(b,RRa,!0);d=GE?GE(d,a):HE.call(null,d,a);d=$APP.qe(d);d=$APP.C.A(d,$APP.sj);a=new $APP.f(null,6,[$APP.$x,$APP.Kw,$APP.Vl,b,Mwb,!0,$APP.X,a,$APP.sj,d,$APP.Nw,a],null);return new $APP.f(null,6,[$APP.$x,$APP.Mk,$APP.Bk,a,$APP.Vl,b,$APP.Nw,c,$APP.sj,$APP.sj.j(a),JD,new $APP.H(null,1,5,$APP.I,[$APP.Bk],null)],null)});
var Nec=new $APP.f(null,6,[$APP.Sia,$APP.ay,$APP.hBa,$APP.Fy,$APP.nDa,$APP.Px,$APP.bta,$APP.Yu,$APP.Spa,$APP.gx,$APP.jpa,$APP.wv],null);
pF.F(null,$APP.Sh,function(a,b,c){a=$APP.r(c);$APP.u(a);a=$APP.w(a);var d=$APP.u(a);a=$APP.w(a);var g=LE;LE=$APP.Yd(null,LE);try{var l=$APP.rg.B(b,IE,$APP.Bk),n=GE?GE(l,d):HE.call(null,l,d),p=$APP.k(function(){var G=$APP.$x.j(n),J=new $APP.ug(null,new $APP.f(null,3,[$APP.Ek,null,sE,null,$APP.zl,null],null),null);return J.j?J.j(G):J.call(null,G)}())?MPa(b,d):null,v=$APP.k(function(){var G=dRa.j(p);return $APP.k(G)?$APP.eb(ZX.j($APP.ed(d))):G}())?$APP.Uj.A(3,GE?GE(l,null):HE.call(null,l,null)):null,
t=$APP.Lf.A($APP.tf($APP.Vg.A(function(G){return GE?GE(l,G):HE.call(null,l,G)},a)),v),A=cRa.j(p),B=$APP.Tc(a);$APP.eb(ZX.j($APP.ed(d)))&&null!=A&&$APP.eb(function(){var G=$APP.Uc.A(A,B);if(G)return G;G=dRa.j(p);return $APP.k(G)?$APP.Uc.A(2+A,B):G}())&&$D(hF,b,new $APP.f(null,2,[iF,B,jPa,d],null));return new $APP.f(null,7,[$APP.Vl,b,$APP.$x,Vrb,$APP.Nw,c,$APP.Tm,n,$APP.Wj,t,JD,new $APP.H(null,2,5,$APP.I,[$APP.Tm,$APP.Wj],null),$APP.sj,function(){var G=$APP.sj.j($APP.Wu.j(n));if(mE(G)&&!$APP.Bd(Nec,
G))return $APP.Zw;G=$APP.R.j($APP.Wu.j(n));var J=Nec.j?Nec.j(G):Nec.call(null,G);return $APP.k(J)?J:G}()],null)}finally{LE=g}});
pF.F(null,$APP.Zh,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);var d=$APP.x.B(c,2,null),g=$APP.x.B(c,3,null);a=$APP.k(g)?new $APP.H(null,2,5,$APP.I,[$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.$h,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)])))),g],null):new $APP.H(null,2,5,$APP.I,[a,d],null);var l=$APP.x.B(a,0,null),n=$APP.x.B(a,1,null);a=LE;LE=$APP.Yd(null,LE);try{d=CE;CE=!0;try{var p=$APP.rg.B(b,IE,$APP.Bk),v=l instanceof $APP.q?function(){if(!$APP.Uc.A(l,
hFb)||!0!==n&&!1!==n)if(!$APP.Uc.A(l,pqb)||!0!==n&&!1!==n)!$APP.Uc.A(l,$jb)||!0!==n&&!1!==n||(aE=$APP.rg.B(aE,aF,n));if(null!=$APP.Kw.j(vE($APP.Oi.A(b,ND),l)))throw cE(b,"Can't set! a constant");var J=tE(l,function(){var O=ND.j(b);return l.j?l.j(O):l.call(null,O)}());if(!$APP.k(function(){var O=null==J;if(O)return O;O=UE.j(J);if($APP.k(O)){O=$APP.go.j(J);if($APP.k(O))return O;O=ZQa.j(J);return $APP.k(O)?O:$APP.Zx.j(J)}return O}()))throw cE(b,"Can't set! local var or non-mutable field");return URa.A?
URa.A(p,l):URa.call(null,p,l)}():$APP.td(l)?function(){if($APP.k(Yeb.j($APP.ed(l))))a:{var J=aE;aE=$APP.rg.B(aE,aF,!1);try{var O=nF?nF(p,l,null):hSa.call(null,p,l,null);break a}finally{aE=J}O=void 0}else O=nF?nF(p,l,null):hSa.call(null,p,l,null);return $APP.k(UE.j(O))?O:null}():null,t=GE?GE(p,n):HE.call(null,p,n);if($APP.td(l)){var A=null==l?null:$APP.Xc(l),B=$APP.ed(A),G=function(){var J=$APP.Uc.A($APP.Fk,$APP.$x.j(t));return J?$APP.hy.j(B):J}();$APP.k(G)&&$APP.lh.C(null,$APP.Li,new $APP.H(null,
5,5,$APP.I,[TD,$APP.R.j($APP.wl.j(b)),jE,A,$APP.Mm],null),$APP.dn.A($APP.Vd,$APP.sf),$APP.y([$APP.Ni.C($APP.y([$APP.sg(G,new $APP.H(null,2,5,$APP.I,[$APP.Sn,$APP.ru],null)),$APP.sg($APP.u($APP.Mm.j(t)),new $APP.H(null,1,5,$APP.I,[$APP.sj],null))]))]))}if(!$APP.k(v))throw cE(b,"set! target must be a field or a symbol naming a var");return $APP.eb(Tac.j(b))&&null!=function(){var J=new $APP.ug(null,new $APP.f(null,3,[$jb,"null",pqb,"null",hFb,"null"],null),null);return J.j?J.j(l):J.call(null,l)}()?new $APP.f(null,
2,[$APP.Vl,b,$APP.$x,dwb],null):new $APP.f(null,6,[$APP.Vl,b,$APP.$x,AAb,$APP.Nw,c,YE,v,$APP.X,t,JD,new $APP.H(null,2,5,$APP.I,[YE,$APP.X],null)],null)}finally{CE=d}}finally{LE=a}});
pF.F(null,$APP.Th,function(a,b,c,d,g){a=$APP.r(c);$APP.u(a);d=$APP.w(a);a=$APP.u(d);var l=$APP.w(d);if(!$APP.k(YY))throw cE(b,"Namespace declarations must appear at the top-level.");if(!(a instanceof $APP.q))throw cE(b,"Namespaces must be named by a symbol.");var n=$APP.k(ukb.j(g))?XQa(a):a;a=$APP.qi.A($APP.Ag(n),/\./);$APP.Uc.A(1,$APP.Tc(a))&&$D(l1b,b,new $APP.f(null,1,[$APP.R,n],null));null!=$APP.He(Jec,a)&&$D(Flb,b,new $APP.f(null,1,[$APP.R,n],null));WQa(b,n,a);a="string"===typeof $APP.u(l)?$APP.u(l):
null;d=$APP.P.j($APP.ed(n));l=null!=a?$APP.w(l):l;var p=$APP.md($APP.u(l))?$APP.u(l):null;l=VQa(null!=p?$APP.w(l):l);l=hOa(l);l=$APP.qe(l);var v=$APP.C.A(l,GD);l=$APP.C.A(l,FD);var t=$APP.Xj.B(n,$APP.Ni,p);n=OQa(b,v);p=$APP.qe(n);n=$APP.C.A(p,kE);p=$APP.C.A(p,yE);p=$APP.Id.B(function(ua,ca){var V=$APP.x.B(ca,0,null);ca=$APP.x.B(ca,1,null);return $APP.rg.B(ua,ca,$APP.Zg.A("cljs.core",$APP.m.j(V)))},$APP.F,p);var A=$APP.kh.j($APP.sf),B=$APP.kh.j(new $APP.f(null,2,[QQa,l,AE,l],null)),G=new $APP.f(null,
5,[$APP.Yj,$APP.Pi.C(RE,b,!1,A,$APP.y([B])),$APP.tn,$APP.Pi.C(RE,b,!0,A,$APP.y([B])),$APP.en,$APP.Hl.A($APP.Pi.C(RE,b,!1,A,$APP.y([B])),$APP.Pi.A(PQa,b)),zE,$APP.Hl.A($APP.Pi.C(RE,b,!0,A,$APP.y([B])),$APP.Pi.A(PQa,b)),SE,$APP.Pi.B(RQa,b,A)],null),J=$APP.kh.j(new $APP.ug(null,new $APP.f(null,5,[zE,null,$APP.en,null,$APP.Yj,null,$APP.tn,null,SE,null],null),null)),O=$APP.kh.j(new $APP.f(null,4,[$APP.en,null,$APP.Yj,null,zE,null,$APP.tn,null],null)),Q=$APP.kh.j($APP.F);v=$APP.Id.B(function(ua,ca){var V=
$APP.r(ca),da=$APP.u(V);V=$APP.w(V);if(!$APP.k(function(){var Y=new $APP.ug(null,new $APP.f(null,5,[zE,null,$APP.en,null,$APP.Yj,null,$APP.tn,null,SE,null],null),null);return Y.j?Y.j(da):Y.call(null,da)}()))throw cE(b,["Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported. Got ",$APP.m.j(ca)," instead."].join(""));if(!$APP.k(function(){var Y=$APP.Fb(J);return Y.j?Y.j(da):Y.call(null,da)}()))throw cE(b,["Only one ",$APP.m.j(da)," form is allowed per namespace definition"].join(""));
$APP.lh.B(J,$APP.ym,da);$APP.Uc.A(SE,da)||(null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.ln,null],null),null),V)&&$APP.lh.M(O,$APP.rg,da,$APP.ln),null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.mn,null],null),null),V)&&$APP.lh.M(O,$APP.rg,da,$APP.mn));(ca=$APP.r($APP.df.A(function(Y){return $APP.ln.j($APP.ed(Y))},V)))&&$APP.lh.M(Q,$APP.rg,da,$APP.Bg($APP.Vg.A($APP.u,ca),$APP.Vg.A(function(Y){return $APP.ln.j($APP.ed(Y))},ca)));return $APP.Je.M($APP.Oo,$APP.Ni,ua,$APP.Vg.A(G.j?G.j(da):
G.call(null,da),$APP.sn.A(new $APP.ug(null,new $APP.f(null,2,[$APP.ln,null,$APP.mn,null],null),null),V)))},$APP.F,$APP.sn.A(function(ua){ua=$APP.x.B(ua,0,null);return $APP.Uc.A(ua,HD)},v));var W=$APP.qe(v);v=$APP.C.A(W,$APP.en);B=$APP.C.A(W,$APP.Yj);var Z=$APP.C.A(W,$APP.bn),fa=$APP.C.A(W,zE),ha=$APP.C.A(W,$APP.tn),ja=$APP.C.A(W,BE);W=$APP.C.A(W,SE);ha=$APP.Vg.A(function(ua){if($APP.k(ukb.j(g))){var ca=$APP.Zg.j($APP.Og.B($APP.m.j(t),0,$APP.m.j(t).length-7));return $APP.Id.B(function(V,da){var Y=
$APP.x.B(da,0,null);da=$APP.x.B(da,1,null);return qD(da,ca)?V:$APP.rg.B(V,Y,da)},$APP.F,ua)}return ua},new $APP.H(null,2,5,$APP.I,[ha,fa],null));fa=$APP.x.B(ha,0,null);ha=$APP.x.B(ha,1,null);var ta=$APP.fg([BE,yE,zE,kE,$APP.R,$APP.sm,$APP.ak,rE,$APP.tn,$APP.P,FD],[ja,$APP.Ni.C($APP.y([Z,p])),ha,n,t,W,B,v,fa,$APP.k(a)?a:d,l]);$APP.lh.C(null,$APP.Li,new $APP.H(null,2,5,$APP.I,[TD,t],null),$APP.Ni,$APP.y([ta]));return $APP.Ni.C($APP.y([new $APP.f(null,6,[$APP.$x,$APP.wl,$APP.Vl,b,$APP.Nw,c,I5b,$APP.Lf.A($APP.sf,
$APP.Mt.j($APP.Fb(A))),$APP.ln,$APP.Fb(O),XHb,$APP.Fb(Q)],null),function(){var ua=$APP.k(function(){var ca=$APP.Fb(O);return ca.j?ca.j($APP.en):ca.call(null,$APP.en)}())?$APP.Li.B(ta,new $APP.H(null,1,5,$APP.I,[rE],null),function(ca){var V=$APP.Fb(O);V=V.j?V.j($APP.en):V.call(null,$APP.en);return $APP.z(ca,$APP.pe([V,!0]))}):ta;return $APP.k(function(){var ca=$APP.Fb(O);return ca.j?ca.j($APP.Yj):ca.call(null,$APP.Yj)}())?$APP.Li.B(ua,new $APP.H(null,1,5,$APP.I,[$APP.ak],null),function(ca){var V=$APP.Fb(O);
V=V.j?V.j($APP.Yj):V.call(null,$APP.Yj);return $APP.z(ca,$APP.pe([V,!0]))}):ua}()]))});
pF.F(null,$APP.tda,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);var d=$APP.u($APP.sn.A(function(fa){return $APP.td(fa)&&$APP.Uc.A($APP.K,$APP.u(fa))},$APP.sn.A($APP.Zd,a)));if($APP.k(d))throw cE(b,["Arguments to ",$APP.Ag($APP.u(a))," must be quoted. Offending spec: ",$APP.m.j(d)].join(""));if(!$APP.k(YY))throw cE(b,["Calls to `",$APP.Ag($APP.u(a)),"` must appear at the top-level."].join(""));d=$APP.Uc.A(SE,$APP.u(a))?TQa(a):SQa(a);a=$APP.R.j($APP.wl.j(b));d=VQa(new $APP.D(null,d,null,
1,null));d=hOa(d);d=$APP.qe(d);var g=$APP.C.A(d,GD);d=$APP.C.A(d,FD);var l=OQa(b,g),n=$APP.qe(l);l=$APP.C.A(n,kE);n=$APP.C.A(n,yE);n=$APP.Id.B(function(fa,ha){var ja=$APP.x.B(ha,0,null);ha=$APP.x.B(ha,1,null);return $APP.rg.B(fa,ha,$APP.Zg.A("cljs.core",$APP.m.j(ja)))},$APP.F,n);var p=$APP.kh.j($APP.sf),v=$APP.kh.j(new $APP.f(null,2,[QQa,d,AE,d],null)),t=new $APP.f(null,5,[$APP.Yj,$APP.Pi.C(RE,b,!1,p,$APP.y([v])),$APP.tn,$APP.Pi.C(RE,b,!0,p,$APP.y([v])),$APP.en,$APP.Hl.A($APP.Pi.C(RE,b,!1,p,$APP.y([v])),
$APP.Pi.A(PQa,b)),zE,$APP.Hl.A($APP.Pi.C(RE,b,!0,p,$APP.y([v])),$APP.Pi.A(PQa,b)),SE,$APP.Pi.B(RQa,b,p)],null),A=$APP.kh.j(new $APP.f(null,4,[$APP.en,null,$APP.Yj,null,zE,null,$APP.tn,null],null)),B=$APP.kh.j($APP.F);g=$APP.Id.B(function(fa,ha){var ja=$APP.r(ha);ha=$APP.u(ja);ja=$APP.w(ja);$APP.Uc.A(SE,ha)||(null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.ln,null],null),null),ja)&&$APP.lh.M(A,$APP.rg,ha,$APP.ln),null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.mn,null],null),null),ja)&&
$APP.lh.M(A,$APP.rg,ha,$APP.mn));var ta=$APP.r($APP.df.A(function(ua){return $APP.ln.j($APP.ed(ua))},ja));null!=ta&&$APP.lh.M(B,$APP.rg,ha,$APP.Bg($APP.Vg.A($APP.u,ta),$APP.Vg.A(function(ua){return $APP.ln.j($APP.ed(ua))},ta)));return $APP.Je.M($APP.Oo,$APP.Ni,fa,$APP.Vg.A(t.j?t.j(ha):t.call(null,ha),$APP.sn.A(new $APP.ug(null,new $APP.f(null,2,[$APP.ln,null,$APP.mn,null],null),null),ja)))},$APP.F,$APP.sn.A(function(fa){fa=$APP.x.B(fa,0,null);return $APP.Uc.A(fa,HD)},g));var G=$APP.qe(g);g=$APP.C.A(G,
$APP.en);v=$APP.C.A(G,$APP.Yj);var J=$APP.C.A(G,$APP.bn),O=$APP.C.A(G,zE),Q=$APP.C.A(G,$APP.tn),W=$APP.C.A(G,BE);G=$APP.C.A(G,SE);var Z=$APP.fg([BE,yE,zE,kE,$APP.R,$APP.sm,$APP.ak,rE,$APP.tn,FD],[W,$APP.Ni.C($APP.y([J,n])),O,l,a,G,v,g,Q,d]);$APP.lh.C(null,$APP.Li,new $APP.H(null,2,5,$APP.I,[TD,a],null),YQa,$APP.y([Z,b]));return $APP.Ni.C($APP.y([new $APP.f(null,6,[$APP.$x,Hzb,$APP.Vl,b,$APP.Nw,c,I5b,$APP.Lf.A($APP.sf,$APP.Mt.j($APP.Fb(p))),$APP.ln,$APP.Fb(A),XHb,$APP.Fb(B)],null),function(){var fa=
$APP.k(function(){var ha=$APP.Fb(A);return ha.j?ha.j($APP.en):ha.call(null,$APP.en)}())?$APP.Li.B(Z,new $APP.H(null,1,5,$APP.I,[rE],null),function(ha){var ja=$APP.Fb(A);ja=ja.j?ja.j($APP.en):ja.call(null,$APP.en);return $APP.z(ha,$APP.pe([ja,!0]))}):Z;return $APP.k(function(){var ha=$APP.Fb(A);return ha.j?ha.j($APP.Yj):ha.call(null,$APP.Yj)}())?$APP.Li.B(fa,new $APP.H(null,1,5,$APP.I,[$APP.ak],null),function(ha){var ja=$APP.Fb(A);ja=ja.j?ja.j($APP.Yj):ja.call(null,$APP.Yj);return $APP.z(ha,$APP.pe([ja,
!0]))}):fa}()]))});pF.F(null,$APP.vda,function(a,b,c){return hRa(XYb,b,c)});pF.F(null,$APP.sda,function(a,b,c){return hRa($Qa,b,c)});var ZE=function(){var a=$APP.kh.j($APP.F),b=$APP.kh.j($APP.F),c=$APP.kh.j($APP.F),d=$APP.kh.j($APP.F),g=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));return new $APP.Ch($APP.Zg.A("cljs.analyzer","build-dot-form"),function(l){return mRa(l)},$APP.xj,g,a,b,c,d)}();
ZE.F(null,new $APP.H(null,3,5,$APP.I,[XE,jRa,$APP.Ec],null),function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);$APP.x.B(a,2,null);return new $APP.f(null,3,[nRa,YXb,YE,b,UE,$APP.z($APP.Zg.j($APP.Ag(c).substring(1)),$APP.ed(c))],null)});ZE.F(null,new $APP.H(null,3,5,$APP.I,[XE,jRa,lRa],null),function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);throw Error(["Cannot provide arguments ",$APP.m.j(a)," on property access ",$APP.m.j(b)].join(""));});
ZE.F(null,new $APP.H(null,3,5,$APP.I,[XE,kRa,XE],null),function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return pRa(b,c,a)});ZE.F(null,new $APP.H(null,3,5,$APP.I,[XE,kRa,$APP.Ec],null),function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return pRa(b,c,a)});ZE.F(null,new $APP.H(null,3,5,$APP.I,[XE,lRa,$APP.Ec],null),function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);$APP.x.B(a,2,null);return pRa(b,$APP.u(c),$APP.Fc(c))});
ZE.F(null,$APP.xj,function(a){throw Error(["Unknown dot form of ",$APP.m.j($APP.Kn.A($APP.$h,a))," with classification ",$APP.m.j(mRa(a))].join(""));});pF.F(null,$APP.$h,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a);a=$APP.u(d);d=$APP.w(d);var g=$APP.r(d);d=$APP.u(g);g=$APP.w(g);var l=LE;LE=$APP.Yd(null,LE);try{return vRa(b,a,d,g,c)}finally{LE=l}});
var ZY=function ZY(a,b){var d=b.indexOf("~{");if(-1===d)return new $APP.D(null,b,null,1,null);var g=b.indexOf("}",d),l=$APP.R.j(MPa(a,$APP.Zg.j($APP.Og.B(b,2+d,g))));return new $APP.de(null,function(){var n=$APP.Og.B(b,0,d);var p=$APP.Og.A(b,g+1);p=ZY.A?ZY.A(a,p):ZY.call(null,a,p);return $APP.Yd(n,$APP.Yd(l,p))},null,null)},eF=function eF(a){var c=a.indexOf("~{");if(-1===c)return new $APP.D(null,a,null,1,null);var d=a.indexOf("}",c);return new $APP.de(null,function(){var g=$APP.Og.B(a,0,c);var l=
$APP.Og.A(a,d+1);l=eF.j?eF.j(l):eF.call(null,l);return $APP.Yd(g,l)},null,null)},xRa=new $APP.ug(null,new $APP.f(null,4,[$APP.gy,"null",$APP.xv,"null",$APP.my,"null",$APP.Yu,"null"],null),null),zRa=new $APP.ug(null,new $APP.f(null,10,[$APP.wv,"null",$APP.Yza,"null",$APP.Sza,"null",x0b,"null",$APP.Px,"null",$APP.gqa,"null",$APP.Kva,"null",$APP.UAa,"null",$APP.mua,"null",$APP.pxa,"null"],null),null);
pF.F(null,$APP.Wh,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a);a=$APP.u(d);d=$APP.w(d);if("string"!==typeof a)throw cE(b,"Invalid js* form");if(null!=d){a:{var g=LE;LE=$APP.Yd(null,LE);try{var l=FRa(b,a,d,c);break a}finally{LE=g}l=void 0}return l}l=$APP.Je.A($APP.m,ZY(b,a));a=wRa(c);g=$APP.ed(c);d=dF.j(g);g=cF.j(g);return new $APP.f(null,7,[$APP.$x,$APP.qE,$APP.Vl,b,$APP.Nw,c,$APP.dqa,l,$APP.sj,a,dF,d,cF,g],null)});
var lF=function lF(a){a=$APP.qe(a);var c=$APP.C.A(a,$APP.$x);switch(c instanceof $APP.E?c.ga:null){case "var":case "local":if(rPa($APP.Zg.j($APP.Ag($APP.R.j(a))))){var d=$APP.Ag($APP.R.j(a)),g=d.lastIndexOf(".");c=$APP.z($APP.Zg.A($APP.ae($APP.R.j(a)),$APP.Og.B(d,0,g)),$APP.ed($APP.Nw.j(a)));d=$APP.Zg.j($APP.Og.A(d,g+1));g=$APP.Vl.j(a);var l=new $APP.D(null,$APP.$h,new $APP.D(null,c,new $APP.D(null,d,null,1,null),2,null),3,null);c=$APP.am($APP.am($APP.Oi.A($APP.rg.C(a,$APP.R,c,$APP.y([$APP.Nw,c])),
$APP.sj),new $APP.H(null,2,5,$APP.I,[$APP.Wu,$APP.R],null),c),new $APP.H(null,2,5,$APP.I,[$APP.Vl,IE],null),$APP.Bk);c=lF.j?lF.j(c):lF.call(null,c);return new $APP.f(null,7,[$APP.$x,tRa,$APP.Vl,g,$APP.Nw,l,YE,c,UE,d,$APP.sj,$APP.sj.j(a),JD,new $APP.H(null,1,5,$APP.I,[YE],null)],null)}return a;default:return a}},ZRa=new $APP.bh(function(){return $APP.C.A(ZNa(),ovb)},null),Oec=function(){var a=new $APP.f(null,2,[tjb,function(c){return ARa($APP.u(c))&&$APP.Ge(yRa,$APP.Fc(c))},Vhb,pbc],null),b=new $APP.f(null,
2,[tjb,function(c){return ARa($APP.u(c))&&$APP.Ge(yRa,$APP.zg($APP.Fc(c)))},Vhb,pbc],null);return new $APP.f(null,4,[Zeb,a,mXb,b,N3b,a,ebb,b],null)}(),xSa=new $APP.H(null,3,5,$APP.I,[function Pec(a,b,c){b=$APP.qe(b);var g=$APP.C.A(b,$APP.sj);if(null==g||$APP.Uc.A($APP.gx,g)){if($APP.Uc.A($APP.Fk,$APP.$x.j(b)))return $APP.Fj.B(b,$APP.Mm,function(l){return $APP.Lf.B($APP.sf,$APP.Vg.j(function(n){return Pec.B?Pec.B(a,n,c):Pec.call(null,a,n,c)}),l)});g=FE(a,b);return null==g?b:$APP.rg.B(b,$APP.sj,g)}return b},
function(a,b){if(a=mOa(b))a=MD.j($APP.em.j(b)),a=$APP.Uc.A($APP.Oi.A($APP.Nr.j(a),$APP.Vl),$APP.Oi.A($APP.tr.j(a),$APP.Vl));if(a&&kOa(EE.j(MD.j($APP.em.j(b))))){a=$APP.u($APP.Tl.j(b));var c=$APP.qe(a);a=$APP.C.A(c,LD);var d=$APP.C.A(c,$APP.R);c=$APP.Vl.j(b);var g=new $APP.H(null,3,5,$APP.I,["((",") \x26\x26 (","))"],null),l=$APP.I,n=$APP.am(EE.j(MD.j($APP.em.j(b))),new $APP.H(null,2,5,$APP.I,[$APP.Vl,IE],null),$APP.Bk);d=ID(n,new $APP.H(null,1,5,$APP.I,[pOa(d)],null),null);b=new $APP.f(null,7,[$APP.$x,
$APP.qE,$APP.Vl,c,ERa,g,$APP.Wj,new $APP.H(null,2,5,l,[a,d],null),$APP.Nw,$APP.Nw.j(b),JD,new $APP.H(null,1,5,$APP.I,[$APP.Wj],null),$APP.sj,$APP.wv],null)}else{if(a=mOa(b))a=MD.j($APP.em.j(b)),a=$APP.Uc.A($APP.Oi.A($APP.Nr.j(a),$APP.Vl),$APP.Oi.A(EE.j(a),$APP.Vl));a&&kOa($APP.tr.j(MD.j($APP.em.j(b))))&&(a=$APP.u($APP.Tl.j(b)),c=$APP.qe(a),a=$APP.C.A(c,LD),d=$APP.C.A(c,$APP.R),c=$APP.Vl.j(b),g=new $APP.H(null,3,5,$APP.I,["((",") || (","))"],null),l=$APP.I,n=$APP.am($APP.tr.j(MD.j($APP.em.j(b))),new $APP.H(null,
2,5,$APP.I,[$APP.Vl,IE],null),$APP.Bk),d=ID(n,new $APP.H(null,1,5,$APP.I,[pOa(d)],null),null),b=new $APP.f(null,7,[$APP.$x,$APP.qE,$APP.Vl,c,ERa,g,$APP.Wj,new $APP.H(null,2,5,l,[a,d],null),$APP.Nw,$APP.Nw.j(b),JD,new $APP.H(null,1,5,$APP.I,[$APP.Wj],null),$APP.sj,$APP.wv],null))}return b},function(a,b){b=$APP.qe(b);var c=$APP.C.A(b,$APP.$x);if(!HRa(b)&&$APP.$d(PRa,c)){var d=$APP.Dd(Oec,$APP.R.j($APP.Wu.j($APP.Fk.j(b))));if(null!=d){c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var g=$APP.qe(d);d=$APP.C.A(g,
tjb);g=$APP.C.A(g,Vhb);var l=$APP.Fl.A($APP.sj,$APP.Wj.j(b));$APP.k(d.j?d.j(l):d.call(null,l))||$D(g,a,new $APP.f(null,2,[$APP.R,c,CRa,l],null))}}return GRa(b)}],null);$APP.IEa={};var $Y=function $Y(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return $Y.C(arguments[0],arguments[1],c)};
$Y.C=function(a,b,c){c=$APP.qe(c);a=$APP.C.A(c,$APP.Su);c=$APP.C.A(c,GG);b=$APP.rg.B(b,zX,!0);return $APP.Bd(b,$APP.Gra)?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Rh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.wl,null,1,null),new $APP.D(null,$APP.Gra,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,a,null,1,null),new $APP.D(null,c,null,1,null)])))):a};$Y.G=2;$Y.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};
var ASa=$APP.Vg.A($APP.Hl.B($APP.Zg,$APP.m,$APP.Md),$APP.Hj.A(97,123)),aZ=function aZ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=4<c.length?new $APP.Bc(c.slice(4),0,null):null;return aZ.C(arguments[0],arguments[1],arguments[2],arguments[3],c)};
aZ.C=function(a,b,c,d,g){$APP.rg.B(b,zX,!0);b=$APP.od(d)?d:new $APP.H(null,1,5,$APP.I,[d],null);a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);var l=$APP.k(b)?new $APP.H(null,3,5,$APP.I,[NX,a,b],null):new $APP.H(null,2,5,$APP.I,[fI,a],null);d="string"===typeof $APP.u(g)?["generic ",$APP.m.j(c),".\n\n",$APP.m.j($APP.u(g))].join(""):["generic ",$APP.m.j(c)].join("");g="string"===typeof $APP.u(g)?$APP.w(g):g;var n=$APP.md($APP.u(g))?new $APP.H(null,2,5,$APP.I,[$APP.u(g),$APP.w(g)],null):new $APP.H(null,2,
5,$APP.I,[$APP.F,g],null);g=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);var p=$Y.C(GG,$APP.E,$APP.y([$APP.Su,gF]));l=$APP.rg.C(g,XH,l,$APP.y([$APP.R,$APP.R.A(g,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,c,null,1,null)))))]));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Qh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hCa,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null),new $APP.D(null,$APP.Je.A($APP.Ik,
$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.U,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,BSa(a,b),null,1,null)))),null,1,null))))),null,1,null),new $APP.D(null,cob,null,1,null),n])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Km,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,p,null,1,null))))),null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,
jub,null,1,null))))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,l,null,1,null),new $APP.D(null,jub,null,1,null)))),null,1,null)])))),null,1,null)]))))};aZ.G=4;aZ.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);var g=$APP.w(d);d=$APP.u(g);g=$APP.w(g);return this.C(b,a,c,d,g)};var tF=BigInt(0),xF=BigInt(1),Qec=BigInt(10),vF=-xF;sF.prototype.valueOf=function(){return uF.j?uF.j(this):uF.call(null,this)};sF.prototype.toString=function(){return[$APP.m.j(this.n),"/",$APP.m.j(this.d)].join("")};sF.prototype.ka=function(){return $APP.Lb(this.n)^$APP.Lb(this.d)};sF.prototype.Tb=function(a,b){return b instanceof sF?ISa.A?ISa.A(this,b):ISa.call(null,this,b):$APP.Uc.A("bigint",$APP.la(b))?$APP.Ed(this.n,this.d*b):$APP.Oa(this,b.valueOf())};var JSa=new sF(xF,xF),Rec=/(-?\d+)(\.(\d+))?([Ee]([+-]\d+))?/;NSa._=!0;zF._=function(){return!1};var JP=function JP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return JP.C(c)};JP.C=function(a){return $APP.Fl.A(BF,a)};JP.G=0;JP.K=function(a){return this.C($APP.r(a))};var SSa=$APP.kh.j($APP.F);$APP.hu.A($APP.Xd,YR);$APP.hu.A($APP.Bc,YR);$APP.hu.A($APP.H,YR);$APP.hu.A($APP.de,YR);$APP.hu.A($APP.D,YR);$APP.hu.A($APP.Gg,YR);$APP.hu.A(GY,EG);$APP.hu.A(EG,DG);$APP.hu.A(CT,DG);
$APP.hu.A(DG,TM);$APP.hu.A(TM,FF);$APP.hu.A(Number,DG);$APP.hu.A(BigInt,EG);$APP.hu.A($APP.za,EG);$APP.hu.A($APP.qa,EG);NSa.number=!0;zF.number=function(){return!0};AF.number=!0;BF.number=function(a){var b=Number.isInteger(a);return $APP.k($APP.k(b)?Math.abs(a)<Number.MAX_SAFE_INTEGER:b)?GY:CT};AF["boolean"]=!0;BF["boolean"]=function(a){return $APP.hb(a)};AF["null"]=!0;BF["null"]=function(){return null};AF._=!0;BF._=function(a){return $APP.Ti.A(a,$APP.hb(a))};
var fG,Sec=$APP.kh.j($APP.F),Tec=$APP.kh.j($APP.F),Uec=$APP.kh.j($APP.F),Vec=$APP.kh.j($APP.F),Wec=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));fG=new $APP.Ch($APP.Zg.A("emmy.value","\x3d"),JP,$APP.xj,Wec,Sec,Tec,Uec,Vec);fG.F(null,new $APP.H(null,2,5,$APP.I,[TM,TM],null),function(a,b){return a===b});fG.F(null,new $APP.H(null,2,5,$APP.I,[YR,YR],null),function(a,b){var c=fG.A($APP.Tc(a),$APP.Tc(b));return $APP.k(c)?$APP.Ge($APP.rd,$APP.Vg.B(fG,a,b)):c});
fG.F(null,$APP.xj,function(a,b){return $APP.vh(BF(a),TM)||$APP.vh(BF(b),TM)?!1:$APP.Uc.A(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[GY,BigInt],null),function(a,b){return a==b});fG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,GY],null),function(a,b){return a==b});
for(var bZ=$APP.r(new $APP.H(null,5,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.qa,$APP.za,aOa],null),new $APP.H(null,3,5,$APP.I,[GY,$APP.za,aOa],null),new $APP.H(null,3,5,$APP.I,[GY,$APP.qa,bOa],null),new $APP.H(null,3,5,$APP.I,[$APP.qa,BigInt,wD],null),new $APP.H(null,3,5,$APP.I,[$APP.za,BigInt,wD],null)],null)),cZ=null,dZ=0,eZ=0;;)if(eZ<dZ){var fZ=cZ.aa(null,eZ),Xec=$APP.x.B(fZ,0,null),Yec=$APP.x.B(fZ,1,null),Zec=$APP.x.B(fZ,2,null);fG.F(null,new $APP.H(null,2,5,$APP.I,[Xec,Yec],null),function(a,
b,c,d,g,l,n,p){return function(v,t){return $APP.Uc.A(p.j?p.j(v):p.call(null,v),t)}}(bZ,cZ,dZ,eZ,fZ,Xec,Yec,Zec));fG.F(null,new $APP.H(null,2,5,$APP.I,[Yec,Xec],null),function(a,b,c,d,g,l,n,p){return function(v,t){return $APP.Uc.A(v,p.j?p.j(t):p.call(null,t))}}(bZ,cZ,dZ,eZ,fZ,Xec,Yec,Zec));eZ+=1}else{var $ec=$APP.r(bZ);if($ec){var gZ=$ec;if($APP.pd(gZ)){var afc=$APP.lc(gZ),bfc=$APP.mc(gZ),cfc=afc,dfc=$APP.Tc(afc);bZ=bfc;cZ=cfc;dZ=dfc}else{var hZ=$APP.u(gZ),efc=$APP.x.B(hZ,0,null),ffc=$APP.x.B(hZ,1,
null),gfc=$APP.x.B(hZ,2,null);fG.F(null,new $APP.H(null,2,5,$APP.I,[efc,ffc],null),function(a,b,c,d,g,l,n,p){return function(v,t){return $APP.Uc.A(p.j?p.j(v):p.call(null,v),t)}}(bZ,cZ,dZ,eZ,hZ,efc,ffc,gfc,gZ,$ec));fG.F(null,new $APP.H(null,2,5,$APP.I,[ffc,efc],null),function(a,b,c,d,g,l,n,p){return function(v,t){return $APP.Uc.A(v,p.j?p.j(t):p.call(null,t))}}(bZ,cZ,dZ,eZ,hZ,efc,ffc,gfc,gZ,$ec));bZ=$APP.w(gZ);cZ=null;dZ=0}eZ=0}else break}
fG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.equals(b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.equals(b)});$APP.Kb.number=function(a,b){return"number"===typeof b?a===b:GF(b)?fG.A(a,b.valueOf()):!1};$APP.za.prototype.Y=function(a,b){return $APP.Uc.A($APP.za,$APP.hb(b))?this.equals(b):fG.A(this,b.valueOf())};$APP.qa.prototype.Y=function(a,b){return $APP.Uc.A($APP.qa,$APP.hb(b))?this.equals(b):fG.A(this,b.valueOf())};
$APP.e=BigInt.prototype;$APP.e.ke=$APP.xc;$APP.e.ka=function(){return $APP.yc(this.toString(16))};$APP.e.Y=function(a,b){a=b.valueOf();return $Na(a)?this==a:fG.A(this,a)};$APP.e.Oa=$APP.xc;$APP.e.ea=function(a,b){a=(0>this?-this:this)<Number.MAX_SAFE_INTEGER?$APP.m.j(this):['"',$APP.m.j(this),'"'].join("");return $APP.Sg(b,$APP.y(["#emmy/bigint ",a]))};$APP.qa.prototype.ke=$APP.xc;$APP.qa.prototype.ka=function(){return this.hb()};$APP.qa.prototype.valueOf=function(){return this.toNumber()};
$APP.za.prototype.ke=$APP.xc;$APP.za.prototype.ka=function(){return $APP.yc(this.toString(16))};$APP.za.prototype.valueOf=function(){return this.toNumber()};$APP.ic.number=!0;$APP.jc.number=function(a,b){var c=b.valueOf();if(DF(c))return $APP.Oa(a,c);throw Error(["Cannot compare ",$APP.m.j(a)," to ",$APP.m.j(b)].join(""));};BigInt.prototype.qc=$APP.xc;
BigInt.prototype.Tb=function(a,b){a=b.valueOf();if(DF(a))return $APP.Oa(this,a);throw Error(["Cannot compare ",$APP.m.j(this)," to ",$APP.m.j(b)].join(""));};$APP.za.prototype.qc=$APP.xc;$APP.za.prototype.Tb=function(a,b){a=b.valueOf();if(a instanceof $APP.za)return this.compare(a);if(DF(a))return $APP.Oa(this,a);throw Error(["Cannot compare ",$APP.m.j(this)," to ",$APP.m.j(b)].join(""));};$APP.qa.prototype.qc=$APP.xc;
$APP.qa.prototype.Tb=function(a,b){a=b.valueOf();if(a instanceof $APP.qa)return this.compare(a);if(DF(a))return $APP.Oa(this,a);throw Error(["Cannot compare ",$APP.m.j(this)," to ",$APP.m.j(b)].join(""));};BigInt.prototype.nd=function(){return!0};$APP.za.prototype.nd=function(){return!0};$APP.qa.prototype.nd=function(){return!0};BigInt.prototype.rb=function(){return BigInt};$APP.za.prototype.rb=function(){return $APP.za};$APP.qa.prototype.rb=function(){return $APP.qa};var PSa=Symbol.for("Symbol.__emmy_meta__");
$APP.Gb["function"]=!0;$APP.Hb["function"]=function(a){a=$APP.Na(a,PSa);return $APP.k(a)?a:null};var JF=2*Math.PI;var KF,hfc=$APP.kh.j($APP.F),ifc=$APP.kh.j($APP.F),jfc=$APP.kh.j($APP.F),kfc=$APP.kh.j($APP.F),lfc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));KF=new $APP.Ch($APP.Zg.A("emmy.generic","zero?"),JP,$APP.xj,lfc,hfc,ifc,jfc,kfc);KF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,$APP.zv],null);return b.j?b.j(a):b.call(null,a)});
var sG,mfc=$APP.kh.j($APP.F),nfc=$APP.kh.j($APP.F),ofc=$APP.kh.j($APP.F),pfc=$APP.kh.j($APP.F),qfc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));sG=new $APP.Ch($APP.Zg.A("emmy.generic","one?"),JP,$APP.xj,qfc,mfc,nfc,ofc,pfc);sG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,D$b],null);return b.j?b.j(a):b.call(null,a)});
var iZ,rfc=$APP.kh.j($APP.F),sfc=$APP.kh.j($APP.F),tfc=$APP.kh.j($APP.F),ufc=$APP.kh.j($APP.F),vfc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));iZ=new $APP.Ch($APP.Zg.A("emmy.generic","identity?"),JP,$APP.xj,vfc,rfc,sfc,tfc,ufc);iZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,jS],null);return b.j?b.j(a):b.call(null,a)});
var tG,wfc=$APP.kh.j($APP.F),xfc=$APP.kh.j($APP.F),yfc=$APP.kh.j($APP.F),zfc=$APP.kh.j($APP.F),Afc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));tG=new $APP.Ch($APP.Zg.A("emmy.generic","zero-like"),JP,$APP.xj,Afc,wfc,xfc,yfc,zfc);tG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,Bcc],null);return b.j?b.j(a):b.call(null,a)});
var NF,Bfc=$APP.kh.j($APP.F),Cfc=$APP.kh.j($APP.F),Dfc=$APP.kh.j($APP.F),Efc=$APP.kh.j($APP.F),Ffc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));NF=new $APP.Ch($APP.Zg.A("emmy.generic","one-like"),JP,$APP.xj,Ffc,Bfc,Cfc,Dfc,Efc);NF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,Ypb],null);return b.j?b.j(a):b.call(null,a)});
var jZ,Gfc=$APP.kh.j($APP.F),Hfc=$APP.kh.j($APP.F),Ifc=$APP.kh.j($APP.F),Jfc=$APP.kh.j($APP.F),Kfc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));jZ=new $APP.Ch($APP.Zg.A("emmy.generic","identity-like"),JP,$APP.xj,Kfc,Gfc,Hfc,Ifc,Jfc);jZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,k$b],null);return b.j?b.j(a):b.call(null,a)});
var TF,Lfc=$APP.kh.j($APP.F),Mfc=$APP.kh.j($APP.F),Nfc=$APP.kh.j($APP.F),Ofc=$APP.kh.j($APP.F),Pfc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));TF=new $APP.Ch($APP.Zg.A("emmy.generic","exact?"),JP,$APP.xj,Pfc,Lfc,Mfc,Nfc,Ofc);TF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,vvb],null);return b.j?b.j(a):b.call(null,a)});
var aG,Qfc=$APP.kh.j($APP.F),Rfc=$APP.kh.j($APP.F),Sfc=$APP.kh.j($APP.F),Tfc=$APP.kh.j($APP.F),Ufc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));aG=new $APP.Ch($APP.Zg.A("emmy.generic","freeze"),JP,$APP.xj,Ufc,Qfc,Rfc,Sfc,Tfc);aG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,U1b],null);return b.j?b.j(a):b.call(null,a)});aG.F(null,new $APP.H(null,1,5,$APP.I,[String],null),function(a){return a});
aG.F(null,new $APP.H(null,1,5,$APP.I,[null],null),function(){return null});var eH,Vfc=$APP.kh.j($APP.F),Wfc=$APP.kh.j($APP.F),Xfc=$APP.kh.j($APP.F),Yfc=$APP.kh.j($APP.F),Zfc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));eH=new $APP.Ch($APP.Zg.A("emmy.generic","add"),JP,$APP.xj,Zfc,Vfc,Wfc,Xfc,Yfc);
eH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[$APP.R,$APP.Fv,cN,function(){return 1},dN,function(){return 1},XH,new $APP.H(null,2,5,$APP.I,[fI,2],null)],null);return b.j?b.j(a):b.call(null,a)});
var kG=function kG(a){switch(arguments.length){case 0:return kG.J();case 1:return kG.j(arguments[0]);case 2:return kG.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return kG.C(arguments[0],arguments[1],c)}};kG.J=function(){return 0};kG.j=function(a){return a};kG.A=function(a,b){return $APP.k(LF(a))?b:$APP.k(LF(b))?a:eH.A(a,b)};kG.C=function(a,b,c){return $APP.Id.B(kG,kG.A(a,b),c)};
kG.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};kG.G=2;var PF,$fc=$APP.kh.j($APP.F),agc=$APP.kh.j($APP.F),bgc=$APP.kh.j($APP.F),cgc=$APP.kh.j($APP.F),dgc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));PF=new $APP.Ch($APP.Zg.A("emmy.generic","negate"),JP,$APP.xj,dgc,$fc,agc,bgc,cgc);
PF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[$APP.R,$APP.Gv,cN,function(){return-1},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null)],null);return b.j?b.j(a):b.call(null,a)});var yG,egc=$APP.kh.j($APP.F),fgc=$APP.kh.j($APP.F),ggc=$APP.kh.j($APP.F),hgc=$APP.kh.j($APP.F),igc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));yG=new $APP.Ch($APP.Zg.A("emmy.generic","sub"),JP,$APP.xj,igc,egc,fgc,ggc,hgc);
yG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[$APP.R,$APP.Gv,cN,function(){return 1},dN,function(){return-1},XH,new $APP.H(null,2,5,$APP.I,[fI,2],null)],null);return b.j?b.j(a):b.call(null,a)});yG.F(null,$APP.xj,function(a,b){return eH.A(a,PF.j(b))});
var RF=function RF(a){switch(arguments.length){case 0:return RF.J();case 1:return RF.j(arguments[0]);case 2:return RF.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return RF.C(arguments[0],arguments[1],c)}};RF.J=function(){return 0};RF.j=function(a){return PF.j(a)};RF.A=function(a,b){return $APP.k(LF(b))?a:$APP.k(LF(a))?PF.j(b):yG.A(a,b)};RF.C=function(a,b,c){return RF.A(a,$APP.Je.B(kG,b,c))};
RF.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};RF.G=2;var MF,jgc=$APP.kh.j($APP.F),kgc=$APP.kh.j($APP.F),lgc=$APP.kh.j($APP.F),mgc=$APP.kh.j($APP.F),ngc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));MF=new $APP.Ch($APP.Zg.A("emmy.generic","mul"),JP,$APP.xj,ngc,jgc,kgc,lgc,mgc);
MF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[$APP.R,$APP.Ev,cN,function(c,d){return d},dN,function(c){return c},XH,new $APP.H(null,2,5,$APP.I,[fI,2],null)],null);return b.j?b.j(a):b.call(null,a)});
var iG=function iG(a){switch(arguments.length){case 0:return iG.J();case 1:return iG.j(arguments[0]);case 2:return iG.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return iG.C(arguments[0],arguments[1],c)}};iG.J=function(){return 1};iG.j=function(a){return a};
iG.A=function(a,b){var c=zF(a),d=zF(b);return $APP.k(c?KF.j(a):c)?tG.j(b):$APP.k(d?KF.j(b):d)?tG.j(a):$APP.k(c?sG.j(a):c)?b:$APP.k(d?sG.j(b):d)?a:MF.A(a,b)};iG.C=function(a,b,c){return $APP.Id.B(iG,iG.A(a,b),c)};iG.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};iG.G=2;var OF,ogc=$APP.kh.j($APP.F),pgc=$APP.kh.j($APP.F),qgc=$APP.kh.j($APP.F),rgc=$APP.kh.j($APP.F),sgc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
OF=new $APP.Ch($APP.Zg.A("emmy.generic","invert"),JP,$APP.xj,sgc,ogc,pgc,qgc,rgc);OF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[$APP.R,$APP.rj,cN,function(c){c=lG.j?lG.j(c):lG.call(null,c);return zG.A?zG.A(-1,c):zG.call(null,-1,c)},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null)],null);return b.j?b.j(a):b.call(null,a)});var tgc=!1;OF.F(null,$APP.xj,function(a){var b=tgc;tgc=!0;try{return zG.A?zG.A(1,a):zG.call(null,1,a)}finally{tgc=b}});
var zG,ugc=$APP.kh.j($APP.F),vgc=$APP.kh.j($APP.F),wgc=$APP.kh.j($APP.F),xgc=$APP.kh.j($APP.F),ygc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));zG=new $APP.Ch($APP.Zg.A("emmy.generic","div"),JP,$APP.xj,ygc,ugc,vgc,wgc,xgc);
zG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[$APP.R,$APP.rj,cN,function(c,d){return zG.A(1,d)},dN,function(c,d){return zG.A(PF.j(c),lG.j?lG.j(d):lG.call(null,d))},XH,new $APP.H(null,2,5,$APP.I,[fI,2],null)],null);return b.j?b.j(a):b.call(null,a)});zG.F(null,$APP.xj,function(a,b){if($APP.k(tgc))throw $APP.Zi.A("No implementation of [[invert]] or [[div]].",new $APP.f(null,2,[$APP.ky,JY,$APP.Wj,new $APP.H(null,2,5,$APP.I,[a,b],null)],null));return MF.A(a,OF.j(b))});
var QF=function QF(a){switch(arguments.length){case 0:return QF.J();case 1:return QF.j(arguments[0]);case 2:return QF.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return QF.C(arguments[0],arguments[1],c)}};QF.J=function(){return 1};QF.j=function(a){return OF.j(a)};QF.A=function(a,b){var c=(c=EF(b))?sG.j(b):c;return $APP.k(c)?a:zG.A(a,b)};QF.C=function(a,b,c){return QF.A(a,$APP.Je.B(iG,b,c))};
QF.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};QF.G=2;var iM,zgc=$APP.kh.j($APP.F),Agc=$APP.kh.j($APP.F),Bgc=$APP.kh.j($APP.F),Cgc=$APP.kh.j($APP.F),Dgc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));iM=new $APP.Ch($APP.Zg.A("emmy.generic","exact-divide"),JP,$APP.xj,Dgc,zgc,Agc,Bgc,Cgc);
iM.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,G6b],null);return b.j?b.j(a):b.call(null,a)});var oG,Egc=$APP.kh.j($APP.F),Fgc=$APP.kh.j($APP.F),Ggc=$APP.kh.j($APP.F),Hgc=$APP.kh.j($APP.F),Igc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));oG=new $APP.Ch($APP.Zg.A("emmy.generic","exp"),JP,$APP.xj,Igc,Egc,Fgc,Ggc,Hgc);
oG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,oG,XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,zJ],null);return b.j?b.j(a):b.call(null,a)});var kZ,Jgc=$APP.kh.j($APP.F),Kgc=$APP.kh.j($APP.F),Lgc=$APP.kh.j($APP.F),Mgc=$APP.kh.j($APP.F),Ngc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));kZ=new $APP.Ch($APP.Zg.A("emmy.generic","exp2"),JP,$APP.xj,Ngc,Jgc,Kgc,Lgc,Mgc);
kZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,wQb],null);return b.j?b.j(a):b.call(null,a)});kZ.F(null,$APP.xj,function(a){return rI.A?rI.A(2,a):rI.call(null,2,a)});var lZ,Ogc=$APP.kh.j($APP.F),Pgc=$APP.kh.j($APP.F),Qgc=$APP.kh.j($APP.F),Rgc=$APP.kh.j($APP.F),Sgc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));lZ=new $APP.Ch($APP.Zg.A("emmy.generic","exp10"),JP,$APP.xj,Sgc,Ogc,Pgc,Qgc,Rgc);
lZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,jdc],null);return b.j?b.j(a):b.call(null,a)});lZ.F(null,$APP.xj,function(a){return rI.A?rI.A(10,a):rI.call(null,10,a)});var pG,Tgc=$APP.kh.j($APP.F),Ugc=$APP.kh.j($APP.F),Vgc=$APP.kh.j($APP.F),Wgc=$APP.kh.j($APP.F),Xgc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));pG=new $APP.Ch($APP.Zg.A("emmy.generic","log"),JP,$APP.xj,Xgc,Tgc,Ugc,Vgc,Wgc);
pG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,OF,XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,BJ],null);return b.j?b.j(a):b.call(null,a)});var mZ,Ygc=$APP.kh.j($APP.F),Zgc=$APP.kh.j($APP.F),$gc=$APP.kh.j($APP.F),ahc=$APP.kh.j($APP.F),bhc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));mZ=new $APP.Ch($APP.Zg.A("emmy.generic","log2"),JP,$APP.xj,bhc,Ygc,Zgc,$gc,ahc);
mZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,Vtb],null);return b.j?b.j(a):b.call(null,a)});var chc=Math.log(2);mZ.F(null,$APP.xj,function(a){return zG.A(pG.j(a),chc)});var nZ,dhc=$APP.kh.j($APP.F),ehc=$APP.kh.j($APP.F),fhc=$APP.kh.j($APP.F),ghc=$APP.kh.j($APP.F),hhc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
nZ=new $APP.Ch($APP.Zg.A("emmy.generic","log10"),JP,$APP.xj,hhc,dhc,ehc,fhc,ghc);nZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,kob],null);return b.j?b.j(a):b.call(null,a)});var ihc=Math.log(10);nZ.F(null,$APP.xj,function(a){return zG.A(pG.j(a),ihc)});var rI,jhc=$APP.kh.j($APP.F),khc=$APP.kh.j($APP.F),lhc=$APP.kh.j($APP.F),mhc=$APP.kh.j($APP.F),nhc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
rI=new $APP.Ch($APP.Zg.A("emmy.generic","expt"),JP,$APP.xj,nhc,jhc,khc,lhc,mhc);rI.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[cN,function(c,d){return MF.A(d,rI.A(c,yG.A(d,1)))},dN,function(c,d){var g=(g=EF(c))?KF.j(c):g;return $APP.k(g)?EF(d)?$APP.eb(qG.j?qG.j(d):qG.call(null,d))?0:AD("Derivative undefined: expt"):0:MF.A(pG.j(c),rI.A(c,d))},XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,DJ],null);return b.j?b.j(a):b.call(null,a)});var WSa=100*MR;
rI.F(null,$APP.xj,function(a,b){return $APP.xd(b)?VSa(a,b):oG.j(MF.A(b,pG.j(a)))});var lG,ohc=$APP.kh.j($APP.F),phc=$APP.kh.j($APP.F),qhc=$APP.kh.j($APP.F),rhc=$APP.kh.j($APP.F),shc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));lG=new $APP.Ch($APP.Zg.A("emmy.generic","square"),JP,$APP.xj,shc,ohc,phc,qhc,rhc);
lG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return MF.A(2,c)},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,aT],null);return b.j?b.j(a):b.call(null,a)});lG.F(null,$APP.xj,function(a){return rI.A(a,2)});var oZ,thc=$APP.kh.j($APP.F),uhc=$APP.kh.j($APP.F),vhc=$APP.kh.j($APP.F),whc=$APP.kh.j($APP.F),xhc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
oZ=new $APP.Ch($APP.Zg.A("emmy.generic","cube"),JP,$APP.xj,xhc,thc,uhc,vhc,whc);oZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return MF.A(3,lG.j(c))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,tV],null);return b.j?b.j(a):b.call(null,a)});oZ.F(null,$APP.xj,function(a){return rI.A(a,3)});var jG,yhc=$APP.kh.j($APP.F),zhc=$APP.kh.j($APP.F),Ahc=$APP.kh.j($APP.F),Bhc=$APP.kh.j($APP.F),Chc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
jG=new $APP.Ch($APP.Zg.A("emmy.generic","sqrt"),JP,$APP.xj,Chc,yhc,zhc,Ahc,Bhc);jG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return OF.j(MF.A(jG.j(c),2))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,FJ],null);return b.j?b.j(a):b.call(null,a)});jG.F(null,$APP.xj,function(a){return oG.j(MF.A(zG.A(1,2),pG.j(a)))});
var qG,Dhc=$APP.kh.j($APP.F),Ehc=$APP.kh.j($APP.F),Fhc=$APP.kh.j($APP.F),Ghc=$APP.kh.j($APP.F),Hhc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));qG=new $APP.Ch($APP.Zg.A("emmy.generic","negative?"),JP,$APP.xj,Hhc,Dhc,Ehc,Fhc,Ghc);qG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,yX],null);return b.j?b.j(a):b.call(null,a)});qG.F(null,$APP.xj,function(a){return 0>$APP.Ed(a,tG.j(a))});
var mG,Ihc=$APP.kh.j($APP.F),Jhc=$APP.kh.j($APP.F),Khc=$APP.kh.j($APP.F),Lhc=$APP.kh.j($APP.F),Mhc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));mG=new $APP.Ch($APP.Zg.A("emmy.generic","infinite?"),JP,$APP.xj,Mhc,Ihc,Jhc,Khc,Lhc);mG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,$APP.aw],null);return b.j?b.j(a):b.call(null,a)});mG.F(null,$APP.xj,function(){return!1});
var hG,Nhc=$APP.kh.j($APP.F),Ohc=$APP.kh.j($APP.F),Phc=$APP.kh.j($APP.F),Qhc=$APP.kh.j($APP.F),Rhc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));hG=new $APP.Ch($APP.Zg.A("emmy.generic","abs"),JP,$APP.xj,Rhc,Nhc,Ohc,Phc,Qhc);hG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,$APP.Iu],null);return b.j?b.j(a):b.call(null,a)});
var pZ,Shc=$APP.kh.j($APP.F),Thc=$APP.kh.j($APP.F),Uhc=$APP.kh.j($APP.F),Vhc=$APP.kh.j($APP.F),Whc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));pZ=new $APP.Ch($APP.Zg.A("emmy.generic","floor"),JP,$APP.xj,Whc,Shc,Thc,Uhc,Vhc);pZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,bT],null);return b.j?b.j(a):b.call(null,a)});
pZ.F(null,$APP.xj,function(a){return $APP.k(qG.j(a))?yG.A(qZ.j?qZ.j(a):qZ.call(null,a),1):qZ.j?qZ.j(a):qZ.call(null,a)});var rZ,Xhc=$APP.kh.j($APP.F),Yhc=$APP.kh.j($APP.F),Zhc=$APP.kh.j($APP.F),$hc=$APP.kh.j($APP.F),aic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));rZ=new $APP.Ch($APP.Zg.A("emmy.generic","ceiling"),JP,$APP.xj,aic,Xhc,Yhc,Zhc,$hc);
rZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,jY],null);return b.j?b.j(a):b.call(null,a)});rZ.F(null,$APP.xj,function(a){return PF.j(pZ.j(PF.j(a)))});var qZ,bic=$APP.kh.j($APP.F),cic=$APP.kh.j($APP.F),dic=$APP.kh.j($APP.F),eic=$APP.kh.j($APP.F),fic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));qZ=new $APP.Ch($APP.Zg.A("emmy.generic","integer-part"),JP,$APP.xj,fic,bic,cic,dic,eic);
qZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,WV],null);return b.j?b.j(a):b.call(null,a)});var sZ,gic=$APP.kh.j($APP.F),hic=$APP.kh.j($APP.F),iic=$APP.kh.j($APP.F),jic=$APP.kh.j($APP.F),kic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));sZ=new $APP.Ch($APP.Zg.A("emmy.generic","fractional-part"),JP,$APP.xj,kic,gic,hic,iic,jic);
sZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,xW],null);return b.j?b.j(a):b.call(null,a)});sZ.F(null,$APP.xj,function(a){return yG.A(a,pZ.j(a))});var qI,lic=$APP.kh.j($APP.F),mic=$APP.kh.j($APP.F),nic=$APP.kh.j($APP.F),oic=$APP.kh.j($APP.F),pic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));qI=new $APP.Ch($APP.Zg.A("emmy.generic","quotient"),JP,$APP.xj,pic,lic,mic,nic,oic);
qI.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,lX],null);return b.j?b.j(a):b.call(null,a)});var lI,qic=$APP.kh.j($APP.F),ric=$APP.kh.j($APP.F),sic=$APP.kh.j($APP.F),tic=$APP.kh.j($APP.F),uic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));lI=new $APP.Ch($APP.Zg.A("emmy.generic","modulo"),JP,$APP.xj,uic,qic,ric,sic,tic);
lI.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,YX],null);return b.j?b.j(a):b.call(null,a)});lI.F(null,$APP.xj,function(a,b){return yG.A(a,MF.A(b,pZ.j(zG.A(a,b))))});var AG,vic=$APP.kh.j($APP.F),wic=$APP.kh.j($APP.F),xic=$APP.kh.j($APP.F),yic=$APP.kh.j($APP.F),zic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
AG=new $APP.Ch($APP.Zg.A("emmy.generic","remainder"),JP,$APP.xj,zic,vic,wic,xic,yic);AG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,eS],null);return b.j?b.j(a):b.call(null,a)});AG.F(null,$APP.xj,function(a,b){var c=zG.A(a,b);return $APP.Uc.A(qG.j(a),qG.j(b))?MF.A(b,yG.A(c,pZ.j(c))):MF.A(b,yG.A(c,rZ.j(c)))});
var wM,Aic=$APP.kh.j($APP.F),Bic=$APP.kh.j($APP.F),Cic=$APP.kh.j($APP.F),Dic=$APP.kh.j($APP.F),Eic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));wM=new $APP.Ch($APP.Zg.A("emmy.generic","gcd"),JP,$APP.xj,Eic,Aic,Bic,Cic,Dic);wM.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,iK],null);return b.j?b.j(a):b.call(null,a)});
var oM,Fic=$APP.kh.j($APP.F),Gic=$APP.kh.j($APP.F),Hic=$APP.kh.j($APP.F),Iic=$APP.kh.j($APP.F),Jic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));oM=new $APP.Ch($APP.Zg.A("emmy.generic","lcm"),JP,$APP.xj,Jic,Fic,Gic,Hic,Iic);oM.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,DV],null);return b.j?b.j(a):b.call(null,a)});
oM.F(null,$APP.xj,function(a,b){var c=wM.A(a,b);return $APP.k(KF.j(c))?c:hG.j(iG.A(iM.A(a,c),b))});var fO,Kic=$APP.kh.j($APP.F),Lic=$APP.kh.j($APP.F),Mic=$APP.kh.j($APP.F),Nic=$APP.kh.j($APP.F),Oic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));fO=new $APP.Ch($APP.Zg.A("emmy.generic","cos"),JP,$APP.xj,Oic,Kic,Lic,Mic,Nic);
fO.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(gO.j?gO.j(c):gO.call(null,c))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,sH],null);return b.j?b.j(a):b.call(null,a)});var gO,Pic=$APP.kh.j($APP.F),Qic=$APP.kh.j($APP.F),Ric=$APP.kh.j($APP.F),Sic=$APP.kh.j($APP.F),Tic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));gO=new $APP.Ch($APP.Zg.A("emmy.generic","sin"),JP,$APP.xj,Tic,Pic,Qic,Ric,Sic);
gO.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,fO,XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,kH],null);return b.j?b.j(a):b.call(null,a)});var tZ,Uic=$APP.kh.j($APP.F),Vic=$APP.kh.j($APP.F),Wic=$APP.kh.j($APP.F),Xic=$APP.kh.j($APP.F),Yic=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));tZ=new $APP.Ch($APP.Zg.A("emmy.generic","tan"),JP,$APP.xj,Yic,Uic,Vic,Wic,Xic);
tZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return OF.j(lG.j(fO.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,lK],null);return b.j?b.j(a):b.call(null,a)});tZ.F(null,$APP.xj,function(a){return zG.A(gO.j(a),fO.j(a))});var uZ,Zic=$APP.kh.j($APP.F),$ic=$APP.kh.j($APP.F),ajc=$APP.kh.j($APP.F),bjc=$APP.kh.j($APP.F),cjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
uZ=new $APP.Ch($APP.Zg.A("emmy.generic","cot"),JP,$APP.xj,cjc,Zic,$ic,ajc,bjc);uZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(lG.j(vZ.j?vZ.j(c):vZ.call(null,c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,MM],null);return b.j?b.j(a):b.call(null,a)});uZ.F(null,$APP.xj,function(a){return zG.A(fO.j(a),gO.j(a))});
var wZ,djc=$APP.kh.j($APP.F),ejc=$APP.kh.j($APP.F),fjc=$APP.kh.j($APP.F),gjc=$APP.kh.j($APP.F),hjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));wZ=new $APP.Ch($APP.Zg.A("emmy.generic","sec"),JP,$APP.xj,hjc,djc,ejc,fjc,gjc);wZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return MF.A(wZ.j(c),tZ.j(c))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,LM],null);return b.j?b.j(a):b.call(null,a)});wZ.F(null,$APP.xj,function(a){return OF.j(fO.j(a))});
var vZ,ijc=$APP.kh.j($APP.F),jjc=$APP.kh.j($APP.F),kjc=$APP.kh.j($APP.F),ljc=$APP.kh.j($APP.F),mjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));vZ=new $APP.Ch($APP.Zg.A("emmy.generic","csc"),JP,$APP.xj,mjc,ijc,jjc,kjc,ljc);vZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(MF.A(uZ.j(c),vZ.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,NM],null);return b.j?b.j(a):b.call(null,a)});vZ.F(null,$APP.xj,function(a){return OF.j(gO.j(a))});
var rG,njc=$APP.kh.j($APP.F),ojc=$APP.kh.j($APP.F),pjc=$APP.kh.j($APP.F),qjc=$APP.kh.j($APP.F),rjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));rG=new $APP.Ch($APP.Zg.A("emmy.generic","atan"),JP,$APP.xj,rjc,njc,ojc,pjc,qjc);
rG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[cN,function(){function c(l,n){return zG.A(n,eH.A(lG.j(n),lG.j(l)))}function d(l){return OF.j(eH.A(1,lG.j(l)))}var g=null;g=function(l,n){switch(arguments.length){case 1:return d.call(this,l);case 2:return c.call(this,l,n)}throw Error("Invalid arity: "+arguments.length);};g.j=d;g.A=c;return g}(),dN,function(c,d){return zG.A(PF.j(c),eH.A(lG.j(d),lG.j(c)))},XH,new $APP.H(null,3,5,$APP.I,[NX,1,2],null),$APP.R,hK],
null);return b.j?b.j(a):b.call(null,a)});var xZ,sjc=$APP.kh.j($APP.F),tjc=$APP.kh.j($APP.F),ujc=$APP.kh.j($APP.F),vjc=$APP.kh.j($APP.F),wjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));xZ=new $APP.Ch($APP.Zg.A("emmy.generic","asin"),JP,$APP.xj,wjc,sjc,tjc,ujc,vjc);
xZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return OF.j(jG.j(yG.A(1,lG.j(c))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,jK],null);return b.j?b.j(a):b.call(null,a)});xZ.F(null,$APP.xj,function(a){return rG.j(zG.A(a,jG.j(yG.A(1,lG.j(a)))))});var kO,xjc=$APP.kh.j($APP.F),yjc=$APP.kh.j($APP.F),zjc=$APP.kh.j($APP.F),Ajc=$APP.kh.j($APP.F),Bjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
kO=new $APP.Ch($APP.Zg.A("emmy.generic","acos"),JP,$APP.xj,Bjc,xjc,yjc,zjc,Ajc);kO.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(OF.j(jG.j(yG.A(1,lG.j(c)))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,kK],null);return b.j?b.j(a):b.call(null,a)});kO.F(null,$APP.xj,function(a){return rG.j(zG.A(jG.j(yG.A(1,lG.j(a))),a))});
var yZ,Cjc=$APP.kh.j($APP.F),Djc=$APP.kh.j($APP.F),Ejc=$APP.kh.j($APP.F),Fjc=$APP.kh.j($APP.F),Gjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));yZ=new $APP.Ch($APP.Zg.A("emmy.generic","acot"),JP,$APP.xj,Gjc,Cjc,Djc,Ejc,Fjc);yZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(OF.j(eH.A(1,lG.j(c))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,XS],null);return b.j?b.j(a):b.call(null,a)});
yZ.F(null,$APP.xj,function(a){return yG.A(QF.A(Math.PI,2),rG.j(a))});var zZ,Hjc=$APP.kh.j($APP.F),Ijc=$APP.kh.j($APP.F),Jjc=$APP.kh.j($APP.F),Kjc=$APP.kh.j($APP.F),Ljc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));zZ=new $APP.Ch($APP.Zg.A("emmy.generic","asec"),JP,$APP.xj,Ljc,Hjc,Ijc,Jjc,Kjc);
zZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return OF.j(MF.A(c,jG.j(yG.A(lG.j(c),1))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,$nb],null);return b.j?b.j(a):b.call(null,a)});zZ.F(null,$APP.xj,function(a){return rG.j(jG.j(yG.A(lG.j(a),1)))});var AZ,Mjc=$APP.kh.j($APP.F),Njc=$APP.kh.j($APP.F),Ojc=$APP.kh.j($APP.F),Pjc=$APP.kh.j($APP.F),Qjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
AZ=new $APP.Ch($APP.Zg.A("emmy.generic","acsc"),JP,$APP.xj,Qjc,Mjc,Njc,Ojc,Pjc);AZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(OF.j(MF.A(c,jG.j(yG.A(lG.j(c),1)))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,aib],null);return b.j?b.j(a):b.call(null,a)});AZ.F(null,$APP.xj,function(a){return rG.j(OF.j(jG.j(yG.A(lG.j(a),1))))});
var tH,Rjc=$APP.kh.j($APP.F),Sjc=$APP.kh.j($APP.F),Tjc=$APP.kh.j($APP.F),Ujc=$APP.kh.j($APP.F),Vjc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));tH=new $APP.Ch($APP.Zg.A("emmy.generic","cosh"),JP,$APP.xj,Vjc,Rjc,Sjc,Tjc,Ujc);tH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,vH,XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,uH],null);return b.j?b.j(a):b.call(null,a)});
tH.F(null,$APP.xj,function(a){return zG.A(eH.A(oG.j(a),oG.j(PF.j(a))),2)});var vH,Wjc=$APP.kh.j($APP.F),Xjc=$APP.kh.j($APP.F),Yjc=$APP.kh.j($APP.F),Zjc=$APP.kh.j($APP.F),$jc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));vH=new $APP.Ch($APP.Zg.A("emmy.generic","sinh"),JP,$APP.xj,$jc,Wjc,Xjc,Yjc,Zjc);
vH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,tH,XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,wH],null);return b.j?b.j(a):b.call(null,a)});vH.F(null,$APP.xj,function(a){return zG.A(yG.A(oG.j(a),oG.j(PF.j(a))),2)});var BZ,akc=$APP.kh.j($APP.F),bkc=$APP.kh.j($APP.F),ckc=$APP.kh.j($APP.F),dkc=$APP.kh.j($APP.F),ekc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
BZ=new $APP.Ch($APP.Zg.A("emmy.generic","tanh"),JP,$APP.xj,ekc,akc,bkc,ckc,dkc);BZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return yG.A(1,lG.j(BZ.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,oX],null);return b.j?b.j(a):b.call(null,a)});BZ.F(null,$APP.xj,function(a){a=oG.j(eH.A(a,a));return zG.A(yG.A(a,1),eH.A(a,1))});
var CZ,fkc=$APP.kh.j($APP.F),gkc=$APP.kh.j($APP.F),hkc=$APP.kh.j($APP.F),ikc=$APP.kh.j($APP.F),jkc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));CZ=new $APP.Ch($APP.Zg.A("emmy.generic","sech"),JP,$APP.xj,jkc,fkc,gkc,hkc,ikc);CZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(MF.A(CZ.j(c),BZ.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,sT],null);return b.j?b.j(a):b.call(null,a)});
CZ.F(null,$APP.xj,function(a){return zG.A(2,eH.A(oG.j(a),oG.j(PF.j(a))))});var DZ,kkc=$APP.kh.j($APP.F),lkc=$APP.kh.j($APP.F),mkc=$APP.kh.j($APP.F),nkc=$APP.kh.j($APP.F),okc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));DZ=new $APP.Ch($APP.Zg.A("emmy.generic","coth"),JP,$APP.xj,okc,kkc,lkc,mkc,nkc);
DZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(lG.j(EZ.j?EZ.j(c):EZ.call(null,c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,tW],null);return b.j?b.j(a):b.call(null,a)});DZ.F(null,$APP.xj,function(a){a=oG.j(eH.A(a,a));return zG.A(eH.A(a,1),yG.A(a,1))});var EZ,pkc=$APP.kh.j($APP.F),qkc=$APP.kh.j($APP.F),rkc=$APP.kh.j($APP.F),skc=$APP.kh.j($APP.F),tkc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
EZ=new $APP.Ch($APP.Zg.A("emmy.generic","csch"),JP,$APP.xj,tkc,pkc,qkc,rkc,skc);EZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(MF.A(DZ.j(c),EZ.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,eW],null);return b.j?b.j(a):b.call(null,a)});EZ.F(null,$APP.xj,function(a){return zG.A(2,yG.A(oG.j(a),oG.j(PF.j(a))))});
var FZ,ukc=$APP.kh.j($APP.F),vkc=$APP.kh.j($APP.F),wkc=$APP.kh.j($APP.F),xkc=$APP.kh.j($APP.F),ykc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));FZ=new $APP.Ch($APP.Zg.A("emmy.generic","acosh"),JP,$APP.xj,ykc,ukc,vkc,wkc,xkc);FZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return OF.j(MF.A(jG.j(yG.A(c,1)),jG.j(eH.A(c,1))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,oV],null);return b.j?b.j(a):b.call(null,a)});
FZ.F(null,$APP.xj,function(a){return MF.A(2,pG.j(eH.A(jG.j(zG.A(eH.A(a,1),2)),jG.j(zG.A(yG.A(a,1),2)))))});var GZ,zkc=$APP.kh.j($APP.F),Akc=$APP.kh.j($APP.F),Bkc=$APP.kh.j($APP.F),Ckc=$APP.kh.j($APP.F),Dkc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));GZ=new $APP.Ch($APP.Zg.A("emmy.generic","asinh"),JP,$APP.xj,Dkc,zkc,Akc,Bkc,Ckc);
GZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return OF.j(jG.j(eH.A(1,lG.j(c))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,fW],null);return b.j?b.j(a):b.call(null,a)});GZ.F(null,$APP.xj,function(a){return pG.j(eH.A(a,jG.j(eH.A(1,lG.j(a)))))});var HZ,Ekc=$APP.kh.j($APP.F),Fkc=$APP.kh.j($APP.F),Gkc=$APP.kh.j($APP.F),Hkc=$APP.kh.j($APP.F),Ikc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
HZ=new $APP.Ch($APP.Zg.A("emmy.generic","atanh"),JP,$APP.xj,Ikc,Ekc,Fkc,Gkc,Hkc);HZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return OF.j(yG.A(1,lG.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,FV],null);return b.j?b.j(a):b.call(null,a)});HZ.F(null,$APP.xj,function(a){return zG.A(yG.A(pG.j(eH.A(1,a)),pG.j(yG.A(1,a))),2)});
var IZ,Jkc=$APP.kh.j($APP.F),Kkc=$APP.kh.j($APP.F),Lkc=$APP.kh.j($APP.F),Mkc=$APP.kh.j($APP.F),Nkc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));IZ=new $APP.Ch($APP.Zg.A("emmy.generic","acoth"),JP,$APP.xj,Nkc,Jkc,Kkc,Lkc,Mkc);IZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return OF.j(yG.A(1,lG.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,aFb],null);return b.j?b.j(a):b.call(null,a)});
IZ.F(null,$APP.xj,function(a){return zG.A(yG.A(pG.j(eH.A(a,1)),pG.j(yG.A(a,1))),2)});var JZ,Okc=$APP.kh.j($APP.F),Pkc=$APP.kh.j($APP.F),Qkc=$APP.kh.j($APP.F),Rkc=$APP.kh.j($APP.F),Skc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));JZ=new $APP.Ch($APP.Zg.A("emmy.generic","asech"),JP,$APP.xj,Skc,Okc,Pkc,Qkc,Rkc);
JZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){var d=eH.A(c,1);return PF.j(OF.j(MF.A(MF.A(c,d),jG.j(zG.A(yG.A(1,c),d)))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,Y3b],null);return b.j?b.j(a):b.call(null,a)});JZ.F(null,$APP.xj,function(a){return pG.j(zG.A(eH.A(1,jG.j(yG.A(1,lG.j(a)))),a))});
var KZ,Tkc=$APP.kh.j($APP.F),Ukc=$APP.kh.j($APP.F),Vkc=$APP.kh.j($APP.F),Wkc=$APP.kh.j($APP.F),Xkc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));KZ=new $APP.Ch($APP.Zg.A("emmy.generic","acsch"),JP,$APP.xj,Xkc,Tkc,Ukc,Vkc,Wkc);KZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return PF.j(OF.j(MF.A(c,jG.j(eH.A(lG.j(c),1)))))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,Ihb],null);return b.j?b.j(a):b.call(null,a)});
KZ.F(null,$APP.xj,function(a){return pG.j(zG.A(eH.A(1,jG.j(eH.A(1,lG.j(a)))),a))});var rR,Ykc=$APP.kh.j($APP.F),Zkc=$APP.kh.j($APP.F),$kc=$APP.kh.j($APP.F),alc=$APP.kh.j($APP.F),blc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));rR=new $APP.Ch($APP.Zg.A("emmy.generic","sinc"),JP,$APP.xj,blc,Ykc,Zkc,$kc,alc);
rR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return $APP.k(KF.j(c))?c:yG.A(zG.A(fO.j(c),c),zG.A(gO.j(c),lG.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,O$b],null);return b.j?b.j(a):b.call(null,a)});rR.F(null,$APP.xj,function(a){return $APP.k(KF.j(a))?NF.j(a):zG.A(gO.j(a),a)});var LZ,clc=$APP.kh.j($APP.F),dlc=$APP.kh.j($APP.F),elc=$APP.kh.j($APP.F),flc=$APP.kh.j($APP.F),glc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
LZ=new $APP.Ch($APP.Zg.A("emmy.generic","tanc"),JP,$APP.xj,glc,clc,dlc,elc,flc);LZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){if($APP.k(KF.j(c)))return c;var d=wZ.j(c);return yG.A(zG.A(iG.A(d,d),c),zG.A(tZ.j(c),lG.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,MXb],null);return b.j?b.j(a):b.call(null,a)});LZ.F(null,$APP.xj,function(a){return $APP.k(KF.j(a))?NF.j(a):zG.A(tZ.j(a),a)});
var tR,hlc=$APP.kh.j($APP.F),ilc=$APP.kh.j($APP.F),jlc=$APP.kh.j($APP.F),klc=$APP.kh.j($APP.F),llc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));tR=new $APP.Ch($APP.Zg.A("emmy.generic","sinhc"),JP,$APP.xj,llc,hlc,ilc,jlc,klc);
tR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){return $APP.k(KF.j(c))?c:yG.A(zG.A(tH.j(c),c),zG.A(vH.j(c),lG.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,Y_b],null);return b.j?b.j(a):b.call(null,a)});tR.F(null,$APP.xj,function(a){return $APP.k(KF.j(a))?NF.j(a):zG.A(vH.j(a),a)});var MZ,mlc=$APP.kh.j($APP.F),nlc=$APP.kh.j($APP.F),olc=$APP.kh.j($APP.F),plc=$APP.kh.j($APP.F),qlc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));
MZ=new $APP.Ch($APP.Zg.A("emmy.generic","tanhc"),JP,$APP.xj,qlc,mlc,nlc,olc,plc);MZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[cN,function(c){if($APP.k(KF.j(c)))return c;var d=CZ.j(c);return yG.A(zG.A(iG.A(d,d),c),zG.A(BZ.j(c),lG.j(c)))},XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,Snb],null);return b.j?b.j(a):b.call(null,a)});MZ.F(null,$APP.xj,function(a){return $APP.k(KF.j(a))?NF.j(a):zG.A(BZ.j(a),a)});
var NZ,rlc=$APP.kh.j($APP.F),slc=$APP.kh.j($APP.F),tlc=$APP.kh.j($APP.F),ulc=$APP.kh.j($APP.F),vlc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));NZ=new $APP.Ch($APP.Zg.A("emmy.generic","make-rectangular"),JP,$APP.xj,vlc,rlc,slc,tlc,ulc);NZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,PV],null);return b.j?b.j(a):b.call(null,a)});
var OZ,wlc=$APP.kh.j($APP.F),xlc=$APP.kh.j($APP.F),ylc=$APP.kh.j($APP.F),zlc=$APP.kh.j($APP.F),Alc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));OZ=new $APP.Ch($APP.Zg.A("emmy.generic","make-polar"),JP,$APP.xj,Alc,wlc,xlc,ylc,zlc);OZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,DT],null);return b.j?b.j(a):b.call(null,a)});
var xH,Blc=$APP.kh.j($APP.F),Clc=$APP.kh.j($APP.F),Dlc=$APP.kh.j($APP.F),Elc=$APP.kh.j($APP.F),Flc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));xH=new $APP.Ch($APP.Zg.A("emmy.generic","real-part"),JP,$APP.xj,Flc,Blc,Clc,Dlc,Elc);xH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,$T],null);return b.j?b.j(a):b.call(null,a)});
var AH,Glc=$APP.kh.j($APP.F),Hlc=$APP.kh.j($APP.F),Ilc=$APP.kh.j($APP.F),Jlc=$APP.kh.j($APP.F),Klc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));AH=new $APP.Ch($APP.Zg.A("emmy.generic","imag-part"),JP,$APP.xj,Klc,Glc,Hlc,Ilc,Jlc);AH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,hV],null);return b.j?b.j(a):b.call(null,a)});
var xG,Llc=$APP.kh.j($APP.F),Mlc=$APP.kh.j($APP.F),Nlc=$APP.kh.j($APP.F),Olc=$APP.kh.j($APP.F),Plc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));xG=new $APP.Ch($APP.Zg.A("emmy.generic","magnitude"),JP,$APP.xj,Plc,Llc,Mlc,Nlc,Olc);xG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,AK],null);return b.j?b.j(a):b.call(null,a)});
var PZ,Qlc=$APP.kh.j($APP.F),Rlc=$APP.kh.j($APP.F),Slc=$APP.kh.j($APP.F),Tlc=$APP.kh.j($APP.F),Ulc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));PZ=new $APP.Ch($APP.Zg.A("emmy.generic","angle"),JP,$APP.xj,Ulc,Qlc,Rlc,Slc,Tlc);PZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,CY],null);return b.j?b.j(a):b.call(null,a)});
var qL,Vlc=$APP.kh.j($APP.F),Wlc=$APP.kh.j($APP.F),Xlc=$APP.kh.j($APP.F),Ylc=$APP.kh.j($APP.F),Zlc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));qL=new $APP.Ch($APP.Zg.A("emmy.generic","conjugate"),JP,$APP.xj,Zlc,Vlc,Wlc,Xlc,Ylc);qL.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,nY],null);return b.j?b.j(a):b.call(null,a)});
var eR,$lc=$APP.kh.j($APP.F),amc=$APP.kh.j($APP.F),bmc=$APP.kh.j($APP.F),cmc=$APP.kh.j($APP.F),dmc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));eR=new $APP.Ch($APP.Zg.A("emmy.generic","transpose"),JP,$APP.xj,dmc,$lc,amc,bmc,cmc);eR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,$APP.VX],null);return b.j?b.j(a):b.call(null,a)});
var QZ,emc=$APP.kh.j($APP.F),fmc=$APP.kh.j($APP.F),gmc=$APP.kh.j($APP.F),hmc=$APP.kh.j($APP.F),imc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));QZ=new $APP.Ch($APP.Zg.A("emmy.generic","trace"),JP,$APP.xj,imc,emc,fmc,gmc,hmc);QZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,aY],null);return b.j?b.j(a):b.call(null,a)});
var ZQ,jmc=$APP.kh.j($APP.F),kmc=$APP.kh.j($APP.F),lmc=$APP.kh.j($APP.F),mmc=$APP.kh.j($APP.F),nmc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));ZQ=new $APP.Ch($APP.Zg.A("emmy.generic","determinant"),JP,$APP.xj,nmc,jmc,kmc,lmc,mmc);ZQ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,lSb],null);return b.j?b.j(a):b.call(null,a)});
var LO,omc=$APP.kh.j($APP.F),pmc=$APP.kh.j($APP.F),qmc=$APP.kh.j($APP.F),rmc=$APP.kh.j($APP.F),smc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));LO=new $APP.Ch($APP.Zg.A("emmy.generic","dimension"),JP,$APP.xj,smc,omc,pmc,qmc,rmc);LO.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,$APP.AY],null);return b.j?b.j(a):b.call(null,a)});
var BH,tmc=$APP.kh.j($APP.F),umc=$APP.kh.j($APP.F),vmc=$APP.kh.j($APP.F),wmc=$APP.kh.j($APP.F),xmc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));BH=new $APP.Ch($APP.Zg.A("emmy.generic","dot-product"),JP,$APP.xj,xmc,tmc,umc,vmc,wmc);BH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,GX],null);return b.j?b.j(a):b.call(null,a)});
var RZ,ymc=$APP.kh.j($APP.F),zmc=$APP.kh.j($APP.F),Amc=$APP.kh.j($APP.F),Bmc=$APP.kh.j($APP.F),Cmc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));RZ=new $APP.Ch($APP.Zg.A("emmy.generic","inner-product"),JP,$APP.xj,Cmc,ymc,zmc,Amc,Bmc);RZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,rX],null);return b.j?b.j(a):b.call(null,a)});
var SZ,Dmc=$APP.kh.j($APP.F),Emc=$APP.kh.j($APP.F),Fmc=$APP.kh.j($APP.F),Gmc=$APP.kh.j($APP.F),Hmc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));SZ=new $APP.Ch($APP.Zg.A("emmy.generic","outer-product"),JP,$APP.xj,Hmc,Dmc,Emc,Fmc,Gmc);SZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,WQb],null);return b.j?b.j(a):b.call(null,a)});
var TZ,Imc=$APP.kh.j($APP.F),Jmc=$APP.kh.j($APP.F),Kmc=$APP.kh.j($APP.F),Lmc=$APP.kh.j($APP.F),Mmc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));TZ=new $APP.Ch($APP.Zg.A("emmy.generic","cross-product"),JP,$APP.xj,Mmc,Imc,Jmc,Kmc,Lmc);TZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,Ncc],null);return b.j?b.j(a):b.call(null,a)});eR.F(null,new $APP.H(null,1,5,$APP.I,[FF],null),function(a){return a});
QZ.F(null,new $APP.H(null,1,5,$APP.I,[FF],null),function(a){return a});ZQ.F(null,new $APP.H(null,1,5,$APP.I,[FF],null),function(a){return a});LO.F(null,new $APP.H(null,1,5,$APP.I,[FF],null),function(){return 1});BH.F(null,new $APP.H(null,2,5,$APP.I,[FF,FF],null),function(a,b){return MF.A(a,b)});RZ.F(null,new $APP.H(null,2,5,$APP.I,[FF,FF],null),function(a,b){return BH.A(a,b)});
var VF,Nmc=$APP.kh.j($APP.F),Omc=$APP.kh.j($APP.F),Pmc=$APP.kh.j($APP.F),Qmc=$APP.kh.j($APP.F),Rmc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));VF=new $APP.Ch($APP.Zg.A("emmy.generic","solve-linear"),JP,$APP.xj,Rmc,Nmc,Omc,Pmc,Qmc);VF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,M_b],null);return b.j?b.j(a):b.call(null,a)});
var cR,Smc=$APP.kh.j($APP.F),Tmc=$APP.kh.j($APP.F),Umc=$APP.kh.j($APP.F),Vmc=$APP.kh.j($APP.F),Wmc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));cR=new $APP.Ch($APP.Zg.A("emmy.generic","solve-linear-right"),JP,$APP.xj,Wmc,Smc,Tmc,Umc,Vmc);cR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,vDb],null);return b.j?b.j(a):b.call(null,a)});
VF.F(null,new $APP.H(null,2,5,$APP.I,[FF,FF],null),function(a,b){return zG.A(b,a)});cR.F(null,new $APP.H(null,2,5,$APP.I,[FF,FF],null),function(a,b){return zG.A(a,b)});var mR,Xmc=$APP.kh.j($APP.F),Ymc=$APP.kh.j($APP.F),Zmc=$APP.kh.j($APP.F),$mc=$APP.kh.j($APP.F),anc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));mR=new $APP.Ch($APP.Zg.A("emmy.generic","partial-derivative"),JP,$APP.xj,anc,Xmc,Ymc,Zmc,$mc);
mR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,iS],null);return b.j?b.j(a):b.call(null,a)});var bR,bnc=$APP.kh.j($APP.F),cnc=$APP.kh.j($APP.F),dnc=$APP.kh.j($APP.F),enc=$APP.kh.j($APP.F),fnc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));bR=new $APP.Ch($APP.Zg.A("emmy.generic","Lie-derivative"),JP,$APP.xj,fnc,bnc,cnc,dnc,enc);
bR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,aR],null);return b.j?b.j(a):b.call(null,a)});var bG,gnc=$APP.kh.j($APP.F),hnc=$APP.kh.j($APP.F),inc=$APP.kh.j($APP.F),jnc=$APP.kh.j($APP.F),knc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));bG=new $APP.Ch($APP.Zg.A("emmy.generic","simplify"),JP,$APP.xj,knc,gnc,hnc,inc,jnc);
bG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.R,$R],null);return b.j?b.j(a):b.call(null,a)});bG.F(null,$APP.xj,function(a){return a});bG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){return a});
TSa($APP.fg([$APP.Xs,$APP.wr,$APP.Zs,$APP.Od,$APP.Ws,iG,$APP.Uc,$APP.Qd,$APP.Mba,$APP.at,RF,$APP.zd,$APP.Ys,$APP.$s,QF,$APP.Pd,kG,$APP.Ck],[$APP.rj,$APP.Fv,$APP.Uv,YX,$APP.Ev,$APP.Ev,$APP.Zv,eS,yX,$APP.$v,$APP.Gv,$APP.aw,$APP.Xv,$APP.Yv,$APP.rj,lX,$APP.Fv,$APP.Gv]));var lnc=new $APP.ug(null,new $APP.f(null,4,[Q9b,null,H6b,null,PM,null,teb,null],null),null);$APP.e=WF.prototype;$APP.e.nd=function(){return $APP.Uc.A(this.type,PM)};$APP.e.rb=function(){return this.type};$APP.e.toString=function(){return $APP.jh.C($APP.y([this.expression]))};$APP.e.valueOf=function(){return"number"===typeof this.expression?this.expression:EF(this.expression)?this.expression.valueOf():this};$APP.e.ba=function(){return this.ca};
$APP.e.da=function(a,b){return new WF(this.type,this.expression,b)};$APP.e.Y=function(a,b){return b instanceof WF?(a=$APP.Uc.A(this.type,b.type))?(a=fG.A(this.expression,b.expression),$APP.k(a)?$APP.Uc.A(this.ca,b.ca):a):a:fG.A(this.expression,b)};$APP.e.Tb=function(a,b){return b instanceof WF?$APP.jc(this.expression,b.expression):$APP.jc(this.expression,b)};$APP.e.ea=function(a,b){return $APP.Vb(b,$APP.m.j(this.expression))};
var UZ=function UZ(a){switch(arguments.length){case 3:return UZ.B(arguments[0],arguments[1],arguments[2]);case 2:return UZ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};UZ.B=function(a,b,c){return UZ.A(a,$APP.pe([b,c]))};UZ.A=function(a,b){return XF(a)?bTa(function(c){return UZ.A(c,b)},a):$APP.zo(b,a)};UZ.G=3;
var $F=function $F(a,b){for(;;){var d=$APP.kd(a),g=$APP.kd(b),l=b instanceof $APP.q,n="string"===typeof b,p=d&&$APP.hd(a),v=g&&$APP.hd(b),t=new $APP.bh(function(A,B){return function(){return $APP.Ed($APP.yc(A),$APP.yc(B))}}(a,b,d,g,l,n,p,v),null);if(p&&v)return 0;if(p)return-1;if(v)return 1;if(DF(a))return DF(b)?$APP.Ed(a,b):l||n||g?-1:$APP.Fb(t);if(DF(b))return 1;if(a instanceof $APP.q)return l?$APP.Ed(a,b):n||g?-1:$APP.Fb(t);if(l)return 1;if("string"===typeof a)return n?$APP.Ed(a,b):g?-1:$APP.Fb(t);
if(n)return 1;if(d)if(g){d=$APP.Tc(a);g=$APP.Tc(b);if(d<g)return-1;if(g<d)return 1;d=function(){var A=$APP.u(a),B=$APP.u(b);return $F.A?$F.A(A,B):$F.call(null,A,B)}();if(0===d)d=$APP.Fc(a),g=$APP.Fc(b),a=d,b=g;else return d}else return $APP.Fb(t);else return g?1:$APP.Fb(t)}},VZ=function VZ(a){switch(arguments.length){case 2:return VZ.A(arguments[0],arguments[1]);case 3:return VZ.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));
}};VZ.A=function(a,b){return $APP.YA.C(bG.j(a),$APP.y([$APP.xx,b]))};VZ.B=function(a,b,c){b=$APP.Je.A($APP.N,$APP.rg.B(c,$APP.xx,b));a=bG.j(a);return $APP.Je.B($APP.YA,a,b)};VZ.G=3;KF.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(a){a=a.expression;var b=EF(a);return b?KF.j(a):b});sG.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(a){a=a.expression;var b=EF(a);return b?sG.j(a):b});iZ.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(a){return sG.j(a)});
tG.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(){return 0});NF.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(){return 1});jZ.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(){return 1});TF.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(a){a=a.expression;var b=EF(a);return b?TF.j(a):b});aG.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(a){return aG.j(a.expression)});$APP.e=cG.prototype;$APP.e.rb=function(){return fT};$APP.e.bi=$APP.xc;$APP.e.nd=function(){return!0};$APP.e.toString=function(){return eG.j?eG.j(this):eG.call(null,this)};$APP.e.Y=function(a,b){return gTa.A?gTa.A(this,b):gTa.call(null,this,b)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([eG.j?eG.j(this):eG.call(null,this)]))};var qTa=new cG(0,0),mnc=new cG(1,0),nG=new cG(0,1),sTa=new cG(0,-1),oTa=new cG(Infinity,Infinity),nTa=new cG(NaN,NaN),xTa=Math.PI/2,iTa=/([+-]?\d+(\.\d*)?([Ee][+-]?\d+)?)(\s?([+-])?\s?([+-]?\d+(\.\d*)?([Ee][+-]?\d+)?)[Ii])?/;$APP.hu.A(fT,TM);var wG=function wG(a){switch(arguments.length){case 1:return wG.j(arguments[0]);case 2:return wG.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};wG.j=function(a){if("string"===typeof a)return kTa(a);if($APP.od(a)){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return dG(b,a)}return dG(a,0)};wG.A=function(a,b){return dG(a,b)};wG.G=2;KF.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return gG(a)});
sG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=sG.j(a.ha);return $APP.k(b)?KF.j(a.ia):b});iZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return sG.j(a)});tG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return dG(tG.j(a.ha),tG.j(a.ia))});NF.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return DTa(a)});jZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return DTa(a)});
aG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;return $APP.k(KF.j(a))?b:new $APP.D(null,dY,new $APP.D(null,b,new $APP.D(null,a,null,1,null),2,null),3,null)});TF.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=TF.j(a.ha);return $APP.k(b)?TF.j(a.ia):b});wM.F(null,new $APP.H(null,2,5,$APP.I,[fT,fT],null),function(a,b){return HTa(a,b)});wM.F(null,new $APP.H(null,2,5,$APP.I,[fT,DG],null),function(a,b){return HTa(a,b)});
wM.F(null,new $APP.H(null,2,5,$APP.I,[DG,fT],null),function(a,b){return HTa(a,b)});NZ.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return $APP.k(KF.j(b))?a:wG.A(a,b)});OZ.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return $APP.k(KF.j(a))?a:$APP.k(KF.j(b))?a:wG.A(iG.A(a,fO.j(b)),iG.A(a,gO.j(b)))});xH.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return a.ha});AH.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return a.ia});
xG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return hTa(a)});PZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return rG.A(a.ia,a.ha)});qL.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return dG(a.ha,PF.j(a.ia))});BH.F(null,new $APP.H(null,2,5,$APP.I,[fT,fT],null),function(a,b){return kG.A(iG.A(a.ha,b.ha),iG.A(a.ia,b.ia))});BH.F(null,new $APP.H(null,2,5,$APP.I,[fT,DG],null),function(a,b){return iG.A(a.ha,b)});
BH.F(null,new $APP.H(null,2,5,$APP.I,[DG,fT],null),function(a,b){return iG.A(a,b.ha)});fG.F(null,new $APP.H(null,2,5,$APP.I,[fT,fT],null),function(a,b){return gTa(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[fT,DG],null),function(a,b){var c=KF.j(a.ia);return $APP.k(c)?fG.A(a.ha,b):c});fG.F(null,new $APP.H(null,2,5,$APP.I,[DG,fT],null),function(a,b){var c=KF.j(b.ia);return $APP.k(c)?fG.A(a,b.ha):c});eH.F(null,new $APP.H(null,2,5,$APP.I,[fT,fT],null),function(a,b){return lTa(a,b)});
eH.F(null,new $APP.H(null,2,5,$APP.I,[fT,DG],null),function(a,b){return lTa(a,wG.j(b))});eH.F(null,new $APP.H(null,2,5,$APP.I,[DG,fT],null),function(a,b){return lTa(wG.j(a),b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[fT,fT],null),function(a,b){return mTa(a,b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[fT,DG],null),function(a,b){return mTa(a,wG.j(b))});yG.F(null,new $APP.H(null,2,5,$APP.I,[DG,fT],null),function(a,b){return mTa(wG.j(a),b)});
MF.F(null,new $APP.H(null,2,5,$APP.I,[fT,fT],null),function(a,b){return pTa(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[fT,DG],null),function(a,b){return pTa(a,wG.j(b))});MF.F(null,new $APP.H(null,2,5,$APP.I,[DG,fT],null),function(a,b){return pTa(wG.j(a),b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[fT,fT],null),function(a,b){return rTa(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[fT,DG],null),function(a,b){return rTa(a,wG.j(b))});
zG.F(null,new $APP.H(null,2,5,$APP.I,[DG,fT],null),function(a,b){return rTa(wG.j(a),b)});OF.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){if($APP.k(gG(a)))var b=oTa;else if($APP.k(mG.j(a)))b=qTa;else{b=a.ha;a=a.ia;var c=kG.A(iG.A(b,b),iG.A(a,a));b=dG(QF.A(b,c),QF.A(PF.j(a),c))}return b});PF.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return dG(PF.j(a.ha),PF.j(a.ia))});rI.F(null,new $APP.H(null,2,5,$APP.I,[fT,fT],null),function(a,b){return tTa(a,b)});
rI.F(null,new $APP.H(null,2,5,$APP.I,[fT,DG],null),function(a,b){return tTa(a,wG.j(b))});rI.F(null,new $APP.H(null,2,5,$APP.I,[DG,fT],null),function(a,b){return tTa(wG.j(a),b)});lG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return iG.A(a,a)});oZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return iG.C(a,a,$APP.y([a]))});hG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return hTa(a)});
oG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=oG.j(a.ha);a=a.ia;return dG(iG.A(b,fO.j(a)),iG.A(b,gO.j(a)))});pG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return vTa(a)});jG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return uTa(a)});gO.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;return dG(iG.A(gO.j(b),tH.j(a)),iG.A(fO.j(b),vH.j(a)))});
fO.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;return dG(iG.A(fO.j(b),tH.j(a)),iG.C(-1,gO.j(b),$APP.y([vH.j(a)])))});tZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=iG.A(2,a.ha);a=iG.A(2,a.ia);var c=kG.A(fO.j(b),tH.j(a));return dG(QF.A(gO.j(b),c),QF.A(vH.j(a),c))});
wZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;var c=QF.A(kG.A(tH.j(iG.A(2,a)),fO.j(iG.A(2,b))),2);return dG(QF.A(iG.A(fO.j(b),tH.j(a)),c),QF.A(iG.A(gO.j(b),vH.j(a)),c))});vZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;var c=QF.A(RF.A(tH.j(iG.A(2,a)),fO.j(iG.A(2,b))),2);return dG(QF.A(iG.A(gO.j(b),tH.j(a)),c),QF.A(iG.C(-1,fO.j(b),$APP.y([vH.j(a)])),c))});
uZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=iG.A(2,a.ha);a=iG.A(2,a.ia);var c=RF.A(fO.j(b),tH.j(a));return dG(QF.A(PF.j(gO.j(b)),c),QF.A(vH.j(a),c))});xZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return wTa(a)});kO.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return yTa(a)});rG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return zTa(a)});
AZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){if($APP.k(gG(a)))var b=dG(xTa,Infinity);else{b=a.ha;a=a.ia;var c=kG.A(lG.j(b),lG.j(a));b=wTa(dG(QF.A(b,c),QF.A(PF.j(a),c)))}return b});zZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){if($APP.k(gG(a)))var b=dG(0,Infinity);else{b=a.ha;a=a.ia;var c=kG.A(lG.j(b),lG.j(a));b=yTa(dG(QF.A(b,c),QF.A(PF.j(a),c)))}return b});
yZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;if($APP.k(KF.j(a)))b=dG(rG.A(1,b),0);else{var c=kG.A(lG.j(b),lG.j(a));b=$APP.k(KF.j(c))?zTa(dG($APP.k(KF.j(b))?0:QF.A(b,0),$APP.k(KF.j(a))?0:QF.A(PF.j(a),0))):zTa(dG(QF.A(b,c),QF.A(PF.j(a),c)))}return b});GZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return ATa(a)});FZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return BTa(a)});HZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){return CTa(a)});
JZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){if($APP.k(gG(a)))var b=oTa;else{b=a.ha;a=a.ia;var c=kG.A(lG.j(b),lG.j(a));b=BTa(dG(QF.A(b,c),QF.A(PF.j(a),c)))}return b});KZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;if($APP.k(KF.j(a)))b=$APP.k(KF.j(b))?dG(Infinity,0):dG(pG.j(kG.A(b,jG.j(kG.A(lG.j(b),1)))),0);else{var c=kG.A(lG.j(b),lG.j(a));b=ATa(dG(QF.A(b,c),QF.A(PF.j(a),c)))}return b});
IZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){if($APP.k(gG(a)))var b=dG(0,xTa);else{b=a.ha;a=a.ia;var c=kG.A(lG.j(b),lG.j(a));b=CTa(dG(QF.A(b,c),QF.A(PF.j(a),c)))}return b});pZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=Math.pow(10,0);return dG(Math.floor(a.ha*b)/b,Math.floor(a.ia*b)/b)});rZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=Math.pow(10,0);return dG(Math.ceil(a.ha*b)/b,Math.ceil(a.ia*b)/b)});
tH.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;return dG(iG.A(tH.j(b),fO.j(a)),iG.A(vH.j(b),gO.j(a)))});vH.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;return dG(iG.A(vH.j(b),fO.j(a)),iG.A(tH.j(b),gO.j(a)))});BZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=iG.A(2,a.ha);a=iG.A(2,a.ia);var c=kG.A(tH.j(b),fO.j(a));return dG(QF.A(vH.j(b),c),QF.A(gO.j(a),c))});
CZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;var c=kG.A(fO.j(iG.A(2,a)),tH.j(iG.A(2,b)));return dG(QF.A(iG.C(2,tH.j(b),$APP.y([fO.j(a)])),c),QF.A(iG.C(-2,vH.j(b),$APP.y([gO.j(a)])),c))});EZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=a.ha;a=a.ia;var c=RF.A(fO.j(iG.A(2,a)),tH.j(iG.A(2,b)));return dG(QF.A(iG.C(-2,vH.j(b),$APP.y([fO.j(a)])),c),QF.A(iG.C(2,tH.j(b),$APP.y([gO.j(a)])),c))});
DZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=iG.A(2,a.ha);a=iG.A(2,a.ia);var c=RF.A(tH.j(b),fO.j(a));return dG(QF.A(vH.j(b),c),QF.A(PF.j(gO.j(a)),c))});qZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=qZ.j(a.ha);a=qZ.j(a.ia);return $APP.k(KF.j(a))?b:wG.A(b,a)});sZ.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=sZ.j(a.ha);a=sZ.j(a.ia);return $APP.k(KF.j(a))?b:wG.A(b,a)});
qG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=KF.j(a.ia);return $APP.k(b)?qG.j(a.ha):b});mG.F(null,new $APP.H(null,1,5,$APP.I,[fT],null),function(a){var b=mG.j(a.ha);return $APP.k(b)?b:mG.j(a.ia)});wM.F(null,$APP.xj,function(a,b){return ITa(a,b)});$APP.hu.A(sF,DG);KTa._=!0;BG._=function(a){return a};CG._=function(){return 1};sF.prototype.Lg=function(){return this.n};sF.prototype.Kg=function(){return this.d};var WZ=function WZ(a){switch(arguments.length){case 1:return WZ.j(arguments[0]);case 2:return WZ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
WZ.j=function(a){if(!(CF(a)||a instanceof sF))if(DF(a)){var b=$APP.Lg(Rec,a.toString());if($APP.k(b)){$APP.x.B(b,0,null);a=$APP.x.B(b,1,null);$APP.x.B(b,2,null);var c=$APP.x.B(b,3,null);$APP.x.B(b,4,null);b=$APP.x.B(b,5,null);var d=parseInt($APP.k(b)?b:"0")-$APP.Tc($APP.k(c)?c:"");b=0>d;a=BigInt([$APP.m.j(a),$APP.m.j(c)].join(""));c=BigInt(Qec**BigInt(Math.abs(d)));a=b?wF(a,c):new sF(a*c,xF)}else throw Error(["Cannot convert ",$APP.m.j(a)," to ratio."].join(""));}else a=CD(["Cannot rationalize ",
$APP.m.j(a)].join(""));return a};WZ.A=function(a,b){a=BigInt(a);b=BigInt(b);0===b&&CSa();b=wF(a,b);return yF(b)};WZ.G=2;var nnc=/(-?\d+)\/(\d+)/;TF.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(){return!0});aG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){var b=BG(a);a=CG(a);return $APP.k(sG.j(a))?b:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.rj,null,1,null),new $APP.D(null,aG.j(b),null,1,null),$APP.y([new $APP.D(null,aG.j(a),null,1,null)]))))});$APP.e=sF.prototype;
$APP.e.bi=$APP.xc;$APP.e.nd=function(){return!0};$APP.e.Y=function(a,b){if(b instanceof sF){a=this.d;var c=b.d;return this.n===b.n&&a===c}a=sG.j(this.d);return $APP.k(a)?fG.A(this.n,b):a};$APP.e.Oa=$APP.xc;$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#emmy/ratio "',this.n,"/",this.d,'"']))};fG.F(null,new $APP.H(null,2,5,$APP.I,[DG,sF],null),function(a,b){return $APP.Uc.A(b,a)});eH.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF(FSa(a,b))});
yG.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF(GSa(a,b))});MF.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF(HSa(a,b))});zG.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF(wF(a.n*b.d,a.d*b.n))});iM.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF(wF(a.n*b.d,a.d*b.n))});KF.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return tF===a.n});
sG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return a.n===a.d});iZ.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return a.n===a.d});tG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(){return 0});NF.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(){return 1});jZ.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(){return 1});PF.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return yF(new sF(vF*a.n,a.d))});
qG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return 0>a.n});mG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(){return!1});OF.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){var b=a.n;a=a.d;var c=0>b;tF===b&&CSa();return yF(c?new sF(vF*a,vF*b):new sF(a,b))});lG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return yF(HSa(a,a))});oZ.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return yF(KSa(a,3))});
hG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return yF(ESa(a))});xG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return yF(ESa(a))});rI.F(null,new $APP.H(null,2,5,$APP.I,[sF,EG],null),function(a,b){return yF(KSa(a,b))});rI.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF($APP.k(sG.j(b.d))?KSa(a,b.n):rI.A(uF(a),uF(b)))});jG.F(null,new $APP.H(null,1,5,$APP.I,[sF],null),function(a){return 0>a?jG.j(uF(a)):zG.A(jG.j(BG(a)),jG.j(CG(a)))});
qI.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF(LSa(a,b))});AG.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF(MSa(a,b))});lI.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){return yF(MSa(FSa(MSa(a,b),b),b))});wM.F(null,new $APP.H(null,2,5,$APP.I,[sF,sF],null),function(a,b){var c=a.d,d=b.d;a=ESa(wF(DSa(a.n,b.n)*DSa(c,d),c*d));return yF(a)});MTa(iM);MTa(wM);LTa(rI);
for(var onc=$APP.r(new $APP.H(null,9,5,$APP.I,[eH,MF,yG,wM,oM,lI,AG,qI,zG],null)),pnc=null,qnc=0,rnc=0;;)if(rnc<qnc){var snc=pnc.aa(null,rnc);MTa(snc);LTa(snc);rnc+=1}else{var tnc=$APP.r(onc);if(tnc){var XZ=tnc;if($APP.pd(XZ)){var unc=$APP.lc(XZ),vnc=$APP.mc(XZ),wnc=unc,xnc=$APP.Tc(unc);onc=vnc;pnc=wnc;qnc=xnc}else{var ync=$APP.u(XZ);MTa(ync);LTa(ync);onc=$APP.w(XZ);pnc=null;qnc=0}rnc=0}else break};var YZ=Boolean;KF.F(null,new $APP.H(null,1,5,$APP.I,[YZ],null),function(a){return $APP.eb(a)});sG.F(null,new $APP.H(null,1,5,$APP.I,[YZ],null),function(a){return a});iZ.F(null,new $APP.H(null,1,5,$APP.I,[YZ],null),function(a){return a});tG.F(null,new $APP.H(null,1,5,$APP.I,[YZ],null),function(){return!1});NF.F(null,new $APP.H(null,1,5,$APP.I,[YZ],null),function(){return!0});jZ.F(null,new $APP.H(null,1,5,$APP.I,[YZ],null),function(){return!0});tG.F(null,new $APP.H(null,1,5,$APP.I,[CT],null),function(){return 0});
NF.F(null,new $APP.H(null,1,5,$APP.I,[CT],null),function(){return 1});jZ.F(null,new $APP.H(null,1,5,$APP.I,[CT],null),function(){return 1});KF.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 0===a});sG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 1===a});iZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 1===a});tG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(){return 0});NF.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(){return 1});
jZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(){return 1});TF.F(null,new $APP.H(null,1,5,$APP.I,[EG],null),function(){return!0});TF.F(null,new $APP.H(null,1,5,$APP.I,[CT],null),function(){return!1});aG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return a});eH.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return a+b});MF.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return a*b});
yG.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return a-b});PF.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return-a});qG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 0>a});rI.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return 0>a&&0!==sZ.j(b)?oG.j(MF.A(b,pG.j(a))):UY.A?UY.A(a,b):UY.call(null,a,b)});hG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return kQ.j?kQ.j(a):kQ.call(null,a)});
xG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return kQ.j?kQ.j(a):kQ.call(null,a)});zG.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return a/b});OF.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 1/a});pZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return $APP.Nd(Math.floor(a))});rZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return $APP.Nd(Math.ceil(a))});qZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return Math.trunc(a)});
mG.F(null,new $APP.H(null,1,5,$APP.I,[EG],null),function(){return!1});mG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return $APP.zd(a)});xH.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return a});AH.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(){return 0});PZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 0>a?Math.PI:tG.j(a)});qL.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return a});
rR.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return $APP.k(KF.j(a))?1:$APP.k(mG.j(a))?0:QF.A(gO.j(a),a)});gO.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return $APP.k(KF.j(a))?0:Math.sin(a)});fO.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return $APP.k(KF.j(a))?1:Math.cos(a)});tZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return Math.tan(a)});tH.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return Math.cosh(a)});
vH.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return Math.sinh(a)});BZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return Math.tanh(a)});rG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return Math.atan(a)});rG.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return Math.atan2(a,b)});xZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 1<hG.j(a)?xZ.j(wG.j(a)):Math.asin(a)});
kO.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 1<hG.j(a)?kO.j(wG.j(a)):Math.acos(a)});FZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 1<=a?Math.acosh(a):FZ.j(wG.j(a))});GZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 1<=a?Math.asinh(a):GZ.j(wG.j(a))});HZ.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 1<=hG.j(a)?HZ.j(wG.j(a)):Math.atanh(a)});
jG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 0>a?jG.j(wG.j(a)):Gec.j?Gec.j(a):Gec.call(null,a)});pG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 0>a?pG.j(wG.j(a)):Math.log(a)});nZ.F(null,new $APP.H(null,1,5,$APP.I,[Number],null),function(a){return 0>a?nZ.j(wG.j(a)):Math.log10(a)});mZ.F(null,new $APP.H(null,1,5,$APP.I,[Number],null),function(a){return 0>a?mZ.j(wG.j(a)):Math.log2(a)});
oG.F(null,new $APP.H(null,1,5,$APP.I,[DG],null),function(a){return 0===a?1:Math.exp(a)});iM.F(null,new $APP.H(null,2,5,$APP.I,[FF,DG],null),function(a,b){var c=NTa(a,b);return $APP.k(c)?c:AD(["exact-divide not allowed between: ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))});qI.F(null,new $APP.H(null,2,5,$APP.I,[FF,DG],null),function(a,b){var c=NTa(a,b);return $APP.k(c)?c:AD(["quotient not allowed between: ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))});
iM.F(null,new $APP.H(null,2,5,$APP.I,[EG,EG],null),function(a,b){return qI.A(a,b)});qZ.F(null,new $APP.H(null,1,5,$APP.I,[EG],null),function(a){return a});sZ.F(null,new $APP.H(null,1,5,$APP.I,[EG],null),function(){return 0});pZ.F(null,new $APP.H(null,1,5,$APP.I,[EG],null),function(a){return a});rZ.F(null,new $APP.H(null,1,5,$APP.I,[EG],null),function(a){return a});qI.F(null,new $APP.H(null,2,5,$APP.I,[GY,GY],null),function(a,b){return $APP.Pd(a,b)});
AG.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return $APP.Qd(a,b)});lI.F(null,new $APP.H(null,2,5,$APP.I,[DG,DG],null),function(a,b){return $APP.Od(a,b)});wM.F(null,new $APP.H(null,2,5,$APP.I,[GY,GY],null),function(a,b){a=0>a?-a:a;for(b=0>b?-b:b;;){if(0===b)return a;var c=$APP.Qd(a,b);a=b;b=c}});wM.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return OTa(a,b)});wM.F(null,new $APP.H(null,2,5,$APP.I,[GY,BigInt],null),function(a,b){return OTa(BigInt(a),b)});
wM.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,GY],null),function(a,b){return OTa(a,BigInt(b))});rI.F(null,new $APP.H(null,2,5,$APP.I,[GY,GY],null),function(a,b){if(0>b){var c=OF.j;b=-b;a=UY.A?UY.A(a,b):UY.call(null,a,b);c=c.call(OF,a)}else c=UY.A?UY.A(a,b):UY.call(null,a,b);return c});zG.F(null,new $APP.H(null,2,5,$APP.I,[EG,EG],null),function(a,b){var c=AG.A(a,b);return $APP.k(KF.j(c))?qI.A(a,b):WZ.A(a,b)});
OF.F(null,new $APP.H(null,1,5,$APP.I,[EG],null),function(a){return $APP.k(sG.j(a))?a:WZ.A(1,a)});var ZZ=BigInt(0),$Z=BigInt(1);eH.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a+b});MF.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a*b});lI.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return yG.A(a,MF.A(b,pZ.j(zG.A(a,b))))});yG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a-b});
PF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return-a});rI.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return $APP.k(qG.j(b))?OF.j(a**-b):a**b});KF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return ZZ==a});sG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return $Z==a});iZ.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return $Z==a});tG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return ZZ});
NF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return $Z});jZ.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return $Z});TF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return!0});hG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return 0>a?-a:a});qI.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a/b});AG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a%b});
xG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return 0>a?-a:a});zG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return $APP.k(KF.j(a%b))?a/b:WZ.A(a,b)});
for(var a_=$APP.r(new $APP.H(null,8,5,$APP.I,[eH,MF,yG,zG,rI,lI,AG,qI],null)),b_=null,c_=0,d_=0;;)if(d_<c_){var e_=b_.aa(null,d_);e_.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,EG],null),function(a,b,c,d,g){return function(l,n){n=BigInt(n);return g.A?g.A(l,n):g.call(null,l,n)}}(a_,b_,c_,d_,e_,ZZ,$Z));e_.F(null,new $APP.H(null,2,5,$APP.I,[EG,BigInt],null),function(a,b,c,d,g){return function(l,n){l=BigInt(l);return g.A?g.A(l,n):g.call(null,l,n)}}(a_,b_,c_,d_,e_,ZZ,$Z));e_.F(null,new $APP.H(null,2,5,$APP.I,
[BigInt,CT],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(a_,b_,c_,d_,e_,ZZ,$Z));e_.F(null,new $APP.H(null,2,5,$APP.I,[CT,BigInt],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(a_,b_,c_,d_,e_,ZZ,$Z));d_+=1}else{var f_=$APP.r(a_);if(f_){var g_=f_;if($APP.pd(g_)){var znc=$APP.lc(g_),Anc=$APP.mc(g_),Bnc=znc,Cnc=$APP.Tc(znc);a_=Anc;b_=Bnc;c_=Cnc}else{var h_=$APP.u(g_);h_.F(null,new $APP.H(null,2,5,$APP.I,
[BigInt,EG],null),function(a,b,c,d,g){return function(l,n){n=BigInt(n);return g.A?g.A(l,n):g.call(null,l,n)}}(a_,b_,c_,d_,h_,g_,f_,ZZ,$Z));h_.F(null,new $APP.H(null,2,5,$APP.I,[EG,BigInt],null),function(a,b,c,d,g){return function(l,n){l=BigInt(l);return g.A?g.A(l,n):g.call(null,l,n)}}(a_,b_,c_,d_,h_,g_,f_,ZZ,$Z));h_.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,CT],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(a_,b_,c_,d_,h_,g_,f_,ZZ,$Z));h_.F(null,
new $APP.H(null,2,5,$APP.I,[CT,BigInt],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(a_,b_,c_,d_,h_,g_,f_,ZZ,$Z));a_=$APP.w(g_);b_=null;c_=0}d_=0}else break}
for(var i_=$APP.r(new $APP.H(null,20,5,$APP.I,[fO,gO,tZ,xZ,kO,rG,tH,vH,BZ,GZ,FZ,FZ,uZ,wZ,vZ,CZ,EZ,pG,oG,jG],null)),j_=null,k_=0,l_=0;;)if(l_<k_){var Dnc=j_.aa(null,l_);Dnc.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a,b,c,d,g){return function(l){l=Number(l);return g.j?g.j(l):g.call(null,l)}}(i_,j_,k_,l_,Dnc,ZZ,$Z));l_+=1}else{var Enc=$APP.r(i_);if(Enc){var m_=Enc;if($APP.pd(m_)){var Fnc=$APP.lc(m_),Gnc=$APP.mc(m_),Hnc=Fnc,Inc=$APP.Tc(Fnc);i_=Gnc;j_=Hnc;k_=Inc}else{var Jnc=$APP.u(m_);
Jnc.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a,b,c,d,g){return function(l){l=Number(l);return g.j?g.j(l):g.call(null,l)}}(i_,j_,k_,l_,Jnc,m_,Enc,ZZ,$Z));i_=$APP.w(m_);j_=null;k_=0}l_=0}else break}rG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,DG],null),function(a,b){return rG.A(Number(a),b)});rG.F(null,new $APP.H(null,2,5,$APP.I,[DG,BigInt],null),function(a,b){return rG.A(a,Number(b))});rG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return rG.A(Number(a),Number(b))});
TF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return!0});aG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return hG.j(a)<Number.MAX_SAFE_INTEGER?Number(a):a});KF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return a.Rb()});sG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return $APP.Uc.A($APP.Ha,a)});iZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return $APP.Uc.A($APP.Ha,a)});
tG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(){return $APP.Aa});NF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(){return $APP.Ha});jZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(){return $APP.Ha});TF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(){return!0});aG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return a});KF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return a.Rb()});
sG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return $APP.Uc.A($APP.Fs,a)});iZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return $APP.Uc.A($APP.Fs,a)});tG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(){return $APP.va});NF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(){return $APP.Fs});jZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(){return $APP.Fs});TF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(){return!0});
aG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return a});eH.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.add(b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.multiply(b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.Wc(b)});PF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return a.Za()});
hG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return $APP.k(a.nb())?a.Za():a});AG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.Xe(b)});xG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return $APP.k(a.nb())?a.Za():a});rI.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return $APP.k(b.nb())?OF.j(PTa(a,b.Za())):PTa(a,b)});
for(var n_=$APP.r(new $APP.H(null,8,5,$APP.I,[eH,MF,yG,wM,oM,rI,AG,qI],null)),o_=null,p_=0,q_=0;;)if(q_<p_){var r_=o_.aa(null,q_);r_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,GY],null),function(a,b,c,d,g){return function(l,n){n=$APP.xa(n);return g.A?g.A(l,n):g.call(null,l,n)}}(n_,o_,p_,q_,r_,ZZ,$Z));r_.F(null,new $APP.H(null,2,5,$APP.I,[GY,$APP.qa],null),function(a,b,c,d,g){return function(l,n){l=$APP.xa(l);return g.A?g.A(l,n):g.call(null,l,n)}}(n_,o_,p_,q_,r_,ZZ,$Z));r_.F(null,new $APP.H(null,2,
5,$APP.I,[$APP.qa,CT],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(n_,o_,p_,q_,r_,ZZ,$Z));r_.F(null,new $APP.H(null,2,5,$APP.I,[CT,$APP.qa],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(n_,o_,p_,q_,r_,ZZ,$Z));q_+=1}else{var s_=$APP.r(n_);if(s_){var t_=s_;if($APP.pd(t_)){var Knc=$APP.lc(t_),Lnc=$APP.mc(t_),Mnc=Knc,Nnc=$APP.Tc(Knc);n_=Lnc;o_=Mnc;p_=Nnc}else{var u_=$APP.u(t_);u_.F(null,new $APP.H(null,
2,5,$APP.I,[$APP.qa,GY],null),function(a,b,c,d,g){return function(l,n){n=$APP.xa(n);return g.A?g.A(l,n):g.call(null,l,n)}}(n_,o_,p_,q_,u_,t_,s_,ZZ,$Z));u_.F(null,new $APP.H(null,2,5,$APP.I,[GY,$APP.qa],null),function(a,b,c,d,g){return function(l,n){l=$APP.xa(l);return g.A?g.A(l,n):g.call(null,l,n)}}(n_,o_,p_,q_,u_,t_,s_,ZZ,$Z));u_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,CT],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(n_,o_,p_,q_,u_,t_,s_,ZZ,
$Z));u_.F(null,new $APP.H(null,2,5,$APP.I,[CT,$APP.qa],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(n_,o_,p_,q_,u_,t_,s_,ZZ,$Z));n_=$APP.w(t_);o_=null;p_=0}q_=0}else break}eH.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.add(b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.multiply(b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.Wc(b)});
PF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return a.Za()});hG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return $APP.k(a.nb())?a.Za():a});AG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.Xe(b)});xG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return $APP.k(a.nb())?a.Za():a});rI.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return $APP.k(b.nb())?OF.j(QTa(a,b.Za())):QTa(a,b)});
for(var v_=$APP.r(new $APP.H(null,8,5,$APP.I,[eH,MF,yG,wM,oM,rI,AG,qI],null)),w_=null,x_=0,y_=0;;)if(y_<x_){var z_=w_.aa(null,y_);z_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,GY],null),function(a,b,c,d,g){return function(l,n){n=$APP.Ca(n);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,z_,ZZ,$Z));z_.F(null,new $APP.H(null,2,5,$APP.I,[GY,$APP.za],null),function(a,b,c,d,g){return function(l,n){l=$APP.Ca(l);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,z_,ZZ,$Z));z_.F(null,new $APP.H(null,2,
5,$APP.I,[$APP.za,CT],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,z_,ZZ,$Z));z_.F(null,new $APP.H(null,2,5,$APP.I,[CT,$APP.za],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,z_,ZZ,$Z));z_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.qa],null),function(a,b,c,d,g){return function(l,n){n=$APP.Ca(n);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,z_,ZZ,$Z));z_.F(null,
new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.za],null),function(a,b,c,d,g){return function(l,n){l=$APP.Ca(l);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,z_,ZZ,$Z));y_+=1}else{var A_=$APP.r(v_);if(A_){var B_=A_;if($APP.pd(B_)){var Onc=$APP.lc(B_),Pnc=$APP.mc(B_),Qnc=Onc,Rnc=$APP.Tc(Onc);v_=Pnc;w_=Qnc;x_=Rnc}else{var C_=$APP.u(B_);C_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,GY],null),function(a,b,c,d,g){return function(l,n){n=$APP.Ca(n);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,C_,B_,
A_,ZZ,$Z));C_.F(null,new $APP.H(null,2,5,$APP.I,[GY,$APP.za],null),function(a,b,c,d,g){return function(l,n){l=$APP.Ca(l);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,C_,B_,A_,ZZ,$Z));C_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,CT],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,C_,B_,A_,ZZ,$Z));C_.F(null,new $APP.H(null,2,5,$APP.I,[CT,$APP.za],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,
l,n)}}(v_,w_,x_,y_,C_,B_,A_,ZZ,$Z));C_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.qa],null),function(a,b,c,d,g){return function(l,n){n=$APP.Ca(n);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,C_,B_,A_,ZZ,$Z));C_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.za],null),function(a,b,c,d,g){return function(l,n){l=$APP.Ca(l);return g.A?g.A(l,n):g.call(null,l,n)}}(v_,w_,x_,y_,C_,B_,A_,ZZ,$Z));v_=$APP.w(B_);w_=null;x_=0}y_=0}else break}
qI.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.div(b)});qI.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.divide(b)});var D_=function D_(a){switch(arguments.length){case 0:return D_.J();case 1:return D_.j(arguments[0]);case 2:return D_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};D_.J=function(){return 0};D_.j=function(a){return a};D_.A=function(a,b){return kG.A(a,b)};D_.G=2;
var E_=function E_(a){switch(arguments.length){case 1:return E_.j(arguments[0]);case 2:return E_.A(arguments[0],arguments[1]);case 3:return E_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};E_.j=function(a){return E_.B(a,a,a)};E_.A=function(a,b){return E_.B(a,a,b)};
E_.B=function(a,b,c){return function(){function d(n,p,v){p=$APP.Hj.A(p,v);return $APP.Vs.B($APP.Vg.j(n),b,p)}function g(n){n=$APP.Id.B(b,a.J?a.J():a.call(null),n);return c.j?c.j(n):c.call(null,n)}var l=null;l=function(n,p,v){switch(arguments.length){case 1:return g.call(this,n);case 3:return d.call(this,n,p,v)}throw Error("Invalid arity: "+arguments.length);};l.j=g;l.B=d;return l}()};E_.G=3;
var F_=function F_(a){switch(arguments.length){case 0:return F_.J();case 1:return F_.j(arguments[0]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};F_.J=function(){return F_.j(function(){return!0})};
F_.j=function(a){return function(){function b(d,g){return $APP.k(a.j?a.j(g):a.call(null,g))?d+1:d}var c=null;c=function(d,g){switch(arguments.length){case 0:return 0;case 1:return d;case 2:return b.call(this,d,g)}throw Error("Invalid arity: "+arguments.length);};c.J=function(){return 0};c.j=function(d){return d};c.A=b;return c}()};F_.G=1;
var G_=function G_(a){switch(arguments.length){case 0:return G_.J();case 1:return G_.j(arguments[0]);case 2:return G_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};G_.J=function(){return null};G_.j=function(a){return a};G_.A=function(a,b){return $APP.k(a)?a<b?a:b:b};G_.G=2;
var H_=function H_(a){switch(arguments.length){case 0:return H_.J();case 1:return H_.j(arguments[0]);case 2:return H_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};H_.J=function(){return null};H_.j=function(a){return a};H_.A=function(a,b){return $APP.k(a)?a>b?a:b:b};H_.G=2;
var I_=function I_(a){switch(arguments.length){case 0:return I_.J();case 1:return I_.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return I_.C(arguments[0],c)}};I_.J=function(){return RTa($APP.sf)};I_.j=function(a){return a};
I_.C=function(a,b){var c=$APP.Yd(a,b);return function(){function d(p,v){return $APP.Fl.B(function(t,A){return t.A?t.A(A,v):t.call(null,A,v)},c,p)}function g(p){return $APP.Fl.B(function(v,t){return v.j?v.j(t):v.call(null,t)},c,p)}function l(){return $APP.Fl.A(function(p){return p.J?p.J():p.call(null)},c)}var n=null;n=function(p,v){switch(arguments.length){case 0:return l.call(this);case 1:return g.call(this,p);case 2:return d.call(this,p,v)}throw Error("Invalid arity: "+arguments.length);};n.J=l;
n.j=g;n.A=d;return n}()};I_.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};I_.G=1;var EI=function EI(a){switch(arguments.length){case 1:return EI.j(arguments[0]);case 2:return EI.A(arguments[0],arguments[1]);case 3:return EI.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};EI.j=function(a){return EI.B(a,a,a)};EI.A=function(a,b){return EI.B(a,a,b)};
EI.B=function(a,b,c){return function(){function d(n,p,v){return l.j($APP.Vg.A(n,$APP.Hj.A(p,v)))}function g(n){return $APP.Vg.A(c,$APP.Fc($APP.St.B(b,a.J?a.J():a.call(null),n)))}var l=null;l=function(n,p,v){switch(arguments.length){case 1:return g.call(this,n);case 3:return d.call(this,n,p,v)}throw Error("Invalid arity: "+arguments.length);};l.j=g;l.B=d;return l}()};EI.G=3;
var J_=function J_(a){switch(arguments.length){case 0:return J_.J();case 1:return J_.j(arguments[0]);case 2:return J_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};J_.J=function(){return new $APP.H(null,2,5,$APP.I,[0,0],null)};J_.j=function(a){var b=$APP.x.B(a,0,null);$APP.x.B(a,1,null);return b};J_.A=function(a,b){var c=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);b-=a;a=c+b;return new $APP.H(null,2,5,$APP.I,[a,a-c-b],null)};J_.G=2;
var DI=function DI(a){switch(arguments.length){case 0:return DI.J();case 1:return DI.j(arguments[0]);case 2:return DI.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};DI.J=function(){return new $APP.H(null,2,5,$APP.I,[0,0],null)};DI.j=function(a){return $APP.Id.A($APP.wr,a)};DI.A=function(a,b){var c=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);var d=c+b;return new $APP.H(null,2,5,$APP.I,[d,a+(Math.abs(c)>=Math.abs(b)?c-d+b:b-d+c)],null)};
DI.G=2;var K_=function K_(a){switch(arguments.length){case 0:return K_.J();case 1:return K_.j(arguments[0]);case 2:return K_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};K_.J=function(){return new $APP.H(null,3,5,$APP.I,[0,0,0],null)};K_.j=function(a){return $APP.Id.A($APP.wr,a)};
K_.A=function(a,b){var c=$APP.x.B(a,0,null),d=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);var g=c+b;b=Math.abs(c)>=Math.abs(b)?c-g+b:b-g+c;c=d+b;return new $APP.H(null,3,5,$APP.I,[g,c,a+(Math.abs(d)>=Math.abs(b)?d-c+b:b-c+d)],null)};K_.G=2;var hL=E_.j(kG),FQ=function FQ(a){switch(arguments.length){case 1:return FQ.j(arguments[0]);case 3:return FQ.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};FQ.j=function(a){return DI.call(null,$APP.Id.B(DI,DI.call(null),a))};FQ.B=function(a,b,c){b=$APP.Hj.A(b,c);return $APP.Vs.B($APP.Vg.j(a),DI,b)};FQ.G=3;
var BI=function BI(a){switch(arguments.length){case 1:return BI.j(arguments[0]);case 3:return BI.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};BI.j=function(a){return $APP.Vg.A(DI,$APP.Fc($APP.St.B(DI,DI.call(null),a)))};BI.B=function(a,b,c){return BI.j($APP.Vg.A(a,$APP.Hj.A(b,c)))};BI.G=3;
var L_=function L_(a){switch(arguments.length){case 1:return L_.j(arguments[0]);case 3:return L_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};L_.j=function(a){return function d(c){var g=$APP.Tc(c);if(128>=g)return $APP.Id.A($APP.wr,c);var l=g>>1;g=$APP.oi.B(c,0,l);c=$APP.oi.A(c,l);return d(g)+d(c)}($APP.od(a)?a:$APP.Lf.A($APP.sf,a))};L_.B=function(a,b,c){return L_.j($APP.Fl.A(a,$APP.Hj.A(b,c)))};L_.G=3;
var M_=function M_(a){switch(arguments.length){case 2:return M_.A(arguments[0],arguments[1]);case 3:return M_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};M_.A=function(a,b){return M_.B(a,b,null)};
M_.B=function(a,b,c){var d=aUa(a,c);return function(){function g(p,v){return a.A?a.A(p,v):a.call(null,p,v)}var l=null,n=function(){function p(t,A,B){var G=null;if(2<arguments.length){G=0;for(var J=Array(arguments.length-2);G<J.length;)J[G]=arguments[G+2],++G;G=new $APP.Bc(J,0,null)}return v.call(this,t,A,G)}function v(t,A,B){return $APP.Id.B(d,t,$APP.Yd(A,B))}p.G=2;p.K=function(t){var A=$APP.u(t);t=$APP.w(t);var B=$APP.u(t);t=$APP.Fc(t);return v(A,B,t)};p.C=v;return p}();l=function(p,v,t){switch(arguments.length){case 0:return b;
case 1:return p;case 2:return g.call(this,p,v);default:var A=null;if(2<arguments.length){A=0;for(var B=Array(arguments.length-2);A<B.length;)B[A]=arguments[A+2],++A;A=new $APP.Bc(B,0,null)}return n.C(p,v,A)}throw Error("Invalid arity: "+arguments.length);};l.G=2;l.K=n.K;l.J=function(){return b};l.j=function(p){return p};l.A=g;l.C=n.C;return l}()};M_.G=3;
var N_=function N_(a){switch(arguments.length){case 4:return N_.M(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return N_.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};N_.M=function(a,b,c,d){return N_.S(a,b,c,d,null)};
N_.S=function(a,b,c,d,g){var l=aUa(b,g);return function(){function n(A,B){return a.A?a.A(A,B):a.call(null,A,B)}function p(A){return c.j?c.j(A):c.call(null,A)}var v=null,t=function(){function A(G,J,O){var Q=null;if(2<arguments.length){Q=0;for(var W=Array(arguments.length-2);Q<W.length;)W[Q]=arguments[Q+2],++Q;Q=new $APP.Bc(W,0,null)}return B.call(this,G,J,Q)}function B(G,J,O){J=$APP.Id.B(l,J,O);return a.A?a.A(G,J):a.call(null,G,J)}A.G=2;A.K=function(G){var J=$APP.u(G);G=$APP.w(G);var O=$APP.u(G);G=
$APP.Fc(G);return B(J,O,G)};A.C=B;return A}();v=function(A,B,G){switch(arguments.length){case 0:return d;case 1:return p.call(this,A);case 2:return n.call(this,A,B);default:var J=null;if(2<arguments.length){J=0;for(var O=Array(arguments.length-2);J<O.length;)O[J]=arguments[J+2],++J;J=new $APP.Bc(O,0,null)}return t.C(A,B,J)}throw Error("Invalid arity: "+arguments.length);};v.G=2;v.K=t.K;v.J=function(){return d};v.j=p;v.A=n;v.C=t.C;return v}()};N_.G=5;/*

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
HG.ld={};HG.ld.s=function(a,b,c){return isNaN(c)||""==c||a.length>=Number(c)?a:a=-1<b.indexOf("-",0)?a+(0,$APP.Hs)(" ",Number(c)-a.length):(0,$APP.Hs)(" ",Number(c)-a.length)+a};
HG.ld.f=function(a,b,c,d,g){d=a.toString();isNaN(g)||""==g||(d=parseFloat(a).toFixed(g));let l;l=0>Number(a)?"-":0<=b.indexOf("+")?"+":0<=b.indexOf(" ")?" ":"";0<=Number(a)&&(d=l+d);if(isNaN(c)||d.length>=Number(c))return d;d=isNaN(g)?Math.abs(Number(a)).toString():Math.abs(Number(a)).toFixed(g);a=Number(c)-d.length-l.length;0<=b.indexOf("-",0)?d=l+d+(0,$APP.Hs)(" ",a):(b=0<=b.indexOf("0",0)?"0":" ",d=l+(0,$APP.Hs)(b,a)+d);return d};
HG.ld.d=function(a,b,c,d,g,l,n,p){return HG.ld.f(parseInt(a,10),b,c,d,0,l,n,p)};HG.ld.i=HG.ld.d;HG.ld.u=HG.ld.d;var Snc=new $APP.H(null,3,5,$APP.I,[3,43,0],null);$APP.Uc.A("default","nodejs");var Tnc="undefined"!==typeof window?window:null,YG=function YG(a){switch(arguments.length){case 3:return YG.B(arguments[0],arguments[1],arguments[2]);case 2:return YG.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(3),0,null);return YG.C(arguments[0],arguments[1],arguments[2],c)}};
YG.B=function(a,b,c){return $APP.Bd(a,b)?a:$APP.rg.B(a,b,c)};YG.C=function(a,b,c,d){return eUa(YG,YG.B(a,b,c),d)};YG.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};YG.A=function(a,b){return $APP.Jd(function(c,d,g){return $APP.Bd(c,d)?c:$APP.rg.B(c,d,g)},null==a?$APP.F:a,b)};YG.G=3;
var O_=function O_(a){switch(arguments.length){case 2:return O_.A(arguments[0],arguments[1]);case 3:return O_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};O_.A=function(a,b){b=0>b?0:b;var c=$APP.Tc(a);return b>=c?$APP.sf:$APP.oi.B(a,b,c)};O_.B=function(a,b,c){b=0>b?0:b;var d=$APP.Nd($APP.Tc(a));c=c>d?d:c;return b>=c?$APP.sf:$APP.oi.B(a,b,c)};O_.G=3;
var P_=function P_(a){switch(arguments.length){case 2:return P_.A(arguments[0],arguments[1]);case 3:return P_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};P_.A=function(a,b){var c=$APP.Tc(a);return 0>b?(b+=c,$APP.oi.B(a,0>b?0:b,c)):b>=c?$APP.sf:$APP.oi.B(a,b,c)};
P_.B=function(a,b,c){if(0>=c)return $APP.sf;var d=$APP.Nd($APP.Tc(a));if(0>b)return b+=d,b=0>b?0:b,c=b+c,$APP.oi.B(a,b,c>d?d:c);c=b+c;d=c>d?d:c;return b>=d?$APP.sf:$APP.oi.B(a,b,d)};P_.G=3;$APP.Pi.A($APP.Id,$APP.N);
(function(){var a=$APP.Na(Tnc,$APP.Ag("performance"),null);if($APP.k(a)){var b=function(){var c=$APP.Na(a,$APP.Ag("now"),null);if($APP.k(c))return c;c=$APP.Na(a,$APP.Ag("mozNow"),null);if($APP.k(c))return c;c=$APP.Na(a,$APP.Ag("msNow"),null);if($APP.k(c))return c;c=$APP.Na(a,$APP.Ag("oNow"),null);return $APP.k(c)?c:$APP.Na(a,$APP.Ag("webkitNow"),null)}();return $APP.k(b)?function(){return 1E6*$APP.Nd(b.call(a))}:function(){return 1E6*(new Date).getTime()}}return function(){return 1E6*(new Date).getTime()}})();
var Unc=function(){function a(d){return new $APP.Sa(d)}function b(){return new $APP.Sa}var c=null;c=function(d){switch(arguments.length){case 0:return b.call(this);case 1:return a.call(this,d)}throw Error("Invalid arity: "+arguments.length);};c.J=b;c.j=a;return c}(),tVa=function(){function a(g,l){g=g instanceof $APP.Sa?g:Unc.j($APP.m.j(g));l=$APP.m.j(l);return g.append(l)}function b(g){return g instanceof $APP.Sa?g:Unc.j($APP.m.j(g))}function c(){return Unc.J()}var d=null;d=function(g,l){switch(arguments.length){case 0:return c.call(this);
case 1:return b.call(this,g);case 2:return a.call(this,g,l)}throw Error("Invalid arity: "+arguments.length);};d.J=c;d.j=b;d.A=a;return d}();$APP.mh(function(a,b){var c=$APP.Tc(a);b=$APP.Nd(b);if(1>c||256<c)throw $APP.Zi.A("`alphabet`: must be [1,256]",$APP.F);if(0>=b)throw $APP.Zi.A("`len`: must be [0,)",$APP.F);var d=(2<<(Math.floor(Math.log(c-1)/Math.log(2))|0))-1;return new $APP.H(null,3,5,$APP.I,[d,$APP.Nd(Math.ceil(1.6*d*b/c)),$APP.Fl.A($APP.m,a)],null)});$APP.Fl.A($APP.m,"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_");
var Q_=function Q_(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return Q_.C(c)};
Q_.C=function(a){var b=$APP.qe(a);a=$APP.C.A(b,$APP.GBa);var c=$APP.C.A(b,wmb),d=$APP.C.A(b,mEb),g=$APP.C.A(b,gGb),l=$APP.C.A(b,$Qb),n=$APP.C.A(b,eob),p=$APP.C.A(b,X7b),v=$APP.C.A(b,pub);b=$APP.C.A(b,fVb);return Math.round(($APP.k(b)?31536E6*b:0)+($APP.k(g)?2551392E3*g:0)+($APP.k(c)?6048E5*c:0)+($APP.k(p)?864E5*p:0)+($APP.k(v)?36E5*v:0)+($APP.k(n)?6E4*n:0)+($APP.k(l)?1E3*l:0)+($APP.k(d)?d:0)+($APP.k(a)?a:0))};Q_.G=0;Q_.K=function(a){return this.C($APP.r(a))};
$APP.Hl.A(function(a){return $APP.Pd($APP.Nd(a),1E3)},Q_);$APP.Hl.A($APP.re,O_);$APP.Hl.A($APP.re,P_);var R_=function R_(a){switch(arguments.length){case 2:return R_.A(arguments[0],arguments[1]);case 3:return R_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};R_.A=function(a,b){return a.substring(b)};R_.B=function(a,b,c){return b>=c?"":a.substring(b,c)};R_.G=3;
var S_=function S_(a){switch(arguments.length){case 2:return S_.A(arguments[0],arguments[1]);case 3:return S_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};S_.A=function(a,b){return cUa(a.substr(b))};S_.B=function(a,b,c){return cUa(a.substr(b,c))};S_.G=3;$APP.Hl.A(cUa,R_);$APP.Hl.A(cUa,S_);$APP.kh.j($APP.xu);var Vnc={jj:["BC","AD"],ij:["Before Christ","Anno Domini"],lj:"JFMAMJJASOND".split(""),sj:"JFMAMJJASOND".split(""),kj:"January February March April May June July August September October November December".split(" "),rj:"January February March April May June July August September October November December".split(" "),oj:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),uj:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),xj:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
wj:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),qj:"Sun Mon Tue Wed Thu Fri Sat".split(" "),vj:"Sun Mon Tue Wed Thu Fri Sat".split(" "),fl:"SMTWTFS".split(""),tj:"SMTWTFS".split(""),pj:["Q1","Q2","Q3","Q4"],mj:["1st quarter","2nd quarter","3rd quarter","4th quarter"],fj:["AM","PM"],uh:["EEEE, MMMM d, y","MMMM d, y","MMM d, y","M/d/yy"],yh:["h:mm:ss a zzzz","h:mm:ss a z","h:mm:ss a","h:mm a"],gj:["{1} 'at' {0}","{1} 'at' {0}","{1}, {0}","{1}, {0}"],vh:6,il:[5,6],wh:5},TUa=
Vnc;TUa=Vnc;var YUa=[/^'(?:[^']|'')*('|$)/,/^(?:G+|y+|Y+|M+|k+|S+|E+|a+|h+|K+|H+|c+|L+|Q+|d+|m+|s+|v+|V+|w+|z+|Z+)/,/^[^'GyYMkSEahKHcLQdmsvVwzZ]+/];
WUa.prototype.format=function(a,b){if(!a)throw Error("The date to format must be non-null.");var c=b?6E4*(a.getTimezoneOffset()-(b.Tf-QG(b,a))):0;let d=c?new Date(a.getTime()+c):a,g=d;b&&d.getTimezoneOffset()!=a.getTimezoneOffset()&&(d=new Date(d.getTime()+6E4*(d.getTimezoneOffset()-a.getTimezoneOffset())),g=new Date(a.getTime()+(c+(0<c?-864E5:864E5))));c=[];for(let l=0;l<this.Kf.length;++l){const n=this.Kf[l].text;1==this.Kf[l].type?c.push(ZUa(this,n,a,d,g,b)):c.push(n)}return c.join("")};
var XUa=!1;(function(a){var b=$APP.x.B(Snc,0,null),c=$APP.x.B(Snc,1,null),d=$APP.x.B(Snc,2,null),g=$APP.od(a)?a:hUa.j(jUa(a));a=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);g=$APP.Fl.A(function(n){return $APP.k(n)?n:0},new $APP.H(null,3,5,$APP.I,[a,l,g],null));a=$APP.x.B(g,0,null);l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);if(b>a||$APP.Uc.A(b,a)&&(c>l||$APP.Uc.A(c,l)&&d>=g))return null;throw $APP.Zi.A("Insufficient `com.taoensso/encore` version, you may have a dependency conflict: see http://goo.gl/qBbLvC for solutions.",
new $APP.f(null,2,[f6b,$APP.Il.A(".",new $APP.H(null,3,5,$APP.I,[a,l,g],null)),XEb,$APP.Il.A(".",new $APP.H(null,3,5,$APP.I,[b,c,d],null))],null));})(new $APP.H(null,3,5,$APP.I,[3,43,0],null));
var Wnc=$APP.mh(function(a){return FUa(a)}),dVa=$APP.mh(function(a,b){a=Wnc(a);return a.j?a.j(b):a.call(null,b)}),fVa=$APP.mh(function(a,b){return gUa(function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return $APP.k(dVa(d,b))?bVa(c):null},a)}),UVa=$APP.mh(function(a,b){a=wUa(b);$APP.x.B(a,0,null);return $APP.x.B(a,1,null)}),ZG=function ZG(a){switch(arguments.length){case 2:return ZG.A(arguments[0],arguments[1]);case 1:return ZG.j(arguments[0]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));
}};ZG.A=function(a,b){a=$APP.hd(a)?b:$APP.rg.B(b,VG,$APP.Vd.A(a,$APP.C.A(b,VG)));return ZG.j(a)};
ZG.j=function(a){var b=$APP.qe(a),c=$APP.C.A(b,VG);$APP.C.A(b,OUa);var d=$APP.C.A(b,xVa);$APP.C.A(b,zyb);var g=$APP.C.A(b,wVa),l=$APP.C.A(b,$APP.Zu),n=$APP.C.A(b,NG),p=$APP.C.A(b,YVa);b=$APP.C.A(b,yVa);return[function(){var v=$APP.dh(p);return $APP.k(v)?[$APP.m.j(v)," "].join(""):null}(),$APP.li($APP.Ag(l))," [",$APP.m.j($APP.k(g)?g:$APP.k(d)?d:"?"),":",$APP.m.j($APP.k(b)?b:"?"),"] - ",$APP.m.j(function(){var v=$APP.C.B(c,t8b,uVa);return $APP.k(v)?v.j?v.j(a):v.call(null,a):null}()),function(){if($APP.k(n)){var v=
$APP.C.B(c,Cac,T_);return $APP.k(v)?$APP.k($APP.C.A(c,Hqb))?null:["\n",$APP.m.j(v.j?v.j(a):v.call(null,a))].join(""):null}return null}()].join("")};ZG.G=2;
var T_=function T_(a){var c=$APP.qe(a),d=$APP.C.A(c,NG);$APP.C.A(c,VG);return[$APP.m.j(d.stack),function(){var g=$APP.Ih(d);return $APP.k(g)?["\nex-data:\n    ",$APP.jh.C($APP.y([g]))].join(""):null}(),function(){var g=$APP.Kh(d);if($APP.k(g)){var l=$APP.m;var n=l.j;g=$APP.rg.B(c,NG,g);g=T_.j?T_.j(g):T_.call(null,g);l=["\n\nCaused by:\n",n.call(l,g)].join("")}else l=null;return l}()].join("")},PVa=new $APP.f(null,1,[NVa,OVa],null),jVa=new $APP.f(null,6,[kVa,$APP.xu,lVa,new $APP.ug(null,new $APP.f(null,
1,["*",null],null),null),IVa,$APP.sf,QVa,PVa,OG,ZG,$Va,"undefined"!==typeof window?new $APP.f(null,1,[hMb,LUa.j?LUa.j($APP.F):LUa.call(null,$APP.F)],null):new $APP.f(null,1,[ysb,HUa.j?HUa.j($APP.F):HUa.call(null,$APP.F)],null)],null);var EJ=function EJ(a){switch(arguments.length){case 2:return EJ.A(arguments[0],arguments[1]);case 3:return EJ.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};EJ.A=function(a,b){return EJ.B(a,b,null)};EJ.B=function(a,b){$APP.k(!0)&&$G($APP.hw,"emmy.util.logic",22,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,[["Assuming ",$APP.m.j(a)," in ",$APP.m.j(b)].join("")],null)},null),-1664117629);return!0};EJ.G=3;var RM=null,fH=aH($APP.Fv),hH=aH($APP.Ev),y0a=aH(FJ),bH=aH(DJ),Xnc=aH($APP.rj),Ync=aH(hK),nWa=aH(cH),lH=Math.PI,Znc=lH/4,gWa=2*lH,fWa=2*Znc,U_=function U_(a){switch(arguments.length){case 1:return U_.j(arguments[0]);case 2:return U_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
U_.j=function(a){return EF(a)?$APP.eb(TF.j(a))?rG.j(a):$APP.k(KF.j(a))?0:new $APP.D(null,hK,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,hK,new $APP.D(null,a,null,1,null),2,null)};
U_.A=function(a,b){if($APP.k(sG.j(b)))return U_.j(a);if($APP.k(UF(a))){if(EF(b))return $APP.k(qG.j(b))?nH:0;a=EJ.A($APP.T.j($APP.r($APP.N.A(new $APP.D(null,rM,null,1,null),new $APP.D(null,b,null,1,null)))),EZb);return $APP.k(a)?0:a}if($APP.k(UF(b))){if(EF(a))return $APP.k(qG.j(a))?$APP.M($APP.Gv,$APP.M($APP.rj,nH,2)):$APP.M($APP.rj,nH,2);a=EJ.A($APP.T.j($APP.r($APP.N.A(new $APP.D(null,rM,null,1,null),new $APP.D(null,a,null,1,null)))),EZb);return $APP.k(a)?$APP.M($APP.rj,nH,2):a}return EF(b)&&EF(a)&&
($APP.eb(TF.j(b))||$APP.eb(TF.j(a)))?rG.A(a,b):new $APP.D(null,hK,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)};U_.G=2;
var $nc=dH(jG,FJ),aoc=dH(pG,BJ),boc=dH(oG,zJ),CH=function CH(a,b){if(EF(a)&&EF(b))return rI.A(a,b);if(EF(a))return $APP.k(sG.j(a))?1:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,DJ,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))));if(EF(b)){if($APP.k(KF.j(b)))return 1;if($APP.k(sG.j(b)))return a;if($APP.k(function(){var l=$APP.xd(b);return l?(l=$APP.Ie(b))?y0a(a):l:l}())){var d=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a)),g=$APP.Pd(b,2);return CH.A?CH.A(d,
g):CH.call(null,d,g)}return $APP.k(function(){var l=bH(a);return $APP.k(l)?EF($APP.Xc($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a)))&&$APP.xd($APP.Xc($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a))*b):l}())?(d=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a)),g=$APP.Xc($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a))*b,CH.A?CH.A(d,g):CH.call(null,d,g)):0>b?eWa(function(){var l=-b;return CH.A?CH.A(a,l):CH.call(null,a,l)}()):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,DJ,null,1,null),new $APP.D(null,a,null,
1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))}return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,DJ,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))},coc=new $APP.ug(null,new $APP.f(null,31,[eW,null,tV,null,xP,null,wH,null,kH,null,lK,null,sH,null,jdc,null,$APP.rj,null,hX,null,BJ,null,uH,null,DJ,null,$APP.Fv,null,LM,null,PX,null,sT,null,kob,null,aT,null,wQb,null,$APP.Ev,null,Vtb,null,hK,null,NM,null,kK,null,$APP.Gv,null,wP,null,FJ,null,jK,null,zJ,null,oX,null],
null),null),yH=function yH(a){return EF(a)?qL.j(a):$APP.td(a)&&$APP.Bd(coc,$APP.u.j?$APP.u.j(a):$APP.u.call(null,a))?$APP.Yd($APP.u.j?$APP.u.j(a):$APP.u.call(null,a),$APP.Vg.A(yH,$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a))):new $APP.D(null,nY,new $APP.D(null,a,null,1,null),2,null)},doc=dH(xG,function(a){return $nc(iH(yH(a),a))}),eoc=dH(PZ,function(a){return U_.A(lWa(a),zH(a))}),V_=function V_(a){switch(arguments.length){case 0:return V_.J();case 1:return V_.j(arguments[0]);case 2:return V_.A(arguments[0],
arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return V_.C(arguments[0],arguments[1],c)}};V_.J=function(){return!0};V_.j=function(){return!0};V_.A=function(a,b){return qWa(a,b)};V_.C=function(a,b,c){a=$APP.Yd(a,$APP.Yd(b,c));a=$APP.Jl.B(2,1,a);return $APP.Id.B(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);l=qWa(l,g);return $APP.k(l)?pWa(d,l):$APP.Mc(!1)},!0,a)};
V_.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};V_.G=2;
var sWa=$APP.fg([eS,$APP.io,eW,DT,tV,wH,kH,lK,sH,iK,YX,$APP.rj,$APP.Iu,hX,GX,$APP.Gu,$T,BJ,$APP.Zv,uH,tW,DJ,xW,$APP.Fv,LM,PX,sT,aT,AK,$APP.Ev,$APP.zv,hK,PV,NM,DV,kK,XS,bT,hV,$APP.Gv,rX,jY,nY,FJ,jK,zJ,WV,Dub,oX,$APP.no,jS,CY,D$b],[function foc(a,b){return bWa(a,b,foc,eS)},M_.B(pWa,!0,$APP.Bba),function(a){return jH(1,kWa(a))},function(a,b){return $APP.k(UF(a))?a:$APP.k(UF(b))?a:DF(a)&&DF(b)?OZ.A(a,b):iH(a,gH(iWa(b),iH(nG,hWa(b))))},function(a){return CH(a,3)},kWa,hWa,function(a){return EF(a)?$APP.k(TF.j(a))?
$APP.k(KF.j(a))?0:new $APP.D(null,lK,new $APP.D(null,a,null,1,null),2,null):SF(a/lH)?0:SF((a-Znc)/lH)?1:SF((a+Znc)/lH)?-1:SF((a-fWa)/lH)?AD("Undefined: tan"):Math.tan(a):a instanceof $APP.q?$APP.k((new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,4,[mH,null,nH,null,oH,null,pH,null],null),null)).call(null,a))?0:$APP.k((new $APP.ug(null,new $APP.f(null,
2,[mK,null,nK,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[mK,null,nK,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[mK,null,nK,null],null),null)).call(null,a))?1:$APP.k((new $APP.ug(null,new $APP.f(null,1,[oK,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[oK,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,1,[oK,null],null),null)).call(null,a))?-1:$APP.k((new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,
2,[qH,null,rH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).call(null,a))?AD("Undefined: tan"):new $APP.D(null,lK,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,lK,new $APP.D(null,a,null,1,null),2,null)},iWa,M_.A(function(a,b){return EF(a)&&EF(b)?wM.A(a,b):EF(a)?$APP.k(KF.j(a))?b:$APP.k(sG.j(a))?1:new $APP.D(null,iK,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null):EF(b)?$APP.k(KF.j(b))?a:$APP.k(sG.j(b))?1:new $APP.D(null,iK,new $APP.D(null,
a,new $APP.D(null,b,null,1,null),2,null),3,null):$APP.Uc.A(a,b)?a:new $APP.D(null,iK,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)},0),function goc(a,b){return bWa(a,b,goc,YX)},N_.S(jH,iH,eWa,1,KF),function(a){return EF(a)?hG.j(a):new $APP.D(null,$APP.Iu,new $APP.D(null,a,null,1,null),2,null)},eWa,mWa,function(a){return $APP.sd(a)?!a:new $APP.D(null,$APP.Gu,new $APP.D(null,a,null,1,null),2,null)},zH,aoc,V_,jWa,function(a){return jH(jWa(a),kWa(a))},CH,function(a){return EF(a)?sZ.j(a):
new $APP.D(null,xW,new $APP.D(null,a,null,1,null),2,null)},M_.A(gH,0),function(a){return EF(a)?$APP.eb(TF.j(a))?wZ.j(a):$APP.k(KF.j(a))?1:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.rj,null,1,null),new $APP.D(null,1,null,1,null),$APP.y([new $APP.D(null,iWa(a),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.rj,null,1,null),new $APP.D(null,1,null,1,null),$APP.y([new $APP.D(null,iWa(a),null,1,null)]))))},dWa,function(a){return jH(1,jWa(a))},function(a){return CH(a,2)},doc,M_.B(iH,1,
KF),function(a){return EF(a)?KF.j(a):new $APP.D(null,$APP.Zv,new $APP.D(null,0,new $APP.D(null,a,null,1,null),2,null),3,null)},U_,function(a,b){return $APP.k(UF(b))?a:DF(a)&&DF(b)?NZ.A(a,b):gH(a,iH(nG,b))},function(a){return EF(a)?$APP.eb(TF.j(a))?vZ.j(a):$APP.k(KF.j(a))?AD(["Zero argument -- g/csc",$APP.m.j(a)].join("")):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.rj,null,1,null),new $APP.D(null,1,null,1,null),$APP.y([new $APP.D(null,hWa(a),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.rj,null,1,null),new $APP.D(null,1,null,1,null),$APP.y([new $APP.D(null,hWa(a),null,1,null)]))))},M_.B(function(a,b){return EF(a)&&EF(b)?oM.A(a,b):EF(a)?$APP.k(KF.j(a))?0:$APP.k(sG.j(a))?b:new $APP.D(null,DV,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null):EF(b)?$APP.k(KF.j(b))?0:$APP.k(sG.j(b))?a:new $APP.D(null,DV,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null):$APP.Uc.A(a,b)?a:new $APP.D(null,DV,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)},
1,KF),function(a){return EF(a)?$APP.eb(TF.j(a))?kO.j(a):$APP.k(sG.j(a))?0:new $APP.D(null,kK,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,kK,new $APP.D(null,a,null,1,null),2,null)},function(a){return cWa($APP.M($APP.rj,nH,2),U_.j(a))},function(a){return EF(a)?pZ.j(a):new $APP.D(null,bT,new $APP.D(null,a,null,1,null),2,null)},lWa,N_.M(cWa,gH,dWa,0),mWa,function(a){return EF(a)?rZ.j(a):new $APP.D(null,jY,new $APP.D(null,a,null,1,null),2,null)},yH,$nc,function(a){return EF(a)?$APP.eb(TF.j(a))?
xZ.j(a):$APP.k(KF.j(a))?0:new $APP.D(null,jK,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,jK,new $APP.D(null,a,null,1,null),2,null)},boc,function(a){return EF(a)?qZ.j(a):new $APP.D(null,WV,new $APP.D(null,a,null,1,null),2,null)},oWa,function(a){return jH(kWa(a),jWa(a))},M_.B(function(a,b){return!0===a?a:!1===a?b:!0===b?b:!1===b?a:$APP.Uc.A(a,b)?b:new $APP.D(null,$APP.no,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)},!1,$APP.rd),rWa,eoc,rWa]);var DM=function DM(a){switch(arguments.length){case 0:return DM.J();case 1:return DM.j(arguments[0]);case 2:return DM.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};DM.J=function(){return DM.A(4,"_")};DM.j=function(a){return DM.A(a,"_")};
DM.A=function(a,b){var c=$APP.kh.j(0);return function(){function d(n){var p=$APP.m.j($APP.lh.A(c,$APP.Lc)),v=a-p.length;0>v&&BD(["Symbol generator of width ",$APP.m.j(a)," exhausted"].join(""));return $APP.Zg.j($APP.Je.A($APP.m,$APP.N.C($APP.m.j(n),$APP.Uj.A(v,"0"),$APP.y([p]))))}function g(){return l.j(b)}var l=null;l=function(n){switch(arguments.length){case 0:return g.call(this);case 1:return d.call(this,n)}throw Error("Invalid arity: "+arguments.length);};l.J=g;l.j=d;return l}()};DM.G=2;
var hoc=function(){function a(d,g,l,n){var p=W_[$APP.la(null==d?null:d)];if(null!=p)return p.M?p.M(d,g,l,n):p.call(null,d,g,l,n);p=W_._;if(null!=p)return p.M?p.M(d,g,l,n):p.call(null,d,g,l,n);throw $APP.ib("ICanonicalize.expression-\x3e",d);}function b(d,g,l){var n=W_[$APP.la(null==d?null:d)];if(null!=n)return n.B?n.B(d,g,l):n.call(null,d,g,l);n=W_._;if(null!=n)return n.B?n.B(d,g,l):n.call(null,d,g,l);throw $APP.ib("ICanonicalize.expression-\x3e",d);}var c=null;c=function(d,g,l,n){switch(arguments.length){case 3:return b.call(this,
d,g,l);case 4:return a.call(this,d,g,l,n)}throw Error("Invalid arity: "+arguments.length);};c.B=b;c.M=a;return c}(),W_=function W_(a){switch(arguments.length){case 3:return W_.B(arguments[0],arguments[1],arguments[2]);case 4:return W_.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};W_.B=function(a,b,c){return null!=a&&null!=a.Jg?a.Jg(a,b,c):hoc(a,b,c)};
W_.M=function(a,b,c,d){return null!=a&&null!=a.Af?a.Af(a,b,c,d):hoc(a,b,c,d)};W_.G=4;var EM=function EM(a){switch(arguments.length){case 1:return EM.j(arguments[0]);case 2:return EM.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};EM.j=function(a){return EM.A(a,DM.A(16,"-g-"))};
EM.A=function(a,b){function c(Z){var fa=$APP.Dj.j($APP.Vg.A(p,Z));Z=$APP.u.j?$APP.u.j(fa):$APP.u.call(null,fa);var ha=DH(Z);return $APP.k(ha)?(fa=$APP.Je.A(ha,$APP.Fc.j?$APP.Fc.j(fa):$APP.Fc.call(null,fa)),$APP.kd(fa)&&$APP.Uc.A($APP.u.j?$APP.u.j(fa):$APP.u.call(null,fa),Z)?d(fa):Q(fa)):d(fa)}function d(Z){Z=$APP.Dj.j($APP.Vg.A(B,Z));return B(Z)}function g(Z){return W(l(Z))}function l(Z){var fa=RM;RM=!1;try{var ha=tWa(ZF(Z));$APP.Ne(O,ha);var ja=Q(Z);return p(ja)}finally{RM=fa}}function n(Z){v();
return g(YF(Z))}function p(Z){return $APP.k(t(Z))?W_(a,Z,function(fa,ha){return uWa(a,fa,ha)},A):Z}function v(){$APP.Ne(O,$APP.Ed);$APP.Ne.A?$APP.Ne.A(G,$APP.F):$APP.Ne.call(null,G,$APP.F);$APP.Ne.A?$APP.Ne.A(J,$APP.F):$APP.Ne.call(null,J,$APP.F);return null}function t(Z){return $APP.kd(Z)&&!$APP.Uc.A($APP.u(Z),$APP.K)}function A(Z,fa){var ha=$APP.Fb(O);return ha.A?ha.A(Z,fa):ha.call(null,Z,fa)}function B(Z){if($APP.k(t(Z))){var fa=aG.j(Z);var ha=$APP.Fb(G);ha=ha.j?ha.j(fa):ha.call(null,fa);$APP.k(ha)?
Z=ha:(ha=b.J?b.J():b.call(null),$APP.lh.M?$APP.lh.M(G,$APP.rg,fa,ha):$APP.lh.call(null,G,$APP.rg,fa,ha),$APP.lh.M?$APP.lh.M(J,$APP.rg,ha,Z):$APP.lh.call(null,J,$APP.rg,ha,Z),Z=ha);return Z}return Z}var G=$APP.kh.j?$APP.kh.j($APP.F):$APP.kh.call(null,$APP.F),J=$APP.kh.j?$APP.kh.j($APP.F):$APP.kh.call(null,$APP.F),O=$APP.kh.j($APP.Ed),Q=function ha(fa){if($APP.k(t(fa))){var ja=$APP.Dj.j($APP.Vg.A(ha,fa));if($APP.k(function(){var ta=vWa(a,$APP.u.j?$APP.u.j(ja):$APP.u.call(null,ja));$APP.k(ta)&&($APP.k(!0)?
(ta=bH(ja),ta=$APP.k(ta)?!CF($APP.Xc($APP.Fc.j?$APP.Fc.j(ja):$APP.Fc.call(null,ja))):ta):ta=!0,ta=$APP.eb(ta));return ta}()))return ja;fa=function(){var ta=$APP.Fb(G);return ta.j?ta.j(ja):ta.call(null,ja)}();return $APP.k(fa)?fa:c(ja)}return fa},W=function ja(ha){if($APP.kd(ha))return $APP.Dj.j($APP.Vg.A(ja,ha));if(ha instanceof $APP.q){var ta=$APP.Fb(J);ta=ta.j?ta.j(ha):ta.call(null,ha);return $APP.k(ta)?ja(ta):ha}return ha};return new $APP.f(null,6,[wWa,function(ha){return XF(ha)?bTa(n,ha):n(ha)},
yWa,function(ha){return XF(ha)?bTa(g,ha):g(ha)},fIb,v,JUb,l,PMb,function(){return $APP.Fb(J)},nNb,function(){return $APP.Fb(G)}],null)};EM.G=2;$APP.e=IH.prototype;$APP.e.Ka=function(a,b){return this.fa(null,b,null)};$APP.e.fa=function(a,b,c){switch(b instanceof $APP.E?b.ga:null){case "id-\x3epartial":return this.Pc;default:return $APP.C.B(this.N,b,c)}};$APP.e.lb=function(a,b,c){return $APP.Id.B(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return b.B?b.B(d,l,g):b.call(null,d,l,g)},c,this)};
$APP.e.ea=function(a,b,c){return $APP.Rg(b,function(d){return $APP.Rg(b,$APP.Ug,""," ","",c,d)},"#emmy.dual.Completed{",", ","}",c,$APP.N.A(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[wV,this.Pc],null)],null),this.N))};$APP.e.Qa=function(){return new $APP.Ff(this,1,new $APP.H(null,1,5,$APP.I,[wV],null),$APP.k(this.N)?$APP.qc(this.N):$APP.we())};$APP.e.ba=function(){return this.R};$APP.e.qa=function(){return new IH(this.Pc,this.R,this.N,this.P)};$APP.e.ta=function(){return 1+$APP.Tc(this.N)};
$APP.e.ka=function(){var a=this.P;return null!=a?a:this.P=a=804361140^$APP.Kc(this)};$APP.e.Y=function(a,b){return null!=b&&this.constructor===b.constructor&&$APP.Uc.A(this.Pc,b.Pc)&&$APP.Uc.A(this.N,b.N)};$APP.e.ac=function(a,b,c){return new IH(FH(this.Pc,b,c),null,null,null)};$APP.e.$b=function(){return null};$APP.e.ic=function(a,b){return $APP.C.B(this.Pc,b,0)};
$APP.e.Ib=function(a,b){return $APP.Bd(new $APP.ug(null,new $APP.f(null,1,[wV,null],null),null),b)?$APP.Oi.A($APP.Ib($APP.Lf.A($APP.F,this),this.R),b):new IH(this.Pc,this.R,$APP.re($APP.Oi.A(this.N,b)),null)};$APP.e.Va=function(a,b){switch(b instanceof $APP.E?b.ga:null){case "id-\x3epartial":return!0;default:return $APP.Bd(this.N,b)}};
$APP.e.sa=function(a,b,c){return $APP.k($APP.$d.A?$APP.$d.A(wV,b):$APP.$d.call(null,wV,b))?new IH(c,this.R,this.N,null):new IH(this.Pc,this.R,$APP.rg.B(this.N,b,c),null)};$APP.e.ma=function(){return $APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[new $APP.Cd(wV,this.Pc,null)],null),this.N))};$APP.e.da=function(a,b){return new IH(this.Pc,b,this.N,this.P)};$APP.e.ua=function(a,b){return $APP.od(b)?this.sa(null,$APP.bd(b,0),$APP.bd(b,1)):$APP.Id.B($APP.nb,this,b)};var X_=AWa($APP.F);
KF.F(null,new $APP.H(null,1,5,$APP.I,[IH],null),function(){return!1});sG.F(null,new $APP.H(null,1,5,$APP.I,[IH],null),function(){return!1});iZ.F(null,new $APP.H(null,1,5,$APP.I,[IH],null),function(){return!1});zWa["null"]=!0;FH["null"]=function(){return null};HH["null"]=function(){return 0};GH["null"]=function(a,b,c){return $APP.Uc.A(c,RH)?0:X_};zWa._=!0;FH._=function(a){return a};HH._=function(){return 0};GH._=function(a,b,c){return $APP.Uc.A(c,RH)?tG.j(a):X_};var BWa=$APP.kh.j(-1);
$APP.hu.A(hN,FF);$APP.e=KH.prototype;$APP.e.ac=function(a,b,c){return $APP.Uc.A(b,this.tag)?new KH(c,this.xc,this.Be):this};$APP.e.$b=function(a,b,c){return $APP.qg.A(c,RH)?X_:$APP.Uc.A(b,this.tag)?this.Be:0};$APP.e.rb=function(){return hN};$APP.e.valueOf=function(){return this.xc.valueOf()};$APP.e.toString=function(){return["#emmy.dual.Dual",$APP.m.j(new $APP.f(null,3,[$APP.sj,this.tag,Jcb,this.xc,dob,this.Be],null))].join("")};$APP.e.Y=function(a,b){return Y_.A?Y_.A(this,b):Y_.call(null,this,b)};
$APP.e.Tb=function(a,b){return EWa.A?EWa.A(this,b):EWa.call(null,this,b)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};var bN=function bN(a){switch(arguments.length){case 1:return bN.j(arguments[0]);case 2:return bN.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};bN.j=function(a){return LH(a)?new $APP.H(null,2,5,$APP.I,[a.xc,a.Be],null):new $APP.H(null,2,5,$APP.I,[a,0],null)};
bN.A=function(a,b){return LH(a)&&$APP.Uc.A(b,MH(a))?new $APP.H(null,2,5,$APP.I,[a.xc,a.Be],null):new $APP.H(null,2,5,$APP.I,[a,0],null)};bN.G=2;var PH=function PH(a){switch(arguments.length){case 1:return PH.j(arguments[0]);case 2:return PH.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};PH.j=function(a){return $APP.x.A(bN.j(a),0)};PH.A=function(a,b){return $APP.x.A(bN.A(a,b),0)};PH.G=2;
var WN=function WN(a){switch(arguments.length){case 1:return WN.j(arguments[0]);case 2:return WN.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};WN.j=function(a){return $APP.x.A(bN.j(a),1)};WN.A=function(a,b){return $APP.x.A(bN.A(a,b),1)};WN.G=2;
var QH=function QH(a){switch(arguments.length){case 1:return QH.j(arguments[0]);case 2:return QH.A(arguments[0],arguments[1]);case 3:return QH.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};QH.j=function(a){return QH.B(a,1,JH())};QH.A=function(a,b){return QH.B(a,1,b)};QH.B=function(a,b,c){return $APP.k(KF.j(b))?a:CWa(c,a,b)};QH.G=3;
var NH=$APP.Ec,Z_=function Z_(a){switch(arguments.length){case 1:return Z_.j(arguments[0]);case 2:return Z_.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return Z_.C(arguments[0],arguments[1],c)}};Z_.j=function(){return!0};Z_.A=function(a,b){return fG.A(bN.j(a),bN.j(b))};Z_.C=function(a,b,c){for(;;)if($APP.k(Z_.A(a,b)))if($APP.w(c))a=b,b=$APP.u(c),c=$APP.w(c);else return Z_.A(b,$APP.u(c));else return!1};
Z_.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};Z_.G=2;var Y_=function Y_(a){switch(arguments.length){case 1:return Y_.j(arguments[0]);case 2:return Y_.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return Y_.C(arguments[0],arguments[1],c)}};Y_.j=function(){return!0};Y_.A=function(a,b){return fG.A(PH.j(a),PH.j(b))};
Y_.C=function(a,b,c){for(;;)if($APP.k(Y_.A(a,b)))if($APP.w(c))a=b,b=$APP.u(c),c=$APP.w(c);else return Y_.A(b,$APP.u(c));else return!1};Y_.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};Y_.G=2;tG.F(null,new $APP.H(null,1,5,$APP.I,[hN],null),function(){return 0});NF.F(null,new $APP.H(null,1,5,$APP.I,[hN],null),function(){return 1});jZ.F(null,new $APP.H(null,1,5,$APP.I,[hN],null),function(){return 1});
aG.F(null,new $APP.H(null,1,5,$APP.I,[hN],null),function(a){return $APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,m4b,null,1,null),new $APP.D(null,MH(a),null,1,null),$APP.y([new $APP.D(null,aG.j(PH.j(a)),null,1,null),new $APP.D(null,aG.j(WN.j(a)),null,1,null)])))))});bG.F(null,new $APP.H(null,1,5,$APP.I,[hN],null),function(a){return new KH(a.tag,bG.j(a.xc),bG.j(a.Be))});var JQ=Error();GWa._=!0;SH._=function(a){a=XH.j($APP.ed(a));return $APP.k(a)?a:new $APP.H(null,2,5,$APP.I,[fI,1],null)};$APP.q.prototype.bc=function(){return new $APP.H(null,2,5,$APP.I,[fI,0],null)};$APP.Ch.prototype.bc=function(){return this.j(XH)};VH.A=function(a,b){return VH.B(a,b,$APP.F)};VH.B=function(a,b,c){b=$APP.rg.B($APP.Ni.C($APP.y([$APP.ed(a),c])),XH,b);return QSa(a,b)};VH.G=3;WH.C=function(a){var b=$APP.$c(a);b=SH($APP.k(b)?b:$APP.Kd);return VH.A($APP.Je.A($APP.Hl,a),b)};WH.G=0;WH.K=function(a){return this.C($APP.r(a))};
ZH.A=function(a,b){return UH(a)?WH.C($APP.y([function(c){return ZH.A(c,b)},a])):$APP.C.A(a,b)};ZH.B=function(a,b,c){return UH(a)?WH.C($APP.y([function(d){return ZH.B(d,b,c)},a])):$APP.C.B(a,b,c)};ZH.G=3;$H.A=function(a,b){return UH(a)?WH.C($APP.y([function(c){return $H.A(c,b)},a])):$APP.Zl.A(a,b)};$H.B=function(a,b,c){return UH(a)?WH.C($APP.y([function(d){return $H.B(d,b,c)},a])):$APP.Zl.B(a,b,c)};$H.G=3;
bI.C=function(a,b){var c=$APP.N.A(b,$APP.Uj.j(0));return VH.A(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return $APP.Je.A(a,$APP.Vg.B(kG,l,c))}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),SH(a))};bI.G=1;bI.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
cI.C=function(a,b){var c=$APP.N.A(b,$APP.Uj.j(1));return VH.A(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return $APP.Je.A(a,$APP.Vg.B(iG,l,c))}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),SH(a))};cI.G=1;cI.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};$APP.Ch.prototype.rb=function(){return TH};AF["function"]=!0;
BF["function"]=function(){return TH};$APP.Ac.prototype.rb=function(){return TH};$APP.dd.prototype.rb=function(){return TH};var ioc=$APP.mh(function(a){var b=LWa(a);return $APP.vd(a.C)?$APP.Uc.A(new $APP.H(null,4,5,$APP.I,[0,1,2,3],null),b)?new $APP.H(null,2,5,$APP.I,[fI,1],null):new $APP.H(null,2,5,$APP.I,[VS,$APP.u(b)],null):$APP.Uc.A(1,$APP.Tc(b))?new $APP.H(null,2,5,$APP.I,[fI,$APP.u(b)],null):new $APP.H(null,3,5,$APP.I,[NX,$APP.u(b),$APP.$c(b)],null)});GWa["function"]=!0;
SH["function"]=function(a){return XH.A($APP.ed(a),ioc(a))};$APP.dd.prototype.bc=function(){return XH.A($APP.ed(this),ioc(this))};dI.J=function(){return new $APP.H(null,2,5,$APP.I,[VS,0],null)};dI.j=function(a){return a};
dI.A=function(a,b){function c(){return $APP.k(!1)?AD(["Incompatible arities: ",$APP.m.j(a)," ",$APP.m.j(b)].join("")):new $APP.H(null,2,5,$APP.I,[VS,0],null)}if(0<$APP.Ed($APP.u(a),$APP.u(b)))return dI.A(b,a);try{if($APP.od(a)&&2===$APP.Tc(a))try{var d=$APP.x.A(a,0);if($APP.$d(d,VS))try{if($APP.od(b)&&2===$APP.Tc(b))try{var g=$APP.x.A(b,0);if($APP.$d(g,VS)){var l=$APP.x.A(b,1),n=$APP.x.A(a,1);return new $APP.H(null,2,5,$APP.I,[VS,function(){var V=n;return V>l?V:l}()],null)}throw JQ;}catch(V){if(V instanceof
Error){var p=V;if(p===JQ)throw JQ;throw p;}throw V;}else throw JQ;}catch(V){if(V instanceof Error)if(p=V,p===JQ)try{if($APP.od(b)&&3===$APP.Tc(b))try{var v=$APP.x.A(b,0);if($APP.$d(v,NX)){var t=$APP.x.A(b,1),A=$APP.x.A(b,2);n=$APP.x.A(a,1);var B=function(){var da=n,Y=t;return da>Y?da:Y}();return $APP.Uc.A(B,A)?new $APP.H(null,2,5,$APP.I,[fI,B],null):B<A?new $APP.H(null,3,5,$APP.I,[NX,B,A],null):c()}throw JQ;}catch(da){if(da instanceof Error){var G=da;if(G===JQ)throw JQ;throw G;}throw da;}else throw JQ;
}catch(da){if(da instanceof Error)if(G=da,G===JQ)try{if($APP.od(b)&&2===$APP.Tc(b))try{var J=$APP.x.A(b,0);if($APP.$d(J,fI)){var O=$APP.x.A(b,1);n=$APP.x.A(a,1);return O>=n?new $APP.H(null,2,5,$APP.I,[fI,O],null):c()}throw JQ;}catch(Y){if(Y instanceof Error){var Q=Y;if(Q===JQ)throw JQ;throw Q;}throw Y;}else throw JQ;}catch(Y){if(Y instanceof Error){Q=Y;if(Q===JQ)throw JQ;throw Q;}throw Y;}else throw G;else throw da;}else throw p;else throw V;}else throw JQ;}catch(V){if(V instanceof Error){p=V;if(p===
JQ)throw JQ;throw p;}throw V;}else throw JQ;}catch(V){if(V instanceof Error)if(p=V,p===JQ)try{if($APP.od(a)&&3===$APP.Tc(a))try{var W=$APP.x.A(a,0);if($APP.$d(W,NX))try{if($APP.od(b)&&3===$APP.Tc(b))try{var Z=$APP.x.A(b,0);if($APP.$d(Z,NX)){var fa=$APP.x.A(b,1),ha=$APP.x.A(b,2);t=$APP.x.A(a,1);A=$APP.x.A(a,2);B=function(){var da=t;return da>fa?da:fa}();var ja=function(){var da=A;return da<ha?da:ha}();return $APP.Uc.A(B,ja)?new $APP.H(null,2,5,$APP.I,[fI,B],null):B<ja?new $APP.H(null,3,5,$APP.I,[NX,
B,ja],null):c()}throw JQ;}catch(da){if(da instanceof Error){G=da;if(G===JQ)throw JQ;throw G;}throw da;}else throw JQ;}catch(da){if(da instanceof Error)if(G=da,G===JQ)try{if($APP.od(b)&&2===$APP.Tc(b))try{var ta=$APP.x.A(b,0);if($APP.$d(ta,fI))return n=$APP.x.A(b,1),t=$APP.x.A(a,1),A=$APP.x.A(a,2),t<=n&&n<=A?new $APP.H(null,2,5,$APP.I,[fI,n],null):c();throw JQ;}catch(Y){if(Y instanceof Error){Q=Y;if(Q===JQ)throw JQ;throw Q;}throw Y;}else throw JQ;}catch(Y){if(Y instanceof Error){Q=Y;if(Q===JQ)throw JQ;
throw Q;}throw Y;}else throw G;else throw da;}else throw JQ;}catch(da){if(da instanceof Error){G=da;if(G===JQ)throw JQ;throw G;}throw da;}else throw JQ;}catch(da){if(da instanceof Error)if(G=da,G===JQ)try{if($APP.od(a)&&2===$APP.Tc(a))try{var ua=$APP.x.A(a,0);if($APP.$d(ua,fI))try{if($APP.od(b)&&2===$APP.Tc(b))try{var ca=$APP.x.A(b,0);if($APP.$d(ca,fI))return O=$APP.x.A(b,1),n=$APP.x.A(a,1),$APP.Uc.A(n,O)?new $APP.H(null,2,5,$APP.I,[fI,n],null):c();throw JQ;}catch(Y){if(Y instanceof Error){Q=Y;if(Q===
JQ)throw JQ;throw Q;}throw Y;}else throw JQ;}catch(Y){if(Y instanceof Error){Q=Y;if(Q===JQ)throw JQ;throw Q;}throw Y;}else throw JQ;}catch(Y){if(Y instanceof Error){Q=Y;if(Q===JQ)throw JQ;throw Q;}throw Y;}else throw JQ;}catch(Y){if(Y instanceof Error){Q=Y;if(Q===JQ)throw Error(["No matching clause: ",$APP.m.j(a)," ",$APP.m.j(b)].join(""));throw Q;}throw Y;}else throw G;else throw da;}else throw p;else throw V;}};dI.G=2;$APP.hu.A(FF,jI);hI(eH,kG);hI(yG,RF);hI(MF,iG);gI(OF);hI(zG,QF);iI(rI);gI(jG);
gI(PF);gI(qG);gI(hG);gI(pZ);gI(rZ);gI(qZ);gI(sZ);iI(qI);iI(AG);iI(lI);gI(gO);gI(fO);gI(tZ);gI(xZ);gI(kO);gI(rG);iI(rG);gI(vH);gI(tH);gI(BZ);gI(lG);gI(oZ);gI(oG);gI(pG);eR.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(a){return function(b){return function(c){c=a.j?a.j(c):a.call(null,c);return b.j?b.j(c):b.call(null,c)}}});gI(ZQ);gI(QZ);iI(wM);iI(oM);iI(iM);iI(VF);iI(cR);gI(LO);iI(BH);iI(RZ);iI(SZ);iI(TZ);iI(NZ);iI(OZ);gI(xH);gI(AH);gI(xG);gI(PZ);gI(qL);
KF.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(){return!1});sG.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(){return!1});iZ.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(){return!1});tG.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(a){return IWa(a)});NF.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(a){return KWa(a)});jZ.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(a){return VH.B($APP.Kd,SH(a),new $APP.f(null,1,[aI,APb],null))});
TF.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(a){return WH.C($APP.y([TF,a]))});aG.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(a){var b=$APP.C,c=b.B,d=$APP.Fb(SSa);if(a instanceof $APP.Ch){var g=$APP.Dh(a,new $APP.H(null,1,5,$APP.I,[$APP.E],null));g=$APP.k(g)?g.j?g.j($APP.R):g.call(null,$APP.R):a}else g=a instanceof $APP.dd?$APP.R.A(a.meta,a):a instanceof $APP.Ac?aG.j($APP.Fb(a)):a;return c.call(b,d,a,g)});$APP.Ch.prototype.ac=function(a,b,c){return QWa(this,b,c)};
$APP.Ch.prototype.$b=function(a,b,c){return PWa(this,b,c)};$APP.Ch.prototype.ic=function(a,b){return $APP.Hl.A(function(c){return HH(c,b)},this)};zWa["function"]=!0;FH["function"]=function(a,b,c){return QWa(a,b,c)};GH["function"]=function(a,b,c){return PWa(a,b,c)};HH["function"]=function(a,b){return $APP.Hl.A(function(c){return HH(c,b)},a)};$APP.dd.prototype.ac=function(a,b,c){return QWa(this.afn,b,c)};$APP.dd.prototype.$b=function(a,b,c){return PWa(this.afn,b,c)};
$APP.dd.prototype.ic=function(a,b){return $APP.Hl.A(function(c){return HH(c,b)},this.afn)};bG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.H],null),function(a){return $APP.Fl.A(bG,a)});tG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.H],null),function(a){return $APP.Fl.A(tG,a)});TF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.H],null),function(a){return $APP.Ge(TF,a)});aG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.H],null),function(a){return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,xP,null,1,null),$APP.Vg.A(aG,a))))});$APP.e=$APP.H.prototype;$APP.e.rb=function(){return $APP.hb(this)};
$APP.e.bc=function(){return new $APP.H(null,3,5,$APP.I,[NX,1,2],null)};$APP.e.ac=function(a,b,c){return $APP.Fl.A(function(d){return FH(d,b,c)},this)};$APP.e.$b=function(a,b,c){return $APP.Fl.A(function(d){return GH(d,b,c)},this)};$APP.e.ic=function(a,b){return $APP.Fl.A(function(c){return HH(c,b)},this)};bG.F(null,new $APP.H(null,1,5,$APP.I,[YR],null),function(a){return $APP.Vg.A(bG,a)});
for(var $_=$APP.r(new $APP.H(null,6,5,$APP.I,[$APP.Xd,$APP.Bc,$APP.de,$APP.D,$APP.Gg,$APP.Fg],null)),a0=null,b0=0,c0=0;;)if(c0<b0){var d0=a0.aa(null,c0);KF.F(null,new $APP.H(null,1,5,$APP.I,[d0],null),function(){return function(){return!1}}($_,a0,b0,c0,d0));sG.F(null,new $APP.H(null,1,5,$APP.I,[d0],null),function(){return function(){return!1}}($_,a0,b0,c0,d0));iZ.F(null,new $APP.H(null,1,5,$APP.I,[d0],null),function(){return function(){return!1}}($_,a0,b0,c0,d0));tG.F(null,new $APP.H(null,1,5,$APP.I,
[d0],null),function(){return function(a){return $APP.Vg.A(tG,a)}}($_,a0,b0,c0,d0));TF.F(null,new $APP.H(null,1,5,$APP.I,[d0],null),function(){return function(a){return $APP.Ge(TF,a)}}($_,a0,b0,c0,d0));aG.F(null,new $APP.H(null,1,5,$APP.I,[d0],null),function(){return function(a){return $APP.Vg.A(aG,a)}}($_,a0,b0,c0,d0));d0.prototype.rb=function(){return function(){return $APP.hb(this)}}($_,a0,b0,c0,d0);d0.prototype.ac=function(a,b,c,d,g){return function(l,n,p){return $APP.Vg.A(function(){return function(v){return FH(v,
n,p)}}(a,b,c,d,this,g),this)}}($_,a0,b0,c0,d0);d0.prototype.$b=function(a,b,c,d,g){return function(l,n,p){return $APP.Vg.A(function(){return function(v){return GH(v,n,p)}}(a,b,c,d,this,g),this)}}($_,a0,b0,c0,d0);d0.prototype.ic=function(a,b,c,d,g){return function(l,n){return $APP.Vg.A(function(){return function(p){return HH(p,n)}}(a,b,c,d,this,g),this)}}($_,a0,b0,c0,d0);c0+=1}else{var e0=$APP.r($_);if(e0){var f0=e0;if($APP.pd(f0)){var joc=$APP.lc(f0),koc=$APP.mc(f0),loc=joc,moc=$APP.Tc(joc);$_=koc;
a0=loc;b0=moc}else{var g0=$APP.u(f0);KF.F(null,new $APP.H(null,1,5,$APP.I,[g0],null),function(){return function(){return!1}}($_,a0,b0,c0,g0,f0,e0));sG.F(null,new $APP.H(null,1,5,$APP.I,[g0],null),function(){return function(){return!1}}($_,a0,b0,c0,g0,f0,e0));iZ.F(null,new $APP.H(null,1,5,$APP.I,[g0],null),function(){return function(){return!1}}($_,a0,b0,c0,g0,f0,e0));tG.F(null,new $APP.H(null,1,5,$APP.I,[g0],null),function(){return function(a){return $APP.Vg.A(tG,a)}}($_,a0,b0,c0,g0,f0,e0));TF.F(null,
new $APP.H(null,1,5,$APP.I,[g0],null),function(){return function(a){return $APP.Ge(TF,a)}}($_,a0,b0,c0,g0,f0,e0));aG.F(null,new $APP.H(null,1,5,$APP.I,[g0],null),function(){return function(a){return $APP.Vg.A(aG,a)}}($_,a0,b0,c0,g0,f0,e0));g0.prototype.rb=function(){return function(){return $APP.hb(this)}}($_,a0,b0,c0,g0,f0,e0);g0.prototype.ac=function(a,b,c,d,g,l,n){return function(p,v,t){return $APP.Vg.A(function(){return function(A){return FH(A,v,t)}}(a,b,c,d,this,g,l,n),this)}}($_,a0,b0,c0,g0,
f0,e0);g0.prototype.$b=function(a,b,c,d,g,l,n){return function(p,v,t){return $APP.Vg.A(function(){return function(A){return GH(A,v,t)}}(a,b,c,d,this,g,l,n),this)}}($_,a0,b0,c0,g0,f0,e0);g0.prototype.ic=function(a,b,c,d,g,l,n){return function(p,v){return $APP.Vg.A(function(){return function(t){return HH(t,v)}}(a,b,c,d,this,g,l,n),this)}}($_,a0,b0,c0,g0,f0,e0);$_=$APP.w(f0);a0=null;b0=0}c0=0}else break}$APP.hu.A($APP.eg,TT);$APP.hu.A($APP.f,TT);$APP.hu.A($APP.kg,TT);
PF.F(null,new $APP.H(null,1,5,$APP.I,[TT],null),function(a){return uD(PF,a)});eH.F(null,new $APP.H(null,2,5,$APP.I,[TT,TT],null),function(a,b){return $APP.Oo.C(eH,$APP.y([a,b]))});yG.F(null,new $APP.H(null,2,5,$APP.I,[TT,TT],null),function(a,b){return $APP.Oo.C(eH,$APP.y([a,uD(PF,b)]))});MF.F(null,new $APP.H(null,2,5,$APP.I,[TT,FF],null),function(a,b){return uD(function(c){return MF.A(c,b)},a)});
MF.F(null,new $APP.H(null,2,5,$APP.I,[FF,TT],null),function(a,b){return uD(function(c){return MF.A(a,c)},b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[TT,FF],null),function(a,b){return uD(function(c){return zG.A(c,b)},a)});NZ.F(null,new $APP.H(null,2,5,$APP.I,[TT,TT],null),function(a,b){return RWa(NZ,a,b)});OZ.F(null,new $APP.H(null,2,5,$APP.I,[TT,TT],null),function(a,b){return RWa(OZ,a,b)});xH.F(null,new $APP.H(null,1,5,$APP.I,[TT],null),function(a){return uD(xH,a)});
AH.F(null,new $APP.H(null,1,5,$APP.I,[TT],null),function(a){return uD(AH,a)});bG.F(null,new $APP.H(null,1,5,$APP.I,[TT],null),function(a){return uD(bG,a)});var noc=new $APP.Ef;fG.F(null,new $APP.H(null,2,5,$APP.I,[TT,TT],null),function(a,b){return $APP.vd($APP.Tc(a)===$APP.Tc(b)?$APP.Jd(function(c,d,g){return $APP.k(fG.A($APP.C.B(b,d,noc),g))?!0:$APP.Mc(!1)},!0,a):null)});mR.F(null,new $APP.H(null,2,5,$APP.I,[TT,YR],null),function(a,b){return uD(function(c){return mR.A(c,b)},a)});
for(var h0=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.eg,$APP.f,$APP.kg],null)),i0=null,j0=0,k0=0;;)if(k0<j0){var l0=i0.aa(null,k0);KF.F(null,new $APP.H(null,1,5,$APP.I,[l0],null),function(){return function(a){return $APP.Ge(KF,$APP.pg(a))}}(h0,i0,j0,k0,l0));sG.F(null,new $APP.H(null,1,5,$APP.I,[l0],null),function(){return function(){return!1}}(h0,i0,j0,k0,l0));iZ.F(null,new $APP.H(null,1,5,$APP.I,[l0],null),function(){return function(){return!1}}(h0,i0,j0,k0,l0));tG.F(null,new $APP.H(null,1,5,$APP.I,
[l0],null),function(){return function(a){return uD(tG,a)}}(h0,i0,j0,k0,l0));TF.F(null,new $APP.H(null,1,5,$APP.I,[l0],null),function(){return function(a){return $APP.Ge(TF,$APP.pg(a))}}(h0,i0,j0,k0,l0));aG.F(null,new $APP.H(null,1,5,$APP.I,[l0],null),function(){return function(a){return uD(aG,a)}}(h0,i0,j0,k0,l0));$APP.e=l0.prototype;$APP.e.rb=function(){return function(){return $APP.ld(this)?$APP.hb(this):$APP.Ti.A(this,$APP.hb(this))}}(h0,i0,j0,k0,l0);$APP.e.bc=function(){return function(){return new $APP.H(null,
3,5,$APP.I,[NX,1,2],null)}}(h0,i0,j0,k0,l0);$APP.e.ac=function(a,b,c,d,g){return function(l,n,p){return uD(function(){return function(v){return FH(v,n,p)}}(a,b,c,d,this,g),this)}}(h0,i0,j0,k0,l0);$APP.e.$b=function(a,b,c,d,g){return function(l,n,p){l=$APP.Ti.j(this);return $APP.k(l)?yD(["`extract-tangent` not supported for type ",$APP.m.j(l),"."].join("")):uD(function(){return function(v){return GH(v,n,p)}}(a,b,c,d,l,this,g),this)}}(h0,i0,j0,k0,l0);$APP.e.ic=function(a,b,c,d,g){return function(l,
n){l=$APP.Ti.j(this);return $APP.k(l)?yD(["`extract-id` not supported for type ",$APP.m.j(l),"."].join("")):uD(function(){return function(p){return HH(p,n)}}(a,b,c,d,l,this,g),this)}}(h0,i0,j0,k0,l0);k0+=1}else{var m0=$APP.r(h0);if(m0){var n0=m0;if($APP.pd(n0)){var ooc=$APP.lc(n0),poc=$APP.mc(n0),qoc=ooc,roc=$APP.Tc(ooc);h0=poc;i0=qoc;j0=roc}else{var o0=$APP.u(n0);KF.F(null,new $APP.H(null,1,5,$APP.I,[o0],null),function(){return function(a){return $APP.Ge(KF,$APP.pg(a))}}(h0,i0,j0,k0,o0,n0,m0));sG.F(null,
new $APP.H(null,1,5,$APP.I,[o0],null),function(){return function(){return!1}}(h0,i0,j0,k0,o0,n0,m0));iZ.F(null,new $APP.H(null,1,5,$APP.I,[o0],null),function(){return function(){return!1}}(h0,i0,j0,k0,o0,n0,m0));tG.F(null,new $APP.H(null,1,5,$APP.I,[o0],null),function(){return function(a){return uD(tG,a)}}(h0,i0,j0,k0,o0,n0,m0));TF.F(null,new $APP.H(null,1,5,$APP.I,[o0],null),function(){return function(a){return $APP.Ge(TF,$APP.pg(a))}}(h0,i0,j0,k0,o0,n0,m0));aG.F(null,new $APP.H(null,1,5,$APP.I,
[o0],null),function(){return function(a){return uD(aG,a)}}(h0,i0,j0,k0,o0,n0,m0));$APP.e=o0.prototype;$APP.e.rb=function(){return function(){return $APP.ld(this)?$APP.hb(this):$APP.Ti.A(this,$APP.hb(this))}}(h0,i0,j0,k0,o0,n0,m0);$APP.e.bc=function(){return function(){return new $APP.H(null,3,5,$APP.I,[NX,1,2],null)}}(h0,i0,j0,k0,o0,n0,m0);$APP.e.ac=function(a,b,c,d,g,l,n){return function(p,v,t){return uD(function(){return function(A){return FH(A,v,t)}}(a,b,c,d,this,g,l,n),this)}}(h0,i0,j0,k0,o0,
n0,m0);$APP.e.$b=function(a,b,c,d,g,l,n){return function(p,v,t){p=$APP.Ti.j(this);return $APP.k(p)?yD(["`extract-tangent` not supported for type ",$APP.m.j(p),"."].join("")):uD(function(){return function(A){return GH(A,v,t)}}(a,b,c,d,p,this,g,l,n),this)}}(h0,i0,j0,k0,o0,n0,m0);$APP.e.ic=function(a,b,c,d,g,l,n){return function(p,v){p=$APP.Ti.j(this);return $APP.k(p)?yD(["`extract-id` not supported for type ",$APP.m.j(p),"."].join("")):uD(function(){return function(t){return HH(t,v)}}(a,b,c,d,p,this,
g,l,n),this)}}(h0,i0,j0,k0,o0,n0,m0);h0=$APP.w(n0);i0=null;j0=0}k0=0}else break}$APP.hu.A($APP.ug,mQb);$APP.hu.A($APP.xg,mQb);eH.F(null,new $APP.H(null,2,5,$APP.I,[mQb,mQb],null),function(a,b){return $APP.jz.A(a,b)});
for(var p0=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.ug,$APP.xg],null)),q0=null,r0=0,s0=0;;)if(s0<r0){var t0=q0.aa(null,s0);KF.F(null,new $APP.H(null,1,5,$APP.I,[t0],null),function(){return function(a){return $APP.hd(a)}}(p0,q0,r0,s0,t0));sG.F(null,new $APP.H(null,1,5,$APP.I,[t0],null),function(){return function(){return!1}}(p0,q0,r0,s0,t0));iZ.F(null,new $APP.H(null,1,5,$APP.I,[t0],null),function(){return function(){return!1}}(p0,q0,r0,s0,t0));tG.F(null,new $APP.H(null,1,5,$APP.I,[t0],null),function(){return function(){return $APP.vg}}(p0,
q0,r0,s0,t0));TF.F(null,new $APP.H(null,1,5,$APP.I,[t0],null),function(){return function(a){return $APP.Ge(TF,a)}}(p0,q0,r0,s0,t0));t0.prototype.rb=function(){return function(){return $APP.hb(this)}}(p0,q0,r0,s0,t0);t0.prototype.bc=function(){return function(){return new $APP.H(null,3,5,$APP.I,[NX,1,2],null)}}(p0,q0,r0,s0,t0);s0+=1}else{var u0=$APP.r(p0);if(u0){var v0=u0;if($APP.pd(v0)){var soc=$APP.lc(v0),toc=$APP.mc(v0),uoc=soc,voc=$APP.Tc(soc);p0=toc;q0=uoc;r0=voc}else{var w0=$APP.u(v0);KF.F(null,
new $APP.H(null,1,5,$APP.I,[w0],null),function(){return function(a){return $APP.hd(a)}}(p0,q0,r0,s0,w0,v0,u0));sG.F(null,new $APP.H(null,1,5,$APP.I,[w0],null),function(){return function(){return!1}}(p0,q0,r0,s0,w0,v0,u0));iZ.F(null,new $APP.H(null,1,5,$APP.I,[w0],null),function(){return function(){return!1}}(p0,q0,r0,s0,w0,v0,u0));tG.F(null,new $APP.H(null,1,5,$APP.I,[w0],null),function(){return function(){return $APP.vg}}(p0,q0,r0,s0,w0,v0,u0));TF.F(null,new $APP.H(null,1,5,$APP.I,[w0],null),function(){return function(a){return $APP.Ge(TF,
a)}}(p0,q0,r0,s0,w0,v0,u0));w0.prototype.rb=function(){return function(){return $APP.hb(this)}}(p0,q0,r0,s0,w0,v0,u0);w0.prototype.bc=function(){return function(){return new $APP.H(null,3,5,$APP.I,[NX,1,2],null)}}(p0,q0,r0,s0,w0,v0,u0);p0=$APP.w(v0);q0=null;r0=0}s0=0}else break};kI.prototype.rb=function(){return jT};kI.prototype.Y=function(a,b){return mI.A?mI.A(this,b):mI.call(null,this,b)};kI.prototype.toString=function(){return["[",$APP.m.j(this.i)," mod ",$APP.m.j(this.ca),"]"].join("")};kI.prototype.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.modint.ModInt "',this.toString(),'"]']))};var x0=function x0(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return x0.C(c)};
x0.C=function(a){var b=$APP.Vs.B($APP.Vg.j(UWa),iG,a),c=$APP.Vg.j(function(d){var g=d.i;d=d.ca;var l=qI.A(b,d);return iG.C(g,l,$APP.y([VWa(l,d).i]))});return lI.A($APP.Vs.B(c,kG,a),b)};x0.G=0;x0.K=function(a){return this.C($APP.r(a))};var woc=oI(eH),xoc=oI(yG),y0=oI(MF),yoc=oI(AG),zoc=oI(lI);fG.F(null,new $APP.H(null,2,5,$APP.I,[TM,jT],null),function(a,b){return mI(b,a)});fG.F(null,new $APP.H(null,2,5,$APP.I,[jT,TM],null),function(a,b){return mI(a,b)});
KF.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return KF.j(a.i)});sG.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return sG.j(a.i)});iZ.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return sG.j(a.i)});tG.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return new kI(tG.j(a.i),a.ca)});NF.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return new kI(NF.j(a.i),a.ca)});
jZ.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return new kI(NF.j(a.i),a.ca)});aG.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return new $APP.D(null,oUb,new $APP.D(null,a.i,new $APP.D(null,a.ca,null,1,null),2,null),3,null)});TF.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(){return!0});qZ.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return a.i});sZ.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(){return 0});
pZ.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return a});rZ.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return a});eH.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return woc(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return y0(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return y0(a,pI(b))});yG.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return xoc(a,b)});
PF.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return nI(PF.j(a.i),a.ca)});OF.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return pI(a)});xG.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return lI.A(a.i,a.ca)});hG.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){var b=a.i;return $APP.k(qG.j(b))?nI(b,a.ca):a});qI.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return y0(a,pI(b))});
AG.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return yoc(a,b)});lI.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return zoc(a,b)});iM.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return y0(a,pI(b))});qG.F(null,new $APP.H(null,1,5,$APP.I,[jT],null),function(a){return qG.j(a.i)});rI.F(null,new $APP.H(null,2,5,$APP.I,[EG,jT],null),function(a,b){return WWa(a,b.i,b.ca)});
rI.F(null,new $APP.H(null,2,5,$APP.I,[jT,EG],null),function(a,b){return WWa(a.i,b,a.ca)});VF.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return y0(b,pI(a))});cR.F(null,new $APP.H(null,2,5,$APP.I,[jT,jT],null),function(a,b){return y0(a,pI(b))});
for(var z0=$APP.r(new $APP.H(null,3,5,$APP.I,[eH,MF,yG],null)),A0=null,B0=0,C0=0;;)if(C0<B0){var Aoc=A0.aa(null,C0);Aoc.F(null,new $APP.H(null,2,5,$APP.I,[EG,jT],null),function(a,b,c,d,g){return function(l,n){var p=n.i;l=g.A?g.A(l,p):g.call(null,l,p);return nI(l,n.ca)}}(z0,A0,B0,C0,Aoc));Aoc.F(null,new $APP.H(null,2,5,$APP.I,[jT,EG],null),function(a,b,c,d,g){return function(l,n){var p=l.i;n=g.A?g.A(p,n):g.call(null,p,n);return nI(n,l.ca)}}(z0,A0,B0,C0,Aoc));C0+=1}else{var Boc=$APP.r(z0);if(Boc){var D0=
Boc;if($APP.pd(D0)){var Coc=$APP.lc(D0),Doc=$APP.mc(D0),Eoc=Coc,Foc=$APP.Tc(Coc);z0=Doc;A0=Eoc;B0=Foc}else{var Goc=$APP.u(D0);Goc.F(null,new $APP.H(null,2,5,$APP.I,[EG,jT],null),function(a,b,c,d,g){return function(l,n){var p=n.i;l=g.A?g.A(l,p):g.call(null,l,p);return nI(l,n.ca)}}(z0,A0,B0,C0,Goc,D0,Boc));Goc.F(null,new $APP.H(null,2,5,$APP.I,[jT,EG],null),function(a,b,c,d,g){return function(l,n){var p=l.i;n=g.A?g.A(p,n):g.call(null,p,n);return nI(n,l.ca)}}(z0,A0,B0,C0,Goc,D0,Boc));z0=$APP.w(D0);A0=
null;B0=0}C0=0}else break}
for(var E0=$APP.r(new $APP.H(null,6,5,$APP.I,[zG,VF,cR,qI,AG,iM],null)),F0=null,G0=0,H0=0;;)if(H0<G0){var Hoc=F0.aa(null,H0);Hoc.F(null,new $APP.H(null,2,5,$APP.I,[EG,jT],null),function(a,b,c,d,g){return function(l,n){l=nI(l,n.ca);return g.A?g.A(l,n):g.call(null,l,n)}}(E0,F0,G0,H0,Hoc));Hoc.F(null,new $APP.H(null,2,5,$APP.I,[jT,EG],null),function(a,b,c,d,g){return function(l,n){n=nI(n,l.ca);return g.A?g.A(l,n):g.call(null,l,n)}}(E0,F0,G0,H0,Hoc));H0+=1}else{var Ioc=$APP.r(E0);if(Ioc){var I0=Ioc;if($APP.pd(I0)){var Joc=
$APP.lc(I0),Koc=$APP.mc(I0),Loc=Joc,Moc=$APP.Tc(Joc);E0=Koc;F0=Loc;G0=Moc}else{var Noc=$APP.u(I0);Noc.F(null,new $APP.H(null,2,5,$APP.I,[EG,jT],null),function(a,b,c,d,g){return function(l,n){l=nI(l,n.ca);return g.A?g.A(l,n):g.call(null,l,n)}}(E0,F0,G0,H0,Noc,I0,Ioc));Noc.F(null,new $APP.H(null,2,5,$APP.I,[jT,EG],null),function(a,b,c,d,g){return function(l,n){n=nI(n,l.ca);return g.A?g.A(l,n):g.call(null,l,n)}}(E0,F0,G0,H0,Noc,I0,Ioc));E0=$APP.w(I0);F0=null;G0=0}H0=0}else break};var Ooc={},V0,Poc,yI=new $APP.Ac(function(){return $APP.Jt},ylb,$APP.fg([$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.hy,$APP.zj,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[$APP.yn,$APP.Uya,"cljs/core.cljs",17,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(Npb)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Npb],null)),$APP.zx,$APP.M(null)],null),1,9057,9057,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Npb],null)),"keyval \x3d\x3e key val\n  Returns a new sorted map with supplied mappings.",
$APP.k($APP.Jt)?$APP.Jt.Z:null])),sI=yI.J?yI.J():yI.call(null),lM=function lM(a){switch(arguments.length){case 1:return lM.j(arguments[0]);case 2:return lM.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};lM.j=function(a){return a};lM.A=function(a,b){var c=$APP.sg(a,$APP.ng(b));a=$APP.sg(b,$APP.ng(a));return $APP.Oo.C($APP.bt,$APP.y([c,a]))};lM.G=2;
var gM=function gM(a){switch(arguments.length){case 0:return gM.J();case 1:return gM.j(arguments[0]);case 2:return gM.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};gM.J=function(){return sI};gM.j=function(a){return a};gM.A=function(a,b){return $APP.Oo.C($APP.Gj,$APP.y([a,b]))};gM.G=2;var xI=function xI(a){switch(arguments.length){case 1:return xI.j(arguments[0]);case 2:return xI.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};xI.j=function(a){return new $APP.H(null,2,5,$APP.I,[sI,a],null)};xI.A=function(a,b){return new $APP.H(null,2,5,$APP.I,[a,b],null)};xI.G=2;
var jXa=bUa(new $APP.Ac(function(){return dXa},i3b,$APP.fg([$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.zj,$APP.gm,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[$APP.z(u7b,new $APP.f(null,1,[$APP.zza,!0],null)),olb,"emmy/polynomial/impl.cljc",32,1,!0,77,77,$APP.Ec,"This variable defines monomial order used in the construction and arithmetic of\n  polynomials. Bind this variable to a comparator on the exponents of each\n  monomial term.\n\n  Defaults to [[exponent/graded-lex-order]].",$APP.k(dXa)?dXa.Z:null])),
eH,KF,xI);var W0=function W0(a){switch(arguments.length){case 2:return W0.A(arguments[0],arguments[1]);case 3:return W0.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};W0.A=function(a,b){return $APP.Vg.A($APP.fd,zI(AI(pXa,sXa(b),a)))};W0.B=function(a,b,c){return $APP.Vg.A($APP.fd,$APP.x.A(AI(pXa,sXa(b),a),c))};W0.G=3;var X0,Qoc=$APP.kh.j($APP.F),Roc=$APP.kh.j($APP.F),Soc=$APP.kh.j($APP.F),Toc=$APP.kh.j($APP.F),Uoc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));X0=new $APP.Ch($APP.Zg.A("emmy.special.factorial","falling-factorial"),JP,$APP.xj,Uoc,Qoc,Roc,Soc,Toc);X0.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,BWb],null);return b.j?b.j(a):b.call(null,a)});
X0.F(null,$APP.xj,function(a,b){if(0===b)return 1;if(0>b){var c=function(){var d=eH.A(a,1),g=RF.j(b);return Y0.A?Y0.A(d,g):Y0.call(null,d,g)}();return $APP.k(KF.j(c))?Infinity:OF.j(c)}return $APP.Vs.B($APP.Hl.A($APP.Vg.j(function(d){return eH.A(a,RF.j(d))}),$APP.Vg.j(AXa)),iG,$APP.Hj.j(b))});
X0.F(null,new $APP.H(null,2,5,$APP.I,[GY,GY],null),function(a,b){if(0===b)return 1;if(0>b)return a+=1,b=-b,b=Y0.A?Y0.A(a,b):Y0.call(null,a,b),$APP.k(KF.j(b))?Infinity:QF.A(1,b);b=$APP.Hj.B(a,a-b,-1);return $APP.Vs.B($APP.Vg.j(wD),iG,b)});var Y0,Voc=$APP.kh.j($APP.F),Woc=$APP.kh.j($APP.F),Xoc=$APP.kh.j($APP.F),Yoc=$APP.kh.j($APP.F),Zoc=$APP.C.B($APP.F,$APP.xm,$APP.th.J?$APP.th.J():$APP.th.call(null));Y0=new $APP.Ch($APP.Zg.A("emmy.special.factorial","rising-factorial"),JP,$APP.xj,Zoc,Voc,Woc,Xoc,Yoc);
Y0.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[XH,new $APP.H(null,2,5,$APP.I,[fI,2],null),$APP.R,Rlb],null);return b.j?b.j(a):b.call(null,a)});Y0.F(null,$APP.xj,function(a,b){return 0===b?1:0>b?(b=X0.A(yG.A(a,1),RF.j(b)),$APP.k(KF.j(b))?Infinity:OF.j(b)):$APP.Vs.B($APP.Hl.A($APP.Vg.j(function(c){return eH.A(a,c)}),$APP.Vg.j(AXa)),iG,$APP.Hj.j(b))});
Y0.F(null,new $APP.H(null,2,5,$APP.I,[GY,GY],null),function(a,b){if(0===b)return 1;if(0>b)return a=X0.A(a-1,-b),$APP.k(KF.j(a))?Infinity:QF.A(1,a);a=$APP.Hj.A(a,a+b);return $APP.Vs.B($APP.Vg.j(wD),iG,a)});
var Z0=function Z0(a,b){if(0===b)return 1;if(0>a){if(0<b){var d=$APP.Ie(b)?1:-1,g=function(){var n=-a+b+-1;return Z0.A?Z0.A(n,b):Z0.call(null,n,b)}();return iG.A?iG.A(d,g):iG.call(null,d,g)}if(b<=a){var l=a-b;d=$APP.Ie(l)?1:-1;g=function(){var n=-b-1;return Z0.A?Z0.A(n,l):Z0.call(null,n,l)}();return iG.A?iG.A(d,g):iG.call(null,d,g)}return 0}if(0>b||b>a)return 0;g=function(){var n=a-b;return b<n?b:n}();d=X0.A(a,g);g=FI(g);return QF.A?QF.A(d,g):QF.call(null,d,g)},$0=function $0(a){for(var c=[],d=arguments.length,
g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return $0.C(arguments[0],arguments[1],c)};
$0.C=function(a,b,c){c=$APP.qe(c);var d=$APP.C.A(c,N8b),g=$APP.kh.j(null);$APP.Ne(g,$APP.mh(function(l,n){if(0===l)return 0===n?1:0;var p=l-1,v=$APP.k(d)?p:-p;if(0===v){l=n-1;var t=$APP.Fb(g);return t.A?t.A(p,l):t.call(null,p,l)}l=function(){var A=n-1,B=$APP.Fb(g);return B.A?B.A(p,A):B.call(null,p,A)}();t=function(){var A=$APP.Fb(g);A=A.A?A.A(p,n):A.call(null,p,n);A=BigInt(A);return iG.A?iG.A(v,A):iG.call(null,v,A)}();return kG.A?kG.A(l,t):kG.call(null,l,t)}));if(0===b)return 0===a?1:0;if(b>a)return 0;
c=$APP.Fb(g);return c.A?c.A(a,b):c.call(null,a,b)};$0.G=2;$0.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var JI=function JI(a,b){var d=function n(l){return new $APP.de(null,function(){if($APP.k(KF.j($APP.u(l))))return $APP.Yd($APP.u(l),n($APP.Fc(l)));var p=MF.A($APP.u(l),$APP.u(b)),v=II($APP.u(l),$APP.Fc(b)),t=n($APP.Fc(l));return $APP.Yd(p,EXa(v,t))},null,null)};return new $APP.de(null,function(){if($APP.k(KF.j($APP.u(b)))){var l=$APP.u(b);var n=$APP.Fc(b);n=JI.A?JI.A(a,n):JI.call(null,a,n);l=$APP.Yd(l,n)}else l=d(a);return l},null,null)},a1=function a1(a,b){return new $APP.de(null,function(){var d=
$APP.u(a),g=$APP.Fc(a),l=$APP.u(b),n=$APP.Fc(b);if($APP.k(function(){var v=KF.j(d);return $APP.k(v)?KF.j(l):v}()))return a1.A?a1.A(g,n):a1.call(null,g,n);if($APP.k(KF.j(d)))return $APP.Yd(d,a1.A?a1.A(g,b):a1.call(null,g,b));if($APP.k(KF.j(l)))return CD("ERROR: denominator has a zero constant term");var p=zG.A(d,l);return $APP.Yd(p,function(){var v=HXa(g,II(p,n));return a1.A?a1.A(v,b):a1.call(null,v,b)}())},null,null)},LI=function LI(a){return new $APP.de(null,function(){var c=OF.j($APP.u(a)),d=JI($APP.Fc(a),
LI.j?LI.j(a):LI.call(null,a));d=II(c,$APP.Vg.A(PF,d));return $APP.Yd(c,d)},null,null)},b1=function b1(a){var c=$APP.r(a),d=$APP.u(c);c=$APP.w(c);c=$APP.r(c);var g=$APP.u(c);c=$APP.w(c);if($APP.k(function(){var n=KF.j(d);return $APP.k(n)?KF.j(g):n}()))return $APP.Yd(d,b1.j?b1.j(c):b1.call(null,c));var l=jG.j(d);return function v(p){return new $APP.de(null,function(){return MI(a1($APP.Vg.B(iG,$APP.Fc(p),$APP.af($APP.Lc,1)),II(2,v(p))),l)},null,null)}(a)};
$APP.N.A(new $APP.H(null,2,5,$APP.I,[0,0],null),$APP.af($APP.Lc,9));
var $oc=new $APP.de(null,function(){return MI($oc,1)},null,null),d1=new $APP.de(null,function(){return MI(c1,0)},null,null),c1=new $APP.de(null,function(){return HI(1,MI(d1,0))},null,null),apc=a1(d1,c1),bpc=LI(c1),cpc=LXa(d1),dpc=MI($APP.Ve(new $APP.H(null,4,5,$APP.I,[1,0,-1,0],null)),0),epc=HI(Math.PI/2,cpc),fpc=HI(Math.PI/2,dpc),gpc=new $APP.de(null,function(){return MI(e1,1)},null,null),e1=new $APP.de(null,function(){return MI(gpc,0)},null,null),hpc=a1(e1,gpc),ipc=LXa(e1),jpc=LXa(hpc),kpc=MI($APP.Uj.j(-1),
0),lpc=MI($APP.Ve(new $APP.H(null,2,5,$APP.I,[1,-1],null)),0),mpc=$APP.N.A(new $APP.de(null,function(){return new $APP.H(null,1,5,$APP.I,[1],null)},null,null),new $APP.de(null,function(){return JI(mpc,mpc)},null,null)),opc=$APP.N.A(new $APP.de(null,function(){return new $APP.H(null,1,5,$APP.I,[0],null)},null,null),new $APP.de(null,function(){return npc},null,null)),ppc=$APP.N.A(new $APP.de(null,function(){return new $APP.H(null,1,5,$APP.I,[1],null)},null,null),new $APP.de(null,function(){return ppc},
null,null)),npc=KI(ppc,opc),qpc=$APP.N.A(new $APP.de(null,function(){return new $APP.H(null,2,5,$APP.I,[0,1],null)},null,null),new $APP.de(null,function(){return $APP.Vg.B($APP.wr,qpc,$APP.Fc(qpc))},null,null)),rpc=$APP.St.A(kG,$APP.Vg.A(QF,$APP.af($APP.Lc,1))),spc=$APP.Vg.A(DXa,$APP.af($APP.Lc,1));$APP.e=NI.prototype;$APP.e.toString=function(){return $APP.m.j(aG.j(this))};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.series.Series "',this.toString(),'"]']))};$APP.e.ba=function(){return this.ca};$APP.e.rb=function(){return qT};$APP.e.bc=function(){return SH($APP.u(this.xs))};$APP.e.ma=function(){return this.xs};$APP.e.da=function(a,b){return new NI(this.xs,b)};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.M(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Lb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){var a=this.xs;a=UI.A?UI.A(a,$APP.sf):UI.call(null,a,$APP.sf);return new NI(a,null)};$APP.e.j=function(a){var b=this.xs;a=new $APP.H(null,1,5,$APP.I,[a],null);b=UI.A?UI.A(b,a):UI.call(null,b,a);return new NI(b,null)};
$APP.e.A=function(a,b){var c=this.xs;a=new $APP.H(null,2,5,$APP.I,[a,b],null);c=UI.A?UI.A(c,a):UI.call(null,c,a);return new NI(c,null)};$APP.e.B=function(a,b,c){var d=this.xs;a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);d=UI.A?UI.A(d,a):UI.call(null,d,a);return new NI(d,null)};$APP.e.M=function(a,b,c,d){var g=this.xs;a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);g=UI.A?UI.A(g,a):UI.call(null,g,a);return new NI(g,null)};
$APP.e.S=function(a,b,c,d,g){var l=this.xs;a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);l=UI.A?UI.A(l,a):UI.call(null,l,a);return new NI(l,null)};$APP.e.la=function(a,b,c,d,g,l){var n=this.xs;a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);n=UI.A?UI.A(n,a):UI.call(null,n,a);return new NI(n,null)};$APP.e.Ga=function(a,b,c,d,g,l,n){var p=this.xs;a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);p=UI.A?UI.A(p,a):UI.call(null,p,a);return new NI(p,null)};
$APP.e.va=function(a,b,c,d,g,l,n,p){var v=this.xs;a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);v=UI.A?UI.A(v,a):UI.call(null,v,a);return new NI(v,null)};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){var t=this.xs;a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);t=UI.A?UI.A(t,a):UI.call(null,t,a);return new NI(t,null)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){var A=this.xs;a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);A=UI.A?UI.A(A,a):UI.call(null,A,a);return new NI(A,null)};
$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){var B=this.xs;a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);B=UI.A?UI.A(B,a):UI.call(null,B,a);return new NI(B,null)};$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){var G=this.xs;a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);G=UI.A?UI.A(G,a):UI.call(null,G,a);return new NI(G,null)};
$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){var J=this.xs;a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);J=UI.A?UI.A(J,a):UI.call(null,J,a);return new NI(J,null)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){var O=this.xs;a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);O=UI.A?UI.A(O,a):UI.call(null,O,a);return new NI(O,null)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){var Q=this.xs;a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);Q=UI.A?UI.A(Q,a):UI.call(null,Q,a);return new NI(Q,null)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q){var W=this.xs;a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q],null);W=UI.A?UI.A(W,a):UI.call(null,W,a);return new NI(W,null)};
$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W){var Z=this.xs;a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W],null);Z=UI.A?UI.A(Z,a):UI.call(null,Z,a);return new NI(Z,null)};$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z){var fa=this.xs;a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z],null);fa=UI.A?UI.A(fa,a):UI.call(null,fa,a);return new NI(fa,null)};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa){var ha=this.xs;a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa],null);ha=UI.A?UI.A(ha,a):UI.call(null,ha,a);return new NI(ha,null)};$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha){var ja=this.xs;a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null);ja=UI.A?UI.A(ja,a):UI.call(null,ja,a);return new NI(ja,null)};
$APP.e.Lb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja){var ta=this.xs;a=$APP.N.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null),ja);ta=UI.A?UI.A(ta,a):UI.call(null,ta,a);return new NI(ta,null)};$APP.e.ac=function(a,b,c){function d(g){return FH(g,b,c)}return VI.A?VI.A(d,this):VI.call(null,d,this)};$APP.e.$b=function(a,b,c){function d(g){return GH(g,b,c)}return VI.A?VI.A(d,this):VI.call(null,d,this)};
$APP.e.ic=function(a,b){function c(d){return HH(d,b)}return VI.A?VI.A(c,this):VI.call(null,c,this)};$APP.e=PI.prototype;$APP.e.toString=function(){return $APP.m.j(aG.j(this))};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.series.PowerSeries "',this.toString(),'"]']))};$APP.e.ba=function(){return this.ca};$APP.e.rb=function(){return $U};$APP.e.bc=function(){return new $APP.H(null,2,5,$APP.I,[fI,1],null)};$APP.e.ma=function(){return this.xs};
$APP.e.da=function(a,b){return new PI(this.xs,b)};$APP.e.call=function(a){switch(arguments.length-1){case 1:return this.j(arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.j=function(a){return new NI(QXa.A?QXa.A(this.xs,a):QXa.call(null,this.xs,a),null)};$APP.e.ac=function(a,b,c){function d(g){return FH(g,b,c)}return VI.A?VI.A(d,this):VI.call(null,d,this)};
$APP.e.$b=function(a,b,c){function d(g){return GH(g,b,c)}return VI.A?VI.A(d,this):VI.call(null,d,this)};$APP.e.ic=function(a,b){function c(d){return HH(d,b)}return VI.A?VI.A(c,this):VI.call(null,c,this)};var f1=function f1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return f1.C(c)};f1.C=function(a){return SI(a)};f1.G=0;f1.K=function(a){return this.C($APP.r(a))};
var g1=function g1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return g1.C(c)};g1.C=function(a){return TI(a)};g1.G=0;g1.K=function(a){return this.C($APP.r(a))};
var tpc=SI(new $APP.H(null,1,5,$APP.I,[0],null)),upc=SI(new $APP.H(null,1,5,$APP.I,[1],null)),vpc=SI(new $APP.H(null,2,5,$APP.I,[0,1],null)),wpc=TI(new $APP.H(null,1,5,$APP.I,[0],null)),xpc=TI(new $APP.H(null,1,5,$APP.I,[1],null)),ypc=TI(new $APP.H(null,2,5,$APP.I,[0,1],null)),h1=function h1(a){switch(arguments.length){case 1:return h1.j(arguments[0]);case 2:return h1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
h1.j=function(a){return TI(new $APP.H(null,1,5,$APP.I,[a],null))};h1.A=function(a,b){a=GI(new $APP.H(null,1,5,$APP.I,[a],null));b=OXa(b);return b.A?b.A(a,null):b.call(null,a,null)};h1.G=2;var i1=function i1(a){switch(arguments.length){case 1:return i1.j(arguments[0]);case 2:return i1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};i1.j=function(a){return QI($APP.Vg.A(a,$APP.Hj.J()),null)};
i1.A=function(a,b){a=$APP.Vg.A(a,$APP.Hj.J());b=OXa(b);return b.A?b.A(a,null):b.call(null,a,null)};i1.G=2;var j1=function j1(a){switch(arguments.length){case 1:return j1.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return j1.C(arguments[0],c)}};j1.j=function(a){return j1.C(a,$APP.y([0]))};
j1.C=function(a,b){return QI(function n(d,g,l){return new $APP.de(null,function(){return $APP.Yd(QF.A($APP.Je.A(g,b),l),n(d+1,mR.A(g,$APP.sf),l*d))},null,null)}(1,a,1),null)};j1.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};j1.G=1;var k1=function k1(a){switch(arguments.length){case 1:return k1.j(arguments[0]);case 2:return k1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};k1.j=function(a){return k1.A(a,0)};
k1.A=function(a,b){return QI(MI($APP.r(a),b),$APP.ed(a))};k1.G=2;var OK=QI($oc,null),l1=QI(d1,null),m1=QI(c1,null),n1=QI(apc,null),o1=QI(bpc,null),p1=QI(cpc,null),q1=QI(epc,null),r1=QI(dpc,null),s1=QI(fpc,null),t1=QI(e1,null),u1=QI(gpc,null),v1=QI(hpc,null),w1=QI(ipc,null),x1=QI(jpc,null),zpc=QI(lpc,null),Apc=QI(kpc,null),Bpc=OI(qpc,null),Cpc=OI(mpc,null),Dpc=OI(rpc,null),Epc=OI(spc,null);$APP.hu.A(FF,lT);$APP.hu.A(TH,lT);
for(var y1=$APP.r(new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[OI,qT],null),new $APP.H(null,2,5,$APP.I,[QI,$U],null)],null)),z1=null,A1=0,B1=0;;)if(B1<A1){var C1=z1.aa(null,B1),D1=$APP.x.B(C1,0,null),E1=$APP.x.B(C1,1,null);KF.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),function(){return function(){return!1}}(y1,z1,A1,B1,C1,D1,E1));sG.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),function(){return function(){return!1}}(y1,z1,A1,B1,C1,D1,E1));iZ.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),
function(){return function(){return!1}}(y1,z1,A1,B1,C1,D1,E1));eH.F(null,new $APP.H(null,2,5,$APP.I,[E1,E1],null),function(a,b,c,d,g,l){return function(n,p){n=EXa($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(y1,z1,A1,B1,C1,D1,E1));eH.F(null,new $APP.H(null,2,5,$APP.I,[lT,E1],null),function(a,b,c,d,g,l){return function(n,p){n=FXa(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(y1,z1,A1,B1,C1,D1,E1));eH.F(null,new $APP.H(null,2,5,$APP.I,[E1,lT],null),function(a,
b,c,d,g,l){return function(n,p){p=GXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));PF.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),function(a,b,c,d,g,l){return function(n){var p=$APP.Vg.A(PF,$APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));yG.F(null,new $APP.H(null,2,5,$APP.I,[E1,E1],null),function(a,b,c,d,g,l){return function(n,p){n=HXa($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(y1,z1,A1,B1,C1,
D1,E1));yG.F(null,new $APP.H(null,2,5,$APP.I,[lT,E1],null),function(a,b,c,d,g,l){return function(n,p){n=HI(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(y1,z1,A1,B1,C1,D1,E1));yG.F(null,new $APP.H(null,2,5,$APP.I,[E1,lT],null),function(a,b,c,d,g,l){return function(n,p){p=IXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));MF.F(null,new $APP.H(null,2,5,$APP.I,[E1,E1],null),function(a,b,c,d,g,l){return function(n,p){n=JI($APP.r(n),$APP.r(p));
return l.A?l.A(n,null):l.call(null,n,null)}}(y1,z1,A1,B1,C1,D1,E1));MF.F(null,new $APP.H(null,2,5,$APP.I,[lT,E1],null),function(a,b,c,d,g,l){return function(n,p){n=II(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(y1,z1,A1,B1,C1,D1,E1));MF.F(null,new $APP.H(null,2,5,$APP.I,[E1,lT],null),function(a,b,c,d,g,l){return function(n,p){p=JXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));lG.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),function(a,
b,c,d,g,l){return function(n){var p=$APP.r(n);p=JI(p,p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));oZ.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),function(a,b,c,d,g,l){return function(n){var p=$APP.r(n);p=JI(JI(p,p),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));rI.F(null,new $APP.H(null,2,5,$APP.I,[E1,GY],null),function(a,b,c,d,g,l){return function(n,p){p=MXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,
B1,C1,D1,E1));OF.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),function(a,b,c,d,g,l){return function(n){var p=LI($APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));zG.F(null,new $APP.H(null,2,5,$APP.I,[lT,E1],null),function(a,b,c,d,g,l){return function(n,p){var v=$APP.r(p);n=II(n,LI(v));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(y1,z1,A1,B1,C1,D1,E1));zG.F(null,new $APP.H(null,2,5,$APP.I,[E1,lT],null),function(a,b,c,d,g,l){return function(n,p){p=KXa($APP.r(n),
p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));zG.F(null,new $APP.H(null,2,5,$APP.I,[E1,E1],null),function(a,b,c,d,g,l){return function(n,p){n=a1($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(y1,z1,A1,B1,C1,D1,E1));cR.F(null,new $APP.H(null,2,5,$APP.I,[lT,E1],null),function(){return function(a,b){return zG.A(a,b)}}(y1,z1,A1,B1,C1,D1,E1));cR.F(null,new $APP.H(null,2,5,$APP.I,[E1,lT],null),function(){return function(a,b){return zG.A(a,b)}}(y1,z1,A1,
B1,C1,D1,E1));cR.F(null,new $APP.H(null,2,5,$APP.I,[E1,E1],null),function(){return function(a,b){return zG.A(a,b)}}(y1,z1,A1,B1,C1,D1,E1));VF.F(null,new $APP.H(null,2,5,$APP.I,[lT,E1],null),function(){return function(a,b){return zG.A(b,a)}}(y1,z1,A1,B1,C1,D1,E1));VF.F(null,new $APP.H(null,2,5,$APP.I,[E1,lT],null),function(){return function(a,b){return zG.A(b,a)}}(y1,z1,A1,B1,C1,D1,E1));VF.F(null,new $APP.H(null,2,5,$APP.I,[E1,E1],null),function(){return function(a,b){return zG.A(b,a)}}(y1,z1,A1,B1,
C1,D1,E1));jG.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),function(a,b,c,d,g,l){return function(n){var p=b1($APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,C1,D1,E1));bG.F(null,new $APP.H(null,1,5,$APP.I,[E1],null),function(){return function(a){return VI(bG,a)}}(y1,z1,A1,B1,C1,D1,E1));B1+=1}else{var F1=$APP.r(y1);if(F1){var G1=F1;if($APP.pd(G1)){var Fpc=$APP.lc(G1),Gpc=$APP.mc(G1),Hpc=Fpc,Ipc=$APP.Tc(Fpc);y1=Gpc;z1=Hpc;A1=Ipc}else{var H1=$APP.u(G1),I1=$APP.x.B(H1,0,null),
J1=$APP.x.B(H1,1,null);KF.F(null,new $APP.H(null,1,5,$APP.I,[J1],null),function(){return function(){return!1}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));sG.F(null,new $APP.H(null,1,5,$APP.I,[J1],null),function(){return function(){return!1}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));iZ.F(null,new $APP.H(null,1,5,$APP.I,[J1],null),function(){return function(){return!1}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));eH.F(null,new $APP.H(null,2,5,$APP.I,[J1,J1],null),function(a,b,c,d,g,l){return function(n,p){n=EXa($APP.r(n),$APP.r(p));return l.A?
l.A(n,null):l.call(null,n,null)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));eH.F(null,new $APP.H(null,2,5,$APP.I,[lT,J1],null),function(a,b,c,d,g,l){return function(n,p){n=FXa(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));eH.F(null,new $APP.H(null,2,5,$APP.I,[J1,lT],null),function(a,b,c,d,g,l){return function(n,p){p=GXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));PF.F(null,new $APP.H(null,1,5,$APP.I,[J1],null),function(a,
b,c,d,g,l){return function(n){var p=$APP.Vg.A(PF,$APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));yG.F(null,new $APP.H(null,2,5,$APP.I,[J1,J1],null),function(a,b,c,d,g,l){return function(n,p){n=HXa($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));yG.F(null,new $APP.H(null,2,5,$APP.I,[lT,J1],null),function(a,b,c,d,g,l){return function(n,p){n=HI(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(y1,
z1,A1,B1,H1,I1,J1,G1,F1));yG.F(null,new $APP.H(null,2,5,$APP.I,[J1,lT],null),function(a,b,c,d,g,l){return function(n,p){p=IXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));MF.F(null,new $APP.H(null,2,5,$APP.I,[J1,J1],null),function(a,b,c,d,g,l){return function(n,p){n=JI($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));MF.F(null,new $APP.H(null,2,5,$APP.I,[lT,J1],null),function(a,b,c,d,g,l){return function(n,
p){n=II(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));MF.F(null,new $APP.H(null,2,5,$APP.I,[J1,lT],null),function(a,b,c,d,g,l){return function(n,p){p=JXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));lG.F(null,new $APP.H(null,1,5,$APP.I,[J1],null),function(a,b,c,d,g,l){return function(n){var p=$APP.r(n);p=JI(p,p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));oZ.F(null,
new $APP.H(null,1,5,$APP.I,[J1],null),function(a,b,c,d,g,l){return function(n){var p=$APP.r(n);p=JI(JI(p,p),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));rI.F(null,new $APP.H(null,2,5,$APP.I,[J1,GY],null),function(a,b,c,d,g,l){return function(n,p){p=MXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));OF.F(null,new $APP.H(null,1,5,$APP.I,[J1],null),function(a,b,c,d,g,l){return function(n){var p=LI($APP.r(n));n=$APP.ed(n);
return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));zG.F(null,new $APP.H(null,2,5,$APP.I,[lT,J1],null),function(a,b,c,d,g,l){return function(n,p){var v=$APP.r(p);n=II(n,LI(v));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));zG.F(null,new $APP.H(null,2,5,$APP.I,[J1,lT],null),function(a,b,c,d,g,l){return function(n,p){p=KXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));zG.F(null,new $APP.H(null,2,5,$APP.I,
[J1,J1],null),function(a,b,c,d,g,l){return function(n,p){n=a1($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));cR.F(null,new $APP.H(null,2,5,$APP.I,[lT,J1],null),function(){return function(a,b){return zG.A(a,b)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));cR.F(null,new $APP.H(null,2,5,$APP.I,[J1,lT],null),function(){return function(a,b){return zG.A(a,b)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));cR.F(null,new $APP.H(null,2,5,$APP.I,[J1,J1],null),function(){return function(a,b){return zG.A(a,
b)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));VF.F(null,new $APP.H(null,2,5,$APP.I,[lT,J1],null),function(){return function(a,b){return zG.A(b,a)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));VF.F(null,new $APP.H(null,2,5,$APP.I,[J1,lT],null),function(){return function(a,b){return zG.A(b,a)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));VF.F(null,new $APP.H(null,2,5,$APP.I,[J1,J1],null),function(){return function(a,b){return zG.A(b,a)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));jG.F(null,new $APP.H(null,1,5,$APP.I,[J1],null),function(a,b,c,d,g,l){return function(n){var p=
b1($APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));bG.F(null,new $APP.H(null,1,5,$APP.I,[J1],null),function(){return function(a){return VI(bG,a)}}(y1,z1,A1,B1,H1,I1,J1,G1,F1));y1=$APP.w(G1);z1=null;A1=0}B1=0}else break}oG.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI($oc,$APP.r(a)),$APP.ed(a))});fO.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(c1,$APP.r(a)),$APP.ed(a))});
gO.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(d1,$APP.r(a)),$APP.ed(a))});tZ.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(apc,$APP.r(a)),$APP.ed(a))});wZ.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(bpc,$APP.r(a)),$APP.ed(a))});xZ.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(cpc,$APP.r(a)),$APP.ed(a))});kO.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(epc,$APP.r(a)),$APP.ed(a))});
rG.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(dpc,$APP.r(a)),$APP.ed(a))});yZ.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(fpc,$APP.r(a)),$APP.ed(a))});tH.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(gpc,$APP.r(a)),$APP.ed(a))});vH.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(e1,$APP.r(a)),$APP.ed(a))});BZ.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(hpc,$APP.r(a)),$APP.ed(a))});
GZ.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(ipc,$APP.r(a)),$APP.ed(a))});HZ.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){return QI(KI(jpc,$APP.r(a)),$APP.ed(a))});mR.F(null,new $APP.H(null,2,5,$APP.I,[qT,YR],null),function(a,b){return OI($APP.Vg.A(function(c){return mR.A(c,b)},a.xs),a.ca)});
mR.F(null,new $APP.H(null,2,5,$APP.I,[$U,YR],null),function(a,b){return $APP.hd(b)?QI($APP.Vg.B(iG,$APP.Fc(a.xs),$APP.af($APP.Lc,1)),a.ca):AD(["Cannot yet take partial derivatives of a power series: ",$APP.m.j(a),$APP.m.j(b)].join(""))});tG.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(){return wpc});NF.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(){return xpc});jZ.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(){return ypc});
tG.F(null,new $APP.H(null,1,5,$APP.I,[qT],null),function(){return tpc});NF.F(null,new $APP.H(null,1,5,$APP.I,[qT],null),function(){return upc});jZ.F(null,new $APP.H(null,1,5,$APP.I,[qT],null),function(){return vpc});TF.F(null,new $APP.H(null,1,5,$APP.I,[qT],null),function(){return!1});TF.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(){return!1});
aG.F(null,new $APP.H(null,1,5,$APP.I,[$U],null),function(a){a=$APP.Lf.B($APP.sf,$APP.Hl.A($APP.gp.j(function(b,c){return $APP.k(KF.j(c))?$APP.sf:$APP.k(sG.j(c))?new $APP.H(null,1,5,$APP.I,[new $APP.D(null,DJ,new $APP.D(null,$APP.Hv,new $APP.D(null,b,null,1,null),2,null),3,null)],null):new $APP.H(null,1,5,$APP.I,[new $APP.D(null,$APP.Ev,new $APP.D(null,c,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,$APP.Hv,new $APP.D(null,b,null,1,null),2,null),3,null),null,1,null),2,null),3,null)],null)}),$APP.eh),
aG.j(bG.j($APP.We.A(4,a.xs))));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),a,$APP.y([new $APP.D(null,Gpb,null,1,null)]))))});aG.F(null,new $APP.H(null,1,5,$APP.I,[qT],null),function(a){a=aG.j(bG.j($APP.We.A(4,a.xs)));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Fv,null,1,null),a,$APP.y([new $APP.D(null,Gpb,null,1,null)]))))});var K1=function K1(a){function c(n){var p=$Xa(cJ,K1,n);return $APP.od(n)?$APP.Lf.B($APP.sf,$APP.eh,p):$APP.Yd($APP.GCa,$APP.Je.A($APP.N,p))}if(a instanceof $APP.q)return new $APP.D(null,$APP.K,new $APP.D(null,a,null,1,null),2,null);if(bJ(a)||cJ(a))return $APP.Xc(a);if($APP.kd(a)){if($APP.k(function(){var n=WXa(a);if($APP.k(n))return n;n=YI(a);return $APP.k(n)?n:ZI(a)}())){var d=$APP.r(a),g=$APP.u(d),l=$APP.w(d);d=$APP.u(l);l=$APP.w(l);if(cJ(d))return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,DUb,null,
1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,g,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.py,null,1,null),new $APP.D(null,$APP.Xc(d),null,1,null),$APP.y([new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(l)))),null,1,null)])))),null,1,null)]))));d=bJ(d)?$APP.Xc(d):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,d,null,1,null))));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.GCa,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,g,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,d,null,1,null),l]))))}return c(a)}return $APP.md(a)?uD(K1,a):a};var L1=function L1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return L1.C(arguments[0],c)};L1.C=function(a,b){return function(c,d,g){c=$APP.Je.B(a,c,b);return $APP.k(c)?g.j?g.j(c):g.call(null,c):null}};L1.G=1;L1.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var M1=function M1(a){switch(arguments.length){case 1:return M1.j(arguments[0]);case 2:return M1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};M1.j=function(a){return M1.A(a,$APP.Uc)};M1.A=function(a,b){return iYa(function(c){return b.A?b.A(a,c):b.call(null,a,c)})};M1.G=2;
var pK=function pK(a){switch(arguments.length){case 1:return pK.j(arguments[0]);case 2:return pK.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};pK.j=function(a){return pK.A(a,function(){return!0})};
pK.A=function(a,b){return WI(a)?iYa(b):function(c,d,g){if($APP.k(b.j?b.j(d):b.call(null,d))){var l=$APP.Dd(c,a);if($APP.k(l))return $APP.x.B(l,0,null),l=$APP.x.B(l,1,null),(d=$APP.Uc.A(l,d))?g.j?g.j(c):g.call(null,c):d;c=$APP.rg.B(c,a,d);return g.j?g.j(c):g.call(null,c)}return null}};pK.G=2;
var N1=function N1(a){switch(arguments.length){case 2:return N1.A(arguments[0],arguments[1]);case 3:return N1.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};N1.A=function(a,b){return kYa(a,b)};N1.B=function(a,b,c){var d=fJ.j?fJ.j(b):fJ.call(null,b),g=fJ.j?fJ.j(c):fJ.call(null,c);return function(l,n,p){return $APP.k(a.j?a.j(n):a.call(null,n))?d.B?d.B(l,n,p):d.call(null,l,n,p):g.B?g.B(l,n,p):g.call(null,l,n,p)}};N1.G=3;
var rK=function rK(a){switch(arguments.length){case 0:return rK.J();case 1:return rK.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return rK.C(arguments[0],c)}};rK.J=function(){return gYa};rK.j=function(a){return fJ.j?fJ.j(a):fJ.call(null,a)};rK.C=function(a,b){var c=$APP.Vg.A(fJ,$APP.Yd(a,b));return function(d,g,l){return $APP.He(function(n){return n.B?n.B(d,g,l):n.call(null,d,g,l)},c)}};
rK.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};rK.G=1;var sK=function sK(a){switch(arguments.length){case 0:return sK.J();case 1:return sK.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return sK.C(arguments[0],c)}};sK.J=function(){return hYa};sK.j=function(a){return fJ.j?fJ.j(a):fJ.call(null,a)};
sK.C=function(a,b){var c=$APP.Vg.A(fJ,$APP.Yd(a,b));return function(d,g,l){return $APP.Id.B(function(n,p){return $APP.k(n)?p.B?p.B(n,g,l):p.call(null,n,g,l):$APP.Mc(n)},d,c)}};sK.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};sK.G=1;var O1=function O1(a){switch(arguments.length){case 1:return O1.j(arguments[0]);case 2:return O1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};O1.j=function(a){return O1.A(a,$APP.Le(!0))};
O1.A=function(a,b){return nYa(function(c,d,g){d=$APP.k(d)?d:$APP.sf;if($APP.kd(d)){var l=function(){var t=!WI(a);return t?c.j?c.j(a):c.call(null,a):t}();if($APP.k(l)){if($APP.k(b.j?b.j(l):b.call(null,l))){var n=$APP.Tc(l);if($APP.Uc.A($APP.We.A(n,d),l))return d=$APP.Se.A(n,d),g.A?g.A(c,d):g.call(null,c,d)}return null}for(var p=$APP.sf,v=d;;)if(d=function(){var t=b.j?b.j(p):b.call(null,p);return $APP.k(t)?(t=WI(a)?c:$APP.rg.B(c,a,p),g.A?g.A(t,v):g.call(null,t,v)):t}(),!$APP.k(d)&&(d=$APP.r(v)))d=$APP.Vd.A(p,
$APP.u(v)),l=$APP.w(v),p=d,v=l;else return d}else return null})};O1.G=2;var P1=function P1(a){switch(arguments.length){case 1:return P1.j(arguments[0]);case 2:return P1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};P1.j=function(a){return P1.A(a,$APP.Le(!0))};
P1.A=function(a,b){return nYa(function(c,d,g){d=$APP.k(d)?d:$APP.sf;if($APP.kd(d)){var l=c.j?c.j(a):c.call(null,a);if($APP.k(l)&&$APP.od(l)){var n=$APP.Tc(l);l=$APP.Qb(l);l=(l=$APP.Uc.A($APP.We.A(n,d),l))?b.j?b.j(d):b.call(null,d):l;if($APP.k(l))return d=$APP.Se.A(n,d),g.A?g.A(c,d):g.call(null,c,d)}}return null})};P1.G=2;var Q1=function Q1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return Q1.C(c)};Q1.C=function(a){return pYa(a)};
Q1.G=0;Q1.K=function(a){return this.C($APP.r(a))};var fJ=function fJ(a){if($APP.cd(a))var c=a;else if($APP.k(WXa(a)))c=pK.A($I(a),aJ(a));else if($APP.k(YI(a)))c=O1.A($I(a),aJ(a));else if($APP.k(ZI(a)))c=P1.A(ZXa(a),aJ(a));else if(WI(a))c=hYa;else if($APP.td(a)||$APP.od(a))if($APP.hd(a))c=M1.j(a);else{c=$APP.N.A;var d=$APP.Vg.A(fJ,$APP.zg(a));a=$APP.$c(a);a=new $APP.H(null,1,5,$APP.I,[$APP.k(YI(a))?oYa($I(a),aJ(a)):fJ.j?fJ.j(a):fJ.call(null,a)],null);c=pYa(c.call($APP.N,d,a))}else c=M1.j(a);return c};
$APP.e=gJ.prototype;$APP.e.Ka=function(a,b){return this.fa(null,b,null)};$APP.e.fa=function(a,b,c){return $APP.C.B(this.N,b,c)};$APP.e.lb=function(a,b,c){return $APP.Id.B(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return b.B?b.B(d,l,g):b.call(null,d,l,g)},c,this)};$APP.e.ea=function(a,b,c){return $APP.Rg(b,function(d){return $APP.Rg(b,$APP.Ug,""," ","",c,d)},"#emmy.pattern.match.Failure{",", ","}",c,$APP.N.A($APP.sf,this.N))};
$APP.e.Qa=function(){return new $APP.Ff(this,0,$APP.sf,$APP.k(this.N)?$APP.qc(this.N):$APP.we())};$APP.e.ba=function(){return this.R};$APP.e.qa=function(){return new gJ(this.R,this.N,this.P)};$APP.e.ta=function(){return 0+$APP.Tc(this.N)};$APP.e.ka=function(){var a=this.P;return null!=a?a:this.P=a=-73365589^$APP.Kc(this)};$APP.e.Y=function(a,b){return null!=b&&this.constructor===b.constructor&&$APP.Uc.A(this.N,b.N)};
$APP.e.Ib=function(a,b){return $APP.Bd($APP.vg,b)?$APP.Oi.A($APP.Ib($APP.Lf.A($APP.F,this),this.R),b):new gJ(this.R,$APP.re($APP.Oi.A(this.N,b)),null)};$APP.e.Va=function(a,b){return $APP.Bd(this.N,b)};$APP.e.sa=function(a,b,c){return new gJ(this.R,$APP.rg.B(this.N,b,c),null)};$APP.e.ma=function(){return $APP.r($APP.N.A($APP.sf,this.N))};$APP.e.da=function(a,b){return new gJ(b,this.N,this.P)};
$APP.e.ua=function(a,b){return $APP.od(b)?this.sa(null,$APP.bd(b,0),$APP.bd(b,1)):$APP.Id.B($APP.nb,this,b)};var jJ=new gJ(null,null,null),iJ=function iJ(a){switch(arguments.length){case 1:return iJ.j(arguments[0]);case 2:return iJ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};iJ.j=function(a){var b=fJ(a);return function(c){c=b.B?b.B($APP.F,c,$APP.Kd):b.call(null,$APP.F,c,$APP.Kd);return $APP.k(c)?c:jJ}};
iJ.A=function(a,b){function c(g){var l=b.j?b.j(g):b.call(null,g);return $APP.k(l)?$APP.k($APP.k(l)?lYa(hJ(l)):l)?$APP.md(l)?$APP.Ni.C($APP.y([g,l])):g:null:null}var d=fJ(a);return function(g){g=d.B?d.B($APP.F,g,c):d.call(null,$APP.F,g,c);return $APP.k(g)?g:jJ}};iJ.G=2;var R1=function R1(a){switch(arguments.length){case 2:return R1.A(arguments[0],arguments[1]);case 3:return R1.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
R1.A=function(a,b){return iJ.j(a)(b)};R1.B=function(a,b,c){return iJ.A(a,b)(c)};R1.G=3;var xJ=$APP.Le(!0),Jpc=$APP.Le(!1),vJ=function vJ(a){switch(arguments.length){case 1:return vJ.j(arguments[0]);case 2:return vJ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};vJ.j=function(a){return iJ.j(a)};vJ.A=function(a,b){return $APP.k($APP.k(b)?$APP.qg.A(b,xJ):b)?iJ.A(a,b):iJ.j(a)};vJ.G=2;
var S1=function S1(a){switch(arguments.length){case 3:return S1.B(arguments[0],arguments[1],arguments[2]);case 4:return S1.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};S1.B=function(a,b,c){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,l0b,null,1,null),new $APP.D(null,K1(c),null,1,null))))};
S1.M=function(a,b,c,d){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,l0b,null,1,null),new $APP.D(null,K1(c),null,1,null),$APP.y([$APP.k(d)?new $APP.H(null,1,5,$APP.I,[d],null):null]))))};S1.G=4;var T1=function T1(a){switch(arguments.length){case 3:return T1.B(arguments[0],arguments[1],arguments[2]);case 4:return T1.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
T1.B=function(a,b,c){$APP.rg.B(b,zX,!0);return fYa($APP.F,c)};T1.M=function(a,b,c,d){$APP.rg.B(b,zX,!0);a=$APP.Nj.J();return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.fm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,a,null,1,null),new $APP.D(null,c,null,1,null))))),null,1,null),$APP.y([new $APP.D(null,fYa(a,d),null,1,null)]))))};T1.G=4;
var U1=function U1(a){switch(arguments.length){case 2:return U1.A(arguments[0],arguments[1]);case 3:return U1.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};U1.A=function(a,b){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,zub,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,V2b,null,1,null),new $APP.D(null,a,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))};
U1.B=function(a,b,c){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,zub,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,V2b,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,lhb,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)]))))};U1.G=3;
var V1=function V1(a){switch(arguments.length){case 4:return V1.M(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return V1.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};V1.M=function(a,b,c,d){$APP.rg.B(b,zX,!0);return U1.A(c,d)};V1.S=function(a,b,c,d,g){$APP.rg.B(b,zX,!0);return U1.B(c,d,g)};V1.G=5;
var mJ=function mJ(a){switch(arguments.length){case 0:return mJ.J();case 1:return mJ.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return mJ.C(arguments[0],c)}};mJ.J=function(){return tYa};mJ.j=function(a){return a};mJ.C=function(a,b){return wYa($APP.Yd(a,b))};mJ.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};mJ.G=1;
var oJ=function oJ(a){switch(arguments.length){case 0:return oJ.J();case 1:return oJ.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return oJ.C(arguments[0],c)}};oJ.J=function(){return sYa};oJ.j=function(a){return a};oJ.C=function(a,b){return xYa($APP.Yd(a,b))};oJ.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};oJ.G=1;
var W1=function W1(a){switch(arguments.length){case 1:return W1.j(arguments[0]);case 2:return W1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};W1.j=function(a){return W1.A(a,$APP.Xt)};W1.A=function(a,b){var c=$APP.Nj.j("t_");return function(d){var g=new $APP.f(null,2,[$APP.Wl,c,Q4b,d],null);b.j?b.j(g):b.call(null,g);d=a.j?a.j(d):a.call(null,d);g=new $APP.f(null,2,[$APP.Wl,c,yDb,d],null);b.j?b.j(g):b.call(null,g);return d}};W1.G=2;
var uJ=function uJ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return uJ.C(c)};uJ.C=function(a){return nJ($APP.Je.A(mJ,a))};uJ.G=0;uJ.K=function(a){return this.C($APP.r(a))};var X1=function X1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return X1.C(arguments[0],arguments[1],c)};
X1.C=function(a,b,c){$APP.rg.B(b,zX,!0);$APP.Tc(c);a=$APP.Jl.A(3,c);a=$APP.Vg.A(function(d){return $APP.Je.A(U1,d)},a);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,Fub,null,1,null),a)))};X1.G=2;X1.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var yJ=function yJ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return yJ.C(c)};
yJ.C=function(a){return CYa($APP.Je.A(oJ,$APP.Vg.A(nJ,a)))};yJ.G=0;yJ.K=function(a){return this.C($APP.r(a))};var Y1=function Y1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return Y1.C(c)};Y1.C=function(a){return $APP.Je.A(yJ,a)};Y1.G=0;Y1.K=function(a){return this.C($APP.r(a))};var Z1=function Z1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return Z1.C(c)};Z1.C=function(a){a=$APP.Lf.A($APP.vg,a);return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),xJ),function(b){b=CJ.j?CJ.j(b):CJ.call(null,b);return $APP.k(b)?b:dJ(b)})]))};Z1.G=0;Z1.K=function(a){return this.C($APP.r(a))};
var $1=function $1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return $1.C(c)};
$1.C=function(a){function b(c){return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,c,new $APP.D(null,wJ,null,1,null),2,null),xJ),function(d){d=$APP.tf(wJ.j?wJ.j(d):wJ.call(null,d));return $APP.k(d)?d:dJ(d)}),kJ(vJ.A(CJ,xJ),function(d){d=$APP.tf(new $APP.H(null,1,5,$APP.I,[CJ.j?CJ.j(d):CJ.call(null,d)],null));return $APP.k(d)?d:dJ(d)})]))}a=$APP.Lf.A($APP.vg,a);return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,TJ,
new $APP.D(null,new $APP.D(null,qK,new $APP.D(null,UJ,null,1,null),2,null),new $APP.D(null,VJ,null,1,null),2,null),3,null),4,null),xJ),function(c){var d=$APP.N.C,g=new $APP.H(null,1,5,$APP.I,[qK.j?qK.j(c):qK.call(null,c)],null),l=TJ.j?TJ.j(c):TJ.call(null,c),n=$APP.qe(c);c=$APP.C.A(n,qK);var p=$APP.C.A(n,UJ);n=$APP.C.A(n,VJ);c=$APP.bf.C(b(c),$APP.y([$APP.N.A(p,n)]));return(d=$APP.r(d.call($APP.N,g,l,$APP.y([c]))))?d:dJ(d)})]))};$1.G=0;$1.K=function(a){return this.C($APP.r(a))};
var a2=function a2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return a2.C(c)};
a2.C=function(a){a=$APP.Lf.A($APP.vg,a);return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,wJ,null,1,null),2,null),xJ),function(b){var c=$APP.N.A,d=new $APP.H(null,1,5,$APP.I,[qK.j?qK.j(b):qK.call(null,b)],null);b=dTa(b.j?b.j(wJ):b.call(null,wJ));return(c=$APP.r(c.call($APP.N,d,b)))?c:dJ(c)})]))};a2.G=0;a2.K=function(a){return this.C($APP.r(a))};
var b2=function b2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return b2.C(c)};
b2.C=function(a){a=$APP.Lf.A($APP.vg,a);return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,HV,new $APP.D(null,CJ,new $APP.D(null,CJ,new $APP.D(null,HX,null,1,null),2,null),3,null),4,null),5,null),xJ),function(b){var c=$APP.N.A,d=new $APP.H(null,1,5,$APP.I,[qK.j?qK.j(b):qK.call(null,b)],null);var g=$APP.El.j;b=$APP.r($APP.N.C(HV.j?HV.j(b):HV.call(null,b),new $APP.H(null,1,5,$APP.I,[CJ.j?CJ.j(b):CJ.call(null,
b)],null),$APP.y([HX.j?HX.j(b):HX.call(null,b)])));g=g.call($APP.El,b?b:dJ(b));return(c=$APP.r(c.call($APP.N,d,g)))?c:dJ(c)})]))};b2.G=0;b2.K=function(a){return this.C($APP.r(a))};
var Kpc=uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,qK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,CF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,OU,new $APP.D(null,CF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){var b=$APP.I,c=qK.j?qK.j(a):qK.call(null,a);a=kG.A(a.j?a.j(AJ):a.call(null,AJ),a.j?a.j(OU):a.call(null,OU));return(b=$APP.r(new $APP.H(null,
3,5,b,[DJ,c,a],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,HV,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,qK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,CF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,qK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,OU,new $APP.D(null,CF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,HX,null,1,null),2,null),3,null),
4,null),5,null),xJ),function(a){var b=$APP.N.C,c=new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),d=HV.j?HV.j(a):HV.call(null,a),g=$APP.I,l=$APP.I,n=qK.j?qK.j(a):qK.call(null,a);var p=kG.A(a.j?a.j(AJ):a.call(null,AJ),a.j?a.j(OU):a.call(null,OU));return(a=$APP.r(b.call($APP.N,c,d,$APP.y([new $APP.H(null,1,5,g,[$APP.r(new $APP.H(null,3,5,l,[DJ,n,p],null))],null),HX.j?HX.j(a):HX.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,HV,new $APP.D(null,qK,new $APP.D(null,new $APP.D(null,
DJ,new $APP.D(null,qK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,CF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,HX,null,1,null),2,null),3,null),4,null),5,null),xJ),function(a){var b=$APP.N.C,c=new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),d=HV.j?HV.j(a):HV.call(null,a),g=$APP.I,l=$APP.I,n=qK.j?qK.j(a):qK.call(null,a);var p=kG.A(a.j?a.j(AJ):a.call(null,AJ),1);return(a=$APP.r(b.call($APP.N,c,d,$APP.y([new $APP.H(null,1,5,g,[$APP.r(new $APP.H(null,
3,5,l,[DJ,n,p],null))],null),HX.j?HX.j(a):HX.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,HV,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,qK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,CF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,qK,new $APP.D(null,HX,null,1,null),2,null),3,null),4,null),5,null),xJ),function(a){var b=$APP.N.C,c=new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),d=HV.j?HV.j(a):HV.call(null,a),g=
$APP.I,l=$APP.I,n=qK.j?qK.j(a):qK.call(null,a);var p=kG.A(a.j?a.j(AJ):a.call(null,AJ),1);return(a=$APP.r(b.call($APP.N,c,d,$APP.y([new $APP.H(null,1,5,g,[$APP.r(new $APP.H(null,3,5,l,[DJ,n,p],null))],null),HX.j?HX.j(a):HX.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,HV,new $APP.D(null,qK,new $APP.D(null,qK,new $APP.D(null,HX,null,1,null),2,null),3,null),4,null),5,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),HV.j?HV.j(a):HV.call(null,
a),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,qK.j?qK.j(a):qK.call(null,a),2],null))],null),HX.j?HX.j(a):HX.call(null,a)]))))?a:dJ(a)})])),yZa=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,AK,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,DF,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){a=$APP.Hl.A(xG,AJ)(a);return $APP.k(a)?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,AK,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,wJ,
null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),function(b){b=$APP.qe(b);b=$APP.C.A(b,wJ);return $APP.Vg.A(function(c){return new $APP.D(null,AK,new $APP.D(null,c,null,1,null),2,null)},b)}(a))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,AK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,1,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[AK,CJ.j?CJ.j(a):
CJ.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,AK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,HYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(a):CJ.call(null,a),AJ.j?AJ.j(a):AJ.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,AK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,
new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,CF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){var b=$APP.I,c=$APP.r(new $APP.H(null,2,5,$APP.I,[AK,CJ.j?CJ.j(a):CJ.call(null,a)],null)),d=$APP.I,g=CJ.j?CJ.j(a):CJ.call(null,a);a=RF.A(a.j?a.j(AJ):a.call(null,AJ),1);return(b=$APP.r(new $APP.H(null,3,5,b,[$APP.Ev,c,$APP.r(new $APP.H(null,3,5,d,[DJ,g,a],null))],null)))?b:dJ(b)})]))])),RJ=function RJ(a){switch(arguments.length){case 2:return RJ.A(arguments[0],
arguments[1]);case 3:return RJ.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};RJ.A=function(a,b){return EJ.B($APP.T.j($APP.r($APP.N.A(new $APP.D(null,rM,null,1,null),new $APP.D(null,a,null,1,null)))),b,function(){return!1})};
RJ.B=function(a,b,c){return EJ.B($APP.T.j($APP.r($APP.N.A(new $APP.D(null,rM,null,1,null),new $APP.D(null,a,null,1,null)))),c,function(){return!1})&&EJ.B($APP.T.j($APP.r($APP.N.A(new $APP.D(null,rM,null,1,null),new $APP.D(null,b,null,1,null)))),c,function(){return!1})};RJ.G=3;
var Lpc=function(){var a=wG.A(0,2);return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,FJ,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,hK,new $APP.D(null,RU,null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,RU.j?RU.j(b):RU.call(null,b)],null))],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,RU.j?RU.j(b):RU.call(null,b)],null))],null))],null))],null)),a],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,jK,new $APP.D(null,RU,
null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,RF.j(nG),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,RU.j?RU.j(b):RU.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,RU.j?RU.j(b):RU.call(null,b),2],null))],null))],null))],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,kK,new $APP.D(null,
RU,null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,RF.j(nG),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,RU.j?RU.j(b):RU.call(null,b),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,RU.j?RU.j(b):RU.call(null,b),2],null))],null))],null))],null))],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,wH,
new $APP.D(null,QU,null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,QU.j?QU.j(b):QU.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,-1,QU.j?QU.j(b):QU.call(null,b)],null))],null))],null)),2],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,uH,new $APP.D(null,QU,null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,
5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,QU.j?QU.j(b):QU.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,-1,QU.j?QU.j(b):QU.call(null,b)],null))],null))],null)),2],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,JJ,new $APP.D(null,EYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,
2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,JJ.j?JJ.j(b):JJ.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null))],null)))?b:dJ(b)})]))]))}(),Mpc=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,
CJ.j?CJ.j(a):CJ.call(null,a),-1],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,1,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(a):CJ.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,
new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,-1,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,
new $APP.D(null,$APP.rj,new $APP.D(null,3,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(a):CJ.call(null,a)],null)),3],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,-3,new $APP.D(null,
2,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,CJ.j?CJ.j(a):CJ.call(null,a)],null)),-3],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,TS,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,US,null,
1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(a):CJ.call(null,a),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TS.j?TS.j(a):TS.call(null,a),$APP.y([US.j?US.j(a):US.call(null,a)])))],null)))?a:dJ(a)})]))])),t1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,mY,new $APP.D(null,YJ,new $APP.D(null,wJ,null,1,null),2,null),3,null),4,null),null,1,null),
2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,mY.j?mY.j(a):mY.call(null,a)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,YJ.j?YJ.j(a):YJ.call(null,a)],null),wJ.j?wJ.j(a):wJ.call(null,a)))],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,mY,new $APP.D(null,YJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,mY.j?mY.j(a):mY.call(null,a)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,YJ.j?YJ.j(a):YJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,CJ,new $APP.D(null,mzb,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,mzb.j?mzb.j(a):mzb.call(null,a),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,
CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)))?a:dJ(a)})]))])),Npc=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,CF,null,1,null),2,null),3,null),new $APP.D(null,bK,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,cK,null,1,null),2,null),3,null),4,null),5,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),bK.j?bK.j(a):bK.call(null,a),$APP.y([new $APP.H(null,
1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,CJ.j?CJ.j(a):CJ.call(null,a),AJ.j?AJ.j(a):AJ.call(null,a)],null))],null))],null),cK.j?cK.j(a):cK.call(null,a)]))))?a:dJ(a)})]))])),y1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,xT,null,1,null),2,null),new $APP.D(null,PU,null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=
$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,a))),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a)))],null)),PU.j?PU.j(a):PU.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,
xT,null,1,null),2,null),new $APP.D(null,aU,null,1,null),2,null),3,null),new $APP.D(null,PU,null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,a))),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a)))],null),aU.j?aU.j(a):aU.call(null,a))),PU.j?PU.j(a):PU.call(null,a)],null)))?
a:dJ(a)}),kJ(vJ.A(new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,AJ,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,xT,null,1,null),2,null),new $APP.D(null,PU,null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,
1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,a))),AJ.j?AJ.j(a):AJ.call(null,a)],null)),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a)))],null)),PU.j?PU.j(a):PU.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,xT,null,1,null),2,null),new $APP.D(null,AJ,null,1,null),2,null),3,
null),new $APP.D(null,PU,null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,a))),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a))),AJ.j?AJ.j(a):AJ.call(null,a)],null))],null)),PU.j?PU.j(a):PU.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,
new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,AJ,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,xT,null,1,null),2,null),new $APP.D(null,OU,null,1,null),2,null),3,null),new $APP.D(null,PU,null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,
3,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,a))),AJ.j?AJ.j(a):AJ.call(null,a)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a))),OU.j?OU.j(a):OU.call(null,a)],null))],null)),PU.j?PU.j(a):PU.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,
AJ,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,xT,null,1,null),2,null),new $APP.D(null,aU,null,1,null),2,null),3,null),new $APP.D(null,PU,null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,
a))),AJ.j?AJ.j(a):AJ.call(null,a)],null)),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a)))],null),aU.j?aU.j(a):aU.call(null,a))),PU.j?PU.j(a):PU.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,xT,null,1,null),2,null),new $APP.D(null,OU,null,
1,null),2,null),3,null),new $APP.D(null,aU,null,1,null),2,null),3,null),new $APP.D(null,PU,null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,a))),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a))),OU.j?OU.j(a):OU.call(null,a)],null))],
null),aU.j?aU.j(a):aU.call(null,a))),PU.j?PU.j(a):PU.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,AJ,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,xT,null,1,null),2,null),new $APP.D(null,OU,null,1,null),2,null),3,null),new $APP.D(null,aU,null,1,
null),2,null),3,null),new $APP.D(null,PU,null,1,null),2,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,a))),AJ.j?AJ.j(a):AJ.call(null,a)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a))),OU.j?OU.j(a):
OU.call(null,a)],null))],null),aU.j?aU.j(a):aU.call(null,a))),PU.j?PU.j(a):PU.call(null,a)],null)))?a:dJ(a)})])),pJ(function(){return!0},kJ(vJ.A(new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,wJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,yT,null,1,null),2,null),new $APP.D(null,SJ,new $APP.D(null,new $APP.D(null,$APP.Rw,new $APP.D(null,xT,null,1,null),2,null),new $APP.D(null,pac,null,1,null),2,null),3,null),4,null),5,null),6,null),new $APP.D(null,PU,null,1,null),
2,null),new $APP.D(null,rWb,null,1,null),2,null),function(a){var b=$APP.qe(a);a=$APP.C.A(b,yT);b=$APP.C.A(b,xT);return 0<$APP.Ed($APP.tf(a),$APP.tf(b))}),function(a){return(a=$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),wJ.j?wJ.j(a):wJ.call(null,a),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),xT.j?xT.j(a):xT.call(null,a)))],null),SJ.j?SJ.j(a):SJ.call(null,
a),new $APP.H(null,1,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Rw],null),yT.j?yT.j(a):yT.call(null,a)))],null),pac.j?pac.j(a):pac.call(null,a)]))),PU.j?PU.j(a):PU.call(null,a)],null))],null),rWb.j?rWb.j(a):rWb.call(null,a))))?a:dJ(a)}))])),x1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,lK,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,CJ.j?CJ.j(a):CJ.call(null,a)],null)),$APP.r(new $APP.H(null,
2,5,$APP.I,[sH,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,MM,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,CJ.j?CJ.j(a):CJ.call(null,a)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,LM,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,
[$APP.rj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,NM,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,hK,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,JJ,new $APP.D(null,CJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=
$APP.r(new $APP.H(null,3,5,$APP.I,[hK,JJ.j?JJ.j(a):JJ.call(null,a),CJ.j?CJ.j(a):CJ.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,hK,new $APP.D(null,JJ,null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[hK,JJ.j?JJ.j(a):JJ.call(null,a),1],null)))?a:dJ(a)})]))])),m1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),
2,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[lK,CJ.j?CJ.j(a):CJ.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,TS,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,US,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,
1,5,$APP.I,[$APP.Ev],null),TS.j?TS.j(a):TS.call(null,a),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[lK,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null),US.j?US.j(a):US.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,uS,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,vS,null,1,null),2,null),3,
null),4,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[lK,CJ.j?CJ.j(a):CJ.call(null,a)],null)),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),uS.j?uS.j(a):uS.call(null,a),$APP.y([vS.j?vS.j(a):vS.call(null,a)])))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,TS,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,
US,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,uS,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,vS,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),TS.j?TS.j(a):TS.call(null,a),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[lK,CJ.j?CJ.j(a):
CJ.call(null,a)],null))],null),US.j?US.j(a):US.call(null,a)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),uS.j?uS.j(a):uS.call(null,a),$APP.y([vS.j?vS.j(a):vS.call(null,a)])))],null)))?a:dJ(a)})]))])),o1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,qJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){var b=$APP.I;a=-(a.j?a.j(AJ):a.call(null,AJ));return(b=$APP.r(new $APP.H(null,2,5,b,[sH,
a],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,qJ,null,1,null),2,null),3,null),new $APP.D(null,zT,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){var b=$APP.I,c=$APP.N.A,d=$APP.I;var g=-(a.j?a.j(AJ):a.call(null,AJ));return(a=$APP.r(new $APP.H(null,2,5,b,[sH,$APP.r(c.call($APP.N,new $APP.H(null,2,5,d,[$APP.Ev,g],null),zT.j?zT.j(a):zT.call(null,a)))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,
sH,new $APP.D(null,new $APP.D(null,$APP.Fv,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,qJ,null,1,null),2,null),3,null),new $APP.D(null,zT,null,1,null),2,null),3,null),new $APP.D(null,BT,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){var b=$APP.I,c=$APP.N.A,d=$APP.I,g=$APP.N.A,l=$APP.I;var n=-(a.j?a.j(AJ):a.call(null,AJ));return(a=$APP.r(new $APP.H(null,2,5,b,[sH,$APP.r(c.call($APP.N,new $APP.H(null,2,5,d,[$APP.Gv,
$APP.r(g.call($APP.N,new $APP.H(null,2,5,l,[$APP.Ev,n],null),zT.j?zT.j(a):zT.call(null,a)))],null),BT.j?BT.j(a):BT.call(null,a)))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,qJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){var b=$APP.I,c=$APP.I;a=-(a.j?a.j(AJ):a.call(null,AJ));return(b=$APP.r(new $APP.H(null,2,5,b,[$APP.Gv,$APP.r(new $APP.H(null,2,5,c,[kH,a],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,
kH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,qJ,null,1,null),2,null),3,null),new $APP.D(null,zT,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){var b=$APP.I,c=$APP.I,d=$APP.N.A,g=$APP.I;var l=-(a.j?a.j(AJ):a.call(null,AJ));return(a=$APP.r(new $APP.H(null,2,5,b,[$APP.Gv,$APP.r(new $APP.H(null,2,5,c,[kH,$APP.r(d.call($APP.N,new $APP.H(null,2,5,g,[$APP.Ev,l],null),zT.j?zT.j(a):zT.call(null,a)))],null))],null)))?a:dJ(a)}),
kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,$APP.Fv,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,qJ,null,1,null),2,null),3,null),new $APP.D(null,zT,null,1,null),2,null),3,null),new $APP.D(null,BT,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){var b=$APP.I,c=$APP.I,d=$APP.N.A,g=$APP.I,l=$APP.N.A,n=$APP.I;var p=-(a.j?a.j(AJ):a.call(null,AJ));return(a=$APP.r(new $APP.H(null,2,5,b,[$APP.Gv,$APP.r(new $APP.H(null,
2,5,c,[kH,$APP.r(d.call($APP.N,new $APP.H(null,2,5,g,[$APP.Gv,$APP.r(l.call($APP.N,new $APP.H(null,2,5,n,[$APP.Ev,p],null),zT.j?zT.j(a):zT.call(null,a)))],null),BT.j?BT.j(a):BT.call(null,a)))],null))],null)))?a:dJ(a)})]))])),Opc=function(){function a(b){var c=CF(b);return c?(c=TF.j(b),$APP.k(c)?3<b:c):c}return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,2,new $APP.D(null,CJ,new $APP.D(null,BT,null,1,null),2,null),3,null),4,null),null,
1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,2,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(b):CJ.call(null,b)],null),BT.j?BT.j(b):BT.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(b):CJ.call(null,b)],null),BT.j?BT.j(b):BT.call(null,b)))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Ev,
new $APP.D(null,2,new $APP.D(null,CJ,new $APP.D(null,BT,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,2,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(b):CJ.call(null,b)],null),BT.j?BT.j(b):BT.call(null,b)))],null)),2],null))],null)),1],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,
new $APP.D(null,$APP.Ev,new $APP.D(null,3,new $APP.D(null,CJ,new $APP.D(null,BT,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,3,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(b):CJ.call(null,b)],null),BT.j?BT.j(b):BT.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,-4,$APP.r(new $APP.H(null,3,5,$APP.I,
[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(b):CJ.call(null,b)],null),BT.j?BT.j(b):BT.call(null,b)))],null)),3],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,3,new $APP.D(null,CJ,new $APP.D(null,BT,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,4,$APP.r(new $APP.H(null,
3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(b):CJ.call(null,b)],null),BT.j?BT.j(b):BT.call(null,b)))],null)),3],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,-3,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(b):CJ.call(null,b)],null),BT.j?BT.j(b):BT.call(null,b)))],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,$APP.Ev,
new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.uU,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,PU,new $APP.D(null,RS,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Ev,function(c){return RF.A(c.j?c.j($APP.uU):c.call(null,$APP.uU),1)}(b),PU.j?PU.j(b):PU.call(null,b)],
null),RS.j?RS.j(b):RS.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,PU.j?PU.j(b):PU.call(null,b)],null),RS.j?RS.j(b):RS.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Ev,function(c){return RF.A(c.j?c.j($APP.uU):c.call(null,$APP.uU),1)}(b),PU.j?PU.j(b):PU.call(null,b)],null),RS.j?RS.j(b):RS.call(null,b)))],null)),$APP.r(new $APP.H(null,
2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,PU.j?PU.j(b):PU.call(null,b)],null),RS.j?RS.j(b):RS.call(null,b)))],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,$APP.Fv,new $APP.D(null,CJ,new $APP.D(null,JJ,new $APP.D(null,SJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,CJ.j?
CJ.j(b):CJ.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Fv,JJ.j?JJ.j(b):JJ.call(null,b)],null),SJ.j?SJ.j(b):SJ.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,CJ.j?CJ.j(b):CJ.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Fv,JJ.j?JJ.j(b):JJ.call(null,b)],null),SJ.j?SJ.j(b):SJ.call(null,b)))],null))],null))],null)))?
b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.uU,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,PU,new $APP.D(null,RS,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Ev,function(c){return RF.A(c.j?
c.j($APP.uU):c.call(null,$APP.uU),1)}(b),PU.j?PU.j(b):PU.call(null,b)],null),RS.j?RS.j(b):RS.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,PU.j?PU.j(b):PU.call(null,b)],null),RS.j?RS.j(b):RS.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Ev,function(c){return RF.A(c.j?c.j($APP.uU):c.call(null,$APP.uU),1)}(b),PU.j?PU.j(b):
PU.call(null,b)],null),RS.j?RS.j(b):RS.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,PU.j?PU.j(b):PU.call(null,b)],null),RS.j?RS.j(b):RS.call(null,b)))],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Fv,new $APP.D(null,CJ,new $APP.D(null,JJ,new $APP.D(null,SJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,CJ.j?CJ.j(b):CJ.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Fv,JJ.j?JJ.j(b):JJ.call(null,b)],null),SJ.j?SJ.j(b):SJ.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,CJ.j?CJ.j(b):CJ.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Fv,JJ.j?
JJ.j(b):JJ.call(null,b)],null),SJ.j?SJ.j(b):SJ.call(null,b)))],null))],null))],null)))?b:dJ(b)})]))]))}(),Ppc=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,UJ,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,VJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Fv,
$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,2,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null))],null))],null),TJ.j?TJ.j(a):TJ.call(null,
a),$APP.y([UJ.j?UJ.j(a):UJ.call(null,a),VJ.j?VJ.j(a):VJ.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,UJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null),new $APP.D(null,VJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,
2,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,2,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null))],null))],null),TJ.j?
TJ.j(a):TJ.call(null,a),$APP.y([UJ.j?UJ.j(a):UJ.call(null,a),VJ.j?VJ.j(a):VJ.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null),new $APP.D(null,UJ,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,VJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=
$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,2,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],
null))],null))],null),TJ.j?TJ.j(a):TJ.call(null,a),$APP.y([UJ.j?UJ.j(a):UJ.call(null,a),VJ.j?VJ.j(a):VJ.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,UJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,VJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Fv,
$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,2,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null))],null))],null),TJ.j?TJ.j(a):TJ.call(null,
a),$APP.y([UJ.j?UJ.j(a):UJ.call(null,a),VJ.j?VJ.j(a):VJ.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,UJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null),new $APP.D(null,VJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,
2,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,-2,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null))],null))],null),TJ.j?
TJ.j(a):TJ.call(null,a),$APP.y([UJ.j?UJ.j(a):UJ.call(null,a),VJ.j?VJ.j(a):VJ.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,TJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null),new $APP.D(null,UJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,VJ,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=
$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,-2,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null)),2],null))],
null))],null))],null),TJ.j?TJ.j(a):TJ.call(null,a),$APP.y([UJ.j?UJ.j(a):UJ.call(null,a),VJ.j?VJ.j(a):VJ.call(null,a)]))))?a:dJ(a)})]))])),s1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,OJ,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,AT,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,
3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null))],null))],null),NJ.j?NJ.j(a):NJ.call(null,a),$APP.y([OJ.j?OJ.j(a):OJ.call(null,
a),AT.j?AT.j(a):AT.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,OJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,AT,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,
[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null))],null))],null),NJ.j?NJ.j(a):NJ.call(null,a),$APP.y([OJ.j?OJ.j(a):OJ.call(null,a),AT.j?AT.j(a):AT.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,
new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,OJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,AT,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,
a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null))],null))],null),NJ.j?NJ.j(a):NJ.call(null,a),$APP.y([OJ.j?OJ.j(a):OJ.call(null,a),AT.j?AT.j(a):AT.call(null,a)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,NJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,OJ,new $APP.D(null,new $APP.D(null,
kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,AT,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null))],null))],null),NJ.j?NJ.j(a):NJ.call(null,a),$APP.y([OJ.j?OJ.j(a):OJ.call(null,a),AT.j?AT.j(a):AT.call(null,a)]))))?a:dJ(a)})]))])),Qpc=function(){function a(b){var c=CF(b);return c?(c=TF.j(b),$APP.k(c)?1<b:c):c}return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,
a,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),g=$APP.I,l=$APP.r(new $APP.H(null,2,5,$APP.I,[kH,CJ.j?CJ.j(b):CJ.call(null,b)],null));var n=(b.j?b.j(AJ):b.call(null,AJ))-2;return(b=$APP.r(new $APP.H(null,4,5,c,[$APP.Ev,d,$APP.r(new $APP.H(null,3,5,g,[DJ,l,n],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,2,CJ.j?CJ.j(b):
CJ.call(null,b)],null))],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,a,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,2],null)),g=$APP.I,l=$APP.r(new $APP.H(null,2,5,$APP.I,[sH,CJ.j?CJ.j(b):CJ.call(null,b)],null));var n=(b.j?b.j(AJ):b.call(null,AJ))-2;
return(b=$APP.r(new $APP.H(null,4,5,c,[$APP.Ev,d,$APP.r(new $APP.H(null,3,5,g,[DJ,l,n],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,1,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,2,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null))],null))],null)))?b:dJ(b)})]))]))}(),q1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,
tJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){var b=$APP.I,c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[kH,CJ.j?CJ.j(a):CJ.call(null,a)],null));var g=(a.j?a.j(AJ):a.call(null,AJ))-2;return(a=$APP.r(new $APP.H(null,3,5,b,[$APP.Ev,$APP.r(new $APP.H(null,3,5,c,[DJ,d,g],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,CJ.j?CJ.j(a):CJ.call(null,a)],null)),2],null))],null))],null)))?a:dJ(a)})]))])),
Rpc=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,tJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){var b=$APP.I,c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[sH,CJ.j?CJ.j(a):CJ.call(null,a)],null));var g=(a.j?a.j(AJ):a.call(null,AJ))-2;return(a=$APP.r(new $APP.H(null,3,5,b,[$APP.Ev,$APP.r(new $APP.H(null,3,5,c,[DJ,d,g],
null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,CJ.j?CJ.j(a):CJ.call(null,a)],null)),2],null))],null))],null)))?a:dJ(a)})]))])),vZa=function(){function a(b){b=$APP.qe(b);var c=$APP.C.A(b,AJ);c=RF.A(c,2);c=$APP.k(sG.j(c))?b=$APP.r(new $APP.H(null,2,5,$APP.I,[qK.j?qK.j(b):qK.call(null,b),CJ.j?CJ.j(b):CJ.call(null,b)],null)):b=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[qK.j?qK.j(b):qK.call(null,
b),CJ.j?CJ.j(b):CJ.call(null,b)],null)),c],null));return c?c:dJ(b)}return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,bK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,new $APP.ug(null,new $APP.f(null,2,[kH,null,sH,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,KYa,null,1,null),2,null),
3,null),null,1,null),2,null),3,null),new $APP.D(null,cK,null,1,null),2,null),3,null),4,null),xJ),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),bK.j?bK.j(b):bK.call(null,b),$APP.y([new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[qK.j?qK.j(b):qK.call(null,b),CJ.j?CJ.j(b):CJ.call(null,b)],null)),2],null)),a(b)],null),cK.j?cK.j(b):cK.call(null,b)]))))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$APP.Fv,new $APP.D(null,tK,new $APP.D(null,
new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,qK,new $APP.D(null,new $APP.ug(null,new $APP.f(null,2,[kH,null,sH,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,KYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,uK,null,1,null),2,null),3,null),4,null),xJ),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Fv],
null),tK.j?tK.j(b):tK.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[qK.j?qK.j(b):qK.call(null,b),CJ.j?CJ.j(b):CJ.call(null,b)],null)),2],null)),a(b)],null))],null),uK.j?uK.j(b):uK.call(null,b)]))))?b:dJ(b)})]))]))}(),Spc=function(){var a=RF.j(nG);return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,a,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null))],null)),wG.A(0,2)],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,a,CJ.j?CJ.j(b):CJ.call(null,b)],null))],null))],null)),2],null)))?b:dJ(b)})]))]))}(),Tpc=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.Gv,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null))],null))],null)),iG.A(2,nG)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,CJ,null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null))],null))],null)),2],null)))?a:dJ(a)})]))])),Upc=function(){function a(c){c=AH.j(c.j?c.j(hT):c.call(null,hT));return $APP.k(qG.j(c))?new $APP.f(null,1,[mT,c],
null):null}function b(c){c=AH.j(c.j?c.j(hT):c.call(null,hT));var d=qG.j(c);d=$APP.k(d)?d:KF.j(c);return $APP.k($APP.eb(d))?new $APP.f(null,1,[mT,c],null):null}return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,hT,new $APP.D(null,rJ,null,1,null),2,null),3,null),null,1,null),2,null),b),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,mT.j?mT.j(c):mT.call(null,c)],null)),$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.Ev,nG,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,mT.j?mT.j(c):mT.call(null,c)],null))],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,hT,new $APP.D(null,rJ,null,1,null),2,null),3,null),null,1,null),2,null),a),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,function(d){return-(d.j?d.j(mT):d.call(null,mT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,RF.j(nG),$APP.r(new $APP.H(null,
2,5,$APP.I,[kH,function(d){return-(d.j?d.j(mT):d.call(null,mT))}(c)],null))],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,hT,new $APP.D(null,rJ,null,1,null),2,null),3,null),new $APP.D(null,wT,null,1,null),2,null),3,null),null,1,null),2,null),b),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,mT.j?
mT.j(c):mT.call(null,c)],null),wT.j?wT.j(c):wT.call(null,c)))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,mT.j?mT.j(c):mT.call(null,c)],null),wT.j?wT.j(c):wT.call(null,c)))],null))],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,hT,new $APP.D(null,rJ,null,1,null),2,null),3,null),new $APP.D(null,wT,null,
1,null),2,null),3,null),null,1,null),2,null),a),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,function(d){return xH.j(d.j?d.j(hT):d.call(null,hT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,function(d){return-(d.j?d.j(mT):d.call(null,mT))}(c)],null),wT.j?wT.j(c):wT.call(null,c)))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,RF.j(nG),$APP.r(new $APP.H(null,
2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,function(d){return-(d.j?d.j(mT):d.call(null,mT))}(c)],null),wT.j?wT.j(c):wT.call(null,c)))],null))],null))],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,hT,new $APP.D(null,sJ,null,1,null),2,null),3,null),null,1,null),2,null),b),function(c){var d=$APP.I,g=$APP.I;var l=xH.j(c.j?c.j(hT):c.call(null,hT));return(c=$APP.r(new $APP.H(null,3,5,d,[$APP.Ev,$APP.r(new $APP.H(null,2,5,
g,[zJ,l],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,mT.j?mT.j(c):mT.call(null,c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,mT.j?mT.j(c):mT.call(null,c)],null))],null))],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,hT,new $APP.D(null,sJ,null,1,null),2,null),3,null),null,1,null),2,null),a),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,
$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,function(d){return xH.j(d.j?d.j(hT):d.call(null,hT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,function(d){return-(d.j?d.j(mT):d.call(null,mT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,RF.j(nG),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,function(d){return-(d.j?d.j(mT):d.call(null,mT))}(c)],null))],null))],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,
new $APP.D(null,XI,new $APP.D(null,hT,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,wT,null,1,null),2,null),3,null),null,1,null),2,null),b),function(c){var d=$APP.I,g=$APP.I;var l=xH.j(c.j?c.j(hT):c.call(null,hT));return(c=$APP.r(new $APP.H(null,3,5,d,[$APP.Ev,$APP.r(new $APP.H(null,2,5,g,[zJ,l],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,mT.j?mT.j(c):mT.call(null,c)],null),wT.j?wT.j(c):
wT.call(null,c)))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,mT.j?mT.j(c):mT.call(null,c)],null),wT.j?wT.j(c):wT.call(null,c)))],null))],null))],null))],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,hT,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,wT,null,1,null),2,null),3,null),null,1,null),
2,null),a),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,function(d){return xH.j(d.j?d.j(hT):d.call(null,hT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,function(d){return-(d.j?d.j(mT):d.call(null,mT))}(c)],null),wT.j?wT.j(c):wT.call(null,c)))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,RF.j(nG),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,$APP.r($APP.N.A(new $APP.H(null,
2,5,$APP.I,[$APP.Ev,function(d){return-(d.j?d.j(mT):d.call(null,mT))}(c)],null),wT.j?wT.j(c):wT.call(null,c)))],null))],null))],null))],null)))?c:dJ(c)})]))]))}(),w1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,XJ,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,YJ,null,1,null),2,null),new $APP.D(null,ZJ,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,$J,null,1,null),2,null),new $APP.D(null,aK,null,1,null),2,null),3,null),4,null),5,null),6,null),xJ),function(a){return(a=
$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),XJ.j?XJ.j(a):XJ.call(null,a),$APP.y([ZJ.j?ZJ.j(a):ZJ.call(null,a),aK.j?aK.j(a):aK.call(null,a),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,YJ.j?YJ.j(a):YJ.call(null,a),$J.j?$J.j(a):$J.call(null,a)],null))],null))],null)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,pzb,null,1,null),2,null),
3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,pzb.j?pzb.j(a):pzb.call(null,a),CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,
5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,XJ,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,dK,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,JJ,null,1,null),2,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],
null),XJ.j?XJ.j(a):XJ.call(null,a),$APP.y([dK.j?dK.j(a):dK.call(null,a),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null))],null)]))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,EY,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,JJ,null,
1,null),2,null),new $APP.D(null,FY,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null)),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),EY.j?EY.j(a):EY.call(null,a),$APP.y([FY.j?FY.j(a):FY.call(null,a)])))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,
new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,XJ,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,dK,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,EY,new $APP.D(null,new $APP.D(null,zJ,new $APP.D(null,JJ,null,1,null),2,null),new $APP.D(null,FY,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r($APP.N.C(new $APP.H(null,
1,5,$APP.I,[$APP.Ev],null),XJ.j?XJ.j(a):XJ.call(null,a),$APP.y([dK.j?dK.j(a):dK.call(null,a),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,CJ.j?CJ.j(a):CJ.call(null,a),JJ.j?JJ.j(a):JJ.call(null,a)],null))],null))],null)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),EY.j?EY.j(a):EY.call(null,a),$APP.y([FY.j?FY.j(a):FY.call(null,a)])))],null)))?a:dJ(a)})]))])),u1a=function(){function a(b){var c=CF(b);return c?TF.j(b):c}
return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Gv,new $APP.D(null,mY,null,1,null),2,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,mY.j?mY.j(b):mY.call(null,b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Gv,new $APP.D(null,mY,new $APP.D(null,YJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,mY.j?mY.j(b):mY.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,YJ.j?YJ.j(b):YJ.call(null,b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Fv,new $APP.D(null,mY,new $APP.D(null,YJ,new $APP.D(null,wJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,mY.j?
mY.j(b):mY.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Fv,YJ.j?YJ.j(b):YJ.call(null,b)],null),wJ.j?wJ.j(b):wJ.call(null,b)))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,CJ,new $APP.D(null,DYa,new $APP.D(null,function(b){return 1<AH.j(b)},null,1,null),2,null),3,null),4,null),new $APP.D(null,ZV,null,1,null),2,null),3,null),null,1,null),
2,null),xJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,nG],null),ZV.j?ZV.j(b):ZV.call(null,b)))],null));b=AH.j(b.j?b.j(CJ):b.call(null,CJ));return(c=$APP.r(new $APP.H(null,3,5,c,[DJ,d,b],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,CJ,new $APP.D(null,DYa,new $APP.D(null,function(b){return-1>AH.j(b)},null,1,null),2,null),3,null),4,null),
new $APP.D(null,ZV,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,RF.j(nG)],null),ZV.j?ZV.j(b):ZV.call(null,b)))],null));b=RF.j(AH.j(b.j?b.j(CJ):b.call(null,CJ)));return(c=$APP.r(new $APP.H(null,3,5,c,[DJ,d,b],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,a,new $APP.D(null,
function(b){return 1<b},null,1,null),2,null),3,null),4,null),new $APP.D(null,ZV,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),ZV.j?ZV.j(b):ZV.call(null,b)))],null)),AJ.j?AJ.j(b):AJ.call(null,b)],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,
a,new $APP.D(null,function(b){return-1>b},null,1,null),2,null),3,null),4,null),new $APP.D(null,ZV,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,-1],null),ZV.j?ZV.j(b):ZV.call(null,b)))],null));b=-(b.j?b.j(AJ):b.call(null,AJ));return(c=$APP.r(new $APP.H(null,3,5,c,[DJ,d,b],null)))?c:dJ(c)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,CJ,new $APP.D(null,
sJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,function(c){return xH.j(c.j?c.j(CJ):c.call(null,CJ))}(b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,function(c){return iG.A(AH.j(c.j?c.j(CJ):c.call(null,CJ)),$APP.te.$a.j?$APP.te.$a.j(nG):$APP.te.$a.call(null,nG))}(b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,zJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,
XI,new $APP.D(null,CJ,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,ZV,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,function(c){return xH.j(c.j?c.j(CJ):c.call(null,CJ))}(b)],null),ZV.j?ZV.j(b):ZV.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,function(c){return iG.A(AH.j(c.j?
c.j(CJ):c.call(null,CJ)),$APP.te.$a.j?$APP.te.$a.j(nG):$APP.te.$a.call(null,nG))}(b)],null),ZV.j?ZV.j(b):ZV.call(null,b)))],null))],null)))?b:dJ(b)})]))]))}(),n1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,nG,null,1,null),2,null),xJ),function(){var a=$APP.r(new $APP.H(null,2,5,$APP.I,[uH,1],null));return a?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,RU,new $APP.D(null,nG,null,1,null),2,null),3,null),null,1,null),2,null),xJ),
function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[uH,RU.j?RU.j(a):RU.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,nG,new $APP.D(null,RU,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[uH,RU.j?RU.j(a):RU.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,wJ,new $APP.D(null,nG,new $APP.D(null,SJ,null,
1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),wJ.j?wJ.j(a):wJ.call(null,a),$APP.y([SJ.j?SJ.j(a):SJ.call(null,a)])))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,nG,null,1,null),2,null),xJ),function(){var a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,$APP.r(new $APP.H(null,2,5,$APP.I,[wH,1],null))],null));return a?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,
new $APP.D(null,$APP.Ev,new $APP.D(null,RU,new $APP.D(null,nG,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,$APP.r(new $APP.H(null,2,5,$APP.I,[wH,RU.j?RU.j(a):RU.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,nG,new $APP.D(null,RU,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,
$APP.r(new $APP.H(null,2,5,$APP.I,[wH,RU.j?RU.j(a):RU.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,wJ,new $APP.D(null,nG,new $APP.D(null,SJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,$APP.r(new $APP.H(null,2,5,$APP.I,[wH,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),wJ.j?wJ.j(a):wJ.call(null,a),$APP.y([SJ.j?SJ.j(a):SJ.call(null,
a)])))],null))],null)))?a:dJ(a)})]))])),Vpc=function(){var a=$APP.M(XI,qK,new $APP.ug(null,new $APP.f(null,2,[PV,"null",dY,"null"],null),null));return yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,a,new $APP.D(null,new $APP.D(null,sH,new $APP.D(null,mS,null,1,null),2,null),new $APP.D(null,new $APP.D(null,kH,new $APP.D(null,mS,null,1,null),2,null),null,1,null),2,null),3,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[zJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,nG,mS.j?mS.j(b):
mS.call(null,b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$T,new $APP.D(null,new $APP.D(null,a,new $APP.D(null,hY,new $APP.D(null,$APP.Hv,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){b=hY.j?hY.j(b):hY.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,hV,new $APP.D(null,new $APP.D(null,a,new $APP.D(null,$APP.Hv,new $APP.D(null,mT,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){b=mT.j?mT.j(b):mT.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,
AK,new $APP.D(null,new $APP.D(null,a,new $APP.D(null,hY,new $APP.D(null,mT,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,hY.j?hY.j(b):hY.call(null,b),2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,mT.j?mT.j(b):mT.call(null,b),2],null))],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,CY,new $APP.D(null,new $APP.D(null,a,new $APP.D(null,hY,new $APP.D(null,
mT,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[hK,mT.j?mT.j(b):mT.call(null,b),hY.j?hY.j(b):hY.call(null,b)],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,$T,new $APP.D(null,new $APP.D(null,DT,new $APP.D(null,OU,new $APP.D(null,GJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,OU.j?OU.j(b):OU.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[sH,GJ.j?GJ.j(b):GJ.call(null,
b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,hV,new $APP.D(null,new $APP.D(null,DT,new $APP.D(null,OU,new $APP.D(null,GJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,OU.j?OU.j(b):OU.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[kH,GJ.j?GJ.j(b):GJ.call(null,b)],null))],null)))?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,AK,new $APP.D(null,new $APP.D(null,DT,new $APP.D(null,OU,new $APP.D(null,$APP.Hv,null,1,null),2,null),3,null),
null,1,null),2,null),xJ),function(b){b=OU.j?OU.j(b):OU.call(null,b);return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,CY,new $APP.D(null,new $APP.D(null,DT,new $APP.D(null,$APP.Hv,new $APP.D(null,GJ,null,1,null),2,null),3,null),null,1,null),2,null),xJ),function(b){b=GJ.j?GJ.j(b):GJ.call(null,b);return $APP.k(b)?b:dJ(b)})]))]))}(),i1a=yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,1,new $APP.D(null,fS,null,1,null),2,null),3,null),xJ),function(a){a=fS.j?fS.j(a):fS.call(null,
a);return $APP.k(a)?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,1,new $APP.D(null,ZV,null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),ZV.j?ZV.j(a):ZV.call(null,a))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,EF,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,NU,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),
2,null),3,null),xJ),function(a){var b=$APP.qe(a);a=$APP.C.A(b,AJ);b=$APP.C.A(b,NU);a=QF.A(a,b);return $APP.k(a)?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Fv,new $APP.D(null,NKb,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,NU,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Fv],null),function(b){return $APP.Vg.A(function(c){return(c=$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.rj,c,NU.j?NU.j(b):NU.call(null,b)],null)))?c:dJ(c)},b.j?b.j(NKb):b.call(null,NKb))}(a))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,AJ,new $APP.D(null,EF,null,1,null),2,null),3,null),new $APP.D(null,ZV,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,NU,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){var b=$APP.N.A,
c=$APP.I,d=$APP.qe(a);var g=$APP.C.A(d,AJ);d=$APP.C.A(d,NU);g=QF.A(g,d);return(a=$APP.r(b.call($APP.N,new $APP.H(null,2,5,c,[$APP.Ev,g],null),ZV.j?ZV.j(a):ZV.call(null,a))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,ZV,null,1,null),2,null),new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,NU,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){var b=$APP.N.A,c=$APP.I;var d=OF.j(a.j?a.j(NU):a.call(null,
NU));return(a=$APP.r(b.call($APP.N,new $APP.H(null,2,5,c,[$APP.Ev,d],null),ZV.j?ZV.j(a):ZV.call(null,a))))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,AJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,NU,new $APP.D(null,EF,null,1,null),2,null),3,null),new $APP.D(null,fS,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,AJ.j?
AJ.j(a):AJ.call(null,a),NU.j?NU.j(a):NU.call(null,a)],null)),fS.j?fS.j(a):fS.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,AJ,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,NU,new $APP.D(null,EF,null,1,null),2,null),3,null),new $APP.D(null,ZV,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,AJ.j?AJ.j(a):
AJ.call(null,a),NU.j?NU.j(a):NU.call(null,a)],null)),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),ZV.j?ZV.j(a):ZV.call(null,a)))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.rj,new $APP.D(null,AJ,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,NU,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),xJ),function(a){var b=$APP.I;var c=OF.j(a.j?a.j(NU):a.call(null,NU));return(a=$APP.r(new $APP.H(null,3,5,b,[$APP.Ev,c,AJ.j?AJ.j(a):AJ.call(null,a)],null)))?a:
dJ(a)})]))]));var Wpc=yJ.C($APP.y([$1.C($APP.y([$APP.Fv,$APP.Ev])),Kpc,Z1.C($APP.y([$APP.Fv,$APP.Ev]))]));$APP.e=BK.prototype;$APP.e.rb=function(){return MK.j(this.context)};$APP.e.bc=function(){return this.arity};$APP.e.ac=function(a,b,c){return new BK(FH(this.o,b,c),this.arity,this.name,this.context,this.ca)};$APP.e.$b=function(a,b,c){return new BK(GH(this.o,b,c),this.arity,this.name,this.context,this.ca)};$APP.e.ic=function(a,b){return new BK(HH(this.o,b),this.arity,this.name,this.context,this.ca)};
$APP.e.toString=function(){var a=aG.j(this);return $APP.m.j($APP.ud(a)?$APP.r(a):a)};$APP.e.ba=function(){return this.ca};$APP.e.da=function(a,b){return new BK(this.o,this.arity,this.name,this.context,b)};$APP.e.Ka=function(a,b){return AZa.A?AZa.A(this,b):AZa.call(null,this,b)};$APP.e.fa=function(){return AD("Operators don't support the not-found arity of get!")};
$APP.e.call=function(a){switch(arguments.length-1){case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.M(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);case 11:return this.xa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13]);
case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],arguments[2],arguments[3],arguments[4],
arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],
arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Lb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],
arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.j=function(a){return this.o.j?this.o.j(a):this.o.call(null,a)};$APP.e.A=function(a,b){return this.o.A?this.o.A(a,b):this.o.call(null,a,b)};$APP.e.B=function(a,b,c){return this.o.B?this.o.B(a,b,c):this.o.call(null,a,b,c)};
$APP.e.M=function(a,b,c,d){return this.o.M?this.o.M(a,b,c,d):this.o.call(null,a,b,c,d)};$APP.e.S=function(a,b,c,d,g){return this.o.S?this.o.S(a,b,c,d,g):this.o.call(null,a,b,c,d,g)};$APP.e.la=function(a,b,c,d,g,l){return this.o.la?this.o.la(a,b,c,d,g,l):this.o.call(null,a,b,c,d,g,l)};$APP.e.Ga=function(a,b,c,d,g,l,n){return this.o.Ga?this.o.Ga(a,b,c,d,g,l,n):this.o.call(null,a,b,c,d,g,l,n)};
$APP.e.va=function(a,b,c,d,g,l,n,p){return this.o.va?this.o.va(a,b,c,d,g,l,n,p):this.o.call(null,a,b,c,d,g,l,n,p)};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){return this.o.Ha?this.o.Ha(a,b,c,d,g,l,n,p,v):this.o.call(null,a,b,c,d,g,l,n,p,v)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){return this.o.wa?this.o.wa(a,b,c,d,g,l,n,p,v,t):this.o.call(null,a,b,c,d,g,l,n,p,v,t)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){return this.o.xa?this.o.xa(a,b,c,d,g,l,n,p,v,t,A):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){return this.o.ya?this.o.ya(a,b,c,d,g,l,n,p,v,t,A,B):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){return this.o.za?this.o.za(a,b,c,d,g,l,n,p,v,t,A,B,G):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){return this.o.Aa?this.o.Aa(a,b,c,d,g,l,n,p,v,t,A,B,G,J):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){return this.o.Ba?this.o.Ba(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q){return this.o.Ca?this.o.Ca(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q)};$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W){return this.o.Da?this.o.Da(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W)};
$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z){return this.o.Ea?this.o.Ea(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z)};$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa){return this.o.Fa?this.o.Fa(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa)};
$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha){return this.o.La?this.o.La(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha)};$APP.e.Lb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja){return $APP.Je.C(this.o,a,b,c,d,$APP.y([g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja]))};$APP.e.Oa=$APP.xc;$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};
var JK=function JK(a){switch(arguments.length){case 1:return JK.j(arguments[0]);case 2:return JK.A(arguments[0],arguments[1]);case 3:return JK.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};JK.j=function(a){return JK.B(a,knb,$APP.F)};JK.A=function(a,b){return JK.B(a,b,$APP.F)};JK.B=function(a,b,c){return CK(a,XH.A(c,SH(a)),b,$APP.Lf.A(new $APP.f(null,1,[MK,EW],null),c),null)};JK.G=3;
var Xpc=JK.A($APP.Kd,$APP.Cx),c2=function c2(a){switch(arguments.length){case 0:return c2.J();case 1:return c2.j(arguments[0]);case 2:return c2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};c2.J=function(){return Xpc};c2.j=function(a){return a};
c2.A=function(a,b){var c=BZa(a,b);return $APP.k(iZ.j(a))?IK(b,c):$APP.k(iZ.j(b))?IK(a,c):$APP.k(KF.j(a))?IK(a,c):CK(WH.C($APP.y([a,b])),FK(b),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Ev,null,1,null),new $APP.D(null,GK(a),null,1,null),$APP.y([new $APP.D(null,GK(b),null,1,null)])))),c,null)};c2.G=2;
var d2=function d2(a){switch(arguments.length){case 1:return d2.j(arguments[0]);case 2:return d2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};d2.j=function(a){return LZa(a)};d2.A=function(a,b){return CK(RXa(OK.j?OK.j(a):OK.call(null,a),b),new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.T.j($APP.r($APP.N.A(new $APP.D(null,zJ,null,1,null),new $APP.D(null,GK(a),null,1,null)))),HK(a),$APP.ed(a))};d2.G=2;$APP.hu.A(FF,KV);$APP.hu.A(TH,KV);
for(var e2=$APP.r(new $APP.H(null,14,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[oG,OK,zJ],null),new $APP.H(null,3,5,$APP.I,[fO,m1,sH],null),new $APP.H(null,3,5,$APP.I,[gO,l1,kH],null),new $APP.H(null,3,5,$APP.I,[tZ,n1,lK],null),new $APP.H(null,3,5,$APP.I,[wZ,o1,LM],null),new $APP.H(null,3,5,$APP.I,[kO,q1,kK],null),new $APP.H(null,3,5,$APP.I,[xZ,p1,jK],null),new $APP.H(null,3,5,$APP.I,[rG,r1,hK],null),new $APP.H(null,3,5,$APP.I,[yZ,s1,XS],null),new $APP.H(null,3,5,$APP.I,[tH,u1,uH],null),new $APP.H(null,
3,5,$APP.I,[vH,t1,wH],null),new $APP.H(null,3,5,$APP.I,[BZ,v1,oX],null),new $APP.H(null,3,5,$APP.I,[GZ,w1,fW],null),new $APP.H(null,3,5,$APP.I,[HZ,x1,FV],null)],null)),f2=null,g2=0,h2=0;;)if(h2<g2){var Ypc=f2.aa(null,h2),Zpc=$APP.x.B(Ypc,0,null),$pc=$APP.x.B(Ypc,1,null),aqc=$APP.x.B(Ypc,2,null),bqc=["g/",$APP.m.j(aqc)," :emmy.operator/operator"].join("");Zpc.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a,b,c,d,g,l,n,p,v){return function(t){return CK(p.j?p.j(t):p.call(null,t),new $APP.H(null,
2,5,$APP.I,[fI,1],null),$APP.T.j($APP.r($APP.N.A(new $APP.D(null,v,null,1,null),new $APP.D(null,GK(t),null,1,null)))),HK(t),null)}}(e2,f2,g2,h2,bqc,Ypc,Zpc,$pc,aqc));h2+=1}else{var cqc=$APP.r(e2);if(cqc){var i2=cqc;if($APP.pd(i2)){var dqc=$APP.lc(i2),eqc=$APP.mc(i2),fqc=dqc,gqc=$APP.Tc(dqc);e2=eqc;f2=fqc;g2=gqc}else{var hqc=$APP.u(i2),iqc=$APP.x.B(hqc,0,null),jqc=$APP.x.B(hqc,1,null),kqc=$APP.x.B(hqc,2,null),lqc=["g/",$APP.m.j(kqc)," :emmy.operator/operator"].join("");iqc.F(null,new $APP.H(null,1,
5,$APP.I,[EW],null),function(a,b,c,d,g,l,n,p,v){return function(t){return CK(p.j?p.j(t):p.call(null,t),new $APP.H(null,2,5,$APP.I,[fI,1],null),$APP.T.j($APP.r($APP.N.A(new $APP.D(null,v,null,1,null),new $APP.D(null,GK(t),null,1,null)))),HK(t),null)}}(e2,f2,g2,h2,lqc,hqc,iqc,jqc,kqc,i2,cqc));e2=$APP.w(i2);f2=null;g2=0}h2=0}else break}KF.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){var b=$APP.c4a.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):$APP.Uc.A(a.o,tG)});
sG.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){var b=Uzb.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):!1});iZ.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){var b=Seb.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):$APP.Uc.A(a.o,$APP.Kd)});tG.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){var b=HWa.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):new BK(tG,a.arity,YDb,a.context,a.ca)});
NF.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){var b=JWa.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):new BK($APP.Kd,a.arity,$APP.Cx,a.context,a.ca)});jZ.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){var b=APb.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):new BK($APP.Kd,a.arity,$APP.Cx,a.context,a.ca)});aG.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){a=aG.j(a.name);return Wpc.j?Wpc.j(a):Wpc.call(null,a)});
eH.F(null,new $APP.H(null,2,5,$APP.I,[EW,EW],null),function(a,b){return GZa(a,b)});eH.F(null,new $APP.H(null,2,5,$APP.I,[EW,KV],null),function(a,b){return DZa(eH,$APP.Fv,a,b)});eH.F(null,new $APP.H(null,2,5,$APP.I,[KV,EW],null),function(a,b){return CZa(eH,$APP.Fv,a,b)});PF.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){return EZa(a)});yG.F(null,new $APP.H(null,2,5,$APP.I,[EW,EW],null),function(a,b){return FZa(a,b)});
yG.F(null,new $APP.H(null,2,5,$APP.I,[EW,KV],null),function(a,b){return DZa(yG,$APP.Gv,a,b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[KV,EW],null),function(a,b){return CZa(yG,$APP.Gv,a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[EW,EW],null),function(a,b){return c2.A(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[EW,KV],null),function(a,b){return IZa(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[KV,EW],null),function(a,b){return HZa(a,b)});
lG.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){return c2.A(a,a)});oZ.F(null,new $APP.H(null,1,5,$APP.I,[EW],null),function(a){return c2.A(a,c2.A(a,a))});rI.F(null,new $APP.H(null,2,5,$APP.I,[EW,GY],null),function(a,b){return $APP.Id.A(c2,$APP.Uj.A(b,a))});zG.F(null,new $APP.H(null,2,5,$APP.I,[EW,FF],null),function(a,b){return JZa(a,b)});cR.F(null,new $APP.H(null,2,5,$APP.I,[EW,FF],null),function(a,b){return JZa(a,b)});
VF.F(null,new $APP.H(null,2,5,$APP.I,[FF,EW],null),function(a,b){return JZa(b,a)});var j2=new $APP.f(null,2,[SK,xP,XK,wP],null),dL=new $APP.f(null,2,[SK,"",XK,"_"],null),zP=new $APP.f(null,2,[SK,XK,XK,SK],null);$APP.hu.A(SK,aS);$APP.hu.A(XK,aS);$APP.hu.A($APP.H,SK);$APP.hu.A(Array,SK);$APP.hu.A(aS,jI);$APP.hu.A(aS,KV);var k2=function k2(a){switch(arguments.length){case 1:return k2.j(arguments[0]);case 2:return k2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};k2.j=function(a){return $APP.Vg.A($APP.Pi.A(MZa,a),$APP.Hj.J())};
k2.A=function(a,b){return $APP.We.A(a,k2.j(b))};k2.G=2;$APP.e=PK.prototype;$APP.e.Hc=$APP.xc;$APP.e.Ac=function(a,b){return $APP.wb(this.v,b)};$APP.e.toString=function(){return["(",$APP.m.j(this.orientation.j?this.orientation.j(j2):this.orientation.call(null,j2))," ",$APP.Il.A(" ",$APP.Vg.A($APP.jh,this.v)),")"].join("")};$APP.e.Ka=function(a,b){return $APP.Ms(this.v,b)};$APP.e.fa=function(a,b,c){return $APP.Ms(this.v,b,c)};$APP.e.lb=function(a,b,c){return $APP.Jb(this.v,b,c)};
$APP.e.aa=function(a,b){return $APP.bd(this.v,b)};$APP.e.eb=function(a,b,c){return $APP.bd(this.v,b,c)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};$APP.e.Qa=function(){return $APP.qc(this.v)};$APP.e.ba=function(){return this.ca};$APP.e.ta=function(){return $APP.lb(this.v)};$APP.e.Ic=function(){return $APP.Qb(this.v)};$APP.e.Y=function(a,b){return OZa.A?OZa.A(this,b):OZa.call(null,this,b)};$APP.e.Sa=function(){return new PK(this.orientation,$APP.sf,this.ca)};
$APP.e.fb=function(a,b){return $APP.Ns(this.v,b)};$APP.e.bb=function(a,b,c){return $APP.Ns(this.v,b,c)};$APP.e.rb=function(){return this.orientation};$APP.e.bc=function(){return NWa(this.v)};$APP.e.sa=function(a,b,c){return new PK(this.orientation,$APP.vb(this.v,b,c),this.ca)};$APP.e.Va=function(a,b){return $APP.ub(this.v,b)};$APP.e.ma=function(){return $APP.Mb(this.v)};$APP.e.da=function(a,b){return new PK(this.orientation,this.v,b)};
$APP.e.ua=function(a,b){return new PK(this.orientation,$APP.nb(this.v,b),this.ca)};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.M(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Lb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){return new PK(this.orientation,$APP.Fl.A(function(a){return a.J?a.J():a.call(null)},this.v),this.ca)};$APP.e.j=function(a){return new PK(this.orientation,$APP.Fl.A(function(b){return b.j?b.j(a):b.call(null,a)},this.v),this.ca)};
$APP.e.A=function(a,b){return new PK(this.orientation,$APP.Fl.A(function(c){return c.A?c.A(a,b):c.call(null,a,b)},this.v),this.ca)};$APP.e.B=function(a,b,c){return new PK(this.orientation,$APP.Fl.A(function(d){return d.B?d.B(a,b,c):d.call(null,a,b,c)},this.v),this.ca)};$APP.e.M=function(a,b,c,d){return new PK(this.orientation,$APP.Fl.A(function(g){return g.M?g.M(a,b,c,d):g.call(null,a,b,c,d)},this.v),this.ca)};
$APP.e.S=function(a,b,c,d,g){return new PK(this.orientation,$APP.Fl.A(function(l){return l.S?l.S(a,b,c,d,g):l.call(null,a,b,c,d,g)},this.v),this.ca)};$APP.e.la=function(a,b,c,d,g,l){return new PK(this.orientation,$APP.Fl.A(function(n){return n.la?n.la(a,b,c,d,g,l):n.call(null,a,b,c,d,g,l)},this.v),this.ca)};$APP.e.Ga=function(a,b,c,d,g,l,n){return new PK(this.orientation,$APP.Fl.A(function(p){return p.Ga?p.Ga(a,b,c,d,g,l,n):p.call(null,a,b,c,d,g,l,n)},this.v),this.ca)};
$APP.e.va=function(a,b,c,d,g,l,n,p){return new PK(this.orientation,$APP.Fl.A(function(v){return v.va?v.va(a,b,c,d,g,l,n,p):v.call(null,a,b,c,d,g,l,n,p)},this.v),this.ca)};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){return new PK(this.orientation,$APP.Fl.A(function(t){return t.Ha?t.Ha(a,b,c,d,g,l,n,p,v):t.call(null,a,b,c,d,g,l,n,p,v)},this.v),this.ca)};
$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){return new PK(this.orientation,$APP.Fl.A(function(A){return A.wa?A.wa(a,b,c,d,g,l,n,p,v,t):A.call(null,a,b,c,d,g,l,n,p,v,t)},this.v),this.ca)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){return new PK(this.orientation,$APP.Fl.A(function(B){return B.xa?B.xa(a,b,c,d,g,l,n,p,v,t,A):B.call(null,a,b,c,d,g,l,n,p,v,t,A)},this.v),this.ca)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){return new PK(this.orientation,$APP.Fl.A(function(G){return G.ya?G.ya(a,b,c,d,g,l,n,p,v,t,A,B):G.call(null,a,b,c,d,g,l,n,p,v,t,A,B)},this.v),this.ca)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){return new PK(this.orientation,$APP.Fl.A(function(J){return J.za?J.za(a,b,c,d,g,l,n,p,v,t,A,B,G):J.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G)},this.v),this.ca)};
$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){return new PK(this.orientation,$APP.Fl.A(function(O){return O.Aa?O.Aa(a,b,c,d,g,l,n,p,v,t,A,B,G,J):O.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J)},this.v),this.ca)};$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){return new PK(this.orientation,$APP.Fl.A(function(Q){return Q.Ba?Q.Ba(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O):Q.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O)},this.v),this.ca)};
$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q){return new PK(this.orientation,$APP.Fl.A(function(W){return W.Ca?W.Ca(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q):W.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q)},this.v),this.ca)};$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W){return new PK(this.orientation,$APP.Fl.A(function(Z){return Z.Da?Z.Da(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W):Z.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W)},this.v),this.ca)};
$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z){return new PK(this.orientation,$APP.Fl.A(function(fa){return fa.Ea?fa.Ea(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z):fa.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z)},this.v),this.ca)};$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa){return new PK(this.orientation,$APP.Fl.A(function(ha){return ha.Fa?ha.Fa(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa):ha.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa)},this.v),this.ca)};
$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha){return new PK(this.orientation,$APP.Fl.A(function(ja){return ja.La?ja.La(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha):ja.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha)},this.v),this.ca)};$APP.e.Lb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja){return new PK(this.orientation,$APP.Fl.A(function(ta){return $APP.Je.C(ta,a,b,c,d,$APP.y([g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja]))},this.v),this.ca)};
$APP.e.ac=function(a,b,c){function d(g){return FH(g,b,c)}return kL.A?kL.A(d,this):kL.call(null,d,this)};$APP.e.$b=function(a,b,c){function d(g){return GH(g,b,c)}return kL.A?kL.A(d,this):kL.call(null,d,this)};$APP.e.ic=function(a,b){function c(d){return HH(d,b)}return kL.A?kL.A(c,this):kL.call(null,c,this)};PK.prototype[$APP.Cc]=function(){return $APP.Hc(this)};PK.prototype.map=function(a){return kL.A?kL.A(a,this):kL.call(null,a,this)};PK.prototype.at=function(a){return $APP.x.A(this.v,a)};
var rP=function rP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return rP.C(c)};rP.C=function(a){return function(b){return $APP.Zl.A(b,a)}};rP.G=0;rP.K=function(a){return this.C($APP.r(a))};fG.F(null,new $APP.H(null,2,5,$APP.I,[XK,SK],null),function(){return!1});fG.F(null,new $APP.H(null,2,5,$APP.I,[SK,XK],null),function(){return!1});fG.F(null,new $APP.H(null,2,5,$APP.I,[XK,YR],null),function(){return!1});
fG.F(null,new $APP.H(null,2,5,$APP.I,[YR,XK],null),function(){return!1});$APP.qda(fG,new $APP.H(null,2,5,$APP.I,[SK,XK],null),new $APP.H(null,2,5,$APP.I,[YR,XK],null));$APP.qda(fG,new $APP.H(null,2,5,$APP.I,[XK,SK],null),new $APP.H(null,2,5,$APP.I,[XK,YR],null));
for(var l2=$APP.r(new $APP.H(null,2,5,$APP.I,[SK,XK],null)),m2=null,n2=0,o2=0;;)if(o2<n2){var p2=m2.aa(null,o2);KF.F(null,new $APP.H(null,1,5,$APP.I,[p2],null),function(){return function(a){return $APP.Ge(KF,a)}}(l2,m2,n2,o2,p2));sG.F(null,new $APP.H(null,1,5,$APP.I,[p2],null),function(){return function(){return!1}}(l2,m2,n2,o2,p2));iZ.F(null,new $APP.H(null,1,5,$APP.I,[p2],null),function(){return function(){return!1}}(l2,m2,n2,o2,p2));tG.F(null,new $APP.H(null,1,5,$APP.I,[p2],null),function(){return function(a){return new PK(a.orientation,
tG.j(a.v),a.ca)}}(l2,m2,n2,o2,p2));NF.F(null,new $APP.H(null,1,5,$APP.I,[p2],null),function(){return function(){return 1}}(l2,m2,n2,o2,p2));jZ.F(null,new $APP.H(null,1,5,$APP.I,[p2],null),function(){return function(){return 1}}(l2,m2,n2,o2,p2));TF.F(null,new $APP.H(null,1,5,$APP.I,[p2],null),function(){return function(a){return $APP.Ge(TF,a.v)}}(l2,m2,n2,o2,p2));aG.F(null,new $APP.H(null,1,5,$APP.I,[p2],null),function(){return function(a){var b=$APP.T.j,c=$APP.N.A;var d=a.orientation;d=d.j?d.j(j2):
d.call(null,j2);return b.call($APP.T,$APP.r(c.call($APP.N,new $APP.D(null,d,null,1,null),$APP.Vg.A(aG,a.v))))}}(l2,m2,n2,o2,p2));o2+=1}else{var q2=$APP.r(l2);if(q2){var r2=q2;if($APP.pd(r2)){var mqc=$APP.lc(r2),nqc=$APP.mc(r2),oqc=mqc,pqc=$APP.Tc(mqc);l2=nqc;m2=oqc;n2=pqc}else{var s2=$APP.u(r2);KF.F(null,new $APP.H(null,1,5,$APP.I,[s2],null),function(){return function(a){return $APP.Ge(KF,a)}}(l2,m2,n2,o2,s2,r2,q2));sG.F(null,new $APP.H(null,1,5,$APP.I,[s2],null),function(){return function(){return!1}}(l2,
m2,n2,o2,s2,r2,q2));iZ.F(null,new $APP.H(null,1,5,$APP.I,[s2],null),function(){return function(){return!1}}(l2,m2,n2,o2,s2,r2,q2));tG.F(null,new $APP.H(null,1,5,$APP.I,[s2],null),function(){return function(a){return new PK(a.orientation,tG.j(a.v),a.ca)}}(l2,m2,n2,o2,s2,r2,q2));NF.F(null,new $APP.H(null,1,5,$APP.I,[s2],null),function(){return function(){return 1}}(l2,m2,n2,o2,s2,r2,q2));jZ.F(null,new $APP.H(null,1,5,$APP.I,[s2],null),function(){return function(){return 1}}(l2,m2,n2,o2,s2,r2,q2));TF.F(null,
new $APP.H(null,1,5,$APP.I,[s2],null),function(){return function(a){return $APP.Ge(TF,a.v)}}(l2,m2,n2,o2,s2,r2,q2));aG.F(null,new $APP.H(null,1,5,$APP.I,[s2],null),function(){return function(a){var b=$APP.T.j,c=$APP.N.A;var d=a.orientation;d=d.j?d.j(j2):d.call(null,j2);return b.call($APP.T,$APP.r(c.call($APP.N,new $APP.D(null,d,null,1,null),$APP.Vg.A(aG,a.v))))}}(l2,m2,n2,o2,s2,r2,q2));l2=$APP.w(r2);m2=null;n2=0}o2=0}else break}
var qqc=WZa(XK,XK),rqc=WZa(SK,SK),sqc=WZa(SK,XK),tqc=WZa(XK,SK),uL=function uL(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return uL.C(c)};uL.C=function(a){return $K(a)};uL.G=0;uL.K=function(a){return this.C($APP.r(a))};var QN=function QN(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return QN.C(c)};
QN.C=function(a){return ZK(XK,a)};QN.G=0;QN.K=function(a){return this.C($APP.r(a))};var t2=function t2(a){switch(arguments.length){case 1:return t2.j(arguments[0]);case 2:return t2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};t2.j=function(a){return VK(a)?t2.A(a,RK(a)):a};t2.A=function(a,b){a=TK(a);a=zP.j?zP.j(a):zP.call(null,a);return ZK(a,b)};t2.G=2;
var u2=function u2(a,b){return $Za(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return VK($APP.u(l))?u2.A?u2.A(a,l):u2.call(null,a,l):$APP.Je.A(a,l)}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),b)},oP=function oP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),
0,null):null;return oP.C(arguments[0],c)};oP.C=function(a,b){return u2(a,b)};oP.G=1;oP.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var YN=function YN(a){switch(arguments.length){case 2:return YN.A(arguments[0],arguments[1]);case 3:return YN.B(arguments[0],arguments[1],arguments[2]);case 4:return YN.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
YN.A=function(a,b){return YN.M(a,a.J?a.J():a.call(null),a,b)};YN.B=function(a,b,c){return YN.M(a,b,a,c)};YN.M=function(a,b,c,d){b=function t(l,n,p,v){if(VK(n)){var A=TK(n);return $APP.Id.B(function(G,J){return t(G,NZa(n,J),$APP.Vd.A(p,J),$APP.Vd.A(v,A))},l,$APP.Hj.j($APP.Tc(n)))}var B=new $APP.H(null,3,5,$APP.I,[n,p,v],null);return a.A?a.A(l,B):a.call(null,l,B)}(b,d,$APP.sf,$APP.sf);return c.j?c.j(b):c.call(null,b)};YN.G=4;
var v2=function v2(a,b){return a_a(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return VK($APP.u(l))?v2.A?v2.A(a,l):v2.call(null,a,l):$APP.Je.A(a,l)}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),b)},kL=function kL(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),
0,null):null;return kL.C(arguments[0],c)};kL.C=function(a,b){return v2(a,b)};kL.G=1;kL.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var FN=function FN(a){switch(arguments.length){case 2:return FN.A(arguments[0],arguments[1]);case 3:return FN.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};FN.A=function(a,b){return FN.B(bL,a,b)};
FN.B=function(a,b,c){return $APP.Xc(function n(g,l){if(VK(l)){var p=$APP.Id.B(function(v,t){var A=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);A=n(A,t);t=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return new $APP.H(null,2,5,$APP.I,[t,$APP.Vd.A(v,A)],null)},new $APP.H(null,2,5,$APP.I,[g,$APP.sf],null),l);g=$APP.x.B(p,0,null);p=$APP.x.B(p,1,null);return new $APP.H(null,2,5,$APP.I,[g,a.A?a.A(l,p):a.call(null,l,p)],null)}return new $APP.H(null,2,5,$APP.I,[$APP.Fc(g),$APP.u(g)],null)}(b,c))};FN.G=3;
var mL=function mL(a){if(VK(a)){var c=TK(a);c=zP.j?zP.j(c):zP.call(null,c);a=QK(c,$APP.Fl.A(mL,RK(a)),$APP.ed(a))}return a},rL=function rL(a,b){return!RZa(a,b)&&$APP.Uc.A($APP.Tc(a),$APP.Tc(b))&&$APP.Ge(function(d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var l=!VK(g);return l?l:(l=!VK(d))?l:rL.A?rL.A(g,d):rL.call(null,g,d)},$APP.Vg.B($APP.ns,a,b))};eH.F(null,new $APP.H(null,2,5,$APP.I,[XK,XK],null),function(a,b){return j_a(kG,a,b)});
eH.F(null,new $APP.H(null,2,5,$APP.I,[SK,SK],null),function(a,b){return j_a(kG,a,b)});PF.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return kL.C(PF,$APP.y([a]))});yG.F(null,new $APP.H(null,2,5,$APP.I,[XK,XK],null),function(a,b){return j_a(RF,a,b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[SK,SK],null),function(a,b){return j_a(RF,a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[aS,aS],null),function(a,b){return sL(a,b)});
MF.F(null,new $APP.H(null,2,5,$APP.I,[aS,FF],null),function(a,b){return e_a(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[FF,aS],null),function(a,b){return f_a(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[aS,FF],null),function(a,b){return e_a(a,OF.j(b))});MF.F(null,new $APP.H(null,2,5,$APP.I,[EW,aS],null),function(a,b){return bL(b,$APP.Vg.A(function(c){return iG.A(a,c)},b))});MF.F(null,new $APP.H(null,2,5,$APP.I,[aS,EW],null),function(a,b){return bL(a,$APP.Vg.A(function(c){return iG.A(c,b)},a))});
lG.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return tL(a,a)});oZ.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return sL(a,sL(a,a))});rI.F(null,new $APP.H(null,2,5,$APP.I,[aS,EG],null),function(a,b){var c=NF.j(b);return $APP.k(sG.j(b))?a:b>c?iG.A(a,rI.A(a,RF.A(b,c))):CD(["Cannot: ",$APP.m.j($APP.T.j($APP.r($APP.N.C(new $APP.D(null,mVb,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))))].join(""))});
bG.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return kL.C(bG,$APP.y([a]))});xG.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){var b=jG.j;a=tL(qL.j(a),a);return b.call(jG,a)});hG.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return jG.j(tL(a,a))});NZ.F(null,new $APP.H(null,2,5,$APP.I,[SK,SK],null),function(a,b){return kL.C(NZ,$APP.y([a,b]))});NZ.F(null,new $APP.H(null,2,5,$APP.I,[XK,XK],null),function(a,b){return kL.C(NZ,$APP.y([a,b]))});
OZ.F(null,new $APP.H(null,2,5,$APP.I,[SK,SK],null),function(a,b){return kL.C(OZ,$APP.y([a,b]))});OZ.F(null,new $APP.H(null,2,5,$APP.I,[XK,XK],null),function(a,b){return kL.C(OZ,$APP.y([a,b]))});xH.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return kL.C(xH,$APP.y([a]))});AH.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return kL.C(AH,$APP.y([a]))});qL.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return kL.C(qL,$APP.y([a]))});
eR.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return mL(a)});LO.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return UK(a)});BH.F(null,new $APP.H(null,2,5,$APP.I,[aS,aS],null),function(a,b){return tL(a,b)});RZ.F(null,new $APP.H(null,2,5,$APP.I,[aS,aS],null),function(a,b){return tL(qL.j(a),b)});SZ.F(null,new $APP.H(null,2,5,$APP.I,[aS,aS],null),function(a,b){return h_a(a,b)});TZ.F(null,new $APP.H(null,2,5,$APP.I,[SK,SK],null),function(a,b){return i_a(a,b)});$APP.e=vL.prototype;$APP.e.toString=function(){return w2.j?w2.j(this):w2.call(null,this)};$APP.e.ac=function(a,b,c){function d(g){return FH(g,b,c)}return IL.A?IL.A(d,this):IL.call(null,d,this)};$APP.e.$b=function(a,b,c){function d(g){return GH(g,b,c)}return IL.A?IL.A(d,this):IL.call(null,d,this)};$APP.e.ic=function(a,b){function c(d){return HH(d,b)}return IL.A?IL.A(c,this):IL.call(null,c,this)};
$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.polynomial.Polynomial "',this.toString(),'"]']))};$APP.e.ba=function(){return this.ca};$APP.e.Y=function(a,b){return DL.A?DL.A(this,b):DL.call(null,this,b)};$APP.e.rb=function(){return XL};$APP.e.bc=function(){return new $APP.H(null,3,5,$APP.I,[NX,0,this.arity],null)};$APP.e.ma=function(){return $APP.r(this.Ra)};$APP.e.da=function(a,b){return new vL(this.arity,this.Ra,b)};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.M(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Lb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){return UL.A?UL.A(this,$APP.sf):UL.call(null,this,$APP.sf)};$APP.e.j=function(a){a=new $APP.H(null,1,5,$APP.I,[a],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};
$APP.e.A=function(a,b){a=new $APP.H(null,2,5,$APP.I,[a,b],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.B=function(a,b,c){a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.M=function(a,b,c,d){a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.S=function(a,b,c,d,g){a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};
$APP.e.la=function(a,b,c,d,g,l){a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.Ga=function(a,b,c,d,g,l,n){a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.va=function(a,b,c,d,g,l,n,p){a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};
$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q){a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};
$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W){a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z){a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa){a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha){a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null);return UL.A?UL.A(this,a):UL.call(null,this,a)};
$APP.e.Lb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja){a=$APP.Lf.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null),ja);return UL.A?UL.A(this,a):UL.call(null,this,a)};var TL=function TL(a){switch(arguments.length){case 1:return TL.j(arguments[0]);case 2:return TL.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};TL.j=function(a){a=gXa(a);return yL(1,a)};TL.A=function(a,b){b=hXa(b);return yL(a,b)};
TL.G=2;var BL=function BL(a){switch(arguments.length){case 1:return BL.j(arguments[0]);case 2:return BL.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};BL.j=function(a){return BL.A(1,a)};BL.A=function(a,b){return wL(a,fXa(b),null)};BL.G=2;
var zL=function zL(a){switch(arguments.length){case 0:return zL.J();case 1:return zL.j(arguments[0]);case 2:return zL.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};zL.J=function(){return zL.A(1,0)};zL.j=function(a){return zL.A(a,0)};zL.A=function(a,b){b=yI.A?yI.A(b,1):yI.call(null,b,1);return wL(a,new $APP.H(null,1,5,$APP.I,[xI.A(b,1)],null),null)};zL.G=2;
var SL=function SL(a){switch(arguments.length){case 1:return SL.j(arguments[0]);case 2:return SL.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};SL.j=function(a){return $APP.k(KF.j(a))?-1:xL(a)?tI(vI(FL.j?FL.j(a):FL.call(null,a))):0};SL.A=function(a,b){var c=p_a(a,b);return $APP.k(KF.j(a))?-1:xL(a)?$APP.Vs.M($APP.Vg.j(function(d){return uI(vI(d),c)}),$APP.Gj,0,a.Ra):0};SL.G=2;
var w2=function w2(a){switch(arguments.length){case 1:return w2.j(arguments[0]);case 2:return w2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};w2.j=function(a){return w2.A(a,10)};w2.A=function(a,b){var c=a.Ra;a=a.arity;var d=$APP.Tc(c);c=$APP.We.A(b,$APP.Vg.A(eXa,c));b=d>b?["... and ",$APP.m.j(d-b)," more terms"].join(""):null;return[$APP.m.j(a),": (",$APP.Il.A(" + ",c),b,")"].join("")};w2.G=2;
var hM=function hM(a){switch(arguments.length){case 2:return hM.A(arguments[0],arguments[1]);case 3:return hM.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};hM.A=function(a,b){return hM.B(a,b,null)};
hM.B=function(a,b,c){function d(){var g=a.j?a.j(sI):a.call(null,sI);if($APP.hd(g))return b;var l=$APP.k(c)?c:AD("`new-arity` argument to `map-exponents` required when promoting constant.");return wL(l,new $APP.H(null,1,5,$APP.I,[xI.A(g,b)],null),null)}return xL(b)?TL.A($APP.k(c)?c:b.arity,function(){return function n(l){return new $APP.de(null,function(){for(;;){var p=$APP.r(l);if(p){if($APP.pd(p)){var v=$APP.lc(p),t=$APP.Tc(v),A=$APP.fe(t);a:for(var B=0;;)if(B<t){var G=$APP.bd(v,B),J=$APP.x.B(G,
0,null);G=$APP.x.B(G,1,null);J=a.j?a.j(J):a.call(null,J);$APP.je(A,xI.A(J,G));B+=1}else{v=!0;break a}return v?$APP.ie($APP.ke(A),n($APP.mc(p))):$APP.ie($APP.ke(A),null)}v=$APP.u(p);A=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);A=a.j?a.j(A):a.call(null,A);return $APP.Yd(xI.A(A,v),n($APP.Fc(p)))}return null}},null,null)}(b.Ra)}()):$APP.k(KF.j(b))?b:d()};hM.G=3;
var x2=function x2(a){switch(arguments.length){case 1:return x2.j(arguments[0]);case 2:return x2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};x2.j=function(a){return x2.A(a,SL.j(a))};
x2.A=function(a,b){if(!xL(a))return $APP.Lf.A(new $APP.H(null,1,5,$APP.I,[a],null),$APP.Uj.A(b,0));var c=SL.j(a);a=a.Ra;for(var d=$APP.bc($APP.sf),g=0;;){if(g>c)return $APP.Lf.A($APP.dc(d),$APP.Uj.A(b-c,0));var l=$APP.u(a),n=vI(l);n=uI(n,0);$APP.Uc.A(n,g)?(a=$APP.Fc(a),d=$APP.mf.A(d,wI(l)),g+=1):(d=$APP.mf.A(d,0),g+=1)}};x2.G=2;
var y2=function y2(a){switch(arguments.length){case 1:return y2.j(arguments[0]);case 2:return y2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};y2.j=function(a){return y2.A(a,GL(a))};y2.A=function(a,b){return $APP.k(sG.j(b))?a:$APP.k(KF.j(b))?CD(["Divide by zero: ",$APP.m.j(a),$APP.m.j(b)].join("")):xL(b)?RL.A?RL.A(a,b):RL.call(null,a,b):u_a(a,OF.j(b))};y2.G=2;
var z2=function z2(a){switch(arguments.length){case 1:return z2.j(arguments[0]);case 2:return z2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};z2.j=function(a){return z2.A(a,0)};z2.A=function(a,b){if(xL(a)){var c=SL.A(a,b);return 0===c?a:hM.A(function(d){var g=uI(d,b);g=c-g;return 0===g?$APP.Oi.A(d,b):$APP.rg.B(d,b,g)},a)}return a};z2.G=2;
var A2=function A2(a){switch(arguments.length){case 2:return A2.A(arguments[0],arguments[1]);case 3:return A2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};A2.A=function(a,b){return A2.B(a,b,$APP.ns)};
A2.B=function(a,b,c){var d=GL(a);return function B(l,n,p,v,t,A){var G=SL.j(A),J=xL(A)?l-G:l;if($APP.Uc.A(J,1)){var O=b*n+GL(A);l=b*p+n;p=b*v+p;t=Math.abs(b)*t+Math.abs(O)}else if($APP.Uc.A(J,2)){var Q=b*b,W=Math.abs(Q);O=Q*n+GL(A);l=Q*p+2*b*n;p=Q*v+2*b*p+n;t=W*(t+n)+Math.abs(O)}else{var Z=PL(b,J-2),fa=Z*b;Q=fa*b;W=Math.abs(Q);O=Q*n+GL(A);l=Q*p+J*fa*n;p=Q*v+J*fa*p+.5*J*(J-1)*Z*n;t=W*(t+(J-1)*n)+Math.abs(O)}n=O;O=p;xL(A)?A=B(G,n,l,O,t,w_a(A)):(A=2*O,G=MR*(t-Math.abs(n)+t),A=c.M?c.M(n,l,A,G):c.call(null,
n,l,A,G));return A}(SL.j(a),d,0,0,.5*Math.abs(d),w_a(a))};A2.G=3;var uqc=$APP.fg([tV,iK,DJ,$APP.Fv,PX,aT,$APP.Ev,DV,$APP.Gv],[oZ,M_.A(wM,0),rI,M_.A(eH,0),PF,lG,M_.B(MF,1,KF),M_.B(oM,1,KF),N_.M(yG,eH,PF,0)]),vqc=tD(uqc),B2=function B2(a){switch(arguments.length){case 1:return B2.j(arguments[0]);case 2:return B2.A(arguments[0],arguments[1]);case 3:return B2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
B2.j=function(a){return B2.B(a,$APP.ns,$APP.Ed)};B2.A=function(a,b){return B2.B(a,b,$APP.Ed)};B2.B=function(a,b,c){var d=$APP.lz.A(ZF(a),vqc),g=$APP.Tc(d);c=$APP.gi.A(c,d);g=$APP.Bg(c,AL(g));a=cTa(a,g,uqc);return b.A?b.A(a,c):b.call(null,a,c)};B2.G=3;var M_a=DH($APP.Ev),N_a=DH($APP.Fv),L_a=DH(DJ),e1a;
if("undefined"===typeof cM||"undefined"===typeof Ooc||"undefined"===typeof V0)V0=function(a){this.pk=a;this.O=393216;this.U=0},$APP.e=V0.prototype,$APP.e.da=function(a,b){return new V0(b)},$APP.e.ba=function(){return this.pk},$APP.e.Jg=function(a,b,c){return B2.A(b,c)},$APP.e.Af=function(a,b,c,d){return B2.B(b,c,d)},$APP.e.zf=function(a,b,c){return WL(b,c)},$APP.e.Le=function(a,b){return $APP.Bd(vqc,b)},V0.cb=!0,V0.Ya="emmy.polynomial/t_emmy$polynomial48706",V0.gb=function(a){return $APP.Vb(a,"emmy.polynomial/t_emmy$polynomial48706")},
Poc=function(a){return new V0(a)};e1a=new V0($APP.F);$APP.hu.A(FF,YL);$APP.hu.A(jT,YL);fG.F(null,new $APP.H(null,2,5,$APP.I,[XL,XL],null),function(a,b){return DL(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[XL,YL],null),function(a,b){return DL(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[YL,XL],null),function(a,b){return DL(b,a)});ZL(eH,KL);ZL(yG,LL);ZL(MF,ML);ZL(qI,function(a,b){return $APP.x.A(QL(a,b),0)});ZL(AG,function(a,b){return $APP.x.A(QL(a,b),1)});
KF.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){return $APP.hd(a.Ra)});sG.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){a=a.Ra;var b=$APP.Uc.A($APP.Tc(a),1);return b?(a=$APP.x.B(a,0,null),(b=$APP.hd(vI(a)))?sG.j(wI(a)):b):b});iZ.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){var b=a.Ra;a=sG.j(a.arity);return $APP.k(a)?(a=$APP.Uc.A($APP.Tc(b),1))?(b=$APP.x.B(b,0,null),(a=$APP.Uc.A(new $APP.f(null,1,[0,1],null),vI(b)))?sG.j(wI(b)):a):a:a});
tG.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){a=$APP.x.A(a.Ra,0);return $APP.k(a)?tG.j(wI(a)):0});NF.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){a=$APP.x.A(a.Ra,0);return $APP.k(a)?NF.j(wI(a)):1});jZ.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){var b=$APP.x.A(a.Ra,0);b=$APP.k(b)?NF.j(wI(b)):1;b=xI.A(yI.A?yI.A(0,1):yI.call(null,0,1),b);return new vL(1,new $APP.H(null,1,5,$APP.I,[b],null),a.ca)});
aG.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,Xlb,null,1,null),new $APP.D(null,a.arity,null,1,null),$APP.y([new $APP.D(null,a.Ra,null,1,null)]))))});TF.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(){return!1});qG.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){return HL(a)});hG.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){return A_a(a)});PF.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){return JL(a)});
lG.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){return NL(a)});oZ.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){return OL(a)});rI.F(null,new $APP.H(null,2,5,$APP.I,[XL,GY],null),function(a,b){return PL(a,b)});iM.F(null,new $APP.H(null,2,5,$APP.I,[XL,XL],null),function(a,b){return RL(a,b)});iM.F(null,new $APP.H(null,2,5,$APP.I,[XL,YL],null),function(a,b){return RL(a,b)});bG.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){return IL(bG,a)});
mR.F(null,new $APP.H(null,2,5,$APP.I,[XL,YR],null),function(a,b){return $APP.hd(b)?$APP.Uc.A(1,a.arity)?VL(a,0):aL(K_a(a)):$APP.Uc.A(1,$APP.Tc(b))?VL(a,$APP.u(b)):AD("Invalid selector! Only 1 deep supported.")});var wqc="undefined"!==typeof window?window:null,C2="undefined"!==typeof performance?performance:$APP.k(wqc)?wqc.performance:null,xqc=function(){var a=$APP.k(C2)?C2.now:null;if($APP.k(a))return a;a=$APP.k(C2)?C2.mozNow:null;if($APP.k(a))return a;a=$APP.k(C2)?C2.msNow:null;if($APP.k(a))return a;a=$APP.k(C2)?C2.oNow:null;return $APP.k(a)?a:$APP.k(C2)?C2.webkitNow:null}(),yqc=$APP.Uc.A("nodejs","default")?process:null,D2=$APP.k(yqc)?yqc.hrtime:null;var zqc=$APP.vd(xqc)?function(){var a=xqc.call(C2);return function(){return 1E6*(xqc.call(C2)-a)}}:null,Aqc=$APP.vd(D2)?function(){var a=D2.J?D2.J():D2.call(null);return function(){var b=D2.j?D2.j(a):D2.call(null,a),c=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return 1E9*c+b}}:null,Bqc=$APP.k(zqc)?zqc:$APP.k(Aqc)?Aqc:O_a;var V_a={},dM,R_a=new $APP.H(null,7,5,$APP.I,[S_a,Xbb,jcb,slb,D5b,pub,X7b],null),Cqc=new $APP.f(null,7,[S_a,"ns",Xbb,"s",jcb,"ms",slb,"s",D5b,"min",pub,"h",X7b,"d"],null);bM.prototype.Cf=function(){return $APP.k(this.gi)?this:new bM(Bqc.J?Bqc.J():Bqc.call(null),this.offset,!0)};bM.prototype.Mg=function(a,b){return Q_a($APP.k(this.gi)?(this.Ig.J?this.Ig.J():this.Ig.call(null))+this.offset:this.offset,b)};
bM.prototype.Bf=function(){var a=T_a($L(this,S_a)),b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b)," ",$APP.m.j(Cqc.j?Cqc.j(a):Cqc.call(null,a))].join("")};var fM=new $APP.H(null,2,5,$APP.I,[1E3,jcb],null),eM=null,c0a=$APP.kh.j($APP.F),d0a=$APP.kh.j(0),e0a=$APP.kh.j(0),j0a=$APP.kh.j(0),m0a=$APP.kh.j(0),mM=function mM(a){switch(arguments.length){case 1:return mM.j(arguments[0]);case 2:return mM.A(arguments[0],arguments[1]);case 3:return mM.B(arguments[0],arguments[1],arguments[2]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(3),0,null);return mM.C(arguments[0],arguments[1],arguments[2],
c)}};mM.j=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,2,5,$APP.I,[b,a],null)};mM.A=function(a,b){var c=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return b.A?b.A(c,a):b.call(null,c,a)};mM.B=function(a,b,c){var d=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return b.B?b.B(d,a,c):b.call(null,d,a,c)};
mM.C=function(a,b,c,d){function g(n,p){return $APP.Je.M(mM,new $APP.H(null,2,5,$APP.I,[n,p],null),c,d)}var l=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return b.B?b.B(l,a,g):b.call(null,l,a,g)};mM.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};mM.G=3;
var jM=M_.B(function(a,b){return EF(a)&&EF(b)?wM.A(a,b):1},0,sG),nM=function nM(a){switch(arguments.length){case 2:return nM.A(arguments[0],arguments[1]);case 3:return nM.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};nM.A=function(a,b){return nM.B(0,a,b)};
nM.B=function(a,b,c){Z_a(a,"full-gcd",$APP.y([b,c]));b=f0a(function(d,g){var l=l0a(d,g);if($APP.k(l))return l;l=n_a(d,g);if(r_a(d))return n0a(d,g);if(r_a(g))return n0a(g,d);if($APP.Uc.A(l,1))return p0a(d,g);l=M_.B(function(n,p){return nM.B(a+1,n,p)},0,sG);a0a("full-gcd");return mM.C(new $APP.H(null,2,5,$APP.I,[d,g],null),G_a,i0a(l),$APP.y([o0a(l)]))},b,c);Z_a(a,"\x3c-",$APP.y([b]));return b};nM.G=3;var pM=M_.A(r0a,0);ZL(oM,s0a);
wM.F(null,new $APP.H(null,2,5,$APP.I,[XL,XL],null),function(a,b){return r0a(a,b)});wM.F(null,new $APP.H(null,2,5,$APP.I,[XL,YL],null),function(a,b){return $APP.k(KF.j(b))?a:kM(a,b)});wM.F(null,new $APP.H(null,2,5,$APP.I,[YL,XL],null),function(a,b){return $APP.k(KF.j(a))?b:kM(b,a)});var Dqc={},E2,Eqc,F2=yJ.C($APP.y([$1.C($APP.y([$APP.Ev])),Z1.C($APP.y([$APP.Ev])),LYa($APP.Ev,1),kJ(vJ.A(new $APP.D(null,$APP.Ev,null,1,null),xJ),function(){return $APP.k(1)?1:dJ(1)})])),G2=function G2(a){switch(arguments.length){case 2:return G2.A(arguments[0],arguments[1]);case 3:return G2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};G2.A=function(a,b){return G2.B(a,b,$APP.Kd)};
G2.B=function(a,b,c){try{var d=$APP.Vg.A(function(l){l=WL(l,b);return c.j?c.j(l):c.call(null,l)},u0a(a)),g=v0a(d);return F2.j?F2.j(g):F2.call(null,g)}catch(l){if(l instanceof Error)return $G($APP.hw,"emmy.polynomial.factor",120,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["Factorization choked! Simplifying the unfactored polynomial."],null)},null),-37723055),a=WL(a,b),F2.j?F2.j(a):F2.call(null,a);throw l;}};G2.G=3;
var H2=function H2(a){switch(arguments.length){case 1:return H2.j(arguments[0]);case 2:return H2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};H2.j=function(a){return H2.A(a,$APP.Kd)};H2.A=function(a,b){return B2.A(YF(a),function(c,d){return G2.B(c,d,b)})};H2.G=2;
var Fqc=function(){var a=DM.A(16,"-f-");return EM.A(function(){if("undefined"===typeof cM||"undefined"===typeof Ooc||"undefined"===typeof Dqc||"undefined"===typeof E2)E2=function(b,c){this.Yk=b;this.rk=c;this.O=393216;this.U=0},E2.prototype.da=function(b,c){return new E2(this.Yk,c)},E2.prototype.ba=function(){return this.rk},E2.prototype.Af=function(b,c,d,g){return B2.B(c,d,g)},E2.prototype.zf=function(b,c,d){return G2.A(c,d)},E2.prototype.Le=function(b,c){return e1a.Le(null,c)},E2.cb=!0,E2.Ya="emmy.polynomial.factor/t_emmy$polynomial$factor49020",
E2.gb=function(b){return $APP.Vb(b,"emmy.polynomial.factor/t_emmy$polynomial$factor49020")},Eqc=function(b,c){return new E2(b,c)};return new E2(a,$APP.F)}(),a)}(),qM=xWa(Fqc);var Gqc={},I2,Hqc,J2=function J2(a){switch(arguments.length){case 2:return J2.A(arguments[0],arguments[1]);case 3:return J2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};J2.A=function(a,b){return J2.B(a,b,null)};J2.B=function(a,b,c){a=AI(B0a,C0a(b),a);return $APP.Vg.A($APP.fd,$APP.k(c)?$APP.x.A(a,c):zI(a))};J2.G=3;$APP.e=sM.prototype;$APP.e.toString=function(){return[$APP.m.j(this.Kb)," : ",$APP.m.j(this.v)].join("")};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.rational-function.RationalFunction "',this.toString(),'"]']))};$APP.e.ba=function(){return this.ca};$APP.e.Y=function(a,b){return vM.A?vM.A(this,b):vM.call(null,this,b)};$APP.e.rb=function(){return BM};$APP.e.bc=function(){return new $APP.H(null,3,5,$APP.I,[NX,0,this.arity],null)};
$APP.e.ma=function(){return new $APP.D(null,this.Kb,new $APP.D(null,this.v,null,1,null),2,null)};$APP.e.da=function(a,b){return new sM(this.arity,this.Kb,this.v,b)};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.M(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Lb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){return zM.A?zM.A(this,$APP.sf):zM.call(null,this,$APP.sf)};$APP.e.j=function(a){a=new $APP.H(null,1,5,$APP.I,[a],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};
$APP.e.A=function(a,b){a=new $APP.H(null,2,5,$APP.I,[a,b],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.B=function(a,b,c){a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.M=function(a,b,c,d){a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.S=function(a,b,c,d,g){a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};
$APP.e.la=function(a,b,c,d,g,l){a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.Ga=function(a,b,c,d,g,l,n){a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.va=function(a,b,c,d,g,l,n,p){a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};
$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q){a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};
$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W){a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z){a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa){a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha){a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null);return zM.A?zM.A(this,a):zM.call(null,this,a)};
$APP.e.Lb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja){a=$APP.Lf.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null),ja);return zM.A?zM.A(this,a):zM.call(null,this,a)};$APP.e.Lg=function(){return this.Kb};$APP.e.Kg=function(){return this.v};
var Iqc=$APP.rg.C(uqc,$APP.rj,N_.S(zG,MF,OF,1,KF),$APP.y([hX,OF])),Jqc=tD(Iqc),K2=function K2(a){switch(arguments.length){case 1:return K2.j(arguments[0]);case 2:return K2.A(arguments[0],arguments[1]);case 3:return K2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};K2.j=function(a){return K2.B(a,$APP.ns,$APP.Ed)};K2.A=function(a,b){return K2.B(a,b,$APP.Ed)};
K2.B=function(a,b,c){var d=$APP.lz.A(ZF(a),Jqc),g=$APP.Tc(d);c=$APP.gi.A(c,d);g=$APP.Bg(c,AL(g));a=cTa(a,g,Iqc);return b.A?b.A(a,c):b.call(null,a,c)};K2.G=3;var g1a;
if("undefined"===typeof cM||"undefined"===typeof Gqc||"undefined"===typeof I2)I2=function(a){this.qk=a;this.O=393216;this.U=0},$APP.e=I2.prototype,$APP.e.da=function(a,b){return new I2(b)},$APP.e.ba=function(){return this.qk},$APP.e.Jg=function(a,b,c){return K2.A(b,c)},$APP.e.Af=function(a,b,c,d){return K2.B(b,c,d)},$APP.e.zf=function(a,b,c){return c1a(b,c)},$APP.e.Le=function(a,b){return $APP.Bd(Jqc,b)},I2.cb=!0,I2.Ya="emmy.rational-function/t_emmy$rational_function48980",I2.gb=function(a){return $APP.Vb(a,
"emmy.rational-function/t_emmy$rational_function48980")},Hqc=function(a){return new I2(a)};g1a=new I2($APP.F);OF.F(null,new $APP.H(null,1,5,$APP.I,[XL],null),function(a){var b=a.arity;return $APP.k(qG.j(a))?tM(b,-1,PF.j(a),$APP.ed(a)):tM(b,1,a,$APP.ed(a))});ZL(zG,xM);ZL(cR,xM);ZL(VF,function(a,b){return yM(b,a)});iM.F(null,new $APP.H(null,2,5,$APP.I,[YL,XL],null),function(a,b){var c=b.Ra,d=$APP.x.B(c,0,null);return $APP.Uc.A($APP.Tc(c),1)&&$APP.hd(vI(d))?iM.A(a,wI(d)):xM(a,b)});
fG.F(null,new $APP.H(null,2,5,$APP.I,[BM,BM],null),function(a,b){return vM(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[XL,BM],null),function(a,b){return vM(b,a)});fG.F(null,new $APP.H(null,2,5,$APP.I,[YL,BM],null),function(a,b){return vM(b,a)});fG.F(null,new $APP.H(null,2,5,$APP.I,[BM,XL],null),function(a,b){return vM(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[BM,YL],null),function(a,b){return vM(a,b)});CM(eH,U0a);CM(yG,V0a);CM(MF,W0a);CM(zG,yM);CM(iM,yM);CM(cR,yM);
CM(VF,function(a,b){return yM(b,a)});CM(wM,a1a);KF.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return KF.j(a.Kb)});sG.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){var b=sG.j(a.Kb);return $APP.k(b)?sG.j(a.v):b});iZ.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){var b=iZ.j(a.Kb);return $APP.k(b)?sG.j(a.v):b});tG.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return tG.j(a.Kb)});NF.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return NF.j(a.Kb)});
jZ.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return new sM(a.arity,jZ.j(a.Kb),NF.j(a.v),a.ca)});aG.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return new $APP.D(null,$APP.rj,new $APP.D(null,aG.j(a.Kb),new $APP.D(null,aG.j(a.v),null,1,null),2,null),3,null)});qG.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return L0a(a)});hG.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return T0a(a)});PF.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return S0a(a)});
OF.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return $0a(a)});lG.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return X0a(a)});oZ.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return Y0a(a)});rI.F(null,new $APP.H(null,2,5,$APP.I,[BM,EG],null),function(a,b){return Z0a(a,b)});bG.F(null,new $APP.H(null,1,5,$APP.I,[BM],null),function(a){return $APP.z(xM(bG.j(a.Kb),bG.j(a.v)),$APP.ed(a))});
mR.F(null,new $APP.H(null,2,5,$APP.I,[BM,YR],null),function(a,b){return $APP.hd(b)?$APP.Uc.A(1,a.arity)?AM(a,0):aL(b1a(a)):$APP.Uc.A(1,$APP.Tc(b))?AM(a,$APP.u(b)):AD("Invalid selector! Only 1 deep supported.")});var FM=$APP.mh(EH(f1a())),GM=d1a($APP.mh(EH(h1a()))),j1a=JM($APP.Hl.A(zZa(new $APP.Ac(function(){return GM},AX,$APP.fg([$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.zj,$APP.gm,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[fV,JT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(GM)?GM.Z:null]))),z0a)),OM=zZa(new $APP.Ac(function(){return GM},AX,$APP.fg([$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.zj,$APP.gm,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[fV,JT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(GM)?GM.Z:
null]))),l1a=hZa(new $APP.Ac(function(){return GM},AX,$APP.fg([$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.zj,$APP.gm,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[fV,JT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(GM)?GM.Z:null]))),k1a=bZa(new $APP.Ac(function(){return GM},AX,$APP.fg([$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.zj,$APP.gm,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[fV,JT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(GM)?GM.Z:null]))),v1a=iZa(new $APP.Ac(function(){return GM},AX,$APP.fg([$APP.wl,
$APP.R,$APP.Wi,$APP.Lr,$APP.zj,$APP.gm,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[fV,JT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(GM)?GM.Z:null]))),p1a=xZa(new $APP.Ac(function(){return GM},AX,$APP.fg([$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.zj,$APP.gm,$APP.Xi,$APP.Mr,$APP.U,$APP.P,$APP.Nr],[fV,JT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(GM)?GM.Z:null]))),r1a=wZa(new $APP.Ac(function(){return GM},AX,$APP.fg([$APP.wl,$APP.R,$APP.Wi,$APP.Lr,$APP.zj,$APP.gm,$APP.Xi,$APP.Mr,$APP.U,
$APP.P,$APP.Nr],[fV,JT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(GM)?GM.Z:null])));$APP.q.prototype.nd=function(){return!0};$APP.q.prototype.rb=function(){return $APP.q};$APP.hu.A($APP.q,PM);$APP.hu.A(PM,FF);fG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.q,YR],null),function(){return!1});fG.F(null,new $APP.H(null,2,5,$APP.I,[YR,$APP.q],null),function(){return!1});fG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.q,TM],null),function(){return!1});fG.F(null,new $APP.H(null,2,5,$APP.I,[TM,$APP.q],null),function(){return!1});
fG.F(null,new $APP.H(null,2,5,$APP.I,[PM,YR],null),function(a,b){return fG.A(YF(a),b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[YR,PM],null),function(a,b){return fG.A(a,YF(b))});fG.F(null,new $APP.H(null,2,5,$APP.I,[PM,TM],null),function(a,b){return fG.A(YF(a),b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[TM,PM],null),function(a,b){return fG.A(a,YF(b))});fG.F(null,new $APP.H(null,2,5,$APP.I,[PM,PM],null),function(a,b){return $APP.Uc.A(YF(a),YF(b))});UM(eH,$APP.Fv);UM(yG,$APP.Gv);UM(MF,$APP.Ev);UM(zG,$APP.rj);
UM(lI,YX);UM(AG,eS);UM(rI,DJ);SM(PF,PX);SM(OF,hX);SM(qZ,WV);SM(sZ,xW);SM(pZ,bT);SM(rZ,jY);SM(gO,kH);SM(fO,sH);SM(tZ,lK);SM(wZ,LM);SM(vZ,NM);SM(xZ,jK);SM(kO,kK);SM(rG,hK);UM(rG,hK);SM(yZ,XS);SM(vH,wH);SM(tH,uH);SM(BZ,oX);SM(DZ,tW);SM(CZ,sT);SM(EZ,eW);SM(hG,$APP.Iu);SM(jG,FJ);SM(pG,BJ);var L2=DH(BJ),M2=DH($APP.rj);mZ.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(a){a=YF(a);a=L2.j?L2.j(a):L2.call(null,a);var b=L2.j?L2.j(2):L2.call(null,2);a=M2.A?M2.A(a,b):M2.call(null,a,b);return QM(a)});
nZ.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(a){a=YF(a);a=L2.j?L2.j(a):L2.call(null,a);var b=L2.j?L2.j(10):L2.call(null,10);a=M2.A?M2.A(a,b):M2.call(null,a,b);return QM(a)});SM(oG,zJ);UM(NZ,PV);UM(OZ,DT);SM(xH,$T);SM(AH,hV);SM(xG,AK);SM(PZ,CY);SM(qL,nY);UM(BH,GX);UM(RZ,rX);UM(wM,iK);UM(oM,DV);qG.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(){return!1});KF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(){return!1});
sG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(){return!1});iZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(){return!1});aG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(a){return a});TF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(){return!1});bG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(a){return a});bG.F(null,new $APP.H(null,1,5,$APP.I,[PM],null),function(a){return QM(z1a(YF(a)))});var B1a=$APP.mh(bG);$APP.hu.A(iN,FF);$APP.e=VM.prototype;$APP.e.rb=function(){return iN};$APP.e.ac=function(a,b,c){return $APP.Uc.A(b,this.tag)?new VM(c,this.id,this.xc,this.Ud):this};$APP.e.$b=function(a,b,c){return $APP.Uc.A(c,RH)?0:$APP.Uc.A(b,this.tag)?K1a.j?K1a.j(this):K1a.call(null,this):X_};$APP.e.ic=function(){return 0};$APP.e.nd=function(){return!1};$APP.e.valueOf=function(){return this.xc.valueOf()};
$APP.e.toString=function(){return["#emmy.tape.TapeCell",$APP.m.j(new $APP.f(null,4,[$APP.sj,this.tag,$APP.Wl,this.id,Jcb,this.xc,Kib,this.Ud],null))].join("")};$APP.e.Tb=function(a,b){return H1a.A?H1a.A(this,b):H1a.call(null,this,b)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};
var YM=function YM(a,b){return GF(a)?E1a(b,a):VK(a)?kL.C(function(d){return YM.A?YM.A(d,b):YM.call(null,d,b)},$APP.y([a])):UH(a)?AD("Function input not yet supported."):a},$M=function $M(a,b,c){if(WM(a)&&$APP.Uc.A(c,a.tag))return HH(b,a.id);if(VK(a))return t2.A(a,$APP.Fl.A(function(g){return $M.B?$M.B(g,b,c):$M.call(null,g,b,c)},a));if(UH(a))throw $APP.Zi.A("function inputs not supported.",new $APP.f(null,1,[jTa,a],null));throw $APP.Zi.A("unknown input type!",new $APP.f(null,1,[jTa,a],null));};
tG.F(null,new $APP.H(null,1,5,$APP.I,[iN],null),function(){return 0});NF.F(null,new $APP.H(null,1,5,$APP.I,[iN],null),function(){return 1});jZ.F(null,new $APP.H(null,1,5,$APP.I,[iN],null),function(){return 1});
aG.F(null,new $APP.H(null,1,5,$APP.I,[iN],null),function(a){return $APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,Xac,null,1,null),new $APP.D(null,a.tag,null,1,null),$APP.y([new $APP.D(null,a.id,null,1,null),new $APP.D(null,aG.j(XM(a)),null,1,null),new $APP.D(null,$APP.Fl.A(function(b){var c=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return new $APP.H(null,2,5,$APP.I,[aG.j(c),aG.j(b)],null)},a.Ud),null,1,null)])))))});
bG.F(null,new $APP.H(null,1,5,$APP.I,[iN],null),function(a){return new VM(a.tag,a.id,bG.j(a.xc),$APP.Fl.A(function(b){var c=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return new $APP.H(null,2,5,$APP.I,[bG.j(c),bG.j(b)],null)},a.Ud))});var N2=function N2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return N2.C(c)};N2.C=function(a){var b=$APP.He($APP.Je.A($APP.zm,a),NH);return $APP.k(b)?b:$APP.Je.A($APP.Gj,a)};N2.G=0;N2.K=function(a){return this.C($APP.r(a))};var eN=function eN(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return eN.C(c)};
eN.C=function(a){var b=$APP.Vg.j(function(c){var d=WM(c)?c.tag:LH(c)?MH(c):null;return $APP.k(d)?new $APP.H(null,2,5,$APP.I,[d,c],null):null});a=$APP.Lf.B($APP.F,b,a);return $APP.r(a)?(b=$APP.Je.A(N2,$APP.ng(a)),new $APP.H(null,2,5,$APP.I,[b,a.j?a.j(b):a.call(null,b)],null)):null};eN.G=0;eN.K=function(a){return this.C($APP.r(a))};kN(eH);gN(PF);kN(yG);var Kqc=O1a(MF);jN(MF,Kqc);jN(BH,Kqc);kN(rI);gN(lG);gN(oZ);gN(OF);kN(zG);
fN(hG,function(a){var b=aN(a);return(0>b?M1a(PF,function(){return-1}):0<b?M1a($APP.Kd,function(){return 1}):$APP.Uc.A(b,0)?AD("Derivative of g/abs undefined at zero"):AD(["error! derivative of g/abs at",$APP.m.j(a)].join("")))(a)});fN(pZ,P1a(pZ,0));fN(rZ,P1a(rZ,0));fN(qZ,P1a(qZ,0));fN(sZ,P1a(sZ,1));var Lqc=O1a(zG);jN(VF,function(a,b){return Lqc.A?Lqc.A(b,a):Lqc.call(null,b,a)});jN(cR,Lqc);gN(jG);gN(pG);gN(oG);gN(fO);gN(gO);gN(tZ);gN(uZ);gN(wZ);gN(vZ);gN(rG);kN(rG);gN(xZ);gN(kO);gN(yZ);gN(zZ);gN(AZ);
gN(tH);gN(vH);gN(BZ);gN(CZ);gN(DZ);gN(EZ);gN(FZ);gN(GZ);gN(HZ);gN(IZ);gN(JZ);gN(KZ);gN(rR);gN(tR);gN(LZ);gN(MZ);jN(fG,lN(fG));fN(KF,function(){var a=lN(KF);return function(b){if(WM(b))return a(b);var c=bN.j(b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);b=KF.j(b);return $APP.k(b)?KF.j(c):b}}());fN(sG,function(){var a=lN(sG);return function(b){if(WM(b))b=a(b);else{var c=bN.j(b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);b=sG.j(b);b=$APP.k(b)?KF.j(c):b}return b}}());
fN(iZ,function(){var a=lN(iZ);return function(b){if(WM(b))b=a(b);else{var c=bN.j(b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);b=iZ.j(b);b=$APP.k(b)?KF.j(c):b}return b}}());fN(qG,lN(qG));fN(mG,lN(mG));$APP.hu.A(uT,kV);$APP.hu.A(ZU,kV);$APP.hu.A(XW,kV);$APP.hu.A(kV,jI);$APP.e=mN.prototype;$APP.e.Hc=$APP.xc;$APP.e.Ac=function(a,b){return $APP.wb(this.v,b)};$APP.e.toString=function(){return $APP.jh.C($APP.y([this.v]))};$APP.e.Ka=function(a,b){return $APP.Ms(this.v,b)};$APP.e.fa=function(a,b,c){return $APP.Ms(this.v,b,c)};$APP.e.aa=function(a,b){return $APP.bd(this.v,b)};$APP.e.eb=function(a,b,c){return $APP.bd(this.v,b,c)};
$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.structure.Matrix "',this.toString(),'"]']))};$APP.e.ta=function(){return $APP.lb(this.v)};$APP.e.Y=function(a,b){return sN.A?sN.A(this,b):sN.call(null,this,b)};$APP.e.Sa=function(){return tG.j(this)};$APP.e.rb=function(){return $APP.Uc.A(this.r,this.c)?uT:$APP.Uc.A(this.r,1)?XW:$APP.Uc.A(this.c,1)?ZU:kV};$APP.e.bc=function(){return $APP.Vs.B($APP.Vg.j(NWa),dI,this.v)};
$APP.e.sa=function(a,b,c){return new mN(this.r,this.c,$APP.vb(this.v,b,c))};$APP.e.Va=function(a,b){return $APP.ub(this.v,b)};$APP.e.ma=function(){return $APP.Mb(this.v)};
$APP.e.call=function(a){switch(arguments.length-1){case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.M(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);case 11:return this.xa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13]);
case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],arguments[2],arguments[3],arguments[4],
arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],
arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Lb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],
arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.j=function(a){return new mN(this.r,this.c,$APP.Fl.A(function(b){return $APP.Fl.A(function(c){return c.j?c.j(a):c.call(null,a)},b)},this.v))};$APP.e.A=function(a,b){return new mN(this.r,this.c,$APP.Fl.A(function(c){return $APP.Fl.A(function(d){return d.A?d.A(a,b):d.call(null,a,b)},c)},this.v))};
$APP.e.B=function(a,b,c){return new mN(this.r,this.c,$APP.Fl.A(function(d){return $APP.Fl.A(function(g){return g.B?g.B(a,b,c):g.call(null,a,b,c)},d)},this.v))};$APP.e.M=function(a,b,c,d){return new mN(this.r,this.c,$APP.Fl.A(function(g){return $APP.Fl.A(function(l){return l.M?l.M(a,b,c,d):l.call(null,a,b,c,d)},g)},this.v))};$APP.e.S=function(a,b,c,d,g){return new mN(this.r,this.c,$APP.Fl.A(function(l){return $APP.Fl.A(function(n){return n.S?n.S(a,b,c,d,g):n.call(null,a,b,c,d,g)},l)},this.v))};
$APP.e.la=function(a,b,c,d,g,l){return new mN(this.r,this.c,$APP.Fl.A(function(n){return $APP.Fl.A(function(p){return p.la?p.la(a,b,c,d,g,l):p.call(null,a,b,c,d,g,l)},n)},this.v))};$APP.e.Ga=function(a,b,c,d,g,l,n){return new mN(this.r,this.c,$APP.Fl.A(function(p){return $APP.Fl.A(function(v){return v.Ga?v.Ga(a,b,c,d,g,l,n):v.call(null,a,b,c,d,g,l,n)},p)},this.v))};
$APP.e.va=function(a,b,c,d,g,l,n,p){return new mN(this.r,this.c,$APP.Fl.A(function(v){return $APP.Fl.A(function(t){return t.va?t.va(a,b,c,d,g,l,n,p):t.call(null,a,b,c,d,g,l,n,p)},v)},this.v))};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){return new mN(this.r,this.c,$APP.Fl.A(function(t){return $APP.Fl.A(function(A){return A.Ha?A.Ha(a,b,c,d,g,l,n,p,v):A.call(null,a,b,c,d,g,l,n,p,v)},t)},this.v))};
$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){return new mN(this.r,this.c,$APP.Fl.A(function(A){return $APP.Fl.A(function(B){return B.wa?B.wa(a,b,c,d,g,l,n,p,v,t):B.call(null,a,b,c,d,g,l,n,p,v,t)},A)},this.v))};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){return new mN(this.r,this.c,$APP.Fl.A(function(B){return $APP.Fl.A(function(G){return G.xa?G.xa(a,b,c,d,g,l,n,p,v,t,A):G.call(null,a,b,c,d,g,l,n,p,v,t,A)},B)},this.v))};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){return new mN(this.r,this.c,$APP.Fl.A(function(G){return $APP.Fl.A(function(J){return J.ya?J.ya(a,b,c,d,g,l,n,p,v,t,A,B):J.call(null,a,b,c,d,g,l,n,p,v,t,A,B)},G)},this.v))};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){return new mN(this.r,this.c,$APP.Fl.A(function(J){return $APP.Fl.A(function(O){return O.za?O.za(a,b,c,d,g,l,n,p,v,t,A,B,G):O.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G)},J)},this.v))};
$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){return new mN(this.r,this.c,$APP.Fl.A(function(O){return $APP.Fl.A(function(Q){return Q.Aa?Q.Aa(a,b,c,d,g,l,n,p,v,t,A,B,G,J):Q.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J)},O)},this.v))};$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){return new mN(this.r,this.c,$APP.Fl.A(function(Q){return $APP.Fl.A(function(W){return W.Ba?W.Ba(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O):W.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O)},Q)},this.v))};
$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q){return new mN(this.r,this.c,$APP.Fl.A(function(W){return $APP.Fl.A(function(Z){return Z.Ca?Z.Ca(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q):Z.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q)},W)},this.v))};$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W){return new mN(this.r,this.c,$APP.Fl.A(function(Z){return $APP.Fl.A(function(fa){return fa.Da?fa.Da(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W):fa.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W)},Z)},this.v))};
$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z){return new mN(this.r,this.c,$APP.Fl.A(function(fa){return $APP.Fl.A(function(ha){return ha.Ea?ha.Ea(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z):ha.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z)},fa)},this.v))};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa){return new mN(this.r,this.c,$APP.Fl.A(function(ha){return $APP.Fl.A(function(ja){return ja.Fa?ja.Fa(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa):ja.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa)},ha)},this.v))};
$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha){return new mN(this.r,this.c,$APP.Fl.A(function(ja){return $APP.Fl.A(function(ta){return ta.La?ta.La(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha):ta.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha)},ja)},this.v))};
$APP.e.Lb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja){return new mN(this.r,this.c,$APP.Fl.A(function(ta){return $APP.Fl.A(function(ua){return $APP.Je.C(ua,a,b,c,d,$APP.y([g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja]))},ta)},this.v))};$APP.e.ac=function(a,b,c){function d(g){return FH(g,b,c)}return tN.A?tN.A(d,this):tN.call(null,d,this)};$APP.e.$b=function(a,b,c){function d(g){return GH(g,b,c)}return tN.A?tN.A(d,this):tN.call(null,d,this)};
$APP.e.ic=function(a,b){function c(d){return HH(d,b)}return tN.A?tN.A(c,this):tN.call(null,c,this)};var vN=function vN(a){switch(arguments.length){case 2:return vN.A(arguments[0],arguments[1]);case 3:return vN.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};vN.A=function(a,b){return vN.B(a,a,b)};
vN.B=function(a,b,c){return nN(a,b,$APP.Fl.A(function(d){return $APP.Fl.A(function(g){return c.A?c.A(d,g):c.call(null,d,g)},$APP.Hj.j(b))},$APP.Hj.j(a)))};vN.G=3;var O2=function O2(a){switch(arguments.length){case 2:return O2.A(arguments[0],arguments[1]);case 3:return O2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};O2.A=function(a,b){return O2.B(a,b,b)};
O2.B=function(a,b,c){var d=[$APP.m.j(a),"_"].join("");return vN.B(b,c,function(g,l){return $APP.Zg.j([d,$APP.m.j(l),"",$APP.m.j(g)].join(""))})};O2.G=3;var CN=function CN(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return CN.C(c)};CN.C=function(a){return W1a(a)};CN.G=0;CN.K=function(a){return this.C($APP.r(a))};
var P2=function P2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return P2.C(c)};P2.C=function(a){return X1a(a)};P2.G=0;P2.K=function(a){return this.C($APP.r(a))};var Q2=function Q2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return Q2.C(c)};Q2.C=function(a){return Y1a(a)};Q2.G=0;Q2.K=function(a){return this.C($APP.r(a))};
var zR=function zR(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return zR.C(c)};zR.C=function(a){return uN(a)};zR.G=0;zR.K=function(a){return this.C($APP.r(a))};var xN=function xN(a){switch(arguments.length){case 1:return xN.j(arguments[0]);case 4:return xN.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
xN.j=function(a){return xN.M(a,XK,SK,!0)};xN.M=function(a,b,c,d){a=$APP.k(d)?wN(a):a;return ZK(b,$APP.Fl.A(function(g){return ZK(c,g)},a))};xN.G=4;var RO=function RO(a){switch(arguments.length){case 2:return RO.A(arguments[0],arguments[1]);case 3:return RO.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};RO.A=function(a,b){var c=oL(iG.A(a,b));return RO.B(c,a,b)};
RO.B=function(a,b,c){var d=UK(a),g=UK(c);return vN.B(d,g,function(l,n){return iG.A(FN.A(k2.A(d,l),a),iG.A(b,FN.A(k2.A(g,n),c)))})};RO.G=3;var qP=function qP(a){switch(arguments.length){case 2:return qP.A(arguments[0],arguments[1]);case 3:return qP.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};qP.A=function(a,b){var c=oL(iG.A(a,b));return qP.B(c,a,b)};qP.B=function(a,b,c){return GN(c,wN(RO.B(a,b,c)),a)};qP.G=3;
var R2=p2a(kG,RF,iG,LF),HN=q2a(kG,RF,iG,QF,LF),JN=function JN(a){switch(arguments.length){case 2:return JN.A(arguments[0],arguments[1]);case 3:return JN.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};JN.A=function(a,b){var c=oL(iG.A(a,b));return JN.B(c,a,b)};JN.B=function(a,b,c){return GN(oL(c),HN(RO.B(a,b,c)),oL(a))};JN.G=3;
var S2=function S2(a){switch(arguments.length){case 1:return S2.j(arguments[0]);case 2:return S2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};S2.j=function(a){return S2.A(a,a)};S2.A=function(a,b){return vN.B(a,b,$APP.Le(0))};S2.G=2;var T2=function T2(a){switch(arguments.length){case 1:return T2.j(arguments[0]);case 2:return T2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
T2.j=function(a){var b=$APP.tf(a);a=$APP.Tc(b);return vN.B(a,a,function(c,d){return $APP.Uc.A(c,d)?b.j?b.j(c):b.call(null,c):0})};T2.A=function(a,b){return vN.B(a,a,function(c,d){return $APP.Uc.A(c,d)?b:0})};T2.G=2;var U2=function U2(a){switch(arguments.length){case 1:return U2.j(arguments[0]);case 2:return U2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};U2.j=function(a){return U2.A(a,zL.J())};
U2.A=function(a,b){var c=pN(a),d=qN(a);$APP.Uc.A(c,d)||AD("not square");b=T2.A(c,b);return R2(RF.A(b,a))};U2.G=2;var LN=v2a(kG,RF,iG,QF,LF);KF.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return $APP.Ge(function(b){return $APP.Ge(KF,b)},a)});sG.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(){return!1});iZ.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return u2a(a)});tG.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return tN(tG,a)});
NF.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return t2a(a)});jZ.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return t2a(a)});aG.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return $APP.Uc.A(a.c,1)?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,zjb,null,1,null),$APP.Vg.A($APP.Hl.A(aG,$APP.u),a.v)))):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,LFb,null,1,null),$APP.Vg.A(function(b){return $APP.Fl.A(aG,b)},a.v))))});
TF.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return $APP.Ge(function(b){return $APP.Ge(TF,b)},a.v)});fG.F(null,new $APP.H(null,2,5,$APP.I,[kV,kV],null),function(a,b){return sN(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[uT,FF],null),function(a,b){var c=rN(a);c?(c=pN(a),b=T2.A?T2.A(c,b):T2.call(null,c,b),a=sN(a,b)):a=c;return a});fG.F(null,new $APP.H(null,2,5,$APP.I,[FF,uT],null),function(a,b){var c=rN(b);c?(c=pN(b),a=T2.A?T2.A(c,a):T2.call(null,c,a),b=sN(a,b)):b=c;return b});
PF.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return tN(PF,a)});yG.F(null,new $APP.H(null,2,5,$APP.I,[kV,kV],null),function(a,b){return yN(RF,a,b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[uT,FF],null),function(a,b){return yN(RF,a,T2.A(pN(a),b))});yG.F(null,new $APP.H(null,2,5,$APP.I,[FF,uT],null),function(a,b){return yN(RF,T2.A(pN(b),a),b)});eH.F(null,new $APP.H(null,2,5,$APP.I,[kV,kV],null),function(a,b){return yN(kG,a,b)});
eH.F(null,new $APP.H(null,2,5,$APP.I,[uT,FF],null),function(a,b){return yN(kG,a,T2.A(pN(a),b))});eH.F(null,new $APP.H(null,2,5,$APP.I,[FF,uT],null),function(a,b){return yN(kG,T2.A(pN(b),a),b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[kV,kV],null),function(a,b){return $1a(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[FF,kV],null),function(a,b){return a2a(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[kV,FF],null),function(a,b){return b2a(a,b)});
MF.F(null,new $APP.H(null,2,5,$APP.I,[kV,SK],null),function(a,b){return d2a(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[XK,kV],null),function(a,b){return e2a(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[kV,FF],null),function(a,b){return b2a(a,OF.j(b))});zG.F(null,new $APP.H(null,2,5,$APP.I,[FF,uT],null),function(a,b){return a2a(a,HN(b))});zG.F(null,new $APP.H(null,2,5,$APP.I,[ZU,uT],null),function(a,b){return MN(a,b)});
zG.F(null,new $APP.H(null,2,5,$APP.I,[XW,uT],null),function(a,b){return MN(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[SK,uT],null),function(a,b){return MN(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[XK,uT],null),function(a,b){return MN(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[kV,uT],null),function(a,b){return $1a(a,HN(b))});oG.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return OK.j?OK.j(a):OK.call(null,a)});
fO.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return m1.j?m1.j(a):m1.call(null,a)});gO.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return l1.j?l1.j(a):l1.call(null,a)});tZ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return n1.j?n1.j(a):n1.call(null,a)});wZ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return o1.j?o1.j(a):o1.call(null,a)});kO.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return q1.j?q1.j(a):q1.call(null,a)});
xZ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return p1.j?p1.j(a):p1.call(null,a)});rG.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return r1.j?r1.j(a):r1.call(null,a)});yZ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return s1.j?s1.j(a):s1.call(null,a)});tH.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return u1.j?u1.j(a):u1.call(null,a)});vH.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return t1.j?t1.j(a):t1.call(null,a)});
BZ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return v1.j?v1.j(a):v1.call(null,a)});GZ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return w1.j?w1.j(a):w1.call(null,a)});HZ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return x1.j?x1.j(a):x1.call(null,a)});bG.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return tN(bG,a)});OF.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return HN(a)});
NZ.F(null,new $APP.H(null,2,5,$APP.I,[kV,kV],null),function(a,b){return yN(NZ,a,b)});OZ.F(null,new $APP.H(null,2,5,$APP.I,[kV,kV],null),function(a,b){return yN(OZ,a,b)});xH.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return tN(xH,a)});AH.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return tN(AH,a)});qL.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return tN(qL,a)});eR.F(null,new $APP.H(null,1,5,$APP.I,[kV],null),function(a){return wN(a)});
ZQ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return R2(a)});ZQ.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return zN(a,function(b){return R2(b)})});QZ.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return o2a(a)});QZ.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return zN(a,function(b){return o2a(b)})});OF.F(null,new $APP.H(null,1,5,$APP.I,[aS],null),function(a){return k2a(a)});
zG.F(null,new $APP.H(null,2,5,$APP.I,[aS,aS],null),function(a,b){return r2a(b,a)});VF.F(null,new $APP.H(null,2,5,$APP.I,[uT,SK],null),function(a,b){return MN(b,a)});VF.F(null,new $APP.H(null,2,5,$APP.I,[uT,XK],null),function(a,b){return MN(b,a)});VF.F(null,new $APP.H(null,2,5,$APP.I,[uT,ZU],null),function(a,b){return MN(b,a)});VF.F(null,new $APP.H(null,2,5,$APP.I,[uT,XW],null),function(a,b){return MN(b,a)});VF.F(null,new $APP.H(null,2,5,$APP.I,[aS,aS],null),function(a,b){return r2a(a,b)});
VF.F(null,new $APP.H(null,2,5,$APP.I,[aS,FF],null),function(a,b){return e_a(k2a(a),b)});cR.F(null,new $APP.H(null,2,5,$APP.I,[XW,uT],null),function(a,b){return MN(a,b)});cR.F(null,new $APP.H(null,2,5,$APP.I,[FCb,uT],null),function(a,b){return MN(a,b)});cR.F(null,new $APP.H(null,2,5,$APP.I,[aS,aS],null),function(a,b){return s2a(a,b)});cR.F(null,new $APP.H(null,2,5,$APP.I,[FF,aS],null),function(a,b){return f_a(a,k2a(b))});LO.F(null,new $APP.H(null,1,5,$APP.I,[uT],null),function(a){return pN(a)});
LO.F(null,new $APP.H(null,1,5,$APP.I,[ZU],null),function(a){return pN(a)});LO.F(null,new $APP.H(null,1,5,$APP.I,[XW],null),function(a){return qN(a)});BH.F(null,new $APP.H(null,2,5,$APP.I,[XW,XW],null),function(a,b){return BH.A(DN(a),DN(b))});BH.F(null,new $APP.H(null,2,5,$APP.I,[ZU,ZU],null),function(a,b){return BH.A(BN(a),BN(b))});RZ.F(null,new $APP.H(null,2,5,$APP.I,[XW,XW],null),function(a,b){return RZ.A(EN(a),EN(b))});
RZ.F(null,new $APP.H(null,2,5,$APP.I,[ZU,ZU],null),function(a,b){return RZ.A(BN(a),BN(b))});TZ.F(null,new $APP.H(null,2,5,$APP.I,[XW,XW],null),function(a,b){return CN.C($APP.y([RK(TZ.A(EN(a),EN(b)))]))});TZ.F(null,new $APP.H(null,2,5,$APP.I,[ZU,ZU],null),function(a,b){return uN(TZ.A(BN(a),BN(b)))});SZ.F(null,new $APP.H(null,2,5,$APP.I,[ZU,XW],null),function(a,b){return $1a(a,b)});mR.F(null,new $APP.H(null,2,5,$APP.I,[kV,YR],null),function(a,b){return tN(function(c){return mR.A(c,b)},a)});$APP.hu.A(rV,TH);$APP.e=B2a.prototype;$APP.e.rb=function(){return rV};$APP.e.bc=function(){return this.arity};$APP.e.toString=function(){return $APP.m.j(this.qd)};$APP.e.Y=function(a,b){return D2a.A?D2a.A(this,b):D2a.call(null,this,b)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};
$APP.e.call=function(a){switch(arguments.length-1){case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.M(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);case 11:return this.xa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13]);
case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],arguments[2],arguments[3],arguments[4],
arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],
arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Lb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],
arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.j=function(a){a=new $APP.H(null,1,5,$APP.I,[a],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.A=function(a,b){a=new $APP.H(null,2,5,$APP.I,[a,b],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};
$APP.e.B=function(a,b,c){a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.M=function(a,b,c,d){a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.S=function(a,b,c,d,g){a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.la=function(a,b,c,d,g,l){a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};
$APP.e.Ga=function(a,b,c,d,g,l,n){a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.va=function(a,b,c,d,g,l,n,p){a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};
$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};
$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};
$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q){a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W){a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};
$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z){a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa){a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};
$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha){a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.e.Lb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja){a=$APP.N.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null),ja);return XN.A?XN.A(this,a):XN.call(null,this,a)};$APP.hu.A(B2a,rV);
TN.j=function(a){return SN(a,new $APP.H(null,2,5,$APP.I,[fI,1],null),new $APP.H(null,1,5,$APP.I,[0],null),0)};TN.A=function(a,b){var c=A2a(b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return TN.B(a,b,c)};TN.B=function(a,b,c){if("number"===typeof c){var d=$APP.od(b)?$APP.Tc(b):1;return SN(a,new $APP.H(null,2,5,$APP.I,[fI,d],null),$APP.od(b)?b:new $APP.H(null,1,5,$APP.I,[b],null),c)}return VK(c)?(d=$APP.Tc(c),a=eL(a,d,TK(c)),kL.C(function(g,l){return TN.B(g,b,l)},$APP.y([a,c]))):AD(["WTF range",$APP.m.j(c)].join(""))};
TN.G=3;VN.C=function(a,b,c,d){$APP.rg.B(b,zX,!0);a=E2a(c);a=$APP.Lf.B($APP.sf,$APP.eh,a);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.fm,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([d]))))};VN.G=3;VN.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};bG.F(null,new $APP.H(null,1,5,$APP.I,[rV],null),function(a){return SN(bG.j(a.qd),SH(a),a.domain,a.range)});
tG.F(null,new $APP.H(null,1,5,$APP.I,[rV],null),function(a){return function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(){return tG.j(a.range)}b.G=0;b.K=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}()});
NF.F(null,new $APP.H(null,1,5,$APP.I,[rV],null),function(a){return function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(){return NF.j(a.range)}b.G=0;b.K=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}()});jZ.F(null,new $APP.H(null,1,5,$APP.I,[rV],null),function(a){return $APP.z($APP.Kd,new $APP.f(null,2,[XH,a.arity,aI,APb],null))});
TF.F(null,new $APP.H(null,1,5,$APP.I,[rV],null),function(a){return WH.C($APP.y([TF,a]))});aG.F(null,new $APP.H(null,1,5,$APP.I,[rV],null),function(a){return aG.j(a.qd)});var dO={},S2a={},eO,T2a;var HQ=function HQ(a){switch(arguments.length){case 1:return HQ.j(arguments[0]);case 2:return HQ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};HQ.j=function(a){return HQ.A(a,1)};HQ.A=function(a,b){return $APP.af(function(c){return a*c},b)};HQ.G=2;
var V2=function V2(a){switch(arguments.length){case 1:return V2.j(arguments[0]);case 2:return V2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};V2.j=function(a){return V2.A(a,1)};V2.A=function(a,b){return $APP.af(function(c){return c/a},b)};V2.G=2;
var DQ=function DQ(a){switch(arguments.length){case 1:return DQ.j(arguments[0]);case 2:return DQ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};DQ.j=function(a){return DQ.A(a,$APP.F)};
DQ.A=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,Dib,2),d=$APP.C.A(b,QHb),g=$APP.C.B(b,Z$a,HR);b=$APP.C.B(b,Ryb,Y2a(g));if($APP.hd(a))return new $APP.f(null,3,[oQ,!1,CQ,0,nQ,null],null);var l=$APP.k(d)?function(A){return A>=d}:$APP.Le(!1);g=$APP.r(a);$APP.u(g);g=$APP.w(g);$APP.x.B(g,0,null);g=a;for(a=1;;){var n=$APP.r(g);g=$APP.u(n);var p=n=$APP.w(n);n=$APP.x.B(p,0,null);if($APP.hd(p))return new $APP.f(null,3,[oQ,!1,CQ,a,nQ,g],null);var v=a+1,t=b.A?b.A(g,n):b.call(null,g,n);if($APP.k(function(){var A=
v>=c;return A?(A=t,$APP.k(A)?A:l(v)):A}()))return new $APP.f(null,3,[oQ,t,CQ,v,nQ,n],null);a=v;g=p}};DQ.G=2;var W2=function W2(a){switch(arguments.length){case 1:return W2.j(arguments[0]);case 2:return W2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};W2.j=function(a){return W2.A(a,null)};
W2.A=function(a,b){b=null==b?MR:iG.A(b,MR);b=Y2a(b);var c=$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[2,2],null)),d=EF(c);$APP.k(d?b(c,-1):d)?(b=Math.PI,c=RF.j(rG.A(RF.j($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[0,1],null))),$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[0,0],null)))),a=0):$APP.k(d?b(c,1):d)?(b=0,c=rG.A(RF.j($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[0,1],null))),$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[0,0],null))),a=0):(b=kO.j(c),d=gO.j(b),c=rG.A(QF.A($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[0,2],
null)),d),RF.j(QF.A($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[1,2],null)),d))),a=rG.A(QF.A($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[2,0],null)),d),QF.A($APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[2,1],null)),d)));return uL.C($APP.y([b,c,a]))};W2.G=2;var JO={},X2,Y2,Z2,$2,KO,MO,NO,OO,a3,b3,c3=function c3(a){switch(arguments.length){case 1:return c3.j(arguments[0]);case 2:return c3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};c3.j=function(a){return c3.A(a,NN)};c3.A=function(a,b){return new $APP.f(null,4,[n3a,b,LNb,a,qO,$APP.F,$APP.Ti,j3a],null)};c3.G=2;
var d3=function d3(a){switch(arguments.length){case 2:return d3.A(arguments[0],arguments[1]);case 3:return d3.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};d3.A=function(a,b){return d3.B(a,b,b)};d3.B=function(a,b,c){return new $APP.f(null,5,[m3a,a,$APP.R,HG(LNb.j(a),b),FO,b,P3a,c,$APP.Ti,oO],null)};d3.G=3;
var e3=function e3(a){switch(arguments.length){case 1:return e3.j(arguments[0]);case 2:return e3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};e3.j=function(a){var b=IO(a);return e3.A(a,b)};
e3.A=function(a,b){var c=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof X2)X2=function(d,g,l,n){this.Pa=d;this.Ub=g;this.id=l;this.uk=n;this.O=393216;this.U=0},X2.prototype.da=function(d,g){return new X2(this.Pa,this.Ub,this.id,g)},X2.prototype.ba=function(){return this.uk},X2.prototype.cd=$APP.xc,X2.prototype.Cc=function(d,g){return $APP.Uc.A(UK(g),FO.j(this.Pa))},X2.prototype.Mc=function(d,g){return xO(g,this.Pa)},
X2.prototype.Nc=function(d,g){return vO(g,this.Pa,this,g)},X2.prototype.Oc=function(d,g){return yO(g,this,function(){return wO(g)})},X2.prototype.dd=function(){return this.id},X2.cb=!0,X2.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40746",X2.gb=function(d){return $APP.Vb(d,"emmy.calculus.manifold/t_emmy$calculus$manifold40746")};return new X2(a,b,c,$APP.F)}(),new $APP.f(null,2,[BO,b,oO,a],null))};e3.G=2;
var f3=function f3(a){switch(arguments.length){case 1:return f3.j(arguments[0]);case 2:return f3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};f3.j=function(a){var b=IO(a);return f3.A(a,b)};
f3.A=function(a,b){var c=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof Y2)Y2=function(d,g,l,n){this.Pa=d;this.Ub=g;this.id=l;this.vk=n;this.O=393216;this.U=0},Y2.prototype.da=function(d,g){return new Y2(this.Pa,this.Ub,this.id,g)},Y2.prototype.ba=function(){return this.vk},Y2.prototype.cd=$APP.xc,Y2.prototype.Cc=function(d,g){return(d=WK(g))?(d=$APP.Uc.A(UK(g),FO.j(this.Pa)))?(d=1<UK(g))?(g=$APP.x.A(g,0),!EF(g)||0<=
g):d:d:d},Y2.prototype.Mc=function(d,g){return xO(g,this.Pa)},Y2.prototype.Nc=function(d,g){d=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);return vO($APP.rg.B($APP.rg.B(g,0,iG.A(d,fO.j(l))),1,iG.A(d,gO.j(l))),this.Pa,this,g)},Y2.prototype.Oc=function(d,g){var l=this;return yO(g,this,function(){var n=wO(g);WK(n)&&$APP.Uc.A(UK(n),P3a.j(l.Pa))||AD("PolarCylindrical bad point");var p=$APP.x.B(n,0,null),v=$APP.x.B(n,1,null),t=kG.A(lG.j(p),lG.j(v));$APP.k(KF.j(t))&&BD("PolarCylindrical singular");return $APP.rg.B($APP.rg.B(n,
0,jG.j(t)),1,rG.A(v,p))})},Y2.prototype.dd=function(){return this.id},Y2.cb=!0,Y2.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40751",Y2.gb=function(d){return $APP.Vb(d,"emmy.calculus.manifold/t_emmy$calculus$manifold40751")};return new Y2(a,b,c,$APP.F)}(),new $APP.f(null,2,[BO,b,oO,a],null))};f3.G=2;
var g3=function g3(a){switch(arguments.length){case 1:return g3.j(arguments[0]);case 2:return g3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};g3.j=function(a){var b=IO(a);return g3.A(a,b)};
g3.A=function(a,b){var c=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof Z2)Z2=function(d,g,l,n){this.Pa=d;this.Ub=g;this.id=l;this.wk=n;this.O=393216;this.U=0},Z2.prototype.da=function(d,g){return new Z2(this.Pa,this.Ub,this.id,g)},Z2.prototype.ba=function(){return this.wk},Z2.prototype.cd=$APP.xc,Z2.prototype.Cc=function(d,g){return(d=WK(g))?(d=$APP.Uc.A(LO.j(g),FO.j(this.Pa)))?$APP.k($APP.Ws)?!EF(g)||0<=$APP.x.A(g,
0):$APP.Ws:d:d},Z2.prototype.Mc=function(d,g){return xO(g,this.Pa)},Z2.prototype.Nc=function(d,g){d=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null),n=$APP.x.B(g,2,null);return vO($APP.rg.B($APP.rg.B($APP.rg.B(g,0,iG.C(d,gO.j(l),$APP.y([fO.j(n)]))),1,iG.C(d,gO.j(l),$APP.y([gO.j(n)]))),2,iG.A(d,fO.j(l))),this.Pa,this,g)},Z2.prototype.Oc=function(d,g){var l=this;return yO(g,this,function(){var n=wO(g);WK(n)&&$APP.Uc.A(LO.j(n),P3a.j(l.Pa))||AD("SphericalCylindrical bad point");var p=$APP.x.B(n,0,null),v=
$APP.x.B(n,1,null),t=$APP.x.B(n,2,null),A=jG.j(kG.C(lG.j(p),lG.j(v),$APP.y([lG.j(t)])));$APP.k(KF.j(A))&&BD("SphericalCylindrical singular");return $APP.rg.B($APP.rg.B($APP.rg.B(n,0,A),1,kO.j(QF.A?QF.A(t,A):QF.call(null,t,A))),2,rG.A(v,p))})},Z2.prototype.dd=function(){return this.id},Z2.cb=!0,Z2.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40762",Z2.gb=function(d){return $APP.Vb(d,"emmy.calculus.manifold/t_emmy$calculus$manifold40762")};return new Z2(a,b,c,$APP.F)}(),new $APP.f(null,2,[BO,
b,oO,a],null))};g3.G=2;var h3=function h3(a){switch(arguments.length){case 1:return h3.j(arguments[0]);case 2:return h3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};h3.j=function(a){var b=IO(a);return h3.A(a,b)};
h3.A=function(a,b){var c=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof $2)$2=function(d,g,l,n){this.Pa=d;this.Ub=g;this.id=l;this.xk=n;this.O=393216;this.U=0},$2.prototype.da=function(d,g){return new $2(this.Pa,this.Ub,this.id,g)},$2.prototype.ba=function(){return this.xk},$2.prototype.cd=$APP.xc,$2.prototype.Cc=function(d,g){return WK(g)&&$APP.Uc.A(LO.j(g),4)},$2.prototype.Mc=function(d,g){return xO(g,this.Pa)},$2.prototype.Nc=
function(d,g){d=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null),n=$APP.x.B(g,2,null),p=$APP.x.B(g,3,null);return vO(uL.C($APP.y([d,iG.C(l,gO.j(n),$APP.y([fO.j(p)])),iG.C(l,gO.j(n),$APP.y([gO.j(p)])),iG.A(l,fO.j(n))])),this.Pa,this,g)},$2.prototype.Oc=function(d,g){var l=this;return yO(g,l,function(){var n=wO(g);if($APP.eb(l.Cc(null,n)))throw $APP.Zi.A("bad -\x3eSpacetimeSpherical point: ",new $APP.f(null,2,[$APP.PO,g,GO,l],null));var p=$APP.x.B(n,0,null),v=$APP.x.B(n,1,null),t=$APP.x.B(n,2,null);n=$APP.x.B(n,
3,null);var A=jG.j(kG.C(lG.j(v),lG.j(t),$APP.y([lG.j(n)])));var B=(B=EF(A))?KF.j(A):B;if($APP.k(B))throw $APP.Zi.A("-\x3eSpacetimeSpherical singular: ",new $APP.f(null,2,[$APP.PO,g,GO,l],null));return uL.C($APP.y([p,A,kO.j(QF.A(n,A)),rG.A(t,v)]))})},$2.prototype.dd=function(){return this.id},$2.cb=!0,$2.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40773",$2.gb=function(d){return $APP.Vb(d,"emmy.calculus.manifold/t_emmy$calculus$manifold40773")};return new $2(a,b,c,$APP.F)}(),new $APP.f(null,
2,[BO,b,oO,a],null))};h3.G=2;var i3=function i3(a){switch(arguments.length){case 1:return i3.j(arguments[0]);case 2:return i3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};i3.j=function(a){var b=IO(a);return i3.A(a,b)};
i3.A=function(a,b){var c=FO.j(a),d=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof a3)a3=function(g,l,n,p,v){this.Pa=g;this.Ub=l;this.n=n;this.id=p;this.Ck=v;this.O=393216;this.U=0},a3.prototype.da=function(g,l){return new a3(this.Pa,this.Ub,this.n,this.id,l)},a3.prototype.ba=function(){return this.Ck},a3.prototype.cd=$APP.xc,a3.prototype.Cc=function(g,l){return(g=WK(l))?(g=$APP.Uc.A(LO.j(l),this.n))?(l=$APP.x.A(l,0),
!EF(l)||$APP.eb(KF.j(l))):g:g},a3.prototype.Mc=function(g,l){return xO(l,this.Pa)},a3.prototype.Nc=function(g,l){var n=$APP.x.B(l,0,null),p=$APP.x.B(l,1,null);g=$APP.x.B(l,2,null);n=hO(n);p=jO(p);g=jO(g);g=iG.C(p,n,$APP.y([g]));return vO(g,this.Pa,this,l)},a3.prototype.Oc=function(g,l){return yO(l,this,function(){var n=wO(l),p=kO.j($APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[2,2],null))),v=rG.A($APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[0,2],null)),PF.j($APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[1,2],null))));
n=rG.A($APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[2,0],null)),$APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[2,1],null)));return uL.C($APP.y([p,v,n]))})},a3.prototype.dd=function(){return this.id},a3.cb=!0,a3.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40815",a3.gb=function(g){return $APP.Vb(g,"emmy.calculus.manifold/t_emmy$calculus$manifold40815")};return new a3(a,b,c,d,$APP.F)}(),new $APP.f(null,2,[BO,b,oO,a],null))};i3.G=2;
var j3=function j3(a){switch(arguments.length){case 1:return j3.j(arguments[0]);case 2:return j3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};j3.j=function(a){var b=IO(a);return j3.A(a,b)};
j3.A=function(a,b){var c=FO.j(a),d=zD();return $APP.z(function(){if("undefined"===typeof cM||"undefined"===typeof dO||"undefined"===typeof JO||"undefined"===typeof b3)b3=function(g,l,n,p,v){this.Pa=g;this.Ub=l;this.n=n;this.id=p;this.Dk=v;this.O=393216;this.U=0},b3.prototype.da=function(g,l){return new b3(this.Pa,this.Ub,this.n,this.id,l)},b3.prototype.ba=function(){return this.Dk},b3.prototype.cd=$APP.xc,b3.prototype.Cc=function(g,l){return WK(l)&&$APP.Uc.A(LO.j(l),this.n)&&(!EF($APP.x.A(l,0))||
Math.PI/-2<$APP.x.A(l,0)&&$APP.x.A(l,0)<Math.PI/2)},b3.prototype.Mc=function(g,l){return xO(l,this.Pa)},b3.prototype.Nc=function(g,l){var n=$APP.x.B(l,0,null),p=$APP.x.B(l,1,null);g=$APP.x.B(l,2,null);n=hO(n);p=jO(p);g=iO(g);g=iG.C(p,n,$APP.y([g]));return vO(g,this.Pa,this,l)},b3.prototype.Oc=function(g,l){return yO(l,this,function(){var n=wO(l),p=xZ.j($APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[2,1],null))),v=rG.A(PF.j($APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[0,1],null))),$APP.Zl.A(n,new $APP.H(null,
2,5,$APP.I,[1,1],null)));n=rG.A(PF.j($APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[2,0],null))),$APP.Zl.A(n,new $APP.H(null,2,5,$APP.I,[2,2],null)));return uL.C($APP.y([p,v,n]))})},b3.prototype.dd=function(){return this.id},b3.cb=!0,b3.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold40823",b3.gb=function(g){return $APP.Vb(g,"emmy.calculus.manifold/t_emmy$calculus$manifold40823")};return new b3(a,b,c,d,$APP.F)}(),new $APP.f(null,2,[BO,b,oO,a],null))};j3.G=2;
var k3=sO(sO(sO(rO(c3.j("R(%d)"),RR),eV,RR,e3),reb,RR,f3),jYb,RR,g3),Sqc=d3.A(k3,1),Tqc=tO(Sqc,eV,RR),Uqc=d3.A(k3,2),Vqc=tO(Uqc,eV,RR),Wqc=tO(Uqc,reb,RR),l3=d3.A(k3,3),Xqc=tO(l3,eV,RR),Yqc=tO(l3,reb,RR),Zqc=tO(l3,jYb,RR),$qc=d3.A(k3,4),arc=tO($qc,eV,RR),brc=tO($qc,reb,RR),crc=d3.A(sO(k3,G7b,RR,h3),4),drc=tO(crc,eV,RR),erc=tO(crc,G7b,RR),frc=sO(sO(sO(sO(sO(sO(sO(rO(rO(rO(c3.j("S2"),pY),WW),UR),EV,pY,R3a(QN.C($APP.y([uL.C($APP.y([1,0,0])),uL.C($APP.y([0,1,0])),uL.C($APP.y([0,0,1]))])))),EV,UR,R3a(QN.C($APP.y([uL.C($APP.y([1,
0,0])),uL.C($APP.y([0,0,1])),uL.C($APP.y([0,-1,0]))])))),EV,WW,R3a(QN.C($APP.y([uL.C($APP.y([1,0,0])),uL.C($APP.y([0,1,0])),uL.C($APP.y([0,0,-1]))])))),tS,pY,V3a(KN)),tS,WW,V3a(function(a){return vN.B(a,a,function(b,c){return $APP.Uc.A(b,c)?$APP.Uc.A(c,a)?-1:1:0})})),qY,pY,X3a(KN)),qY,WW,X3a(function(a){return vN.B(a,a,function(b,c){return $APP.Uc.A(b,c)?$APP.Uc.A(c,a)?-1:1:0})})),m3=d3.B(frc,2,3),grc=tO(m3,EV,pY),hrc=tO(m3,EV,UR),irc=tO(m3,tS,pY),jrc=tO(m3,qY,pY),n3=sO(sO(sO(sO(sO(sO(sO(rO(rO(rO(c3.j("S(%d)"),
pY),WW),UR),EV,pY,T3a(KN)),EV,WW,T3a(function(a){return vN.B(a,a,function(b,c){return $APP.Uc.A(b,c)?$APP.Uc.A(c,a)?-1:1:0})})),EV,UR,T3a(function(a){return cL(a,XK,function(b){return cL(a,SK,function(c){return $APP.Uc.A(c,a-2)&&$APP.Uc.A(b,a-1)?-1:$APP.Uc.A(c,a-1)&&$APP.Uc.A(b,a-2)?1:$APP.Uc.A(c,b)&&c<a-2?1:0})})})),qY,pY,X3a(KN)),qY,WW,X3a(function(a){return vN.B(a,a,function(b,c){return $APP.Uc.A(b,c)?$APP.Uc.A(c,a)?-1:1:0})})),tS,pY,V3a(KN)),tS,WW,V3a(function(a){return vN.B(a,a,function(b,c){return $APP.Uc.A(b,
c)?$APP.Uc.A(c,a)?-1:1:0})})),o3=d3.A(n3,1),krc=tO(o3,EV,pY),lrc=tO(o3,EV,UR),mrc=tO(o3,tS,pY),nrc=tO(o3,qY,pY),p3=d3.A(n3,2),orc=tO(p3,EV,pY),prc=tO(p3,EV,UR),qrc=tO(p3,tS,pY),rrc=tO(p3,qY,pY),q3=d3.A(n3,3),src=tO(q3,EV,pY),trc=tO(q3,EV,UR),urc=tO(q3,qY,pY),vrc=tO(q3,tS,WW),wrc=sO(sO(rO(rO(c3.j("SO3"),bsb),HAb),t_b,bsb,i3),qlb,HAb,j3),xrc=d3.A(wrc,3),yrc=tO(xrc,t_b,bsb),zrc=tO(xrc,qlb,HAb);var QO=function QO(a,b){return VH.B(function(){function d(n){var p=a.j?a.j(b):a.call(null,b);return p.j?p.j(n):p.call(null,n)}var g=null,l=function(){function n(v,t){var A=null;if(1<arguments.length){A=0;for(var B=Array(arguments.length-1);A<B.length;)B[A]=arguments[A+1],++A;A=new $APP.Bc(B,0,null)}return p.call(this,v,A)}function p(v,t){v=Z1a($APP.Yd(v,t));t=function(){function A(B){return $APP.Je.A(b,B)}return QO.A?QO.A(a,A):QO.call(null,a,A)}();return t.j?t.j(v):t.call(null,v)}n.G=1;n.K=function(v){var t=
$APP.u(v);v=$APP.Fc(v);return p(t,v)};n.C=p;return n}();g=function(n,p){switch(arguments.length){case 0:return 0;case 1:return d.call(this,n);default:var v=null;if(1<arguments.length){v=0;for(var t=Array(arguments.length-1);v<t.length;)t[v]=arguments[v+1],++v;v=new $APP.Bc(t,0,null)}return l.C(n,v)}throw Error("Invalid arity: "+arguments.length);};g.G=1;g.K=l.K;g.J=function(){return 0};g.j=d;g.C=l.C;return g}(),SH(b),new $APP.f(null,1,[aI,o2b],null))},r3=function r3(a){switch(arguments.length){case 1:return r3.j(arguments[0]);
case 2:return r3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};r3.j=function(a){return r3.A(a,$APP.sf)};r3.A=function(a,b){return QO(function(c){return L1a(c,b)},a)};r3.G=2;
for(var s3=ZM,t3=$APP.r(new $APP.H(null,2,5,$APP.I,[TH,aS],null)),u3=null,v3=0,w3=0;;)if(w3<v3){var Arc=u3.aa(null,w3);mR.F(null,new $APP.H(null,2,5,$APP.I,[Arc,YR],null),function(){return function(a,b){return $APP.Uc.A(s3,RH)?a4a(a,b):r3.A(a,b)}}(t3,u3,v3,w3,Arc));mR.F(null,new $APP.H(null,2,5,$APP.I,[Arc,null],null),function(){return function(a){return $APP.Uc.A(s3,RH)?a4a(a,$APP.sf):r3.A(a,$APP.sf)}}(t3,u3,v3,w3,Arc));w3+=1}else{var Brc=$APP.r(t3);if(Brc){var x3=Brc;if($APP.pd(x3)){var Crc=$APP.lc(x3),
Drc=$APP.mc(x3),Erc=Crc,Frc=$APP.Tc(Crc);t3=Drc;u3=Erc;v3=Frc}else{var Grc=$APP.u(x3);mR.F(null,new $APP.H(null,2,5,$APP.I,[Grc,YR],null),function(){return function(a,b){return $APP.Uc.A(s3,RH)?a4a(a,b):r3.A(a,b)}}(t3,u3,v3,w3,Grc,x3,Brc));mR.F(null,new $APP.H(null,2,5,$APP.I,[Grc,null],null),function(){return function(a){return $APP.Uc.A(s3,RH)?a4a(a,$APP.sf):r3.A(a,$APP.sf)}}(t3,u3,v3,w3,Grc,x3,Brc));t3=$APP.w(x3);u3=null;v3=0}w3=0}else break}
var Hrc=JK.A(function(a){var b=s3;s3=RH;try{return mR.A(a,$APP.sf)}finally{s3=b}},cH),SO=JK.A(function(a){var b=s3;s3=ZM;try{return mR.A(a,$APP.sf)}finally{s3=b}},cH),y3=function y3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return y3.C(c)};y3.C=function(a){return JK.A(function(b){var c=s3;s3=RH;try{return mR.A(b,a)}finally{s3=c}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Rw,null,1,null),a))))};y3.G=0;
y3.K=function(a){return this.C($APP.r(a))};var QQ=function QQ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return QQ.C(c)};QQ.C=function(a){return JK.A(function(b){var c=s3;s3=ZM;try{return mR.A(b,a)}finally{s3=c}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Rw,null,1,null),a))))};QQ.G=0;QQ.K=function(a){return this.C($APP.r(a))};
var z3=function z3(a){switch(arguments.length){case 1:return z3.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return z3.C(arguments[0],c)}};z3.j=function(a){return z3.C(a,$APP.y([0]))};z3.C=function(a,b){var c=$APP.Je,d=c.A,g=oG.j(SO);a=g.j?g.j(a):g.call(null,a);return PXa(d.call(c,a,b))};z3.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};z3.G=1;
var A3=function A3(a){switch(arguments.length){case 1:return A3.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return A3.C(arguments[0],c)}};A3.j=function(a){return A3.C(a,$APP.y([0]))};
A3.C=function(a,b){var c=$APP.Vg.A(lL,b),d=$APP.Bg($APP.ef(c),$APP.ef(b));a=$APP.Je.B(z3,a,c);return VI(function(g){return bG.j(kL.C(function p(n){return LH(n)?QH.B(p(PH.j(n)),p(WN.j(n)),MH(n)):WM(n)?D1a(n.tag,n.id,p(XM(n)),$APP.Fl.A(function(v){var t=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);return new $APP.H(null,2,5,$APP.I,[p(t),p(v)],null)},n.Ud)):UZ.A(bG.j(n),d)},$APP.y([g])))},a)};A3.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};A3.G=1;$APP.hu.A(TO,EW);var XO=function XO(a){switch(arguments.length){case 2:return XO.A(arguments[0],arguments[1]);case 3:return XO.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};XO.A=function(a,b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.zeb,null,1,null),new $APP.D(null,a,null,1,null))));return XO.B(a,b,c)};XO.B=function(a,b,c){return WO(YH($APP.Hl.A(YH,f4a(a,b))),c)};XO.G=3;
var B3=function B3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return B3.C(arguments[0],c)};B3.C=function(a,b){return function(c){var d=WH,g=d.C;c=WH.C($APP.y([c,EO(a)]));var l=$APP.Je.A(QQ,b);c=l.j?l.j(c):l.call(null,c);return g.call(d,$APP.y([c,DO(a)]))}};B3.G=1;B3.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var YO=function YO(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return YO.C(arguments[0],arguments[1],c)};YO.C=function(a,b,c){a=$APP.Je.B(B3,a,c);return WO(YH($APP.Hl.A(YH,a)),b)};YO.G=2;YO.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var w4a={},$O,x4a,C3=function C3(a,b){return 0===b?$APP.M($APP.Ec):$APP.hd(a)?$APP.Ec:$APP.N.A($APP.Vg.A(function(d){return $APP.Vd.A(d,$APP.u(a))},function(){var d=$APP.Fc(a),g=b-1;return C3.A?C3.A(d,g):C3.call(null,d,g)}()),function(){var d=$APP.Fc(a);return C3.A?C3.A(d,b):C3.call(null,d,b)}())},yP=function yP(a){return $APP.hd(a)?$APP.M($APP.Ec):function g(d){return new $APP.de(null,function(){for(var l=d;;){var n=$APP.r(l);if(n){var p=n,v=$APP.u(p);if(n=$APP.r(function(t,A,B,G){return function Q(O){return new $APP.de(null,
function(W,Z){return function(){for(;;){var fa=$APP.r(O);if(fa){if($APP.pd(fa)){var ha=$APP.lc(fa),ja=$APP.Tc(ha),ta=$APP.fe(ja);a:for(var ua=0;;)if(ua<ja){var ca=$APP.bd(ha,ua);$APP.je(ta,$APP.Yd(ca,Z));ua+=1}else{ha=!0;break a}return ha?$APP.ie($APP.ke(ta),Q($APP.mc(fa))):$APP.ie($APP.ke(ta),null)}ta=$APP.u(fa);return $APP.Yd($APP.Yd(ta,Z),Q($APP.Fc(fa)))}return null}}}(t,A,B,G),null,null)}}(l,v,p,n)($APP.u(a))))return $APP.N.A(n,g($APP.Fc(l)));l=$APP.Fc(l)}else return null}},null,null)}(function(){var d=
$APP.Fc(a);return yP.j?yP.j(d):yP.call(null,d)}())},D3=function D3(a){switch(arguments.length){case 1:return D3.j(arguments[0]);case 2:return D3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};D3.j=function(a){a=r4a(a);return $APP.Ie(a)?1:-1};D3.A=function(a,b){var c;if(c=$APP.Uc.A($APP.Tc(a),$APP.Tc(b)))c=$APP.Uc.A($APP.Ts.A($APP.yc,a),$APP.Ts.A($APP.yc,b));return c?$APP.Ie(q4a(a,b))?1:-1:0};D3.G=2;$APP.hu.A(eP,bP);$APP.hu.A(bP,EW);
var F4a=new $APP.f(null,5,[$APP.c4a,function(a){return cP(a)&&$APP.Uc.A(EK(a),B4a)},HWa,function(a){return JK.B(B4a,OKb,HK(a))},JWa,function(){return yD("form fields don't have an identity.")},Seb,function(){return!1},APb,function(){return yD("form fields don't have a multiplicative identity.")}],null),gP=function gP(a){switch(arguments.length){case 2:return gP.A(arguments[0],arguments[1]);case 3:return gP.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));
}};gP.A=function(a,b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,rvb,null,1,null),new $APP.D(null,aG.j(a),null,1,null))));return gP.B(a,b,c)};gP.B=function(a,b,c){return fP(G4a(a,b),c)};gP.G=3;var E3=function E3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return E3.C(arguments[0],c)};
E3.C=function(a,b){return function(c){return kL.C(function(d){var g=WH.C($APP.y([$APP.Je.A(rP,b),DO(a)]));return d.j?d.j(g):d.call(null,g)},$APP.y([c]))}};E3.G=1;E3.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var hP=function hP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return hP.C(arguments[0],arguments[1],c)};hP.C=function(a,b,c){a=$APP.Je.B(E3,a,c);return fP(YH($APP.Hl.A(YH,a)),b)};
hP.G=2;hP.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var F3=function F3(a){switch(arguments.length){case 0:return F3.J();case 1:return F3.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return F3.C(arguments[0],c)}};F3.J=function(){return $APP.Le(1)};F3.j=function(a){return a};F3.C=function(a,b){return $APP.Id.A(function(c,d){return O4a(d,c)},$APP.Wd($APP.Yd(a,b)))};
F3.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};F3.G=1;MF.F(null,new $APP.H(null,2,5,$APP.I,[bP,bP],null),function(a,b){return O4a(a,b)});var G3=function G3(a){switch(arguments.length){case 1:return G3.j(arguments[0]);case 2:return G3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};G3.j=function(a){return a};G3.A=function(a,b){var c=aP(a),d=aP(b);return iG.A(FI(c+d)/(FI(c)*FI(d)),Q4a(S4a(a,b)))};G3.G=2;
var H3=function H3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return H3.C(c)};H3.C=function(a){return $APP.Id.B(G3,$APP.Le(1),a)};H3.G=0;H3.K=function(a){return this.C($APP.r(a))};
var UP=JK.A(function(a){function b(d,g){return $APP.N.A($APP.We.A(d,g),$APP.Se.A(d+1,g))}var c=aP(a);return $APP.Uc.A(c,0)?kP.j?kP.j(a):kP.call(null,a):dP(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return function(n){var p=FO.j(A3a(n));if(c<p){p=function(t){var A=b(t,l);return kG.A(iG.A($APP.Ie(t)?1:-1,function(){var B=$APP.Je.A(a,A);var G=$APP.x.A(l,
t);B=G.j?G.j(B):G.call(null,B);return B.j?B.j(n):B.call(null,n)}()),function(){function B(O){var Q=iG.A,W=$APP.Ie(t+O)?1:-1;O=$APP.Je.A(a,$APP.Yd(NK($APP.x.A(l,t),$APP.x.A(l,O)),b(O-1,A)));O=O.j?O.j(n):O.call(null,n);return Q.call(iG,W,O)}var G=t+1,J=c+1;return hL.B?hL.B(B,G,J):hL.call(null,B,G,J)}())};var v=c+1;return hL.B?hL.B(p,0,v):hL.call(null,p,0,v)}return 0}}d.G=0;d.K=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),c+1,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.jP,null,1,null),new $APP.D(null,
aG.j(a),null,1,null)))))},$APP.jP);$APP.hu.A(T4a,Y4a);var I3=function I3(a){switch(arguments.length){case 1:return I3.j(arguments[0]);case 2:return I3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};I3.j=function(a){return I3.A(a,null)};I3.A=function(a,b){return function(c){return UO(c)?null==b?AD("Pullback of a vector requires inverse map"):r5a(b,a)(c):z5a(a)(c)}};I3.G=2;var J3=function J3(a){var c=aG.j(a),d=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,aR,null,1,null),new $APP.D(null,c,null,1,null))));return JK.A(function(g){if(UH(g))return a.j?a.j(g):a.call(null,g);if(UO(g))return NK(a,g);if(cP(g)){var l=aP(g),n=function(){function v(A){var B=null;if(0<arguments.length){B=0;for(var G=Array(arguments.length-0);B<G.length;)G[B]=arguments[B+0],++B;B=new $APP.Bc(G,0,null)}return t.call(this,B)}function t(A){var B=$APP.Lf.A($APP.sf,A);return RF.A(function(){var G=$APP.Je.A(g,
B),J=bR.j(a);return J.j?J.j(G):J.call(null,G)}(),function(){function G(J){J=$APP.Fj.B(B,J,bR.j(a));return $APP.Je.A(g,J)}return hL.B?hL.B(G,0,l):hL.call(null,G,0,l)}())}v.G=0;v.K=function(A){A=$APP.r(A);return t(A)};v.C=t;return v}(),p=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,aR,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,aG.j(g),null,1,null))));return dP(n,l,p)}return VK(g)?kL.C(J3.j?J3.j(a):J3.call(null,a),$APP.y([g])):yD("Bad argument: Lie Derivative")},
d)};bR.F(null,new $APP.H(null,1,5,$APP.I,[TO],null),function(a){return J3(a)});var KP=function KP(a){switch(arguments.length){case 1:return KP.j(arguments[0]);case 2:return KP.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};KP.j=function(a){return X5a(a)};KP.A=function(a,b){a=S5a(a,b);return X5a(EP(WH.C($APP.y([FP(a),AP.j?AP.j(b):AP.call(null,b)])),GP(a)))};KP.G=2;var K3=function K3(a){var c;if(c=$APP.kd(a)){c=$APP.u(a);var d=new $APP.ug(null,new $APP.f(null,2,[wP,"null",xP,"null"],null),null);c=d.j?d.j(c):d.call(null,c)}return $APP.k(c)?$APP.bf.C(K3,$APP.y([$APP.Fc(a)])):$APP.od(a)?$APP.bf.C(K3,$APP.y([a])):a instanceof $APP.q?new $APP.H(null,1,5,$APP.I,[a],null):AD(["Invalid coordinate prototype: ",$APP.m.j(a)].join(""))},L3=function L3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=3<c.length?new $APP.Bc(c.slice(3),
0,null):null;return L3.C(arguments[0],arguments[1],arguments[2],c)};
L3.C=function(a,b,c,d){$APP.rg.B(b,zX,!0);$APP.Ie($APP.Tc(c))||AD("let-coordinates requires an even number of bindings");b=$APP.Jl.A(2,c);a=$APP.Vg.A($APP.u,b);b=$APP.Vg.A($APP.Xc,b);c=$APP.Vg.A($APP.Hl.A($APP.Zg,$APP.Ag),b);var g=$APP.bf.C(K3,$APP.y([a])),l=$APP.Vg.A(k4a,g),n=$APP.Vg.A(J4a,g);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.fm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.C(c,new $APP.D(null,$APP.ck,null,1,null),
$APP.y([new $APP.D(null,hHb,null,1,null)]))))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.yRb,null,1,null),new $APP.D(null,zWb,null,1,null),$APP.y([new $APP.D(null,$APP.Lf.A($APP.sf,b),null,1,null),new $APP.D(null,$APP.Fl.A(b6a,a),null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.Lf.A($APP.sf,g),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,z$b,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.CX,null,1,null),
new $APP.D(null,hS,null,1,null),$APP.y([new $APP.D(null,hHb,null,1,null)])))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Lf.A($APP.sf,l),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,z$b,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.CX,null,1,null),new $APP.D(null,LX,null,1,null),$APP.y([new $APP.D(null,hHb,null,1,null)])))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Lf.A($APP.sf,n),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
z$b,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.CX,null,1,null),new $APP.D(null,vT,null,1,null),$APP.y([new $APP.D(null,hHb,null,1,null)])))),null,1,null)))),null,1,null)]))))),null,1,null),$APP.y([d]))))};L3.G=3;L3.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};
var M3=function M3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=4<c.length?new $APP.Bc(c.slice(4),0,null):null;return M3.C(arguments[0],arguments[1],arguments[2],arguments[3],c)};M3.C=function(a,b,c,d,g){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,Mlb,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,c,null,1,null),new $APP.D(null,d,null,1,null))))),null,1,null),$APP.y([g]))))};M3.G=4;
M3.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);var g=$APP.w(d);d=$APP.u(g);g=$APP.w(g);return this.C(b,a,c,d,g)};var Irc=function(){var a=a6a(grc),b=$APP.x.B(a,0,null);a=iP(grc);var c=$APP.x.B(a,0,null),d=$APP.x.B(a,1,null);return tP(function(g,l){return kG.A(iG.A(c.j?c.j(g):c.call(null,g),c.j?c.j(l):c.call(null,l)),iG.C(rI.A(gO.j(b),2),d.j?d.j(g):d.call(null,g),$APP.y([d.j?d.j(l):d.call(null,l)])))},new $APP.H(null,2,5,$APP.I,[TO,TO],null))}();var VP=function VP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return VP.C(arguments[0],arguments[1],c)};
VP.C=function(a,b,c){c=$APP.qe(c);c=$APP.C.B(c,Ndc,!1);b=$4a(b)?$APP.k(c)?J6a(b,a,c):b:$APP.k(c)?J6a(lP(b),a,b):lP(b);var d=$APP.ef(nP(b)),g=$APP.ef(mP(b));b=W1a($APP.Vg.A(function(n){return $APP.Vg.A(function(p){return a.A?a.A(n,p):a.call(null,n,p)},d)},d));var l=g2a(b);return function(n){var p=aP(n);if(0===p)return iG.A(n,$APP.Je.A(F3,g));var v=C3(d,p);v=$APP.Vg.A(function(G){return $APP.Je.A(n,G)},v);var t=C3(g,p),A=$APP.Vg.A(function(G){return $APP.sn.A($APP.Lf.A($APP.vg,G),g)},t),B=$APP.Vg.A(function(G){return $APP.Je.A(F3,
G)},A);p=$APP.Vg.M(function(G,J,O){return iG.A($APP.Je.A(iG,G),D3.A($APP.N.A(J,O),g))},C3(l,p),t,A);return $APP.Je.A(kG,$APP.Vg.M(iG,p,v,B))}};VP.G=2;VP.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var N3=JK.A(function(a){return WH.C($APP.y([t2,SO.j?SO.j(a):SO.call(null,a)]))},hEb),Jrc=JK.A(WH.C($APP.y([QZ,N3])),jOb),WP=function WP(a){switch(arguments.length){case 1:return WP.j(arguments[0]);case 2:return WP.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
WP.j=function(a){var b=GP(a),c=KP.j(a);return function(d){return function(g){return pP(function(l,n){l=c(l);l=l.j?l.j(d):l.call(null,d);n=n.j?n.j(l):n.call(null,l);return n.j?n.j(g):n.call(null,g)},b)}}};WP.A=function(a,b){b=VP(a,b);return WH.C($APP.y([b,UP,b,PP(a)]))};WP.G=2;
var Krc=JK.A(function(a){var b=$APP.Vg.A(QQ,new $APP.H(null,3,5,$APP.I,[0,1,2],null)),c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=ZH.A(a,0),l=ZH.A(a,1);a=ZH.A(a,2);return uL.C($APP.y([RF.A(d.j?d.j(a):d.call(null,a),b.j?b.j(l):b.call(null,l)),RF.A(b.j?b.j(g):b.call(null,g),c.j?c.j(a):c.call(null,a)),RF.A(c.j?c.j(l):c.call(null,l),d.j?d.j(g):d.call(null,g))]))},MQb),Lrc=JK.A(WH.C($APP.y([QZ,iG.A(N3,N3)])),MBb);var $6a=mJ.C(kJ(vJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Kv,new $APP.D(null,new $APP.ug(null,new $APP.f(null,3,[kH,null,lK,null,sH,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),new $APP.D(null,2,null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[DJ,$APP.Kv.j?$APP.Kv.j(a):$APP.Kv.call(null,a),2],null)),CJ.j?CJ.j(a):CJ.call(null,a)],
null)))?a:dJ(a)}),$APP.y([vYa(null)])),d7a=uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.ug(null,new $APP.f(null,2,[-1,null,-1,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[fQ,CJ.j?CJ.j(a):CJ.call(null,a)],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,$APP.Hv,
new $APP.D(null,new $APP.ug(null,new $APP.f(null,2,[-1,null,-1,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,zT,null,1,null),2,null),3,null),xJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[fQ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),zT.j?zT.j(a):zT.call(null,a)))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,MU,new $APP.D(null,qJ,null,1,null),2,null),3,null),new $APP.D(null,CJ,null,1,null),2,null),
3,null),xJ),function(a){var b=$APP.I,c=$APP.I;var d=PF.j(a.j?a.j(MU):a.call(null,MU));return(a=$APP.r(new $APP.H(null,2,5,b,[fQ,$APP.r(new $APP.H(null,3,5,c,[$APP.Ev,d,CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)))?a:dJ(a)}),kJ(vJ.A(new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,XI,new $APP.D(null,MU,new $APP.D(null,qJ,null,1,null),2,null),3,null),new $APP.D(null,zT,null,1,null),2,null),3,null),xJ),function(a){var b=$APP.I,c=$APP.N.A,d=$APP.I;var g=PF.j(a.j?a.j(MU):a.call(null,MU));return(a=
$APP.r(new $APP.H(null,2,5,b,[fQ,$APP.r(c.call($APP.N,new $APP.H(null,2,5,d,[$APP.Ev,g],null),zT.j?zT.j(a):zT.call(null,a)))],null)))?a:dJ(a)})])),Mrc=new $APP.H(null,10,5,$APP.I,"".split(""),null),Nrc=new $APP.H(null,10,5,$APP.I,"".split(""),null),Orc=/(.+)_([0-9a-zA-Z]+)$/,Prc=/(.+)([0-9a-zA-Z]+)$/,Qrc=$APP.fg("Epsilon Mu Iota omicron Omicron Eta Zeta Alpha Rho Chi Nu Tau Kappa Beta".split(" "),
"O".split("")),Rrc=$APP.fg("ldots varpi gamma eta Phi nu Omega delta upsilon sigma iota Delta rho varepsilon omega varrho varsigma psi Pi pi vartheta Xi kappa varphi chi zeta Psi tau Gamma Lambda Theta Upsilon mu theta alpha ell beta Sigma xi lambda phi epsilon".split(" "),"...                                         ".split(" ")),Src=$APP.Lf.B($APP.F,$APP.Vg.j(function(a){a=$APP.x.B(a,0,null);return new $APP.H(null,2,5,$APP.I,[a,["\\",$APP.m.j(a)].join("")],
null)}),Rrc),Trc=function(){var a=uD(function(b){return["\\",$APP.m.j(b)].join("")},$APP.wja(Rrc));return $APP.Ni.C($APP.y([Src,a,$APP.fg("cosh csc cot atan sin _ tan cos sinh sec asin tanh acos".split(" "),"\\sinh \\csc \\cot \\arctan \\sin \\_ \\tan \\cos \\sinh \\sec \\arcsin \\sinh \\arccos".split(" "))]))}(),Urc=$APP.Ni.C($APP.y([Qrc,Rrc])),Vrc=m7a($APP.y([k7a,$APP.fg([fQ,$APP.Zv,$APP.Xv,$APP.Uv,$APP.Ev,DJ,$APP.Yv,$APP.Gv,$APP.no,cH,$APP.Gu,$APP.rj,eQ,$APP.$v,$APP.Rw,$APP.Fv,YX,$APP.io,eS],[6,
3,3,3,5,8,3,4,1,9,4,5,7,3,9,4,5,2,5]),g7a,new $APP.ug(null,new $APP.f(null,15,[fQ,"null",$APP.Zv,"null",$APP.Xv,"null",$APP.Uv,"null",$APP.Ev,"null",DJ,"null",$APP.Yv,"null",$APP.Gv,"null",$APP.no,"null",$APP.rj,"null",$APP.$v,"null",$APP.Fv,"null",YX,"null",$APP.io,"null",eS,"null"],null),null),e7a," ",l7a,!0,i7a,new $APP.f(null,3,[xW,"frac",WV,"int",$APP.Gu,""],null),f7a,$APP.fg([eS,$APP.io,YX,$APP.rj,DJ,bT,$APP.Rw,jY,$APP.no],[function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b),
" % ",$APP.m.j(a)].join("")},function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b),"  ",$APP.m.j(a)].join("")},function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b)," mod ",$APP.m.j(a)].join("")},Z6a,function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);var c=(c=$APP.xd(a))?$APP.Ke($APP.Mba)(a):c;return $APP.k(c)?[$APP.m.j(b),$APP.m.j(n7a(a,Mrc))].join(""):null},function(a){a=$APP.x.B(a,0,null);return["",$APP.m.j(a),""].join("")},function(a){return $APP.Uc.A($APP.Tc(a),
1)&&$APP.xd($APP.u(a))?["",$APP.m.j(n7a($APP.u(a),Nrc))].join(""):null},function(a){a=$APP.x.B(a,0,null);return["",$APP.m.j(a),""].join("")},function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b),"  ",$APP.m.j(a)].join("")}]),h7a,function O3(a){a:switch(a){case Infinity:var c="";break a;case -Infinity:c="-";break a;default:c=null}if($APP.k(c))return c;c=$APP.m.j(a);var d=Urc.j?Urc.j(c):Urc.call(null,c);if($APP.k(d))return d;d=$APP.Mg.A?$APP.Mg.A(Prc,c):$APP.Mg.call(null,
Prc,c);if($APP.k(d))return function(g){$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);var n=$APP.Lg(/[0-9]+/,g);return $APP.k(n)?[$APP.m.j(O3(l)),$APP.m.j(n7a(n,Mrc))].join(""):[$APP.m.j(O3(l)),"",$APP.m.j(O3(g))].join("")}(d);c=$APP.Mg.A?$APP.Mg.A(Orc,c):$APP.Mg.call(null,Orc,c);return $APP.k(c)?function(g){$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);var n=$APP.Lg(/[0-9]+/,g);return $APP.k(n)?[$APP.m.j(O3(l)),$APP.m.j(n7a(n,Nrc))].join(""):[$APP.m.j(O3(l)),
"_",$APP.m.j(O3(g))].join("")}(c):a}])),P3=function(){function a(A){return["\\left(",$APP.m.j(A),"\\right)"].join("")}function b(A){$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);A=hQ(P3.j?P3.j(A):P3.call(null,A));return[$APP.m.j(A),"^{\\prime\\prime}"].join("")}function c(A){$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);A=hQ(P3.j?P3.j(A):P3.call(null,A));return[$APP.m.j(A),"^\\prime"].join("")}function d(A){return function(B){$APP.x.B(B,0,null);B=$APP.x.B(B,1,null);return["\\",$APP.m.j(A)," ",$APP.m.j(hQ(P3.j?
P3.j(B):P3.call(null,B)))].join("")}}var g=d("dot"),l=d("ddot"),n=d("hat"),p=d("bar"),v=d("vec"),t=d("tilde");return m7a($APP.y([k7a,$APP.fg([fQ,$APP.Zv,$APP.Xv,$APP.Uv,$APP.Ev,DJ,$APP.Yv,$APP.Gv,$APP.no,cH,$APP.Gu,$APP.rj,eQ,$APP.$v,$APP.Rw,$APP.Fv,YX,$APP.io,eS],[6,3,3,3,5,8,3,4,1,9,1,0,7,3,9,4,5,2,5]),j7a,a,g7a,new $APP.ug(null,new $APP.f(null,15,[fQ,"null",$APP.Zv,"null",$APP.Xv,"null",$APP.Uv,"null",$APP.Ev,"null",DJ,"null",$APP.Yv,"null",$APP.Gv,"null",$APP.no,"null",$APP.rj,"null",$APP.$v,
"null",$APP.Fv,"null",YX,"null",$APP.io,"null",eS,"null"],null),null),e7a,"\\,",l7a,!0,f7a,$APP.fg([eS,$APP.io,xP,$APP.$v,YX,$APP.rj,LFb,$APP.Gu,zjb,$APP.Uv,DJ,xW,bT,$APP.Rw,jY,wP,FJ,WV,$APP.no],[function(A){var B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return[$APP.m.j(hQ(B))," \\mathbin{\\%} ",$APP.m.j(hQ(A))].join("")},function(A){var B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return[$APP.m.j(B)," \\land ",$APP.m.j(A)].join("")},function(A){return["\\begin{pmatrix}",$APP.Il.A(" \\cr \\cr ",$APP.Vg.A(o7a,
A)),"\\end{pmatrix}"].join("")},function(A){return $APP.Il.A(" \\geq ",A)},function(A){var B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return[$APP.m.j(hQ(B))," \\bmod ",$APP.m.j(hQ(A))].join("")},function(A){var B=$APP.Tc(A);return $APP.Uc.A(B,1)?["\\frac",gQ(1),gQ($APP.u(A))].join(""):$APP.Uc.A(B,2)?["\\frac",gQ($APP.u(A)),gQ($APP.Xc(A))].join(""):null},function(A){return["\\begin{bmatrix}",$APP.Il.A(" \\cr \\cr ",$APP.Vg.A(function(B){B=$APP.Vg.A($APP.Hl.A(o7a,P3),B);return $APP.Il.A(" \x26 ",B)},
A)),"\\end{bmatrix}"].join("")},function(A){A=$APP.x.B(A,0,null);return["\\lnot",a(A)].join("")},function(A){return["\\begin{bmatrix}",$APP.Il.A(" \\cr \\cr ",$APP.Vg.A(o7a,A)),"\\end{bmatrix}"].join("")},function(A){return $APP.Il.A(" \\leq ",A)},function(A){var B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return[$APP.m.j(hQ(B)),"^",$APP.m.j(hQ(A))].join("")},function(A){A=$APP.x.B(A,0,null);return["\\mathsf{frac} ",a(A)].join("")},function(A){A=$APP.x.B(A,0,null);return["\\left\\lfloor ",$APP.m.j(A),
" \\right\\rfloor"].join("")},function(A){return["\\partial_",$APP.m.j(hQ($APP.Il.A(",",A)))].join("")},function(A){A=$APP.x.B(A,0,null);return["\\left\\lceil ",$APP.m.j(A)," \\right\\rceil"].join("")},function(A){return["\\begin{bmatrix}",$APP.Il.A($APP.k(!1)?" \\cr \\cr ":"\x26",$APP.Vg.A(o7a,A)),"\\end{bmatrix}"].join("")},function(A){return["\\sqrt ",$APP.m.j(hQ($APP.u(A)))].join("")},function(A){A=$APP.x.B(A,0,null);return["\\mathsf{int} ",a(A)].join("")},function(A){var B=$APP.x.B(A,0,null);
A=$APP.x.B(A,1,null);return[$APP.m.j(B)," \\lor ",$APP.m.j(A)].join("")}]),h7a,function G(B){if(JTa(B))return["\\frac",gQ(BG(B)),gQ(CG(B))].join("");a:switch(B){case Infinity:var J="\\infty";break a;case -Infinity:J="-\\infty";break a;default:J=null}if($APP.k(J))return J;var O=$APP.m.j(B);J=Trc.j?Trc.j(O):Trc.call(null,O);if($APP.k(J))return J;J=$APP.Mg.A?$APP.Mg.A(Prc,O):$APP.Mg.call(null,Prc,O);if($APP.k(J))return function(Q){$APP.x.B(Q,0,null);var W=$APP.x.B(Q,1,null);Q=$APP.x.B(Q,2,null);return[$APP.m.j(hQ(G(W))),
"^",$APP.m.j(hQ(G(Q)))].join("")}(J);J=$APP.Mg.A?$APP.Mg.A(Orc,O):$APP.Mg.call(null,Orc,O);if($APP.k(J))return function(Q){$APP.x.B(Q,0,null);var W=$APP.x.B(Q,1,null);Q=$APP.x.B(Q,2,null);return[$APP.m.j(hQ(G(W))),"_",$APP.m.j(hQ(G(Q)))].join("")}(J);J=function(){var Q=/(.+)dotdot$/;return $APP.Mg.A?$APP.Mg.A(Q,O):$APP.Mg.call(null,Q,O)}();if($APP.k(J))return l(J);J=function(){var Q=/(.+)dot$/;return $APP.Mg.A?$APP.Mg.A(Q,O):$APP.Mg.call(null,Q,O)}();if($APP.k(J))return g(J);J=function(){var Q=/(.+)hat$/;
return $APP.Mg.A?$APP.Mg.A(Q,O):$APP.Mg.call(null,Q,O)}();if($APP.k(J))return n(J);J=function(){var Q=/(.+)primeprime$/;return $APP.Mg.A?$APP.Mg.A(Q,O):$APP.Mg.call(null,Q,O)}();if($APP.k(J))return b(J);J=function(){var Q=/(.+)prime$/;return $APP.Mg.A?$APP.Mg.A(Q,O):$APP.Mg.call(null,Q,O)}();if($APP.k(J))return c(J);J=function(){var Q=/(.+)bar$/;return $APP.Mg.A?$APP.Mg.A(Q,O):$APP.Mg.call(null,Q,O)}();if($APP.k(J))return p(J);J=function(){var Q=/(.+)vec$/;return $APP.Mg.A?$APP.Mg.A(Q,O):$APP.Mg.call(null,
Q,O)}();if($APP.k(J))return v(J);J=function(){var Q=/(.+)tilde$/;return $APP.Mg.A?$APP.Mg.A(Q,O):$APP.Mg.call(null,Q,O)}();return $APP.k(J)?t(J):B instanceof $APP.q&&1<O.length&&$APP.eb($APP.Lg(/^d[a-z]/,O))?$APP.k(!0)?["\\mathsf",gQ(O)].join(""):gQ(O):B}]))}(),Q3=function Q3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return Q3.C(arguments[0],c)};
Q3.C=function(a,b){b=$APP.qe(b);b=$APP.C.A(b,VDb);a=P3.j?P3.j(a):P3.call(null,a);return $APP.k(b)?["\\begin{equation}\n","string"===typeof b&&$APP.r(b)?["\\label{",$APP.m.j(b),"}\n"].join(""):"",$APP.m.j(a),"\n\\end{equation}"].join(""):a};Q3.G=1;Q3.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var zQ=function(){function a(b){return["[",$APP.Il.A(", ",b),"]"].join("")}return m7a($APP.y([k7a,$APP.fg([fQ,$APP.Zv,$APP.Xv,$APP.Uv,$APP.Ev,$APP.Yv,$APP.Gv,$APP.no,cH,$APP.Gu,$APP.rj,eQ,$APP.$v,$APP.Fv,$APP.io],[7,2,2,2,5,2,3,1,8,9,5,8,2,3,1]),g7a,new $APP.ug(null,new $APP.f(null,6,[fQ,"null",$APP.Zv,"null",$APP.Ev,"null",$APP.Gv,"null",$APP.rj,"null",$APP.Fv,"null"],null),null),i7a,$APP.fg([wH,kH,lK,sH,$APP.Iu,$APP.Gu,BJ,uH,DJ,hK,kK,bT,oV,jY,FJ,jK,zJ,WV,fW,oX,FV],"Math.sinh Math.sin Math.tan Math.cos Math.abs ! Math.log Math.cosh Math.pow Math.atan Math.acos Math.floor Math.acosh Math.ceil Math.sqrt Math.asin Math.exp Math.trunc Math.asinh Math.tanh Math.atanh".split(" ")),
h7a,function(b){return b instanceof $APP.q?$APP.hi(b):b},f7a,function(){function b(c){return["(",$APP.m.j(c),")"].join("")}return new $APP.f(null,7,[xP,a,wP,a,YX,function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return b([b([b([$APP.m.j(d)," % ",$APP.m.j(c)].join(""))," + ",$APP.m.j(c)].join(""))," % ",$APP.m.j(c)].join(""))},eS,function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return[$APP.m.j(d)," % ",$APP.m.j(c)].join("")},$APP.io,function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,
1,null);return[$APP.m.j(d)," \x26\x26 ",$APP.m.j(c)].join("")},$APP.no,function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return[$APP.m.j(d)," || ",$APP.m.j(c)].join("")},$APP.rj,Z6a],null)}()]))}();var K7a=(jG.j(5)+1)/2,J7a=(jG.j(5)-1)/2,I7a=1-J7a,R3=function R3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return R3.C(c)};R3.C=function(a){return $APP.Je.B($APP.Nt,$APP.Xc,a)};R3.G=0;R3.K=function(a){return this.C($APP.r(a))};
var S3=function S3(a){switch(arguments.length){case 3:return S3.B(arguments[0],arguments[1],arguments[2]);case 4:return S3.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};S3.B=function(a,b,c){return S3.M(a,b,c,$APP.F)};
S3.M=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,nAb,R3);var l=$APP.C.B(g,$APP.Uw,$APP.Le(null)),n=TY.j(a);a=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);b=$APP.od(b)?b:new $APP.H(null,2,5,$APP.I,[b,n.j?n.j(b):n.call(null,b)],null);var p=$APP.x.B(b,0,null),v=$APP.od(c)?c:new $APP.H(null,2,5,$APP.I,[c,n.j?n.j(c):n.call(null,c)],null),t=$APP.x.B(v,0,null);c=$APP.Ni.C($APP.y([new $APP.f(null,5,[mQ,1E3,lQ,1E3,E7a,1E-8,P7a,1E-8,R7a,a],null),g]));var A=rQ(t,p);p=rQ(p,t);g=Q7a(c);c=S7a($APP.rg.B(c,R7a,a));
b=new $APP.H(null,4,5,$APP.I,[b,new $APP.H(null,2,5,$APP.I,[A,n.j?n.j(A):n.call(null,A)],null),new $APP.H(null,2,5,$APP.I,[p,n.j?n.j(p):n.call(null,p)],null),v],null);$APP.x.B(b,0,null);$APP.x.B(b,1,null);$APP.x.B(b,2,null);$APP.x.B(b,3,null);v=b;for(b=0;;){A=$APP.x.B(v,0,null);p=$APP.x.B(v,1,null);t=$APP.x.B(v,2,null);var B=$APP.x.B(v,3,null);l.S?l.S(A,p,t,B,b):l.call(null,A,p,t,B,b);v=g(A,p,t,B,b);var G=v;G=$APP.k(G)?G:c(A,p,t,B,b);if($APP.k(G))return l=d.M?d.M(A,p,t,B):d.call(null,A,p,t,B),d=$APP.x.B(l,
0,null),l=$APP.x.B(l,1,null),new $APP.f(null,5,[nQ,d,$APP.fw,l,oQ,$APP.vd(v),pQ,b,qQ,$APP.Fb(a)],null);v=L7a(n,A,p,t,B);b+=1}};S3.G=4;var T3=function T3(a){switch(arguments.length){case 3:return T3.B(arguments[0],arguments[1],arguments[2]);case 4:return T3.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};T3.B=function(a,b,c){return T3.M(a,b,c,$APP.F)};
T3.M=function(a,b,c,d){a=$APP.Hl.A(PF,a);return $APP.Fj.B(S3.M(a,b,c,d),$APP.fw,PF)};T3.G=4;var U3=function U3(a){switch(arguments.length){case 1:return U3.j(arguments[0]);case 2:return U3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};U3.j=function(a){return U3.A(a,$APP.F)};
U3.A=function(a,b){function c(B,G,J,O){var Q=$APP.x.B(B,0,null),W=$APP.x.B(J,0,null);G=new $APP.f(null,5,[J4b,B,Lvb,G,c3b,J,qQ,$APP.Fb(v),pQ,O],null);return W<Q?$APP.rg.C(G,J4b,J,$APP.y([c3b,B])):G}function d(B,G,J,O){$APP.x.B(G,0,null);B=$APP.x.B(G,1,null);$APP.x.B(J,0,null);J=$APP.x.B(J,1,null);return O>n||$APP.Fb(v)>p||B<=J}b=$APP.qe(b);var g=$APP.C.B(b,c5b,0),l=$APP.C.B(b,d5b,1),n=$APP.C.B(b,lQ,1E3),p=$APP.C.B(b,mQ,1E3);a=TY.j(a);var v=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);b=X7a(a,b);l=T7a(a,
g,l);g=$APP.x.B(l,0,null);var t=$APP.x.B(g,0,null);l=$APP.x.B(l,1,null);var A=$APP.x.B(l,0,null);t=sQ(t,A);a=a.j?a.j(t):a.call(null,t);a=new $APP.H(null,3,5,$APP.I,[l,g,new $APP.H(null,2,5,$APP.I,[t,a],null)],null);$APP.x.B(a,0,null);$APP.x.B(a,1,null);$APP.x.B(a,2,null);g=a;for(a=0;;){t=g;g=$APP.x.B(t,0,null);l=$APP.x.B(t,1,null);t=$APP.x.B(t,2,null);if(d(g,l,t,a))return c(g,l,t,a);g=b(g,l,t);a+=1}};U3.G=2;
var V3=function V3(a){switch(arguments.length){case 1:return V3.j(arguments[0]);case 2:return V3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};V3.j=function(a){return V3.A(a,$APP.F)};V3.A=function(a,b){a=$APP.Hl.A(PF,a);return U3.A(a,b)};V3.G=2;
var W3=function W3(a){switch(arguments.length){case 1:return W3.j(arguments[0]);case 2:return W3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};W3.j=function(a){return W3.A(a,$APP.F)};
W3.A=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,$APP.nq,0),d=$APP.C.B(b,HZb,10);b=$APP.C.B(b,lQ,1E3);var g=TY.j(a);a=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var l=T7a(g,c,c+d);c=$APP.x.B(l,0,null);d=$APP.x.B(c,0,null);l=$APP.x.B(l,1,null);var n=$APP.x.B(l,0,null);n=d+(d-n);a:{d=c;var p=new $APP.H(null,2,5,$APP.I,[n,g.j?g.j(n):g.call(null,n)],null);for(c=0;;){n=$APP.x.B(l,0,null);var v=l;l=p;p=$APP.x.B(l,0,null);var t=v,A=d,B=l,G=c;$APP.x.B(t,0,null);t=$APP.x.B(t,1,null);$APP.x.B(A,0,null);A=$APP.x.B(A,
1,null);$APP.x.B(B,0,null);B=$APP.x.B(B,1,null);if(G>b||A<=(t<B?t:B)){g=v;v=c;c=$APP.x.B(g,0,null);n=$APP.x.B(l,0,null);b=new $APP.f(null,6,[J4b,g,Lvb,d,c3b,l,qQ,$APP.Fb(a),oQ,v<=b,pQ,v],null);b=n<c?$APP.rg.C(b,J4b,l,$APP.y([c3b,g])):b;break a}v=p+(p-n);n=l;v=new $APP.H(null,2,5,$APP.I,[v,g.j?g.j(v):g.call(null,v)],null);c+=1;l=d;d=n;p=v}}return b};W3.G=2;
var X3=function X3(a){switch(arguments.length){case 1:return X3.j(arguments[0]);case 2:return X3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};X3.j=function(a){return X3.A(a,$APP.F)};X3.A=function(a,b){a=$APP.Hl.A(PF,a);return U3.A(a,b)};X3.G=2;var tQ=function tQ(a){switch(arguments.length){case 3:return tQ.B(arguments[0],arguments[1],arguments[2]);case 4:return tQ.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};tQ.B=function(a,b,c){return tQ.M(a,b,c,$APP.F)};
tQ.M=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,e5b,1E-11);var l=$APP.C.B(g,dMb,HR),n=$APP.C.B(g,brb,b+I7a*(c-b)),p=$APP.C.B(g,lQ,1E3),v=$APP.C.A(g,mQ);g=$APP.C.B(g,$APP.Uw,$APP.Le(null));v=$APP.k(v)?v:p+1;b=new $APP.H(null,2,5,$APP.I,[b<c?b:c,b>c?b:c],null);c=$APP.x.B(b,0,null);var t=$APP.x.B(b,1,null);b=TY.j(a);a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);n=new $APP.H(null,2,5,$APP.I,[n,b.j?b.j(n):b.call(null,n)],null);c=new $APP.H(null,3,5,$APP.I,[c,n,t],null);$APP.x.B(c,0,null);t=$APP.x.B(c,
1,null);$APP.x.B(t,0,null);$APP.x.B(t,1,null);$APP.x.B(c,2,null);n=new $APP.H(null,2,5,$APP.I,[n,n],null);$APP.x.B(n,0,null);$APP.x.B(n,1,null);for(var A=n,B=n=0,G=0;;){var J=c;t=$APP.x.B(J,0,null);c=$APP.x.B(J,1,null);var O=$APP.x.B(c,0,null),Q=$APP.x.B(c,1,null);J=$APP.x.B(J,2,null);var W=A;A=$APP.x.B(W,0,null);W=$APP.x.B(W,1,null);var Z=n;n=G;var fa=l+d*hG.j(O);G=2*fa;var ha=G;var ja=.5*(J-t);ha=hG.j(O-.5*(t+J))+ja<=ha;g.B?g.B(n,O,Q):g.call(null,n,O,Q);if(n>p||$APP.Fb(a)>v||ha)return new $APP.f(null,
5,[nQ,O,$APP.fw,Q,pQ,n,oQ,ha,qQ,$APP.Fb(a)],null);hG.j(Z)<=fa?Q=Y7a(t,O,J):(ha=U7a(W,c,A),Q=$APP.x.B(ha,0,null),ha=$APP.x.B(ha,1,null),ja=Z,Z=Q>ha*(t-O)&&Q<ha*(J-O),ja=hG.j(Q)<hG.j(.5*ha*ja),Q=Z&&ja?new $APP.H(null,2,5,$APP.I,[B,Q/ha],null):Y7a(t,O,J));B=Q;Q=$APP.x.B(B,0,null);B=$APP.x.B(B,1,null);Z=O;ha=B;ja=Z+ha;fa=ja-t<G||J-ja<G?Z<=.5*(t+J)?Z+fa:Z-fa:hG.j(ha)<fa?0<ha?Z+fa:Z-fa:ja;G=new $APP.H(null,2,5,$APP.I,[fa,b.j?b.j(fa):b.call(null,fa)],null);ha=fa<O?new $APP.H(null,2,5,$APP.I,[G,c],null):
new $APP.H(null,2,5,$APP.I,[c,G],null);Z=$APP.x.B(ha,0,null);O=$APP.x.B(Z,0,null);fa=$APP.x.B(Z,1,null);var ta=$APP.x.B(ha,1,null);ha=$APP.x.B(ta,0,null);ja=$APP.x.B(ta,1,null);t=fa<=ja?new $APP.H(null,3,5,$APP.I,[t,Z,ha],null):new $APP.H(null,3,5,$APP.I,[O,ta,J],null);J=A;A=W;ta=G;W=$APP.x.B(J,0,null);O=$APP.x.B(J,1,null);G=$APP.x.B(A,0,null);fa=$APP.x.B(A,1,null);Z=$APP.x.B(c,0,null);ha=$APP.x.B(c,1,null);ja=$APP.x.B(ta,0,null);ta=$APP.x.B(ta,1,null);J=ta<=ha?new $APP.H(null,2,5,$APP.I,[A,c],null):
ta<=fa||$APP.Uc.A(G,Z)?new $APP.H(null,2,5,$APP.I,[A,new $APP.H(null,2,5,$APP.I,[ja,ta],null)],null):ta<=O||$APP.Uc.A(W,Z)||$APP.Uc.A(W,G)?new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[ja,ta],null),A],null):new $APP.H(null,2,5,$APP.I,[J,A],null);W=Q;Q=B;O=n+1;c=t;A=J;n=W;B=Q;G=O}};tQ.G=4;var Y3=function Y3(a){switch(arguments.length){case 3:return Y3.B(arguments[0],arguments[1],arguments[2]);case 4:return Y3.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Y3.B=function(a,b,c){return Y3.M(a,b,c,$APP.Le(null))};Y3.M=function(a,b,c,d){return tQ.M(a,b,c,new $APP.f(null,1,[$APP.Uw,d],null))};Y3.G=4;
var Z3=function Z3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return Z3.C(arguments[0],arguments[1],c)};Z3.C=function(a,b,c){var d=$APP.qe(c);c=$APP.C.A(d,i7b);a=H7a(a,b,d);return $APP.k(oQ.j(a))?$APP.k(c)?a:nQ.j(a):dOa(["multidimensional-minimize failed to converge: ",$APP.m.j(a)].join(""))};Z3.G=2;Z3.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var Wrc=$APP.kh.j($APP.F),Xrc=$APP.fg([lX,eS,xP,wH,kH,lK,sH,YX,$APP.rj,$APP.Iu,BJ,uH,DJ,xW,$APP.Fv,$APP.Ev,hK,kK,bT,$APP.Gv,oV,jY,wP,FJ,jK,zJ,WV,fW,oX,FV],[new $APP.f(null,2,[$APP.ix,pLb,$APP.Dy,$APP.Pd],null),new $APP.f(null,2,[$APP.ix,lZb,$APP.Dy,$APP.Qd],null),new $APP.f(null,2,[$APP.ix,dNb,$APP.Dy,$APP.ns],null),new $APP.f(null,2,[$APP.ix,iCb,$APP.Dy,function(a){return Math.sinh(a)}],null),new $APP.f(null,2,[$APP.ix,IKb,$APP.Dy,function(a){return Math.sin(a)}],null),new $APP.f(null,2,[$APP.ix,
Xbc,$APP.Dy,function(a){return Math.tan(a)}],null),new $APP.f(null,2,[$APP.ix,S$b,$APP.Dy,function(a){return Math.cos(a)}],null),new $APP.f(null,2,[$APP.ix,mGb,$APP.Dy,$APP.Od],null),new $APP.f(null,2,[$APP.ix,jec,$APP.Dy,$APP.Xs],null),new $APP.f(null,2,[$APP.ix,sOb,$APP.Dy,function(a){return Math.abs(a)}],null),new $APP.f(null,2,[$APP.ix,lDb,$APP.Dy,function(a){return Math.log(a)}],null),new $APP.f(null,2,[$APP.ix,Yjb,$APP.Dy,function(a){return Math.cosh(a)}],null),new $APP.f(null,2,[$APP.ix,PUb,
$APP.Dy,function(a,b){return Math.pow(a,b)}],null),new $APP.f(null,2,[$APP.ix,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Yx,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,$APP.Vv,null,1,null))))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iy,null,1,null),new $APP.D(null,$APP.Vv,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,hOb,null,1,null),new $APP.D(null,$APP.Vv,null,1,null)))),null,1,null)])))),
null,1,null)])))),$APP.Fk,function(a){return a-Math.floor(a)}],null),new $APP.f(null,2,[$APP.ix,FG,$APP.Dy,$APP.wr],null),new $APP.f(null,2,[$APP.ix,xdc,$APP.Dy,$APP.Ws],null),new $APP.f(null,2,[$APP.ix,xKb,$APP.Dy,function(a){return Math.atan(a)}],null),new $APP.f(null,2,[$APP.ix,OQb,$APP.Dy,function(a){return Math.acos(a)}],null),new $APP.f(null,2,[$APP.ix,hOb,$APP.Dy,function(a){return Math.floor(a)}],null),new $APP.f(null,2,[$APP.ix,$APP.Iy,$APP.Dy,$APP.Ck],null),new $APP.f(null,2,[$APP.ix,q_b,
$APP.Dy,function(a){return Math.acosh(a)}],null),new $APP.f(null,2,[$APP.ix,Z5b,$APP.Dy,function(a){return Math.ceil(a)}],null),new $APP.f(null,2,[$APP.ix,MP,$APP.Dy,QN],null),new $APP.f(null,2,[$APP.ix,A$b,$APP.Dy,function(a){return Math.sqrt(a)}],null),new $APP.f(null,2,[$APP.ix,NNb,$APP.Dy,function(a){return Math.asin(a)}],null),new $APP.f(null,2,[$APP.ix,E2b,$APP.Dy,function(a){return Math.exp(a)}],null),new $APP.f(null,2,[$APP.ix,DGb,$APP.Dy,function(a){return Math.trunc(a)}],null),new $APP.f(null,
2,[$APP.ix,vcb,$APP.Dy,function(a){return Math.asinh(a)}],null),new $APP.f(null,2,[$APP.ix,mfb,$APP.Dy,function(a){return Math.tanh(a)}],null),new $APP.f(null,2,[$APP.ix,Xdc,$APP.Dy,function(a){return Math.atanh(a)}],null)]),r8a=uD($APP.ix,Xrc),e8a=$APP.Oi.C(Xrc,xP,$APP.y([wP])),Yrc=M9b,uQ=new $APP.ug(null,new $APP.f(null,5,[$APP.qE,null,$APP.Mi,null,M9b,null,GG,null,hQb,null],null),null),yQ=function yQ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?
new $APP.Bc(c.slice(2),0,null):null;return yQ.C(arguments[0],arguments[1],c)},WNa;
yQ.C=function(a,b,c){var d=S6a(a),g=function(){return function p(n){return new $APP.de(null,function(){for(var v=n;;){var t=$APP.r(v);if(t){var A=t,B=$APP.u(A);if(t=$APP.r(function(G,J,O,Q,W){return function ha(fa){return new $APP.de(null,function(){return function(){for(;;){var ja=$APP.r(fa);if(ja){if($APP.pd(ja)){var ta=$APP.lc(ja),ua=$APP.Tc(ta),ca=$APP.fe(ua);a:for(var V=0;;)if(V<ua){var da=$APP.bd(ta,V);ca.add(da);V+=1}else{ta=!0;break a}return ta?$APP.ie($APP.ke(ca),ha($APP.mc(ja))):$APP.ie($APP.ke(ca),
null)}ca=$APP.u(ja);return $APP.Yd(ca,ha($APP.Fc(ja)))}return null}}}(G,J,O,Q,W),null,null)}}(v,B,A,t,d)(B)))return $APP.N.A(t,p($APP.Fc(v)));v=$APP.Fc(v)}else return null}},null,null)}(b)}();return X6a($APP.Uc.A(XP(dQ(d)),$APP.fm)?Y6a(bQ(dQ(d)),function(l){return $APP.k(c)?$APP.Lf.A($APP.sf,$APP.N.A(g,l)):$APP.Lf.A(l,g)}):cQ(d,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.fm,null,1,null),new $APP.D(null,$APP.tf(g),null,1,null),$APP.y([new $APP.D(null,XP(d),null,1,null)]))))))};yQ.G=2;
yQ.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};WNa=$APP.fka(new $APP.f(null,2,[$APP.Uo,new $APP.f(null,1,[$APP.Xw,Math],null),$APP.$l,new $APP.f(null,1,[Ocb,new $APP.f(null,2,[xP,uL,wP,QN],null)],null)],null));
$APP.KR=function KR(a){switch(arguments.length){case 3:return KR.B(arguments[0],arguments[1],arguments[2]);case 4:return KR.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};$APP.KR.B=function(a,b,c){return $APP.KR.M(a,b,c,$APP.F)};
$APP.KR.M=function(a,b,c,d){var g=$APP.qe(d),l=$APP.C.B(g,$APP.fq,Yrc);d=$APP.C.B(g,$APP.vQ,iV);var n=$APP.C.A(g,XH),p=$APP.C.B(g,$APP.vYb,$APP.vd(b)),v=$APP.C.B(g,c8a,DM.j(4)),t=$APP.C.B(g,AUa,!0);g=$APP.C.B(g,$APP.aV,!0);var A=new $APP.f(null,5,[$APP.vQ,d,$APP.vYb,p,$APP.fq,l,XH,n,$APP.Dy,a],null);n=function(){if($APP.k(t)){var J=$APP.Fb(Wrc);return J.j?J.j(A):J.call(null,A)}return t}();if($APP.k(n))return $G($APP.Wu,"emmy.expression.compile",607,new $APP.bh(function(){return new $APP.H(null,1,
5,$APP.I,["compiled state function cache hit"],null)},null),298571733),n;var B=Y_a(),G=h8a(l);l=function(){function J(Q,W){var Z=null;if(1<arguments.length){Z=0;for(var fa=Array(arguments.length-1);Z<fa.length;)fa[Z]=arguments[Z+1],++Z;Z=new $APP.Bc(fa,0,null)}return O.call(this,Q,Z)}function O(Q,W){W=$APP.qe(W);return $APP.Ni.C($APP.y([new $APP.f(null,1,[$APP.em,Q],null),W]))}J.G=1;J.K=function(Q){var W=$APP.u(Q);Q=$APP.Fc(Q);return O(W,Q)};J.C=O;return J}();c=x8a(c,v);n=function(){return $APP.k(b)?
$APP.k(p)?function Q(O){return new $APP.de(null,function(){for(;;){var W=$APP.r(O);if(W){if($APP.pd(W)){var Z=$APP.lc(W),fa=$APP.Tc(Z),ha=$APP.fe(fa);a:for(var ja=0;;)if(ja<fa)$APP.bd(Z,ja),$APP.je(ha,v.j?v.j($APP.Pv):v.call(null,$APP.Pv)),ja+=1;else{Z=!0;break a}return Z?$APP.ie($APP.ke(ha),Q($APP.mc(W))):$APP.ie($APP.ke(ha),null)}$APP.u(W);return $APP.Yd(v.j?v.j($APP.Pv):v.call(null,$APP.Pv),Q($APP.Fc(W)))}return null}},null,null)}(b):b:b}();a=!1!==n?$APP.Je.A(a,n):a;a:switch(d instanceof $APP.E?
d.ga:null){case "native":a=$APP.Je.A(a,c);break a;default:a=a.j?a.j(c):a.call(null,c)}d=n8a(l8a(o8a($APP.Fj.B(k8a(l(aG.j($APP.k(g)?bG.j(a):a),$APP.vQ,d,$APP.dm,$APP.k(p)?n:null,j8a,c),v),$APP.em,f8a)),function(){return v.j?v.j("_"):v.call(null,"_")}));a=function(){var J=G instanceof $APP.E?G.ga:null;switch(J){case "source":return u8a;case "clj":return s8a;case "js":return u8a;case "native":return v8a;case "sci":return w8a;default:throw Error(["No matching clause: ",$APP.m.j(J)].join(""));}}();d=a.j?
a.j(d):a.call(null,d);$G($APP.Wu,"emmy.expression.compile",640,new $APP.bh(function(){return new $APP.H(null,2,5,$APP.I,["compiled function in",B.Bf(null)],null)},null),-368687219);$APP.k($APP.k(t)?p:t)&&$APP.lh.M(Wrc,$APP.rg,A,d);return d};$APP.KR.G=4;
$APP.$3=function $3(a){switch(arguments.length){case 1:return $3.j(arguments[0]);case 2:return $3.A(arguments[0],arguments[1]);case 3:return $3.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
$APP.$3.j=function(a){var b=$APP.$3.A;var c=SH(a);var d=$APP.x.B(c,0,null),g=$APP.x.B(c,1,null);c=$APP.Uc.A(d,fI)?g:AD(["`compile-fn` can only infer arity for functions with just one\n           arity, not ",$APP.m.j(c),". Please pass an explicit `n`."].join(""));return b.call($APP.$3,a,c)};$APP.$3.A=function(a,b){return $APP.$3.B(a,b,$APP.F)};
$APP.$3.B=function(a,b,c){var d=$APP.Lf.A($APP.sf,$APP.Nn.A(b,function(){return $APP.Nj.j($APP.Vv)}));return $APP.KR.M(a,!1,d,$APP.Ni.C($APP.y([new $APP.f(null,2,[$APP.vQ,M9b,XH,b],null),c])))};$APP.$3.G=3;var B8a=new $APP.H(null,2,5,$APP.I,[oCb,oCb],null),d9a=new $APP.H(null,2,5,$APP.I,[AQ,AQ],null),c9a=new $APP.H(null,2,5,$APP.I,[oCb,AQ],null),e9a=new $APP.H(null,2,5,$APP.I,[AQ,oCb],null);$APP.Vg.B(function(a,b){return a/2*b},$APP.af(function(a){return 2*a},4),$APP.af(function(a){return a/jG.j(2+jG.j(4-lG.j(a)))},Math.sqrt(2)));var GQ=function GQ(a){switch(arguments.length){case 2:return GQ.A(arguments[0],arguments[1]);case 3:return GQ.B(arguments[0],arguments[1],arguments[2]);case 4:return GQ.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};GQ.A=function(a,b){return zI(G8a(a,b,$APP.af($APP.Lc,1)))};
GQ.B=function(a,b,c){return zI(G8a(a,b,c))};GQ.M=function(a,b,c,d){return GQ.B(a,b,$APP.af(function(g){return d+g},c))};GQ.G=4;var a4=function a4(a){switch(arguments.length){case 3:return a4.B(arguments[0],arguments[1],arguments[2]);case 4:return a4.M(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return a4.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
a4.B=function(a,b,c){return $APP.x.A(G8a(a,c,$APP.af($APP.Lc,1)),b)};a4.M=function(a,b,c,d){return $APP.x.A(G8a(a,c,d),b)};a4.S=function(a,b,c,d,g){return a4.M(a,b,c,$APP.af(function(l){return g+l},d))};a4.G=5;var b4=function b4(a){switch(arguments.length){case 1:return b4.j(arguments[0]);case 3:return b4.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};b4.j=function(a){return b4.B(a,1,$APP.Lc)};
b4.B=function(a,b,c){return CI(function(d){return new $APP.H(null,2,5,$APP.I,[b,d],null)},function(d,g){var l=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var n=Math.pow(a,l),p=n-1;return new $APP.H(null,2,5,$APP.I,[c.j?c.j(l):c.call(null,l),(n*d-g)/p],null)},function(d){return $APP.fd($APP.$c(d))})};b4.G=3;
var c4=function c4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return c4.C(arguments[0],c)};c4.C=function(a,b){return E_.j($APP.Je.B(b4,a,b))};c4.G=1;c4.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var d4=function d4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return d4.C(arguments[0],c)};
d4.C=function(a,b){return EI.j($APP.Je.B(b4,a,b))};d4.G=1;d4.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var e4=function e4(a){switch(arguments.length){case 3:return e4.B(arguments[0],arguments[1],arguments[2]);case 4:return e4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};e4.B=function(a,b,c){return e4.M(a,b,c,$APP.F)};e4.M=function(a,b,c,d){return N8a(S8a(I8a(a,b,c),P8a(a,b,c),2,$APP.rr.A(d,1)),d)};e4.G=4;
var f4=function f4(a){switch(arguments.length){case 3:return f4.B(arguments[0],arguments[1],arguments[2]);case 4:return f4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};f4.B=function(a,b,c){return f4.M(a,b,c,$APP.F)};f4.M=function(a,b,c,d){return N8a(S8a(J8a(a,b,c),P8a(a,b,c),2,$APP.rr.A(d,1)),d)};f4.G=4;
var g4=function g4(a){switch(arguments.length){case 3:return g4.B(arguments[0],arguments[1],arguments[2]);case 4:return g4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};g4.B=function(a,b,c){return g4.M(a,b,c,$APP.F)};g4.M=function(a,b,c,d){d=$APP.qe(d);var g=$APP.C.B(d,$APP.rr,1);g="number"===typeof g?HQ.A(2,g):g;return N8a($APP.Vg.A(L8a(a,b,c),g),d)};g4.G=4;
var h4=function h4(a){switch(arguments.length){case 3:return h4.B(arguments[0],arguments[1],arguments[2]);case 4:return h4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};h4.B=function(a,b,c){return h4.M(a,b,c,$APP.F)};h4.M=function(a,b,c,d){d=$APP.qe(d);var g=$APP.C.B(d,$APP.rr,1);g="number"===typeof g?HQ.A(2,g):g;return N8a($APP.Vg.A(K8a(a,b,c),g),d)};h4.G=4;
var Zrc=EQ(function(a,b,c){return(a.j?a.j(b):a.call(null,b))*(c-b)},e4),$rc=EQ(function(a,b,c){return(a.j?a.j(c):a.call(null,c))*(c-b)},f4),asc=EQ(function(a,b,c){var d=a.j?a.j(b):a.call(null,b);a=a.j?a.j(c):a.call(null,c);return(d<a?d:a)*(c-b)},g4),bsc=EQ(function(a,b,c){var d=a.j?a.j(b):a.call(null,b);a=a.j?a.j(c):a.call(null,c);return(d>a?d:a)*(c-b)},h4);$APP.Pi.A(IQ,function(a){return 4/(1+a*a)});$APP.Pi.A(IQ,function(a){return 4/(1+a*a)});var i4=function i4(a){switch(arguments.length){case 3:return i4.B(arguments[0],arguments[1],arguments[2]);case 4:return i4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};i4.B=function(a,b,c){return i4.M(a,b,c,new $APP.f(null,1,[$APP.rr,1],null))};
i4.M=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,$APP.rr,1);g=$APP.C.A(g,M8a);a=S8a(T8a(a,b,c),P8a(a,b,c),2,d);return $APP.k($APP.k(g)?"number"===typeof d:g)?GQ.M(a,2,2,2):a};i4.G=4;var csc=EQ(IQ,i4);var j4=function j4(a){switch(arguments.length){case 3:return j4.B(arguments[0],arguments[1],arguments[2]);case 4:return j4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};j4.B=function(a,b,c){return j4.M(a,b,c,new $APP.f(null,1,[$APP.rr,1],null))};j4.M=function(a,b,c,d){d=$APP.qe(d);d=$APP.C.B(d,$APP.rr,1);return a4.S(i4.M(a,b,c,d),2,2,2,2)};j4.G=4;var dsc=EQ($APP.Hl.A($APP.u,j4),j4);var k4=function k4(a){switch(arguments.length){case 3:return k4.B(arguments[0],arguments[1],arguments[2]);case 4:return k4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};k4.B=function(a,b,c){return k4.M(a,b,c,new $APP.f(null,1,[$APP.rr,1],null))};
k4.M=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,$APP.rr,1);g=$APP.C.A(g,M8a);a=S8a(O8a(a,b,c),V8a(a,b,c),3,d);return $APP.k($APP.k(g)?"number"===typeof d:g)?GQ.M(a,3,2,2):a};k4.G=4;var esc=EQ(U8a,k4);var X8a=$APP.Tj.A(HQ.A(2,2),HQ.A(2,3)),fsc=EQ(U8a,$8a(k4)),gsc=EQ(IQ,$8a(i4));var l4=function l4(a){switch(arguments.length){case 3:return l4.B(arguments[0],arguments[1],arguments[2]);case 4:return l4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};l4.B=function(a,b,c){return l4.M(a,b,c,new $APP.f(null,1,[$APP.rr,1],null))};l4.M=function(a,b,c,d){d=$APP.qe(d);var g=$APP.C.B(d,$APP.rr,1);return a4.S(k4.M(a,b,c,$APP.rg.B(d,$APP.rr,HQ.A(2,g))),1,2,2,2)};l4.G=4;
var hsc=EQ($APP.Hl.A($APP.u,l4),l4);var m4=function m4(a){switch(arguments.length){case 3:return m4.B(arguments[0],arguments[1],arguments[2]);case 4:return m4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};m4.B=function(a,b,c){return m4.M(a,b,c,$APP.F)};m4.M=function(a,b,c,d){d=$APP.qe(d);$APP.C.B(d,$APP.rr,1);return GQ.M(k4.M(a,b,c,d),3,2,2)};m4.G=4;
var n4=function n4(a){switch(arguments.length){case 3:return n4.B(arguments[0],arguments[1],arguments[2]);case 4:return n4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};n4.B=function(a,b,c){return n4.M(a,b,c,$APP.F)};n4.M=function(a,b,c,d){d=$APP.qe(d);$APP.C.B(d,$APP.rr,1);return GQ.M(i4.M(a,b,c,d),2,2,2)};n4.G=4;var isc=EQ(U8a,m4),jsc=EQ(IQ,n4);var o4=function o4(a){switch(arguments.length){case 3:return o4.B(arguments[0],arguments[1],arguments[2]);case 4:return o4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};o4.B=function(a,b,c){return o4.M(a,b,c,new $APP.f(null,1,[$APP.rr,1],null))};o4.M=function(a,b,c,d){d=$APP.qe(d);d=$APP.C.B(d,$APP.rr,1);return a4.S(i4.M(a,b,c,d),1,2,2,2)};o4.G=4;var ksc=EQ($APP.Hl.A($APP.u,o4),o4);var p4=function p4(a){switch(arguments.length){case 3:return p4.B(arguments[0],arguments[1],arguments[2]);case 4:return p4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};p4.B=function(a,b,c){return p4.M(a,b,c,new $APP.f(null,1,[$APP.rr,1],null))};p4.M=function(a,b,c,d){d=$APP.qe(d);d=$APP.C.B(d,$APP.rr,1);return a4.S(i4.M(a,b,c,new $APP.f(null,1,[$APP.rr,HQ.A(3,d)],null)),1,3,2,2)};p4.G=4;
var lsc=EQ($APP.Hl.A($APP.u,p4),p4);var msc=$APP.fg([RT,iwb,U$b,Glb,Fhb,lac,Mxb,BTb,cub,eqb,Nlb,PVb,icc,j5b,vxb,Wmb,TJb,jX,JNb],[new $APP.f(null,2,[$APP.ky,jX,$APP.BQ,B8a],null),lsc,new $APP.f(null,2,[$APP.ky,jX,$APP.BQ,d9a],null),csc,asc,new $APP.f(null,2,[$APP.ky,jX,$APP.BQ,e9a],null),jsc,ksc,esc,gsc,isc,$rc,Zrc,dsc,new $APP.f(null,2,[$APP.ky,jX,$APP.BQ,c9a],null),hsc,fsc,function(a,b){return function(){function c(l,n,p,v){v=$APP.Ni.C($APP.y([new $APP.f(null,3,[QHb,10,mUb,.05,$APP.BQ,B8a],null),v]));var t=new $APP.H(null,1,5,$APP.I,
[new $APP.H(null,3,5,$APP.I,[n,p,$APP.BQ.j(v)],null)],null);n=DI.call(null);for(p=0;;){if($APP.hd(t))return new $APP.f(null,3,[oQ,!0,pQ,p,nQ,DI.call(null,n)],null);var A=$APP.fd(t),B=$APP.x.B(A,0,null),G=$APP.x.B(A,1,null);A=$APP.x.B(A,2,null);t=$APP.gd(t);var J=B;var O=G;J=$APP.Uc.A(A,d9a)?b.M?b.M(l,J,O,v):b.call(null,l,J,O,v):a.M?a.M(l,J,O,v):a.call(null,l,J,O,v);O=$APP.qe(J);J=$APP.C.A(O,oQ);O=$APP.C.A(O,nQ);if($APP.k(J))B=t,n=DI.call(null,n,O),p+=1,t=B;else{J=B;var Q=mUb.j(v);O=G-J;Q=0===Q?.5:
.5+Q*($APP.bu.j(2)-1);J+=Q*O;B=$APP.Vd.C(t,new $APP.H(null,3,5,$APP.I,[J,G,y8a(A)],null),$APP.y([new $APP.H(null,3,5,$APP.I,[B,J,z8a(A)],null)]));p+=1;t=B}}}function d(l,n,p){return g.M(l,n,p,$APP.F)}var g=null;g=function(l,n,p,v){switch(arguments.length){case 3:return d.call(this,l,n,p);case 4:return c.call(this,l,n,p,v)}throw Error("Invalid arity: "+arguments.length);};g.B=d;g.M=c;return g}()}(fsc,gsc),bsc]),nsc=$APP.Lf.A($APP.vg,$APP.ng(msc)),q4=function q4(a){if($APP.cd(a))return new $APP.H(null,
2,5,$APP.I,[a,$APP.F],null);if(a instanceof $APP.E)return a=msc.j?msc.j(a):msc.call(null,a),q4.j?q4.j(a):q4.call(null,a);if($APP.md(a)){var c=$APP.ky.j(a);var d=q4.j?q4.j(c):q4.call(null,c);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return new $APP.H(null,2,5,$APP.I,[c,$APP.Ni.C($APP.y([$APP.Oi.A(a,$APP.ky),d]))],null)}return null},r4=function r4(a){switch(arguments.length){case 3:return r4.B(arguments[0],arguments[1],arguments[2]);case 4:return r4.M(arguments[0],arguments[1],arguments[2],arguments[3]);
default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};r4.B=function(a,b,c){return r4.M(a,b,c,$APP.F)};r4.M=function(a,b,c,d){var g=q4(a);return $APP.k(g)?(a=$APP.x.B(g,0,null),g=$APP.x.B(g,1,null),b=mG.j(b),c=$APP.k(b)?b:mG.j(c),new $APP.H(null,2,5,$APP.I,[$APP.k(c)?f9a(a):a,$APP.Oi.A($APP.Ni.C($APP.y([g,d])),$APP.ky)],null)):null};r4.G=4;
var s4=function s4(a){switch(arguments.length){case 3:return s4.B(arguments[0],arguments[1],arguments[2]);case 4:return s4.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};s4.B=function(a,b,c){return s4.M(a,b,c,$APP.F)};
s4.M=function(a,b,c,d){var g=$APP.qe(d),l=$APP.C.B(g,$APP.ky,RT),n=$APP.C.B(g,t9a,!1);d=$APP.C.B(g,i7b,!1);g=r4.M(l,b,c,g);return $APP.k(g)?(l=$APP.x.B(g,0,null),g=$APP.x.B(g,1,null),a=$APP.k(n)?$APP.$3.A(a,1):$APP.Hl.A(xD,a),b=l.M?l.M(a,b,c,g):l.call(null,a,b,c,g),$APP.k(d)?b:nQ.j(b)):AD(["Unknown method: ",$APP.m.j(l),". Try one of: ",$APP.m.j(nsc)].join(""))};s4.G=4;var t4=function t4(a){switch(arguments.length){case 0:return t4.J();case 1:return t4.j(arguments[0]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};t4.J=function(){return $APP.M($APP.dv,$APP.M(w2a,NN,$APP.M(RN,NN),$APP.M(RN,NN)),NN)};
t4.j=function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.dv,$APP.r(new $APP.H(null,4,5,$APP.I,[w2a,NN,$APP.r(new $APP.H(null,3,5,$APP.I,[RN,NN,a],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[RN,NN,a],null))],null)),NN],null)))?a:dJ(a)};t4.G=1;var OQ=function OQ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=3<c.length?new $APP.Bc(c.slice(3),0,null):null;return OQ.C(arguments[0],arguments[1],arguments[2],c)};
OQ.C=function(a,b,c,d){return $APP.Je.S(uL,a,b,c,d)};OQ.G=3;OQ.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};var RQ=function RQ(a){switch(arguments.length){case 1:return RQ.j(arguments[0]);case 2:return RQ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
RQ.j=function(a){var b=SO.j?SO.j(a):SO.call(null,a);return VH.A(function(c){return uL.C($APP.y([c,a.j?a.j(c):a.call(null,c),b.j?b.j(c):b.call(null,c)]))},new $APP.H(null,2,5,$APP.I,[fI,1],null))};RQ.A=function(a,b){a=$APP.We.A(b-1,$APP.af(SO,a));var c=$APP.Lf.A(uL.C($APP.y([$APP.Kd])),a);return VH.A(function(d){return c.j?c.j(d):c.call(null,d)},new $APP.H(null,2,5,$APP.I,[fI,1],null))};RQ.G=2;
var u4=function u4(a){switch(arguments.length){case 1:return u4.j(arguments[0]);case 2:return u4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};u4.j=function(a){return u4.A(a,null)};
u4.A=function(a,b){return function(c){var d=RQ.j(c);return RF.C(function(){var g=WH,l=g.C;var n=QQ.j?QQ.j(2):QQ.call(null,2);n=n.j?n.j(a):n.call(null,a);g=l.call(g,$APP.y([n,d]));return SO.j?SO.j(g):SO.call(null,g)}(),WH.C($APP.y([function(){var g=QQ.j?QQ.j(1):QQ.call(null,1);return g.j?g.j(a):g.call(null,a)}(),d])),$APP.y([$APP.k(b)?RF.j(WH.C($APP.y([function(){var g=QQ.j?QQ.j(2):QQ.call(null,2);return g.j?g.j(b):g.call(null,b)}(),d]))):0]))}};u4.G=2;
var v4=function v4(a){switch(arguments.length){case 1:return v4.j(arguments[0]);case 2:return v4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};v4.j=function(a){return v4.A(a,null)};
v4.A=function(a,b){var c=function(){var g=QQ.j?QQ.j(2):QQ.call(null,2);return g.j?g.j(a):g.call(null,a)}(),d=function(){var g=QQ.j?QQ.j(1):QQ.call(null,1);return g.j?g.j(a):g.call(null,a)}();return XSa(function(){var g=QQ.j?QQ.j(2):QQ.call(null,2);return g.j?g.j(c):g.call(null,c)}(),RF.C(d,$APP.k(b)?function(){var g=QQ.j?QQ.j(2):QQ.call(null,2);return g.j?g.j(b):g.call(null,b)}():0,$APP.y([kG.A(function(){var g=QQ.j?QQ.j(0):QQ.call(null,0);return g.j?g.j(c):g.call(null,c)}(),iG.A(function(){var g=
QQ.j?QQ.j(1):QQ.call(null,1);return g.j?g.j(c):g.call(null,c)}(),MQ))])))};v4.G=2;$APP.PQ=function PQ(a){switch(arguments.length){case 1:return PQ.j(arguments[0]);case 2:return PQ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};$APP.PQ.j=function(a){return $APP.PQ.A(a,null)};$APP.PQ.A=function(a,b){var c=v4.A(a,b);return function(d){return uL.C($APP.y([1,MQ(d),c.j?c.j(d):c.call(null,d)]))}};$APP.PQ.G=2;
var SQ=function SQ(a){switch(arguments.length){case 4:return SQ.M(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return SQ.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};SQ.M=function(a,b,c,d){return SQ.S(a,b,c,d,$APP.F)};SQ.S=function(a,b,c,d,g){return s4.M(WH.C($APP.y([a,RQ.j(b)])),c,d,g)};SQ.G=5;
var w4=function w4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=6<c.length?new $APP.Bc(c.slice(6),0,null):null;return w4.C(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],c)};w4.C=function(a,b,c,d,g,l,n){n=$APP.qe(n);n=$APP.C.A(n,oab);l=q9a(c,g,l);a=Z3.C(u9a(a,b,c,d,g),l,$APP.y([$APP.Uw,n]));return s9a(b,c,d,g,a)};w4.G=6;
w4.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);var g=$APP.w(d);d=$APP.u(g);var l=$APP.w(g);g=$APP.u(l);var n=$APP.w(l);l=$APP.u(n);n=$APP.w(n);return this.C(b,a,c,d,g,l,n)};var UQ=JK.A(w9a,Wzb);var x4=JK.A(P9a,PCb),osc=JK.A(function(a){return function(b){function c(n){n=uL.C($APP.y([d,g,n]));return a.j?a.j(n):a.call(null,n)}var d=$APP.x.B(b,0,null),g=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var l=x4.j?x4.j(c):x4.call(null,c);return l.j?l.j(b):l.call(null,b)}},NMb),psc=JK.A(function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=P9a(function(l){l=WQ(c,d,l);return a.j?a.j(l):a.call(null,l)});return g.j?g.j(b):g.call(null,b)}},z0b),$Q=function $Q(a,
b){return function(d){var g=a.j?a.j(d):a.call(null,d),l=b.j?b.j(d):b.call(null,d);if(VK(g)||VK(l))return kL.C(function(n){return kL.C(function(p){var v=$APP.Hl.A($APP.Je.A(rP,n),a);p=$APP.Hl.A($APP.Je.A(rP,p),b);v=$Q.A?$Q.A(v,p):$Q.call(null,v,p);return v.j?v.j(d):v.call(null,d)},$APP.y([jL(l)]))},$APP.y([jL(g)]));g=RF.A(iG.A(function(){var n=QQ.j?QQ.j(1):QQ.call(null,1);return n.j?n.j(a):n.call(null,a)}(),function(){var n=QQ.j?QQ.j(2):QQ.call(null,2);return n.j?n.j(b):n.call(null,b)}()),iG.A(function(){var n=
QQ.j?QQ.j(2):QQ.call(null,2);return n.j?n.j(a):n.call(null,a)}(),function(){var n=QQ.j?QQ.j(1):QQ.call(null,1);return n.j?n.j(b):n.call(null,b)}()));return g.j?g.j(d):g.call(null,d)}};bR.F(null,new $APP.H(null,1,5,$APP.I,[TH],null),function(a){return Q9a(a)});$APP.e=fR.prototype;$APP.e.Hc=$APP.xc;$APP.e.Ac=function(a,b){return this.Va(null,b)?new $APP.Cd(b,this.eb(null,b,null),null):null};$APP.e.toString=function(){return["#emmy/quaternion [",$APP.m.j(this.r)," ",$APP.m.j(this.i)," ",$APP.m.j(this.Ma)," ",$APP.m.j(this.k),"]"].join("")};$APP.e.Ka=function(a,b){return this.fa(null,b,null)};$APP.e.fa=function(a,b,c){return"number"===typeof b?this.eb(null,b,c):c};
$APP.e.lb=function(a,b,c){a=b.B?b.B(c,this.r,0):b.call(null,c,this.r,0);c=this.i;a=b.B?b.B(a,c,1):b.call(null,a,c,1);c=this.Ma;a=b.B?b.B(a,c,2):b.call(null,a,c,2);c=this.k;return b.B?b.B(a,c,3):b.call(null,a,c,3)};$APP.e.aa=function(a,b){return this.eb(null,b,null)};$APP.e.eb=function(a,b,c){switch(b){case 0:return this.r;case 1:return this.i;case 2:return this.Ma;case 3:return this.k;default:return c}};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};
$APP.e.Qa=function(){return $APP.eca($APP.tf(this),0,4)};$APP.e.ba=function(){return this.ca};$APP.e.ta=function(){return 4};$APP.e.Ic=function(){return new $APP.D(null,this.k,new $APP.D(null,this.Ma,new $APP.D(null,this.i,new $APP.D(null,this.r,null,1,null),2,null),3,null),4,null)};$APP.e.Y=function(a,b){return jR.A?jR.A(this,b):jR.call(null,this,b)};$APP.e.Sa=function(){return new fR(0,0,0,0,this.ca)};
$APP.e.fb=function(a,b){a=b.A?b.A(this.r,this.i):b.call(null,this.r,this.i);var c=this.Ma;a=b.A?b.A(a,c):b.call(null,a,c);c=this.k;return b.A?b.A(a,c):b.call(null,a,c)};$APP.e.bb=function(a,b,c){a=b.A?b.A(c,this.r):b.call(null,c,this.r);c=this.i;a=b.A?b.A(a,c):b.call(null,a,c);c=this.Ma;a=b.A?b.A(a,c):b.call(null,a,c);c=this.k;return b.A?b.A(a,c):b.call(null,a,c)};$APP.e.rb=function(){return JU};$APP.e.bc=function(){return s$a.j?s$a.j(this):s$a.call(null,this)};
$APP.e.sa=function(a,b,c){switch(b){case 0:return new fR(c,this.i,this.Ma,this.k,this.ca);case 1:return new fR(this.r,c,this.Ma,this.k,this.ca);case 2:return new fR(this.r,this.i,c,this.k,this.ca);case 3:return new fR(this.r,this.i,this.Ma,c,this.ca);default:throw Error("Quaternion's key for assoc must be 0, 1, 2 or 3.");}};$APP.e.Va=function(a,b){a=new $APP.ug(null,new $APP.f(null,4,[0,null,1,null,3,null,2,null],null),null);b=a.j?a.j(b):a.call(null,b);return $APP.vd(b)};
$APP.e.ma=function(){return new $APP.D(null,this.r,new $APP.D(null,this.i,new $APP.D(null,this.Ma,new $APP.D(null,this.k,null,1,null),2,null),3,null),4,null)};$APP.e.da=function(a,b){return new fR(this.r,this.i,this.Ma,this.k,b)};$APP.e.ua=function(){throw Error("conj not suported on Quaternion instances. convert to vector first!");};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.M(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Lb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){return lR.A?lR.A(this,$APP.sf):lR.call(null,this,$APP.sf)};$APP.e.j=function(a){a=new $APP.H(null,1,5,$APP.I,[a],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};
$APP.e.A=function(a,b){a=new $APP.H(null,2,5,$APP.I,[a,b],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.B=function(a,b,c){a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.M=function(a,b,c,d){a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.S=function(a,b,c,d,g){a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};
$APP.e.la=function(a,b,c,d,g,l){a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.Ga=function(a,b,c,d,g,l,n){a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.va=function(a,b,c,d,g,l,n,p){a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};
$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q){a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};
$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W){a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z){a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa){a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha){a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null);return lR.A?lR.A(this,a):lR.call(null,this,a)};
$APP.e.Lb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha,ja){a=$APP.Lf.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,Q,W,Z,fa,ha],null),ja);return lR.A?lR.A(this,a):lR.call(null,this,a)};$APP.e.ac=function(a,b,c){return new fR(FH(this.r,b,c),FH(this.i,b,c),FH(this.Ma,b,c),FH(this.k,b,c),this.ca)};$APP.e.$b=function(a,b,c){return new fR(GH(this.r,b,c),GH(this.i,b,c),GH(this.Ma,b,c),GH(this.k,b,c),this.ca)};
$APP.e.ic=function(a,b){return new fR(HH(this.r,b),HH(this.i,b),HH(this.Ma,b),HH(this.k,b),this.ca)};var y4=function y4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return y4.C(arguments[0],c)};y4.C=function(a,b){b=$APP.qe(b);b=$APP.C.A(b,$APP.JR);a=pR.j?pR.j(a):pR.call(null,a);return $APP.k(b)?IF(b)(1,jG.j(a)):sG.j(a)};y4.G=1;y4.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var z4=gR(0,0,0,0,null),qsc=gR(1,0,0,0,null),rsc=gR(0,1,0,0,null),ssc=gR(0,0,1,0,null),tsc=gR(0,0,0,1,null),kR=function kR(a){switch(arguments.length){case 1:return kR.j(arguments[0]);case 2:return kR.A(arguments[0],arguments[1]);case 4:return kR.M(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};kR.j=function(a){return m$a(a)?a:$APP.kd(a)?$APP.Je.A(kR,$APP.We.A(4,a)):vG(a)?gR(a.ha,a.ia,0,0,null):gR(a,0,0,0,null)};
kR.A=function(a,b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return gR(a,c,d,b,null)};kR.M=function(a,b,c,d){return gR(a,b,c,d,null)};kR.G=4;var vR=function vR(a){switch(arguments.length){case 0:return vR.J();case 1:return vR.j(arguments[0]);case 2:return vR.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return vR.C(arguments[0],arguments[1],c)}};vR.J=function(){return z4};
vR.j=function(a){return a};vR.A=function(a,b){return kR.M(eH.A(a.r,b.r),eH.A(a.i,b.i),eH.A(a.Ma,b.Ma),eH.A(a.k,b.k))};vR.C=function(a,b,c){return $APP.Id.B(vR,vR.A(a,b),c)};vR.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};vR.G=2;
var wR=function wR(a){switch(arguments.length){case 0:return wR.J();case 1:return wR.j(arguments[0]);case 2:return wR.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return wR.C(arguments[0],arguments[1],c)}};wR.J=function(){return z4};wR.j=function(a){return nR(a)};wR.A=function(a,b){return kR.M(yG.A(a.r,b.r),yG.A(a.i,b.i),yG.A(a.Ma,b.Ma),yG.A(a.k,b.k))};
wR.C=function(a,b,c){return wR.A(a,$APP.Je.B(vR,b,c))};wR.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};wR.G=2;var xR=function xR(a){switch(arguments.length){case 0:return xR.J();case 1:return xR.j(arguments[0]);case 2:return xR.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return xR.C(arguments[0],arguments[1],c)}};xR.J=function(){return qsc};xR.j=function(a){return a};
xR.A=function(a,b){var c=a.r,d=a.i,g=a.Ma;a=a.k;var l=b.r,n=b.i,p=b.Ma;b=b.k;return kR.M(RF.A(iG.A(c,l),kG.C(iG.A(d,n),iG.A(g,p),$APP.y([iG.A(a,b)]))),kG.C(iG.A(c,n),iG.A(d,l),$APP.y([iG.A(g,b),iG.C(-1,a,$APP.y([p]))])),kG.C(iG.A(c,p),iG.C(-1,d,$APP.y([b])),$APP.y([iG.A(g,l),iG.A(a,n)])),kG.C(iG.A(c,b),iG.A(d,p),$APP.y([iG.C(-1,g,$APP.y([n])),iG.A(a,l)])))};xR.C=function(a,b,c){return $APP.Id.B(xR,xR.A(a,b),c)};
xR.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};xR.G=2;var uR=function uR(a){switch(arguments.length){case 0:return uR.J();case 1:return uR.j(arguments[0]);case 2:return uR.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return uR.C(arguments[0],arguments[1],c)}};uR.J=function(){return qsc};uR.j=function(a){return z$a(a)};
uR.A=function(a,b){return xR.A(a,z$a(b))};uR.C=function(a,b,c){return uR.A(a,$APP.Je.B(xR,b,c))};uR.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};uR.G=2;
var usc=CN.C($APP.y([new $APP.H(null,4,5,$APP.I,[1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,1,0,0],null),new $APP.H(null,4,5,$APP.I,[0,0,1,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,1],null)])),A4=CN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,1,0,0],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,-1],null),new $APP.H(null,4,5,$APP.I,[0,0,1,0],null)])),B4=CN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,0,1,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,1],null),new $APP.H(null,
4,5,$APP.I,[-1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,-1,0,0],null)])),C4=CN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,0,0,1],null),new $APP.H(null,4,5,$APP.I,[0,0,-1,0],null),new $APP.H(null,4,5,$APP.I,[0,1,0,0],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null)])),vsc=xN.j(usc),wsc=xN.j(A4),xsc=xN.j(B4),ysc=xN.j(C4),D4=QF.A(1,4);KF.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return q$a(a)});sG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return r$a(a)});
iZ.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return r$a(a)});tG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return new fR(tG.j(a.r),0,0,0,a.ca)});NF.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return new fR(NF.j(a.r),0,0,0,a.ca)});jZ.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return new fR(NF.j(a.r),0,0,0,a.ca)});
TF.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){var b=TF.j(a.r);return $APP.k(b)?(b=TF.j(a.i),$APP.k(b)?(b=TF.j(a.Ma),$APP.k(b)?TF.j(a.k):b):b):b});aG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return new $APP.D(null,N0b,new $APP.D(null,aG.j(a.r),new $APP.D(null,aG.j(a.i),new $APP.D(null,aG.j(a.Ma),new $APP.D(null,aG.j(a.k),null,1,null),2,null),3,null),4,null),5,null)});fG.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return jR(a,b)});
fG.F(null,new $APP.H(null,2,5,$APP.I,[YR,JU],null),function(a,b){return jR(b,a)});fG.F(null,new $APP.H(null,2,5,$APP.I,[JU,YR],null),function(a,b){return jR(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){return jR(b,a)});fG.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return jR(a,b)});fG.F(null,new $APP.H(null,2,5,$APP.I,[DG,JU],null),function(a,b){return jR(b,a)});fG.F(null,new $APP.H(null,2,5,$APP.I,[JU,DG],null),function(a,b){return jR(a,b)});
bG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return gR(bG.j(a.r),bG.j(a.i),bG.j(a.Ma),bG.j(a.k),$APP.ed(a))});eH.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return vR.A(a,b)});eH.F(null,new $APP.H(null,2,5,$APP.I,[FF,JU],null),function(a,b){return kR.M(eH.A(a,b.r),b.i,b.Ma,b.k)});eH.F(null,new $APP.H(null,2,5,$APP.I,[JU,FF],null),function(a,b){return kR.M(eH.A(a.r,b),a.i,a.Ma,a.k)});
eH.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){return vR.A(kR.j(a),b)});eH.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return vR.A(a,kR.j(b))});PF.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return nR(a)});yG.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return wR.A(a,b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[FF,JU],null),function(a,b){return kR.M(yG.A(a,b.r),PF.j(b.i),PF.j(b.Ma),PF.j(b.k))});
yG.F(null,new $APP.H(null,2,5,$APP.I,[JU,FF],null),function(a,b){return kR.M(yG.A(a.r,b),a.i,a.Ma,a.k)});yG.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){return wR.A(kR.j(a),b)});yG.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return wR.A(a,kR.j(b))});MF.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return xR.A(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[FF,JU],null),function(a,b){return u$a(a,b)});
MF.F(null,new $APP.H(null,2,5,$APP.I,[JU,FF],null),function(a,b){return v$a(a,b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){return xR.A(kR.j(a),b)});MF.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return xR.A(a,kR.j(b))});rI.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return H$a(a,b)});rI.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return H$a(a,kR.j(b))});
rI.F(null,new $APP.H(null,2,5,$APP.I,[JU,DG],null),function(a,b){return H$a(a,b)});OF.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return z$a(a)});zG.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return uR.A(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[FF,JU],null),function(a,b){return u$a(a,OF.j(b))});zG.F(null,new $APP.H(null,2,5,$APP.I,[JU,FF],null),function(a,b){return oR(a,b)});zG.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){return uR.A(kR.j(a),b)});
zG.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return uR.A(a,kR.j(b))});jG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return I$a(a)});pG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return A$a(a)});oG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return sR(a)});gO.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return C$a(a)});fO.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return B$a(a)});
tZ.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return D$a(a)});tH.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return E$a(a)});vH.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return F$a(a)});BZ.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return G$a(a)});mG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){var b=mG.j(a.r);if($APP.k(b))return b;b=mG.j(a.i);if($APP.k(b))return b;b=mG.j(a.Ma);return $APP.k(b)?b:mG.j(a.k)});
hG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return qR(a)});xG.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return qR(a)});qL.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return w$a(a)});xH.F(null,new $APP.H(null,1,5,$APP.I,[JU],null),function(a){return a.r});mR.F(null,new $APP.H(null,2,5,$APP.I,[JU,YR],null),function(a,b){return t$a(a,b)});TZ.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return y$a(a,b)});
TZ.F(null,new $APP.H(null,2,5,$APP.I,[JU,FF],null),function(){return z4});TZ.F(null,new $APP.H(null,2,5,$APP.I,[FF,JU],null),function(){return z4});TZ.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){b=b.ia;return kR.M(0,0,iG.A(a.k,b),RF.j(iG.A(a.Ma,b)))});TZ.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){a=a.ia;return kR.M(0,0,RF.j(iG.A(a,b.k)),iG.A(a,b.Ma))});BH.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return x$a(a,b)});
BH.F(null,new $APP.H(null,2,5,$APP.I,[FF,JU],null),function(a,b){return iG.A(a,b.r)});BH.F(null,new $APP.H(null,2,5,$APP.I,[JU,FF],null),function(a,b){return iG.A(a.r,b)});BH.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){return kG.A(iG.A(a.ha,b.r),iG.A(a.ia,b.i))});BH.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return kG.A(iG.A(a.r,b.ha),iG.A(a.i,b.ia))});cR.F(null,new $APP.H(null,2,5,$APP.I,[JU,FF],null),function(a,b){return oR(a,b)});
cR.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return uR.A(a,b)});cR.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){return uR.A(kR.j(a),b)});cR.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return uR.A(a,kR.j(b))});VF.F(null,new $APP.H(null,2,5,$APP.I,[FF,JU],null),function(a,b){return oR(b,a)});VF.F(null,new $APP.H(null,2,5,$APP.I,[JU,JU],null),function(a,b){return uR.A(b,a)});
VF.F(null,new $APP.H(null,2,5,$APP.I,[fT,JU],null),function(a,b){return uR.A(b,kR.j(a))});VF.F(null,new $APP.H(null,2,5,$APP.I,[JU,fT],null),function(a,b){return uR.A(kR.j(b),a)});var zsc=CN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,1,0,0],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,1],null),new $APP.H(null,4,5,$APP.I,[0,0,-1,0],null)])),Asc=CN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,0,1,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,-1],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,1,0,0],null)])),Bsc=CN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,0,0,1],null),new $APP.H(null,4,5,$APP.I,[0,0,1,0],null),new $APP.H(null,
4,5,$APP.I,[0,-1,0,0],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null)]));var E4=function E4(a){switch(arguments.length){case 1:return E4.j(arguments[0]);case 2:return E4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
E4.j=function(a){return function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);var c=$APP.x.B(b,2,null);c=$APP.x.B(c,0,null);var d=function(){var p=QQ.A?QQ.A(2,0):QQ.call(null,2,0);return p.j?p.j(a):p.call(null,a)}(),g=function(){var p=QQ.A?QQ.A(1,0):QQ.call(null,1,0);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}(),l=function(){var p=QQ.A?QQ.A(2,1):QQ.call(null,2,1);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}(),n=function(){var p=iG.A;var v=QQ.A?QQ.A(1,1):QQ.call(null,
1,1);v=v.j?v.j(a):v.call(null,a);p=p.call(iG,-1,v);return p.j?p.j(b):p.call(null,b)}();return iG.A(JN.B(c,function(){var p=QQ.A?QQ.A(2,0):QQ.call(null,2,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),c),RF.A(g,kG.C(function(){var p=QQ.j?QQ.j(0):QQ.call(null,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),iG.A(function(){var p=QQ.A?QQ.A(1,0):QQ.call(null,1,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),c),$APP.y([iG.A(function(){var p=QQ.A?
QQ.A(1,1):QQ.call(null,1,1);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),l),iG.A(function(){var p=QQ.A?QQ.A(2,1):QQ.call(null,2,1);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),n)]))))}};
E4.A=function(a,b){return function(c){var d=$APP.x.B(c,0,null),g=$APP.x.B(c,1,null),l=$APP.x.B(c,2,null);l=$APP.x.B(l,0,null);var n=function(){var A=QQ.A?QQ.A(2,0):QQ.call(null,2,0);return A.j?A.j(a):A.call(null,a)}(),p=function(){var A=QQ.A?QQ.A(1,0):QQ.call(null,1,0);A=A.j?A.j(a):A.call(null,a);return A.j?A.j(c):A.call(null,c)}(),v=function(){var A=QQ.A?QQ.A(2,1):QQ.call(null,2,1);A=A.j?A.j(a):A.call(null,a);return A.j?A.j(c):A.call(null,c)}(),t=uL.C($APP.y([d,g,uL.C($APP.y([l,v]))]));d=function(){var A=
QQ.A?QQ.A(2,0):QQ.call(null,2,0);A=A.j?A.j(b):A.call(null,b);return A.j?A.j(t):A.call(null,t)}();g=function(){var A=QQ.A?QQ.A(2,1):QQ.call(null,2,1);A=A.j?A.j(b):A.call(null,b);return A.j?A.j(t):A.call(null,t)}();g=RF.A(function(){var A=iG.A;var B=QQ.A?QQ.A(1,1):QQ.call(null,1,1);B=B.j?B.j(a):B.call(null,a);A=A.call(iG,-1,B);return A.j?A.j(c):A.call(null,c)}(),g);return iG.A(JN.B(l,function(){var A=QQ.A?QQ.A(2,0):QQ.call(null,2,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),l),
kG.A(RF.A(p,kG.C(function(){var A=QQ.j?QQ.j(0):QQ.call(null,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),iG.A(function(){var A=QQ.A?QQ.A(1,0):QQ.call(null,1,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),l),$APP.y([iG.A(function(){var A=QQ.A?QQ.A(1,1):QQ.call(null,1,1);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),v),iG.A(function(){var A=QQ.A?QQ.A(2,1):QQ.call(null,2,1);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),g)]))),
d))}};E4.G=2;$APP.F4=function F4(a){switch(arguments.length){case 1:return F4.j(arguments[0]);case 2:return F4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
$APP.F4.j=function(a){return function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);var c=$APP.x.B(b,2,null);c=$APP.x.B(c,0,null);var d=function(){var p=QQ.A?QQ.A(2,0):QQ.call(null,2,0);return p.j?p.j(a):p.call(null,a)}(),g=function(){var p=QQ.A?QQ.A(1,0):QQ.call(null,1,0);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}(),l=function(){var p=QQ.A?QQ.A(2,1):QQ.call(null,2,1);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}(),n=RF.j(function(){var p=QQ.A?QQ.A(1,1):QQ.call(null,
1,1);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}());return uL.C($APP.y([1,uL.C($APP.y([c,l])),uL.C($APP.y([iG.A(JN.B(c,function(){var p=QQ.A?QQ.A(2,0):QQ.call(null,2,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),c),RF.A(g,kG.C(function(){var p=QQ.j?QQ.j(0):QQ.call(null,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),iG.A(function(){var p=QQ.A?QQ.A(1,0):QQ.call(null,1,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),c),$APP.y([iG.A(function(){var p=
QQ.A?QQ.A(1,1):QQ.call(null,1,1);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),l),iG.A(function(){var p=QQ.A?QQ.A(2,1):QQ.call(null,2,1);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),n)])))),n]))]))}};
$APP.F4.A=function(a,b){return function(c){var d=$APP.x.B(c,0,null),g=$APP.x.B(c,1,null),l=$APP.x.B(c,2,null);l=$APP.x.B(l,0,null);var n=function(){var A=QQ.A?QQ.A(2,0):QQ.call(null,2,0);return A.j?A.j(a):A.call(null,a)}(),p=function(){var A=QQ.A?QQ.A(1,0):QQ.call(null,1,0);A=A.j?A.j(a):A.call(null,a);return A.j?A.j(c):A.call(null,c)}(),v=function(){var A=QQ.A?QQ.A(2,1):QQ.call(null,2,1);A=A.j?A.j(a):A.call(null,a);return A.j?A.j(c):A.call(null,c)}(),t=uL.C($APP.y([d,g,uL.C($APP.y([l,v]))]));d=function(){var A=
QQ.A?QQ.A(2,0):QQ.call(null,2,0);A=A.j?A.j(b):A.call(null,b);return A.j?A.j(t):A.call(null,t)}();g=function(){var A=QQ.A?QQ.A(2,1):QQ.call(null,2,1);A=A.j?A.j(b):A.call(null,b);return A.j?A.j(t):A.call(null,t)}();g=RF.A(function(){var A=iG.A;var B=QQ.A?QQ.A(1,1):QQ.call(null,1,1);B=B.j?B.j(a):B.call(null,a);A=A.call(iG,-1,B);return A.j?A.j(c):A.call(null,c)}(),g);return uL.C($APP.y([1,uL.C($APP.y([l,v])),uL.C($APP.y([iG.A(JN.B(l,function(){var A=QQ.A?QQ.A(2,0):QQ.call(null,2,0);A=A.j?A.j(n):A.call(null,
n);return A.j?A.j(c):A.call(null,c)}(),l),kG.A(RF.A(p,kG.C(function(){var A=QQ.j?QQ.j(0):QQ.call(null,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),iG.A(function(){var A=QQ.A?QQ.A(1,0):QQ.call(null,1,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),l),$APP.y([iG.A(function(){var A=QQ.A?QQ.A(1,1):QQ.call(null,1,1);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),v),iG.A(function(){var A=QQ.A?QQ.A(2,1):QQ.call(null,2,1);A=A.j?A.j(n):A.call(null,
n);return A.j?A.j(c):A.call(null,c)}(),g)]))),d)),g]))]))}};$APP.F4.G=2;var DR=function DR(a){switch(arguments.length){case 2:return DR.A(arguments[0],arguments[1]);case 3:return DR.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};DR.A=function(a,b){return DR.B(a,b,a.j?a.j(b):a.call(null,b))};DR.B=function(a,b,c){return function(d){var g=b+d;return((a.j?a.j(g):a.call(null,g))-c)/d}};DR.G=3;
var FR=function FR(a){switch(arguments.length){case 2:return FR.A(arguments[0],arguments[1]);case 3:return FR.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};FR.A=function(a,b){return FR.B(a,b,a.j?a.j(b):a.call(null,b))};FR.B=function(a,b,c){return function(d){var g=b-d;g=a.j?a.j(g):a.call(null,g);return(c-g)/d}};FR.G=3;
var GR=function GR(a){switch(arguments.length){case 2:return GR.A(arguments[0],arguments[1]);case 3:return GR.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};GR.A=function(a,b){return GR.B(a,b,a.j?a.j(b):a.call(null,b))};GR.B=function(a,b,c){var d=2*c;return function(g){return(function(){var l=b+g;return a.j?a.j(l):a.call(null,l)}()+function(){var l=b-g;return a.j?a.j(l):a.call(null,l)}()-d)/(g*g)}};GR.G=3;
var X$a=new $APP.ug(null,new $APP.f(null,4,[$$a,null,Mkb,null,ksb,null,cdb,null],null),null),G4=function G4(a){switch(arguments.length){case 1:return G4.j(arguments[0]);case 2:return G4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};G4.j=function(a){return G4.A(a,$APP.F)};
G4.A=function(a,b){var c=aab(b);return function(){function d(n,p){p=$APP.Ni.C($APP.y([c,p]));var v=$APP.qe(p),t=$APP.C.A(v,QHb),A=$APP.C.A(v,Z$a),B=$APP.C.A(v,B3b),G=$APP.C.A(v,$APP.ky);p=$APP.C.A(v,i7b);G=Y$a(G,a,n,a.j?a.j(n):a.call(null,n));var J=$APP.qe(G),O=$APP.C.A(J,ER),Q=$APP.C.A(J,CR);G=$APP.C.A(J,WG);J=$APP.C.A(J,BR);n=$APP.k(B)?B:.1*hG.j(n);$APP.k(t)?A=t:(t=O.j?O.j(n):O.call(null,n),A=Math.floor(Math.log(A/(MR*(Math.floor(Math.abs(t))+1)))/Math.log(2))+1);n=$APP.Vg.A(Q,V2.A(2,n));v=DQ.A(GQ.M(n,
2,G,J),$APP.rg.B(v,QHb,A));return $APP.k(p)?v:nQ.j(v)}function g(n){return l.A(n,$APP.F)}var l=null;l=function(n,p){switch(arguments.length){case 1:return g.call(this,n);case 2:return d.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.j=g;l.A=d;return l}()};G4.G=2;$APP.lab=$APP.Vr(2);var fab={},gab={},IR;var pab=IF(1E-8),H4=function H4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return H4.C(arguments[0],c)};
H4.C=function(a,b){var c=qab(a,b);return function(){function d(n,p,v){return c(n,0,p,v)}function g(n,p){return l.B(n,p,$APP.F)}var l=null;l=function(n,p,v){switch(arguments.length){case 2:return g.call(this,n,p);case 3:return d.call(this,n,p,v)}throw Error("Invalid arity: "+arguments.length);};l.A=g;l.B=d;return l}()};H4.G=1;H4.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var I4=function I4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return I4.C(arguments[0],c)};I4.C=function(a,b){return qab(a,b)};I4.G=1;I4.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var J4=function J4(a){switch(arguments.length){case 1:return J4.j(arguments[0]);case 2:return J4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};J4.j=function(a){return J4.A(Math.PI/2,a)};J4.A=function(a,b){var c=Math.sin(a);a=Math.cos(a);a*=a;b*=c;var d=(1-b)*(1+b);return c*(LR(a,d,1)-b*b*(sab(a,d,1)/3))};J4.G=2;
var K4=function K4(a){switch(arguments.length){case 2:return K4.A(arguments[0],arguments[1]);case 3:return K4.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};K4.A=function(a,b){return K4.B(Math.PI/2,a,b)};K4.B=function(a,b,c){var d=Math.sin(a);a=Math.cos(a);b=b*d*d;a*=a;c*=d;c=(1-c)*(1+c);return d*(LR(a,c,1)+b*(uab(a,c,1,1-b)/3))};K4.G=3;
var L4=function L4(a){switch(arguments.length){case 2:return L4.A(arguments[0],arguments[1]);case 3:return L4.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};L4.A=function(a,b){return L4.B(a,b,$APP.ns)};
L4.B=function(a,b,c){b=1-b*b;if($APP.Uc.A(b,0)){var d=1/Math.cosh(a);a=Math.tanh(a);var g=b=d;return c.B?c.B(a,b,g):c.call(null,a,b,g)}b=xab(b,a);a=$APP.x.B(b,0,null);var l=$APP.x.B(b,1,null);g=$APP.x.B(b,2,null);b=$APP.x.B(b,3,null);for(var n=1,p=l,v=1,t=$APP.sf,A=$APP.sf;;){var B=Math.sqrt(p),G=.5*(n+B);if(Math.abs(n-B)>HR*n&&13>v){p=G;var J=n*B;v+=1;l=$APP.Yd(n,t);B=$APP.Yd(B,A);n=p;p=J;t=l;A=B}else{g*=G;var O=Math.sin(g);d=Math.cos(g);v=$APP.Uc.A(O,0)?new $APP.H(null,4,5,$APP.I,[n,O,d,1],null):
function(){for(var Q=t,W=A,Z=d/O,fa=Z*G,ha=1;;)if($APP.r(Q)&&$APP.r(W)){var ja=$APP.u(Q),ta=function(){var Y=fa*Z,ea=ha*fa;Y=($APP.u(W)+Y)/(Y+ja);return new $APP.H(null,3,5,$APP.I,[ea/ja,ea,Y],null)}(),ua=$APP.x.B(ta,0,null),ca=$APP.x.B(ta,1,null),V=$APP.x.B(ta,2,null);Q=$APP.Fc(Q);W=ta=$APP.Fc(W);Z=ua;fa=ca;ha=V}else{var da=1/Math.sqrt(1+fa*fa);ta=function(){var Y=0>O?-da:da;return new $APP.H(null,2,5,$APP.I,[Y,fa*Y],null)}();Q=$APP.x.B(ta,0,null);ta=$APP.x.B(ta,1,null);return new $APP.H(null,4,
5,$APP.I,[Z,Q,ta,ha],null)}}();n=$APP.x.B(v,0,null);l=$APP.x.B(v,1,null);g=$APP.x.B(v,2,null);v=$APP.x.B(v,3,null);return $APP.k(a)?(a=l/b,b=n,c.B?c.B(a,b,g):c.call(null,a,b,g)):c.B?c.B(l,g,v):c.call(null,l,g,v)}}};L4.G=3;var Gab=U2a(function(a,b,c){b=$APP.qe(c);var d=$APP.C.A(b,Hab),g=$APP.C.A(b,Iab),l=$APP.C.A(b,RR);return function(n){return EO(a)(QR(a,kG.A(Bab(d,g)(n),l)))}},function(a,b,c){c=$APP.qe(c);var d=$APP.C.A(c,Hab),g=$APP.C.A(c,Iab),l=$APP.C.A(c,RR);return function(n){n=Bab(RF.j(d),g)(RF.A(DO(a)(n),l));return QR(b,n)}}),Csc=U2a(Kab,Lab),Dsc=Csc(ITb,ITb);var M4=function M4(a){switch(arguments.length){case 3:return M4.B(arguments[0],arguments[1],arguments[2]);case 4:return M4.M(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return M4.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};M4.B=function(a,b,c){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,UN,null,1,null),new $APP.D(null,c,null,1,null))))};
M4.M=function(a,b,c,d){$APP.rg.B(b,zX,!0);return $APP.Td(d)&&$APP.Uc.A($APP.dv,$APP.u(d))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,UN,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,d,null,1,null)))),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,UN,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)]))))};
M4.S=function(a,b,c,d,g){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,UN,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null),new $APP.D(null,g,null,1,null)]))))};M4.G=5;var N4=function N4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return N4.C(arguments[0],arguments[1],c)};
N4.C=function(a,b,c){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,fWb,null,1,null),c)))};N4.G=2;N4.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var O4=function O4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=3<c.length?new $APP.Bc(c.slice(3),0,null):null;return O4.C(arguments[0],arguments[1],arguments[2],c)};
O4.C=function(a,b,c,d){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,Mlb,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([d]))))};O4.G=3;O4.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};var P4=function P4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=4<c.length?new $APP.Bc(c.slice(4),0,null):null;return P4.C(arguments[0],arguments[1],arguments[2],arguments[3],c)};
P4.C=function(a,b,c,d,g){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,G1b,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null),g]))))};P4.G=4;P4.K=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);var g=$APP.w(d);d=$APP.u(g);g=$APP.w(g);return this.C(b,a,c,d,g)};
var Q4=function Q4(a){switch(arguments.length){case 1:return Q4.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return Q4.C(arguments[0],c)}};Q4.j=function(a){return a};
Q4.C=function(a,b){return UH(a)?WH.C($APP.y([function(c){return $APP.Je.B(Q4,c,b)},a])):DK(a)?JK.A(WH.C($APP.y([function(c){return $APP.Je.B(Q4,c,b)},EK(a)])),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.KK,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,LK,null,1,null),b))),null,1,null),$APP.y([new $APP.D(null,GK(a),null,1,null)]))))):$APP.Aba(a)&&$APP.Ge(CF,b)?oN(a)?T1a(a,b):$APP.Zl.A(a,b):$APP.Zl.A(a,b)};Q4.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
Q4.G=1;var R4=function R4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return R4.C(c)};R4.C=function(a){return function(b){return $APP.Je.B(Q4,b,a)}};R4.G=0;R4.K=function(a){return this.C($APP.r(a))};var S4=function S4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return S4.C(c)};
S4.C=function(a){return $APP.Ge($APP.xd,a)?$APP.Je.A(QQ,a):$APP.Je.A($APP.Pi,a)};S4.G=0;S4.K=function(a){return this.C($APP.r(a))};var Esc=Math.PI,Fsc=RF.j(Math.PI),Gsc=iG.A(2,Math.PI),Hsc=RF.j(Gsc),Isc=Math.E,Jsc,Ksc=Math.sqrt(5)+1;Jsc=QF.A?QF.A(Ksc,2):QF.call(null,Ksc,2);var T4=function T4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return T4.C(arguments[0],c)};
T4.C=function(a,b){b=$APP.qe(b);b=$APP.C.A(b,$APP.TW);return Q3.C(bG.j(a),$APP.y([VDb,$APP.k(b)?b:!0]))};T4.G=1;T4.K=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var Psc;
Psc=$APP.fg([Pcc,$5b,Igb,X0b,I8b,Abb,kUb,H0b,BGb,wPb,Wcb,Ocb,ISb,dSb,Emb,s3b,rbc,eGb,vub,wkb,fob,Idb,fV,ugb,F$b,e1b,lOb,U6b,Ywb,YVb,DRb,sBb,G0b,nDb,IYb,Ctb,T2b,dVb,q3b,Eqb,lfb,h6b,Izb,zcb,hsb,Eyb,rSb,Pib,Wbc,VQb,NDb,cbc,XCb,mHb,t5b,qyb,RQb,V6b,Ekb,Rgb,fZb,wGb,yrb,m0b,Jhb,bAb,w4b,v3b,Vqb,rZb,fXb,o5b,Z2b,fzb,Mub,jZb,tib],[$APP.ap(new $APP.f(null,8,[$APP.z(Ldb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[YW,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null)))],
null)),new $APP.f(null,3,[$APP.R,rIb,$APP.X,NR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[YW,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null))],null)],null),$APP.z(kFb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[YW],null)],null)))],null)),new $APP.f(null,3,[$APP.R,Tpb,$APP.X,OR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[YW],null)],null))],null)],
null),$APP.z(qZb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[$APP.Hv,$APP.Vv,$APP.SP,$APP.TP],null)],null)))],null)),new $APP.f(null,3,[$APP.R,$ib,$APP.X,PR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[$APP.Hv,$APP.Vv,$APP.SP,$APP.TP],null)],null))],null)],null),$APP.z(Jpb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gS],null)))],null)),new $APP.f(null,3,[$APP.R,
iNb,$APP.X,yab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[gS],null))],null)],null),$APP.z(bVb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gS],null)))],null)),new $APP.f(null,3,[$APP.R,dBb,$APP.X,zab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[gS],null))],null)],null),$APP.z(S_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ieb],null)))],null)),new $APP.f(null,3,[$APP.R,lTb,$APP.X,Aab,$APP.h,
new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[ieb],null))],null)],null),$APP.z(mYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xFb,NY],null))),$APP.P,"Takes a unit 3-vector `direction` (representing a direction) and a velocity\n  `v:c` normalized by `C`."],null)),new $APP.f(null,3,[$APP.R,dac,$APP.X,Bab,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a unit 3-vector `direction` (representing a direction) and a velocity\n  `v:c` normalized by `C`.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[xFb,NY],null))],null)],null),$APP.z(yWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null)))],null)),new $APP.f(null,3,[$APP.R,Eub,$APP.X,Cab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null))],null)],null)],null),$APP.Zo(Pcc)),$APP.ap($APP.fg([$APP.z(PKb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(WMb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(FGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[FU],null))),$APP.P,"Given a 2x2 complex matrix `M` of the form\n\n  ```\n  [ a + b i,  c + d i]\n  [ -c + d i, a - b i]\n  ```\n\n  Returns a [[Quaternion]] instance with coefficients `[a b c d]`."],null)),$APP.z(J$a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))),$APP.P,"Given a normalized [[Quaternion]] `q`, returns the corresponding orthogonal 3x3\n  rotation matrix representing a rotation in 3d-space.\n\n  The implementation here will first normalize `q` for you and then generate a\n  rotation matrix from that new quaternion `q-normal`.\n\n  [[-\x3erotation-matrix]] will still work if `q` isn't normalized; but if\n  a [[Quaternion]] isn't normalized it doesn't make sense to interpret it as a\n  rotation.\n\n  See https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix"],
null)),$APP.z(nS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns `true` if `q` is an instance of [[Quaternion]], false otherwise."],null)),$APP.z($APP.Lac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns a new quaternion generated by dividing each coefficient of the supplied\n  quaternion `q` by the [[magnitude]] of `q`. (If the [[magnitude]]\n  is [[zero?]], returns the zero quaternion `q`.)\n\n  The returned quaternion will have [[magnitude]] (approximately) equal to\n  1. [[unit?]] will return true for a [[normalize]]d quaternion, though you may\n  need to supply an `:epsilon`."],
null)),$APP.z(Edb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))),$APP.P,"Given a unit quaternion `q` [representing a spatial\n  rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation) (sometimes\n  called a 'versor'), returns a pair of\n\n  - `theta`, the rotation in radians about the rotation axis\n  - `axis`, a 3-element unit vector with elements `x`, `y` and `z` representing\n    an axis of rotation in 3d Euclidean space.\n\n  If the unit quaternion `q` represents NO rotation, the axis is undefined; this\n  manifests as the squared norm of the non-real vector part of `q` sitting\n  within [[*angle-axis-tolerance*]] of 0.\n\n  In this case, the conversion is degenerate and [[-\x3eangle-axis]] returns the\n  pair [0 [1 0 0]] as a default. (This check only occurs with a quaternion with\n  all numeric elements in the non-real positions.)"],
null)),$APP.z(wH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the hyperbolic sine of the supplied quaternion `q`.\n\n  [[sinh]] is defined in terms of the [[exp]] function as `(e^q - e^{-q}) / 2`."],null)),$APP.z(NLb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(AEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))),$APP.P,"Returns the `r` component of the supplied quaternion `q`.\n\n  Identical to [[real-part]]."],
null)),$APP.z(kH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the sine of the supplied quaternion `q`.\n\n  See the [Boost\n  documentation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/trans.html)\n  and [source](https://www.boost.org/doc/libs/1_78_0/boost/math/quaternion.hpp)\n  for a reference implementation."],null)),$APP.z(ivb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[vU,$APP.Lh,
new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.XU],null)],null)],null))),$APP.P,"Returns true if `q` is a unit quaternion (i.e., a 'versor', a quaternion\n  with [[magnitude]] equal to one), false otherwise.\n\n  To check if the [[magnitude]] of `q` is /approximately/ equal to one, pass a\n  tolerance via the `:epsilon` keyword argument.\n\n  For more control, use [[magnitude]] to compute the magnitude directly.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,
1,5,$APP.I,[$APP.M(vU,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.XU],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[vU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.XU],null)],null)],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(sXb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(WHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[CY,$APP.BX],null))),$APP.P,"Returns a [[Quaternion]] that represents a rotation of `angle` radians around a\n  normalized version of the vector described by `axis`. `axis` must be a\n  3-vector with components `x`, `y` and `z`.\n\n  Given an `axis` with numeric entries, [[from-angle-axis]] will explicitly\n  normalize `axis` before calling [[from-angle-normal-axis]]. If any entries are\n  non-numerical (i.e., symbolic), [[from-angle-axis]] will instead log an\n  assumption that the magnitude of `axis` \x3d\x3d 1 and proceed.\n\n  NOTE: If you have an already-normalized axis,\n  prefer [[from-angle-normal-axis]]."],
null)),$APP.z(lK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the tangent of the supplied quaternion `q`.\n\n  [[tan]] is defined as `(/ (sin q) (cos q))`."],null)),$APP.z(sH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the cosine of the supplied quaternion `q`.\n\n  See the [Boost\n  documentation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/trans.html)\n  and [source](https://www.boost.org/doc/libs/1_78_0/boost/math/quaternion.hpp)\n  for a reference implementation."],
null)),$APP.z(ZHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns true if the quaternion `q` has zero entries for all non-real fields,\n  false otherwise."],null)),$APP.z(lvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"Given two complex numbers `a` and `b`, returns a quaternion instance with\n\n  - `r` and `i` components set to the real and imaginary components of `a`\n  - `j` and `k` components set to the real and imaginary components of `b`"],
null)),$APP.z(Ncc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[lO,$APP.mO],null))),$APP.P,"Returns a quaternion representing the (vector) cross product of the two pure\n  sides (retrieved via [[three-vector]]) of the supplied quaternions `l` and\n  `r`.\n\n  NOTE that the suggestion for this function comes from this [C++ quaternion\n  library](https://github.com/ferd36/quaternions/blob/master/include/quaternion.h#L1109).\n  Strictly, this is not the 'cross product of two quaternions'."],
null)),$APP.z(REb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))),$APP.P,"Returns the `i` component of the supplied quaternion `q`."],null)),$APP.z($APP.JX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null))),$APP.P,"Variadic function for subtracting quaternion arguments.\n\n  - Given no arguments, returns [[ZERO]], the additive identity.\n  - Given 1 argument `q`, acts as identity.\n  - Given 2 arguments, returns the difference of quaternions `q1` and `q2`.\n  - Given more than 2 arguments, returns the difference of the first quaternion\n    `q1` with the sum of all remaining arguments.\n\n  The difference of two quaternions is a new quaternion with coefficients equal\n  to the pairwise difference of the coefficients of `q1` and `q2`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null,null)],null)],null)),$APP.z(bX,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z($Bb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[CY],null))),$APP.P,"Create a quaternion representing a roll rotation by the supplied\n  `angle` (specified in radians)."],null)),$APP.z(hX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the multiplicative inverse of the supplied quaternion `q`.\n\n  The inverse of a quaternion is a new quaternion that, when [[mul]]tiplied by\n  `q`, will produce the [[ONE]] quaternion (the multiplicative identity)."],null)),$APP.z(CU,new $APP.f(null,
1,[$APP.Kw,!0],null)),$APP.z(GX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[lO,$APP.mO],null))),$APP.P,"Returns the quaternion dot product of the supplied quaternions `l` and `r`.\n\n  The quaternion dot product is the sum of the products of the corresponding\n  coefficients of each quaternion, equal to\n\n  $$r_l * r_r + i_l * i_r + j_l * j_r + k_l * k_r$$"],null)),$APP.z(UYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CY],null))),$APP.P,
"Create a quaternion representing a yaw rotation by the supplied\n  `angle` (specified in radians)."],null)),$APP.z($T,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))),$APP.P,"Returns the `r` component of the supplied quaternion `q`.\n\n  Identical to [[get-r]]."],null)),$APP.z(BJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the logarithm $\\ln q$ of the supplied quaternion `q`.\n\n  Given a quaternion $q$ with real part $r$ and non-real vector $\\vec{v}$, the\n  logarithm [is computed\n  as](https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions)\n\n  $$\n  \\ln(q) \x3d \\ln \\|q\\| + \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\\n  \\arccos \\frac{r}{\\|\\q\\|}\n  $$"],
null)),$APP.z(Ebc,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(iS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,QT],null))),$APP.P,"Given a quaternion `q` with function coefficients and a possibly-empty sequence\n  of partial derivative `selectors`, returns a new [[Quaternion]] generated by\n  replacing each (functional) coefficient with its derivative with respect to\n  `selectors`."],null)),$APP.z(Myb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z($APP.d8b,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.mO,SX,$ob,JIb],null))),$APP.P,"Generates a [[Quaternion]] instance, given:\n\n  - a magnitude `r`\n  - a rotation angle `theta`, with a natural range of `-2*pi` to `2*pi`\n  - `colat`, the [colatitude](https://mathworld.wolfram.com/Colatitude.html) of\n    the (non-real) vectorial part of the quaternion\n  - `lon`, the longitude of the vectorial part of the quaternion"],null)),$APP.z(CEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[vU],null))),$APP.P,"Returns the 4x4 matrix representation of the supplied [[Quaternion]] `q`."],null)),$APP.z(iLb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(uH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the hyperbolic cosine of the supplied quaternion `q`.\n\n  [[cosh]] is defined in terms of the [[exp]] function as `(e^q + e^{-q}) / 2`."],null)),$APP.z(gU,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.mO,new $APP.H(null,3,5,$APP.I,[$APP.Ov,sU,$APP.tU],null)],null),new $APP.H(null,4,5,$APP.I,[$APP.mO,$APP.Ov,sU,$APP.tU],null))),$APP.P,"Constructor that builds [[Quaternion]] instances out of a variety of types.\n  Given:\n\n  - a quaternion `x`, acts as identity.\n\n  - a sequential `x`, returns a quaternion with coefficients built from the\n    first four entries.\n\n  - a complex number `x`, returns a quaternion built from the real and imaginary\n    components of `x` with `j` and `k` components equal to zero.\n\n  - a real number `x` and 3-vector, returns a quaternion with real coefficient\n    equal to `x` and imaginary components equal to the elements of the vector\n\n  - 4 distinct arguments `r`, `i`, `j` and `k`, returns a quaternion with these\n    as the coefficients.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.mO,new $APP.H(null,3,5,$APP.I,[$APP.Ov,sU,$APP.tU],null)],null),new $APP.H(null,4,5,$APP.I,[$APP.mO,$APP.Ov,sU,$APP.tU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.mO,new $APP.H(null,3,5,$APP.I,[$APP.Ov,sU,$APP.tU],null)],null),new $APP.H(null,4,5,$APP.I,[$APP.mO,$APP.Ov,
sU,$APP.tU],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(DJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Pv],null))),$APP.P,"Returns the result of raising quaternion `q` to the real, complex or quaternion\n  power `p`."],null)),$APP.z(EU,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(URb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CY],null))),$APP.P,"Create a quaternion representing a pitch rotation by the supplied\n  `angle` (specified in radians)."],
null)),$APP.z(PX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the negation (additive inverse) of the supplied quaternion `q`.\n\n  The additive inverse of a quaternion is a new quaternion that, when [[add]]ed\n  to `q`, will produce the [[ZERO]] quaternion (the additive identity)."],null)),$APP.z(tVb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(Qdb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(AK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[vU],null))),$APP.P,"Returns the norm of the supplied quaternion `q`.\n\n  The norm of a quaternion is the square root of the sum of the squares of the\n  quaternion's coefficients."],null)),$APP.z(JY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null))),$APP.P,"Variadic function for dividing quaternion arguments.\n\n  - Given no arguments, returns [[ONE]], the multiplicative identity.\n  - Given 1 argument `q`, acts as identity.\n  - Given 2 arguments, returns the quotient of quaternions `q1` and `q2`.\n  - Given more than 2 arguments, returns the quotient of the first quaternion\n    `q1` with the product of all remaining arguments.\n\n  The quotient of two quaternions is a new quaternion equal to the product of\n  `q1` and the multiplicative inverse of `q2`",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null,null)],null)],null)),$APP.z(Bpb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(F3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[vU],null))),$APP.P,"Returns true if the quaternion `q` has a zero real entry, false otherwise.\n\n  A 'pure' quaternion is sometimes called an 'imaginary' quaternion."],null)),$APP.z(VCb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(TDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))),$APP.P,"Returns a pair of complex number created respectively from the `(r,i)`\n  and `(j,k)` components of the supplied quaternion `q`.\n\n  NOTE that this only works if the coefficients of `q` are real numbers, due to\n  restrictions on the current complex number implementation. "],
null)),$APP.z(TEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))),$APP.P,"Returns the `k` component of the supplied quaternion `q`."],null)),$APP.z(VPb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(Bjb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,22,[$S,"null",LT,"null",SV,"null",kU,"null",SW,"null",oU,"null",hU,"null",WE,"null",$Lb,"null",xX,"null",SS,"null",rS,"null",lS,"null",LY,"null",gV,"null",uX,"null",
uY,"null",nT,"null",RW,"null",jW,"null",RV,"null",tY,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.mO,$APP.Ov,sU,$APP.tU,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,17,[$S,"null",LT,"null",SV,"null",kU,"null",SW,"null",oU,"null",xX,"null",SS,"null",rS,"null",lS,"null",gV,"null",uX,"null",uY,"null",nT,"null",RW,"null",jW,"null",tY,"null"],null),null),$APP.P,"Positional factory function for emmy.quaternion/Quaternion."],null)),$APP.z(HCb,new $APP.f(null,
1,[$APP.Pu,!0],null)),$APP.z($APP.gT,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null))),$APP.P,"Variadic function that returns the sum of all supplied quaternions.\n\n  Given 1 argument `q`, acts as identity. Given no arguments, returns [[ZERO]],\n  the additive identity.\n\n  The sum of two or more quaternions is a new quaternion with coefficients equal\n  to the elementwise sum of the coefficients of all supplied quaternions.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null,null)],null)],null)),$APP.z(xMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$Sb,ndb,aTb,ldb],
null))),$APP.P,"Returns a [[Quaternion]] instance with [[complex-1]] part built from the polar\n  coordinates `r1` and `theta1` and [[complex-2]] part built from `r2` and\n  `theta2`"],null)),$APP.z($Jb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xac],null))),$APP.P,"Given a 4x4 matrix representation of a quaternion, returns the associated\n  quaternion by extracting the first row."],null)),$APP.z(Pkb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,
5,$APP.I,[$APP.mO,OX,ndb,ldb],null))),$APP.P,"Returns a [[Quaternion]] `q` with magnitude `rho`, built such that:\n\n  - the magnitude of `q` equals `rho`\n  - the magnitude `([[complex-1]] q)` equals `(* rho (cos alpha))`\n  - the angle of `([[complex-1]] q)` equals `theta1`\n  - The magnitude `([[complex-2]] q)` equals `(* rho (cos alpha))`\n  - the angle of `([[complex-2]] q)` equals `theta12`\n\n  This strange, possibly unnecessary constructor taken from the [Boost\n  quaternion\n  implementation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/create.html)."],
null)),$APP.z(rBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns a 2x2 complex matrix representation of the supplied Quaternion `q`.\n\n  For a quaternion with coefficients `[a b c d]`, the returned matrix will have\n  the following form:\n\n  ```\n  [ a + b i,  c + d i]\n  [ -c + d i, a - b i]\n  ```\n\n  NOTE that this currently only works for quaternions `q` with real or symbolic\n  entries."],null)),$APP.z(h4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the `r` and `i` components of the quaternion `q` as a `Complex` number\n  instance."],null)),$APP.z(f4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the `j` and `k` components of the quaternion `q` as a `Complex` number\n  instance."],null)),$APP.z(nY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the conjugate of the supplied quaternion `q`.\n\n  The conjugate of a quaternion is a new quaternion with real coefficient equal\n  to that of `q` and each imaginary coefficient negated. `(mul q (conjugate q))`\n  will return a [[real?]] quaternion."],
null)),$APP.z(YQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))),$APP.P,"Given an orthogonal 3x3 matrix M representing a rotation in 3-space, returns\n  the unit quaternion that corresponds to the same transformation.\n\n  GJS notes in scmutils that this algorithm is the 'expanded Matt Mason method'.\n\n  NOTE Orthogonal means, no stretching allowed, only rotation!\n\n  NOTE this routine uses non-generic [[clojure.core/\x3e\x3d]]\n  and [[clojure.core/max]] internally, so if you use numeric entries (or if your\n  entries simplify down to numbers), make sure that they work with these native\n  operations. No `BigInt` in ClojureScript for now, for example."],
null)),$APP.z(pFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[lO,$APP.mO],null))),$APP.P,"Returns the commutator of the supplied quaternions `l` and `r`.\n\n  The commutator of two quaternions is equal to\n\n  ```clj\n  (- (* l r) (* r l))\n  ```"],null)),$APP.z(FJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the square root of the supplied quaternion `q`.\n\n  `([[sqrt]] q)` is identical to, but more efficient than, raising `q` to the\n  1/2 power.\n\n  Thanks to the [Spire\n  library](https://github.com/typelevel/spire/blob/82f607714f94ba1c70b13fd4751063dfdcd155f5/core/src/main/scala/spire/math/Quaternion.scala#L217)\n  for the correct implementation used here."],
null)),$APP.z($APP.iX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Sv],null))),$APP.P,"Returns a new quaternion generated by multiplying each coefficient of the\n  supplied quaternion `q` by the supplied scalar `s` on the right."],null)),$APP.z(ZT,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(XNb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(Lzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,
new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))),$APP.P,"Returns a 4-vector of the coefficients of quaternion `q`.\n\n  Works identically to `(vec q)`, but more efficient as we are able to create\n  the new vector in one shot."],null)),$APP.z(zJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the exponential $e^q$ of the supplied quaternion `q`.\n\n  Given a quaternion $q$ with real part $r$ and non-real vector $\\vec{v}$, the\n  exponential [is computed\n  as](https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions)\n\n  $$\n  \\exp(q) \x3d e^r \\left(\\cos \\|\\mathbf{v}\\| \\\n  + \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\sin\\|\\mathbf{v}\\| \\right)\n  $$"],
null)),$APP.z(SEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))),$APP.P,"Returns the `j` component of the supplied quaternion `q`."],null)),$APP.z(Wjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[CY,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null))),$APP.P,"Returns a [[Quaternion]] that represents a rotation of `angle` radians around\n  the unit (normalized) vector described by the second argument, a 3-vector with\n  components `x`, `y` and `z`.\n\n  The second argument represents an axis of rotation.\n\n  NOTE: If you have an UN-normalized axis, prefer [[from-angle-axis]]."],
null)),$APP.z(oX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))),$APP.P,"Returns the hyperbolic tangent of the supplied quaternion `q`.\n\n  [[tan]] is defined as `(/ (sinh q) (cosh q))`."],null)),$APP.z(Bec,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))),$APP.P,"Returns a 3-vector holding the coefficients of the non-real (imaginary)\n  components of the quaternion `q`."],
null)),$APP.z(YU,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null))),$APP.P,"Variadic function that returns the product of all supplied quaternions.\n\n  Given 1 argument `q`, acts as identity. Given no arguments, returns [[ONE]],\n  the multiplicative identity.\n\n  The product of two or more quaternions is a new quaternion generated by\n  multiplying together each quaternion of the form `(r+ai+bj+ck)`, respecting\n  the quaternion rules:\n\n  i^2 \x3d\x3d j^2 \x3d\x3d k^2 \x3d\x3d -1\n  ijk \x3d\x3d -1,\n  ij  \x3d\x3d k,  jk \x3d\x3d i,  ki \x3d\x3d j\n  ji  \x3d\x3d -k, kj \x3d\x3d -i, ik \x3d\x3d -j",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null,null)],null)],null)),$APP.z(IIb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(tTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[vU,$APP.Sv],null))),$APP.P,"Returns a new quaternion generated by dividing each coefficient of the supplied\n  quaternion `q` by the supplied scalar `s`."],null)),$APP.z(atb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Rv,$APP.mO,SX,WR],null))),$APP.P,"Returns a [[Quaternion]] `q` with [[real-part]] equal to `t` and\n  the [[three-vector]] part built from the spherical coordinates `r`, `colat`\n  and `lon`."],null)),$APP.z(GXb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.JGb,CY,sU,$APP.tU],null))),$APP.P,"Returns a [[Quaternion]] `q` with [[complex-1]] built from the polar\n  coordinates `mag` and `angle`, and `j` and `k` components equal to the\n  supplied `j` and `k`."],null))],[new $APP.f(null,3,[$APP.R,pcc,$APP.X,C4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,syb,$APP.X,z4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,yUb,$APP.X,function(a){a=Q1a(a);var b=$APP.x.B(a,0,null);a=$APP.x.B(b,0,null);b=$APP.x.B(b,
1,null);return kR.M(xH.j(a),AH.j(a),xH.j(b),AH.j(b))},$APP.h,new $APP.f(null,2,[$APP.P,"Given a 2x2 complex matrix `M` of the form\n\n  ```\n  [ a + b i,  c + d i]\n  [ -c + d i, a - b i]\n  ```\n\n  Returns a [[Quaternion]] instance with coefficients `[a b c d]`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))],null)],null),new $APP.f(null,3,[$APP.R,dHb,$APP.X,K$a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a normalized [[Quaternion]] `q`, returns the corresponding orthogonal 3x3\n  rotation matrix representing a rotation in 3d-space.\n\n  The implementation here will first normalize `q` for you and then generate a\n  rotation matrix from that new quaternion `q-normal`.\n\n  [[-\x3erotation-matrix]] will still work if `q` isn't normalized; but if\n  a [[Quaternion]] isn't normalized it doesn't make sense to interpret it as a\n  rotation.\n\n  See https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Iib,$APP.X,m$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `q` is an instance of [[Quaternion]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,pOb,$APP.X,function(a){return $APP.k(q$a(a))?a:oR(a,qR(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new quaternion generated by dividing each coefficient of the supplied\n  quaternion `q` by the [[magnitude]] of `q`. (If the [[magnitude]]\n  is [[zero?]], returns the zero quaternion `q`.)\n\n  The returned quaternion will have [[magnitude]] (approximately) equal to\n  1. [[unit?]] will return true for a [[normalize]]d quaternion, though you may\n  need to supply an `:epsilon`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,eOb,$APP.X,function(a){var b=hR(a),c=pL(b,b);var d=(d=$APP.Ge(EF,b))?IF(1E-8)(0,c):d;if($APP.k(d))return new $APP.H(null,2,5,$APP.I,[0,new $APP.H(null,3,5,$APP.I,[1,0,0],null)],null);c=jG.j(c);a=MF.A(2,rG.A(c,a.r));b=zG.A(b,c);return new $APP.H(null,2,5,$APP.I,[a,b],null)},$APP.h,new $APP.f(null,2,[$APP.P,"Given a unit quaternion `q` [representing a spatial\n  rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation) (sometimes\n  called a 'versor'), returns a pair of\n\n  - `theta`, the rotation in radians about the rotation axis\n  - `axis`, a 3-element unit vector with elements `x`, `y` and `z` representing\n    an axis of rotation in 3d Euclidean space.\n\n  If the unit quaternion `q` represents NO rotation, the axis is undefined; this\n  manifests as the squared norm of the non-real vector part of `q` sitting\n  within [[*angle-axis-tolerance*]] of 0.\n\n  In this case, the conversion is degenerate and [[-\x3eangle-axis]] returns the\n  pair [0 [1 0 0]] as a default. (This check only occurs with a quaternion with\n  all numeric elements in the non-real positions.)",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Vcc,$APP.X,F$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the hyperbolic sine of the supplied quaternion `q`.\n\n  [[sinh]] is defined in terms of the [[exp]] function as `(e^q - e^{-q}) / 2`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,C7b,$APP.X,pR,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns the square of the [[magnitude]] of the supplied quaternion `q`,\n  equivalent to taking the [[dot-product]] of `q` with itself.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,EDb,$APP.X,function(a){return a.r},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `r` component of the supplied quaternion `q`.\n\n  Identical to [[real-part]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))],
null)],null),new $APP.f(null,3,[$APP.R,gzb,$APP.X,C$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sine of the supplied quaternion `q`.\n\n  See the [Boost\n  documentation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/trans.html)\n  and [source](https://www.boost.org/doc/libs/1_78_0/boost/math/quaternion.hpp)\n  for a reference implementation.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,iBb,$APP.X,y4,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns true if `q` is a unit quaternion (i.e., a 'versor', a quaternion\n  with [[magnitude]] equal to one), false otherwise.\n\n  To check if the [[magnitude]] of `q` is /approximately/ equal to one, pass a\n  tolerance via the `:epsilon` keyword argument.\n\n  For more control, use [[magnitude]] to compute the magnitude directly.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[vU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.XU],null)],null)],null))],null)],null),new $APP.f(null,
3,[$APP.R,lKb,$APP.X,1E-8,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Uvb,$APP.X,function(a,b){if($APP.Ge(EF,b)){var c=hG.j(b);b=zG.A(b,c);return yR(a,b)}c=bG.j(pL(b,b));c=EJ.A(new $APP.D(null,$APP.Zv,new $APP.D(null,c,new $APP.D(null,1,null,1,null),2,null),3,null),WHb);return $APP.k(c)?yR(a,b):c},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] that represents a rotation of `angle` radians around a\n  normalized version of the vector described by `axis`. `axis` must be a\n  3-vector with components `x`, `y` and `z`.\n\n  Given an `axis` with numeric entries, [[from-angle-axis]] will explicitly\n  normalize `axis` before calling [[from-angle-normal-axis]]. If any entries are\n  non-numerical (i.e., symbolic), [[from-angle-axis]] will instead log an\n  assumption that the magnitude of `axis` \x3d\x3d 1 and proceed.\n\n  NOTE: If you have an already-normalized axis,\n  prefer [[from-angle-normal-axis]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[CY,$APP.BX],null))],null)],null),new $APP.f(null,3,[$APP.R,Pub,$APP.X,D$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the tangent of the supplied quaternion `q`.\n\n  [[tan]] is defined as `(/ (sin q) (cos q))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,jHb,$APP.X,B$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the cosine of the supplied quaternion `q`.\n\n  See the [Boost\n  documentation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/trans.html)\n  and [source](https://www.boost.org/doc/libs/1_78_0/boost/math/quaternion.hpp)\n  for a reference implementation.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,yFb,$APP.X,iR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the quaternion `q` has zero entries for all non-real fields,\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,Abc,$APP.X,function(a,b){return kR.M(xH.j(a),AH.j(a),xH.j(b),AH.j(b))},$APP.h,new $APP.f(null,2,[$APP.P,"Given two complex numbers `a` and `b`, returns a quaternion instance with\n\n  - `r` and `i` components set to the real and imaginary components of `a`\n  - `j` and `k` components set to the real and imaginary components of `b`",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,KKb,$APP.X,y$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a quaternion representing the (vector) cross product of the two pure\n  sides (retrieved via [[three-vector]]) of the supplied quaternions `l` and\n  `r`.\n\n  NOTE that the suggestion for this function comes from this [C++ quaternion\n  library](https://github.com/ferd36/quaternions/blob/master/include/quaternion.h#L1109).\n  Strictly, this is not the 'cross product of two quaternions'.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[lO,$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,FDb,$APP.X,function(a){return a.i},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `i` component of the supplied quaternion `q`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))],null)],null),new $APP.f(null,3,[$APP.R,etb,$APP.X,wR,$APP.h,new $APP.f(null,2,[$APP.P,"Variadic function for subtracting quaternion arguments.\n\n  - Given no arguments, returns [[ZERO]], the additive identity.\n  - Given 1 argument `q`, acts as identity.\n  - Given 2 arguments, returns the difference of quaternions `q1` and `q2`.\n  - Given more than 2 arguments, returns the difference of the first quaternion\n    `q1` with the sum of all remaining arguments.\n\n  The difference of two quaternions is a new quaternion with coefficients equal\n  to the pairwise difference of the coefficients of `q1` and `q2`.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,TNb,$APP.X,jR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied quaternion `q1` is equal to the value `q2`. The\n  rules for [[eq]] are as follows:\n\n  - If `q2` is a quaternion, returns true if all coefficients match, false\n    otherwise\n\n  - If `q2` is complex, returns true if the real and `i` coefficients are equal,\n    with `j` and `k` coefficients of `q1` equal to zero, false otherwise\n\n  - If `q2` is sequential with a count of 4, it's interpreted as a vector of\n    quaternion coefficients.\n\n  Else, if `q1` is a [[real?]] quaternion, returns true if the real component of\n  `q1` is [[emmy.value/\x3d]] to `q2`, false otherwise.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,CW],null))],null)],null),new $APP.f(null,3,[$APP.R,tFb,$APP.X,function(a){return yR(a,new $APP.H(null,3,5,$APP.I,[0,0,1],null))},$APP.h,new $APP.f(null,2,[$APP.P,"Create a quaternion representing a roll rotation by the supplied\n  `angle` (specified in radians).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CY],null))],null)],null),new $APP.f(null,3,[$APP.R,i6b,$APP.X,z$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the multiplicative inverse of the supplied quaternion `q`.\n\n  The inverse of a quaternion is a new quaternion that, when [[mul]]tiplied by\n  `q`, will produce the [[ONE]] quaternion (the multiplicative identity).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,G$b,$APP.X,rsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,zPb,$APP.X,x$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the quaternion dot product of the supplied quaternions `l` and `r`.\n\n  The quaternion dot product is the sum of the products of the corresponding\n  coefficients of each quaternion, equal to\n\n  $$r_l * r_r + i_l * i_r + j_l * j_r + k_l * k_r$$",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[lO,$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,WWb,$APP.X,function(a){return yR(a,new $APP.H(null,3,5,$APP.I,[0,1,0],null))},$APP.h,new $APP.f(null,2,[$APP.P,"Create a quaternion representing a yaw rotation by the supplied\n  `angle` (specified in radians).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CY],null))],null)],null),new $APP.f(null,3,[$APP.R,ecb,$APP.X,function(a){return a.r},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `r` component of the supplied quaternion `q`.\n\n  Identical to [[get-r]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))],null)],null),new $APP.f(null,3,[$APP.R,Gbc,$APP.X,A$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the logarithm $\\ln q$ of the supplied quaternion `q`.\n\n  Given a quaternion $q$ with real part $r$ and non-real vector $\\vec{v}$, the\n  logarithm [is computed\n  as](https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions)\n\n  $$\n  \\ln(q) \x3d \\ln \\|q\\| + \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\\n  \\arccos \\frac{r}{\\|\\q\\|}\n  $$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,$Yb,$APP.X,u$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new quaternion generated by multiplying each coefficient of the\n  supplied quaternion `q` by the supplied scalar `s` on the left.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,vU],null))],null)],null),new $APP.f(null,3,[$APP.R,zOb,$APP.X,t$a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a quaternion `q` with function coefficients and a possibly-empty sequence\n  of partial derivative `selectors`, returns a new [[Quaternion]] generated by\n  replacing each (functional) coefficient with its derivative with respect to\n  `selectors`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,QT],null))],null)],null),new $APP.f(null,3,[$APP.R,K$b,$APP.X,ssc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Kjb,$APP.X,function(a,b,c,d){var g=QF.A(b,2);b=fO.j(g);var l=gO.j(g);g=gO.j(c);l=iG.A(a,l);g=iG.A(l,g);return kR.M(iG.A(a,b),iG.A(g,fO.j(d)),iG.A(g,gO.j(d)),iG.A(l,fO.j(c)))},$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [[Quaternion]] instance, given:\n\n  - a magnitude `r`\n  - a rotation angle `theta`, with a natural range of `-2*pi` to `2*pi`\n  - `colat`, the [colatitude](https://mathworld.wolfram.com/Colatitude.html) of\n    the (non-real) vectorial part of the quaternion\n  - `lon`, the longitude of the vectorial part of the quaternion",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.mO,SX,$ob,JIb],null))],null)],null),new $APP.f(null,3,[$APP.R,FYb,$APP.X,function(a){return kG.C(iG.A(a.r,usc),iG.A(a.i,A4),$APP.y([iG.A(a.Ma,B4),iG.A(a.k,C4)]))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the 4x4 matrix representation of the supplied [[Quaternion]] `q`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,nhb,$APP.X,wsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,qob,$APP.X,E$a,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns the hyperbolic cosine of the supplied quaternion `q`.\n\n  [[cosh]] is defined in terms of the [[exp]] function as `(e^q + e^{-q}) / 2`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,bRb,$APP.X,kR,$APP.h,new $APP.f(null,2,[$APP.P,"Constructor that builds [[Quaternion]] instances out of a variety of types.\n  Given:\n\n  - a quaternion `x`, acts as identity.\n\n  - a sequential `x`, returns a quaternion with coefficients built from the\n    first four entries.\n\n  - a complex number `x`, returns a quaternion built from the real and imaginary\n    components of `x` with `j` and `k` components equal to zero.\n\n  - a real number `x` and 3-vector, returns a quaternion with real coefficient\n    equal to `x` and imaginary components equal to the elements of the vector\n\n  - 4 distinct arguments `r`, `i`, `j` and `k`, returns a quaternion with these\n    as the coefficients.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.mO,new $APP.H(null,3,5,$APP.I,[$APP.Ov,sU,$APP.tU],null)],null),new $APP.H(null,4,5,$APP.I,[$APP.mO,$APP.Ov,sU,$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,pDb,$APP.X,H$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of raising quaternion `q` to the real, complex or quaternion\n  power `p`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,
J$b,$APP.X,tsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,V3b,$APP.X,function(a){return yR(a,new $APP.H(null,3,5,$APP.I,[1,0,0],null))},$APP.h,new $APP.f(null,2,[$APP.P,"Create a quaternion representing a pitch rotation by the supplied\n  `angle` (specified in radians).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CY],null))],null)],null),new $APP.f(null,3,[$APP.R,Ayb,$APP.X,nR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the negation (additive inverse) of the supplied quaternion `q`.\n\n  The additive inverse of a quaternion is a new quaternion that, when [[add]]ed\n  to `q`, will produce the [[ZERO]] quaternion (the additive identity).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,iGb,$APP.X,ysc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,nyb,$APP.X,usc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,SVb,$APP.X,qR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the norm of the supplied quaternion `q`.\n\n  The norm of a quaternion is the square root of the sum of the squares of the\n  quaternion's coefficients.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,
3,[$APP.R,FHb,$APP.X,uR,$APP.h,new $APP.f(null,2,[$APP.P,"Variadic function for dividing quaternion arguments.\n\n  - Given no arguments, returns [[ONE]], the multiplicative identity.\n  - Given 1 argument `q`, acts as identity.\n  - Given 2 arguments, returns the quotient of quaternions `q1` and `q2`.\n  - Given more than 2 arguments, returns the quotient of the first quaternion\n    `q1` with the product of all remaining arguments.\n\n  The quotient of two quaternions is a new quaternion equal to the product of\n  `q1` and the multiplicative inverse of `q2`",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,mpb,$APP.X,qsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,qfb,$APP.X,function(a){return KF.j(a.r)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the quaternion `q` has a zero real entry, false otherwise.\n\n  A 'pure' quaternion is sometimes called an 'imaginary' quaternion.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,D6b,$APP.X,vsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Njb,$APP.X,function(a){return new $APP.H(null,2,5,$APP.I,[n$a(a),o$a(a)],null)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a pair of complex number created respectively from the `(r,i)`\n  and `(j,k)` components of the supplied quaternion `q`.\n\n  NOTE that this only works if the coefficients of `q` are real numbers, due to\n  restrictions on the current complex number implementation. ",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,HDb,$APP.X,function(a){return a.k},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `k` component of the supplied quaternion `q`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))],null)],null),new $APP.f(null,3,[$APP.R,ncb,$APP.X,xsc,$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.R,ENb,$APP.X,gR,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.quaternion/Quaternion.",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.mO,$APP.Ov,sU,$APP.tU,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,itb,$APP.X,lR,$APP.h,new $APP.f(null,2,[$APP.P,"Given a quaternion `q` with function coefficients and a sequence `args` of\n  arguments, and returns a new [[Quaternion]] generated by replacing each\n  coefficient with the result of applying the (functional) coefficient to\n  `args`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Mu],null))],null)],null),new $APP.f(null,3,[$APP.R,flb,$APP.X,vR,$APP.h,new $APP.f(null,2,[$APP.P,"Variadic function that returns the sum of all supplied quaternions.\n\n  Given 1 argument `q`, acts as identity. Given no arguments, returns [[ZERO]],\n  the additive identity.\n\n  The sum of two or more quaternions is a new quaternion with coefficients equal\n  to the elementwise sum of the coefficients of all supplied quaternions.",$APP.U,$APP.M($APP.sf,
new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,Jyb,$APP.X,function(a,b,c,d){return kR.M(iG.A(a,fO.j(b)),iG.A(a,gO.j(b)),iG.A(c,fO.j(d)),iG.A(c,gO.j(d)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] instance with [[complex-1]] part built from the polar\n  coordinates `r1` and `theta1` and [[complex-2]] part built from `r2` and\n  `theta2`",$APP.U,$APP.M(new $APP.H(null,
4,5,$APP.I,[$Sb,ndb,aTb,ldb],null))],null)],null),new $APP.f(null,3,[$APP.R,NYb,$APP.X,function(a){return kR.j($APP.x.A(a,0))},$APP.h,new $APP.f(null,2,[$APP.P,"Given a 4x4 matrix representation of a quaternion, returns the associated\n  quaternion by extracting the first row.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xac],null))],null)],null),new $APP.f(null,3,[$APP.R,Zlb,$APP.X,function(a,b,c,d){var g=iG.A(a,fO.j(b));a=iG.A(a,gO.j(b));return kR.M(iG.A(g,fO.j(c)),iG.A(g,gO.j(c)),iG.A(a,fO.j(d)),
iG.A(a,gO.j(d)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] `q` with magnitude `rho`, built such that:\n\n  - the magnitude of `q` equals `rho`\n  - the magnitude `([[complex-1]] q)` equals `(* rho (cos alpha))`\n  - the angle of `([[complex-1]] q)` equals `theta1`\n  - The magnitude `([[complex-2]] q)` equals `(* rho (cos alpha))`\n  - the angle of `([[complex-2]] q)` equals `theta12`\n\n  This strange, possibly unnecessary constructor taken from the [Boost\n  quaternion\n  implementation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/create.html).",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.mO,OX,ndb,ldb],null))],null)],null),new $APP.f(null,3,[$APP.R,HLb,$APP.X,function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null);a=$APP.x.B(a,3,null);return CN.C($APP.y([new $APP.H(null,2,5,$APP.I,[NZ.A(b,c),NZ.A(d,a)],null),new $APP.H(null,2,5,$APP.I,[NZ.A(PF.j(d),a),NZ.A(b,PF.j(c))],null)]))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a 2x2 complex matrix representation of the supplied Quaternion `q`.\n\n  For a quaternion with coefficients `[a b c d]`, the returned matrix will have\n  the following form:\n\n  ```\n  [ a + b i,  c + d i]\n  [ -c + d i, a - b i]\n  ```\n\n  NOTE that this currently only works for quaternions `q` with real or symbolic\n  entries.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,hPb,$APP.X,n$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `r` and `i` components of the quaternion `q` as a `Complex` number\n  instance.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,gPb,$APP.X,o$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `j` and `k` components of the quaternion `q` as a `Complex` number\n  instance.",$APP.U,$APP.M(new $APP.H(null,1,
5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,o7b,$APP.X,w$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the conjugate of the supplied quaternion `q`.\n\n  The conjugate of a quaternion is a new quaternion with real coefficient equal\n  to that of `q` and each imaginary coefficient negated. `(mul q (conjugate q))`\n  will return a [[real?]] quaternion.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,ZCb,$APP.X,function(a){var b=$APP.x.B(a,
0,null),c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=$APP.x.B(a,1,null),l=$APP.x.B(g,0,null),n=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);var p=$APP.x.B(a,2,null),v=$APP.x.B(p,0,null);a=$APP.x.B(p,1,null);var t=$APP.x.B(p,2,null);p=iG.A(D4,kG.C(1,c,$APP.y([n,t])));var A=iG.A(D4,kG.C(1,c,$APP.y([RF.j(n),RF.j(t)]))),B=iG.A(D4,kG.C(1,RF.j(c),$APP.y([n,RF.j(t)]))),G=iG.A(D4,kG.C(1,RF.j(c),$APP.y([RF.j(n),t])));t=iG.A(D4,RF.A(a,g));n=iG.A(D4,RF.A(b,v));c=iG.A(D4,RF.A(l,d));d=iG.A(D4,
kG.A(d,l));b=iG.A(D4,kG.A(b,v));g=iG.A(D4,kG.A(g,a));var J=bG.j(p),O=bG.j(A),Q=bG.j(B),W=bG.j(G);return EF(J)&&EF(O)&&EF(Q)&&EF(W)?(J>=function(){var Z=O>Q?O:Q;return Z>W?Z:W}()?(l=jG.j(J),a=QF.A(t,l),p=QF.A(n,l),d=QF.A(c,l)):O>=function(){var Z=J>Q?J:Q;return Z>W?Z:W}()?(a=jG.j(O),l=QF.A(t,a),p=QF.A(d,a),d=QF.A(b,a)):Q>=function(){var Z=J>O?J:O;return Z>W?Z:W}()?(p=jG.j(Q),l=QF.A(n,p),a=QF.A(d,p),d=QF.A(g,p)):(d=jG.j(W),l=QF.A(c,d),a=QF.A(b,d),p=QF.A(g,d)),kR.M(l,a,p,d)):$APP.eb(KF.j(J))?(l=jG.j(p),
a=QF.A(t,l),p=QF.A(n,l),d=QF.A(c,l),kR.M(l,a,p,d)):$APP.eb(KF.j(O))?(a=jG.j(A),l=0,p=QF.A(d,a),d=QF.A(b,a),kR.M(l,a,p,d)):$APP.eb(KF.j(Q))?(p=jG.j(B),a=l=0,d=QF.A(g,p),kR.M(l,a,p,d)):kR.M(0,0,0,0)},$APP.h,new $APP.f(null,2,[$APP.P,"Given an orthogonal 3x3 matrix M representing a rotation in 3-space, returns\n  the unit quaternion that corresponds to the same transformation.\n\n  GJS notes in scmutils that this algorithm is the 'expanded Matt Mason method'.\n\n  NOTE Orthogonal means, no stretching allowed, only rotation!\n\n  NOTE this routine uses non-generic [[clojure.core/\x3e\x3d]]\n  and [[clojure.core/max]] internally, so if you use numeric entries (or if your\n  entries simplify down to numbers), make sure that they work with these native\n  operations. No `BigInt` in ClojureScript for now, for example.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))],null)],null),new $APP.f(null,3,[$APP.R,Ccc,$APP.X,function(a,b){return wR.A(xR.A(a,b),xR.A(b,a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the commutator of the supplied quaternions `l` and `r`.\n\n  The commutator of two quaternions is equal to\n\n  ```clj\n  (- (* l r) (* r l))\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[lO,$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,rJb,$APP.X,I$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the square root of the supplied quaternion `q`.\n\n  `([[sqrt]] q)` is identical to, but more efficient than, raising `q` to the\n  1/2 power.\n\n  Thanks to the [Spire\n  library](https://github.com/typelevel/spire/blob/82f607714f94ba1c70b13fd4751063dfdcd155f5/core/src/main/scala/spire/math/Quaternion.scala#L217)\n  for the correct implementation used here.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,pVb,$APP.X,v$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new quaternion generated by multiplying each coefficient of the\n  supplied quaternion `q` by the supplied scalar `s` on the right.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,TPb,$APP.X,s$a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a quaternion `q` with function coefficients, returns an arity compatible\n  with all function coefficient entries.\n\n  NOTE that by default, if any arities are incompatible, the function will\n  return `[:at-least 0]`. To force strict arity checks,\n  bind [[emmy.function/*strict-arity-checks*]] to `true`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,Dlb,$APP.X,B4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,PFb,$APP.X,p$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a 4-vector of the coefficients of quaternion `q`.\n\n  Works identically to `(vec q)`, but more efficient as we are able to create\n  the new vector in one shot.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],
null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,CPb,$APP.X,sR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the exponential $e^q$ of the supplied quaternion `q`.\n\n  Given a quaternion $q$ with real part $r$ and non-real vector $\\vec{v}$, the\n  exponential [is computed\n  as](https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions)\n\n  $$\n  \\exp(q) \x3d e^r \\left(\\cos \\|\\mathbf{v}\\| \\\n  + \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\sin\\|\\mathbf{v}\\| \\right)\n  $$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,GDb,$APP.X,function(a){return a.Ma},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `j` component of the supplied quaternion `q`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(vU,new $APP.f(null,1,[$APP.sj,kX],null))],null))],null)],null),new $APP.f(null,3,[$APP.R,rHb,$APP.X,yR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] that represents a rotation of `angle` radians around\n  the unit (normalized) vector described by the second argument, a 3-vector with\n  components `x`, `y` and `z`.\n\n  The second argument represents an axis of rotation.\n\n  NOTE: If you have an UN-normalized axis, prefer [[from-angle-axis]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[CY,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,kAb,$APP.X,G$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the hyperbolic tangent of the supplied quaternion `q`.\n\n  [[tan]] is defined as `(/ (sinh q) (cosh q))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null))],null)],null),new $APP.f(null,3,[$APP.R,Yob,$APP.X,hR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a 3-vector holding the coefficients of the non-real (imaginary)\n  components of the quaternion `q`.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(nS,vU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,B$b,$APP.X,xR,$APP.h,new $APP.f(null,2,[$APP.P,"Variadic function that returns the product of all supplied quaternions.\n\n  Given 1 argument `q`, acts as identity. Given no arguments, returns [[ONE]],\n  the multiplicative identity.\n\n  The product of two or more quaternions is a new quaternion generated by\n  multiplying together each quaternion of the form `(r+ai+bj+ck)`, respecting\n  the quaternion rules:\n\n  i^2 \x3d\x3d j^2 \x3d\x3d k^2 \x3d\x3d -1\n  ijk \x3d\x3d -1,\n  ij  \x3d\x3d k,  jk \x3d\x3d i,  ki \x3d\x3d j\n  ji  \x3d\x3d -k, kj \x3d\x3d -i, ik \x3d\x3d -j",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[BW,CW],null),new $APP.H(null,4,5,$APP.I,[BW,CW,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,dzb,$APP.X,A4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Kub,$APP.X,oR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new quaternion generated by dividing each coefficient of the supplied\n  quaternion `q` by the supplied scalar `s`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Sv],null))],null)],
null),new $APP.f(null,3,[$APP.R,rCb,$APP.X,function(a,b,c,d){var g=iG.A(b,gO.j(c));return kR.M(a,iG.A(g,fO.j(d)),iG.A(g,gO.j(d)),iG.A(b,fO.j(c)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] `q` with [[real-part]] equal to `t` and\n  the [[three-vector]] part built from the spherical coordinates `r`, `colat`\n  and `lon`.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Rv,$APP.mO,SX,WR],null))],null)],null),new $APP.f(null,3,[$APP.R,Zrb,$APP.X,function(a,b,c,d){return kR.M(iG.A(a,fO.j(b)),
iG.A(a,gO.j(b)),c,d)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] `q` with [[complex-1]] built from the polar\n  coordinates `mag` and `angle`, and `j` and `k` components equal to the\n  supplied `j` and `k`.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.JGb,CY,sU,$APP.tU],null))],null)],null)]),$APP.Zo($5b)),$APP.ap(new $APP.f(null,3,[$APP.z(h7b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[TR],null)))],null)),new $APP.f(null,3,[$APP.R,IHb,$APP.X,V$a,
$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[TR],null))],null)],null),$APP.z(jXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))],null)),new $APP.f(null,3,[$APP.R,m$b,$APP.X,function(a){return function(b){return WH.C($APP.y([a.j?a.j(b):a.call(null,b),V$a(RF.j(b))]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))],null)],null),$APP.z(hLb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,
$APP.I,[TR],null)))],null)),new $APP.f(null,3,[$APP.R,kOb,$APP.X,function(a){return function(b){return WH.C($APP.y([b,V$a(RF.j(a))]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[TR],null))],null)],null)],null),$APP.Zo(Igb)),$APP.ap($APP.fg([$APP.z(fOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,nX],null))),$APP.P,"Alias for [[rule-simplifier]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,
[$APP.M(nX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,nX],null)),$APP.zx,$APP.M(null)],null)],null)),Qyb,$APP.z(xcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KY],null))),$APP.P,"Given some rule `the-rule`, returns a new rule that accepts potentially nested\n  `data` and applies `the-rule` to all subexpressions on the way down AND back\n  up a traversal. This is a sort of hybrid of breadth-first, depth-first.\n\n  The transformation is applied a single time to all subexpressions.\n  See [[iterated-top-down]] for a version that will iterate to convergence."],
null)),$APP.z(YNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Takes a rule `r` and returns a new rule that return either `(r data)` if `r` is\n  successful, or its original input on failure.\n\n  NOTE that the returned rule will never fail! This makes it inappropriate to\n  use with [[choice]], for example, if you expect any rule supplied after this\n  one to ever be matched. [[attempt]] rules are great choices for the final rule\n  passed to [[choice]], however."],
null)),ubb,$APP.z(xXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Returns `true` if `r` was marked as an 'attempt' rule, i.e., a rule that will\n  never fail, but return its input on a failed match."],null)),$APP.z($yb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KY],null))),$APP.P,"Version of [[top-down]] that iterates on each subexpression to convergence\n  before each subexpression returns. Any change in a subexpression triggers a\n  new iterated-top-down replacement of that subexpression.\n\n  The returned rule keeps an internal memoization cache and will return\n  immediately for subexpressions it's seen before."],
null)),$APP.z(Cdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KY],null))),$APP.P,"Version of [[bottom-up]] that iterates on each subexpression to convergence\n  before each subexpression returns. Any change in a subexpression triggers a\n  new iterated-bottom-up replacement of that subexpression.\n\n  The returned rule keeps an internal memoization cache and will return\n  immediately for subexpressions it's seen before."],null)),$APP.z(L$b,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.mO],null))),$APP.P,"Returns a new rule which repeatedly applies `r` until `f` returns `true`\n  between the input and output of the rule `r` applied iteratively to the input\n  `data`, signaling completion.\n\n  See [[while]] for a similar function that treats its predicate differently."],null)),$APP.z(COb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.mO,GMb,Plb],null))),$APP.P,"Takes a rule `r` and returns a new rule that calls `r` with its input.\n\n  The returned rule returns:\n\n  - `(succeed-r (r data)) if `(r data)` is successful,\n  - `(fail-r data) otherwise."],
null)),$APP.z(cfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),$APP.P,"Rule that always fails with an explicit `failure`, no matter the input."],null)),trb,$APP.z(BEb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,nX],null))),$APP.P,"Given some number of `rules`, returns a new rule that will attempt to apply\n  each rule to its input expression (and every subexpression of the input,\n  bottom up), iterating until no rule causes any change in any level of the\n  supplied expression.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(nX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,nX],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(aY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Kv],null))),$APP.P,"Takes a rule `r` and returns a new version of `r` tagged with a unique `id`.\n  The returned rule calls the side-effecting `f` with\n\n  ```clojure\n  {:id id, :in data}\n  ```\n\n  Before calling `r` with `data`, and calls `f` with\n\n  ```clojure\n  {:id id, :out (r data)}\n  ```\n\n  when the rule returns.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Kv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Kv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(NHb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Lh,KW],
null))),$APP.P,"Accepts any number of `rules` and returns a new `rule` that attempts to pipe\n  its input `data` through each rule in `rules`. Only succeeds if every rule\n  succeeds on the previous rule's successful output.\n\n  NOTE: The zero-arity `(pipe)` returns [[pass]], a rule that succeeds for any\n  input by returning the input unchanged.\n\n  See [[pipe*]] for an identical function that accepts an explicit sequence.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,
2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.mO],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Lh,KW],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(cac,new $APP.f(null,3,[$APP.P,"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,eJ)],null)),$APP.z(bJb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Lh,KW],null))),$APP.P,"Accepts any number of `rules` and returns a new `rule` that attempts to apply\n  each rule in `rules` to its input data. Returns the first non-failing rule's\n  result, or `failure` if no rule succeeds.\n\n  NOTE: The zero-arity `(choice)` returns [[fail]], a rule that fails for any\n  input.\n\n  See [[choice*]] for an identical function that accepts an explicit sequence.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.mO],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Lh,KW],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(tWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.mO],null))),$APP.P,"Returns a rule that applies the rule `r` iteratively `n` times to the input\n  data, failing if any application fails.\n\n  For example, these forms are equivalent, except that the [[n-times]] version\n  will fail immediately if any application fails vs passing on its failure:\n\n  ```clojure\n  (n-times 3 my-rule)\n  (fn [data]\n    (my-rule (my-rule (my-rule data))))\n  ```"],
null)),$APP.z(LGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Takes a rule `r` and returns a new rule that applies `r` to `data` iteratively\n  until (\x3d input (r input))."],null)),$APP.z(Q_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[nX],null))),$APP.P,"Identical to the multi-arity [[pipe]], but accepts an explicit sequence."],null)),$APP.z(jGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Kv,$APP.mO],null))),$APP.P,"Takes a predicate function `f` and a rule `r`, and returns a new rule that will\n  return `(r data)` if `(f data)` is true, fail otherwise."],null)),$APP.z(Ibc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ax],null))),$APP.P,"Rule that always succeeds by returning its input data unchanged."],null)),$APP.z(o4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Similar to `clojure.core/iterate` for rule application.\n\n  Takes a rule `r` and returns a new rule that will return the last non-failing\n  result of the sequence `[data (r data) (r (r data)) ...]`\n\n  This might be `data` itself if `r` fails on first application. This means that\n  the returned rule will never fail."],
null)),Tob,xS,$APP.z(C0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Marks the supplied rule as an 'attempt' rule that won't fail."],null)),$APP.z(yzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Returns a rule that will pass its input data on unchanged if `(f data)` returns\n  true and fail otherwise."],null)),$APP.z(l6b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,
$APP.I,[$APP.Bv],null),new $APP.H(null,2,5,$APP.I,[$APP.Bv,$APP.Ey],null))),$APP.P,"Builds the pattern portion of a rule from the supplied pattern form or matcher\n  combinator and optional predicate `pred`.\n\n  See [[emmy.pattern.syntax]] for the allowed syntax pattern, or [[emmy.pattern.match]]\n  for details on matcher combinators.\n\n  See [[match/matcher]] for more detailed documentation.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,
1,5,$APP.I,[$APP.Bv],null),new $APP.H(null,2,5,$APP.I,[$APP.Bv,$APP.Ey],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null),new $APP.H(null,2,5,$APP.I,[$APP.Bv,$APP.Ey],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(m_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[nX],null))),$APP.P,"Identical to the multi-arity [[choice]], but accepts an explicit sequence."],null)),$APP.z(sYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,
5,$APP.I,[aIb,$APP.dx],null))),$APP.P,"Functional version of [[rule]]. See [[rule]] for documentation."],null)),$APP.z(gJb,new $APP.f(null,3,[$APP.P,"Returns true if `x` is equivalent to the failure sentinel [[failure]], false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,c2b)],null)),$APP.z(UGb,new $APP.f(null,2,[$APP.P,"Singleton object representing the failure of a matcher to match its input.\n  Check for failure with [[failed?]]",
jU,$APP.M($APP.K,j0b)],null)),$APP.z(irb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,nX],null))),$APP.P,"Given some number of `rules`, returns a new rule that will act like [[choice]]\n  and attempt to apply each rule to the input data, returning the first match.\n\n  If all `rules` fail, the returned rule will return its input `data`.\n\n  See [[ruleset]] for a macro that allows inline rule definition.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,
0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(nX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,nX],null)),$APP.zx,$APP.M(null)],null)],null)),cec,$APP.z(GQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a rule that matches any input and always returns `x`."],null)),nfb,$APP.z(V4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KY],null))),$APP.P,"Given some rule `the-rule`, returns a new rule that accepts potentially nested\n  `data` and applies `the-rule` to all subexpressions in depth-first order, from\n  the leaves on up.\n\n  The transformation is applied a single time to all subexpressions.\n  See [[iterated-bottom-up]] for a version that will iterate to convergence."],
null)),$APP.z($APP.Ex,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.mO],null))),$APP.P,"Returns a new rule which repeatedly applies `r` as long as `f` continues to\n  return `true` between the input and output of the rule `r` applied iteratively\n  to the input `data`.\n\n  See [[until]] for a similar function that treats its predicate differently."],null))],[new $APP.f(null,3,[$APP.R,bYb,$APP.X,Y1,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[rule-simplifier]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,nX],null))],null)],null),new $APP.f(null,3,[$APP.R,Nib,$APP.X,xJ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ccb,$APP.X,function(a){var b=nJ(a);return lJ(function g(d){d=BYa(g,b.j?b.j(d):b.call(null,d));return b.j?b.j(d):b.call(null,d)})},$APP.h,new $APP.f(null,2,[$APP.P,"Given some rule `the-rule`, returns a new rule that accepts potentially nested\n  `data` and applies `the-rule` to all subexpressions on the way down AND back\n  up a traversal. This is a sort of hybrid of breadth-first, depth-first.\n\n  The transformation is applied a single time to all subexpressions.\n  See [[iterated-top-down]] for a version that will iterate to convergence.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KY],null))],null)],null),new $APP.f(null,3,[$APP.R,b1b,$APP.X,nJ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a rule `r` and returns a new rule that return either `(r data)` if `r` is\n  successful, or its original input on failure.\n\n  NOTE that the returned rule will never fail! This makes it inappropriate to\n  use with [[choice]], for example, if you expect any rule supplied after this\n  one to ever be matched. [[attempt]] rules are great choices for the final rule\n  passed to [[choice]], however.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,MJb,$APP.X,X1,$APP.h,new $APP.f(null,4,[$APP.P,"Accepts triplets of the form:\n\n  \x3cpattern\x3e \x3cpredicate\x3e \x3cconsequence-template\x3e\n\n  and returns a new rule that will attempt to match the rules compiled from each\n  triplet in sequence, returning the filled-in `\x3cconsequence-template\x3e` of the\n  first successful match.\n\n  If none of the rules match, the returned rule returns its input data\n  unchanged.\n\n  See [[ruleset*]] for a function version that takes explicit\n  already-constructed rules.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,wvb],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,gWb,$APP.X,zYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `r` was marked as an 'attempt' rule, i.e., a rule that will\n  never fail, but return its input on a failed match.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,WPb,$APP.X,function(a){var b=nJ(a),c=$APP.kh.j(null);$APP.Ne(c,$APP.mh(function(d){var g=b.j?b.j(d):
b.call(null,d);if($APP.Uc.A(g,d)){d=BYa($APP.Fb(c),d);g=b.j?b.j(d):b.call(null,d);if($APP.Uc.A(g,d))return g;d=$APP.Fb(c);return d.j?d.j(g):d.call(null,g)}d=$APP.Fb(c);return d.j?d.j(g):d.call(null,g)}));return lJ($APP.Fb(c))},$APP.h,new $APP.f(null,2,[$APP.P,"Version of [[top-down]] that iterates on each subexpression to convergence\n  before each subexpression returns. Any change in a subexpression triggers a\n  new iterated-top-down replacement of that subexpression.\n\n  The returned rule keeps an internal memoization cache and will return\n  immediately for subexpressions it's seen before.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KY],null))],null)],null),new $APP.f(null,3,[$APP.R,rjb,$APP.X,CYa,$APP.h,new $APP.f(null,2,[$APP.P,"Version of [[bottom-up]] that iterates on each subexpression to convergence\n  before each subexpression returns. Any change in a subexpression triggers a\n  new iterated-bottom-up replacement of that subexpression.\n\n  The returned rule keeps an internal memoization cache and will return\n  immediately for subexpressions it's seen before.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[KY],null))],null)],null),new $APP.f(null,3,[$APP.R,HVb,$APP.X,AYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new rule which repeatedly applies `r` until `f` returns `true`\n  between the input and output of the rule `r` applied iteratively to the input\n  `data`, signaling completion.\n\n  See [[while]] for a similar function that treats its predicate differently.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,a0b,$APP.X,function(a,
b,c){return function(d){var g=a.j?a.j(d):a.call(null,d);return $APP.k(hJ.j?hJ.j(g):hJ.call(null,g))?c.j?c.j(d):c.call(null,d):b.j?b.j(g):b.call(null,g)}},$APP.h,new $APP.f(null,2,[$APP.P,"Takes a rule `r` and returns a new rule that calls `r` with its input.\n\n  The returned rule returns:\n\n  - `(succeed-r (r data)) if `(r data)` is successful,\n  - `(fail-r data) otherwise.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.mO,GMb,Plb],null))],null)],null),new $APP.f(null,3,[$APP.R,Teb,$APP.X,tYa,
$APP.h,new $APP.f(null,2,[$APP.P,"Rule that always fails with an explicit `failure`, no matter the input.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))],null)],null),new $APP.f(null,3,[$APP.R,ytb,$APP.X,T1,$APP.h,new $APP.f(null,4,[$APP.P,"Provided with a single `form`, [[template]] is similar to Clojure's `unquote`\n  facility, except that symbols are not prefixed by namespace. For example:\n\n  ```clojure\n  (let [x 10]\n    (template (+ ~x y z ~@[4 5])))\n  ;;\x3d\x3e (+ 10 y z 4 5)\n  ```\n\n  When you provide a binding map `m`, [[template]] returns its input form, but\n  replaces any:\n\n  - variable binding form like `?x`\n  - segment binding form like `??x`\n  - reverse-segment binding form, like `$$x`\n\n  with the appropriate entry in `m`. (`m` can be a symbol referencing a binding\n  map in the environment.)\n\n  Splices and unquote splices are respected. For example:\n\n  ```clojure\n  (let [m {'?x 10 '?y 12 '??z [1 2 3]}]\n    (template m (+ ?x ?y ??z ~m ~@[1 2])))\n  ;;\x3d\x3e (+ 10 12 1 2 3 {?x 10, ?y 12, ??z [1 2 3]} 1 2)\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.Bv],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,aSb,$APP.X,yJ,$APP.h,new $APP.f(null,2,[$APP.P,"Given some number of `rules`, returns a new rule that will attempt to apply\n  each rule to its input expression (and every subexpression of the input,\n  bottom up), iterating until no rule causes any change in any level of the\n  supplied expression.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,nX],null))],null)],null),new $APP.f(null,3,[$APP.R,H8b,$APP.X,W1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a rule `r` and returns a new version of `r` tagged with a unique `id`.\n  The returned rule calls the side-effecting `f` with\n\n  ```clojure\n  {:id id, :in data}\n  ```\n\n  Before calling `r` with `data`, and calls `f` with\n\n  ```clojure\n  {:id id, :out (r data)}\n  ```\n\n  when the rule returns.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,
2,5,$APP.I,[$APP.mO,$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,H7b,$APP.X,oJ,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts any number of `rules` and returns a new `rule` that attempts to pipe\n  its input `data` through each rule in `rules`. Only succeeds if every rule\n  succeeds on the previous rule's successful output.\n\n  NOTE: The zero-arity `(pipe)` returns [[pass]], a rule that succeeds for any\n  input by returning the input unchanged.\n\n  See [[pipe*]] for an identical function that accepts an explicit sequence.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Lh,KW],null))],null)],null),new $APP.f(null,3,[$APP.R,RHb,$APP.X,dJ,$APP.h,new $APP.f(null,3,[$APP.P,"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,eJ],null)],null),new $APP.f(null,3,[$APP.R,fhb,$APP.X,mJ,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts any number of `rules` and returns a new `rule` that attempts to apply\n  each rule in `rules` to its input data. Returns the first non-failing rule's\n  result, or `failure` if no rule succeeds.\n\n  NOTE: The zero-arity `(choice)` returns [[fail]], a rule that fails for any\n  input.\n\n  See [[choice*]] for an identical function that accepts an explicit sequence.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.mO],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Lh,KW],null))],null)],null),new $APP.f(null,3,[$APP.R,yZb,$APP.X,function(a,b){return xYa($APP.Uj.A(a,b))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule that applies the rule `r` iteratively `n` times to the input\n  data, failing if any application fails.\n\n  For example, these forms are equivalent, except that the [[n-times]] version\n  will fail immediately if any application fails vs passing on its failure:\n\n  ```clojure\n  (n-times 3 my-rule)\n  (fn [data]\n    (my-rule (my-rule (my-rule data))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,XSb,$APP.X,function(a){return AYa($APP.Uc,a)},$APP.h,new $APP.f(null,2,[$APP.P,"Takes a rule `r` and returns a new rule that applies `r` to `data` iteratively\n  until (\x3d input (r input)).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,gQb,$APP.X,xYa,$APP.h,new $APP.f(null,2,[$APP.P,"Identical to the multi-arity [[pipe]], but accepts an explicit sequence.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nX],null))],null)],null),new $APP.f(null,3,[$APP.R,Bob,$APP.X,pJ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a predicate function `f` and a rule `r`, and returns a new rule that will\n  return `(r data)` if `(f data)` is true, fail otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,Xyb,$APP.X,sYa,$APP.h,new $APP.f(null,2,[$APP.P,"Rule that always succeeds by returning its input data unchanged.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ax],null))],null)],null),new $APP.f(null,3,[$APP.R,upb,$APP.X,function(a){return lJ(function(b){for(;;){var c=a.j?a.j(b):a.call(null,b);if($APP.k(hJ.j?hJ.j(c):hJ.call(null,c)))return b;b=c}})},$APP.h,new $APP.f(null,2,[$APP.P,"Similar to `clojure.core/iterate` for rule application.\n\n  Takes a rule `r` and returns a new rule that will return the last non-failing\n  result of the sequence `[data (r data) (r (r data)) ...]`\n\n  This might be `data` itself if `r` fails on first application. This means that\n  the returned rule will never fail.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,lhb,$APP.X,function(a,b,c){$APP.rg.B(b,zX,!0);a=$APP.Nj.J();return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Yx,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,a,null,1,null))))),null,1,null),$APP.y([new $APP.D(null,fYa(a,c),null,1,null)]))))},$APP.h,new $APP.f(null,4,[$APP.P,"Accepts a skeleton expression `form` and returns a function from a pattern\n  matcher's binding map to a data structure of identical shape to `skel`, with:\n\n  - all variable binding forms like `?x` replaced by their entries in the\n    binding map\n  - same with any segment or reverse-segment binding form like `??x` or `$$x`,\n    with the added note that these will be spliced in\n  - any `unquote` or `unquote-splicing` forms respected.\n\n  Compared to [[template]], these two forms are equivalent:\n\n  ```clojure\n  (fn [m] (template m \x3cform\x3e))\n  (consequence \x3cform\x3e)\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,V2b,$APP.X,S1,$APP.h,new $APP.f(null,4,[$APP.P,"Takes an unevaluated pattern form (or matcher combinator) and an optional\n  predicate `pred`, and returns a matcher appropriate for passing to [[rule*]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null),new $APP.H(null,2,5,$APP.I,[$APP.Bv,$APP.Ey],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,Lob,$APP.X,
lJ,$APP.h,new $APP.f(null,2,[$APP.P,"Marks the supplied rule as an 'attempt' rule that won't fail.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,cMb,$APP.X,uYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule that will pass its input data on unchanged if `(f data)` returns\n  true and fail otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,l0b,$APP.X,vJ,$APP.h,new $APP.f(null,2,[$APP.P,
"Builds the pattern portion of a rule from the supplied pattern form or matcher\n  combinator and optional predicate `pred`.\n\n  See [[emmy.pattern.syntax]] for the allowed syntax pattern, or [[emmy.pattern.match]]\n  for details on matcher combinators.\n\n  See [[match/matcher]] for more detailed documentation.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null),new $APP.H(null,2,5,$APP.I,[$APP.Bv,$APP.Ey],null))],null)],null),new $APP.f(null,3,[$APP.R,gdb,$APP.X,wYa,$APP.h,new $APP.f(null,
2,[$APP.P,"Identical to the multi-arity [[choice]], but accepts an explicit sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nX],null))],null)],null),new $APP.f(null,3,[$APP.R,zub,$APP.X,kJ,$APP.h,new $APP.f(null,2,[$APP.P,"Functional version of [[rule]]. See [[rule]] for documentation.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[aIb,$APP.dx],null))],null)],null),new $APP.f(null,3,[$APP.R,R8b,$APP.X,hJ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` is equivalent to the failure sentinel [[failure]], false\n  otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,c2b],null)],null),new $APP.f(null,3,[$APP.R,lec,$APP.X,jJ,$APP.h,new $APP.f(null,2,[$APP.P,"Singleton object representing the failure of a matcher to match its input.\n  Check for failure with [[failed?]]",jU,j0b],null)],null),new $APP.f(null,3,[$APP.R,Fub,$APP.X,uJ,$APP.h,new $APP.f(null,2,[$APP.P,"Given some number of `rules`, returns a new rule that will act like [[choice]]\n  and attempt to apply each rule to the input data, returning the first match.\n\n  If all `rules` fail, the returned rule will return its input `data`.\n\n  See [[ruleset]] for a macro that allows inline rule definition.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,nX],null))],null)],null),new $APP.f(null,3,[$APP.R,prb,$APP.X,Jpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,tnb,$APP.X,vYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule that matches any input and always returns `x`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Veb,$APP.X,V1,$APP.h,new $APP.f(null,4,[$APP.P,"Accepts either:\n\n  - A pattern written using the syntax from `emmy.pattern.syntax` and a consequence\n    function from binding map \x3d\x3e failure or return form, or\n  - A pattern, predicate and a consequence _skeleton_,\n\n  And returns a rule. A rule is a function from some data object to either\n\n  - A special `failure` singleton (test for this with [[failed?]]), or\n  - A successful transformation provided by a consequence function.\n\n  In the 2-argument case, you must provide an explicit function of the binding\n  map. A return of `failure`, `nil` or `false` will cause the whole rule to\n  fail. To successfully return `nil` or `false`, wrap the result in [[succeed]].\n\n  Notes for the 3-argument case:\n\n  - If the predicate returns `nil`, `false` or `failure`, the rule fails.\n\n  - The predicate can succeed by returning anything else. If the return value is\n    a map, the rule will call the consequence function with this map merged in to\n    the bindings.\n\n  - the third form is a consequence 'skeleton' instead of an explicit function\n    See [[consequence]] for details.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xS,odc],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Ey,Xvb],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,bgb,$APP.X,function(a){var b=nJ(a);return lJ(function g(d){d=BYa(g,d);return b.j?b.j(d):b.call(null,d)})},$APP.h,new $APP.f(null,2,[$APP.P,"Given some rule `the-rule`, returns a new rule that accepts potentially nested\n  `data` and applies `the-rule` to all subexpressions in depth-first order, from\n  the leaves on up.\n\n  The transformation is applied a single time to all subexpressions.\n  See [[iterated-bottom-up]] for a version that will iterate to convergence.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KY],null))],null)],null),new $APP.f(null,3,[$APP.R,qJb,$APP.X,function(a,b){return lJ(function g(d){return oJ.C(nJ(b),$APP.y([function(l){return $APP.k(a.A?a.A(d,l):a.call(null,d,l))?g(l):l}]))(d)})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new rule which repeatedly applies `r` as long as `f` continues to\n  return `true` between the input and output of the rule `r` applied iteratively\n  to the input `data`.\n\n  See [[until]] for a similar function that treats its predicate differently.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.mO],null))],null)],null)]),$APP.Zo(X0b)),$APP.ap(new $APP.f(null,7,[$APP.z(YTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.fx],null))),$APP.P,"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`."],null)),new $APP.f(null,3,[$APP.R,Jdc,$APP.X,V2a,$APP.h,new $APP.f(null,2,[$APP.P,"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.uU,$APP.fx],null))],null)],null),$APP.z($APP.Wwa,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.fx],null))),$APP.P,"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`."],null)),new $APP.f(null,3,[$APP.R,l2b,$APP.X,W2a,$APP.h,new $APP.f(null,2,[$APP.P,"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.fx],null))],
null)],null),$APP.z(Acb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null))),$APP.P,"Returns an infinite sequence of `x * n^i`, starting with `i \x3d\x3d 0`. `x` defaults\n  to 1.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,Zub,$APP.X,HQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an infinite sequence of `x * n^i`, starting with `i \x3d\x3d 0`. `x` defaults\n  to 1.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null))],null)],null),$APP.z(wDb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),
new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null))),$APP.P,"Returns an infinite sequence of `x / n^i`, starting with `i \x3d\x3d 0`. `x` defaults\n  to 1.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null)),$APP.zx,$APP.M(null,null)],null)],null)),
new $APP.f(null,3,[$APP.R,$Tb,$APP.X,V2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an infinite sequence of `x / n^i`, starting with `i \x3d\x3d 0`. `x` defaults\n  to 1.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null))],null)],null),$APP.z(NCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null))),$APP.P,"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$."],
null)),new $APP.f(null,3,[$APP.R,XLb,$APP.X,X2a,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null))],null)],null),$APP.z(mAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ey,$APP.ux],null))),$APP.P,"Returns a pair of vectors:\n\n  - the first contains the items in coll for which (pred item) returns true\n  - the second contains the items for which (pred item) returns false\n\n  pred must be free of side-effects."],
null)),new $APP.f(null,3,[$APP.R,T_b,$APP.X,function(a,b){var c=$APP.Id.B(function(d,g){var l=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return $APP.k(a.j?a.j(g):a.call(null,g))?new $APP.H(null,2,5,$APP.I,[$APP.mf.A(l,g),d],null):new $APP.H(null,2,5,$APP.I,[l,$APP.mf.A(d,g)],null)},new $APP.H(null,2,5,$APP.I,[$APP.bc($APP.sf),$APP.bc($APP.sf)],null),b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return new $APP.H(null,2,5,$APP.I,[$APP.dc(b),$APP.dc(c)],null)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a pair of vectors:\n\n  - the first contains the items in coll for which (pred item) returns true\n  - the second contains the items for which (pred item) returns false\n\n  pred must be free of side-effects.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ey,$APP.ux],null))],null)],null),$APP.z(nsb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,2,5,$APP.I,[$APP.fx,new $APP.f(null,2,[$APP.zu,new $APP.H(null,4,5,$APP.I,[xV,Xeb,QX,dT],null),$APP.Kl,new $APP.f(null,3,[xV,2,QX,q2b,dT,$APP.M(IJb,QX)],null)],null)],null))),$APP.P,"Accepts a sequence, iterates through it and returns a dictionary of this form:\n\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3csequence element\x3e}\n\n  `:converged?` is true if the sequence reached convergence by passing the tests\n  described below, false otherwise.\n\n  `:terms-checked` will be equal to the number of items examined in the\n  sequence.\n\n  `:result` holds the final item examined in the sequence.\n\n  ## Optional keyword args:\n\n  `:convergence-fn` user-supplied function of two successive elements in `xs`\n  that stops iteration and signals convergence if it returns true.\n\n  `:minterms` `seq-limit` won't return until at least this many terms from the\n  sequence have been processed.\n\n  `:maxterms` `seq-limit` will return (with `:converged? false`) after\n  processing this many elements without passing any other checks.\n\n  `:tolerance` A combination of relative and absolute tolerance. defaults to\n  `sqrt(machine epsilon)`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,2,5,$APP.I,[$APP.fx,new $APP.f(null,2,[$APP.zu,new $APP.H(null,4,5,$APP.I,[xV,Xeb,QX,dT],null),$APP.Kl,new $APP.f(null,3,[xV,2,QX,q2b,dT,$APP.M(IJb,QX)],null)],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,2,5,$APP.I,[$APP.fx,new $APP.f(null,2,[$APP.zu,new $APP.H(null,4,5,$APP.I,[xV,Xeb,QX,dT],null),
$APP.Kl,new $APP.f(null,3,[xV,2,QX,q2b,dT,$APP.M(IJb,QX)],null)],null)],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,cAb,$APP.X,DQ,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a sequence, iterates through it and returns a dictionary of this form:\n\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3csequence element\x3e}\n\n  `:converged?` is true if the sequence reached convergence by passing the tests\n  described below, false otherwise.\n\n  `:terms-checked` will be equal to the number of items examined in the\n  sequence.\n\n  `:result` holds the final item examined in the sequence.\n\n  ## Optional keyword args:\n\n  `:convergence-fn` user-supplied function of two successive elements in `xs`\n  that stops iteration and signals convergence if it returns true.\n\n  `:minterms` `seq-limit` won't return until at least this many terms from the\n  sequence have been processed.\n\n  `:maxterms` `seq-limit` will return (with `:converged? false`) after\n  processing this many elements without passing any other checks.\n\n  `:tolerance` A combination of relative and absolute tolerance. defaults to\n  `sqrt(machine epsilon)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,2,5,$APP.I,[$APP.fx,new $APP.f(null,2,[$APP.zu,new $APP.H(null,4,5,$APP.I,[xV,Xeb,QX,dT],null),$APP.Kl,new $APP.f(null,3,[xV,2,QX,q2b,dT,$APP.M(IJb,QX)],null)],null)],null))],null)],null)],null),$APP.Zo(I8b)),$APP.ap($APP.fg([$APP.z(mob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` implements [[IFrame]], false otherwise."],null)),$APP.z(Hmb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.nW,q6b],null))),$APP.P,"Marks (via metadata) the supplied set of `coords` as being owned by `owner`. If\n  `coords` already has an owner (that is not equal to `owner`), throws."],null)),$APP.z(gVb,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,new $APP.f(null,5,[$APP.z(vHb,new $APP.f(null,1,[$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not."],
null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null)],null),$APP.z(uwb,new $APP.f(null,1,[$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.Nx],null)],null),$APP.z(qS,new $APP.f(null,1,[$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor."],null)),new $APP.H(null,
1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)],null),$APP.z(IZb,new $APP.f(null,1,[$APP.P,"Returns the symbolic name of the suppplied frame."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)],null),$APP.z($APP.Fw,new $APP.f(null,1,[$APP.P,"Returns the parameters registered with the supplied frame."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)],null)],null)],null),$APP.Lv,new $APP.f(null,5,[wjb,new $APP.f(null,3,[$APP.R,vHb,$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null)),$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not."],null),xLb,new $APP.f(null,3,[$APP.R,uwb,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.Nx],null)),$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`."],
null),y4b,new $APP.f(null,3,[$APP.R,qS,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)),$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor."],null),B1b,new $APP.f(null,3,[$APP.R,IZb,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)),$APP.P,"Returns the symbolic name of the suppplied frame."],null),$APP.dm,new $APP.f(null,3,[$APP.R,$APP.Fw,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)),$APP.P,"Returns the parameters registered with the supplied frame."],
null)],null),eU,$APP.M("@interface")],null)),$APP.z(uwb,new $APP.f(null,3,[$APP.Nm,vX,$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.Nx],null)))],null)),$APP.z(dQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null))),$APP.P,"Returns the owning [[IFrame]] instance of the supplied coordinates `coords`,\n  nil if there's no owner otherwise."],
null)),$APP.z($APP.Fw,new $APP.f(null,3,[$APP.Nm,vX,$APP.P,"Returns the parameters registered with the supplied frame.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))],null)),$APP.z(qS,new $APP.f(null,3,[$APP.Nm,vX,$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))],null)),$APP.z(nMb,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[lS,
"null",vX,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,7,5,$APP.I,[qX,ZS,LQb,$APP.Vw,qS,$APP.Fw,uEb],null))),$APP.P,"Positional factory function for emmy.calculus.frame/t_emmy$calculus$frame49289."],null)),$APP.z(vHb,new $APP.f(null,3,[$APP.Nm,vX,$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null)))],null)),$APP.z(JRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))),$APP.P,"Returns true if `e` is an event, false otherwise.\n\n  Make new events with [[make-event]]."],null)),$APP.z(zac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))),$APP.P,"Marks the input event `e` as an event via its metadata. The return value will\n  return `true` when passed to [[event?]]."],
null)),$APP.z(IZb,new $APP.f(null,3,[$APP.Nm,vX,$APP.P,"Returns the symbolic name of the suppplied frame.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))],null)),$APP.z(jNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qX,ZS],null))),$APP.P,"Takes:\n\n  - `c-\x3ee`, a function mapping coordinates to events\n  - `e-\x3ec`, a function mapping events to coordinates\n\n  and returns a function that takes:\n\n  - a symbolic name\n  - an ancestor frame\n  - a dictionary of params\n\n  and returns instance of [[IFrame]].\n\n  Both `c-\x3ee` and `e-\x3ec` must accept three arguments:\n\n  - `ancestor-frame`\n  - the [[IFrame]] instance\n  - a map of parameters supplied to the returned function (possibly empty!)."],
null))],[new $APP.f(null,3,[$APP.R,Bxb,$APP.X,L2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` implements [[IFrame]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Tfb,$APP.X,R2a,$APP.h,new $APP.f(null,2,[$APP.P,"Marks (via metadata) the supplied set of `coords` as being owned by `owner`. If\n  `coords` already has an owner (that is not equal to `owner`), throws.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.nW,q6b],
null))],null)],null),new $APP.f(null,3,[$APP.R,vX,$APP.X,J2a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,p6b,$APP.X,aO,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.Nx],null))],null)],null),new $APP.f(null,3,[$APP.R,QLb,$APP.X,Q2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the owning [[IFrame]] instance of the supplied coordinates `coords`,\n  nil if there's no owner otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null))],null)],null),new $APP.f(null,3,[$APP.R,RYb,$APP.X,cO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the parameters registered with the supplied frame.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))],null)],null),new $APP.f(null,3,[$APP.R,rmb,$APP.X,K2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))],
null)],null),new $APP.f(null,3,[$APP.R,CKb,$APP.X,T2a,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.frame/t_emmy$calculus$frame49289.",$APP.U,$APP.M(new $APP.H(null,7,5,$APP.I,[qX,ZS,LQb,$APP.Vw,qS,$APP.Fw,uEb],null))],null)],null),new $APP.f(null,3,[$APP.R,cTb,$APP.X,$N,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null))],null)],null),new $APP.f(null,3,[$APP.R,P$b,$APP.X,O2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `e` is an event, false otherwise.\n\n  Make new events with [[make-event]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))],null)],null),new $APP.f(null,3,[$APP.R,ssb,$APP.X,N2a,$APP.h,new $APP.f(null,2,[$APP.P,"Marks the input event `e` as an event via its metadata. The return value will\n  return `true` when passed to [[event?]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))],null)],null),new $APP.f(null,3,[$APP.R,$Ob,$APP.X,bO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the symbolic name of the suppplied frame.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))],null)],null),new $APP.f(null,3,[$APP.R,zSb,$APP.X,U2a,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - `c-\x3ee`, a function mapping coordinates to events\n  - `e-\x3ec`, a function mapping events to coordinates\n\n  and returns a function that takes:\n\n  - a symbolic name\n  - an ancestor frame\n  - a dictionary of params\n\n  and returns instance of [[IFrame]].\n\n  Both `c-\x3ee` and `e-\x3ec` must accept three arguments:\n\n  - `ancestor-frame`\n  - the [[IFrame]] instance\n  - a map of parameters supplied to the returned function (possibly empty!).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[qX,ZS],null))],null)],null)]),$APP.Zo(Abb)),$APP.ap($APP.fg([$APP.z(pmb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Vw,$APP.fy,oZb],null)))],null)),$APP.z(t5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))),$APP.P,"Defined on FDG p.72."],null)),$APP.z(dhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))),$APP.P,"Defined on FDG p.72."],null)),$APP.z(uvb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,B9b],null)))],null)),$APP.z(t0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null)))],null)),$APP.z(RCb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RX],null)))],null)),$APP.z(y5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null),new $APP.H(null,2,5,$APP.I,[KT,RX],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,
2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[KT],null),new $APP.H(null,2,5,$APP.I,[KT,RX],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null),new $APP.H(null,2,5,$APP.I,[KT,RX],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(mvb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,RX],null)))],null)),$APP.z(ACb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,RX],null)))],null)),$APP.z(k_b,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))),$APP.P,"Returns a function which will pull a form back across a map (without needing\n  its inverse)"],null)),jib,$APP.z(w5a,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null)))],null))],[new $APP.f(null,3,[$APP.R,QRb,$APP.X,s5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Vw,$APP.fy,oZb],null))],null)],null),new $APP.f(null,3,[$APP.R,PNb,$APP.X,u5a,$APP.h,new $APP.f(null,
2,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))],null)],null),new $APP.f(null,3,[$APP.R,ZAb,$APP.X,AP,$APP.h,new $APP.f(null,2,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))],null)],null),new $APP.f(null,3,[$APP.R,DQb,$APP.X,x5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,B9b],null))],null)],null),new $APP.f(null,3,[$APP.R,FWb,$APP.X,o5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,
$APP.I,[KT],null))],null)],null),new $APP.f(null,3,[$APP.R,lzb,$APP.X,p5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RX],null))],null)],null),new $APP.f(null,3,[$APP.R,Zqb,$APP.X,I3,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null),new $APP.H(null,2,5,$APP.I,[KT,RX],null))],null)],null),new $APP.f(null,3,[$APP.R,Akb,$APP.X,A5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,RX],null))],null)],null),new $APP.f(null,3,[$APP.R,
gvb,$APP.X,r5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,RX],null))],null)],null),new $APP.f(null,3,[$APP.R,jPb,$APP.X,z5a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function which will pull a form back across a map (without needing\n  its inverse)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))],null)],null),new $APP.f(null,3,[$APP.R,AHb,$APP.X,AP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,dLb,$APP.X,BP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[KT],null))],null)],null)]),$APP.Zo(kUb)),$APP.ap(new $APP.f(null,1,[$APP.z(RLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hy,$APP.NW,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.Dw],null),$APP.ck,$APP.Lx],null)],null))),$APP.P,"Find the minimum of the function f: R^n -\x3e R, given an initial point q  R^n.\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked with iteration count,\n  the values of X and the value of f(X) at each intermediate point of\n  evaluation.\n\n  `:info?` if true, wraps the result with evaluation information.\n\n  `:adaptive?` if true, the Nelder-Mead parameters for contraction, expansion,\n  reflection and shrinking will be set adaptively, as functions of the number of\n  dimensions. If false they stay constant.\n\n  `:alpha` sets the reflection coefficient used for each step of Nelder-Mead.\n\n  `:beta` sets the expansion coefficient used for each step of Nelder-Mead.\n\n  `:gamma` sets the contraction coefficient used for each step of Nelder-Mead.\n\n  `:sigma` sets the shrink coefficient used for each step of Nelder-Mead.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  200*dimension.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 200*dimension.\n\n  `:simplex-tolerance` When the absolute value of the max difference between the\n  best point and any point in the simplex falls below this tolerance, the\n  minimizer stops. Defaults to 1e-4.\n\n  `:fn-tolerance` When the absolute value of the max difference between the best\n  point's function value and the fn value of any point in the simplex falls\n  below this tolerance, the minimizer stops. Defaults to 1e-4.\n\n  `:zero-delta` controls the value to which 0 entries in the initial vector are\n  set during initial simplex generation. Defaults to 0.00025.\n\n  `:nonzero-delta` factor by which entries in the initial vector are perturbed to\n  generate the initial simplex. Defaults to 0.05.\n\n  See Gao, F. and Han, L.\n      Implementing the Nelder-Mead simplex algorithm with adaptive\n      parameters. 2012. Computational Optimization and Applications.\n      51:1, pp. 259-277\n  I gratefully acknowledge the [Python implementation in\n  SciPy](https://github.com/scipy/scipy/blob/589c9afe41774ee96ec121f1867361146add8276/scipy/optimize/optimize.py#L556:5)\n  which I have imitated here.\n  "],
null)),new $APP.f(null,3,[$APP.R,VUb,$APP.X,H7a,$APP.h,new $APP.f(null,2,[$APP.P,"Find the minimum of the function f: R^n -\x3e R, given an initial point q  R^n.\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked with iteration count,\n  the values of X and the value of f(X) at each intermediate point of\n  evaluation.\n\n  `:info?` if true, wraps the result with evaluation information.\n\n  `:adaptive?` if true, the Nelder-Mead parameters for contraction, expansion,\n  reflection and shrinking will be set adaptively, as functions of the number of\n  dimensions. If false they stay constant.\n\n  `:alpha` sets the reflection coefficient used for each step of Nelder-Mead.\n\n  `:beta` sets the expansion coefficient used for each step of Nelder-Mead.\n\n  `:gamma` sets the contraction coefficient used for each step of Nelder-Mead.\n\n  `:sigma` sets the shrink coefficient used for each step of Nelder-Mead.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  200*dimension.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 200*dimension.\n\n  `:simplex-tolerance` When the absolute value of the max difference between the\n  best point and any point in the simplex falls below this tolerance, the\n  minimizer stops. Defaults to 1e-4.\n\n  `:fn-tolerance` When the absolute value of the max difference between the best\n  point's function value and the fn value of any point in the simplex falls\n  below this tolerance, the minimizer stops. Defaults to 1e-4.\n\n  `:zero-delta` controls the value to which 0 entries in the initial vector are\n  set during initial simplex generation. Defaults to 0.00025.\n\n  `:nonzero-delta` factor by which entries in the initial vector are perturbed to\n  generate the initial simplex. Defaults to 0.05.\n\n  See Gao, F. and Han, L.\n      Implementing the Nelder-Mead simplex algorithm with adaptive\n      parameters. 2012. Computational Optimization and Applications.\n      51:1, pp. 259-277\n  I gratefully acknowledge the [Python implementation in\n  SciPy](https://github.com/scipy/scipy/blob/589c9afe41774ee96ec121f1867361146add8276/scipy/optimize/optimize.py#L556:5)\n  which I have imitated here.\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hy,$APP.NW,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.Dw],null),$APP.ck,$APP.Lx],null)],null))],null)],null)],null),$APP.Zo(H0b)),$APP.ap($APP.fg([$APP.z(qmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[wU,$APP.tU,dX],null))),$APP.P,"Direct Clojure translation (via the Scheme translation in scmutils) of W.H.\n  Press, Numerical Recipes, subroutine `sncndn`.\n\n  Calls the supplied continuation `cont` with `sn`, `cn` and `dn` as defined\n  below.\n\n  If no `cont` is supplied, returns a three-vector of `sn`, `cn` and `dn`.\n\n  Comments from Press, page 261:\n\n  The Jacobian elliptic function sn is defined as follows: instead of\n  considering the elliptic integral\n\n  $$u(y, k) \\equiv u\x3dF(\\phi, k)$$\n\n  Consider the _inverse_ function:\n\n  ```\n  $$y \x3d \\sin \\phi \x3d \\mathrm{sn}(u, k)$$\n  ```\n\n  Equivalently,\n\n  ```\n  $$u\x3d\\int_{0}^{\\mathrm{sn}} \\frac{d y}{\\sqrt{\\left(1-y^{2}\\right)\\left(1-k^{2} y^{2}\\right)}}$$\n  ```\n\n  When $k \x3d 0$, $sn$ is just $\\sin$. The functions $cn$ and $dn$ are defined by\n  the relations\n\n  ```\n  $$\\mathrm{sn}^{2}+\\mathrm{cn}^{2}\x3d1, \\quad k^{2} \\mathrm{sn}^{2}+\\mathrm{dn}^{2}\x3d1$$\n  ```\n\n  The function calls the continuation with all three functions $sn$, $cn$, and\n  $dn$ since computing all three is no harder than computing any one of them.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[wU,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[wU,$APP.tU,dX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[wU,$APP.tU,dX],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(qGb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.tU],null),new $APP.H(null,2,5,$APP.I,[WR,$APP.tU],null))),$APP.P,
"Passing `k` returns the complete elliptic integral of the second kind - see\n  Press, 6.11.20.\n\n  The two-arity version returns the Legendre elliptic integral of the second\n  kind E(, k). See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.20.\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.tU],null),new $APP.H(null,2,5,$APP.I,[WR,$APP.tU],
null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.tU],null),new $APP.H(null,2,5,$APP.I,[WR,$APP.tU],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(rGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[WR,$APP.tU],null))),$APP.P,"Legendre elliptic integral of the first kind F(, k).\n   See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.19\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf)."],null)),$APP.z(Dcb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null))),$APP.P,"Computes Carlsons degenerate elliptic integral, $R_C(x, y)$. `x` must be\n  nonnegative and `y` must be nonzero. If `y \x3c 0`, the Cauchy principal value is\n  returned.\n\n  Internal details:\n\n  - `tiny` must be at least 5 times the machine underflow limit\n  - `big` at most one fifth the machine maximum overflow limit."],null)),$APP.z($cb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,
[$APP.Vv,$APP.SP,$APP.TP],null))),$APP.P,"From W.H. Press, Numerical Recipes in C++, 2ed. NR::rf from section 6.11\n\n  Here's the reference for what's going on here:\n  http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf\n\n  Comment from Press, page 257:\n\n  'Computes Carlsons elliptic integral of the first kind, RF (x, y, z). x, y,\n  and z must be nonnegative, and at most one can be zero. TINY must be at least\n  5 times the machine underflow limit, BIG at most one fifth the machine\n  overflow limit.'\n\n  A value of 0.08 for the error tolerance parameter is adequate for single\n  precision (7 significant digits). Since the error scales as 6 n, we see that\n  0.0025 will yield double precision (16 significant digits) and require at most\n  two or three more iterations.'\n\n  This is called `Carlson-elliptic-1` in scmutils."],
null)),$APP.z(R0b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[WR,$APP.uU,$APP.tU],null))),$APP.P,"The two-arity call returns the complete elliptic integral of the third kind -\n  see\n  https://en.wikipedia.org/wiki/Carlson_symmetric_form#Complete_elliptic_integrals\n  for reference.\n\n  The three-arity call returns the Legendre elliptic integral of the third kind\n  (, k). See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.21; Note that\n  our sign convention for `n` is opposite theirs.\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[WR,$APP.uU,$APP.tU],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[WR,$APP.uU,$APP.tU],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Zyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.tU],null))),$APP.P,"Returns a pair of:\n\n  - the elliptic integral of the first kind, `K`\n  - the derivative `dK/dk`\n\n  evaluated at `k`."],
null)),$APP.z(Ccb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null))),$APP.P,"Comment from Press, section 6.11, page 257:\n\n  'Computes Carlsons elliptic integral of the second kind, RD(x, y, z). x and y must be\n  nonnegative, and at most one can be zero. z must be positive. TINY must be at least twice\n  the negative 2/3 power of the machine overflow limit. BIG must be at most 0.1  ERRTOL\n  times the negative 2/3 power of the machine underflow limit.'\n\n  This is called `Carlson-elliptic-2` in scmutils."],
null)),$APP.z(nGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.tU],null))),$APP.P,"Complete elliptic integral of the first kind - see Press, 6.11.18."],null)),$APP.z(adb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP,$APP.Pv],null))),$APP.P,"Computes\n  [Carlsons elliptic\n  integral](https://en.wikipedia.org/wiki/Carlson_symmetric_form) of the third\n  kind, `RJ(x, y, z, p)`.\n\n  `x`, `y`, and `z` must be nonnegative, and at most one can be zero. `p` must\n  be nonzero.\n\n  If `p \x3c 0`, the Cauchy principal value is returned. `tiny` internally must be\n  at least twice the cube root of the machine underflow limit, `big` at most one\n  fifth the cube root of the machine overflow limit."],
null)),$APP.z(ijb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.tU,FT],null))),$APP.P,"Computes the first and second complete elliptic integrals at once, and passes\n  them to the supplied continuation as args `K` and `E`."],null))],[new $APP.f(null,3,[$APP.R,hlb,$APP.X,L4,$APP.h,new $APP.f(null,2,[$APP.P,"Direct Clojure translation (via the Scheme translation in scmutils) of W.H.\n  Press, Numerical Recipes, subroutine `sncndn`.\n\n  Calls the supplied continuation `cont` with `sn`, `cn` and `dn` as defined\n  below.\n\n  If no `cont` is supplied, returns a three-vector of `sn`, `cn` and `dn`.\n\n  Comments from Press, page 261:\n\n  The Jacobian elliptic function sn is defined as follows: instead of\n  considering the elliptic integral\n\n  $$u(y, k) \\equiv u\x3dF(\\phi, k)$$\n\n  Consider the _inverse_ function:\n\n  ```\n  $$y \x3d \\sin \\phi \x3d \\mathrm{sn}(u, k)$$\n  ```\n\n  Equivalently,\n\n  ```\n  $$u\x3d\\int_{0}^{\\mathrm{sn}} \\frac{d y}{\\sqrt{\\left(1-y^{2}\\right)\\left(1-k^{2} y^{2}\\right)}}$$\n  ```\n\n  When $k \x3d 0$, $sn$ is just $\\sin$. The functions $cn$ and $dn$ are defined by\n  the relations\n\n  ```\n  $$\\mathrm{sn}^{2}+\\mathrm{cn}^{2}\x3d1, \\quad k^{2} \\mathrm{sn}^{2}+\\mathrm{dn}^{2}\x3d1$$\n  ```\n\n  The function calls the continuation with all three functions $sn$, $cn$, and\n  $dn$ since computing all three is no harder than computing any one of them.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[wU,$APP.tU,dX],null))],null)],null),new $APP.f(null,3,[$APP.R,S7b,$APP.X,J4,$APP.h,new $APP.f(null,2,[$APP.P,"Passing `k` returns the complete elliptic integral of the second kind - see\n  Press, 6.11.20.\n\n  The two-arity version returns the Legendre elliptic integral of the second\n  kind E(, k). See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.20.\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.tU],null),new $APP.H(null,2,5,$APP.I,[WR,$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,T7b,$APP.X,vab,$APP.h,new $APP.f(null,2,[$APP.P,"Legendre elliptic integral of the first kind F(, k).\n   See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.19\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[WR,$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,LPb,$APP.X,tab,$APP.h,
new $APP.f(null,2,[$APP.P,"Computes Carlsons degenerate elliptic integral, $R_C(x, y)$. `x` must be\n  nonnegative and `y` must be nonzero. If `y \x3c 0`, the Cauchy principal value is\n  returned.\n\n  Internal details:\n\n  - `tiny` must be at least 5 times the machine underflow limit\n  - `big` at most one fifth the machine maximum overflow limit.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null))],null)],null),new $APP.f(null,3,[$APP.R,KPb,$APP.X,LR,$APP.h,new $APP.f(null,2,[$APP.P,
"From W.H. Press, Numerical Recipes in C++, 2ed. NR::rf from section 6.11\n\n  Here's the reference for what's going on here:\n  http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf\n\n  Comment from Press, page 257:\n\n  'Computes Carlsons elliptic integral of the first kind, RF (x, y, z). x, y,\n  and z must be nonnegative, and at most one can be zero. TINY must be at least\n  5 times the machine underflow limit, BIG at most one fifth the machine\n  overflow limit.'\n\n  A value of 0.08 for the error tolerance parameter is adequate for single\n  precision (7 significant digits). Since the error scales as 6 n, we see that\n  0.0025 will yield double precision (16 significant digits) and require at most\n  two or three more iterations.'\n\n  This is called `Carlson-elliptic-1` in scmutils.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null))],null)],null),new $APP.f(null,3,[$APP.R,Ipb,$APP.X,K4,$APP.h,new $APP.f(null,2,[$APP.P,"The two-arity call returns the complete elliptic integral of the third kind -\n  see\n  https://en.wikipedia.org/wiki/Carlson_symmetric_form#Complete_elliptic_integrals\n  for reference.\n\n  The three-arity call returns the Legendre elliptic integral of the third kind\n  (, k). See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.21; Note that\n  our sign convention for `n` is opposite theirs.\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[WR,$APP.uU,$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,Gtb,$APP.X,function(a){return $APP.Uc.A(a,0)?new $APP.H(null,2,5,$APP.I,[Math.PI/2,0],null):wab(a,function(b,c){return new $APP.H(null,2,5,$APP.I,[b,(c/(1-a*a)-b)/a],null)})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a pair of:\n\n  - the elliptic integral of the first kind, `K`\n  - the derivative `dK/dk`\n\n  evaluated at `k`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,FPb,$APP.X,sab,$APP.h,new $APP.f(null,2,[$APP.P,"Comment from Press, section 6.11, page 257:\n\n  'Computes Carlsons elliptic integral of the second kind, RD(x, y, z). x and y must be\n  nonnegative, and at most one can be zero. z must be positive. TINY must be at least twice\n  the negative 2/3 power of the machine overflow limit. BIG must be at most 0.1  ERRTOL\n  times the negative 2/3 power of the machine underflow limit.'\n\n  This is called `Carlson-elliptic-2` in scmutils.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null))],null)],null),new $APP.f(null,3,[$APP.R,R7b,$APP.X,function(a){return vab(Math.PI/2,a)},$APP.h,new $APP.f(null,2,[$APP.P,"Complete elliptic integral of the first kind - see Press, 6.11.18.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,OPb,$APP.X,uab,$APP.h,new $APP.f(null,2,[$APP.P,"Computes\n  [Carlsons elliptic\n  integral](https://en.wikipedia.org/wiki/Carlson_symmetric_form) of the third\n  kind, `RJ(x, y, z, p)`.\n\n  `x`, `y`, and `z` must be nonnegative, and at most one can be zero. `p` must\n  be nonzero.\n\n  If `p \x3c 0`, the Cauchy principal value is returned. `tiny` internally must be\n  at least twice the cube root of the machine underflow limit, `big` at most one\n  fifth the cube root of the machine overflow limit.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP,$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,vMb,$APP.X,wab,$APP.h,new $APP.f(null,2,[$APP.P,"Computes the first and second complete elliptic integrals at once, and passes\n  them to the supplied continuation as args `K` and `E`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.tU,FT],null))],null)],null)]),$APP.Zo(BGb)),$APP.ap(new $APP.f(null,8,[$APP.z(jxb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null))),$APP.P,"Identical to bracket-min, except brackets a maximum of the supplied fn.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null)),$APP.zx,$APP.M(null,null)],null)],null)),
new $APP.f(null,3,[$APP.R,RZb,$APP.X,V3,$APP.h,new $APP.f(null,2,[$APP.P,"Identical to bracket-min, except brackets a maximum of the supplied fn.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null))],null)],null),$APP.z(Blb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[PW,cWb],null),new $APP.H(null,2,5,$APP.I,[QW,dWb],null),new $APP.H(null,2,5,$APP.I,[aUb,eWb],null)],null),new $APP.f(null,
1,[$APP.dta,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Xh,new $APP.H(null,1,5,$APP.I,[acb],null),$APP.M($APP.$v,$APP.M($APP.Uua,acb),0))],null)],null)))),$APP.P,"Accepts three pairs of `[x, (f x)]`, fits a quadratic function to all three\n  points and returns the step from `xb` (the coordinate of the second argument)\n  to the minimum of the fitted quadratic.\n\n  Returns the numerator and denominator `p` and `q` of the required step. If `q`\n  is 0, then the supplied points were colinear.\n\n  `q` is guaranteed to be `\x3e\x3d 0`, while `p` might be negative.\n\n  See these notes for the derivation of this method:\n  http://fourier.eng.hmc.edu/e176/lectures/NM/node25.html"],
null)),new $APP.f(null,3,[$APP.R,Ycb,$APP.X,U7a,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts three pairs of `[x, (f x)]`, fits a quadratic function to all three\n  points and returns the step from `xb` (the coordinate of the second argument)\n  to the minimum of the fitted quadratic.\n\n  Returns the numerator and denominator `p` and `q` of the required step. If `q`\n  is 0, then the supplied points were colinear.\n\n  `q` is guaranteed to be `\x3e\x3d 0`, while `p` might be negative.\n\n  See these notes for the derivation of this method:\n  http://fourier.eng.hmc.edu/e176/lectures/NM/node25.html",
$APP.U,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[PW,cWb],null),new $APP.H(null,2,5,$APP.I,[QW,dWb],null),new $APP.H(null,2,5,$APP.I,[aUb,eWb],null)],null),new $APP.f(null,1,[$APP.dta,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Xh,new $APP.H(null,1,5,$APP.I,[acb],null),$APP.M($APP.$v,$APP.M($APP.Uua,acb),0))],null)],null)))],null)],null),$APP.z(VKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null))),$APP.P,"Returns the points ordered as f(a) \x3c f(b)"],
null)),new $APP.f(null,3,[$APP.R,xjb,$APP.X,T7a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the points ordered as f(a) \x3c f(b)",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null))],null)],null),$APP.z(ARb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null))),$APP.P,"Identical to bracket-min-scmutils, except brackets a maximum of the supplied\n  fn.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,
$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,fdb,$APP.X,X3,$APP.h,new $APP.f(null,2,[$APP.P,"Identical to bracket-min-scmutils, except brackets a maximum of the supplied\n  fn.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null))],null)],null),$APP.z(JYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[wrb],null),$APP.Kl,new $APP.f(null,1,[wrb,110],null)],null)],null))),$APP.P,"Returns a function that performs steps of bracket extension.\n\n  :grow-limit is the maximum factor that the parabolic interpolation can jump\n  the function."],null)),new $APP.f(null,3,[$APP.R,
WYb,$APP.X,X7a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that performs steps of bracket extension.\n\n  :grow-limit is the maximum factor that the parabolic interpolation can jump\n  the function.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[wrb],null),$APP.Kl,new $APP.f(null,1,[wrb,110],null)],null)],null))],null)],null),$APP.z(ayb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,
2,5,$APP.I,[$APP.Kv,new $APP.f(null,3,[$APP.zu,new $APP.H(null,4,5,$APP.I,[PW,QW,IT,sX],null),$APP.Kl,new $APP.f(null,4,[PW,0,QW,1,IT,1E3,sX,1E3],null),$APP.ck,$APP.Lx],null)],null))),$APP.P,"Generates an interval `[lo, hi]` that is guaranteed to contain a minimum of the\n  function `f`, along with a candidate point `[mid, (f mid)]` that the user can\n  use to start a minimum search.\n\n  Returns a dictionary of the form:\n\n  {:lo `lower end of the bracket`\n   :mid `candidate point`\n   :hi `upper end of the bracket`\n   :fncalls `# of fn evaluations so far`\n   :iterations `total iterations`}\n\n  `:lo`, `:mid` and `:hi` are each pairs of the form `[x, (f x)]`.\n\n  The implementation works by growing the bounds using either:\n\n  - a step outside the bounds that places one bound at the golden-ratio cut\n  point between the new bounds, or\n  - a parabola with a minimum interpolated outside the current bounds, bounded b\n  a max.\n\n  This implementation was ported from `scipy.optimize.optimize.bracket`:\n  https://github.com/scipy/scipy/blob/v1.5.2/scipy/optimize/optimize.py#L2450\n\n  `bracket-min` supports the following optional keyword arguments:\n\n  `:xa` the initial guess for the lower end of the bracket. Defaults to 0.0.\n\n  `:xb` the initial guess for the upper end of the bracket. Defaults to 1.0. (If\n  these points aren't supplied in sorted order they'll be switched.)\n\n  `:grow-limit` The maximum factor that the parabolic interpolation can jump the\n  function. Defaults to 110.0.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n  ",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,3,[$APP.zu,new $APP.H(null,4,5,$APP.I,[PW,QW,IT,sX],null),$APP.Kl,new $APP.f(null,4,[PW,0,QW,1,IT,1E3,sX,1E3],null),$APP.ck,$APP.Lx],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,3,[$APP.zu,new $APP.H(null,4,5,$APP.I,[PW,QW,IT,sX],
null),$APP.Kl,new $APP.f(null,4,[PW,0,QW,1,IT,1E3,sX,1E3],null),$APP.ck,$APP.Lx],null)],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,XWb,$APP.X,U3,$APP.h,new $APP.f(null,2,[$APP.P,"Generates an interval `[lo, hi]` that is guaranteed to contain a minimum of the\n  function `f`, along with a candidate point `[mid, (f mid)]` that the user can\n  use to start a minimum search.\n\n  Returns a dictionary of the form:\n\n  {:lo `lower end of the bracket`\n   :mid `candidate point`\n   :hi `upper end of the bracket`\n   :fncalls `# of fn evaluations so far`\n   :iterations `total iterations`}\n\n  `:lo`, `:mid` and `:hi` are each pairs of the form `[x, (f x)]`.\n\n  The implementation works by growing the bounds using either:\n\n  - a step outside the bounds that places one bound at the golden-ratio cut\n  point between the new bounds, or\n  - a parabola with a minimum interpolated outside the current bounds, bounded b\n  a max.\n\n  This implementation was ported from `scipy.optimize.optimize.bracket`:\n  https://github.com/scipy/scipy/blob/v1.5.2/scipy/optimize/optimize.py#L2450\n\n  `bracket-min` supports the following optional keyword arguments:\n\n  `:xa` the initial guess for the lower end of the bracket. Defaults to 0.0.\n\n  `:xb` the initial guess for the upper end of the bracket. Defaults to 1.0. (If\n  these points aren't supplied in sorted order they'll be switched.)\n\n  `:grow-limit` The maximum factor that the parabolic interpolation can jump the\n  function. Defaults to 110.0.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n  ",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,3,[$APP.zu,new $APP.H(null,4,5,$APP.I,[PW,QW,IT,sX],null),$APP.Kl,new $APP.f(null,4,[PW,0,QW,1,IT,1E3,sX,1E3],null),$APP.ck,$APP.Lx],null)],null))],null)],null),$APP.z(NUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Iv,new $APP.H(null,3,5,$APP.I,[QW,$APP.ck,$APP.qU],null),$APP.Jv],null))),$APP.P,"Fits a parabola through all three points, and returns the coordinate of the\n  minimum of the parabola.\n\n  If the supplied points are colinear, returns a point that takes a large jump\n  in the direction of the downward slope of the line."],
null)),new $APP.f(null,3,[$APP.R,QUb,$APP.X,V7a,$APP.h,new $APP.f(null,2,[$APP.P,"Fits a parabola through all three points, and returns the coordinate of the\n  minimum of the parabola.\n\n  If the supplied points are colinear, returns a point that takes a large jump\n  in the direction of the downward slope of the line.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Iv,new $APP.H(null,3,5,$APP.I,[QW,$APP.ck,$APP.qU],null),$APP.Jv],null))],null)],null),$APP.z(Fqb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,2,[$APP.zu,new $APP.H(null,3,5,$APP.I,[$APP.Bw,$APP.tv,IT],null),$APP.Kl,new $APP.f(null,3,[$APP.Bw,0,$APP.tv,10,IT,1E3],null)],null)],null))),$APP.P," Given a function f, a starting point and a step size, try to bracket a local\n  extremum for f.\n\n  Return a list (retcode a b c fa fb fc iter-count) where a \x3c b \x3c c, and fa, fb,\n  fc are the function values at these points. In the case of a minimum, fb\n  \x3c\x3d (min fa fc); the opposite inequality holds in the case of a maximum.\n\n  iter-count is the number of function evaluations required. retcode is 'okay if\n  the search succeeded, or 'maxcount if it was abandoned.\n  ",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,2,[$APP.zu,new $APP.H(null,3,5,$APP.I,[$APP.Bw,$APP.tv,IT],null),$APP.Kl,new $APP.f(null,3,[$APP.Bw,0,$APP.tv,10,IT,1E3],null)],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,2,[$APP.zu,new $APP.H(null,3,5,$APP.I,[$APP.Bw,$APP.tv,
IT],null),$APP.Kl,new $APP.f(null,3,[$APP.Bw,0,$APP.tv,10,IT,1E3],null)],null)],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,asb,$APP.X,W3,$APP.h,new $APP.f(null,2,[$APP.P," Given a function f, a starting point and a step size, try to bracket a local\n  extremum for f.\n\n  Return a list (retcode a b c fa fb fc iter-count) where a \x3c b \x3c c, and fa, fb,\n  fc are the function values at these points. In the case of a minimum, fb\n  \x3c\x3d (min fa fc); the opposite inequality holds in the case of a maximum.\n\n  iter-count is the number of function evaluations required. retcode is 'okay if\n  the search succeeded, or 'maxcount if it was abandoned.\n  ",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,new $APP.f(null,2,[$APP.zu,new $APP.H(null,3,5,$APP.I,[$APP.Bw,$APP.tv,IT],null),$APP.Kl,new $APP.f(null,3,[$APP.Bw,0,$APP.tv,10,IT,1E3],null)],null)],null))],null)],null)],null),$APP.Zo(wPb)),$APP.ap($APP.fg([$APP.z(ybb,new $APP.f(null,3,[$APP.Nm,hU,$APP.P,"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[emmy.value/zero-like]] this)`.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Qu,$APP.Ux,kW],null)))],null)),$APP.z(uyb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,6,[kU,"null",hU,"null",WE,"null",LY,"null",gV,"null",y7b,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ux,QS,FW],null))),VR,new $APP.ug(null,new $APP.f(null,3,[kU,"null",gV,"null",y7b,"null"],null),null),$APP.P,"Positional factory function for emmy.dual/Dual."],null)),$APP.z(keb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.sf)),$APP.P,"Returns a new, unique tag for use by a perturbation in an automatic\n  differentiation pass."],null)),$APP.z(KTb,new $APP.f(null,4,[ZX,!0,$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Yyb],null))),$APP.P,"Positional factory function for emmy.dual/Completed."],null)),$APP.z(Gmb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z($APP.Ux,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null))),$APP.P,"If `dx` is an instance of [[Dual]] returns the `tag` component. Else, acts\n  as nil."],
null)),$APP.z(bX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Iv,$APP.qU,$APP.Lh,$APP.Ww],null))),$APP.P,"For non-differentials, this is identical to [[emmy.value/\x3d]].\n  For [[Dual]] instances, equality acts on tangent components too.\n\n  If you want to ignore the tangent components, use [[equiv]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,
new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Iv,$APP.qU,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(Pvb,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,new $APP.f(null,3,[$APP.z(seb,new $APP.f(null,1,[$APP.P,"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`."],
null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Qu,Epb,Szb],null)],null),$APP.z(ybb,new $APP.f(null,1,[$APP.P,"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[emmy.value/zero-like]] this)`."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Qu,$APP.Ux,kW],null)],null),$APP.z(Vbc,new $APP.f(null,1,[$APP.P,"Given an instance of [[Completed]] (or a container type with [[Completed]]\n    instances at its leaves) and the `id` of an [[emmy.tape/TapeCell]], returns\n    the partial derivative associated with that [[emmy.tape/TapeCell]]'s\n    `id`.\n\n    This function is an internal implementation detail of reverse-mode automatic\n    differentiation."],
null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.tx],null)],null)],null)],null),$APP.Lv,new $APP.f(null,3,[U3b,new $APP.f(null,3,[$APP.R,seb,$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Qu,Epb,Szb],null)),$APP.P,"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`."],null),Zfb,new $APP.f(null,3,[$APP.R,ybb,$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Qu,
$APP.Ux,kW],null)),$APP.P,"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[emmy.value/zero-like]] this)`."],null),GPb,new $APP.f(null,3,[$APP.R,Vbc,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.tx],null)),$APP.P,"Given an instance of [[Completed]] (or a container type with [[Completed]]\n    instances at its leaves) and the `id` of an [[emmy.tape/TapeCell]], returns\n    the partial derivative associated with that [[emmy.tape/TapeCell]]'s\n    `id`.\n\n    This function is an internal implementation detail of reverse-mode automatic\n    differentiation."],
null)],null),eU,$APP.M("@interface")],null)),$APP.z(seb,new $APP.f(null,3,[$APP.Nm,hU,$APP.P,"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Qu,Epb,Szb],null)))],null)),$APP.z(Rvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null))),$APP.P,"Returns true if the supplied object is an instance of [[Dual]], false\n  otherwise."],
null)),$APP.z(kNb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(B7b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Rv],null))),$APP.P,"Returns a pair of the primal and tangent components of the supplied `dx`, with\n  respect to the supplied `tag`. See the docs for [[primal]]\n  and [[tangent]] for more details.\n\n  [[primal-tangent-pair]] is equivalent to\n\n  `[([[primal]] dx tag) ([[tangent]] dx tag)]`\n\n  but slightly more efficient if you need both.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Rv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Rv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(mgb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QS],null),new $APP.H(null,2,5,$APP.I,[QS,$APP.Ux],null),$APP.z(new $APP.H(null,3,5,$APP.I,
[QS,FW,$APP.Ux],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(Oqb,QS)],null)],null)))),$APP.P,"Returns a new [[Dual]] object with the supplied `primal` and `tangent`\n  components, and the supplied internal `tag` that this [[Dual]] will\n  carry around to prevent perturbation confusion.\n\n  If the `tangent` component is `0`, acts as identity on `primal`. `tangent`\n  defaults to 1.\n\n  `tag` defaults to a side-effecting call to [[fresh-tag]]; you can retrieve\n  this unknown tag by calling [[tag]] on the returned [[Dual]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[QS],null),new $APP.H(null,2,5,$APP.I,[QS,$APP.Ux],null),new $APP.H(null,3,5,$APP.I,[QS,FW,$APP.Ux],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[QS],null),new $APP.H(null,2,5,$APP.I,[QS,$APP.Ux],null),new $APP.H(null,3,5,$APP.I,[QS,FW,$APP.Ux],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z($APP.sw,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(QS,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Ux],null))),$APP.P,"If `dx` is an instance of [[Dual]] returns the `primal` component. Else, acts\n  as identity.\n\n  If the optional `tag` is supplied, [[primal-part]] acts as identity\n  for [[Dual]] instances with a non-matching tag.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,
[$W,$APP.Ux],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Ux],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(FW,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Ux],null))),$APP.P,"If `dx` is an instance of [[Dual]] returns the `tangent` component. Else, returns 0.\n\n  If the optional `tag` is supplied, [[primal-part]] returns 0 for [[Dual]]\n  instances with a non-matching tag.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Ux],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Ux],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(uCb,new $APP.f(null,4,[ZX,!0,$APP.lw,$APP.nj,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Lub],null))),$APP.P,"Factory function for emmy.dual/Completed, taking a map of keywords to field values."],
null)),$APP.z(BKb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(pYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ux,$APP.Kv,$APP.Mu],null))),$APP.P,"Like `apply`, but conj-es `tag` onto the dynamic variable [[*active-tags*]]\n  inside the scope of `f`.\n\n  Returns the result of applying `f` to `args`."],null)),$APP.z(M0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"Comparator that compares [[Dual]] instances with each other or\n  non-differentials using all tangent terms each instance. Matches the response\n  of [[eq]].\n\n  Acts as [[emmy.value/compare]] for non-differentials."],
null)),$APP.z(VXb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(Vbc,new $APP.f(null,3,[$APP.Nm,hU,$APP.P,"Given an instance of [[Completed]] (or a container type with [[Completed]]\n    instances at its leaves) and the `id` of an [[emmy.tape/TapeCell]], returns\n    the partial derivative associated with that [[emmy.tape/TapeCell]]'s\n    `id`.\n\n    This function is an internal implementation detail of reverse-mode automatic\n    differentiation.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,
$APP.I,[$APP.Qu,$APP.tx],null)))],null)),$APP.z(mjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ux],null))),$APP.P,"Returns true if `tag` is an element of [[*active-tags*]] (and therefore pending\n  for extraction by some nested derivative), false otherwise."],null)),$APP.z(Dub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[emmy.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to handle [[Dual]]\n  inputs in addition to any types that a normal `(f x)` call would present. This\n  restriction does _not_ apply to operations like putting `x` into a container\n  or destructuring; just primitive function calls."],
null)),$APP.z(Grb,new $APP.f(null,1,[$APP.Kw,!0],null))],[new $APP.f(null,3,[$APP.R,W3b,$APP.X,GH,$APP.h,new $APP.f(null,2,[$APP.P,"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[emmy.value/zero-like]] this)`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Qu,$APP.Ux,kW],null))],null)],null),new $APP.f(null,3,[$APP.R,eBb,$APP.X,CWa,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.dual/Dual.",$APP.U,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.Ux,QS,FW],null))],null)],null),new $APP.f(null,3,[$APP.R,NAb,$APP.X,JH,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new, unique tag for use by a perturbation in an automatic\n  differentiation pass.",$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.R,Atb,$APP.X,AWa,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.dual/Completed.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Yyb],null))],null)],null),new $APP.f(null,3,[$APP.R,rPb,$APP.X,Y_,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns true if all of the supplied objects have equal [[primal]]s, false\n  otherwise.\n\n  Use [[equiv]] if you want to compare scalars with\n  [[Dual]]s and ignore the tangent. If you _do_ want to take the tangent into\n  account, prefer [[eq]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Iv,$APP.qU,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,W8b,$APP.X,MH,$APP.h,new $APP.f(null,
2,[$APP.P,"If `dx` is an instance of [[Dual]] returns the `tag` component. Else, acts\n  as nil.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null))],null)],null),new $APP.f(null,3,[$APP.R,e3b,$APP.X,Z_,$APP.h,new $APP.f(null,2,[$APP.P,"For non-differentials, this is identical to [[emmy.value/\x3d]].\n  For [[Dual]] instances, equality acts on tangent components too.\n\n  If you want to ignore the tangent components, use [[equiv]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),new $APP.H(null,
2,5,$APP.I,[$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Iv,$APP.qU,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,hU,$APP.X,zWa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,eUb,$APP.X,FH,$APP.h,new $APP.f(null,2,[$APP.P,"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Qu,Epb,Szb],null))],null)],null),
new $APP.f(null,3,[$APP.R,k5b,$APP.X,LH,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied object is an instance of [[Dual]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null))],null)],null),new $APP.f(null,3,[$APP.R,sLb,$APP.X,RH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Krb,$APP.X,bN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a pair of the primal and tangent components of the supplied `dx`, with\n  respect to the supplied `tag`. See the docs for [[primal]]\n  and [[tangent]] for more details.\n\n  [[primal-tangent-pair]] is equivalent to\n\n  `[([[primal]] dx tag) ([[tangent]] dx tag)]`\n\n  but slightly more efficient if you need both.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.R,Lkb,$APP.X,QH,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new [[Dual]] object with the supplied `primal` and `tangent`\n  components, and the supplied internal `tag` that this [[Dual]] will\n  carry around to prevent perturbation confusion.\n\n  If the `tangent` component is `0`, acts as identity on `primal`. `tangent`\n  defaults to 1.\n\n  `tag` defaults to a side-effecting call to [[fresh-tag]]; you can retrieve\n  this unknown tag by calling [[tag]] on the returned [[Dual]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[QS],null),new $APP.H(null,2,5,$APP.I,[QS,$APP.Ux],null),$APP.z(new $APP.H(null,3,5,$APP.I,[QS,FW,$APP.Ux],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(Oqb,QS)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Sgb,$APP.X,EWa,$APP.h,new $APP.f(null,2,[$APP.P,"Comparator that compares [[Dual]] instances with each other or\n  non-differentials using only the [[primal]] of each instance. Matches the\n  response of [[equiv]].\n\n  Acts as [[emmy.value/compare]] for non-differentials.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,JLb,$APP.X,PH,$APP.h,new $APP.f(null,2,[$APP.P,"If `dx` is an instance of [[Dual]] returns the `primal` component. Else, acts\n  as identity.\n\n  If the optional `tag` is supplied, [[primal-part]] acts as identity\n  for [[Dual]] instances with a non-matching tag.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Ux],null))],null)],null),new $APP.f(null,
3,[$APP.R,Sbb,$APP.X,WN,$APP.h,new $APP.f(null,2,[$APP.P,"If `dx` is an instance of [[Dual]] returns the `tangent` component. Else, returns 0.\n\n  If the optional `tag` is supplied, [[primal-part]] returns 0 for [[Dual]]\n  instances with a non-matching tag.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$W],null),new $APP.H(null,2,5,$APP.I,[$W,$APP.Ux],null))],null)],null),new $APP.f(null,3,[$APP.R,D1b,$APP.X,function(a){var b=$APP.Oi.A(a,wV);b=$APP.nd(a)?$APP.Lf.A($APP.F,b):b;return new IH(wV.j(a),
null,$APP.re(b),null)},$APP.h,new $APP.f(null,2,[$APP.P,"Factory function for emmy.dual/Completed, taking a map of keywords to field values.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Lub],null))],null)],null),new $APP.f(null,3,[$APP.R,QSb,$APP.X,NH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,tZb,$APP.X,OH,$APP.h,new $APP.f(null,2,[$APP.P,"Like `apply`, but conj-es `tag` onto the dynamic variable [[*active-tags*]]\n  inside the scope of `f`.\n\n  Returns the result of applying `f` to `args`.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ux,$APP.Kv,$APP.Mu],null))],null)],null),new $APP.f(null,3,[$APP.R,Y5b,$APP.X,function(a,b){return HF(bN.j(a),bN.j(b))},$APP.h,new $APP.f(null,2,[$APP.P,"Comparator that compares [[Dual]] instances with each other or\n  non-differentials using all tangent terms each instance. Matches the response\n  of [[eq]].\n\n  Acts as [[emmy.value/compare]] for non-differentials.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,
3,[$APP.R,ORb,$APP.X,ZM,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,b$b,$APP.X,HH,$APP.h,new $APP.f(null,2,[$APP.P,"Given an instance of [[Completed]] (or a container type with [[Completed]]\n    instances at its leaves) and the `id` of an [[emmy.tape/TapeCell]], returns\n    the partial derivative associated with that [[emmy.tape/TapeCell]]'s\n    `id`.\n\n    This function is an internal implementation detail of reverse-mode automatic\n    differentiation.",$APP.U,$APP.M(new $APP.H(null,2,5,
$APP.I,[$APP.Qu,$APP.tx],null))],null)],null),new $APP.f(null,3,[$APP.R,vPb,$APP.X,DWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `tag` is an element of [[*active-tags*]] (and therefore pending\n  for extraction by some nested derivative), false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ux],null))],null)],null),new $APP.f(null,3,[$APP.R,Uyb,$APP.X,FWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[emmy.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to handle [[Dual]]\n  inputs in addition to any types that a normal `(f x)` call would present. This\n  restriction does _not_ apply to operations like putting `x` into a container\n  or destructuring; just primitive function calls.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,P7b,$APP.X,X_,$APP.h,$APP.F],null)]),$APP.Zo(Wcb)),$APP.ap($APP.fg([$APP.z(mU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures."],null)),$APP.z(xP,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))),
$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.fx)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(D2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))),$APP.P,"Construct a down (covariant) tuple from the supplied sequence. For a\n  variadic version, see [[down]]."],
null)),$APP.z(H2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns `true` if `s` is a `down` structure, false otherwise."],null)),$APP.z($APP.AY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"If `s` is sequential, returns its dimension, i.e., the total number of\n  non-sequential entries in the structure. Else, returns 1."],null)),$APP.z(pWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(Fmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null))),$APP.P,"For a non-[[Structure]] `s`, the single-arity case acts as [[identity]]. For\n  a [[Structure]], returns an identical structure with its orientation\n  reversed (up becomes down, down becomes up).\n\n  NOTE that a vector is interpreted as an `up` structure, so:\n\n  (opposite [1 2 3])\n  ;;\x3d\x3e (down 1 2 3)\n\n  The two-arity case returns a new [[Structure]] of opposite orientation to `s`\n  with the contents of the sequence `xs`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(vzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,
[$APP.M($APP.Yw,$APP.Tv)],null)],null)))),$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient."],null)),$APP.z(w6b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null))),$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(YOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `s` is an `up` or `down` structure containing all `up` or\n  `down` structures of internally-matching orientation and size, false\n  otherwise."],
null)),$APP.z(u0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,$APP.Sv],null))),$APP.P,"Accepts\n\n  - some symbolic (or string) `name`\n  - a structure `s`\n\n  and returns a new structure of identical shape, with symbolic entries like\n  `'x0_1` that show their access chain with proper orientations for each step."],null)),$APP.z(MY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise."],
null)),$APP.z(avb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(lib,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(O7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Return the structure `s` in unoriented vector form."],null)),$APP.z(Omb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))),$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```"],
null)),$APP.z(DKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a structure of the same shape and orientation as `s`, generated by\n  substituting gensymmed symbols in for each entry."],null)),gEb,$APP.z(gU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[mU,$APP.fx],null))),$APP.P,"Generate a structure with the supplied orientation, given some sequence `xs`"],null)),$APP.z(mIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null))),$APP.P,"Returns a new structure of equivalent shape to `s`, generated by applying `f`\n  to three arguments:\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  For example:\n\n  ```clojure\n  (dorun (map-chain println (s/down (s/up 1 2) (s/up 3 4))))\n\n  1 [0 0] [::s/down ::s/up]\n  2 [0 1] [::s/down ::s/up]\n  3 [1 0] [::s/down ::s/up]\n  4 [1 1] [::s/down ::s/up]\n  ```"],
null)),$APP.z(TIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a structure compatible for multiplication with `s` down to 0."],null)),aqb,$APP.z($gb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ov,sU],null))),$APP.P,"Returns `1` if `i`\x3d\x3d `j`, `0` otherwise."],null)),$APP.z(cSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))),$APP.P,"Returns true if the supplied structures have the same orientation, false\n  otherwise."],
null)),$APP.z(K5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null)))),$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient."],null)),$APP.z(jQb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.AY,mU,$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,mU)],null)],null)))),$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`."],null)),$APP.z(VAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))),$APP.P,"Returns the (vector) inner product of `v1` and `v2`; this is equivalent to the\n  sum of the pairwise product of each entry.\n\n    This is equivalent to [[vector-dot-product]] with every element of `v1`\n  transformed into its complex conjugate.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]]."],
null)),$APP.z(qW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qv],null))),$APP.P,"Returns true if the supplied orientation lives in the set of allowed\n  orientations, false otherwise."],null)),$APP.z(dIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)"],null)),$APP.z(hmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a new structure with the same orientation as the first element of `s`,\n  filled with elements of the same orientation as `s`.\n\n  Each element is generating by taking the first element of each entry in `s`,\n  the the second, etc... In that sense this is similar to a traditional matrix\n  transpose.\n\n  A comment from `scmutils` states:\n\n  'used only in symmetrize-Christoffel in\n  src/calculus/covariant-derivative.scm.'"],null)),$APP.z(LK,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oS],null))),$APP.P,"Given an access chain (a sequence of indices), return a function that accepts a\n  structure and returns the element at the specified access chain.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(oS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oS],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(TAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Sv,$APP.fx],null))),$APP.P,"Returns a structure containing `xs` with the same orientation as `s`."],null)),$APP.z(Tib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Vx,$APP.wY,mU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,mU)],null)],null)))),$APP.P,"Generates a structure of the specified `orientation` and dimension `size`\n  populated by symbolic entries, each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  (\x3d (literal 'x 3 ::s/up)\n     (up 'x0 'x1 'x2))\n\n  See [[literal-up]] and [[literal-down]] for constructors with baked in\n  orientations."],
null)),$APP.z(anb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SY,$APP.sv],null),new $APP.H(null,3,5,$APP.I,[$E,SY,$APP.sv],null))),$APP.P,"Given:\n\n  - a sequence of `values`\n  - a model `struct`\n\n  Returns a new structure generated by unpacking `values` into a structure with\n  the same shape as `struct`.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[SY,$APP.sv],null),new $APP.H(null,3,
5,$APP.I,[$E,SY,$APP.sv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[SY,$APP.sv],null),new $APP.H(null,3,5,$APP.I,[$E,SY,$APP.sv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Tab,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given an `up` or `down` structure containing structures of the same\n  orientation and size (a 2 tensor), returns a dictionary with keys:\n\n  ```clj\n  {:outer-orientation \x3c::up or ::down\x3e\n   :inner-orientation \x3c::up or ::down\x3e\n   :outer-size \x3cint\x3e\n   :inner-size \x3cint\x3e}\n\n  If `s` is _not_ a valid tensor, returns nil.\n  ```"],
null)),$APP.z(jvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Return a structure of the same shape as `s` whose elements are access chains\n  corresponding to position of each element (i.e., the sequence of indices\n  needed to address that element via [[get-in]]).\n\n  Each access chain has the sequence of orientations (`::s/up`, `::s/down`)\n  associated with each step attached to it as metadata, under an `:orientations`\n  key. Use this if the orientation of the indices matters."],
null)),$APP.z($0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))),$APP.P,"Returns the (vector) dot product of `v1` and `v2`; this is equivalent to the sum\n  of the pairwise product of each entry.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]]."],null)),$APP.z(Lcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))),$APP.P,"Construct an up (contravariant) tuple from the supplied sequence. For a\n  variadic version, see [[up]]."],
null)),$APP.z(gwb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null))),$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Kv,AV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null)),$APP.zx,
$APP.M(null)],null)],null)),$APP.z(Imb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.Sv],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.HT,$APP.Sv],null))),$APP.P,"Returns the result of accumulating all non-structural entries in `s` using the\n  supplied fold function `f` into the optional accumulator `init` (defaults\n  to `(f)`).\n\n  `f` must be a 2-argument fn of type `(accumulator, [x chain orientations]) \x3d\x3e\n  accumulator` responsible for merging some value `x` into the ongoing\n  accumulation. The second argument is a 3-vector containing\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  `f` should return a new instance of the accumulator.\n\n  Additional arities allow you to supply\n\n  - `init`, the initial (empty) accumulator (defaults to `(f)`)\n  - `present`, a function that will be applied to the final, aggregated\n    result (defaults to `f`)\n\n  For example:\n\n  ```clojure\n  (fold-chain\n    (fn ([] [])\n     ([acc] acc)\n     ([acc [s chain orientations]]\n      (conj acc {:s s\n                 :chain chain\n                 :orientations orientations})))\n    (s/down (s/up 1 2) (s/up 3 4)))\n\n  [{:s 1, :chain [0 0], :orientations [::s/down ::s/up]}\n   {:s 2, :chain [0 1], :orientations [::s/down ::s/up]}\n   {:s 3, :chain [1 0], :orientations [::s/down ::s/up]}\n   {:s 4, :chain [1 1], :orientations [::s/down ::s/up]}]\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.Sv],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.HT,$APP.Sv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.Sv],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.HT,$APP.Sv],null)),$APP.zx,$APP.M(null,null,null)],
null)],null)),$APP.z(hGb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(wP,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))),$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.fx)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z($APP.VX,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a structure with the same shape as `s`, with all orientations\n  inverted."],null)),$APP.z(dyb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,22,[$S,"null",LT,"null",SV,"null",kU,"null",SW,"null",oU,"null",hU,"null",WE,"null",$Lb,"null",xX,"null",SS,"null",rS,"null",lS,"null",LY,"null",gV,"null",uX,"null",uY,"null",nT,"null",RW,"null",jW,"null",RV,"null",tY,"null"],null),null),$APP.lw,
ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[mU,$APP.Tv,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,17,[$S,"null",LT,"null",SV,"null",kU,"null",SW,"null",oU,"null",xX,"null",SS,"null",rS,"null",lS,"null",gV,"null",uX,"null",uY,"null",nT,"null",RW,"null",jW,"null",tY,"null"],null),null),$APP.P,"Positional factory function for emmy.structure/Structure."],null)),$APP.z(LCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms."],
null)),$APP.z(orb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))),$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x0 'x1 'x2))\n  ```"],null)),$APP.z(aDb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(PZb,new $APP.f(null,1,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null))],[new $APP.f(null,3,[$APP.R,Osb,$APP.X,TK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,LP,$APP.X,uL,$APP.h,new $APP.f(null,2,[$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,r8b,$APP.X,aL,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a down (covariant) tuple from the supplied sequence. For a\n  variadic version, see [[down]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,O8b,$APP.X,PZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is a `down` structure, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Agb,$APP.X,UK,$APP.h,new $APP.f(null,2,[$APP.P,"If `s` is sequential, returns its dimension, i.e., the total number of\n  non-sequential entries in the structure. Else, returns 1.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,OIb,$APP.X,rqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,pIb,$APP.X,t2,$APP.h,new $APP.f(null,
2,[$APP.P,"For a non-[[Structure]] `s`, the single-arity case acts as [[identity]]. For\n  a [[Structure]], returns an identical structure with its orientation\n  reversed (up becomes down, down becomes up).\n\n  NOTE that a vector is interpreted as an `up` structure, so:\n\n  (opposite [1 2 3])\n  ;;\x3d\x3e (down 1 2 3)\n\n  The two-arity case returns a new [[Structure]] of opposite orientation to `s`\n  with the contents of the sequence `xs`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],
null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,S9b,$APP.X,ZZa,$APP.h,new $APP.f(null,2,[$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,
new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,rqb,$APP.X,k2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null))],null)],null),new $APP.f(null,3,[$APP.R,QNb,$APP.X,XZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is an `up` or `down` structure containing all `up` or\n  `down` structures of internally-matching orientation and size, false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,bEb,$APP.X,c_a,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts\n\n  - some symbolic (or string) `name`\n  - a structure `s`\n\n  and returns a new structure of identical shape, with symbolic entries like\n  `'x0_1` that show their access chain with proper orientations for each step.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,IAb,$APP.X,WK,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,wyb,$APP.X,kL,$APP.h,new $APP.f(null,2,[$APP.P,"Return a structure with the same shape as s but with f applied to each\n  primitive (that is, not structural) component.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null))],null)],null),new $APP.f(null,3,[$APP.R,N_b,$APP.X,qqc,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,K4b,$APP.X,RK,$APP.h,new $APP.f(null,2,[$APP.P,"Return the structure `s` in unoriented vector form.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Thb,$APP.X,gL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))],null)],null),new $APP.f(null,3,[$APP.R,wob,$APP.X,lL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure of the same shape and orientation as `s`, generated by\n  substituting gensymmed symbols in for each entry.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,sgb,$APP.X,zP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,kzb,$APP.X,ZK,$APP.h,new $APP.f(null,2,[$APP.P,"Generate a structure with the supplied orientation, given some sequence `xs`",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[mU,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,Sbc,$APP.X,iL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new structure of equivalent shape to `s`, generated by applying `f`\n  to three arguments:\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  For example:\n\n  ```clojure\n  (dorun (map-chain println (s/down (s/up 1 2) (s/up 3 4))))\n\n  1 [0 0] [::s/down ::s/up]\n  2 [0 1] [::s/down ::s/up]\n  3 [1 0] [::s/down ::s/up]\n  4 [1 1] [::s/down ::s/up]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,J1b,$APP.X,nL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure compatible for multiplication with `s` down to 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Fkb,$APP.X,nL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,dub,$APP.X,MZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `1` if `i`\x3d\x3d `j`, `0` otherwise.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Ov,sU],null))],null)],null),new $APP.f(null,3,[$APP.R,$lb,$APP.X,RZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied structures have the same orientation, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.R,inb,$APP.X,YZa,$APP.h,new $APP.f(null,2,[$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,BUb,$APP.X,cL,$APP.h,new $APP.f(null,2,[$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`.",$APP.U,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.AY,mU,$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,
mU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,tdc,$APP.X,g_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the (vector) inner product of `v1` and `v2`; this is equivalent to the\n  sum of the pairwise product of each entry.\n\n    This is equivalent to [[vector-dot-product]] with every element of `v1`\n  transformed into its complex conjugate.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.LW,$APP.MW],null))],null)],null),new $APP.f(null,3,[$APP.R,BYb,$APP.X,QZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied orientation lives in the set of allowed\n  orientations, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qv],null))],null)],null),new $APP.f(null,3,[$APP.R,$6b,$APP.X,VK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,aec,$APP.X,d_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new structure with the same orientation as the first element of `s`,\n  filled with elements of the same orientation as `s`.\n\n  Each element is generating by taking the first element of each entry in `s`,\n  the the second, etc... In that sense this is similar to a traditional matrix\n  transpose.\n\n  A comment from `scmutils` states:\n\n  'used only in symmetrize-Christoffel in\n  src/calculus/covariant-derivative.scm.'",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Wbb,$APP.X,rP,$APP.h,new $APP.f(null,2,[$APP.P,"Given an access chain (a sequence of indices), return a function that accepts a\n  structure and returns the element at the specified access chain.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oS],null))],null)],null),new $APP.f(null,3,[$APP.R,zrb,$APP.X,bL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure containing `xs` with the same orientation as `s`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,aWb,$APP.X,eL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a structure of the specified `orientation` and dimension `size`\n  populated by symbolic entries, each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  (\x3d (literal 'x 3 ::s/up)\n     (up 'x0 'x1 'x2))\n\n  See [[literal-up]] and [[literal-down]] for constructors with baked in\n  orientations.",$APP.U,$APP.M($APP.z(new $APP.H(null,
3,5,$APP.I,[$APP.Vx,$APP.wY,mU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,mU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Cfb,$APP.X,FN,$APP.h,new $APP.f(null,2,[$APP.P,"Given:\n\n  - a sequence of `values`\n  - a model `struct`\n\n  Returns a new structure generated by unpacking `values` into a structure with\n  the same shape as `struct`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[SY,$APP.sv],null),new $APP.H(null,3,5,$APP.I,[$E,SY,$APP.sv],null))],null)],
null),new $APP.f(null,3,[$APP.R,Jvb,$APP.X,YK,$APP.h,new $APP.f(null,2,[$APP.P,"Given an `up` or `down` structure containing structures of the same\n  orientation and size (a 2 tensor), returns a dictionary with keys:\n\n  ```clj\n  {:outer-orientation \x3c::up or ::down\x3e\n   :inner-orientation \x3c::up or ::down\x3e\n   :outer-size \x3cint\x3e\n   :inner-size \x3cint\x3e}\n\n  If `s` is _not_ a valid tensor, returns nil.\n  ```",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],
null),new $APP.f(null,3,[$APP.R,oPb,$APP.X,jL,$APP.h,new $APP.f(null,2,[$APP.P,"Return a structure of the same shape as `s` whose elements are access chains\n  corresponding to position of each element (i.e., the sequence of indices\n  needed to address that element via [[get-in]]).\n\n  Each access chain has the sequence of orientations (`::s/up`, `::s/down`)\n  associated with each step attached to it as metadata, under an `:orientations`\n  key. Use this if the orientation of the indices matters.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,dJb,$APP.X,pL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the (vector) dot product of `v1` and `v2`; this is equivalent to the sum\n  of the pairwise product of each entry.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))],null)],null),new $APP.f(null,3,[$APP.R,uAb,$APP.X,$K,$APP.h,
new $APP.f(null,2,[$APP.P,"Construct an up (contravariant) tuple from the supplied sequence. For a\n  variadic version, see [[up]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,ZDb,$APP.X,oP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,
$APP.Lh,AV],null))],null)],null),new $APP.f(null,3,[$APP.R,UEb,$APP.X,YN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of accumulating all non-structural entries in `s` using the\n  supplied fold function `f` into the optional accumulator `init` (defaults\n  to `(f)`).\n\n  `f` must be a 2-argument fn of type `(accumulator, [x chain orientations]) \x3d\x3e\n  accumulator` responsible for merging some value `x` into the ongoing\n  accumulation. The second argument is a 3-vector containing\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  `f` should return a new instance of the accumulator.\n\n  Additional arities allow you to supply\n\n  - `init`, the initial (empty) accumulator (defaults to `(f)`)\n  - `present`, a function that will be applied to the final, aggregated\n    result (defaults to `f`)\n\n  For example:\n\n  ```clojure\n  (fold-chain\n    (fn ([] [])\n     ([acc] acc)\n     ([acc [s chain orientations]]\n      (conj acc {:s s\n                 :chain chain\n                 :orientations orientations})))\n    (s/down (s/up 1 2) (s/up 3 4)))\n\n  [{:s 1, :chain [0 0], :orientations [::s/down ::s/up]}\n   {:s 2, :chain [0 1], :orientations [::s/down ::s/up]}\n   {:s 3, :chain [1 0], :orientations [::s/down ::s/up]}\n   {:s 4, :chain [1 1], :orientations [::s/down ::s/up]}]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.Sv],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.HT,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,evb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,MP,$APP.X,QN,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))],null)],
null),new $APP.f(null,3,[$APP.R,XDb,$APP.X,mL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure with the same shape as `s`, with all orientations\n  inverted.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,iXb,$APP.X,QK,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.structure/Structure.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[mU,$APP.Tv,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,ymb,$APP.X,oL,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,I6b,$APP.X,fL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x0 'x1 'x2))\n  ```",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))],null)],null),new $APP.f(null,3,[$APP.R,Kdc,$APP.X,sqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,uWb,$APP.X,tqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null)]),$APP.Zo(Ocb)),$APP.ap(new $APP.f(null,2,[$APP.z(uFb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],
null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,bW],null))),$APP.P,"Find the minimum of the function `f: R -\x3e R` in the interval `[a, b]`.\n\n  If an `observe` function is supplied, it will be invoked with the iteration\n  count and the values of x and f(x) at each search step.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,bW],
null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,bW],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,vNb,$APP.X,Y3,$APP.h,new $APP.f(null,2,[$APP.P,"Find the minimum of the function `f: R -\x3e R` in the interval `[a, b]`.\n\n  If an `observe` function is supplied, it will be invoked with the iteration\n  count and the values of x and f(x) at each search step.",$APP.U,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,bW],null))],null)],null),$APP.z(T3b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Hy,$APP.NW,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[cY],null),$APP.ck,$APP.Lx],null)],null))),$APP.P,"Entrypoint for multidimensional minimization routines.\n\n  See [[emmy.numerical.multimin.nelder-mead/nelder-mead]] for the only\n  supported option.",$APP.hy,new $APP.f(null,
6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Hy,$APP.NW,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[cY],null),$APP.ck,$APP.Lx],null))],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Hy,$APP.NW,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[cY],null),$APP.ck,$APP.Lx],null)],null)),$APP.zx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.R,CMb,$APP.X,Z3,$APP.h,new $APP.f(null,2,[$APP.P,"Entrypoint for multidimensional minimization routines.\n\n  See [[emmy.numerical.multimin.nelder-mead/nelder-mead]] for the only\n  supported option.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Hy,$APP.NW,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[cY],null),$APP.ck,$APP.Lx],null)],null))],null)],null)],null),$APP.Zo(ISb)),$APP.ap($APP.fg([$APP.z(MRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[jV],null)))],null)),$APP.z(Qob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null)))],null)),$APP.z(byb,new $APP.f(null,
1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],null)),$APP.z(uXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],null)),$APP.z(W1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],null)),c_b,$APP.z(vgb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$Db],null)))],null)),$APP.z(EUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(Bwb,$APP.Iv)],null)],null)))),$APP.P,"Given an antisymmetric matrix `a` of dimension 3, returns a column vector of\n  its positive components."],null)),$APP.z(Zjb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Hv,vU,RY],null)],null)))],null)),$wb,$APP.z(wAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],
null)),$APP.z(gqb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[jV],null)))],null)),$APP.z(Sub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Hv,new $APP.H(null,3,5,$APP.I,[SX,$APP.Hv,WT],null),new $APP.H(null,3,5,$APP.I,[IWb,jlb,ynb],null)],null)],null))),$APP.P,"Although this implementation appears to summarize `(M-\x3eomega-body r/Euler-\x3eM)`,\n  it is actually essential to prevent intermediate expression explosion."],
null)),$APP.z(ztb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Hv,vU,RY],null)],null)))],null)),Rjb,$APP.z(Xxb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$Db],null)))],null)),$APP.z(Ilb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],null)),$APP.z(Wpb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],null)),$APP.z(d9b,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],null)),$APP.z(VIb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],null)),$APP.z(vib,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null)))],null)),$APP.z(TUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[jV],null)))],null)),$APP.z(OSb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[jV],null)))],null)),$APP.z(Zpb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null)))],null))],[new $APP.f(null,3,[$APP.R,cjb,$APP.X,function(a){return TQ(M$a(a))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[jV],null))],null)],null),new $APP.f(null,3,[$APP.R,T9b,$APP.X,function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return CN.C($APP.y([new $APP.H(null,3,5,$APP.I,[0,RF.j(a),c],null),new $APP.H(null,3,
5,$APP.I,[a,0,RF.j(b)],null),new $APP.H(null,3,5,$APP.I,[RF.j(c),b,0],null)]))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,M1b,$APP.X,function(a,b,c){var d=U$a(a,b,c);return function(g){$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=d(g);l=K$a(kR.j(l));return iG.A(g,eR.j(l))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],
null),new $APP.f(null,3,[$APP.R,Iqb,$APP.X,S$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],null),new $APP.f(null,3,[$APP.R,UMb,$APP.X,P$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],null),new $APP.f(null,3,[$APP.R,WXb,$APP.X,T$a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,F5b,$APP.X,Q$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$Db],null))],null)],null),new $APP.f(null,3,
[$APP.R,RJb,$APP.X,L$a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an antisymmetric matrix `a` of dimension 3, returns a column vector of\n  its positive components.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(Bwb,$APP.Iv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,z6b,$APP.X,function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null),c=$APP.x.B(a,2,null);a=uN(b);c=Y1a(c);var d=QF.A(-2,BH.A(b,b));b=iG.A(d,$APP.Zl.A(iG.C(c,
zsc,$APP.y([a])),new $APP.H(null,2,5,$APP.I,[0,0],null)));var g=iG.A(d,$APP.Zl.A(iG.C(c,Asc,$APP.y([a])),new $APP.H(null,2,5,$APP.I,[0,0],null)));a=iG.A(d,$APP.Zl.A(iG.C(c,Bsc,$APP.y([a])),new $APP.H(null,2,5,$APP.I,[0,0],null)));return uL.C($APP.y([b,g,a]))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Hv,vU,RY],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,oQb,$APP.X,S$a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,tvb,$APP.X,function(a,
b,c){return $APP.PQ.j(AR.B?AR.B(a,b,c):AR.call(null,a,b,c))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],null),new $APP.f(null,3,[$APP.R,xec,$APP.X,function(a){return TQ(N$a(a))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[jV],null))],null)],null),new $APP.f(null,3,[$APP.R,$7b,$APP.X,R$a,$APP.h,new $APP.f(null,2,[$APP.P,"Although this implementation appears to summarize `(M-\x3eomega-body r/Euler-\x3eM)`,\n  it is actually essential to prevent intermediate expression explosion.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Hv,new $APP.H(null,3,5,$APP.I,[SX,$APP.Hv,WT],null),new $APP.H(null,3,5,$APP.I,[IWb,jlb,ynb],null)],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,vQb,$APP.X,function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);var c=QF.A(iG.A(2,b),BH.A(b,b));b=BH.A(c,iG.A(A4,a));var d=BH.A(c,iG.A(B4,a));a=BH.A(c,iG.A(C4,a));return uL.C($APP.y([b,d,a]))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Hv,vU,RY],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,VWb,$APP.X,AR,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ryb,$APP.X,function(a){return function(b){return iG.A(eR.j(nO(a.j?a.j(b):a.call(null,b))),Q$a(a)(b))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$Db],null))],null)],null),new $APP.f(null,3,[$APP.R,b9b,$APP.X,O$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],
null),new $APP.f(null,3,[$APP.R,vGb,$APP.X,U$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],null),new $APP.f(null,3,[$APP.R,LKb,$APP.X,T$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],null),new $APP.f(null,3,[$APP.R,w9b,$APP.X,function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);g=uN(g);var l=uN(d),n=OF.j($APP.Zl.A(iG.A(wN(g),g),new $APP.H(null,2,5,$APP.I,
[0,0],null)));d=iG.C(n,A4,$APP.y([l]));var p=iG.C(n,B4,$APP.y([l]));l=iG.C(n,C4,$APP.y([l]));g=iG.A(g,wN(g));return iG.A(2,kG.C(iG.A(a,$APP.Zl.A(iG.C(wN(d),g,$APP.y([d])),new $APP.H(null,2,5,$APP.I,[0,0],null))),iG.A(b,$APP.Zl.A(iG.C(wN(p),g,$APP.y([p])),new $APP.H(null,2,5,$APP.I,[0,0],null))),$APP.y([iG.A(c,$APP.Zl.A(iG.C(wN(l),g,$APP.y([l])),new $APP.H(null,2,5,$APP.I,[0,0],null)))])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],null),new $APP.f(null,
3,[$APP.R,O6b,$APP.X,AR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,yU,SR],null))],null)],null),new $APP.f(null,3,[$APP.R,hqb,$APP.X,M$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[jV],null))],null)],null),new $APP.f(null,3,[$APP.R,uLb,$APP.X,N$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[jV],null))],null)],null),new $APP.f(null,3,[$APP.R,Nob,$APP.X,function(a){return function(b,c,d){return function(g){return iG.A(P$a(b,c,
d)(g),eR.j(a))}}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))],null)],null)]),$APP.Zo(dSb)),$APP.ap($APP.fg([$APP.z(YZb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UV],null)))],null)),z0b,$APP.z(drb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],null)))],null)),$APP.z(v9b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))],null)),$APP.z(ewb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),$APP.P,"p. 334"],null)),$APP.z(RIb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null)))],null)),$APP.z(qEb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(Hlb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,IU],null)))],null)),$APP.z(DPb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,
5,$APP.I,[$APP.Or,IU],null)))],null)),$APP.z(oTb,new $APP.f(null,1,[$APP.gm,!0],null)),bMb,$APP.z(Rtb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null))),$APP.P,"A transformation of configuration coordinates F to a procedure implementing a\n  transformation of phase-space coordinates (p. 320)"],null)),$APP.z(dDb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null)))],null)),$APP.z(Mtb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Or,IU],null)))],null)),$APP.z(qkb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[BAb,CAb],null)))],null)),$APP.z(rUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[zU],null)))],null)),$APP.z(okb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[zU],null)))],null)),$APP.z(gib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SR,$APP.BU],null))),$APP.P,"p.324"],null)),$APP.z(lXb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SR,EU],null)))],null)),$APP.z(A5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,rU],null)))],null)),PCb,$APP.z(K9b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[uW,vW],null)))],null)),$APP.z(pwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null))),$APP.P,"p.327"],null)),$APP.z(vXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[SR,$APP.BU],null)))],null)),$APP.z(zJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Rv,vU,$APP.Pv],null))),$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q` and momentum tuple (or\n  scalar) `p`, returns a 'Hamiltonian state tuple', i.e., the state expected by a\n  Hamiltonian."],null)),$APP.z(Dhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[SR,$APP.BU,Jmb],null))),$APP.P,"p.324"],null)),$APP.z(Qlb,new $APP.f(null,
1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UU],null)))],null)),$APP.z(Vbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),$APP.P,"Symplectic test in terms of matrices"],null)),$APP.z(LZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),$APP.P,"p.326"],null)),$APP.z(q5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[s7b],null)))],null)),$APP.z(R9a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],null))),$APP.P,"the flow derivative generalizes the Lie derivative to allow for time dependent\n  H and F --- computes the 'time' derivative of F along the flow specified by H"],null)),$APP.z(UV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),$APP.P,"Returns function signature for a Hamiltonian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Hamiltonian literal functions."],
null)),$APP.z(zgb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EU],null)))],null)),$APP.z(mTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(Cob,$APP.Sv)],null)],null)))),$APP.P,"Given a hamiltonian state, returns a [[emmy.structure/up]] containing the\n  coordinate and momentum components. "],null)),$APP.z(Q6b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[AU,hyb],null)))],null)),$APP.z(AGb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[AIb,xTb],null)))],null)),Nyb,$APP.z(PGb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))],null)),$APP.z(LXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[uW,vW],null)))],null)),$APP.z(qDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[WU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,
2,5,$APP.I,[$APP.M(bY,WU),$APP.M($APP.Yv,$APP.M($APP.qv,WU),2)],null)],null)))),$APP.P,"Returns the momentum element of a local Hamiltonian state tuple (by convention,\n  the third element)."],null)),$APP.z(Lqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),$APP.P,"p. 334 (used, but not defined there)"],null)),$APP.z(SWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.BU,TR],null))),$APP.P,"The generalization of Lie-transform to include time dependence."],
null)),$APP.z(MCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))),$APP.P,"p. 334"],null)),NMb,$APP.z(rcc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),Ptb,$APP.z(hAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],null)))],null)),$APP.z(E0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null)))],null)),$APP.z(N5b,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Gu,$APP.M($APP.jv,$APP.uU))],null)],null)))),$APP.P,"f is a function of (x y continue fail), which calls continue with the values of\n  x' y' that follow x y in the mapping.\n\n  Returns a map of the same shape that iterates the iterated map n times before\n  invoking the continuation, or invokes the fail continuation if the inner map\n  fails."],null)),
k1b,$APP.z(XNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),$APP.P,"n \x3d\x3d degrees of freedom"],null)),$APP.z(Hnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Pv],null)))],null)),$APP.z(n_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[zU],null)))],null)),pob,$APP.z(F8b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.Sv],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,3,5,$APP.I,[$APP.M($APP.Zv,$APP.M(rQb,$APP.Or),1),$APP.M($APP.Hw,$APP.M(tmb,$APP.Or)),$APP.M($APP.Yv,$APP.M(tmb,$APP.Or),2)],null)],null))))],null)),$APP.z(Cob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if the supplied state is\n\n  - of type [[emmy.structure/up]]\n\n  - contains three elements of `time`, `coordinate` and `momentum` of either of\n    the following type shapes:\n\n  ```\n  (up \x3cnumber\x3e \x3cnumber\x3e \x3cnumber\x3e)\n  (up \x3cnumber\x3e (up \x3cnumber\x3e*) (down \x3cnumber\x3e*))\n  ```\n\n  If structural, the dimension of the coordinate and momentum tuples must match."],
null)),$APP.z(Gbb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(dmb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EU],null)))],null)),$APP.z(Hrb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SR,$APP.BU],null))),$APP.P,"Tests that K yields a canonical transformation if the C is symplectic. (The\n  qp-canonical? code is really a symplectic test without factoring out the\n  Hamiltonian.)"],
null)),$APP.z(pdc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],null)))],null)),$APP.z(T9a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.BU,$APP.Rv],null))),$APP.P,"p. 428, the Lie transform is just the time-advance operator using the Lie\n  derivative (see Hamiltonian.scm)."],null)),$APP.z(P0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.tU],null)))],null)),$APP.z(igb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `s` is compatible for contraction with a proper H-state, false\n  otherwise."],null))],[new $APP.f(null,3,[$APP.R,qnb,$APP.X,M9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UV],null))],null)],null),new $APP.f(null,3,[$APP.R,TSb,$APP.X,psc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,gub,$APP.X,$APP.YQ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],
null))],null)],null),new $APP.f(null,3,[$APP.R,hzb,$APP.X,function(a){return function(b){var c=KQ(b),d=$APP.LQ(b);var g=QQ.j?QQ.j(2):QQ.call(null,2);g=g.j?g.j(a):g.call(null,a);b=g.j?g.j(b):g.call(null,b);return WQ(c,d,b)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.R,GUb,$APP.X,l$a,$APP.h,new $APP.f(null,2,[$APP.P,"p. 334",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))],null)],null),new $APP.f(null,3,[$APP.R,U4b,
$APP.X,function(a){return function(b){return RF.j(iG.A(cR.A(XQ(b),function(){var c=QQ.j?QQ.j(1):QQ.call(null,1);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}()),function(){var c=QQ.j?QQ.j(0):QQ.call(null,0);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}()))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null))],null)],null),new $APP.f(null,3,[$APP.R,$dc,$APP.X,function(a){return function(b){return a$a(f$a(b),a)}},$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,blb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);c=QF.A(lG.j(c),iG.A(2,a));d=hG.j(d);d=b.j?b.j(d):b.call(null,d);return L9a(c,d)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,IU],null))],null)],null),new $APP.f(null,3,[$APP.R,Wxb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,
2,null);return L9a(QF.A(lG.j(c),iG.A(2,a)),$APP.Je.A(b,d))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,IU],null))],null)],null),new $APP.f(null,3,[$APP.R,lmb,$APP.X,!1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,wEb,$APP.X,XQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,E$b,$APP.X,X9a,$APP.h,new $APP.f(null,2,[$APP.P,"A transformation of configuration coordinates F to a procedure implementing a\n  transformation of phase-space coordinates (p. 320)",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[AU],null))],null)],null),new $APP.f(null,3,[$APP.R,dfb,$APP.X,function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null),g=$APP.x.B(b,2,null);b=QF.A(kG.A(iG.A(a,lG.j(d)),QF.A(lG.j(g),a)),2);d=rG.A(QF.A(d,jG.j(QF.A(iG.A(2,b),a))),QF.A(g,jG.j(iG.C(2,b,$APP.y([a])))));return uL.C($APP.y([c,d,b]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null))],null)],null),new $APP.f(null,3,[$APP.R,TOb,$APP.X,function(a,b){return function(c){$APP.x.B(c,
0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(d,0,null);$APP.x.B(d,1,null);d=$APP.x.B(c,2,null);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return L9a(QF.A(kG.A(lG.j(c),lG.j(QF.A(d,g))),iG.A(2,a)),b.j?b.j(g):b.call(null,g))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,IU],null))],null)],null),new $APP.f(null,3,[$APP.R,Tvb,$APP.X,function(a,b){return RF.A(iG.A(XQ.j?XQ.j(b):XQ.call(null,b),$APP.LQ.j?$APP.LQ.j(a):$APP.LQ.call(null,a)),iG.A(XQ.j?XQ.j(a):XQ.call(null,a),$APP.LQ.j?
$APP.LQ.j(b):$APP.LQ.call(null,b)))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BAb,CAb],null))],null)],null),new $APP.f(null,3,[$APP.R,nib,$APP.X,c$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[zU],null))],null)],null),new $APP.f(null,3,[$APP.R,xCb,$APP.X,b$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[zU],null))],null)],null),new $APP.f(null,3,[$APP.R,nnb,$APP.X,Z9a,$APP.h,new $APP.f(null,2,[$APP.P,"p.324",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[SR,$APP.BU],null))],null)],null),new $APP.f(null,3,[$APP.R,N2b,$APP.X,function(a,b){return RF.A(WH.C($APP.y([$9a,a])),iG.A(SO.j?SO.j(a):SO.call(null,a),kG.A($9a,N9a(b))))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[SR,EU],null))],null)],null),new $APP.f(null,3,[$APP.R,$Rb,$APP.X,$Q,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,rU],null))],null)],null),new $APP.f(null,3,[$APP.R,wac,$APP.X,x4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,
Meb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null);d=QF.A(kG.A(iG.A(a,c),iG.A(b,g)),kG.A(a,b));c=RF.A(g,c);return uL.A?uL.A(d,c):uL.call(null,d,c)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[uW,vW],null))],null)],null),new $APP.f(null,3,[$APP.R,Ghb,$APP.X,e$a,$APP.h,new $APP.f(null,2,[$APP.P,"p.327",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null))],null)],null),new $APP.f(null,3,[$APP.R,
u2b,$APP.X,function(a,b){return RF.A(WH.C($APP.y([N9a(b),a])),iG.A(SO.j?SO.j(a):SO.call(null,a),N9a(WH.C($APP.y([b,a])))))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[SR,$APP.BU],null))],null)],null),new $APP.f(null,3,[$APP.R,Btb,$APP.X,WQ,$APP.h,new $APP.f(null,2,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q` and momentum tuple (or\n  scalar) `p`, returns a 'Hamiltonian state tuple', i.e., the state expected by a\n  Hamiltonian.",$APP.U,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.Rv,vU,$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,Xdb,$APP.X,Y9a,$APP.h,new $APP.f(null,2,[$APP.P,"p.324",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[SR,$APP.BU,Jmb],null))],null)],null),new $APP.f(null,3,[$APP.R,P6b,$APP.X,function(a){return WQ($APP.Nj.j($APP.Rv),fL($APP.Nj.j($APP.Vv),a),gL($APP.Nj.j($APP.Pv),a))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UU],null))],null)],null),new $APP.f(null,3,[$APP.R,mPb,$APP.X,function(a){return function(b){var c=
g$a(g9a(b));b=b4a(a)(b);return RF.A(c,iG.C(b,c,$APP.y([eR.j(b)])))}},$APP.h,new $APP.f(null,2,[$APP.P,"Symplectic test in terms of matrices",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))],null)],null),new $APP.f(null,3,[$APP.R,kyb,$APP.X,d$a,$APP.h,new $APP.f(null,2,[$APP.P,"p.326",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))],null)],null),new $APP.f(null,3,[$APP.R,Asb,$APP.X,dR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[s7b],null))],null)],null),new $APP.f(null,
3,[$APP.R,f8b,$APP.X,S9a,$APP.h,new $APP.f(null,2,[$APP.P,"the flow derivative generalizes the Lie derivative to allow for time dependent\n  H and F --- computes the 'time' derivative of F along the flow specified by H",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],null))],null)],null),new $APP.f(null,3,[$APP.R,g9b,$APP.X,I9a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns function signature for a Hamiltonian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Hamiltonian literal functions.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,uVb,$APP.X,V9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[EU],null))],null)],null),new $APP.f(null,3,[$APP.R,zTb,$APP.X,function(a){return uL.C($APP.y([$APP.LQ(a),XQ(a)]))},$APP.h,new $APP.f(null,2,[$APP.P,"Given a hamiltonian state, returns a [[emmy.structure/up]] containing the\n  coordinate and momentum components. ",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Sv],
null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(Cob,$APP.Sv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Vpb,$APP.X,a$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[AU,hyb],null))],null)],null),new $APP.f(null,3,[$APP.R,HTb,$APP.X,L9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[AIb,xTb],null))],null)],null),new $APP.f(null,3,[$APP.R,I4b,$APP.X,XQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,n0b,$APP.X,function(a){return function(b){var c=
function(){var l=oL(b),n=SO.j?SO.j(dR):SO.call(null,dR);return n.j?n.j(l):n.call(null,l)}(),d=function(){var l=SO.j?SO.j(a):SO.call(null,a);return l.j?l.j(b):l.call(null,b)}(),g=qP.A(d,b);return RF.A(c,iG.C(d,c,$APP.y([g])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))],null)],null),new $APP.f(null,3,[$APP.R,xNb,$APP.X,function(a,b){return function(c){var d=$APP.x.B(c,0,null),g=$APP.x.B(c,1,null),l=$APP.x.B(g,0,null),n=$APP.x.B(g,1,null);c=$APP.x.B(c,2,null);var p=
$APP.x.B(c,0,null),v=$APP.x.B(c,1,null);return uL.C($APP.y([d,function(){var t=QF.A(kG.A(iG.A(a,l),iG.A(b,n)),kG.A(a,b)),A=RF.A(n,l);return uL.A?uL.A(t,A):uL.call(null,t,A)}(),function(){var t=kG.A(p,v),A=QF.A(RF.A(iG.A(a,v),iG.A(b,p)),kG.A(a,b));return QN.A?QN.A(t,A):QN.call(null,t,A)}()]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[uW,vW],null))],null)],null),new $APP.f(null,3,[$APP.R,NOb,$APP.X,XQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the momentum element of a local Hamiltonian state tuple (by convention,\n  the third element).",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[WU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(bY,WU),$APP.M($APP.Yv,$APP.M($APP.qv,WU),2)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,sob,$APP.X,h$a,$APP.h,new $APP.f(null,2,[$APP.P,"p. 334 (used, but not defined there)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,fbb,$APP.X,function(a,b){return JK.A(oG.j(iG.A(b,S9a(a))),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
SWb,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))))},$APP.h,new $APP.f(null,2,[$APP.P,"The generalization of Lie-transform to include time dependence.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.BU,TR],null))],null)],null),new $APP.f(null,3,[$APP.R,s$b,$APP.X,j$a,$APP.h,new $APP.f(null,2,[$APP.P,"p. 334",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))],null)],null),new $APP.f(null,3,[$APP.R,a$b,$APP.X,osc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,
Svb,$APP.X,$9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,H$b,$APP.X,X9a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,cib,$APP.X,N9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],null))],null)],null),new $APP.f(null,3,[$APP.R,Vub,$APP.X,k$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Arb,$APP.X,W9a,$APP.h,
new $APP.f(null,2,[$APP.P,"f is a function of (x y continue fail), which calls continue with the values of\n  x' y' that follow x y in the mapping.\n\n  Returns a map of the same shape that iterates the iterated map n times before\n  invoking the continuation, or invokes the fail continuation if the inner map\n  fails.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Gu,$APP.M($APP.jv,$APP.uU))],null)],null)))],
null)],null),new $APP.f(null,3,[$APP.R,Crb,$APP.X,$APP.YQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,KLb,$APP.X,g$a,$APP.h,new $APP.f(null,2,[$APP.P,"n \x3d\x3d degrees of freedom",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,BCb,$APP.X,K9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,Ssb,$APP.X,f$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[zU],null))],null)],null),new $APP.f(null,3,[$APP.R,Ydb,$APP.X,XQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,n$b,$APP.X,function(a,b){return GN(oL(b),a,1)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.Sv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,3,5,$APP.I,[$APP.M($APP.Zv,$APP.M(rQb,$APP.Or),1),$APP.M($APP.Hw,$APP.M(tmb,$APP.Or)),$APP.M($APP.Yv,$APP.M(tmb,$APP.Or),2)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,ucb,$APP.X,J9a,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if the supplied state is\n\n  - of type [[emmy.structure/up]]\n\n  - contains three elements of `time`, `coordinate` and `momentum` of either of\n    the following type shapes:\n\n  ```\n  (up \x3cnumber\x3e \x3cnumber\x3e \x3cnumber\x3e)\n  (up \x3cnumber\x3e (up \x3cnumber\x3e*) (down \x3cnumber\x3e*))\n  ```\n\n  If structural, the dimension of the coordinate and momentum tuples must match.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],
null),new $APP.f(null,3,[$APP.R,zec,$APP.X,function(a){return RO.B(oL(a),a,1)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,xub,$APP.X,function(a){var b=USa(JF);return function(c,d,g){c=b(c-d);d=b(d-a*Math.sin(c));return g.A?g.A(c,d):g.call(null,c,d)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[EU],null))],null)],null),new $APP.f(null,3,[$APP.R,Dec,$APP.X,function(a,b){return function(c){return RF.A(dR(function(){var d=
a.j?a.j(c):a.call(null,c),g=SO.j?SO.j(b):SO.call(null,b);return g.j?g.j(d):g.call(null,d)}()),iG.A(function(){var d=SO.j?SO.j(a):SO.call(null,a);return d.j?d.j(c):d.call(null,c)}(),dR(function(){var d=WH.C($APP.y([b,a]));d=SO.j?SO.j(d):SO.call(null,d);return d.j?d.j(c):d.call(null,c)}())))}},$APP.h,new $APP.f(null,2,[$APP.P,"Tests that K yields a canonical transformation if the C is symplectic. (The\n  qp-canonical? code is really a symplectic test without factoring out the\n  Hamiltonian.)",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[SR,$APP.BU],null))],null)],null),new $APP.f(null,3,[$APP.R,lQb,$APP.X,function(a){return function(b){var c=KQ(b),d=$APP.LQ(b);var g=QQ.j?QQ.j(2):QQ.call(null,2);g=g.j?g.j(a):g.call(null,a);b=g.j?g.j(b):g.call(null,b);return OQ(c,d,b)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],null))],null)],null),new $APP.f(null,3,[$APP.R,Qqb,$APP.X,U9a,$APP.h,new $APP.f(null,2,[$APP.P,"p. 428, the Lie transform is just the time-advance operator using the Lie\n  derivative (see Hamiltonian.scm).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.BU,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.R,vob,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);return kG.A(QF.A(lG.j(c),iG.A(2,a)),iG.C(QF.A(1,2),b,$APP.y([lG.j(d)])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,SUb,$APP.X,function(a){return J9a(mL(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is compatible for contraction with a proper H-state, false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null)]),$APP.Zo(Emb)),$APP.ap($APP.fg([$APP.z(B5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null))),$APP.P,"Takes a system derivative `R` and returns a operator that takes a function `F`\n  of coordinatized state and performs the operation described below, from\n  ODE.scm in scmutils:\n\n  Let `(sigma t)` be the state of a system at time `t`. Let the\n  (first-order) system of differential equations governing the evolution of\n  this state be:\n\n  ```clojure\n  ((D sigma) t) \x3d (R (sigma t))\n  ```\n\n  ```clojure\n  (D sigma) \x3d (compose R sigma)\n  ```\n\n  i.e. `R` is a system derivative.\n\n  Let `F` be any function of state, then a differential equation for the\n  evolution of `F`, as it is dragged along the integral curve sigma is:\n\n  ```clojure\n  (D (compose F sigma)) \x3d (* (compose (D F) sigma) (D sigma))\n  \x3d (compose (* (D F) R) sigma)\n  ```\n\n  Let's call this operation `Lie-D` (the Lie derivative for coordinates)."],
null)),$APP.z(HOb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Dx,TU],null)))],null)),$APP.z(yvb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[XT],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(GT,XT)],null)],null))))],null)),$APP.z(pvb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))],null)),$APP.z(npb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,
$APP.I,[DX,TU],null))),$APP.P,"Returns a data structure representing [Christoffel symbols of the second\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_second_kind_(symmetric_definition))."],null)),$APP.z(Nnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))],null)),$APP.z(B5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Kyb],null)))],null)),$APP.z(Ewb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[Dcc,Odb],null)))],null)),$APP.z(lBb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null)))],null)),$APP.z(KIb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[rY,pX,sW],null)))],null)),$APP.z(iSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,
1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(D5a,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ON],null)))],null)),$APP.z(GT,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(Mbc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[NV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(VW,NV)],null)],null))))],null)),$APP.z(Pob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null)))],null)),$APP.z(Ygb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null)))],null)),$APP.z(X1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[rY,pX,sW],null)))],null)),$APP.z(VW,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(aNb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))],null)),$APP.z(LVb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))],null))],[new $APP.f(null,3,[$APP.R,Sjb,$APP.X,C5a,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a system derivative `R` and returns a operator that takes a function `F`\n  of coordinatized state and performs the operation described below, from\n  ODE.scm in scmutils:\n\n  Let `(sigma t)` be the state of a system at time `t`. Let the\n  (first-order) system of differential equations governing the evolution of\n  this state be:\n\n  ```clojure\n  ((D sigma) t) \x3d (R (sigma t))\n  ```\n\n  ```clojure\n  (D sigma) \x3d (compose R sigma)\n  ```\n\n  i.e. `R` is a system derivative.\n\n  Let `F` be any function of state, then a differential equation for the\n  evolution of `F`, as it is dragged along the integral curve sigma is:\n\n  ```clojure\n  (D (compose F sigma)) \x3d (* (compose (D F) sigma) (D sigma))\n  \x3d (compose (* (D F) R) sigma)\n  ```\n\n  Let's call this operation `Lie-D` (the Lie derivative for coordinates).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null))],null)],null),new $APP.f(null,3,[$APP.R,Hhb,$APP.X,EP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Dx,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,LJb,$APP.X,N5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[XT],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(GT,XT)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,o_b,$APP.X,K5a,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))],null)],null),new $APP.f(null,3,[$APP.R,uac,$APP.X,HP,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a data structure representing [Christoffel symbols of the second\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_second_kind_(symmetric_definition)).",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[DX,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,XXb,$APP.X,L5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[SR],null))],null)],null),new $APP.f(null,3,[$APP.R,cEb,$APP.X,O5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Kyb],null))],null)],null),new $APP.f(null,3,[$APP.R,H1b,$APP.X,R5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[Dcc,Odb],null))],null)],null),new $APP.f(null,3,[$APP.R,z4b,$APP.X,P5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null))],null)],null),new $APP.f(null,3,[$APP.R,Qib,$APP.X,Z5a,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[rY,pX,sW],null))],null)],null),new $APP.f(null,3,[$APP.R,WFb,$APP.X,KP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null))],null)],null),new $APP.f(null,3,[$APP.R,Fac,$APP.X,E5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[ON],null))],null)],null),new $APP.f(null,3,[$APP.R,Mdc,$APP.X,J5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null))],null)],null),new $APP.f(null,3,[$APP.R,bec,$APP.X,M5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(VW,NV)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Vdc,$APP.X,Y5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null))],null)],null),new $APP.f(null,3,[$APP.R,Pcb,$APP.X,S5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],
null))],null)],null),new $APP.f(null,3,[$APP.R,OEb,$APP.X,$5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[rY,pX,sW],null))],null)],null),new $APP.f(null,3,[$APP.R,OAb,$APP.X,G5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,EXb,$APP.X,GP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))],null)],null),new $APP.f(null,3,[$APP.R,xOb,$APP.X,FP,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))],null)],null)]),$APP.Zo(s3b)),$APP.ap(new $APP.f(null,7,[$APP.z(h8b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,BY],null),new $APP.H(null,3,5,$APP.I,[$APP.Pv,BY,$R],null))),$APP.P,"Given a polynomial `p`, and a sequence of variables `vars` (one for each\n  indeterminate in `p`), returns a symbolic expression representing the product\n  of all factors of `p`.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Pv,BY],null),new $APP.H(null,3,5,$APP.I,[$APP.Pv,BY,$R],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,BY],null),new $APP.H(null,3,5,$APP.I,[$APP.Pv,BY,$R],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,pPb,$APP.X,G2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a polynomial `p`, and a sequence of variables `vars` (one for each\n  indeterminate in `p`), returns a symbolic expression representing the product\n  of all factors of `p`.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,BY],null),new $APP.H(null,3,5,$APP.I,[$APP.Pv,BY,$R],null))],null)],null),$APP.z(HRb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,$R],null))),$APP.P,"Given some symbolic expression containing only polynomial operations, returns a\n  factored version of the expression with basic simplifications applied.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.\n\n  NOTE prefer [[factor]], as [[factor]] can handle expressions with\n  non-polynomial operations. The trigonometric functions, for example.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,$R],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,$R],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,AMb,$APP.X,H2,$APP.h,new $APP.f(null,2,[$APP.P,"Given some symbolic expression containing only polynomial operations, returns a\n  factored version of the expression with basic simplifications applied.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.\n\n  NOTE prefer [[factor]], as [[factor]] can handle expressions with\n  non-polynomial operations. The trigonometric functions, for example.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,$R],null))],null)],null),$APP.z(r6b,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[lS,"null",XX,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[NBb,bwb],null))),$APP.P,"Positional factory function for emmy.polynomial.factor/t_emmy$polynomial$factor49020."],null)),new $APP.f(null,
3,[$APP.R,uob,$APP.X,Eqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.polynomial.factor/t_emmy$polynomial$factor49020.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[NBb,bwb],null))],null)],null),$APP.z(kJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Given a [[Polynomial]] `p`, returns a sequence of factors of in order of\n  increasing power.\n\n  The first element is a constant factor, the next is a factor with power 1, and\n  so on."],
null)),new $APP.f(null,3,[$APP.R,FQb,$APP.X,u0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a [[Polynomial]] `p`, returns a sequence of factors of in order of\n  increasing power.\n\n  The first element is a constant factor, the next is a factor with power 1, and\n  so on.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),$APP.z(w0a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),$APP.P,"Given an unwrapped symbolic expression, returns a new symbolic expression with\n  any perfect square (exponent with an even power) removed from underneath any\n  `sqrt` that appears in the expression.\n\n  To use [[root-out-squares]] with a wrapped symbolic expression,\n  use [[emmy.expression/fmap]]."],
null)),new $APP.f(null,3,[$APP.R,ELb,$APP.X,z0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an unwrapped symbolic expression, returns a new symbolic expression with\n  any perfect square (exponent with an even power) removed from underneath any\n  `sqrt` that appears in the expression.\n\n  To use [[root-out-squares]] with a wrapped symbolic expression,\n  use [[emmy.expression/fmap]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null),$APP.z(Odc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null)))],null)),new $APP.f(null,3,[$APP.R,xUb,$APP.X,qM,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null),WS,new $APP.f(null,3,[$APP.R,l3b,$APP.X,Fqc,$APP.h,$APP.F],null)],null),$APP.Zo(rbc)),$APP.ap($APP.fg([$APP.z(nTb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vw],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vw,$APP.iw],
null))),$APP.P,"Returns an [[Operator]] wrapping the supplied procedure `f` with the symbolic\n  name `name`. (`name` defaults to `'???`.)\n\n  Optionally accepts a `context` map that will be stored inside the\n  returned [[Operator]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vw],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vw,$APP.iw],null)],null),$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vw],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vw,$APP.iw],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(uDb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,8,[SW,"null",hU,"null",WE,"null",lS,"null",LY,"null",nT,"null",jW,"null",RV,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Qv,ZT,$APP.Vw,$APP.iw,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,4,[SW,"null",
lS,"null",nT,"null",jW,"null"],null),null),$APP.P,"Positional factory function for emmy.operator/Operator."],null)),$APP.z(sFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if the supplied `x` is an instance of [[Operator]], false\n  otherwise."],null)),$APP.Cx,$APP.z(Bdc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Pv],null)))],null)),$APP.z($APP.Vw,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))),$APP.P,"Returns the stored name of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied."],null)),$APP.z($APP.iw,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))),$APP.P,"Returns the context field of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied."],null)),$APP.z(hRb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null),new $APP.H(null,2,5,$APP.I,
[DW,$APP.uU],null))),$APP.P,"Similar to `exp`, but takes an optional argument `n` that defines an order for\n  each term of the taylor series expansion.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[DW],null),new $APP.H(null,2,5,$APP.I,[DW,$APP.uU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null),new $APP.H(null,2,5,$APP.I,[DW,$APP.uU],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(zZb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))),$APP.P,"Returns the backing procedure of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied."],null)),$APP.z(pFb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Pv],null)))],null)),$APP.z(ZT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))),$APP.P,"Returns the arity of the supplied [[Operator]]. Errors if a non-[[Operator]] is\n  supplied."],
null)),$APP.z(zJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))),$APP.P,"Returns an operator represented by a Taylor series expansion of $e^x$, applied\n  to `op`. This expanded series of operators is itself an operator that applies\n  each element to its argument.\n\n  Put another way: `(exp g)` to an operator g means forming the power series\n\n  ```\n  I + g + 1/2 g^2 + ... + 1/n! g^n\n  ```\n\n  where (as elsewhere) exponentiating the operator means `n`-fold composition."],
null))],[new $APP.f(null,3,[$APP.R,Bib,$APP.X,JK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an [[Operator]] wrapping the supplied procedure `f` with the symbolic\n  name `name`. (`name` defaults to `'???`.)\n\n  Optionally accepts a `context` map that will be stored inside the\n  returned [[Operator]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vw],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vw,$APP.iw],null))],null)],null),new $APP.f(null,
3,[$APP.R,c6b,$APP.X,CK,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.operator/Operator.",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Qv,ZT,$APP.Vw,$APP.iw,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,oMb,$APP.X,DK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `x` is an instance of [[Operator]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,q8b,$APP.X,Xpc,$APP.h,$APP.F],
null),new $APP.f(null,3,[$APP.R,lJb,$APP.X,KZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,w0b,$APP.X,GK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the stored name of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))],null)],null),new $APP.f(null,3,[$APP.R,Peb,$APP.X,HK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the context field of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))],null)],null),new $APP.f(null,3,[$APP.R,c1b,$APP.X,d2,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to `exp`, but takes an optional argument `n` that defines an order for\n  each term of the taylor series expansion.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null),new $APP.H(null,2,5,$APP.I,[DW,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,dTb,$APP.X,EK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the backing procedure of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))],null)],null),new $APP.f(null,3,[$APP.R,Acc,$APP.X,NK,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,TBb,$APP.X,FK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the arity of the supplied [[Operator]]. Errors if a non-[[Operator]] is\n  supplied.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))],null)],null),new $APP.f(null,3,[$APP.R,OTb,$APP.X,LZa,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns an operator represented by a Taylor series expansion of $e^x$, applied\n  to `op`. This expanded series of operators is itself an operator that applies\n  each element to its argument.\n\n  Put another way: `(exp g)` to an operator g means forming the power series\n\n  ```\n  I + g + 1/2 g^2 + ... + 1/n! g^n\n  ```\n\n  where (as elsewhere) exponentiating the operator means `n`-fold composition.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[DW],null))],null)],null)]),$APP.Zo(eGb)),
$APP.ap($APP.fg([$APP.z(deb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.tU],null)))],null)),$APP.z(mLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.DU,vU,IW,JW],null),new $APP.H(null,5,5,$APP.I,[$APP.DU,vU,IW,JW,XV],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,5,$APP.nw,5,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[$APP.DU,vU,IW,JW],null),new $APP.H(null,5,5,$APP.I,[$APP.DU,vU,IW,JW,XV],null)],null),
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.DU,vU,IW,JW],null),new $APP.H(null,5,5,$APP.I,[$APP.DU,vU,IW,JW,XV],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z($ab,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,8,5,$APP.I,[$X,HW,AW,IW,BW,$APP.uU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[bW],null)],null)],null))),$APP.P,"SICM p. 23. The optional parameter values is a callback which will report\n  intermediate points of the minimization.",$APP.hy,new $APP.f(null,
6,[$APP.ru,!0,$APP.Sn,6,$APP.nw,6,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($X,HW,AW,IW,BW,$APP.uU,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[bW],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,8,5,$APP.I,[$X,HW,AW,IW,BW,$APP.uU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[bW],null)],null)],null)),$APP.zx,$APP.M(null)],null)],null)),YPb,k7b,$APP.z(Aib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EX],null))),$APP.P,"SICM p. 47. Polar to rectangular coordinates of state."],
null)),nob,$APP.z(kEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[HW,AW,IW,BW,kTb],null))),$APP.P,"SICM p. 23n"],null)),Reb,$APP.z(bpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,IU],null))),$APP.P,"Lagrangian for a point mass on with the potential energy V(x, y)"],null)),$APP.z($Wb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null)))],null)),$APP.z(R$b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.mO,SX,WR],null)],null)))],null)),$APP.z(nqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))),$APP.P,"The state derivative of a Lagrangian is a function carrying a state tuple to\n  its time derivative.\n\n  Alias for the non-dissipative, single-arity version\n  of [[Lagrangian-\x3estate-derivative]]."],null)),Kxb,$APP.z(a7b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,
3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null)))],null)),$APP.z(apb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[rU,$APP.Or,lO],null)))],null)),$APP.z($APP.bv,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),0)],null)],null)))),$APP.P,"Extract the time slot from a state tuple.\n\n  See [[coordinate]] for more detail."],null)),
lyb,$APP.z(QAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))],null)),$APP.z(rNb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[vW,sSb,IU],null)))],null)),$APP.z(Dtb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),2)],null)],null)))),$APP.P,"Returns the velocity element of a local tuple (by convention, the third\n  element).\n\n  See [[coordinate]] for more detail."],
null)),$APP.z(xJb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EX],null)))],null)),$APP.z(Dob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Ew],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qIb,$APP.Ew)],null)],null))))],null)),Wzb,n3b,$APP.z(rAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$X],null)))],null)),$APP.z($X,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,
1,5,$APP.I,[$APP.uU],null))),$APP.P,"Returns a function signature for a Lagrangian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Lagrangian literal functions.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.uU],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.uU],null)),$APP.zx,$APP.M(null,null)],null)],null)),fAb,tOb,$APP.z(IFb,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Rv,vU,RY,$APP.Lh,tT],null))),$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q`, velocity tuple (or scalar)\n  `qdot` and any number of additional higher-order derivative tuples (or\n  scalars), returns a 'Local tuple', i.e., the state expected by a Lagrangian.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Rv,vU,RY,tT)],null),$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,
[$APP.Rv,vU,RY,$APP.Lh,tT],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(vec,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,rU],null))),$APP.P,"The Lagrangian of an object experiencing uniform acceleration\n  in the negative y direction, i.e. the acceleration due to gravity"],null)),$APP.z(E5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.NW,$APP.OW,$APP.uU],null)))],null)),vFb,sZb,$APP.z($Vb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),3)],null)],null)))),$APP.P,"Returns the acceleration element of a local tuple (by convention, the fourth\n  element).\n\n  See [[coordinate]] for more detail."],null)),$APP.z(T8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,
!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(qQb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null),$APP.z(new $APP.H(null,2,5,$APP.I,[vU,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,
[$APP.M($APP.Yv,$APP.uU,1)],null)],null)))),$APP.P,"Gamma takes a path function (from time to coordinates) to a state\n  function (from time to local tuple).",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[vU,$APP.uU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[vU,$APP.uU],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(bxb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),1)],null)],null)))),$APP.P,"A convenience function on local tuples. A local tuple describes\n  the state of a system at a particular time:\n\n  ```\n  [t, q, D q, D^2 q]\n  ```\n\n  representing time, position, velocity (and optionally acceleration etc.)\n\n  [[coordinate]] returns the `q` element, which is expected to be a mapping from\n  time to a structure of coordinates."],
null)),$APP.z(kwb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,Pyb],null)))],null)),fwb,$APP.z(Fgb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.mO,WR],null)],null)))],null)),ydb,Oyb,$APP.z(Hpb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))],null)),$APP.z(P2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Brb],null))),$APP.P,"Given a state tuple (of finite length), reconstitutes the initial segment of\n  the Taylor series corresponding to the state tuple data as a function of t.\n\n  Time is measured beginning at the point of time specified in the input state\n  tuple."],
null)),$APP.z(tlb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[AIb,xTb],null)))],null)),$APP.z(yTb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))],null)),$APP.z($qb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.tU],null))),$APP.P,"The Lagrangian of a simple harmonic oscillator (mass-spring\n  system). m is the mass and k is the spring constant used in\n  Hooke's law. The resulting Lagrangian is a function of the\n  local tuple of the system."],
null)),$APP.z(xzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],null)),$APP.z(azb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],
null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(vsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[vW,sSb,lO,rU],null))),$APP.P,"Pendulum of mass m2 and length b, hanging from a support of mass m1 that is\n  free to move horizontally (from Groesberg, Advanced Mechanics, p. 72)"],null)),$APP.z(DJb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pV],null)))],null)),$APP.z(fjb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qUb,$APP.fx],null))),$APP.P,"Given `ys` (a sequence of function values) and `xs` (an equal-length sequence\n  of function inputs), returns a [[emmy.polynomial/Polynomial]] instance\n  guaranteed to pass through all supplied `xs` and `ys`.\n\n  The contract for inputs is that `(map vector xs ys)` should return a sequence\n  of pairs of points."],null)),$APP.z(C3b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],
null)))],null)),$APP.z(rob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,Txb],null)))],null)),xxb,$APP.z(jKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$X,HW,AW,IW,BW],null))),$APP.P,"SICM p. 23"],null)),$APP.z(Obb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Mvb],null))),$APP.P,"The lagrangian of a free particle of mass m. The Lagrangian\n  returned is a function of the local tuple. Since the particle\n  is free, there is no potential energy, so the Lagrangian is\n  just the kinetic energy."],
null)),$APP.z(O4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,Pyb],null))),$APP.P,"Consider planar motion in a central force field, with an arbitrary potential,\n  `U`, depending only on the radius. The generalized coordinates are polar."],null)),$APP.z(tUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,SR,bOb],null)))],null)),$APP.z(lEb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UU],null)))],null)),
oob,$APP.z(gKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pV],null))),$APP.P,"SICM p. 83"],null)),pMb,$APP.z(eQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null)))],null)),leb,$APP.z(qec,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[dAb,$APP.Or],null)))],null)),$APP.z(E4b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,
vY],null))),$APP.P,"Optionally takes a dissipation function.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(cQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.tU],null)))],
null)),$APP.z(NIb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(FOb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Tv],null)))],null)),Znb,$APP.z(t1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null)],null)))],null)),ogb],[new $APP.f(null,3,[$APP.R,kZb,$APP.X,function(a){return function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return iG.C(b,a,$APP.y([b]))}},$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,I1b,$APP.X,SQ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.DU,vU,IW,JW],null),new $APP.H(null,5,5,$APP.I,[$APP.DU,vU,IW,JW,XV],null))],null)],null),new $APP.f(null,3,[$APP.R,pKb,$APP.X,w4,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 23. The optional parameter values is a callback which will report\n  intermediate points of the minimization.",$APP.U,$APP.M(new $APP.H(null,8,
5,$APP.I,[$X,HW,AW,IW,BW,$APP.uU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[bW],null)],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,FNb,$APP.X,RQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,uKb,$APP.X,NQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,o9b,$APP.X,D9a,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 47. Polar to rectangular coordinates of state.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[EX],null))],null)],null),new $APP.f(null,3,[$APP.R,RDb,$APP.X,KQ,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.R,Tkb,$APP.X,s9a,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 23n",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[HW,AW,IW,BW,kTb],null))],null)],null),new $APP.f(null,3,[$APP.R,G3b,$APP.X,MQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,d3b,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);c=$APP.x.B(c,2,null);return RF.A(iG.C(QF.A(1,2),a,$APP.y([lG.j(c)])),b.A?b.A(g,d):b.call(null,g,d))}},
$APP.h,new $APP.f(null,2,[$APP.P,"Lagrangian for a point mass on with the potential energy V(x, y)",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,IU],null))],null)],null),new $APP.f(null,3,[$APP.R,N6b,$APP.X,w9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null))],null)],null),new $APP.f(null,3,[$APP.R,Ncb,$APP.X,E9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.mO,SX,WR],null)],null))],null)],null),new $APP.f(null,
3,[$APP.R,kYb,$APP.X,function(a){return $APP.PQ.A(a,null)},$APP.h,new $APP.f(null,2,[$APP.P,"The state derivative of a Lagrangian is a function carrying a state tuple to\n  its time derivative.\n\n  Alias for the non-dissipative, single-arity version\n  of [[Lagrangian-\x3estate-derivative]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.R,Rob,$APP.X,QN,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,axb,$APP.X,G9a,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,bkb,$APP.X,function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return kG.A(iG.C(QF.A(1,2),b,$APP.y([lG.j(iG.A(c,d))])),iG.C(a,b,$APP.y([c,fO.j(g)])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[rU,$APP.Or,lO],null))],null)],null),new $APP.f(null,3,[$APP.R,p_b,$APP.X,KQ,$APP.h,new $APP.f(null,
2,[$APP.P,"Extract the time slot from a state tuple.\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,vbc,$APP.X,NQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ZOb,$APP.X,o9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,
3,[$APP.R,owb,$APP.X,function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null),l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var n=$APP.x.B(d,2,null);d=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);return RF.A(kG.A(iG.C(QF.A(1,2),a,$APP.y([lG.j(d)])),iG.C(QF.A(1,2),b,$APP.y([lG.j(n)]))),c.A?c.A(l,g):c.call(null,l,g))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[vW,sSb,IU],null))],null)],null),new $APP.f(null,3,[$APP.R,CLb,$APP.X,MQ,$APP.h,new $APP.f(null,2,[$APP.P,
"Returns the velocity element of a local tuple (by convention, the third\n  element).\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),2)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,AKb,$APP.X,B9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[EX],null))],null)],null),new $APP.f(null,3,[$APP.R,z7b,$APP.X,g9a,$APP.h,
new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Ew],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qIb,$APP.Ew)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,jwb,$APP.X,UQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Iac,$APP.X,m9a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Rab,$APP.X,z9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$X],null))],null)],null),new $APP.f(null,3,[$APP.R,$Mb,$APP.X,t4,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a function signature for a Lagrangian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Lagrangian literal functions.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,Fwb,$APP.X,uL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,vtb,$APP.X,y9a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Yvb,$APP.X,OQ,$APP.h,new $APP.f(null,2,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q`, velocity tuple (or scalar)\n  `qdot` and any number of additional higher-order derivative tuples (or\n  scalars), returns a 'Local tuple', i.e., the state expected by a Lagrangian.",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Rv,vU,RY,$APP.Lh,tT],null))],null)],null),new $APP.f(null,3,[$APP.R,JMb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);c=$APP.x.B(c,2,null);return RF.A(iG.C(QF.A(1,2),a,$APP.y([lG.j(c)])),iG.C(a,b,$APP.y([d])))}},$APP.h,new $APP.f(null,2,[$APP.P,"The Lagrangian of an object experiencing uniform acceleration\n  in the negative y direction, i.e. the acceleration due to gravity",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,rU],null))],null)],null),new $APP.f(null,3,[$APP.R,Sfb,$APP.X,q9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.NW,$APP.OW,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,Ddb,$APP.X,$APP.LQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,cxb,$APP.X,OQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,T6b,$APP.X,NQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the acceleration element of a local tuple (by convention, the fourth\n  element).\n\n  See [[coordinate]] for more detail.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),3)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Oeb,$APP.X,v4,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null))],null)],null),new $APP.f(null,3,[$APP.R,jsb,$APP.X,RQ,$APP.h,new $APP.f(null,2,[$APP.P,"Gamma takes a path function (from time to coordinates) to a state\n  function (from time to local tuple).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null),$APP.z(new $APP.H(null,2,5,$APP.I,[vU,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yv,$APP.uU,1)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,mBb,$APP.X,$APP.LQ,$APP.h,new $APP.f(null,2,[$APP.P,"A convenience function on local tuples. A local tuple describes\n  the state of a system at a particular time:\n\n  ```\n  [t, q, D q, D^2 q]\n  ```\n\n  representing time, position, velocity (and optionally acceleration etc.)\n\n  [[coordinate]] returns the `q` element, which is expected to be a mapping from\n  time to a structure of coordinates.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),1)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,sfb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(c,2,null);c=RF.A;g=iG.C(QF.A(1,2),a,$APP.y([lG.j(g)]));d=hG.j(d);d=b.j?b.j(d):b.call(null,d);return c.call(RF,g,d)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Or,Pyb],null))],null)],null),new $APP.f(null,3,[$APP.R,Awb,$APP.X,y9a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,vAb,$APP.X,C9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.mO,WR],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,V5b,$APP.X,NQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,tXb,$APP.X,$APP.LQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,oib,$APP.X,y9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,
$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.R,ODb,$APP.X,v9a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a state tuple (of finite length), reconstitutes the initial segment of\n  the Taylor series corresponding to the state tuple data as a function of t.\n\n  Time is measured beginning at the point of time specified in the input state\n  tuple.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Brb],null))],null)],null),new $APP.f(null,3,[$APP.R,iWb,$APP.X,function(a,b){return RF.A(a,b)},$APP.h,
new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[AIb,xTb],null))],null)],null),new $APP.f(null,3,[$APP.R,Gwb,$APP.X,m9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.R,Srb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);return RF.A(iG.C(QF.A(1,2),a,$APP.y([lG.j(c)])),iG.C(QF.A(1,2),b,$APP.y([lG.j(d)])))}},$APP.h,new $APP.f(null,2,[$APP.P,"The Lagrangian of a simple harmonic oscillator (mass-spring\n  system). m is the mass and k is the spring constant used in\n  Hooke's law. The resulting Lagrangian is a function of the\n  local tuple of the system.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,cHb,$APP.X,TQ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,iHb,$APP.X,u4,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null))],null)],null),new $APP.f(null,3,[$APP.R,ESb,$APP.X,function(a,b,c,d){var g=WH,l=g.C;a=k9a(a,b,d);c=j9a(c);c=$APP.VQ.j?
$APP.VQ.j(c):$APP.VQ.call(null,c);return l.call(g,$APP.y([a,c]))},$APP.h,new $APP.f(null,2,[$APP.P,"Pendulum of mass m2 and length b, hanging from a support of mass m1 that is\n  free to move horizontally (from Groesberg, Advanced Mechanics, p. 72)",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[vW,sSb,lO,rU],null))],null)],null),new $APP.f(null,3,[$APP.R,yKb,$APP.X,H9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pV],null))],null)],null),new $APP.f(null,3,[$APP.R,ofb,$APP.X,r9a,
$APP.h,new $APP.f(null,2,[$APP.P,"Given `ys` (a sequence of function values) and `xs` (an equal-length sequence\n  of function inputs), returns a [[emmy.polynomial/Polynomial]] instance\n  guaranteed to pass through all supplied `xs` and `ys`.\n\n  The contract for inputs is that `(map vector xs ys)` should return a sequence\n  of pairs of points.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[qUb,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,Rrb,$APP.X,n9a,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.R,Qmb,$APP.X,function(a,b){return RF.A(p9a(a),function(c){$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);c=$APP.x.B(c,0,null);return b.j?b.j(c):b.call(null,c)})},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,Txb],null))],null)],null),new $APP.f(null,3,[$APP.R,qdc,$APP.X,OQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Lfb,$APP.X,u9a,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 23",$APP.U,
$APP.M(new $APP.H(null,5,5,$APP.I,[$X,HW,AW,IW,BW],null))],null)],null),new $APP.f(null,3,[$APP.R,jCb,$APP.X,$APP.i9a,$APP.h,new $APP.f(null,2,[$APP.P,"The lagrangian of a free particle of mass m. The Lagrangian\n  returned is a function of the local tuple. Since the particle\n  is free, there is no potential energy, so the Lagrangian is\n  just the kinetic energy.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Mvb],null))],null)],null),new $APP.f(null,3,[$APP.R,vqb,$APP.X,function(a,b){return function(c){$APP.x.B(c,
0,null);var d=$APP.x.B(c,1,null);d=$APP.x.B(d,0,null);var g=$APP.x.B(c,2,null);c=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return RF.A(iG.C(QF.A(1,2),a,$APP.y([kG.A(lG.j(c),lG.j(iG.A(d,g)))])),b.j?b.j(d):b.call(null,d))}},$APP.h,new $APP.f(null,2,[$APP.P,"Consider planar motion in a central force field, with an arbitrary potential,\n  `U`, depending only on the radius. The generalized coordinates are polar.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,Pyb],null))],null)],null),new $APP.f(null,
3,[$APP.R,TCb,$APP.X,function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null);g=$APP.x.B(g,0,null);var l=$APP.x.B(d,2,null);d=$APP.x.B(l,0,null);var n=$APP.x.B(l,1,null);l=$APP.x.B(l,2,null);return kG.C(iG.C(QF.A(1,2),a,$APP.y([kG.A(lG.j(d),lG.j(iG.A(n,gO.j(g))))])),iG.C(QF.A(1,2),b,$APP.y([lG.j(kG.A(l,iG.A(n,fO.j(g))))])),$APP.y([iG.C(-1,c,$APP.y([fO.j(g)]))]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[zU,SR,bOb],null))],null)],null),new $APP.f(null,
3,[$APP.R,isb,$APP.X,h9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UU],null))],null)],null),new $APP.f(null,3,[$APP.R,PDb,$APP.X,$APP.LQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Iwb,$APP.X,F9a,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 83",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pV],null))],null)],null),new $APP.f(null,3,[$APP.R,rrb,$APP.X,MQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Lsb,$APP.X,p9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Ehb,$APP.X,uL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,c0b,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);d=$APP.x.B(d,0,null);var g=$APP.x.B(c,2,null);c=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return kG.A(iG.C(QF.A(1,2),b,$APP.y([kG.A(lG.j(c),lG.j(iG.A(d,g)))])),QF.A(iG.A(a,b),d))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[dAb,$APP.Or],null))],null)],null),new $APP.f(null,
3,[$APP.R,ngb,$APP.X,$APP.PQ,$APP.h,new $APP.f(null,2,[$APP.P,"Optionally takes a dissipation function.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null))],null)],null),new $APP.f(null,3,[$APP.R,fKb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);return RF.A(iG.C(QF.A(1,2),c,$APP.y([a,c])),iG.C(QF.A(1,2),d,$APP.y([b,d])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Or,$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,UJb,$APP.X,$APP.VQ,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a coordinate transformation `F` from a local tuple to a new coordinate\n  structure, and returns a function from `local -\x3e local` that applies the\n  transformation directly.\n\n  [[F-\x3eC]] handles local tuples of arbitrary length.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null))],null)],null),new $APP.f(null,3,[$APP.R,qwb,$APP.X,l9a,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[vU,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,lrb,$APP.X,uL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,P1b,$APP.X,A9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,$ub,$APP.X,MQ,$APP.h,$APP.F],null)]),$APP.Zo(vub)),$APP.ap($APP.fg([$APP.z(bnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],
null)),$APP.z(FXb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(CQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(zRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(Q3b,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(L9b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,Sdb],null))),$APP.P,"Takes a function and returns a pair of:\n\n  - an atom that keeps track of fn invocation counts,\n  - the instrumented fn",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,Sdb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,Sdb],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z($APP.Cya,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(fub,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(qCb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(znb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(Kbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Or],null))),$APP.P,"Returns a map of identical type and key set to `m`, with each value `v`\n  transformed by the supplied function`f` into `(f v)`."],
null)),$APP.z($APP.wx,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"Returns a string containing a randomly generated unique identifier."],null)),$APP.z($APP.bEa,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),WCb,$APP.z(aac,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(hSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,
"Walks x, removing namespaces from any symbols that are found.\n  Convenient in unit tests, where the distinction between symbols\n  in `clojure.core` vs. `cljs.core` is unimportant"],null)),eAb,$APP.z(e6b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(S5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if the supplied `x` is a `BigInt`, false otherwise."],null)),$APP.z(zHb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null)))],null)),$APP.z(LEb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(MMb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null)))],null)),$APP.z(eHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[GW,$APP.Sv],null))),$APP.P,"Returns true if s matches the regex pattern re, false otherwise."],null)),$APP.z(q4b,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(HXb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z($APP.my,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(uub,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z($APP.xv,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(Rzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(eDb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(Ynb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),BNb,$APP.z(x1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null))],[new $APP.f(null,3,[$APP.R,iob,$APP.X,cOa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Ffb,$APP.X,MR,$APP.h,$APP.F],
null),new $APP.f(null,3,[$APP.R,Kcc,$APP.X,eOa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,eRb,$APP.X,function(a){return Number.isNaN(a)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,SGb,$APP.X,$APP.za,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,eLb,$APP.X,TY,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function and returns a pair of:\n\n  - an atom that keeps track of fn invocation counts,\n  - the instrumented fn",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,Sdb],null))],null)],null),new $APP.f(null,3,[$APP.R,rkb,$APP.X,aOa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,wIb,$APP.X,CD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,C5b,$APP.X,yD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,mWb,$APP.X,function(a){throw Error(a);},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,OZb,$APP.X,uD,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a map of identical type and key set to `m`, with each value `v`\n  transformed by the supplied function`f` into `(f v)`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,
d_b,$APP.X,zD,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string containing a randomly generated unique identifier.",$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.R,Bkb,$APP.X,fOa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,zlb,$APP.X,Gec,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,QY,$APP.X,wD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,
3,[$APP.R,ZQb,$APP.X,function(a){return $APP.yo(function(b){return $APP.ce(b)?$APP.Zg.j($APP.Ag(b)):b},a)},$APP.h,new $APP.f(null,2,[$APP.P,"Walks x, removing namespaces from any symbols that are found.\n  Convenient in unit tests, where the distinction between symbols\n  in `clojure.core` vs. `cljs.core` is unimportant",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Ahb,$APP.X,UY,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,T0b,$APP.X,function(a){throw Error(a);
},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,nXb,$APP.X,$Na,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `x` is a `BigInt`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,NFb,$APP.X,tD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Jqb,$APP.X,$APP.qa,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.R,nYb,$APP.X,function(a){return a instanceof Error},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.R,Ucb,$APP.X,vD,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if s matches the regex pattern re, false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[GW,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,yPb,$APP.X,HR,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,qeb,$APP.X,
function(a){return BigInt(a)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,kac,$APP.X,xD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,FKb,$APP.X,BD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,a2b,$APP.X,bOa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,izb,$APP.X,dOa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,nCb,$APP.X,Hec,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,XOb,$APP.X,AD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,JJb,$APP.X,kQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,clb,$APP.X,function(a){return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,
QY,null,1,null),new $APP.D(null,a,null,1,null))))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null)]),$APP.Zo(wkb)),$APP.ap($APP.fg([$APP.z(mU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures."],null)),$APP.z(xP,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,
$APP.fx],null))),$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.fx)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(D2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))),$APP.P,"Construct a down (covariant) tuple from the supplied sequence. For a\n  variadic version, see [[down]]."],
null)),$APP.z(H2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns `true` if `s` is a `down` structure, false otherwise."],null)),$APP.z($APP.AY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"If `s` is sequential, returns its dimension, i.e., the total number of\n  non-sequential entries in the structure. Else, returns 1."],null)),$APP.z(pWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(Fmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null))),$APP.P,"For a non-[[Structure]] `s`, the single-arity case acts as [[identity]]. For\n  a [[Structure]], returns an identical structure with its orientation\n  reversed (up becomes down, down becomes up).\n\n  NOTE that a vector is interpreted as an `up` structure, so:\n\n  (opposite [1 2 3])\n  ;;\x3d\x3e (down 1 2 3)\n\n  The two-arity case returns a new [[Structure]] of opposite orientation to `s`\n  with the contents of the sequence `xs`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(vzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,
[$APP.M($APP.Yw,$APP.Tv)],null)],null)))),$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient."],null)),$APP.z(w6b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null))),$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(YOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `s` is an `up` or `down` structure containing all `up` or\n  `down` structures of internally-matching orientation and size, false\n  otherwise."],
null)),$APP.z(u0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,$APP.Sv],null))),$APP.P,"Accepts\n\n  - some symbolic (or string) `name`\n  - a structure `s`\n\n  and returns a new structure of identical shape, with symbolic entries like\n  `'x0_1` that show their access chain with proper orientations for each step."],null)),$APP.z(MY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise."],
null)),$APP.z(avb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(lib,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(O7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Return the structure `s` in unoriented vector form."],null)),$APP.z(Omb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))),$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```"],
null)),$APP.z(DKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a structure of the same shape and orientation as `s`, generated by\n  substituting gensymmed symbols in for each entry."],null)),gEb,$APP.z(gU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[mU,$APP.fx],null))),$APP.P,"Generate a structure with the supplied orientation, given some sequence `xs`"],null)),$APP.z(mIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null))),$APP.P,"Returns a new structure of equivalent shape to `s`, generated by applying `f`\n  to three arguments:\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  For example:\n\n  ```clojure\n  (dorun (map-chain println (s/down (s/up 1 2) (s/up 3 4))))\n\n  1 [0 0] [::s/down ::s/up]\n  2 [0 1] [::s/down ::s/up]\n  3 [1 0] [::s/down ::s/up]\n  4 [1 1] [::s/down ::s/up]\n  ```"],
null)),$APP.z(TIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a structure compatible for multiplication with `s` down to 0."],null)),aqb,$APP.z($gb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ov,sU],null))),$APP.P,"Returns `1` if `i`\x3d\x3d `j`, `0` otherwise."],null)),$APP.z(cSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))),$APP.P,"Returns true if the supplied structures have the same orientation, false\n  otherwise."],
null)),$APP.z(K5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null)))),$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient."],null)),$APP.z(jQb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.AY,mU,$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,mU)],null)],null)))),$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`."],null)),$APP.z(VAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))),$APP.P,"Returns the (vector) inner product of `v1` and `v2`; this is equivalent to the\n  sum of the pairwise product of each entry.\n\n    This is equivalent to [[vector-dot-product]] with every element of `v1`\n  transformed into its complex conjugate.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]]."],
null)),$APP.z(qW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qv],null))),$APP.P,"Returns true if the supplied orientation lives in the set of allowed\n  orientations, false otherwise."],null)),$APP.z(dIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)"],null)),$APP.z(hmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a new structure with the same orientation as the first element of `s`,\n  filled with elements of the same orientation as `s`.\n\n  Each element is generating by taking the first element of each entry in `s`,\n  the the second, etc... In that sense this is similar to a traditional matrix\n  transpose.\n\n  A comment from `scmutils` states:\n\n  'used only in symmetrize-Christoffel in\n  src/calculus/covariant-derivative.scm.'"],null)),$APP.z(LK,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oS],null))),$APP.P,"Given an access chain (a sequence of indices), return a function that accepts a\n  structure and returns the element at the specified access chain.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(oS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oS],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(TAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Sv,$APP.fx],null))),$APP.P,"Returns a structure containing `xs` with the same orientation as `s`."],null)),$APP.z(Tib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Vx,$APP.wY,mU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,mU)],null)],null)))),$APP.P,"Generates a structure of the specified `orientation` and dimension `size`\n  populated by symbolic entries, each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  (\x3d (literal 'x 3 ::s/up)\n     (up 'x0 'x1 'x2))\n\n  See [[literal-up]] and [[literal-down]] for constructors with baked in\n  orientations."],
null)),$APP.z(anb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SY,$APP.sv],null),new $APP.H(null,3,5,$APP.I,[$E,SY,$APP.sv],null))),$APP.P,"Given:\n\n  - a sequence of `values`\n  - a model `struct`\n\n  Returns a new structure generated by unpacking `values` into a structure with\n  the same shape as `struct`.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[SY,$APP.sv],null),new $APP.H(null,3,
5,$APP.I,[$E,SY,$APP.sv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[SY,$APP.sv],null),new $APP.H(null,3,5,$APP.I,[$E,SY,$APP.sv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Tab,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given an `up` or `down` structure containing structures of the same\n  orientation and size (a 2 tensor), returns a dictionary with keys:\n\n  ```clj\n  {:outer-orientation \x3c::up or ::down\x3e\n   :inner-orientation \x3c::up or ::down\x3e\n   :outer-size \x3cint\x3e\n   :inner-size \x3cint\x3e}\n\n  If `s` is _not_ a valid tensor, returns nil.\n  ```"],
null)),$APP.z(jvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Return a structure of the same shape as `s` whose elements are access chains\n  corresponding to position of each element (i.e., the sequence of indices\n  needed to address that element via [[get-in]]).\n\n  Each access chain has the sequence of orientations (`::s/up`, `::s/down`)\n  associated with each step attached to it as metadata, under an `:orientations`\n  key. Use this if the orientation of the indices matters."],
null)),$APP.z($0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))),$APP.P,"Returns the (vector) dot product of `v1` and `v2`; this is equivalent to the sum\n  of the pairwise product of each entry.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]]."],null)),$APP.z(Lcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))),$APP.P,"Construct an up (contravariant) tuple from the supplied sequence. For a\n  variadic version, see [[up]]."],
null)),$APP.z(gwb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null))),$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Kv,AV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null)),$APP.zx,
$APP.M(null)],null)],null)),$APP.z(Imb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.Sv],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.HT,$APP.Sv],null))),$APP.P,"Returns the result of accumulating all non-structural entries in `s` using the\n  supplied fold function `f` into the optional accumulator `init` (defaults\n  to `(f)`).\n\n  `f` must be a 2-argument fn of type `(accumulator, [x chain orientations]) \x3d\x3e\n  accumulator` responsible for merging some value `x` into the ongoing\n  accumulation. The second argument is a 3-vector containing\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  `f` should return a new instance of the accumulator.\n\n  Additional arities allow you to supply\n\n  - `init`, the initial (empty) accumulator (defaults to `(f)`)\n  - `present`, a function that will be applied to the final, aggregated\n    result (defaults to `f`)\n\n  For example:\n\n  ```clojure\n  (fold-chain\n    (fn ([] [])\n     ([acc] acc)\n     ([acc [s chain orientations]]\n      (conj acc {:s s\n                 :chain chain\n                 :orientations orientations})))\n    (s/down (s/up 1 2) (s/up 3 4)))\n\n  [{:s 1, :chain [0 0], :orientations [::s/down ::s/up]}\n   {:s 2, :chain [0 1], :orientations [::s/down ::s/up]}\n   {:s 3, :chain [1 0], :orientations [::s/down ::s/up]}\n   {:s 4, :chain [1 1], :orientations [::s/down ::s/up]}]\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.Sv],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.HT,$APP.Sv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.Sv],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.HT,$APP.Sv],null)),$APP.zx,$APP.M(null,null,null)],
null)],null)),$APP.z(hGb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(wP,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))),$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.fx)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z($APP.VX,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a structure with the same shape as `s`, with all orientations\n  inverted."],null)),$APP.z(dyb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,22,[$S,"null",LT,"null",SV,"null",kU,"null",SW,"null",oU,"null",hU,"null",WE,"null",$Lb,"null",xX,"null",SS,"null",rS,"null",lS,"null",LY,"null",gV,"null",uX,"null",uY,"null",nT,"null",RW,"null",jW,"null",RV,"null",tY,"null"],null),null),$APP.lw,
ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[mU,$APP.Tv,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,17,[$S,"null",LT,"null",SV,"null",kU,"null",SW,"null",oU,"null",xX,"null",SS,"null",rS,"null",lS,"null",gV,"null",uX,"null",uY,"null",nT,"null",RW,"null",jW,"null",tY,"null"],null),null),$APP.P,"Positional factory function for emmy.structure/Structure."],null)),$APP.z(LCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms."],
null)),$APP.z(orb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))),$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x0 'x1 'x2))\n  ```"],null)),$APP.z(aDb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null)),$APP.z(PZb,new $APP.f(null,1,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))],null))],[new $APP.f(null,3,[$APP.R,Osb,$APP.X,TK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,LP,$APP.X,uL,$APP.h,new $APP.f(null,2,[$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,r8b,$APP.X,aL,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a down (covariant) tuple from the supplied sequence. For a\n  variadic version, see [[down]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,O8b,$APP.X,PZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is a `down` structure, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Agb,$APP.X,UK,$APP.h,new $APP.f(null,2,[$APP.P,"If `s` is sequential, returns its dimension, i.e., the total number of\n  non-sequential entries in the structure. Else, returns 1.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,OIb,$APP.X,rqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,pIb,$APP.X,t2,$APP.h,new $APP.f(null,
2,[$APP.P,"For a non-[[Structure]] `s`, the single-arity case acts as [[identity]]. For\n  a [[Structure]], returns an identical structure with its orientation\n  reversed (up becomes down, down becomes up).\n\n  NOTE that a vector is interpreted as an `up` structure, so:\n\n  (opposite [1 2 3])\n  ;;\x3d\x3e (down 1 2 3)\n\n  The two-arity case returns a new [[Structure]] of opposite orientation to `s`\n  with the contents of the sequence `xs`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],
null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,S9b,$APP.X,ZZa,$APP.h,new $APP.f(null,2,[$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,
new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,rqb,$APP.X,k2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null))],null)],null),new $APP.f(null,3,[$APP.R,QNb,$APP.X,XZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is an `up` or `down` structure containing all `up` or\n  `down` structures of internally-matching orientation and size, false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,bEb,$APP.X,c_a,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts\n\n  - some symbolic (or string) `name`\n  - a structure `s`\n\n  and returns a new structure of identical shape, with symbolic entries like\n  `'x0_1` that show their access chain with proper orientations for each step.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,IAb,$APP.X,WK,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,wyb,$APP.X,kL,$APP.h,new $APP.f(null,2,[$APP.P,"Return a structure with the same shape as s but with f applied to each\n  primitive (that is, not structural) component.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null))],null)],null),new $APP.f(null,3,[$APP.R,N_b,$APP.X,qqc,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,K4b,$APP.X,RK,$APP.h,new $APP.f(null,2,[$APP.P,"Return the structure `s` in unoriented vector form.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Thb,$APP.X,gL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))],null)],null),new $APP.f(null,3,[$APP.R,wob,$APP.X,lL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure of the same shape and orientation as `s`, generated by\n  substituting gensymmed symbols in for each entry.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,sgb,$APP.X,zP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,kzb,$APP.X,ZK,$APP.h,new $APP.f(null,2,[$APP.P,"Generate a structure with the supplied orientation, given some sequence `xs`",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[mU,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,Sbc,$APP.X,iL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new structure of equivalent shape to `s`, generated by applying `f`\n  to three arguments:\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  For example:\n\n  ```clojure\n  (dorun (map-chain println (s/down (s/up 1 2) (s/up 3 4))))\n\n  1 [0 0] [::s/down ::s/up]\n  2 [0 1] [::s/down ::s/up]\n  3 [1 0] [::s/down ::s/up]\n  4 [1 1] [::s/down ::s/up]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,J1b,$APP.X,nL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure compatible for multiplication with `s` down to 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Fkb,$APP.X,nL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,dub,$APP.X,MZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `1` if `i`\x3d\x3d `j`, `0` otherwise.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Ov,sU],null))],null)],null),new $APP.f(null,3,[$APP.R,$lb,$APP.X,RZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied structures have the same orientation, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.R,inb,$APP.X,YZa,$APP.h,new $APP.f(null,2,[$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,BUb,$APP.X,cL,$APP.h,new $APP.f(null,2,[$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`.",$APP.U,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.AY,mU,$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,
mU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,tdc,$APP.X,g_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the (vector) inner product of `v1` and `v2`; this is equivalent to the\n  sum of the pairwise product of each entry.\n\n    This is equivalent to [[vector-dot-product]] with every element of `v1`\n  transformed into its complex conjugate.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.LW,$APP.MW],null))],null)],null),new $APP.f(null,3,[$APP.R,BYb,$APP.X,QZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied orientation lives in the set of allowed\n  orientations, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qv],null))],null)],null),new $APP.f(null,3,[$APP.R,$6b,$APP.X,VK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,aec,$APP.X,d_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new structure with the same orientation as the first element of `s`,\n  filled with elements of the same orientation as `s`.\n\n  Each element is generating by taking the first element of each entry in `s`,\n  the the second, etc... In that sense this is similar to a traditional matrix\n  transpose.\n\n  A comment from `scmutils` states:\n\n  'used only in symmetrize-Christoffel in\n  src/calculus/covariant-derivative.scm.'",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,Wbb,$APP.X,rP,$APP.h,new $APP.f(null,2,[$APP.P,"Given an access chain (a sequence of indices), return a function that accepts a\n  structure and returns the element at the specified access chain.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oS],null))],null)],null),new $APP.f(null,3,[$APP.R,zrb,$APP.X,bL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure containing `xs` with the same orientation as `s`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,aWb,$APP.X,eL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a structure of the specified `orientation` and dimension `size`\n  populated by symbolic entries, each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  (\x3d (literal 'x 3 ::s/up)\n     (up 'x0 'x1 'x2))\n\n  See [[literal-up]] and [[literal-down]] for constructors with baked in\n  orientations.",$APP.U,$APP.M($APP.z(new $APP.H(null,
3,5,$APP.I,[$APP.Vx,$APP.wY,mU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,mU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Cfb,$APP.X,FN,$APP.h,new $APP.f(null,2,[$APP.P,"Given:\n\n  - a sequence of `values`\n  - a model `struct`\n\n  Returns a new structure generated by unpacking `values` into a structure with\n  the same shape as `struct`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[SY,$APP.sv],null),new $APP.H(null,3,5,$APP.I,[$E,SY,$APP.sv],null))],null)],
null),new $APP.f(null,3,[$APP.R,Jvb,$APP.X,YK,$APP.h,new $APP.f(null,2,[$APP.P,"Given an `up` or `down` structure containing structures of the same\n  orientation and size (a 2 tensor), returns a dictionary with keys:\n\n  ```clj\n  {:outer-orientation \x3c::up or ::down\x3e\n   :inner-orientation \x3c::up or ::down\x3e\n   :outer-size \x3cint\x3e\n   :inner-size \x3cint\x3e}\n\n  If `s` is _not_ a valid tensor, returns nil.\n  ```",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],
null),new $APP.f(null,3,[$APP.R,oPb,$APP.X,jL,$APP.h,new $APP.f(null,2,[$APP.P,"Return a structure of the same shape as `s` whose elements are access chains\n  corresponding to position of each element (i.e., the sequence of indices\n  needed to address that element via [[get-in]]).\n\n  Each access chain has the sequence of orientations (`::s/up`, `::s/down`)\n  associated with each step attached to it as metadata, under an `:orientations`\n  key. Use this if the orientation of the indices matters.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,dJb,$APP.X,pL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the (vector) dot product of `v1` and `v2`; this is equivalent to the sum\n  of the pairwise product of each entry.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))],null)],null),new $APP.f(null,3,[$APP.R,uAb,$APP.X,$K,$APP.h,
new $APP.f(null,2,[$APP.P,"Construct an up (contravariant) tuple from the supplied sequence. For a\n  variadic version, see [[up]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,ZDb,$APP.X,oP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,
$APP.Lh,AV],null))],null)],null),new $APP.f(null,3,[$APP.R,UEb,$APP.X,YN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of accumulating all non-structural entries in `s` using the\n  supplied fold function `f` into the optional accumulator `init` (defaults\n  to `(f)`).\n\n  `f` must be a 2-argument fn of type `(accumulator, [x chain orientations]) \x3d\x3e\n  accumulator` responsible for merging some value `x` into the ongoing\n  accumulation. The second argument is a 3-vector containing\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  `f` should return a new instance of the accumulator.\n\n  Additional arities allow you to supply\n\n  - `init`, the initial (empty) accumulator (defaults to `(f)`)\n  - `present`, a function that will be applied to the final, aggregated\n    result (defaults to `f`)\n\n  For example:\n\n  ```clojure\n  (fold-chain\n    (fn ([] [])\n     ([acc] acc)\n     ([acc [s chain orientations]]\n      (conj acc {:s s\n                 :chain chain\n                 :orientations orientations})))\n    (s/down (s/up 1 2) (s/up 3 4)))\n\n  [{:s 1, :chain [0 0], :orientations [::s/down ::s/up]}\n   {:s 2, :chain [0 1], :orientations [::s/down ::s/up]}\n   {:s 3, :chain [1 0], :orientations [::s/down ::s/up]}\n   {:s 4, :chain [1 1], :orientations [::s/down ::s/up]}]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.Sv],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Cy,$APP.HT,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,evb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,MP,$APP.X,QN,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))],null)],
null),new $APP.f(null,3,[$APP.R,XDb,$APP.X,mL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure with the same shape as `s`, with all orientations\n  inverted.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,iXb,$APP.X,QK,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.structure/Structure.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[mU,$APP.Tv,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,ymb,$APP.X,oL,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,I6b,$APP.X,fL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x0 'x1 'x2))\n  ```",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))],null)],null),new $APP.f(null,3,[$APP.R,Kdc,$APP.X,sqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,uWb,$APP.X,tqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null)]),$APP.Zo(fob)),$APP.ap(new $APP.f(null,5,[$APP.z(Lwb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[a9b,$APP.Vx],null)))],
null)),new $APP.f(null,3,[$APP.R,mnb,$APP.X,function(a,b){a=$APP.JEa(a,b);return $APP.md(a)?a:$APP.ed(a)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[a9b,$APP.Vx],null))],null)],null),ixb,new $APP.f(null,3,[$APP.R,VTa,$APP.X,$Y,$APP.h,new $APP.f(null,4,[$APP.P,"I borrowed this lovely, mysterious macro from `macrovich`:\n   https://github.com/cgrand/macrovich. This allows us to fork behavior inside\n   of a macro at macroexpansion time, not at read time.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,2,5,$APP.I,[obc,WPa],null)],null)],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),meb,new $APP.f(null,3,[$APP.R,GCb,$APP.X,function(a,b,c,d){a=$APP.rg.B(b,zX,!0);b=$APP.Nj.j([$APP.m.j(c),"-value"].join(""));return $APP.k(zX.j(a))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Qh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.di,null,1,null),new $APP.D(null,b,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)])))),
null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,sEb,null,1,null),new $APP.D(null,$APP.kx,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.di,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
sEb,null,1,null),new $APP.D(null,$APP.kx,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.ai,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.di,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)]))))},$APP.h,new $APP.f(null,4,[$APP.P,
"Given some namespace `ns`, returns a function of some binding symbol and a\n  form to bind. The function returns either\n\n  - A form like `(def ~sym ~form)`, if `sym` is not currently bound into `ns`\n\n  - If `sym` is bound already, returns a form that emits a warning and then\n    uses `ns-unmap` and `intern` to reassign the binding.\n\n  In Clojure, this behavior matches redefinitions of symbols bound in\n  `clojure.core`. Symbols bound with `def` that are already imported from other\n  namespaces cause an exception, hence this more careful workaround.\n\n  (In ClojureScript, only forms like `(def ~sym ~form)` are emitted, since the\n  compiler does not currently error in case 2 and already handles emitting the\n  warning for us.)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Bv],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),XKb,new $APP.f(null,3,[$APP.R,jfb,$APP.X,aZ,$APP.h,new $APP.f(null,4,[$APP.P,"Defines a multifn using the provided symbol. Arranges for the multifn\n  to answer the :arity message, reporting either `[:exactly a]` or\n  `[:between a b]` according to the arguments given.\n\n  - `arities` can be either a single or a vector of 2 numbers.\n\n  The `options` allowed differs slightly from `defmulti`:\n\n  - the first optional argument is a docstring.\n\n  - the second optional argument is a dict of metadata. When you query the\n  defined multimethod with a keyword, it will pass that keyword along as a query\n  to this metadata map. (`:arity` is always overridden if supplied, and `:name`\n  defaults to the symbol `f`.)\n\n  Any remaining options are passed along to `defmulti`.",
$APP.U,$APP.M(new $APP.H(null,6,5,$APP.I,[$APP.Vw,jIb,$APP.oxa,$APP.Au,$APP.Lh,$APP.yu],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),$APP.z(vdb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$V],null)))],null)),new $APP.f(null,3,[$APP.R,i8b,$APP.X,function(a,b){return $APP.Jd(function(c,d,g){var l=$APP.C.A(c,d);return null==l?c:$APP.rg.B(c,d,g.j?g.j(l):g.call(null,l))},a,b)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$V],null))],null)],
null)],null),$APP.Zo(Idb)),$APP.ap(new $APP.f(null,4,[$APP.z(fib,new $APP.f(null,1,[$APP.gm,!0],null)),new $APP.f(null,3,[$APP.R,f2b,$APP.X,FM,$APP.h,$APP.F],null),$APP.z(OLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[eY],null))),$APP.P,"Returns the result of executing the supplied `thunk` in an environment where\n  the [[*rf-simplify*]] and [[*poly-simplify*]] are not memoized."],null)),new $APP.f(null,3,[$APP.R,EOb,$APP.X,function(a){var b=GM,c=FM,d=d1a(EH(h1a())),
g=d1a(EH(f1a()));GM=d;FM=g;try{return a.J?a.J():a.call(null)}finally{FM=c,GM=b}},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of executing the supplied `thunk` in an environment where\n  the [[*rf-simplify*]] and [[*poly-simplify*]] are not memoized.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[eY],null))],null)],null),$APP.z(kIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),$APP.P,"Simplifies an expression representing a complex number. TODO say more!"],
null)),new $APP.f(null,3,[$APP.R,wMb,$APP.X,z1a,$APP.h,new $APP.f(null,2,[$APP.P,"Simplifies an expression representing a complex number. TODO say more!",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null),$APP.z(JT,new $APP.f(null,1,[$APP.gm,!0],null)),new $APP.f(null,3,[$APP.R,AX,$APP.X,GM,$APP.h,$APP.F],null)],null),$APP.Zo(fV)),$APP.ap($APP.fg([$APP.z(CJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.z($APP.Mv,new $APP.f(null,1,[$APP.sj,
bob],null))],null))),$APP.P,"Returns a [[Literal]] generated by applying `f` to the expression part of\n  `e`.\n\n  [[literal-type]] and [[meta]] will return the same thing for `e` and the\n  return value."],null)),$APP.z(UFb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null)))],null)),MIb,$APP.z($APP.bxa,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null)))],null)),$APP.z(bKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))),$APP.P,"If `x` is a [[Literal]] instance, returns its type. Else, returns nil."],null)),$APP.z(PWb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,beb,$APP.Sh],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,ypb],null))),$APP.P,"Returns a form similar to `expr`, with all instances of `old` replaced by\n  `new`. Substitution occurs\n  in [postwalk](https://clojuredocs.org/clojure.walk/postwalk) order.\n\n  NOTE that this now works for expressions too.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Tw,beb,$APP.Sh],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,ypb],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,beb,$APP.Sh],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,ypb],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z($APP.sw,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[lO,$APP.mO],null))),$APP.P,"Comparator for expressions. The rule is that types have the following ordering:\n\n  - empty sequence is \x3c anything (except another empty seq)\n  - real \x3c symbol \x3c string \x3c sequence\n  - sequences compare element-by-element\n\n  Any types _not_ in this list compare with the other type using hashes."],
null)),$APP.z($APP.gya,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null)))],null)),$APP.z(JTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is a [[Literal]] instance, false otherwise."],null)),USb,$APP.z(HCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,Tlb,L6b],null))),$APP.P,"Walk the unwrapped expression `expr` in postorder, replacing symbols found\n  there with their values in the `sym-\x3evar` mapping, if present.\n\n  `sym-\x3ef` is used for elements in function application position (first of a\n  sequence)."],
null)),$APP.z(N7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Uu,$APP.Tw],null))),$APP.P,"Constructs a [[Literal]] instance with the supplied type and an empty metadata\n  map out of the literal form `expr`."],null)),$APP.z(zxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is both a [[Literal]] and has a type specified\n  in [[abstract-types]], false otherwise."],null)),$APP.z(F4b,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),$APP.P,"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`."],null)),$APP.z(Spb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,8,[kU,"null",WE,"null",Bvb,"null",lS,"null",LY,"null",gV,"null",y7b,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.Uu,peb,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,5,[kU,"null",lS,"null",gV,"null",y7b,"null",nT,"null"],null),null),$APP.P,"Positional factory function for emmy.expression/Literal."],null)),$APP.z(Eac,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tw,bU],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,bU,$APP.yu],null))),$APP.P,"Renders an expression through the simplifier and onto the stream.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,
$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Tw,bU],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,bU,$APP.yu],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tw,bU],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,bU,$APP.yu],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(A4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),$APP.P,"Return the set of 'variables' (e.g. symbols) found in `expr`.\n\n  `expr` is either a symbol, a [[Literal]] instance or some sequence\n  representing a symbolic expression."],
null)),$APP.z(ZZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),$APP.P,"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`."],null)),$APP.z(Nub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uu,DW,$APP.Mu],null))),$APP.P,"Similar to [[make-literal]], but accepts:\n\n  - some operation\n  - the arguments to which it applies\n\n  Similar to `clojure.core/apply`.\n\n  For example:\n\n  ```clojure\n  (literal-apply ::numeric 'cos [1 2 3])\n  ;;\x3d\x3e (cos 1 2 3)\n  ```"],
null))],[new $APP.f(null,3,[$APP.R,gbb,$APP.X,bTa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Literal]] generated by applying `f` to the expression part of\n  `e`.\n\n  [[literal-type]] and [[meta]] will return the same thing for `e` and the\n  return value.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.z($APP.Mv,new $APP.f(null,1,[$APP.sj,bob],null))],null))],null)],null),new $APP.f(null,3,[$APP.R,PAb,$APP.X,fTa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],
null))],null)],null),new $APP.f(null,3,[$APP.R,utb,$APP.X,lnc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,iIb,$APP.X,dTa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,O9b,$APP.X,aTa,$APP.h,new $APP.f(null,2,[$APP.P,"If `x` is a [[Literal]] instance, returns its type. Else, returns nil.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,ZGb,$APP.X,UZ,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a form similar to `expr`, with all instances of `old` replaced by\n  `new`. Substitution occurs\n  in [postwalk](https://clojuredocs.org/clojure.walk/postwalk) order.\n\n  NOTE that this now works for expressions too.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,beb,$APP.Sh],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,ypb],null))],null)],null),new $APP.f(null,3,[$APP.R,iqb,$APP.X,$F,$APP.h,new $APP.f(null,2,[$APP.P,"Comparator for expressions. The rule is that types have the following ordering:\n\n  - empty sequence is \x3c anything (except another empty seq)\n  - real \x3c symbol \x3c string \x3c sequence\n  - sequences compare element-by-element\n\n  Any types _not_ in this list compare with the other type using hashes.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[lO,$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,hib,$APP.X,function(a){return!$APP.kd(a)||$APP.Ge(function(b){var c=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return 0>=$F(c,b)},$APP.Jl.B(2,1,a))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,glb,$APP.X,XF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is a [[Literal]] instance, false otherwise.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Okb,$APP.X,fTa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,W7b,$APP.X,cTa,$APP.h,new $APP.f(null,2,[$APP.P,"Walk the unwrapped expression `expr` in postorder, replacing symbols found\n  there with their values in the `sym-\x3evar` mapping, if present.\n\n  `sym-\x3ef` is used for elements in function application position (first of a\n  sequence).",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,Tlb,L6b],null))],null)],null),
new $APP.f(null,3,[$APP.R,usb,$APP.X,ZSa,$APP.h,new $APP.f(null,2,[$APP.P,"Constructs a [[Literal]] instance with the supplied type and an empty metadata\n  map out of the literal form `expr`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Uu,$APP.Tw],null))],null)],null),new $APP.f(null,3,[$APP.R,yNb,$APP.X,function(a){return XF(a)&&$APP.Bd(lnc,a.type)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is both a [[Literal]] and has a type specified\n  in [[abstract-types]], false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,wib,$APP.X,YF,$APP.h,new $APP.f(null,2,[$APP.P,"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null),new $APP.f(null,3,[$APP.R,icb,$APP.X,YSa,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.expression/Literal.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uu,peb,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Owb,$APP.X,VZ,$APP.h,new $APP.f(null,2,[$APP.P,"Renders an expression through the simplifier and onto the stream.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tw,bU],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,bU,$APP.yu],null))],null)],null),new $APP.f(null,3,[$APP.R,fxb,$APP.X,ZF,$APP.h,new $APP.f(null,2,[$APP.P,"Return the set of 'variables' (e.g. symbols) found in `expr`.\n\n  `expr` is either a symbol, a [[Literal]] instance or some sequence\n  representing a symbolic expression.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null),new $APP.f(null,3,[$APP.R,uPb,$APP.X,eTa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null),new $APP.f(null,3,[$APP.R,mCb,$APP.X,$Sa,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[make-literal]], but accepts:\n\n  - some operation\n  - the arguments to which it applies\n\n  Similar to `clojure.core/apply`.\n\n  For example:\n\n  ```clojure\n  (literal-apply ::numeric 'cos [1 2 3])\n  ;;\x3d\x3e (cos 1 2 3)\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uu,DW,$APP.Mu],null))],null)],null)]),$APP.Zo(ugb)),$APP.ap(new $APP.f(null,5,[$APP.z(Bac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[aW,MV,$APP.SU,IW,$APP.aX],null))),$APP.P,"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt"],
null)),new $APP.f(null,3,[$APP.R,YIb,$APP.X,rab,$APP.h,new $APP.f(null,2,[$APP.P,"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[aW,MV,$APP.SU,IW,$APP.aX],null))],null)],null),$APP.z(abc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[aW,h1b],null))),$APP.P,"make-integrator takes a state derivative function (which in this\n  system is assumed to be a map from a structure to a structure of the\n  same shape, as differentiating a function does not change its\n  shape), and returns an integrator, which is a function of several\n  arguments:\n\n  - the initial state\n  - an intermediate-state observation function\n  - the step size desired\n  - the final time to seek, and\n  - an error tolerance.\n\n  If the `observe` function is not nil, it will be invoked with the time as\n  first argument and integrated state as the second, at each intermediate step."],
null)),new $APP.f(null,3,[$APP.R,L5b,$APP.X,qab,$APP.h,new $APP.f(null,2,[$APP.P,"make-integrator takes a state derivative function (which in this\n  system is assumed to be a map from a structure to a structure of the\n  same shape, as differentiating a function does not change its\n  shape), and returns an integrator, which is a function of several\n  arguments:\n\n  - the initial state\n  - an intermediate-state observation function\n  - the step size desired\n  - the final time to seek, and\n  - an error tolerance.\n\n  If the `observe` function is not nil, it will be invoked with the time as\n  first argument and integrated state as the second, at each intermediate step.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[aW,h1b],null))],null)],null),$APP.z(grb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null))),$APP.P,"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(aW,MV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null)),$APP.zx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.R,wcb,$APP.X,H4,$APP.h,new $APP.f(null,2,[$APP.P,"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null))],null)],null),$APP.z($APP.mNb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null))),$APP.P,"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.",$APP.hy,new $APP.f(null,6,[$APP.ru,
!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(aW,MV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null)),$APP.zx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.R,kpb,$APP.X,I4,$APP.h,new $APP.f(null,2,[$APP.P,"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null))],null)],null),$APP.z(Web,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.ZW,$APP.NW,ZTb,new $APP.f(null,2,[$APP.zu,new $APP.H(null,2,5,$APP.I,[$APP.XU,Kwb],null),$APP.Kl,new $APP.f(null,2,[$APP.XU,idc,Kwb,!1],null)],null)],null))),$APP.P,"Produces a function, monotonic in its single numeric argument,\n   that represents the integral of the function f' given the initial\n   data $y_0 \x3d f(x_0)$ and an options dictionary (presently containing\n   the tolerance for error $\\epsilon$, but eventually also selecting\n   from a menu of integration techniques).\n\n   This is done by creating an adaptive step-size ODE solver, and\n   advancing its steps as needed to supply function values. (This\n   architecture accounts for why the arguments to f must be presented\n   in order). Old solution segments are discarded. The goal of this\n   approach is to avoid the requirement of supplying an upper limit\n   to the integration. At the cost of requiring monotonic arguments\n   to f, the integrated function can essentially be used forever\n   without accumulating unbounded state.\n\n   The function `f'` should have the signature `[x y y']`, where `y'` is a\n   primitive double array, which the function should fill in based\n   on the values `x` and `y`.) Both `y` and `y'` will be primitive arrays\n   of type double, the same length as that of `y0`. Both arrays are\n   owned by the integrator. In particular, y should never be modified,\n   and neither array should be modified or expected to persist after\n   the return of `f'`. This approach has observable memory and\n   performance impacts.\n\n   The return value of the integrating function, however, is newly\n   allocated and belongs to the caller.\n\n   The integrating function may be called with no arguments to shut down\n   the integration, allowing for the final reclamation of its resources.\n\n   When the ODE solver is provided by Java, it may be necessary to\n   use an auxiliary thread to enable this style of flow control.  If\n   JavaScript, we expect the solver to provide a generator of solution\n   segments."],
null)),new $APP.f(null,3,[$APP.R,gec,$APP.X,mab,$APP.h,new $APP.f(null,2,[$APP.P,"Produces a function, monotonic in its single numeric argument,\n   that represents the integral of the function f' given the initial\n   data $y_0 \x3d f(x_0)$ and an options dictionary (presently containing\n   the tolerance for error $\\epsilon$, but eventually also selecting\n   from a menu of integration techniques).\n\n   This is done by creating an adaptive step-size ODE solver, and\n   advancing its steps as needed to supply function values. (This\n   architecture accounts for why the arguments to f must be presented\n   in order). Old solution segments are discarded. The goal of this\n   approach is to avoid the requirement of supplying an upper limit\n   to the integration. At the cost of requiring monotonic arguments\n   to f, the integrated function can essentially be used forever\n   without accumulating unbounded state.\n\n   The function `f'` should have the signature `[x y y']`, where `y'` is a\n   primitive double array, which the function should fill in based\n   on the values `x` and `y`.) Both `y` and `y'` will be primitive arrays\n   of type double, the same length as that of `y0`. Both arrays are\n   owned by the integrator. In particular, y should never be modified,\n   and neither array should be modified or expected to persist after\n   the return of `f'`. This approach has observable memory and\n   performance impacts.\n\n   The return value of the integrating function, however, is newly\n   allocated and belongs to the caller.\n\n   The integrating function may be called with no arguments to shut down\n   the integration, allowing for the final reclamation of its resources.\n\n   When the ODE solver is provided by Java, it may be necessary to\n   use an auxiliary thread to enable this style of flow control.  If\n   JavaScript, we expect the solver to provide a generator of solution\n   segments.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.ZW,$APP.NW,ZTb,new $APP.f(null,2,[$APP.zu,new $APP.H(null,2,5,$APP.I,[$APP.XU,Kwb],null),$APP.Kl,new $APP.f(null,2,[$APP.XU,idc,Kwb,!1],null)],null)],null))],null)],null)],null),$APP.Zo(F$b)),$APP.ap($APP.fg([$APP.z(Vsb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null))),$APP.P,"Return a [[PowerSeries]] starting with the supplied values. The remainder of\n  the series will be filled with the zero-value corresponding to the first of\n  the given values.\n\n  If you have a sequence already, prefer [[power-series*]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ox)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(LV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `s` is specifically a [[PowerSeries]], false otherwise."],null)),Pgb,uOb,$APP.z(CJb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(omb,new $APP.f(null,5,[VE,new $APP.ug(null,
new $APP.f(null,10,[SW,"null",hU,"null",WE,"null",rS,"null",lS,"null",LY,"null",gV,"null",uY,"null",nT,"null",RV,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,6,[SW,"null",rS,"null",lS,"null",gV,"null",uY,"null",nT,"null"],null),null),$APP.P,"Positional factory function for emmy.series/Series."],null)),$APP.z(LDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],
null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.$v,$APP.uU,0)],null)],null)))),$APP.P,"Returns a [[PowerSeries]] instance representing $x^n$."],null)),E6b,$APP.z(u1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.uU],null))),$APP.P,"Returns the sum of all elements in the input series `s` up to order\n  `n` (inclusive). For example:\n\n  ```clojure\n  (sum (series 1 1 1 1 1 1 1) 3)\n  ;; \x3d\x3e 4\n  ```\n\n  NOTE that [[sum]] sums the first `n + 1` terms, since a series starts with an\n  order 0 term."],
null)),$APP.z(E_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Accepts a [[Series]] or [[PowerSeries]] and coerces the input to\n  a [[PowerSeries]] without any application. Returns the coerced [[PowerSeries]]\n  instance.\n\n  Supplying a non-series will throw."],null)),$APP.z(YS,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[$APP.Jv,YV],null))),$APP.P,"Returns a [[PowerSeries]] representing the supplied constant term.\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[$APP.Jv,YV],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[$APP.Jv,YV],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(MAb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),$APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,YS],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(LV,$APP.Sv)],null)],null)))),$APP.P,"Returns a [[PowerSeries]] $U$ that represents the definite integral of the\n  input power series $S$ with constant term $c$:\n\n  ```\n  $$U \x3d c + \\int_0^{\\infty} S$$\n  ```",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,YS],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],
null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,YS],null)),$APP.zx,$APP.M(null,null)],null)],null)),YCb,$APP.z(qXb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,10,[SW,"null",hU,"null",WE,"null",rS,"null",lS,"null",LY,"null",gV,"null",uY,"null",nT,"null",RV,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,6,[SW,"null",rS,"null",lS,"null",gV,"null",uY,"null",nT,"null"],null),null),$APP.P,"Positional factory function for emmy.series/PowerSeries."],
null)),$APP.z(E7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null))),$APP.P,"Returns a [[PowerSeries]] instance representing a\n  [Binomial series](https://en.wikipedia.org/wiki/Binomial_series), i.e., the\n  taylor series of the function $f$ given by\n\n  ```\n  $$f(x) \x3d (1 + x)^\\alpha$$\n  ```"],null)),$APP.z(yeb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ox],null))),$APP.P,"Given a sequence, returns a new [[Series]] object that wraps that\n  sequence (potentially padding its tail with zeros if it's finite)."],
null)),$APP.z($APP.Cv,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null))),$APP.P,"Returns the value of the supplied [[Series]] or [[PowerSeries]] applied to `xs`.\n\n  If a [[PowerSeries]] is supplied, `xs` (despite its name) must be a single\n  value. Returns a [[Series]] generated by multiplying each `i`th term in `s` by\n  $x^i$, where $x$ is the `xs` argument.\n\n  If a [[Series]] `s` is supplied:\n\n  Assumes that `s` is a series of applicables of arity equal to the count of\n  `xs`. If, in fact, `s` is a series of series-valued applicables, then the\n  result will be a sort of layered sum of the values.\n\n  Concretely, suppose that `s` has the form:\n\n  ```\n  [x \x3d\x3e [A1 A2 A3...], x \x3d\x3e [B1 B2 B3...], x \x3d\x3e [C1 C2 C3...], ...]\n  ```\n\n  Then, this series applied to x will yield the new series:\n\n  ```\n  [A1 (+ A2 B1) (+ A3 B2 C1) ...]\n  ```\n\n  The way to think about this is, that if a power series has some other series\n  as the coefficient of the $x^n$ term, the series must shift by $n$ positions\n  before being added into the final total."],
null)),YSb,K1b,$APP.z($APP.Cx,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(qNb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null))),$APP.P,"Return a [[Series]] starting with the supplied values. The remainder of the\n  series will be filled with the zero-value corresponding to the first of the\n  given values.\n\n  If you have a sequence already, prefer [[series*]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,
5,$APP.I,[$APP.M($APP.ox)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(Y1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a series (of the same type as the input) of partial sums of the terms\n  in the supplied series `s`."],null)),$APP.z(ikb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.uU],null))),$APP.P,"Accepts an input series `s` and an exponent `n`, and expands the series in the\n  `n`th power of its argument. Every term `i` maps to position `i*n`, with zeros\n  padded in the new missing slots.\n\n  For example:\n\n  ```clojure\n  (inflate identity 3)\n  ;; \x3d\x3e (series 0 0 0 1)\n\n  (take 6 (inflate (generate inc) 3))\n  ;; \x3d\x3e (1 0 2 0 3 0)\n  ```\n\n  NOTE this operation makes sense as described for a [[PowerSeries]], where each\n  entry represents the coefficient of some power of `x`; functionally it still\n  works with [[Series]] objects."],
null)),rYb,$APP.z(jQb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,YV],null))),$APP.P,"Returns a [[PowerSeries]] generated by `(f i)` for `i` in `0, 1, ...`\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,
2,5,$APP.I,[$APP.Kv,YV],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,YV],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(mdb,new $APP.f(null,1,[$APP.Pu,!0],null)),s5b,BIb,$APP.z(vWb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null))),$APP.P,"Returns a [[PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) expansion of `f` at the\n  point specified by `xs`. Multiple arguments are allowed. If no arguments `xs`\n  are supplied, the expansion point defaults to 0.\n\n  The expansion at 0 is also called a 'Maclaurin series'.\n\n  NOTE: this function takes derivatives internally, so if you pass a function\n  make sure you require [[emmy.calculus.derivative]] to install the\n  derivative implementation for functions. If you pass some other callable,\n  differentiable function-like thing, like a polynomial, this is not necessary.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Ieb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `s` is either a [[Series]] or a [[PowerSeries]], false\n  otherwise."],null)),
$APP.z(YDb,new $APP.f(null,1,[$APP.Pu,!0],null)),RXb,$APP.z(dU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,mV],null))),$APP.P,"Given a univariate [[PowerSeries]] and a singleton sequence of `factors`,\n  returns a new [[PowerSeries]] that scales its argument by `(first factor)` on\n  application.\n\n  Given a [[Series]], recursively applies [[arg-scale]] to each element, making\n  this ONLY appropriate in its current form for a [[Series]] of [[PowerSeries]]\n  instances."],
null)),Fcb,$APP.z(a1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(LV,$APP.Sv)],null)],null)))),$APP.P,"Returns a new [[PowerSeries]] $U$ that represents the compositional inverse (the\n  'reversion') of the input power series $S$, satisfying:\n\n  ```\n  $$S(U(x)) \x3d x$$\n  ```"],null)),Gvb,$APP.z(FX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,
yY],null))),$APP.P,"Given a univariate [[PowerSeries]] and a singleton sequence of `shifts`,\n  returns a function that, when applied, returns a value equivalent to calling\n  the original `s` with its argument shifted by `(first shifts)`.\n\n  NOTE: [[arg-shift]] can't return a [[PowerSeries]] instance because the\n  implementation of [[compose]] does not currently allow a constant element in\n  the right-hand series.\n\n  Given a [[Series]], recursively applies [[arg-shift]] to each element, making\n  this ONLY appropriate in its current form for a [[Series]] of [[PowerSeries]]\n  instances. Returns a [[Series]] of functions."],
null)),ZIb,CHb,tqb,s1b,lYb,$APP.z($APP.KK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(LV,$APP.Sv),$APP.M(LV,$APP.Rv)],null)],null)))),$APP.P,"Returns a new [[PowerSeries]] $U$ that represents the composition of the two\n  input power series $S$ and $T$, where $U$ evaluates like:\n\n  ```\n  $$U(x) \x3d S(T(x))$$\n  ```"],null)),$APP.z(WJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ox],null))),$APP.P,"Given a sequence, returns a new [[PowerSeries]] object that wraps that\n  sequence (potentially padding its tail with zeros if it's finite)."],null)),I2b,u4b,uYb],[new $APP.f(null,3,[$APP.R,J2b,$APP.X,g1,$APP.h,new $APP.f(null,2,[$APP.P,"Return a [[PowerSeries]] starting with the supplied values. The remainder of\n  the series will be filled with the zero-value corresponding to the first of\n  the given values.\n\n  If you have a sequence already, prefer [[power-series*]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null))],null)],null),new $APP.f(null,3,[$APP.R,$bb,$APP.X,RI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is specifically a [[PowerSeries]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,W2b,$APP.X,p1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,UXb,$APP.X,r1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,LOb,$APP.X,VI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new series generated by applying the supplied `f` to each element in\n  the input series `s`. The returned series will be the same type as the input\n  series, either [[Series]] or [[PowerSeries]].\n\n  NOTE scmutils calls this `series:elementwise`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,JAb,$APP.X,OI,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.series/Series.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,pNb,$APP.X,function(a){return TI($APP.N.A($APP.Uj.A(a,0),new $APP.H(null,1,5,$APP.I,[1],null)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] instance representing $x^n$.",$APP.U,
$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.$v,$APP.uU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,aMb,$APP.X,u1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,SRb,$APP.X,TXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sum of all elements in the input series `s` up to order\n  `n` (inclusive). For example:\n\n  ```clojure\n  (sum (series 1 1 1 1 1 1 1) 3)\n  ;; \x3d\x3e 4\n  ```\n\n  NOTE that [[sum]] sums the first `n + 1` terms, since a series starts with an\n  order 0 term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,tzb,$APP.X,PXa,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a [[Series]] or [[PowerSeries]] and coerces the input to\n  a [[PowerSeries]] without any application. Returns the coerced [[PowerSeries]]\n  instance.\n\n  Supplying a non-series will throw.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,wwb,$APP.X,h1,$APP.h,new $APP.f(null,2,[$APP.P,
"Returns a [[PowerSeries]] representing the supplied constant term.\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[$APP.Jv,YV],null))],null)],null),new $APP.f(null,3,[$APP.R,qqb,$APP.X,k1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] $U$ that represents the definite integral of the\n  input power series $S$ with constant term $c$:\n\n  ```\n  $$U \x3d c + \\int_0^{\\infty} S$$\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),$APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,YS],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(LV,$APP.Sv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,xpb,$APP.X,l1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,gob,$APP.X,QI,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.series/PowerSeries.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Or],null))],null)],null),new $APP.f(null,
3,[$APP.R,Bhb,$APP.X,VXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] instance representing a\n  [Binomial series](https://en.wikipedia.org/wiki/Binomial_series), i.e., the\n  taylor series of the function $f$ given by\n\n  ```\n  $$f(x) \x3d (1 + x)^\\alpha$$\n  ```",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null))],null)],null),new $APP.f(null,3,[$APP.R,Nvb,$APP.X,SI,$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence, returns a new [[Series]] object that wraps that\n  sequence (potentially padding its tail with zeros if it's finite).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ox],null))],null)],null),new $APP.f(null,3,[$APP.R,Fec,$APP.X,function(a,b){return RI(a)?QXa(a,b):NXa(a)?UI(a,b):AD(["value only works on `Series` or `PowerSeries`; received ",$APP.m.j(a)].join(""))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the value of the supplied [[Series]] or [[PowerSeries]] applied to `xs`.\n\n  If a [[PowerSeries]] is supplied, `xs` (despite its name) must be a single\n  value. Returns a [[Series]] generated by multiplying each `i`th term in `s` by\n  $x^i$, where $x$ is the `xs` argument.\n\n  If a [[Series]] `s` is supplied:\n\n  Assumes that `s` is a series of applicables of arity equal to the count of\n  `xs`. If, in fact, `s` is a series of series-valued applicables, then the\n  result will be a sort of layered sum of the values.\n\n  Concretely, suppose that `s` has the form:\n\n  ```\n  [x \x3d\x3e [A1 A2 A3...], x \x3d\x3e [B1 B2 B3...], x \x3d\x3e [C1 C2 C3...], ...]\n  ```\n\n  Then, this series applied to x will yield the new series:\n\n  ```\n  [A1 (+ A2 B1) (+ A3 B2 C1) ...]\n  ```\n\n  The way to think about this is, that if a power series has some other series\n  as the coefficient of the $x^n$ term, the series must shift by $n$ positions\n  before being added into the final total.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,jSb,$APP.X,q1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,PIb,$APP.X,OK,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,dcb,$APP.X,ypc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Wtb,$APP.X,f1,$APP.h,new $APP.f(null,2,[$APP.P,"Return a [[Series]] starting with the supplied values. The remainder of the\n  series will be filled with the zero-value corresponding to the first of the\n  given values.\n\n  If you have a sequence already, prefer [[series*]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null))],null)],null),new $APP.f(null,3,[$APP.R,Vyb,$APP.X,SXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a series (of the same type as the input) of partial sums of the terms\n  in the supplied series `s`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,GWb,$APP.X,RXa,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts an input series `s` and an exponent `n`, and expands the series in the\n  `n`th power of its argument. Every term `i` maps to position `i*n`, with zeros\n  padded in the new missing slots.\n\n  For example:\n\n  ```clojure\n  (inflate identity 3)\n  ;; \x3d\x3e (series 0 0 0 1)\n\n  (take 6 (inflate (generate inc) 3))\n  ;; \x3d\x3e (1 0 2 0 3 0)\n  ```\n\n  NOTE this operation makes sense as described for a [[PowerSeries]], where each\n  entry represents the coefficient of some power of `x`; functionally it still\n  works with [[Series]] objects.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,JHb,$APP.X,o1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Lrb,$APP.X,i1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] generated by `(f i)` for `i` in `0, 1, ...`\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,YV],null))],
null)],null),new $APP.f(null,3,[$APP.R,Yzb,$APP.X,xpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,pjb,$APP.X,m1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,M5b,$APP.X,w1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Irb,$APP.X,j1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) expansion of `f` at the\n  point specified by `xs`. Multiple arguments are allowed. If no arguments `xs`\n  are supplied, the expansion point defaults to 0.\n\n  The expansion at 0 is also called a 'Maclaurin series'.\n\n  NOTE: this function takes derivatives internally, so if you pass a function\n  make sure you require [[emmy.calculus.derivative]] to install the\n  derivative implementation for functions. If you pass some other callable,\n  differentiable function-like thing, like a polynomial, this is not necessary.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,Evb,$APP.X,NXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is either a [[Series]] or a [[PowerSeries]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,bNb,$APP.X,wpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,rub,$APP.X,n1,$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.R,zzb,$APP.X,function Lsc(a,b){return RI(a)?UXa(a,TI(new $APP.H(null,2,5,$APP.I,[0,$APP.u(b)],null))):VI(function(d){return Lsc.A?Lsc.A(d,b):Lsc.call(null,d,b)},a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given a univariate [[PowerSeries]] and a singleton sequence of `factors`,\n  returns a new [[PowerSeries]] that scales its argument by `(first factor)` on\n  application.\n\n  Given a [[Series]], recursively applies [[arg-scale]] to each element, making\n  this ONLY appropriate in its current form for a [[Series]] of [[PowerSeries]]\n  instances.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,mV],null))],null)],null),new $APP.f(null,3,[$APP.R,oLb,$APP.X,Apc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,tRb,$APP.X,function(a){return QI(LXa($APP.r(a)),$APP.ed(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new [[PowerSeries]] $U$ that represents the compositional inverse (the\n  'reversion') of the input power series $S$, satisfying:\n\n  ```\n  $$S(U(x)) \x3d x$$\n  ```",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),
new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(LV,$APP.Sv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Sdc,$APP.X,s1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,X_b,$APP.X,function Msc(a,b){return RI(a)?$APP.Je.B(bI,a,b):VI(function(d){return Msc.A?Msc.A(d,b):Msc.call(null,d,b)},a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given a univariate [[PowerSeries]] and a singleton sequence of `shifts`,\n  returns a function that, when applied, returns a value equivalent to calling\n  the original `s` with its argument shifted by `(first shifts)`.\n\n  NOTE: [[arg-shift]] can't return a [[PowerSeries]] instance because the\n  implementation of [[compose]] does not currently allow a constant element in\n  the right-hand series.\n\n  Given a [[Series]], recursively applies [[arg-shift]] to each element, making\n  this ONLY appropriate in its current form for a [[Series]] of [[PowerSeries]]\n  instances. Returns a [[Series]] of functions.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,yY],null))],null)],null),new $APP.f(null,3,[$APP.R,z9b,$APP.X,zpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,HPb,$APP.X,Dpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,fDb,$APP.X,Cpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,XBb,$APP.X,x1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,spb,$APP.X,t1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,k6b,$APP.X,UXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new [[PowerSeries]] $U$ that represents the composition of the two\n  input power series $S$ and $T$, where $U$ evaluates like:\n\n  ```\n  $$U(x) \x3d S(T(x))$$\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(LV,$APP.Sv),$APP.M(LV,$APP.Rv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Ybb,$APP.X,TI,$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence, returns a new [[PowerSeries]] object that wraps that\n  sequence (potentially padding its tail with zeros if it's finite).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ox],null))],null)],null),new $APP.f(null,3,
[$APP.R,nkb,$APP.X,Bpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,$Fb,$APP.X,Epc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Efb,$APP.X,v1,$APP.h,$APP.F],null)]),$APP.Zo(e1b)),$APP.ap($APP.fg([$APP.z(EFb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null))),$APP.P,"Alternative definition of [[wedge]] in terms of alternation.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Mu)],null),$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(OV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[hWb],null))),$APP.P,"Returns true if the supplied `f` is a form field operator, false otherwise."],null)),$APP.z(QJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,oW],null))),$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a one-form field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3eoneform-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-form-field`'s component\n  functions will accept a single non-structural argument."],
null)),$APP.z(ebc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(SHb,$APP.Kv)],null)],null)))),$APP.P,"One of the two incompatible definitions of differential.\n\n  This differential is a special case of exterior derivative. The other one\n  lives at [[map/differential]]."],null)),$APP.z(C1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Hyb,xU],null))),$APP.P,
"Given a structure `w` of and a vector field basis `vector-basis`, returns a new\n  structure generated by applying the full vector basis to each element of `w`.\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [vb    (vf/coordinate-system-\x3evector-basis coordsys)\n        basis (coordinate-system-\x3eoneform-basis coordsys)\n        components (down d:dx d:dy)]\n    (\x3d components\n       (-\x3e components\n           (basis-components-\x3eoneform-field basis)\n           (oneform-field-\x3ebasis-components vb))))\n  ```"],
null)),dnb,$APP.z(wtb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,MHb],null))),$APP.P,"Given a structure of `components` functions defined on manifold points and and\n  a matching `oneform-basis` (of identical structure),\n\n  Returns a new one-form field that\n\n  - passes its vector-field argument to `oneform-basis`, returning a new\n    equivalent structure with each slot populated by functions from a manifold\n    point to the directional derivative (using the vector field) in that\n    coordinate direction\n\n  - contracts the result of that operation with the result of applying each\n    component in `components` to the manifold point.\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[oneform-field-\x3ebasis-components]]"],
null)),$APP.z(AUb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null))),$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation, returns a\n  one-form field.\n\n  The returned one-form field at each structural spot takes a vector field and\n  returns a function that takes the directional derivative in that coordinate's\n  direction using the vector field.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(oW,$APP.Vw,oS)],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null)),$APP.zx,$APP.M(null)],null)],null)),zNb,$APP.z(POb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Bv,oW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(OV,$APP.Bv)],null)],null)))),$APP.P,"Given a one-form field `form` and a `coordinate-system`, returns a function\n  from the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the form field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-oneform-field 'f R2-rect)]\n      ((oneform-field-\x3ecomponents f R2-rect)\n       (up 'x0 'y0))))\n\n  ;;\x3d\x3e (down (f_0 (up x0 y0))\n  ;;         (f_1 (up x0 y0)))\n  ```"],
null)),$APP.z(Wfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null))),$APP.P,"Returns true if the supplied `f` is an [form field of rank\n  n](https://en.wikipedia.org/wiki/Differential_form), false otherwise.\n\n  A form-field of rank n is an operator that takes n vector fields to a\n  real-valued function on the manifold."],null)),$APP.z(iDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-oneform-field` instances.\n\n  The one-form field at each structural spot takes a vector field and returns a\n  function that takes the directional derivative in that coordinate's direction\n  using the vector field.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-oneform-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied."],
null)),$APP.z(P4a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null))),$APP.P,"Returns the alternation of the supplied differential `form`."],null)),$APP.z(DIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Returns the rank of the supplied differential form `f`. Functions are treated\n  as differential forms of rank 0.\n\n  Throws for any non differential form supplied."],null)),$APP.z(OKb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),$APP.P,"Returns a form field that returns, for any supplied vector field `vf`, a\n  manifold function [[manifold/zero-manifold-function]] that maps every input\n  manifold `point` to the scalar value 0."],null)),$APP.z(zYb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null))),$APP.P,"Takes:\n\n  - a `down` tuple of `components` of the one-form field relative to\n    `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a full one-form field.\n\n  A one-field field is an operator that takes a vector field to a real-valued\n  function on the manifold.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.jP,$APP.z(N4a,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.lx],
null))),$APP.P,"Computes the wedge product of the sequence `fs` of one-forms.\n\n  Higher rank forms can be constructed from one-forms by wedging them together.\n  This antisymmetric tensor product is computed as a determinant. The purpose of\n  this is to allow us to use the construction dx^dy to compute the area\n  described by the vectors that are given to it.\n\n  See Spivak p275 v1 of 'Differential Geometry' to see the correct definition.\n  The key is that the wedge of the coordinate basis forms had better be the\n  volume element.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.lx],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(obb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Returns true if the supplied `f` is\n  a [One-form](https://en.wikipedia.org/wiki/One-form), false\n  otherwise.\n\n  A [One-form](https://en.wikipedia.org/wiki/One-form) takes a single vector\n  field to a real-valued function on the manifold."],
null))],[new $APP.f(null,3,[$APP.R,Dmb,$APP.X,H3,$APP.h,new $APP.f(null,2,[$APP.P,"Alternative definition of [[wedge]] in terms of alternation.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null))],null)],null),new $APP.f(null,3,[$APP.R,Cec,$APP.X,cP,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `f` is a form field operator, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[hWb],null))],null)],null),new $APP.f(null,3,[$APP.R,QPb,$APP.X,I4a,$APP.h,new $APP.f(null,
2,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a one-form field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3eoneform-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-form-field`'s component\n  functions will accept a single non-structural argument.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Vw,oW],null))],null)],null),new $APP.f(null,3,[$APP.R,gfb,$APP.X,kP,$APP.h,new $APP.f(null,2,[$APP.P,"One of the two incompatible definitions of differential.\n\n  This differential is a special case of exterior derivative. The other one\n  lives at [[map/differential]].",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(SHb,$APP.Kv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,eSb,$APP.X,M4a,$APP.h,
new $APP.f(null,2,[$APP.P,"Given a structure `w` of and a vector field basis `vector-basis`, returns a new\n  structure generated by applying the full vector basis to each element of `w`.\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [vb    (vf/coordinate-system-\x3evector-basis coordsys)\n        basis (coordinate-system-\x3eoneform-basis coordsys)\n        components (down d:dx d:dy)]\n    (\x3d components\n       (-\x3e components\n           (basis-components-\x3eoneform-field basis)\n           (oneform-field-\x3ebasis-components vb))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[Hyb,xU],null))],null)],null),new $APP.f(null,3,[$APP.R,Qzb,$APP.X,kP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,CIb,$APP.X,L4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a structure of `components` functions defined on manifold points and and\n  a matching `oneform-basis` (of identical structure),\n\n  Returns a new one-form field that\n\n  - passes its vector-field argument to `oneform-basis`, returning a new\n    equivalent structure with each slot populated by functions from a manifold\n    point to the directional derivative (using the vector field) in that\n    coordinate direction\n\n  - contracts the result of that operation with the result of applying each\n    component in `components` to the manifold point.\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[oneform-field-\x3ebasis-components]]",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,MHb],null))],null)],null),new $APP.f(null,3,[$APP.R,EIb,$APP.X,hP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation, returns a\n  one-form field.\n\n  The returned one-form field at each structural spot takes a vector field and\n  returns a function that takes the directional derivative in that coordinate's\n  direction using the vector field.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null))],null)],null),new $APP.f(null,3,[$APP.R,Qcb,$APP.X,UP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,qjb,$APP.X,H4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a one-form field `form` and a `coordinate-system`, returns a function\n  from the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the form field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-oneform-field 'f R2-rect)]\n      ((oneform-field-\x3ecomponents f R2-rect)\n       (up 'x0 'y0))))\n\n  ;;\x3d\x3e (down (f_0 (up x0 y0))\n  ;;         (f_1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Bv,oW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(OV,$APP.Bv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,tbc,$APP.X,D4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `f` is an [form field of rank\n  n](https://en.wikipedia.org/wiki/Differential_form), false otherwise.\n\n  A form-field of rank n is an operator that takes n vector fields to a\n  real-valued function on the manifold.",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,vT,$APP.X,iP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-oneform-field` instances.\n\n  The one-form field at each structural spot takes a vector field and returns a\n  function that takes the directional derivative in that coordinate's direction\n  using the vector field.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-oneform-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,l8b,$APP.X,Q4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the alternation of the supplied differential `form`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null))],null)],null),new $APP.f(null,3,[$APP.R,ygb,$APP.X,aP,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the rank of the supplied differential form `f`. Functions are treated\n  as differential forms of rank 0.\n\n  Throws for any non differential form supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,INb,$APP.X,B4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a form field that returns, for any supplied vector field `vf`, a\n  manifold function [[manifold/zero-manifold-function]] that maps every input\n  manifold `point` to the scalar value 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))],null)],null),new $APP.f(null,3,[$APP.R,bUb,$APP.X,gP,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - a `down` tuple of `components` of the one-form field relative to\n    `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a full one-form field.\n\n  A one-field field is an operator that takes a vector field to a real-valued\n  function on the manifold.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null))],null)],null),new $APP.f(null,3,[$APP.R,Rsb,$APP.X,UP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ohb,$APP.X,F3,$APP.h,new $APP.f(null,2,[$APP.P,"Computes the wedge product of the sequence `fs` of one-forms.\n\n  Higher rank forms can be constructed from one-forms by wedging them together.\n  This antisymmetric tensor product is computed as a determinant. The purpose of\n  this is to allow us to use the construction dx^dy to compute the area\n  described by the vectors that are given to it.\n\n  See Spivak p275 v1 of 'Differential Geometry' to see the correct definition.\n  The key is that the wedge of the coordinate basis forms had better be the\n  volume element.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.lx],null))],null)],null),new $APP.f(null,3,[$APP.R,gLb,$APP.X,E4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `f` is\n  a [One-form](https://en.wikipedia.org/wiki/One-form), false\n  otherwise.\n\n  A [One-form](https://en.wikipedia.org/wiki/One-form) takes a single vector\n  field to a real-valued function on the manifold.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Kv],null))],null)],null)]),$APP.Zo(lOb)),$APP.ap($APP.fg([Fdb,Xzb,Shb,C4b,Vob,$APP.z(GX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hUb,iUb],null))),$APP.P,"Returns the symbolic dot product of the two supplied numbers `z1` and `z2`.\n\n  If both are numbers, defers to [[emmy.generic/dot-product]]. Else,\n  returns\n\n  $$\\Re(z_1)\\Re(z_2) + \\Im(z_1)\\Im(z_2)$$"],null)),ueb,$APP.z(xYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],
null))),$APP.P,"Given a symbol (like `'+`) returns an applicable operator if there is a\n  corresponding symbolic operator construction available."],null)),Ykb,$APP.z(ttb,new $APP.f(null,1,[$APP.gm,!0],null)),FJ,HQb,aPb,$APP.z(k3b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null)))],null))],[new $APP.f(null,3,[$APP.R,R2b,$APP.X,hH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Jac,$APP.X,fH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,bHb,$APP.X,nWa,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.R,OYb,$APP.X,Ync,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,D7b,$APP.X,$APP.u,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,rEb,$APP.X,mWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the symbolic dot product of the two supplied numbers `z1` and `z2`.\n\n  If both are numbers, defers to [[emmy.generic/dot-product]]. Else,\n  returns\n\n  $$\\Re(z_1)\\Re(z_2) + \\Im(z_1)\\Im(z_2)$$",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hUb,iUb],null))],null)],null),new $APP.f(null,
3,[$APP.R,ddb,$APP.X,y0a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,sub,$APP.X,DH,$APP.h,new $APP.f(null,2,[$APP.P,"Given a symbol (like `'+`) returns an applicable operator if there is a\n  corresponding symbolic operator construction available.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,edb,$APP.X,Xnc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,UWb,$APP.X,RM,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,enb,$APP.X,$nc,$APP.h,$APP.F],
null),new $APP.f(null,3,[$APP.R,XPb,$APP.X,bH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,urb,$APP.X,$APP.Fc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,SYb,$APP.X,aWa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null)]),$APP.Zo(U6b)),$APP.ap(new $APP.f(null,5,[$APP.z(lpb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv],null),new $APP.H(null,4,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv,gdc],null),new $APP.H(null,
5,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv,$APP.Pv,vU],null))),$APP.P,"Function with an identical interface to [[richardson-sequence]], except for an\n  additional second argument `col`.\n\n  `richardson-column` will return that _column_ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  Richardson accelerations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the Richardson tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a single acceleration by combining points\n  from column 0; `2` kills two terms from the error sequence, etc.\n\n  NOTE Given a better interface for [[richardson-sequence]] this function could\n  be merged with that function.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,5,$APP.nw,5,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv],null),new $APP.H(null,4,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv,gdc],null),new $APP.H(null,5,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv,$APP.Pv,vU],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv],null),new $APP.H(null,4,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv,gdc],null),new $APP.H(null,5,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv,$APP.Pv,vU],null)),$APP.zx,
$APP.M(null,null,null)],null)],null)),new $APP.f(null,3,[$APP.R,hwb,$APP.X,a4,$APP.h,new $APP.f(null,2,[$APP.P,"Function with an identical interface to [[richardson-sequence]], except for an\n  additional second argument `col`.\n\n  `richardson-column` will return that _column_ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  Richardson accelerations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the Richardson tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a single acceleration by combining points\n  from column 0; `2` kills two terms from the error sequence, etc.\n\n  NOTE Given a better interface for [[richardson-sequence]] this function could\n  be merged with that function.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv],null),new $APP.H(null,4,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv,gdc],null),new $APP.H(null,5,5,$APP.I,[$APP.fx,$APP.Ox,$APP.Rv,$APP.Pv,vU],null))],null)],null),$APP.z(SAb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Rv,$APP.Lh,$APP.Lx],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns the best approximation of `A(0)` using the algorithm described\n  in [[richardson-sequence]].\n\n  Equivalent to `(last ([[richardson-sequence]] t))`\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Rv,$APP.Lx)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Rv,$APP.Lh,$APP.Lx],null)),$APP.zx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.R,Job,$APP.X,c4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns the best approximation of `A(0)` using the algorithm described\n  in [[richardson-sequence]].\n\n  Equivalent to `(last ([[richardson-sequence]] t))`\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Rv,$APP.Lh,$APP.Lx],null))],null)],null),$APP.z(ufb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Rv,$APP.Lh,$APP.Lx],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns a lazy sequence of successive approximations `A(0)` using the\n  algorithm described in [[richardson-sequence]].\n\n  Equivalent to `([[richardson-sequence]] t)`.\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Rv,$APP.Lx)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Rv,$APP.Lh,$APP.Lx],null)),$APP.zx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.R,zDb,$APP.X,d4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns a lazy sequence of successive approximations `A(0)` using the\n  algorithm described in [[richardson-sequence]].\n\n  Equivalent to `([[richardson-sequence]] t)`.\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Rv,$APP.Lh,$APP.Lx],null))],null)],null),$APP.z(Uac,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Rv],null),new $APP.H(null,3,5,$APP.I,[$APP.fx,$APP.Rv,Oob],null),new $APP.H(null,4,5,$APP.I,[$APP.fx,$APP.Rv,$APP.Pv,vU],null))),$APP.P,"Takes:\n\n  - `xs`: a (potentially lazy) sequence of points representing function values\n  generated by inputs continually decreasing by a factor of `t`. For example:\n  `[f(x), f(x/t), f(x/t^2), ...]`\n  - `t`: the ratio between successive inputs that generated `xs`.\n\n  And returns a new (lazy) sequence of 'accelerated' using [Richardson\n  extrapolation](https://en.wikipedia.org/wiki/Richardson_extrapolation) to\n  cancel out error terms in the taylor series expansion of `f(x)` around the\n  value the series to which the series is trying to converge.\n\n  Each term in the returned sequence cancels one of the error terms through a\n  linear combination of neighboring terms in the sequence.\n\n  ### Custom P Sequence\n\n  The three-arity version takes one more argument:\n\n  - `p-sequence`: the orders of the error terms in the taylor series expansion\n  of the function that `xs` is estimating. For example, if `xs` is generated\n  from some `f(x)` trying to approximate `A`, then `[p_1, p_2...]` etc are the\n  correction terms:\n\n  ```\n  $$f(x) \x3d A + B x^{p_1} + C x^{p_2}...$$\n  ```\n\n  The two-arity version uses a default `p-sequence` of `[1, 2, 3, ...]`\n\n  ### Arithmetic Progression\n\n  The FOUR arity version takes `xs` and `t` as before, but instead of\n  `p-sequence` makes the assumption that `p-sequence` is an arithmetic\n  progression of the form `p + iq`, customized by:\n\n  - `p`: the exponent on the highest-order error term\n  - `q`: the step size on the error term exponent for each new seq element\n\n  ## Notes\n\n  Richardson extrapolation is a special case of polynomial extrapolation,\n  implemented in `polynomial.cljc`.\n\n  Instead of a sequence of `xs`, if you generate an explicit series of points of\n  the form `[x (f x)]` with successively smaller `x` values and\n  polynomial-extrapolate it forward to x \x3d\x3d 0 (with,\n  say, `(polynomial/modified-neville xs 0)`) you'll get the exact same result.\n\n  Richardson extrapolation is more efficient since it can make assumptions about\n  the spacing between points and pre-calculate a few quantities. See the\n  namespace for more discussion.\n\n  References:\n\n  - Wikipedia, [\"Richardson Extrapolation\"](https://en.wikipedia.org/wiki/Richardson_extrapolation)\n  - GJS, ['Abstraction in Numerical Methods'](https://dspace.mit.edu/bitstream/handle/1721.1/6060/AIM-997.pdf?sequence\x3d2)",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Rv],null),new $APP.H(null,3,5,$APP.I,[$APP.fx,$APP.Rv,Oob],null),new $APP.H(null,4,5,$APP.I,[$APP.fx,$APP.Rv,$APP.Pv,vU],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Rv],null),new $APP.H(null,3,5,$APP.I,[$APP.fx,$APP.Rv,Oob],null),new $APP.H(null,4,5,$APP.I,[$APP.fx,$APP.Rv,$APP.Pv,vU],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),new $APP.f(null,
3,[$APP.R,opb,$APP.X,GQ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - `xs`: a (potentially lazy) sequence of points representing function values\n  generated by inputs continually decreasing by a factor of `t`. For example:\n  `[f(x), f(x/t), f(x/t^2), ...]`\n  - `t`: the ratio between successive inputs that generated `xs`.\n\n  And returns a new (lazy) sequence of 'accelerated' using [Richardson\n  extrapolation](https://en.wikipedia.org/wiki/Richardson_extrapolation) to\n  cancel out error terms in the taylor series expansion of `f(x)` around the\n  value the series to which the series is trying to converge.\n\n  Each term in the returned sequence cancels one of the error terms through a\n  linear combination of neighboring terms in the sequence.\n\n  ### Custom P Sequence\n\n  The three-arity version takes one more argument:\n\n  - `p-sequence`: the orders of the error terms in the taylor series expansion\n  of the function that `xs` is estimating. For example, if `xs` is generated\n  from some `f(x)` trying to approximate `A`, then `[p_1, p_2...]` etc are the\n  correction terms:\n\n  ```\n  $$f(x) \x3d A + B x^{p_1} + C x^{p_2}...$$\n  ```\n\n  The two-arity version uses a default `p-sequence` of `[1, 2, 3, ...]`\n\n  ### Arithmetic Progression\n\n  The FOUR arity version takes `xs` and `t` as before, but instead of\n  `p-sequence` makes the assumption that `p-sequence` is an arithmetic\n  progression of the form `p + iq`, customized by:\n\n  - `p`: the exponent on the highest-order error term\n  - `q`: the step size on the error term exponent for each new seq element\n\n  ## Notes\n\n  Richardson extrapolation is a special case of polynomial extrapolation,\n  implemented in `polynomial.cljc`.\n\n  Instead of a sequence of `xs`, if you generate an explicit series of points of\n  the form `[x (f x)]` with successively smaller `x` values and\n  polynomial-extrapolate it forward to x \x3d\x3d 0 (with,\n  say, `(polynomial/modified-neville xs 0)`) you'll get the exact same result.\n\n  Richardson extrapolation is more efficient since it can make assumptions about\n  the spacing between points and pre-calculate a few quantities. See the\n  namespace for more discussion.\n\n  References:\n\n  - Wikipedia, [\"Richardson Extrapolation\"](https://en.wikipedia.org/wiki/Richardson_extrapolation)\n  - GJS, ['Abstraction in Numerical Methods'](https://dspace.mit.edu/bitstream/handle/1721.1/6060/AIM-997.pdf?sequence\x3d2)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Rv],null),new $APP.H(null,3,5,$APP.I,[$APP.fx,$APP.Rv,Oob],null),new $APP.H(null,4,5,$APP.I,[$APP.fx,$APP.Rv,$APP.Pv,vU],null))],null)],null),$APP.z(Xpb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,3,5,$APP.I,[$APP.Rv,KCb,nxb],null))),$APP.P,"Returns a fold expected to process the outputs of some function `A` for inputs\n  of the form:\n\n  $$A(h), A(h/t), A(h/t^2) \\ldots$$\n\n  and generate (when present is called) successively tighter estimates of A(0)\n  using the algorithm described in [[richardson-sequence]].\n\n  Takes as a required argument:\n\n  - `t`: the ratio between the successive inputs that generated the\n    data to be processed by this fold (see above)\n\n\n  If `initial-p` and `next-p-fn` are not supplied, it's assumed that the order\n  of the error terms in the taylor series expansion of `A` start at 1 and\n  increase by 1 with each new term.\n\n  You can tune this by supplying:\n\n  - `initial-p`: The order of the first error term\n  - `next-p-fn`: a function that will generate the next term given the previous\n    term\n\n  For the geometrically increasing error series `[2, 4, 6, 8]`, for example,\n  try\n\n  ```clj\n  (richardson-fold \x3ct\x3e 2 #(+ % 2))\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,3,5,$APP.I,[$APP.Rv,KCb,nxb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,3,5,$APP.I,[$APP.Rv,KCb,nxb],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,XIb,$APP.X,b4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a fold expected to process the outputs of some function `A` for inputs\n  of the form:\n\n  $$A(h), A(h/t), A(h/t^2) \\ldots$$\n\n  and generate (when present is called) successively tighter estimates of A(0)\n  using the algorithm described in [[richardson-sequence]].\n\n  Takes as a required argument:\n\n  - `t`: the ratio between the successive inputs that generated the\n    data to be processed by this fold (see above)\n\n\n  If `initial-p` and `next-p-fn` are not supplied, it's assumed that the order\n  of the error terms in the taylor series expansion of `A` start at 1 and\n  increase by 1 with each new term.\n\n  You can tune this by supplying:\n\n  - `initial-p`: The order of the first error term\n  - `next-p-fn`: a function that will generate the next term given the previous\n    term\n\n  For the geometrically increasing error series `[2, 4, 6, 8]`, for example,\n  try\n\n  ```clj\n  (richardson-fold \x3ct\x3e 2 #(+ % 2))\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,3,5,$APP.I,[$APP.Rv,KCb,nxb],null))],null)],null)],null),$APP.Zo(Ywb)),$APP.ap($APP.fg([$APP.z(Sab,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,2,5,$APP.I,[xS,$APP.Ey],null))),$APP.P,"Takes a `pattern` or matcher combinator, and returns a function from a data\n  object to either:\n\n  - A successful map of bindings extracted by matching the supplied `pattern` or\n    combinator to the input data\n  - An explicit `failure` object\n\n  Check for failure with [[failed?]].\n\n  Optionally, you can supply a predicate `pred`. `pred` takes the map of\n  bindings from a successful match and returns either:\n\n  - `nil`, `false` or the explicit `failure` object to force a match failure,\n    potentially causing a backtrack back into the data\n  - a map of NEW bindings to merge into the binding map (and signal success)\n\n  Any other truthy value signals success with no new bindings.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,2,5,$APP.I,[xS,$APP.Ey],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,2,5,$APP.I,[xS,$APP.Ey],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z($APP.uDa,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null))),$APP.P,"Takes a binding variable `sym` and an optional predicate `pred`, and returns a\n  matcher that binds its input to `sym` in the returned `frame`.\n\n  The returned matcher only succeeds if `input` passes `pred`.\n\n  If `sym` is already present in `frame`, the matcher only succeeds if the\n  values are equal, fails otherwise.\n\n  NOTE: If `sym` is the wildcard `_`, the returned matcher will not introduce a\n  new binding, but _will_ still check the predicate.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z($APP.io,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Lh,$APP.Ww],
null))),$APP.P,"Takes a sequence of patterns and returns a matcher that will apply its\n  arguments to the first pattern;\n\n  If that match succeeds, the next pattern will be called with the new, returned\n  frame (and the original data and success continuation).\n\n  The returned matcher succeeds only of all patterns succeed, and returns the\n  value of the final pattern.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,
[xS],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(lwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[xS,$APP.Kv,$APP.ax],null))),$APP.P,"Convenience function that creates a [[foreach-matcher]] from the supplied\n  `pattern` and callback `f` and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((foreach-matcher pattern pred) data)\n  ```"],
null)),$APP.z(Ngb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[tsb],null))),$APP.P,"Takes a `new-frame` of bindings and returns a matcher that will ignore its\n  input and always succeed by replacing the current map of bindings with\n  `new-frame`."],null)),$APP.z(y2b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ey,QV],null),new $APP.H(null,3,5,$APP.I,[$APP.Ey,QV,LLb],null))),$APP.P,"Returns a matcher that passes its `frame` on to `success-pattern` if `pred`\n  succeeds on its data input, `fail-pattern` otherwise.\n\n  If no `fail-matcher` is supplied, the behavior is equivalent\n  to [[match-when]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Ey,QV],null),new $APP.H(null,3,5,$APP.I,[$APP.Ey,QV,LLb],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ey,QV],null),new $APP.H(null,3,5,$APP.I,[$APP.Ey,QV,LLb],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(bX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,tCb],null))),$APP.P,
"Takes some input `x` and returns a matcher which succeeds if its data input is\n  equal to `x` (via `\x3d` or the optional `eq-fn` argument). Fails otherwise.\n\n  The frame is not modified.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,tCb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,tCb],null)),$APP.zx,$APP.M(null,
null)],null)],null)),$APP.z(sqb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.Mu],null))),$APP.P,"Takes a function from `frame` to a new frame (or false) and any number of\n  arguments `args`, and returns a matcher that will ignore its input and\n\n  - succeed with `(apply f frame args)` if that value is truthy,\n  - fail otherwise.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Kv,$APP.Mu)],
null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.Mu],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(lFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ey],null))),$APP.P,"Takes a predicate function `pred` and returns a matcher that succeeds (with no\n  new bindings) if its data input passes the predicate, fails otherwise."],null)),$APP.z($APP.Gu,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Takes a `pattern` and returns a matcher that will apply its arguments to the\n  `pattern`. The returned pattern will succeed with the original frame if\n  `pattern` fails, and fail if `pattern` succeeds."],
null)),$APP.z(cfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.Hv,$APP.Hv],null))),$APP.P,"Matcher which will fail for any input."],null)),$APP.z($APP.rAa,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,kY],null))),$APP.P,"Takes a sequence of patterns and returns a matcher that accepts a sequential\n  data input, and attempts to match successive items (or segments) in the\n  sequence with the supplied patterns.\n\n  The returned matcher succeeds if `patterns` can consume all elements, fails\n  otherwise (or of any of the supplied patterns fails on its argument).\n\n  On success, the returned matcher calls its success continuation with a frame\n  processed by each pattern in sequence.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(kY)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,kY],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(VRb,new $APP.f(null,4,[ZX,!0,$APP.lw,$APP.nj,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WEb],null))),$APP.P,"Factory function for emmy.pattern.match/Failure, taking a map of keywords to field values."],null)),$APP.z($APP.sdc,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null))),$APP.P,"Takes a binding variable `sym` and returns a matcher that calls its success\n  continuation with successively longer prefixes of its (sequential) data input\n  bound to `sym` inside the frame.\n\n  If `sym` is already present in the frame, the returned matcher only succeeds\n  if the bound value is a prefix of the data argument `xs`.\n\n  If `sym` matches the wildcard symbol `_`, the behavior is the same, but no new\n  binding is introduced.\n\n  NOTE: the returned matcher will call its success continuation with TWO\n  arguments; the new frame and the remaining elements in `xs`. This is a\n  different contract than all other matchers, making `segment` appropriate for\n  use inside `sequence`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Ibc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[pT,$APP.Hv,cac],null))),$APP.P,"Matcher that succeeds (with no new bindings) for any input, passing along its\n  input frame."],
null)),$APP.z(yzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ey],null))),$APP.P,"Takes a predicate function `pred` and returns a matcher that succeeds (with no\n  new bindings) if its data input passes the predicate, fails otherwise."],null)),$APP.z(nwb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null))),$APP.P,"Returns a matcher that takes a binding variable `sym`, and succeeds if it's\n  called with a sequential data argument with a prefix that is the REVERSE of\n  the sequence bound to `sym` in `frame`.\n\n  Fails if any of the following are true:\n\n  - `sym` is not bound in the frame\n  - `sym` is bound to something other than a vector prefix created by `segment`\n  - the data argument does not have a prefix matching the reverse of vector\n    bound to `sym`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(v5b,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(sib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xS,$APP.ax],null))),$APP.P,
"Convenience function that creates an [[all-results-matcher]] from the supplied\n  `pattern` and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((all-results-matcher pattern pred) data)\n  ```"],null)),$APP.z(gJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is equivalent to the failure sentinel [[failure]], false\n  otherwise."],null)),UGb,$APP.z(aIb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[xS,$APP.ax],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Ey,$APP.ax],null))),$APP.P,"Convenience function that creates a matcher from the supplied `pattern` (and\n  optional predicate `pred`) and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((matcher pattern pred) data)\n  ```",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[xS,$APP.ax],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Ey,$APP.ax],
null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xS,$APP.ax],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Ey,$APP.ax],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(KHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Takes a matcher and returns `f` with its metadata modified such\n  that [[segment-matcher?]] will return `true` when applied to `f`."],null)),$APP.z(ZLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[xS],null))),$APP.P,"Takes a `pattern` and callback function `f`, and returns a matcher that takes a\n  `data` argument and returns a sequence of every possible match of `pattern` to\n  the data.\n\n  For a convenience function that applies the matcher to data immediately,\n  see [[all-results]].\n\n  NOTE: If you pass a segment matcher, `f` must accept two arguments - the\n  binding map, and the sequence of all remaining items that the segment\n  matcher rejected."],null)),$APP.z(PLb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[kY],null))),$APP.P,"Version of [[sequence]] that takes an explicit sequence of `patterns`, vs the\n  multi-arity version. See [[sequence]] for documentation."],null)),$APP.z(jRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ey,QV],null))),$APP.P,"Returns a matcher that passes its `frame` on to `success-pattern` if `pred`\n  succeeds on its data input, fails otherwise."],null)),$APP.z(iVb,new $APP.f(null,4,
[ZX,!0,$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"Positional factory function for emmy.pattern.match/Failure."],null)),$APP.z(WIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xS,$APP.Kv],null))),$APP.P,"Takes a `pattern` and side-effecting callback function `f`, and returns a\n  matcher that calls `f` with a map of bindings for every possible match of\n  `pattern` to its input data.\n\n  For a convenience function that applies the matcher to data immediately,\n  see [[foreach]].\n\n  NOTE: If you pass a segment matcher, `f` must accept two arguments - the\n  binding map, and the sequence of all remaining items that the segment\n  matcher rejected."],
null)),$APP.z($APP.no,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Lh,$APP.Ww],null))),$APP.P,"Takes a sequence of patterns, and returns a matcher that will apply its\n  arguments to each matcher in turn. Returns the value of the first pattern that\n  succeeds.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[xS],null)],null),$APP.U,
$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null)],null)],null))],[new $APP.f(null,3,[$APP.R,dXb,$APP.X,iJ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `pattern` or matcher combinator, and returns a function from a data\n  object to either:\n\n  - A successful map of bindings extracted by matching the supplied `pattern` or\n    combinator to the input data\n  - An explicit `failure` object\n\n  Check for failure with [[failed?]].\n\n  Optionally, you can supply a predicate `pred`. `pred` takes the map of\n  bindings from a successful match and returns either:\n\n  - `nil`, `false` or the explicit `failure` object to force a match failure,\n    potentially causing a backtrack back into the data\n  - a map of NEW bindings to merge into the binding map (and signal success)\n\n  Any other truthy value signals success with no new bindings.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,2,5,$APP.I,[xS,$APP.Ey],null))],null)],null),new $APP.f(null,3,[$APP.R,Xub,$APP.X,pK,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a binding variable `sym` and an optional predicate `pred`, and returns a\n  matcher that binds its input to `sym` in the returned `frame`.\n\n  The returned matcher only succeeds if `input` passes `pred`.\n\n  If `sym` is already present in `frame`, the matcher only succeeds if the\n  values are equal, fails otherwise.\n\n  NOTE: If `sym` is the wildcard `_`, the returned matcher will not introduce a\n  new binding, but _will_ still check the predicate.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null))],null)],null),new $APP.f(null,3,[$APP.R,e7b,$APP.X,sK,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a sequence of patterns and returns a matcher that will apply its\n  arguments to the first pattern;\n\n  If that match succeeds, the next pattern will be called with the new, returned\n  frame (and the original data and success continuation).\n\n  The returned matcher succeeds only of all patterns succeed, and returns the\n  value of the final pattern.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,Ymb,$APP.X,function(a,b,c){return qYa(a,b)(c)},$APP.h,new $APP.f(null,2,[$APP.P,"Convenience function that creates a [[foreach-matcher]] from the supplied\n  `pattern` and callback `f` and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((foreach-matcher pattern pred) data)\n  ```",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,
[xS,$APP.Kv,$APP.ax],null))],null)],null),new $APP.f(null,3,[$APP.R,YHb,$APP.X,function(a){return function(b,c,d){return d.j?d.j(a):d.call(null,a)}},$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `new-frame` of bindings and returns a matcher that will ignore its\n  input and always succeed by replacing the current map of bindings with\n  `new-frame`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[tsb],null))],null)],null),new $APP.f(null,3,[$APP.R,TZb,$APP.X,N1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matcher that passes its `frame` on to `success-pattern` if `pred`\n  succeeds on its data input, `fail-pattern` otherwise.\n\n  If no `fail-matcher` is supplied, the behavior is equivalent\n  to [[match-when]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ey,QV],null),new $APP.H(null,3,5,$APP.I,[$APP.Ey,QV,LLb],null))],null)],null),new $APP.f(null,3,[$APP.R,dcc,$APP.X,M1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes some input `x` and returns a matcher which succeeds if its data input is\n  equal to `x` (via `\x3d` or the optional `eq-fn` argument). Fails otherwise.\n\n  The frame is not modified.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,tCb],null))],null)],
null),new $APP.f(null,3,[$APP.R,t2b,$APP.X,L1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function from `frame` to a new frame (or false) and any number of\n  arguments `args`, and returns a matcher that will ignore its input and\n\n  - succeed with `(apply f frame args)` if that value is truthy,\n  - fail otherwise.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.Mu],null))],null)],null),new $APP.f(null,3,[$APP.R,nVb,$APP.X,jYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a predicate function `pred` and returns a matcher that succeeds (with no\n  new bindings) if its data input passes the predicate, fails otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ey],null))],null)],null),new $APP.f(null,3,[$APP.R,Yhb,$APP.X,lYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `pattern` and returns a matcher that will apply its arguments to the\n  `pattern`. The returned pattern will succeed with the original frame if\n  `pattern` fails, and fail if `pattern` succeeds.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,Kcb,$APP.X,gYa,$APP.h,new $APP.f(null,2,[$APP.P,"Matcher which will fail for any input.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.Hv,$APP.Hv],null))],null)],null),new $APP.f(null,3,[$APP.R,sac,$APP.X,Q1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a sequence of patterns and returns a matcher that accepts a sequential\n  data input, and attempts to match successive items (or segments) in the\n  sequence with the supplied patterns.\n\n  The returned matcher succeeds if `patterns` can consume all elements, fails\n  otherwise (or of any of the supplied patterns fails on its argument).\n\n  On success, the returned matcher calls its success continuation with a frame\n  processed by each pattern in sequence.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,kY],null))],null)],null),new $APP.f(null,3,[$APP.R,WNb,$APP.X,function(a){var b=$APP.Oi.j(a);a=$APP.nd(a)?$APP.Lf.A($APP.F,b):b;return new gJ(null,$APP.re(a),null)},$APP.h,new $APP.f(null,2,[$APP.P,"Factory function for emmy.pattern.match/Failure, taking a map of keywords to field values.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WEb],null))],null)],null),new $APP.f(null,3,[$APP.R,gRb,$APP.X,O1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a binding variable `sym` and returns a matcher that calls its success\n  continuation with successively longer prefixes of its (sequential) data input\n  bound to `sym` inside the frame.\n\n  If `sym` is already present in the frame, the returned matcher only succeeds\n  if the bound value is a prefix of the data argument `xs`.\n\n  If `sym` matches the wildcard symbol `_`, the behavior is the same, but no new\n  binding is introduced.\n\n  NOTE: the returned matcher will call its success continuation with TWO\n  arguments; the new frame and the remaining elements in `xs`. This is a\n  different contract than all other matchers, making `segment` appropriate for\n  use inside `sequence`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null))],null)],null),new $APP.f(null,3,[$APP.R,xwb,$APP.X,hYa,$APP.h,new $APP.f(null,2,[$APP.P,"Matcher that succeeds (with no new bindings) for any input, passing along its\n  input frame.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[pT,$APP.Hv,cac],null))],null)],null),new $APP.f(null,3,[$APP.R,cvb,$APP.X,iYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a predicate function `pred` and returns a matcher that succeeds (with no\n  new bindings) if its data input passes the predicate, fails otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ey],null))],null)],null),new $APP.f(null,3,[$APP.R,Oac,$APP.X,P1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matcher that takes a binding variable `sym`, and succeeds if it's\n  called with a sequential data argument with a prefix that is the REVERSE of\n  the sequence bound to `sym` in `frame`.\n\n  Fails if any of the following are true:\n\n  - `sym` is not bound in the frame\n  - `sym` is bound to something other than a vector prefix created by `segment`\n  - the data argument does not have a prefix matching the reverse of vector\n    bound to `sym`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vx],null),new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.Ey],null))],null)],null),new $APP.f(null,3,[$APP.R,yLb,$APP.X,fJ,$APP.h,new $APP.f(null,2,[$APP.P,"Given a pattern (built using the syntax elements described in\n  `emmy.pattern.syntax`), returns a matcher combinator that will successfully\n  match data structures described by the input pattern, and fail otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,
[$APP.R,ccc,$APP.X,function(a,b){return rYa(a)(b)},$APP.h,new $APP.f(null,2,[$APP.P,"Convenience function that creates an [[all-results-matcher]] from the supplied\n  `pattern` and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((all-results-matcher pattern pred) data)\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xS,$APP.ax],null))],null)],null),new $APP.f(null,3,[$APP.R,c2b,$APP.X,hJ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is equivalent to the failure sentinel [[failure]], false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,j0b,$APP.X,jJ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Uab,$APP.X,R1,$APP.h,new $APP.f(null,2,[$APP.P,"Convenience function that creates a matcher from the supplied `pattern` (and\n  optional predicate `pred`) and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((matcher pattern pred) data)\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xS,$APP.ax],null),new $APP.H(null,
3,5,$APP.I,[xS,$APP.Ey,$APP.ax],null))],null)],null),new $APP.f(null,3,[$APP.R,gDb,$APP.X,nYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a matcher and returns `f` with its metadata modified such\n  that [[segment-matcher?]] will return `true` when applied to `f`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,jTb,$APP.X,rYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `pattern` and callback function `f`, and returns a matcher that takes a\n  `data` argument and returns a sequence of every possible match of `pattern` to\n  the data.\n\n  For a convenience function that applies the matcher to data immediately,\n  see [[all-results]].\n\n  NOTE: If you pass a segment matcher, `f` must accept two arguments - the\n  binding map, and the sequence of all remaining items that the segment\n  matcher rejected.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,Dbc,$APP.X,pYa,$APP.h,new $APP.f(null,2,[$APP.P,"Version of [[sequence]] that takes an explicit sequence of `patterns`, vs the\n  multi-arity version. See [[sequence]] for documentation.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[kY],null))],null)],null),new $APP.f(null,3,[$APP.R,Pqb,$APP.X,kYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matcher that passes its `frame` on to `success-pattern` if `pred`\n  succeeds on its data input, fails otherwise.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ey,QV],null))],null)],null),new $APP.f(null,3,[$APP.R,sjb,$APP.X,function(){return new gJ(null,null,null)},$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.pattern.match/Failure.",$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.R,ihb,$APP.X,qYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `pattern` and side-effecting callback function `f`, and returns a\n  matcher that calls `f` with a map of bindings for every possible match of\n  `pattern` to its input data.\n\n  For a convenience function that applies the matcher to data immediately,\n  see [[foreach]].\n\n  NOTE: If you pass a segment matcher, `f` must accept two arguments - the\n  binding map, and the sequence of all remaining items that the segment\n  matcher rejected.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xS,$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,nbc,$APP.X,rK,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a sequence of patterns, and returns a matcher that will apply its\n  arguments to each matcher in turn. Returns the value of the first pattern that\n  succeeds.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xS],null),new $APP.H(null,3,5,$APP.I,[xS,$APP.Lh,$APP.Ww],null))],null)],null)]),$APP.Zo(YVb)),$APP.ap($APP.fg([$APP.z(KRb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,vV],null))),$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]]."],null)),$APP.z(Uub,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[HU,TU],null)))],null)),$APP.z(qVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Kv,vV],null))),$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]]."],null)),$APP.z(WQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[lxb,mxb],null)))],null)),$APP.z(pBb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,TU],null)))],null)),
$APP.z(gjb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[chb,TU],null)))],null)),$APP.z(ilb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields."],null)),$APP.z(Xrb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields."],null)),$APP.z(iTb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,
[HU,wU,$APP.jP,$APP.uU],null)))],null)),$APP.z(JWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[udb,TU],null)))],null))],[new $APP.f(null,3,[$APP.R,Y0b,$APP.X,vP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,vV],
null))],null)],null),new $APP.f(null,3,[$APP.R,dOb,$APP.X,m5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[HU,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,dRb,$APP.X,tP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Kv,vV],null))],null)],null),new $APP.f(null,3,[$APP.R,Vjb,$APP.X,j5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[lxb,mxb],null))],null)],null),new $APP.f(null,3,[$APP.R,DSb,$APP.X,h5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,s9b,$APP.X,i5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[chb,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,OCb,$APP.X,uP,$APP.h,new $APP.f(null,
2,[$APP.P,"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,XMb,$APP.X,sP,$APP.h,new $APP.f(null,2,[$APP.P,"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,$Ib,$APP.X,l5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[HU,wU,$APP.jP,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,A0b,$APP.X,n5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[udb,TU],null))],null)],null)]),$APP.Zo(DRb)),$APP.ap($APP.fg([$APP.z(xWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,
"If `pattern` is a variable binding form in a pattern with restriction predicates,\n  returns a predicate that only returns true if all of the predicates pass for\n  its input, false otherwise.\n\n  If `pattern` has no restrictions or is some other input type, returns a\n  predicate that will always return `true`."],null)),$APP.z(Jbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Given a pattern with unquoted binding forms and, potentially, `~` and `~@`\n  entries, returns a pattern appropriately quoted such that it can be evaluated\n  by the Clojure reader.\n\n  Changes:\n\n  - `(? x) \x3d\x3e (list '? 'x)`\n  - any bare symbol is quoted\n  - Any form unquoted like `~x` is left UNquoted, even in the symbol spot of `(?\n    ~sym ...)`\n  - Any form marked `~@[1 2 3]` is spliced in directly, EVEN in the symbol spot\n    of `(? ~@sym ...)`\n\n  These rules proceed recursively down into map, vector and sequential data\n  structures. (Recursion only pushes down into values for map-shaped patterns.)"],
null)),$APP.z(t7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Returns true if `pattern` is a sequence form that should be spliced directly\n  into the returned pattern, false otherwise."],null)),$APP.z(VSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[udc,$APP.Kv,$APP.fx],null))),$APP.P,"Helper function for reducing over a sequence that might contain forms that need\n  to be spliced into the resulting sequence. This is a sort of helper for a\n  guarded `mapcat`.\n\n  Takes a sequence `xs` and mapping function `f` and returns a sequence of\n  sequences that, if concatenated together, would be identical to\n\n  ```clojure\n  (map f xs)\n  ```\n\n  Where any `x` such that `(splice? x)` returns true would have its sequential\n  value `(f x)` spliced into the result.\n\n  For example:\n\n  ```clojure\n  (let [f (fn [x] (if (odd? x)  [x x x] x))]\n    (splice-reduce odd? f (range 5)))\n\n  ;;\x3d\x3e [[0] [1 1 1] [2] [3 3 3] [4]]\n  ```"],
null)),$APP.z(bdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Returns true if `pattern` is a reversed-segment variable reference, false\n  otherwise.\n\n  A reverse-segment binding variable is either:\n\n  - A symbol starting with `$$`\n  - A sequence of the form `(:$$ \x3cbinding\x3e ...)`."],null)),$APP.z(SCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Returns true if `pattern` is a binding pattern with restriction predicates,\n  false otherwise."],
null)),$APP.z(ALb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Returns true if `pattern` is a binding variable reference, false otherwise.\n\n  A binding variable is either:\n\n  - A symbol starting with a single `?` character\n  - A sequence of the form `(? \x3cbinding\x3e ...)`."],null)),$APP.z(Y7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Given a REVERSE-segment name, either extracts the symbol from a pattern\n  like `(:$$ x)`, or transforms symbols like `$$x` into `??x`."],
null)),$APP.z(M7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Given a variable or segment binding form, returns the binding variable.\n\n  NOTE that [[variable-name]] will not guard against incorrect inputs."],null)),$APP.z(xob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Returns true if `pattern` is a segment variable reference, false otherwise.\n\n  A segment binding variable is either:\n\n  - A symbol starting with `??`\n  - A sequence of the form `(?? \x3cbinding\x3e ...)`."],
null)),$APP.z(nZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Given a `pattern` that responds `true` to [[unquote?]] or [[unquote-splice?]],\n  returns the form from that pattern."],null)),$APP.z(zAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))),$APP.P,"Returns true if `pattern` matches the wildcard character `_`, false otherwise."],null)),$APP.z(Zdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[xS],null))),$APP.P,"Returns true if `pattern` is a form that should be included with no quoting\n  into the returned pattern, false otherwise."],null))],[new $APP.f(null,3,[$APP.R,fcb,$APP.X,aJ,$APP.h,new $APP.f(null,2,[$APP.P,"If `pattern` is a variable binding form in a pattern with restriction predicates,\n  returns a predicate that only returns true if all of the predicates pass for\n  its input, false otherwise.\n\n  If `pattern` has no restrictions or is some other input type, returns a\n  predicate that will always return `true`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,Pbb,$APP.X,K1,$APP.h,new $APP.f(null,2,[$APP.P,"Given a pattern with unquoted binding forms and, potentially, `~` and `~@`\n  entries, returns a pattern appropriately quoted such that it can be evaluated\n  by the Clojure reader.\n\n  Changes:\n\n  - `(? x) \x3d\x3e (list '? 'x)`\n  - any bare symbol is quoted\n  - Any form unquoted like `~x` is left UNquoted, even in the symbol spot of `(?\n    ~sym ...)`\n  - Any form marked `~@[1 2 3]` is spliced in directly, EVEN in the symbol spot\n    of `(? ~@sym ...)`\n\n  These rules proceed recursively down into map, vector and sequential data\n  structures. (Recursion only pushes down into values for map-shaped patterns.)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,gHb,$APP.X,cJ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a sequence form that should be spliced directly\n  into the returned pattern, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,X$b,$APP.X,$Xa,$APP.h,new $APP.f(null,2,[$APP.P,"Helper function for reducing over a sequence that might contain forms that need\n  to be spliced into the resulting sequence. This is a sort of helper for a\n  guarded `mapcat`.\n\n  Takes a sequence `xs` and mapping function `f` and returns a sequence of\n  sequences that, if concatenated together, would be identical to\n\n  ```clojure\n  (map f xs)\n  ```\n\n  Where any `x` such that `(splice? x)` returns true would have its sequential\n  value `(f x)` spliced into the result.\n\n  For example:\n\n  ```clojure\n  (let [f (fn [x] (if (odd? x)  [x x x] x))]\n    (splice-reduce odd? f (range 5)))\n\n  ;;\x3d\x3e [[0] [1 1 1] [2] [3 3 3] [4]]\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[udc,$APP.Kv,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,R_b,$APP.X,ZI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a reversed-segment variable reference, false\n  otherwise.\n\n  A reverse-segment binding variable is either:\n\n  - A symbol starting with `$$`\n  - A sequence of the form `(:$$ \x3cbinding\x3e ...)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,eub,$APP.X,function(a){return $APP.kd(a)&&
2<$APP.Tc(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a binding pattern with restriction predicates,\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,hBb,$APP.X,WXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a binding variable reference, false otherwise.\n\n  A binding variable is either:\n\n  - A symbol starting with a single `?` character\n  - A sequence of the form `(? \x3cbinding\x3e ...)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,Ylb,$APP.X,ZXa,$APP.h,new $APP.f(null,2,[$APP.P,"Given a REVERSE-segment name, either extracts the symbol from a pattern\n  like `(:$$ x)`, or transforms symbols like `$$x` into `??x`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,W4b,$APP.X,$I,$APP.h,new $APP.f(null,2,[$APP.P,"Given a variable or segment binding form, returns the binding variable.\n\n  NOTE that [[variable-name]] will not guard against incorrect inputs.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,f$b,$APP.X,YI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a segment variable reference, false otherwise.\n\n  A segment binding variable is either:\n\n  - A symbol starting with `??`\n  - A sequence of the form `(?? \x3cbinding\x3e ...)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,Csb,$APP.X,function(a){return $APP.Xc(a)},$APP.h,new $APP.f(null,
2,[$APP.P,"Given a `pattern` that responds `true` to [[unquote?]] or [[unquote-splice?]],\n  returns the form from that pattern.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,DEb,$APP.X,WI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` matches the wildcard character `_`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null),new $APP.f(null,3,[$APP.R,u$b,$APP.X,bJ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a form that should be included with no quoting\n  into the returned pattern, false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xS],null))],null)],null)]),$APP.Zo(sBb)),$APP.ap($APP.fg([$APP.z(Aac,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.H(null,3,5,$APP.I,[$APP.bw,wU,$APP.Tv],null))),$APP.P,"Given two polynomials `u` and `v` (potentially multivariate) with\n  non-polynomial coefficients, returns the greatest common divisor of `u` and\n  `v` calculated using a multivariate extension of Knuth's algorithm 4.6.1E.\n\n  Optionally takes a debugging `level`. To see the debugging logs generated over\n  the course of the run, set [[*poly-gcd-debug*]] to true.\n\n  NOTE: [[full-gcd]] Internally checks that it hasn't run out a stopwatch set\n  with [[with-limited-time]]; you can wrap a call to [[full-gcd]] in this\n  function to limit its execution time.\n\n  For example, this form will throw a TimeoutException after 1 second:\n\n  ```clojure\n  (with-limited-time [1 :seconds]\n    (fn [] (full-gcd u v)))\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.H(null,3,5,$APP.I,[$APP.bw,wU,$APP.Tv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.H(null,3,5,$APP.I,[$APP.bw,wU,$APP.Tv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(wqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,
2,5,$APP.I,[$APP.M(mJb,wU),$APP.M(mJb,$APP.Tv)],null)],null)))),$APP.P,"Given two univariate polynomials `u` and `v`, returns the greatest common\n  divisor of `u` and `v` calculated using Knuth's algorithm 4.6.1E."],null)),$APP.z(iK,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[wU],null),new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.H(null,4,5,$APP.I,[wU,$APP.Tv,$APP.Lh,$APP.Ww],null)))],null)),$APP.z(sAb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(LRb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"Returns true if the [[*clock*]] dynamic variable contains a Stopwatch with an\n  elapsed time that's passed the limit allowed by the\n  dynamic [[*poly-gcd-time-limit*]], false otherwise."],null)),$APP.z(IBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tu,eY],null))),$APP.P,"Given an explicit `timeout` and a no-argument function `thunk`, calls `thunk`\n  in a context where [[*poly-gcd-time-limit*]] is dynamically bound to\n  `timeout`. Calling [[time-expired?]] or [[maybe-bail-out!]] inside `thunk`\n  will signal failure appropriately if `thunk` has taken longer than `timeout`."],
null)),$APP.z(Vmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))),$APP.P,"Higher-level wrapper around [[full-gcd]] that:\n\n  - optimizes the case where `u` and `v` share no variables\n  - sorts the variables in `u` and `v` in order of increasing degree\n\n  before attempting [[full-gcd]]. See [[full-gcd]] for a full description."],null)),$APP.z(HFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"When called, logs statistics about the GCD memoization cache, and the number of\n  times the system has encountered monomial or other trivial GCDs. "],
null)),$APP.z(IXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the greatest common divisor of all partial derivatives of the\n  polynomial `p` using binary applications of the [[gcd]] algorithm between each\n  partial derivative.\n\n  This algorithm assumes that all coefficients are integral, and halts when it\n  encounters a result that responds true to [[emmy.value/one?]].\n\n  If a non-[[p/Polynomial]] is supplied, returns 1."],null)),
$APP.z(DV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))),$APP.P,"Returns the least common multiple of (possibly polynomial) arguments `u` and\n  `v`, using [[gcd]] to calculate the gcd portion of\n\n  ```\n  (/ (g/abs (* u v))\n     (gcd u v))\n  ```"],null)),$APP.z(KNb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(SOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,iK],null))),$APP.P,"Given some polynomial `p`, and a multi-arity `gcd` function for its\n  coefficients, returns a pair of the polynomial's content and primitive.\n\n  The 'content' of a polynomial is the greatest common divisor of its\n  coefficients. The 'primitive part' of a polynomial is the quotient of the\n  polynomial by its content.\n\n  See Wikipedia's ['Primitive Part and\n  Content'](https://en.wikipedia.org/wiki/Primitive_part_and_content) page for\n  more details. "],
null)),$APP.z(iub,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(Tdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))),$APP.P,"Given two polynomials `u` and `v`, attempts to return the greatest common\n  divisor of `u` and `v` by testing for trivial cases. If no trivial case\n  applies, returns `nil`."],null)),$APP.z(Oub,new $APP.f(null,1,[$APP.gm,!0],null))],[new $APP.f(null,3,[$APP.R,cOb,$APP.X,nM,$APP.h,new $APP.f(null,2,[$APP.P,"Given two polynomials `u` and `v` (potentially multivariate) with\n  non-polynomial coefficients, returns the greatest common divisor of `u` and\n  `v` calculated using a multivariate extension of Knuth's algorithm 4.6.1E.\n\n  Optionally takes a debugging `level`. To see the debugging logs generated over\n  the course of the run, set [[*poly-gcd-debug*]] to true.\n\n  NOTE: [[full-gcd]] Internally checks that it hasn't run out a stopwatch set\n  with [[with-limited-time]]; you can wrap a call to [[full-gcd]] in this\n  function to limit its execution time.\n\n  For example, this form will throw a TimeoutException after 1 second:\n\n  ```clojure\n  (with-limited-time [1 :seconds]\n    (fn [] (full-gcd u v)))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.H(null,3,5,$APP.I,[$APP.bw,wU,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,Zsb,$APP.X,p0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given two univariate polynomials `u` and `v`, returns the greatest common\n  divisor of `u` and `v` calculated using Knuth's algorithm 4.6.1E.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(mJb,wU),$APP.M(mJb,$APP.Tv)],
null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Stb,$APP.X,pM,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[wU],null),new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.H(null,4,5,$APP.I,[wU,$APP.Tv,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,Yib,$APP.X,eM,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Nqb,$APP.X,$_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the [[*clock*]] dynamic variable contains a Stopwatch with an\n  elapsed time that's passed the limit allowed by the\n  dynamic [[*poly-gcd-time-limit*]], false otherwise.",
$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.R,iZb,$APP.X,b0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an explicit `timeout` and a no-argument function `thunk`, calls `thunk`\n  in a context where [[*poly-gcd-time-limit*]] is dynamically bound to\n  `timeout`. Calling [[time-expired?]] or [[maybe-bail-out!]] inside `thunk`\n  will signal failure appropriately if `thunk` has taken longer than `timeout`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tu,eY],null))],null)],null),new $APP.f(null,
3,[$APP.R,ONb,$APP.X,q0a,$APP.h,new $APP.f(null,2,[$APP.P,"Higher-level wrapper around [[full-gcd]] that:\n\n  - optimizes the case where `u` and `v` share no variables\n  - sorts the variables in `u` and `v` in order of increasing degree\n\n  before attempting [[full-gcd]]. See [[full-gcd]] for a full description.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,rtb,$APP.X,function(){var a=$APP.Tc($APP.Fb(c0a));if(0<a){var b=$APP.Fb(d0a),c=$APP.Fb(e0a);
$G($APP.Wu,"emmy.polynomial.gcd",71,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,[HG("GCD cache hit rate %.2f%% (%d entries)",b/(b+c)*100,a)],null)},null),-1143507686)}return $G($APP.Wu,"emmy.polynomial.gcd",76,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,[HG("GCD triv %d mono %d",$APP.Fb(j0a),$APP.Fb(m0a))],null)},null),-190209174)},$APP.h,new $APP.f(null,2,[$APP.P,"When called, logs statistics about the GCD memoization cache, and the number of\n  times the system has encountered monomial or other trivial GCDs. ",
$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.R,l7b,$APP.X,t0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the greatest common divisor of all partial derivatives of the\n  polynomial `p` using binary applications of the [[gcd]] algorithm between each\n  partial derivative.\n\n  This algorithm assumes that all coefficients are integral, and halts when it\n  encounters a result that responds true to [[emmy.value/one?]].\n\n  If a non-[[p/Polynomial]] is supplied, returns 1.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,Fbc,$APP.X,s0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the least common multiple of (possibly polynomial) arguments `u` and\n  `v`, using [[gcd]] to calculate the gcd portion of\n\n  ```\n  (/ (g/abs (* u v))\n     (gcd u v))\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,nQb,$APP.X,!1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,K2b,$APP.X,h0a,$APP.h,new $APP.f(null,
2,[$APP.P,"Given some polynomial `p`, and a multi-arity `gcd` function for its\n  coefficients, returns a pair of the polynomial's content and primitive.\n\n  The 'content' of a polynomial is the greatest common divisor of its\n  coefficients. The 'primitive part' of a polynomial is the quotient of the\n  polynomial by its content.\n\n  See Wikipedia's ['Primitive Part and\n  Content'](https://en.wikipedia.org/wiki/Primitive_part_and_content) page for\n  more details. ",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Pv,iK],null))],null)],null),new $APP.f(null,3,[$APP.R,HIb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,J9b,$APP.X,l0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given two polynomials `u` and `v`, attempts to return the greatest common\n  divisor of `u` and `v` by testing for trivial cases. If no trivial case\n  applies, returns `nil`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,jpb,$APP.X,fM,$APP.h,$APP.F],null)]),$APP.Zo(G0b)),
$APP.ap($APP.fg([$APP.z(fgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),$APP.P,"Given a metric and a basis, computes the inverse metric."],null)),$APP.z(dpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))),$APP.P,"For making a (0,2) tensor into a (2,0) tensor."],null)),$APP.z(hX,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))],null)),$APP.z(AOb,new $APP.f(null,1,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,YRb],null)))],null)),bBb,$APP.z(UBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))),$APP.P,"Computes the trace of a (0,2) tensor."],null)),$APP.z(nub,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))],null)),$APP.z(uhb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,TU],null)))],null)),$APP.z(ibb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[MX,TU],null))),$APP.P,"Computes the trace of a (2,0) tensor"],null)),twb,$APP.z(tQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[kT],null)))],null)),$APP.z(m6a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),$APP.P,"To make a one-form field into a vector field, i.e., a (0,1) tensor into a (1,0)\n  tensor."],null)),$APP.z(Rdc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,oW],null))),
$APP.P,"Flat coordinate systems here only."],null)),$APP.z(Lnb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))),$APP.P,"For making a (2,0) tensor into a (0,2) tensor."],null)),$APP.z(l6a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[hW],null))),$APP.P,"To make a vector field into a one-form field, i.e., a (1,0) tensor into a (0,1)\n  tensor."],null)),Xtb,$APP.z(VGb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[hW,TU],null)))],null)),epb,Knb,$APP.z(uec,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))],null)),$APP.z(Ojb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[hW,TU,$APP.Or],null)))],null)),$APP.z(dec,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,xBb],null)))],null))],[new $APP.f(null,3,[$APP.R,ffb,$APP.X,j6a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a metric and a basis, computes the inverse metric.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,njb,$APP.X,o6a,$APP.h,new $APP.f(null,2,[$APP.P,"For making a (0,2) tensor into a (2,0) tensor.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,O_b,$APP.X,OP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,XZb,$APP.X,k6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[KT,YRb],null))],null)],null),new $APP.f(null,3,[$APP.R,pTb,$APP.X,PP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,i5b,$APP.X,p6a,$APP.h,new $APP.f(null,2,[$APP.P,"Computes the trace of a (0,2) tensor.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,Psb,$APP.X,e6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,sCb,$APP.X,h6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[VV,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,Ohb,$APP.X,q6a,$APP.h,new $APP.f(null,2,[$APP.P,"Computes the trace of a (2,0) tensor",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,DZb,$APP.X,Irc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,CGb,$APP.X,NP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[kT],null))],null)],null),new $APP.f(null,3,[$APP.R,s8b,$APP.X,QP,$APP.h,new $APP.f(null,2,[$APP.P,"To make a one-form field into a vector field, i.e., a (0,1) tensor into a (1,0)\n  tensor.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,UIb,$APP.X,g6a,$APP.h,new $APP.f(null,2,[$APP.P,"Flat coordinate systems here only.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,oW],null))],null)],null),new $APP.f(null,3,[$APP.R,m2b,$APP.X,n6a,$APP.h,new $APP.f(null,2,[$APP.P,"For making a (2,0) tensor into a (0,2) tensor.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,Adc,$APP.X,PP,$APP.h,new $APP.f(null,
2,[$APP.P,"To make a vector field into a one-form field, i.e., a (1,0) tensor into a (0,1)\n  tensor.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[hW],null))],null)],null),new $APP.f(null,3,[$APP.R,Eib,$APP.X,QP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,U2b,$APP.X,i6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,ojb,$APP.X,QP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,n2b,$APP.X,PP,$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.R,$$b,$APP.X,d6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,W9b,$APP.X,r6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[hW,TU,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,WSb,$APP.X,c6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,xBb],null))],null)],null)]),$APP.Zo(nDb)),$APP.ap(new $APP.f(null,2,[$APP.z(EEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,$APP.Lx],null))),$APP.P,"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\n\n  See [[brent-min]] for all supported `opts`."],null)),new $APP.f(null,3,[$APP.R,A6b,$APP.X,Z7a,$APP.h,new $APP.f(null,2,[$APP.P,"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\n\n  See [[brent-min]] for all supported `opts`.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,$APP.Lx],null))],null)],null),$APP.z(sDb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,6,5,$APP.I,[NT,PT,PY,IT,sX,$APP.Dw],null),$APP.Kl,new $APP.f(null,5,[NT,yV,PT,OY,PY,$APP.M(UT,$APP.Iv,$APP.qU),IT,1E3,$APP.Dw,$APP.M($APP.cw,null)],null)],null)],null))),$APP.P,"Find the minimum of the function f: R -\x3e R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id\x3dAITCAgAAQBAJ\x26q\x3dBrent%E2%80%99s#v\x3donepage\x26q\x3dParabolic\x26f\x3dfalse).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  [[brent-min]] supports the following optional keyword arguments:\n\n  - `:callback`: if supplied, the supplied fn will be invoked at each\n    intermediate point with the iteration count and the values of x and f(x) at\n    each search step.\n\n  - `:initial-guess`: the first internal point checked by the algorithm. Defaults\n    to `([[initial-brent-guess]] a b)`.\n\n  - `:relative-threshold`: multiplied by each guess to determine a relative\n    threshold. Defaults to 1.0e-11.\n\n  - `:absolute-threshold`: a smaller absolute threshold that applies when the\n    candidate minimum point is close to 0. defaults to around 1.49e8, the sqrt of\n    the machine tolerance. You won't gain any benefit attempting to set the value\n    less than the default.\n\n  - `:maxiter`: Maximum number of iterations allowed for the minimizer. Defaults\n    to 1000.\n\n  - `:maxfun`: Maximum number of times the function can be evaluated before\n    exiting. Defaults to `(inc maxiter)`.\n  ",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,6,5,$APP.I,[NT,PT,PY,IT,sX,$APP.Dw],null),$APP.Kl,new $APP.f(null,5,[NT,yV,PT,OY,PY,$APP.M(UT,$APP.Iv,$APP.qU),IT,1E3,$APP.Dw,$APP.M($APP.cw,null)],null)],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,
4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,6,5,$APP.I,[NT,PT,PY,IT,sX,$APP.Dw],null),$APP.Kl,new $APP.f(null,5,[NT,yV,PT,OY,PY,$APP.M(UT,$APP.Iv,$APP.qU),IT,1E3,$APP.Dw,$APP.M($APP.cw,null)],null)],null)],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,fkb,$APP.X,tQ,$APP.h,new $APP.f(null,2,[$APP.P,"Find the minimum of the function f: R -\x3e R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id\x3dAITCAgAAQBAJ\x26q\x3dBrent%E2%80%99s#v\x3donepage\x26q\x3dParabolic\x26f\x3dfalse).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  [[brent-min]] supports the following optional keyword arguments:\n\n  - `:callback`: if supplied, the supplied fn will be invoked at each\n    intermediate point with the iteration count and the values of x and f(x) at\n    each search step.\n\n  - `:initial-guess`: the first internal point checked by the algorithm. Defaults\n    to `([[initial-brent-guess]] a b)`.\n\n  - `:relative-threshold`: multiplied by each guess to determine a relative\n    threshold. Defaults to 1.0e-11.\n\n  - `:absolute-threshold`: a smaller absolute threshold that applies when the\n    candidate minimum point is close to 0. defaults to around 1.49e8, the sqrt of\n    the machine tolerance. You won't gain any benefit attempting to set the value\n    less than the default.\n\n  - `:maxiter`: Maximum number of iterations allowed for the minimizer. Defaults\n    to 1000.\n\n  - `:maxfun`: Maximum number of times the function can be evaluated before\n    exiting. Defaults to `(inc maxiter)`.\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,6,5,$APP.I,[NT,PT,PY,IT,sX,$APP.Dw],null),$APP.Kl,new $APP.f(null,5,[NT,yV,PT,OY,PY,$APP.M(UT,$APP.Iv,$APP.qU),IT,1E3,$APP.Dw,$APP.M($APP.cw,null)],null)],null)],null))],null)],null)],null),$APP.Zo(IYb)),$APP.ap($APP.fg([$APP.z(Udc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))),$APP.P,
"Generates a lagrange interpolating polynomial that fits every point in the\n  supplied sequence `points` (of form `[x (f x)]`) and returns the value of the\n  polynomial evaluated at `x`.\n\n  The Lagrange polynomial has this form:\n\n  ```\n  g(x) \x3d  (f(a) * [(x-b)(x-c)...] / [(a-b)(a-c)...])\n        + (f(b) * [(x-a)(x-c)...] / [(b-a)(b-c)...])\n        + ...\n  ```\n\n  for points `[a f(a)], [b f(b)], [c f(c)]` etc.\n\n  This particular method of interpolating `x` into the polynomial is\n  inefficient; any new calculation requires fully recomputing. Takes `O(n^2)`\n  operations in the number of points.\n  "],
null)),$APP.z(l_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described in [[neville]].\n\n  Faster than, but equivalent to, `(last ([[neville]] xs x))`"],null)),$APP.z(r1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[modified-neville]].\n\n  Equivalent to `([[modified-neville]] xs x)`."],null)),$APP.z(S8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),
$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[neville]].\n\n  Equivalent to `([[neville]] xs x)`."],null)),$APP.z(y6b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-neville]]."],
null)),$APP.z(pkb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described\n  in [[modified-neville]].\n\n  Faster than, but equivalent to, `(last ([[modified-neville]] xs x))`"],null)),$APP.z(hZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))),$APP.P,"Top-down implementation of [Neville's\n  algorithm]((https://en.wikipedia.org/wiki/Neville%27s_algorithm))\n\n  Returns the value of `P(x)`, where `P` is a polynomial fit (using Neville's\n  algorithm) to every point in the supplied sequence `points` (of form `[x (f\n  x)]`)\n\n  The efficiency and results should be identical to\n  [[emmy.numerical.interpolate/lagrange]]. This function represents a step\n  on the journey toward more incremental methods of polynomial interpolation.\n\n  References:\n\n  - Press's Numerical Recipes (p103), [chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)"],
null)),$APP.z(LBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))),$APP.P,"Similar to [[neville]] (the interface is identical) but slightly more efficient.\n  Internally this builds up its estimates by tracking the delta from the\n  previous estimate.\n\n  This non-obvious change lets us swap an addition in for a multiplication,\n  making the algorithm slightly more efficient.\n\n  See [[neville]] for usage information, and info about the required structure\n  of the arguments.\n\n  The structure of the [[modified-neville]] algorithm makes it difficult to\n  select a particular column. See [[neville]] if you'd like to generate\n  polynomial approximations between successive sequences of points.\n\n  References:\n\n  - [\"A comparison of algorithms for polynomial interpolation\"](https://www.sciencedirect.com/science/article/pii/0771050X82900511), A. Macleod\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)"],
null)),$APP.z(RNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[GBb,$APP.lu,$APP.HT],null))),$APP.P,"Given `prepare` and `merge` and `present` functions, returns a fold capable of\n  aggregating a point of the form [x, f(x)] into an accumulating tableau\n  row (generating the next tableau row).\n\n  The 0-arity of the returned function returns an empty row, `[]`.\n\n  The 1-arity calls the supplied `present` on the accumulated tableau row.\n\n  The 2-arity scans the supplied `merge` across all entries in the accumulating\n  row, producing a new row.\n\n  ### More detail on the arguments:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  l -- return\n     /\n    /\n   /\n  r\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `present`: Transforms a `tableau` row into an estimate at some value `x` of\n  the polynomial interpolated to hit all supplied points."],
null)),$APP.z(ANb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))),$APP.P,"Takes a potentially lazy sequence of `points` and a point `x` and generates a\n  lazy sequence of approximations of P(x).\n\n  entry N in the returned sequence is the estimate using a polynomial generated\n  from the first N points of the input sequence."],null)),$APP.z(YMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[GBb,$APP.lu,$APP.sS],null))),
$APP.P,"Returns a Newton-style approximation tableau, given:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  ```\n  l -- return\n     /\n    /\n   /\n  r\n  ```\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `points`: the (potentially lazy) sequence of points used to generate the\n  first column of the tableau.\n  "],
null)),$APP.z(j2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n    and returns the next row of the tableau using the algorithm described in\n  [[neville]]."],
null)),$APP.z(VOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.sS,$APP.Vv,$APP.kv],null))),$APP.P,"Takes:\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  Said another way: the Nth in the returned sequence is the estimate using a\n  polynomial generated from the first `N` points of the input sequence:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  ```\n\n  This function generates each estimate using Neville's algorithm:\n\n  ```\n  $$P(x) \x3d [(x - x_r) P_l(x) - (x - x_l) P_r(x)] / [x_l - x_r]$$\n  ```\n\n  ### Column\n\n  If you supply an integer for the third `column` argument, `neville` will\n  return that _column_ of the interpolation tableau instead of the first row.\n  This will give you a sequence of nth-order polynomial approximations taken\n  between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n   p0 p01 p012 p0123 p01234\n   p1 p12 p123 p1234 .\n   p2 p23 p234 .     .\n   p3 p34 .    .     .\n   p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of linear approximations\n  between pairs of points; `2` gives quadratic approximations between successive\n  triplets, etc.\n\n  References:\n\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.sS,$APP.Vv,$APP.kv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.sS,$APP.Vv,$APP.kv],null)),$APP.zx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.R,OVb,$APP.X,oXa,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a lagrange interpolating polynomial that fits every point in the\n  supplied sequence `points` (of form `[x (f x)]`) and returns the value of the\n  polynomial evaluated at `x`.\n\n  The Lagrange polynomial has this form:\n\n  ```\n  g(x) \x3d  (f(a) * [(x-b)(x-c)...] / [(a-b)(a-c)...])\n        + (f(b) * [(x-a)(x-c)...] / [(b-a)(b-c)...])\n        + ...\n  ```\n\n  for points `[a f(a)], [b f(b)], [c f(c)]` etc.\n\n  This particular method of interpolating `x` into the polynomial is\n  inefficient; any new calculation requires fully recomputing. Takes `O(n^2)`\n  operations in the number of points.\n  ",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,bvb,$APP.X,function(a){return E_.j(wXa(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described in [[neville]].\n\n  Faster than, but equivalent to, `(last ([[neville]] xs x))`",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,qFb,$APP.X,zXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[modified-neville]].\n\n  Equivalent to `([[modified-neville]] xs x)`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,i4b,$APP.X,function(a){return EI.j(wXa(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[neville]].\n\n  Equivalent to `([[neville]] xs x)`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Chb,$APP.X,yXa,$APP.h,new $APP.f(null,2,[$APP.P,"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-neville]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,djb,$APP.X,function(a){return E_.j(yXa(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described\n  in [[modified-neville]].\n\n  Faster than, but equivalent to, `(last ([[modified-neville]] xs x))`",$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Zxb,$APP.X,function(a,b){return function g(d){if($APP.Uc.A(1,$APP.Tc(d))){var l=$APP.x.B(d,0,null);$APP.x.B(l,0,null);return $APP.x.B(l,1,null)}l=$APP.gd(d);var n=$APP.oi.A(d,1),p=$APP.u(d);p=$APP.x.B(p,0,null);d=$APP.fd(d);d=$APP.x.B(d,0,null);return QF.A(kG.A(iG.A(RF.A(b,d),g(l)),iG.A(RF.A(p,b),g(n))),RF.A(p,d))}($APP.tf(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Top-down implementation of [Neville's\n  algorithm]((https://en.wikipedia.org/wiki/Neville%27s_algorithm))\n\n  Returns the value of `P(x)`, where `P` is a polynomial fit (using Neville's\n  algorithm) to every point in the supplied sequence `points` (of form `[x (f\n  x)]`)\n\n  The efficiency and results should be identical to\n  [[emmy.numerical.interpolate/lagrange]]. This function represents a step\n  on the journey toward more incremental methods of polynomial interpolation.\n\n  References:\n\n  - Press's Numerical Recipes (p103), [chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,cpb,$APP.X,function(a,b){return vXa(zI(AI(tXa,uXa(b),a)))},$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[neville]] (the interface is identical) but slightly more efficient.\n  Internally this builds up its estimates by tracking the delta from the\n  previous estimate.\n\n  This non-obvious change lets us swap an addition in for a multiplication,\n  making the algorithm slightly more efficient.\n\n  See [[neville]] for usage information, and info about the required structure\n  of the arguments.\n\n  The structure of the [[modified-neville]] algorithm makes it difficult to\n  select a particular column. See [[neville]] if you'd like to generate\n  polynomial approximations between successive sequences of points.\n\n  References:\n\n  - [\"A comparison of algorithms for polynomial interpolation\"](https://www.sciencedirect.com/science/article/pii/0771050X82900511), A. Macleod\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,QVb,$APP.X,CI,$APP.h,new $APP.f(null,2,[$APP.P,"Given `prepare` and `merge` and `present` functions, returns a fold capable of\n  aggregating a point of the form [x, f(x)] into an accumulating tableau\n  row (generating the next tableau row).\n\n  The 0-arity of the returned function returns an empty row, `[]`.\n\n  The 1-arity calls the supplied `present` on the accumulated tableau row.\n\n  The 2-arity scans the supplied `merge` across all entries in the accumulating\n  row, producing a new row.\n\n  ### More detail on the arguments:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  l -- return\n     /\n    /\n   /\n  r\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `present`: Transforms a `tableau` row into an estimate at some value `x` of\n  the polynomial interpolated to hit all supplied points.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[GBb,$APP.lu,$APP.HT],null))],null)],null),new $APP.f(null,3,[$APP.R,Lcb,$APP.X,function(a,b){return $APP.Vg.A($APP.fd,zI($APP.Hg.A($APP.r,$APP.af(rXa(b),$APP.Vg.A(pXa,a)))))},$APP.h,new $APP.f(null,2,[$APP.P,"Takes a potentially lazy sequence of `points` and a point `x` and generates a\n  lazy sequence of approximations of P(x).\n\n  entry N in the returned sequence is the estimate using a polynomial generated\n  from the first N points of the input sequence.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,pGb,$APP.X,AI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a Newton-style approximation tableau, given:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  ```\n  l -- return\n     /\n    /\n   /\n  r\n  ```\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `points`: the (potentially lazy) sequence of points used to generate the\n  first column of the tableau.\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[GBb,$APP.lu,$APP.sS],null))],null)],null),new $APP.f(null,3,[$APP.R,Ydc,$APP.X,wXa,$APP.h,new $APP.f(null,2,[$APP.P,"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n    and returns the next row of the tableau using the algorithm described in\n  [[neville]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Cwb,$APP.X,W0,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  Said another way: the Nth in the returned sequence is the estimate using a\n  polynomial generated from the first `N` points of the input sequence:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  ```\n\n  This function generates each estimate using Neville's algorithm:\n\n  ```\n  $$P(x) \x3d [(x - x_r) P_l(x) - (x - x_l) P_r(x)] / [x_l - x_r]$$\n  ```\n\n  ### Column\n\n  If you supply an integer for the third `column` argument, `neville` will\n  return that _column_ of the interpolation tableau instead of the first row.\n  This will give you a sequence of nth-order polynomial approximations taken\n  between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n   p0 p01 p012 p0123 p01234\n   p1 p12 p123 p1234 .\n   p2 p23 p234 .     .\n   p3 p34 .    .     .\n   p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of linear approximations\n  between pairs of points; `2` gives quadratic approximations between successive\n  triplets, etc.\n\n  References:\n\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.sS,$APP.Vv,$APP.kv],null))],null)],null)]),$APP.Zo(Ctb)),$APP.ap(new $APP.f(null,6,[$APP.z(Wyb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null))),$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  forward-difference estimate of the the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x + h) - f(x)] / h\n  ```\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,Jub,$APP.X,DR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  forward-difference estimate of the the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x + h) - f(x)] / h\n  ```\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null))],null)],null),$APP.z(kSb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null))),$APP.P,"Takes a function `f: R \x3d\x3e R` (function of a single real variable), and returns\n  a new function of `x` that approximates the derivative $Df(x)$ (or $D^2f(x)$\n  if you pass `:method :central-d2`).\n\n  Returns the estimated value of the derivative at `x`. If you pass `:info?\n  true`, the fn returns a dictionary of the results of `us/seq-limit`:\n\n  ```clojure\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3cderivative estimate\x3e}\n  ```\n\n  Make sure to visit [[emmy.calculus.derivative/D]] if you want symbolic or\n  automatic differentiation.\n\n  ### Roundoff Estimate\n\n  The returned function will attempt to estimate how many times it can halve the\n  step size used to estimate the derivative before roundoff error swamps the\n  calculation, and force the function to return (with `:converged? false`, if\n  you pass `:info?`)\n\n  ### Optional Arguments\n\n  `D-numeric` takes optional args as its second param. Any of these can be\n  overridden by passing a second argument to the function returned by\n  `D-numeric`; helpful for setting defaults and then overriding them later.\n\n  The returned function passes through these and any other options to\n  `us/seq-limit`, where they control the sequence of richardson\n  extrapolation-accelerated estimates.\n\n  Options:\n\n  - `:method`: one of `:central`, `:central-d2`, `:forward` or `:backward`.\n  `:central-d2` forces a second derivative estimate; the other methods configure\n  a first derivative estimator.\n\n  - `:info?` if false (default), returns the estimated value of `x`. If true,\n  returns a dictionary with more information (see `D-numeric`'s docstring for\n  more info.)\n\n  - `:initial-h`: the initial `h` to use for derivative estimates before $h \to\n  0$. Defaults to `0.1 * abs(x)`.\n\n  - `:tolerance`: see `us/stream-limit` for a discussion of how this value\n  handles relative vs absolute tolerance. $\\sqrt(\\epsilon)$ by default, where\n  $\\epsilon$ \x3d machine tolerance.\n\n  - `:maxterms`: the maximum number of terms to consider when hunting for a\n  derivative estimate. This defaults to an estimate generated internally,\n  designed to prevent roundoff error from swamping the result. If you want to\n  disable this feature, set `:maxterms` to something moderately large, like\n  `:maxterms 100`. But do so carefully! See the surrounding namespace for a\n  larger discussion.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,Ovb,$APP.X,G4,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function `f: R \x3d\x3e R` (function of a single real variable), and returns\n  a new function of `x` that approximates the derivative $Df(x)$ (or $D^2f(x)$\n  if you pass `:method :central-d2`).\n\n  Returns the estimated value of the derivative at `x`. If you pass `:info?\n  true`, the fn returns a dictionary of the results of `us/seq-limit`:\n\n  ```clojure\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3cderivative estimate\x3e}\n  ```\n\n  Make sure to visit [[emmy.calculus.derivative/D]] if you want symbolic or\n  automatic differentiation.\n\n  ### Roundoff Estimate\n\n  The returned function will attempt to estimate how many times it can halve the\n  step size used to estimate the derivative before roundoff error swamps the\n  calculation, and force the function to return (with `:converged? false`, if\n  you pass `:info?`)\n\n  ### Optional Arguments\n\n  `D-numeric` takes optional args as its second param. Any of these can be\n  overridden by passing a second argument to the function returned by\n  `D-numeric`; helpful for setting defaults and then overriding them later.\n\n  The returned function passes through these and any other options to\n  `us/seq-limit`, where they control the sequence of richardson\n  extrapolation-accelerated estimates.\n\n  Options:\n\n  - `:method`: one of `:central`, `:central-d2`, `:forward` or `:backward`.\n  `:central-d2` forces a second derivative estimate; the other methods configure\n  a first derivative estimator.\n\n  - `:info?` if false (default), returns the estimated value of `x`. If true,\n  returns a dictionary with more information (see `D-numeric`'s docstring for\n  more info.)\n\n  - `:initial-h`: the initial `h` to use for derivative estimates before $h \to\n  0$. Defaults to `0.1 * abs(x)`.\n\n  - `:tolerance`: see `us/stream-limit` for a discussion of how this value\n  handles relative vs absolute tolerance. $\\sqrt(\\epsilon)$ by default, where\n  $\\epsilon$ \x3d machine tolerance.\n\n  - `:maxterms`: the maximum number of terms to consider when hunting for a\n  derivative estimate. This defaults to an estimate generated internally,\n  designed to prevent roundoff error from swamping the result. If you want to\n  disable this feature, set `:maxterms` to something moderately large, like\n  `:maxterms 100`. But do so carefully! See the surrounding namespace for a\n  larger discussion.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null))],null)],null),$APP.z(X8b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null))),$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  central-difference estimate of the second derivative of `f` at point `x`:\n\n  f''(x) \x3d [f(x + h) - 2f(x) + f(x - h)] / h^2\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,t3b,$APP.X,GR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  central-difference estimate of the second derivative of `f` at point `x`:\n\n  f''(x) \x3d [f(x + h) - 2f(x) + f(x - h)] / h^2\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null))],null)],null),$APP.z(Nmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null))),$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  central-difference estimate of the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x + h) - f(x - h)] / 2h\n  ```"],null)),new $APP.f(null,3,[$APP.R,mDb,$APP.X,
W$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  central-difference estimate of the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x + h) - f(x - h)] / 2h\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null))],null)],null),$APP.z(GKb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null))),$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  backward-difference estimate of the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x) - f(x - h)] / h\n  ```\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,Wkb,$APP.X,FR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  backward-difference estimate of the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x) - f(x - h)] / h\n  ```\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Vv,cX],null))],null)],null),Gdb,new $APP.f(null,3,[$APP.R,JBb,$APP.X,X$a,$APP.h,$APP.F],null)],null),$APP.Zo(T2b)),$APP.ap($APP.fg([$APP.z(HEb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,QT],null))),$APP.P,"Accepts:\n\n  - some function `f` of potentially many arguments\n  - optionally, a sequence of selectors meant to index into the structural\n    argument, or argument vector, of `f`\n\n  And returns a new function that computes either the\n  full [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  or the entry at `selectors` using [reverse-mode automatic\n  differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation#Reverse_accumulation).\n\n  Any multivariable function will have its argument vector coerced into an `up`\n  structure. Any [[emmy.matrix/Matrix]] in a multiple-arg function call will be\n  converted into a `down` of `up`s (a row of columns).\n\n  Arguments to single-variable functions are not transformed.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,QT],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,QT],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(y0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],null)),$APP.z(Pxb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null))),$APP.P,"Similar to [[taylor-series]], except `f` is evaluated with symbolic arguments,\n  and these arguments are only replaced with the values `xs` after Taylor series\n  expansion.\n\n  Please see the docs for [[taylor-series]]!",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(U9b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))),$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses forward-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,
$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(QT)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(ZKb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null)))],null)),$APP.z(tKb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))),$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses reverse-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(QT)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z($APP.Rw,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null)))],null)),$APP.z(cW,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(lRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],null)),$APP.z(cH,new $APP.f(null,
1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],null)),$APP.z(cDb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null))),$APP.P,"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[emmy.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, i.e., the Taylor series expansion at `(\x3d x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[emmy.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[emmy.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.R,F2b,$APP.X,r3,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts:\n\n  - some function `f` of potentially many arguments\n  - optionally, a sequence of selectors meant to index into the structural\n    argument, or argument vector, of `f`\n\n  And returns a new function that computes either the\n  full [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  or the entry at `selectors` using [reverse-mode automatic\n  differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation#Reverse_accumulation).\n\n  Any multivariable function will have its argument vector coerced into an `up`\n  structure. Any [[emmy.matrix/Matrix]] in a multiple-arg function call will be\n  converted into a `down` of `up`s (a row of columns).\n\n  Arguments to single-variable functions are not transformed.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,QT],null))],null)],null),new $APP.f(null,3,[$APP.R,oyb,$APP.X,Hrc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,zbb,$APP.X,A3,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[taylor-series]], except `f` is evaluated with symbolic arguments,\n  and these arguments are only replaced with the values `xs` after Taylor series\n  expansion.\n\n  Please see the docs for [[taylor-series]]!",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,TRb,$APP.X,y3,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses forward-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))],null)],
null),new $APP.f(null,3,[$APP.R,UKb,$APP.X,b4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null))],null)],null),new $APP.f(null,3,[$APP.R,Wsb,$APP.X,QQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses reverse-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))],
null)],null),new $APP.f(null,3,[$APP.R,ywb,$APP.X,QQ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))],null)],null),new $APP.f(null,3,[$APP.R,Hkb,$APP.X,s3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,a8b,$APP.X,SO,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,Pwb,$APP.X,SO,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,
3,[$APP.R,YUb,$APP.X,z3,$APP.h,new $APP.f(null,2,[$APP.P,"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[emmy.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, i.e., the Taylor series expansion at `(\x3d x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[emmy.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[emmy.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null))],null)],null)]),$APP.Zo(dVb)),$APP.ap(new $APP.f(null,6,[$APP.z(yob,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,4,[kU,"null",WE,"null",LY,"null",gV,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ov,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,2,[kU,"null",gV,"null"],null),null),$APP.P,"Positional factory function for emmy.modint/ModInt."],
null)),new $APP.f(null,3,[$APP.R,n9b,$APP.X,SWa,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.modint/ModInt.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ov,$APP.Or],null))],null)],null),$APP.z(Bzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),new $APP.f(null,3,[$APP.R,wdb,$APP.X,function(a){return a.i},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),$APP.z(KMb,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,mX],null))),$APP.P,"[Chinese Remainder Algorithm](https://en.wikipedia.org/wiki/Chinese_remainder_theorem).\n\n  Accepts a sequence of [[ModInt]] instances (where the `modulus` of\n  all [[ModInt]] instances are relatively prime), and returns a [[ModInt]] `x`\n  such that `(residue input) \x3d\x3d (mod x (modulus input))`.\n\n  For example:\n\n  ```clojure\n  (let [a1 (m/make 2 5)\n        a2 (m/make 3 13)]\n    [(\x3d 42 (chinese-remainder a1 a2))\n     (\x3d (residue a1) (mod cr (modulus a1)))\n     (\x3d (residue a2) (mod cr (modulus a2)))])\n  ;;\x3d\x3e [true true true]\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(mX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,mX],null)),$APP.zx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.R,Bbb,$APP.X,x0,$APP.h,new $APP.f(null,2,[$APP.P,"[Chinese Remainder Algorithm](https://en.wikipedia.org/wiki/Chinese_remainder_theorem).\n\n  Accepts a sequence of [[ModInt]] instances (where the `modulus` of\n  all [[ModInt]] instances are relatively prime), and returns a [[ModInt]] `x`\n  such that `(residue input) \x3d\x3d (mod x (modulus input))`.\n\n  For example:\n\n  ```clojure\n  (let [a1 (m/make 2 5)\n        a2 (m/make 3 13)]\n    [(\x3d 42 (chinese-remainder a1 a2))\n     (\x3d (residue a1) (mod cr (modulus a1)))\n     (\x3d (residue a2) (mod cr (modulus a2)))])\n  ;;\x3d\x3e [true true true]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,mX],null))],null)],null),$APP.z(gU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Ov,$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(oRb,$APP.Ov),$APP.M(oRb,$APP.Or)],null)],null)))),$APP.P,"Returns an instance of [[ModInt]] that represents integer `i` with integral\n  modulus `m`."],null)),new $APP.f(null,3,[$APP.R,oYb,$APP.X,nI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an instance of [[ModInt]] that represents integer `i` with integral\n  modulus `m`.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Ov,$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(oRb,$APP.Ov),$APP.M(oRb,$APP.Or)],null)],null)))],null)],null),$APP.z(CWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is an instance of [[ModInt]], false otherwise."],null)),new $APP.f(null,3,[$APP.R,y$b,$APP.X,TWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is an instance of [[ModInt]], false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),$APP.z(SIb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),new $APP.f(null,3,[$APP.R,Zkb,$APP.X,UWa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null)],null),$APP.Zo(q3b)),$APP.ap($APP.fg([$APP.z(Ltb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  that will take a symbolic expression, and return a simplified expression with\n  any subexpression NOT supported by the analyzer backend replaced by a\n  generated symbol.\n\n  Any replaced subexpression will map to the SAME symbol over repeated\n  invocations, unless you call the resetting function generated by passing\n  `analyzer` to [[initializer]].\n\n  For example:\n\n  ```clojure\n  (let [a  (poly-analyzer)\n        ea (expression-analyzer a)]\n    (ea '(+ x x x (sin x) (sin x))))\n  ;;\x3d\x3e (+ (* 3 x) (* 2 -s-0000000000000000))\n  ```"],
null)),$APP.z(sV,new $APP.f(null,3,[$APP.Nm,XX,$APP.P,"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression-\x3e]], so these functions are complementary.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[WS,$APP.qU,wRb],null)))],null)),$APP.z(Gfb,new $APP.f(null,3,[$APP.Nm,XX,$APP.P,"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[WS,$APP.Vv],null)))],null)),$APP.z(WOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression \x3d\x3e simplified S-expression) that will\n  reset its internal symbolic bindings at every invocation.\n\n  Equivalent to:\n\n  ```clojure\n  (let [new-analysis! (initializer analyzer)\n        simplify (expression-simplifier analyzer)]\n    (fn [expr]\n      (new-analysis!)\n      (simplify expr)))\n  ```\n\n  See [[expression-simplifier]] for a version that will assign the same symbol\n  to every expression it sees more than once."],
null)),$APP.z(Beb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression \x3d\x3e simplified S-expression) that will\n  NOT reset its internal symbolic bindings across invocations.\n\n  This can be useful if the analyzer backend has any sort of memoization or\n  caching of expressions.\n\n  Pass `analyzer` to [[initializer]] to create a function that, when called,\n  will explicitly reset the internal cache:\n\n  ```clojure\n  (def reset-analyzer! (initializer analyzer))\n  (def simplify (expression-simplifier analyzer))\n\n  (reset-analyzer!)\n  (simplify \x3cexpr\x3e)\n  ```\n\n  See [[default-simplifier]] for a version that will reset its internal variable\n  assignment cache at each invocation."],
null)),$APP.z(cLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will return the analyzer's current map of\n  generated symbol \x3d\x3e subexpression.\n\n  Call the no-argument function returned by passing `analyzer`\n  to [[initializer]] to reset the table.\n\n  For example:\n\n  ```clojure\n  (def a (poly-analyzer))\n  (def ea (expression-analyzer a))\n\n  (def get-tables (auxiliary-variable-fetcher a))\n  (def reset-tables! (initializer a))\n\n  (ea '(+ x x x (sin x) (sin x)))\n  ;;\x3d\x3e (+ (* 3 x) (* 2 -s-0000000000000000))\n\n  (get-tables)\n  ;;\x3d\x3e {'-s-0000000000000000 '(sin x)}\n\n  (reset-tables!)\n  (get-tables)\n  ;;\x3d\x3e {}\n  ```"],
null)),$APP.z(dGb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.wY],null),new $APP.H(null,2,5,$APP.I,[$APP.wY,$APP.ox],null))),$APP.P,'Called with no arguments, produces a function mapping a string prefix\n   to a generated symbol with a four-digit suffix which increments\n   with each call, providing a stream of unique symbols. If the returned\n   function is called without arguments, a default prefix of "_" is\n   used (but see below).\n\n   May be called with one integer argument to set the size of the\n   suffix field in digits.\n\n   Supplying yet one more string argument changes the default prefix.\n   ```\n   (def g (monotonic-symbol-generator))\n   (take 5 (repeatedly #(g "a")))\n   (take 5 (repeatedly g))\n   ;; (a0000 a0001 a0002 a0003 a0004)\n   ;; (_0005 _0006 _0007 _0008 _0009)\n\n\n   (def h (monotonic-symbol-generator 2))\n   (take 5 (repeatedly #(h "b")))\n   (take 5 (repeatedly h))\n   ;; (b00 b01 b02 b03 b04)\n   ;; (_05 _06 _07 _08 _09)\n\n   (def j (monotonic-symbol-generator 3 "x"))\n   (take 5 (repeatedly #(j "a")))\n   (take 5 (repeatedly j))\n   ;; (a000 a001 a002 a003 a004)\n   ;; (x005 x006 x007 x008 x009)\n   ```\n   ',
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.wY],null),new $APP.H(null,2,5,$APP.I,[$APP.wY,$APP.ox],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.wY],null),new $APP.H(null,2,5,$APP.I,[$APP.wY,$APP.ox],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(k9b,new $APP.f(null,5,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,new $APP.f(null,3,[$APP.z(IX,new $APP.f(null,1,[$APP.P,"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]]."],
null)),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[WS,$APP.Vv,FT],null),new $APP.H(null,4,5,$APP.I,[WS,$APP.Vv,FT,iT],null)],null),$APP.z(sV,new $APP.f(null,1,[$APP.P,"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression-\x3e]], so these functions are complementary."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,
3,5,$APP.I,[WS,$APP.qU,wRb],null)],null),$APP.z(Gfb,new $APP.f(null,1,[$APP.P,"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[WS,$APP.Vv],null)],null)],null)],null),$APP.Lv,new $APP.f(null,3,[B6b,new $APP.f(null,3,[$APP.R,IX,$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[WS,$APP.Vv,FT],null),new $APP.H(null,4,5,$APP.I,[WS,$APP.Vv,FT,iT],null)),$APP.P,"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]]."],
null),OWb,new $APP.f(null,3,[$APP.R,sV,$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[WS,$APP.qU,wRb],null)),$APP.P,"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression-\x3e]], so these functions are complementary."],null),Khb,new $APP.f(null,3,[$APP.R,Gfb,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[WS,$APP.Vv],null)),$APP.P,
"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise."],null)],null),$APP.P,"[[ICanonicalize]] captures the methods exposed by a Emmy analyzer backend.",eU,$APP.M("@interface")],null)),$APP.z(KBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will reset the analyzer's internal caches\n  of symbol \x3d\x3e subexpression and subexpression \x3d\x3e symbol."],
null)),$APP.z(IX,new $APP.f(null,4,[$APP.Nm,XX,$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[WS,$APP.Vv,FT],null),new $APP.H(null,4,5,$APP.I,[WS,$APP.Vv,FT,iT],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[WS,$APP.Vv,FT],null),new $APP.H(null,4,5,$APP.I,[WS,$APP.Vv,FT,iT],null)),$APP.zx,$APP.M(null,null)],null),$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[WS,$APP.Vv,FT],null),new $APP.H(null,4,5,$APP.I,
[WS,$APP.Vv,FT,iT],null))),$APP.P,"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]]."],null)),$APP.z(csb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(yYb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qV],null),new $APP.H(null,2,5,$APP.I,[qV,M4b],null))),
$APP.P,"Make-analyzer takes an analyzer `backend` (which implements [[ICanonicalize]])\n  and returns a dictionary with the apparatus necessary to prepare expressions\n  for analysis by replacing subexpressions formed from operations unknown to the\n  analyzer with generated symbols, and backsubstituting after analysis is\n  complete.\n\n  For example, in the case of polynomial canonical form, we would replace a\n  subexpression like `(sin x)` with a gensym, before entry, since the `sin`\n  operation is not available to the polynomial canonicalizer, and restore it\n  afterwards.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[qV],null),new $APP.H(null,2,5,$APP.I,[qV,M4b],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qV],null),new $APP.H(null,2,5,$APP.I,[qV,M4b],null)),$APP.zx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.R,aJb,$APP.X,function(a){return JUb.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  that will take a symbolic expression, and return a simplified expression with\n  any subexpression NOT supported by the analyzer backend replaced by a\n  generated symbol.\n\n  Any replaced subexpression will map to the SAME symbol over repeated\n  invocations, unless you call the resetting function generated by passing\n  `analyzer` to [[initializer]].\n\n  For example:\n\n  ```clojure\n  (let [a  (poly-analyzer)\n        ea (expression-analyzer a)]\n    (ea '(+ x x x (sin x) (sin x))))\n  ;;\x3d\x3e (+ (* 3 x) (* 2 -s-0000000000000000))\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))],null)],null),new $APP.f(null,3,[$APP.R,i1b,$APP.X,uWa,$APP.h,new $APP.f(null,2,[$APP.P,"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression-\x3e]], so these functions are complementary.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[WS,$APP.qU,wRb],null))],null)],null),
new $APP.f(null,3,[$APP.R,Hbc,$APP.X,vWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[WS,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,cqb,$APP.X,xWa,$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression \x3d\x3e simplified S-expression) that will\n  reset its internal symbolic bindings at every invocation.\n\n  Equivalent to:\n\n  ```clojure\n  (let [new-analysis! (initializer analyzer)\n        simplify (expression-simplifier analyzer)]\n    (fn [expr]\n      (new-analysis!)\n      (simplify expr)))\n  ```\n\n  See [[expression-simplifier]] for a version that will assign the same symbol\n  to every expression it sees more than once.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))],null)],null),new $APP.f(null,3,[$APP.R,QIb,$APP.X,EH,$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression \x3d\x3e simplified S-expression) that will\n  NOT reset its internal symbolic bindings across invocations.\n\n  This can be useful if the analyzer backend has any sort of memoization or\n  caching of expressions.\n\n  Pass `analyzer` to [[initializer]] to create a function that, when called,\n  will explicitly reset the internal cache:\n\n  ```clojure\n  (def reset-analyzer! (initializer analyzer))\n  (def simplify (expression-simplifier analyzer))\n\n  (reset-analyzer!)\n  (simplify \x3cexpr\x3e)\n  ```\n\n  See [[default-simplifier]] for a version that will reset its internal variable\n  assignment cache at each invocation.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))],null)],null),new $APP.f(null,3,[$APP.R,$kb,$APP.X,function(a){return PMb.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will return the analyzer's current map of\n  generated symbol \x3d\x3e subexpression.\n\n  Call the no-argument function returned by passing `analyzer`\n  to [[initializer]] to reset the table.\n\n  For example:\n\n  ```clojure\n  (def a (poly-analyzer))\n  (def ea (expression-analyzer a))\n\n  (def get-tables (auxiliary-variable-fetcher a))\n  (def reset-tables! (initializer a))\n\n  (ea '(+ x x x (sin x) (sin x)))\n  ;;\x3d\x3e (+ (* 3 x) (* 2 -s-0000000000000000))\n\n  (get-tables)\n  ;;\x3d\x3e {'-s-0000000000000000 '(sin x)}\n\n  (reset-tables!)\n  (get-tables)\n  ;;\x3d\x3e {}\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))],null)],null),new $APP.f(null,3,[$APP.R,amb,$APP.X,DM,$APP.h,new $APP.f(null,2,[$APP.P,'Called with no arguments, produces a function mapping a string prefix\n   to a generated symbol with a four-digit suffix which increments\n   with each call, providing a stream of unique symbols. If the returned\n   function is called without arguments, a default prefix of "_" is\n   used (but see below).\n\n   May be called with one integer argument to set the size of the\n   suffix field in digits.\n\n   Supplying yet one more string argument changes the default prefix.\n   ```\n   (def g (monotonic-symbol-generator))\n   (take 5 (repeatedly #(g "a")))\n   (take 5 (repeatedly g))\n   ;; (a0000 a0001 a0002 a0003 a0004)\n   ;; (_0005 _0006 _0007 _0008 _0009)\n\n\n   (def h (monotonic-symbol-generator 2))\n   (take 5 (repeatedly #(h "b")))\n   (take 5 (repeatedly h))\n   ;; (b00 b01 b02 b03 b04)\n   ;; (_05 _06 _07 _08 _09)\n\n   (def j (monotonic-symbol-generator 3 "x"))\n   (take 5 (repeatedly #(j "a")))\n   (take 5 (repeatedly j))\n   ;; (a000 a001 a002 a003 a004)\n   ;; (x005 x006 x007 x008 x009)\n   ```\n   ',
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.wY],null),new $APP.H(null,2,5,$APP.I,[$APP.wY,$APP.ox],null))],null)],null),new $APP.f(null,3,[$APP.R,XX,$APP.X,function(){},$APP.h,new $APP.f(null,1,[$APP.P,"[[ICanonicalize]] captures the methods exposed by a Emmy analyzer backend."],null)],null),new $APP.f(null,3,[$APP.R,Onb,$APP.X,function(a){return fIb.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will reset the analyzer's internal caches\n  of symbol \x3d\x3e subexpression and subexpression \x3d\x3e symbol.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WS],null))],null)],null),new $APP.f(null,3,[$APP.R,Iub,$APP.X,W_,$APP.h,new $APP.f(null,2,[$APP.P,"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]].",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[WS,$APP.Vv,FT],null),new $APP.H(null,4,5,$APP.I,
[WS,$APP.Vv,FT,iT],null))],null)],null),new $APP.f(null,3,[$APP.R,HUb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Gcc,$APP.X,EM,$APP.h,new $APP.f(null,2,[$APP.P,"Make-analyzer takes an analyzer `backend` (which implements [[ICanonicalize]])\n  and returns a dictionary with the apparatus necessary to prepare expressions\n  for analysis by replacing subexpressions formed from operations unknown to the\n  analyzer with generated symbols, and backsubstituting after analysis is\n  complete.\n\n  For example, in the case of polynomial canonical form, we would replace a\n  subexpression like `(sin x)` with a gensym, before entry, since the `sin`\n  operation is not available to the polynomial canonicalizer, and restore it\n  afterwards.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qV],null),new $APP.H(null,2,5,$APP.I,[qV,M4b],null))],null)],null)]),$APP.Zo(Eqb)),$APP.ap($APP.fg([$APP.z(xDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[jIb],null))),$APP.P,"Find the most relaxed possible statement of the joint arity of the given sequence of `arities`.\n  If they are incompatible, an exception is thrown."],null)),$APP.z(CU,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(ndc,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,ZT],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,ZT,$APP.Or],null))),$APP.P,"Appends the supplied `arity` to the metadata of `f`, knocking out any\n  pre-existing arity notation.\n\n  Optionally accepts a third parameter `m` of metadata to attach to the return\n  function, in addition to the new `:arity` key.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,ZT],null),new $APP.H(null,
3,5,$APP.I,[$APP.Kv,ZT,$APP.Or],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,ZT],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,ZT,$APP.Or],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(JDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,ZT],null))),$APP.P,"Given an [[emmy.value/scalar?]] input `x`, returns a function of arity `arity`\n  that always returns `x` no matter what input it receives.\n\n  For non-numerical `x`, returns `x`."],null)),
$APP.z(AYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Returns true if `f` is of [[v/kind]] `::v/function`, false otherwise."],null)),$APP.z(hbb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"Returns the joint arity of arities `a` and `b`.\n\n  The joint arity is the loosest possible arity specification compatible with\n  both `a` and `b`. Throws if `a` and `b` are incompatible.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z($APP.Wv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,wW],null),new $APP.H(null,3,5,$APP.I,
[$APP.Kv,wW,$APP.uu],null))),$APP.P,"For non-functions, acts like [[clojure.core/get-in]]. For function\n  arguments (anything that responds true to [[function?]]), returns\n\n  ```clojure\n  (comp #(clojure.core/get-in % ks) f)\n  ```\n\n  If `not-found` is supplied it's passed through to the\n  composed [[clojure.core/get-in]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,wW],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,
wW,$APP.uu],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,wW],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,wW,$APP.uu],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z($APP.vua,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"meta-preserving version of `clojure.core/memoize`.\n\n  The returned function will have a new `:arity` entry in its metadata with the\n  `arity` of the original `f`; this is because the process used to figure out a\n  function's arity will not work across the memoization boundary."],
null)),$APP.z($APP.Lw,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.tU,$APP.uu],null))),$APP.P,"For non-functions, acts like [[clojure.core/get]]. For function\n  arguments (anything that responds true to [[function?]]), returns\n\n  ```clojure\n  (comp #(clojure.core/get % k) f)\n  ```\n\n  If `not-found` is supplied it's passed through to the\n  composed [[clojure.core/get]].",$APP.hy,new $APP.f(null,6,
[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.tU,$APP.uu],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.tU,$APP.uu],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Cjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))),$APP.P,"Returns the most general arity compatible with the aritiies of all entries in\n  the supplied sequence `xs` of values."],
null)),$APP.z(dU,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,mV],null))),$APP.P,"Takes a function `f` and a sequence of `factors`, and returns a new function\n  that multiplies each factor by the corresponding argument of `f`. Too many or\n  two few factors are ignored.\n\n  ```clojure\n  ((arg-scale square 3) 4) \x3d\x3d\x3e 144\n  ((arg-scale square 3 2 1) 4) \x3d\x3d\x3e 144\n  ```",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,
new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Kv,mV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,mV],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(FX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,yY],null))),$APP.P,"Takes a function `f` and a sequence of `shifts`, and returns a new function\n  that adds each shift to the corresponding argument of `f`. Too many or two few\n  shifts are ignored.\n\n  ```clojure\n  ((arg-shift square 3) 4) \x3d\x3d\x3e 49\n  ((arg-shift square 3 2 1) 4) \x3d\x3d\x3e 49\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Kv,yY)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,yY],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(Rxb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(ZT,new $APP.f(null,3,[$APP.Nm,RV,$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],
null)),$APP.z(fbc,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,new $APP.f(null,1,[$APP.z(ZT,new $APP.f(null,1,[$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null)],null)],null),$APP.Lv,new $APP.f(null,1,[XH,new $APP.f(null,3,[$APP.R,ZT,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)),$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection."],
null)],null),eU,$APP.M("@interface")],null)),$APP.z($APP.KK,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$V],null))),$APP.P,"Arity-preserving version of `clojure.core/comp`.\n\n  The arity of a composition is the arity of the rightmost (that is, first to be\n  applied) function term in `fns`.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($V)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$V],null)),
$APP.zx,$APP.M(null)],null)],null))],[new $APP.f(null,3,[$APP.R,qLb,$APP.X,MWa,$APP.h,new $APP.f(null,2,[$APP.P,"Find the most relaxed possible statement of the joint arity of the given sequence of `arities`.\n  If they are incompatible, an exception is thrown.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[jIb],null))],null)],null),new $APP.f(null,3,[$APP.R,wYb,$APP.X,$APP.Kd,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,PJb,$APP.X,VH,$APP.h,new $APP.f(null,2,[$APP.P,"Appends the supplied `arity` to the metadata of `f`, knocking out any\n  pre-existing arity notation.\n\n  Optionally accepts a third parameter `m` of metadata to attach to the return\n  function, in addition to the new `:arity` key.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,ZT],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,ZT,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,c8b,$APP.X,eI,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[emmy.value/scalar?]] input `x`, returns a function of arity `arity`\n  that always returns `x` no matter what input it receives.\n\n  For non-numerical `x`, returns `x`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,ZT],null))],null)],null),new $APP.f(null,3,[$APP.R,nlb,$APP.X,UH,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if `f` is of [[v/kind]] `::v/function`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,oEb,$APP.X,dI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the joint arity of arities `a` and `b`.\n\n  The joint arity is the loosest possible arity specification compatible with\n  both `a` and `b`. Throws if `a` and `b` are incompatible.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,
2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,YGb,$APP.X,$H,$APP.h,new $APP.f(null,2,[$APP.P,"For non-functions, acts like [[clojure.core/get-in]]. For function\n  arguments (anything that responds true to [[function?]]), returns\n\n  ```clojure\n  (comp #(clojure.core/get-in % ks) f)\n  ```\n\n  If `not-found` is supplied it's passed through to the\n  composed [[clojure.core/get-in]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,wW],null),new $APP.H(null,3,5,$APP.I,
[$APP.Kv,wW,$APP.uu],null))],null)],null),new $APP.f(null,3,[$APP.R,Olb,$APP.X,YH,$APP.h,new $APP.f(null,2,[$APP.P,"meta-preserving version of `clojure.core/memoize`.\n\n  The returned function will have a new `:arity` entry in its metadata with the\n  `arity` of the original `f`; this is because the process used to figure out a\n  function's arity will not work across the memoization boundary.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,ghb,
$APP.X,ZH,$APP.h,new $APP.f(null,2,[$APP.P,"For non-functions, acts like [[clojure.core/get]]. For function\n  arguments (anything that responds true to [[function?]]), returns\n\n  ```clojure\n  (comp #(clojure.core/get % k) f)\n  ```\n\n  If `not-found` is supplied it's passed through to the\n  composed [[clojure.core/get]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.tU],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.tU,$APP.uu],null))],null)],null),new $APP.f(null,3,[$APP.R,Xjb,$APP.X,
NWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the most general arity compatible with the aritiies of all entries in\n  the supplied sequence `xs` of values.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,hJb,$APP.X,cI,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function `f` and a sequence of `factors`, and returns a new function\n  that multiplies each factor by the corresponding argument of `f`. Too many or\n  two few factors are ignored.\n\n  ```clojure\n  ((arg-scale square 3) 4) \x3d\x3d\x3e 144\n  ((arg-scale square 3 2 1) 4) \x3d\x3d\x3e 144\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,mV],null))],null)],null),new $APP.f(null,3,[$APP.R,Yab,$APP.X,bI,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function `f` and a sequence of `shifts`, and returns a new function\n  that adds each shift to the corresponding argument of `f`. Too many or two few\n  shifts are ignored.\n\n  ```clojure\n  ((arg-shift square 3) 4) \x3d\x3d\x3e 49\n  ((arg-shift square 3 2 1) 4) \x3d\x3d\x3e 49\n  ```",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,
$APP.Lh,yY],null))],null)],null),new $APP.f(null,3,[$APP.R,xcb,$APP.X,!1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,wBb,$APP.X,SH,$APP.h,new $APP.f(null,2,[$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,RV,$APP.X,GWa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,y9b,$APP.X,WH,$APP.h,new $APP.f(null,2,[$APP.P,"Arity-preserving version of `clojure.core/comp`.\n\n  The arity of a composition is the arity of the rightmost (that is, first to be\n  applied) function term in `fns`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$V],null))],null)],null)]),$APP.Zo(lfb)),$APP.ap($APP.fg([$APP.z(zCb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[eT,MVb,d0b],null),$APP.Vv],null))),$APP.P,"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using a second-order variation of [[kahan-babushka-neumaier]].\n\n  See [this Wikipedia\n  page](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements)\n  for more information.\n\n  This algorithm was proposed by Klein in ['A Generalized Kahan-Babushka\n  Summation\n  Algorithm'](https://citeseerx.ist.psu.edu/viewdoc/download?doi\x3d10.1.1.582.288\x26rep\x3drep1\x26type\x3dpdf),\n  along with the higher-order versions implemented by [[kbk-n]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[eT,MVb,d0b],null),$APP.Vv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[eT,MVb,d0b],null),$APP.Vv],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(bdc,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,
1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Jv],null),$APP.Vv],null))),$APP.P,"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using Neumaier's improvement to [[kahan]].\n\n  This algorithm is more efficient than [[kahan]], handles a wider range of\n  cases (adding in numbers larger than the current running sum, for example) and\n  should be preferred.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,
new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Jv],null),$APP.Vv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Jv],null),$APP.Vv],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z($APP.qv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Ey],null))),$APP.P,"Given some predicate `pred`, returns a fold that counts the number of items it\n  encounters that return true when passed to `pred`, false otherwise.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Ey],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Ey],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(YS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[r3b],null))),$APP.P,"Given some value `const`, returns a fold that ignores all input and returns\n  `const` for a call to any of its arities."],null)),$APP.z($APP.wu,
new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,3,5,$APP.I,[lU,$APP.Lh,J5b],null))),$APP.P,"Given some number of `folds`, returns a new fold with the following properties:\n\n  - the accumulator is a vector of the accumulators of each input fold\n  - each `x` is merged into each accumulator using the appropriate fold\n  - `present` is called for every entry in the final vector\n\n  Given a single `fold`, acts as identity.\n\n  The no-argument call `(join)` is equivalent to `([[constant]] [])`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[lU],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,3,5,$APP.I,[lU,$APP.Lh,J5b],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(C9b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Hv],null)],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,
[eT,$APP.Jv],null),$APP.Vv],null))),$APP.P,"Fold that tracks the summation of a sequence of floating point numbers, using\n  the [Kahan summation\n  algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) for\n  maintaining stability in the face of accumulating floating point errors.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Hv],null)],null),new $APP.H(null,2,5,
$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Jv],null),$APP.Vv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Hv],null)],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Jv],null),$APP.Vv],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z($APP.kva,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null))),$APP.P,"Fold that stores its minimum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(eYb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,2,5,$APP.I,[lU,$APP.HT],null),new $APP.H(null,
3,5,$APP.I,[$APP.Cy,lU,$APP.HT],null))),$APP.P,'Given\n\n  - a 0-argument fn `init` that returns some "empty" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) \x3d\x3e accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator \x3d\x3e final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns the result of accumulating all elements in `xs` using the functions\n  above, then `present`ing the result.\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns the result of\n  accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.',
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,2,5,$APP.I,[lU,$APP.HT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,lU,$APP.HT],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,2,5,$APP.I,[lU,$APP.HT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,lU,$APP.HT],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),p2b,$APP.z($APP.rw,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,
new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null))),$APP.P,"Fold that stores its maximum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),
new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(d2b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null))),$APP.P,"Fold-style function. The 2-arity merge operation adds the value `x` into the\n  accumulating stating using [[emmy.generic/+]].\n\n  - given 0 arguments, returns an accumulator of 0.0\n  - given a single argument `acc`, acts as identity.",$APP.hy,new $APP.f(null,
6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(Mbb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,2,5,$APP.I,[lU,$APP.HT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,lU,
$APP.HT],null))),$APP.P,'Given\n\n  - a 0-argument fn `init` that returns some "empty" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) \x3d\x3e accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator \x3d\x3e final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns a lazy sequence of all intermediate results of the summation. For\n  example, given [0 1 2 3], the return sequence would be equivalent to:\n\n  ```clj\n  (def sum-fn (fold-\x3esum-fn init fold present))\n\n  [(sum-fn [0])\n   (sum-fn [0 1])\n   (sum-fn [0 1 2])\n   (sum-fn [0 1 2 3])]\n  ```\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns a lazy sequence of all\n  intermediate results of accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.',
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,2,5,$APP.I,[lU,$APP.HT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,lU,$APP.HT],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,2,5,$APP.I,[lU,$APP.HT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,lU,$APP.HT],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),mub],[new $APP.f(null,3,[$APP.R,bZb,$APP.X,K_,$APP.h,new $APP.f(null,
2,[$APP.P,"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using a second-order variation of [[kahan-babushka-neumaier]].\n\n  See [this Wikipedia\n  page](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements)\n  for more information.\n\n  This algorithm was proposed by Klein in ['A Generalized Kahan-Babushka\n  Summation\n  Algorithm'](https://citeseerx.ist.psu.edu/viewdoc/download?doi\x3d10.1.1.582.288\x26rep\x3drep1\x26type\x3dpdf),\n  along with the higher-order versions implemented by [[kbk-n]].",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[eT,MVb,d0b],null),$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,aRb,$APP.X,DI,$APP.h,new $APP.f(null,2,[$APP.P,"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using Neumaier's improvement to [[kahan]].\n\n  This algorithm is more efficient than [[kahan]], handles a wider range of\n  cases (adding in numbers larger than the current running sum, for example) and\n  should be preferred.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Jv],null),$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,htb,$APP.X,F_,$APP.h,new $APP.f(null,2,[$APP.P,"Given some predicate `pred`, returns a fold that counts the number of items it\n  encounters that return true when passed to `pred`, false otherwise.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Ey],null))],null)],null),new $APP.f(null,3,[$APP.R,Hjb,$APP.X,
RTa,$APP.h,new $APP.f(null,2,[$APP.P,"Given some value `const`, returns a fold that ignores all input and returns\n  `const` for a call to any of its arities.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[r3b],null))],null)],null),new $APP.f(null,3,[$APP.R,dCb,$APP.X,I_,$APP.h,new $APP.f(null,2,[$APP.P,"Given some number of `folds`, returns a new fold with the following properties:\n\n  - the accumulator is a vector of the accumulators of each input fold\n  - each `x` is merged into each accumulator using the appropriate fold\n  - `present` is called for every entry in the final vector\n\n  Given a single `fold`, acts as identity.\n\n  The no-argument call `(join)` is equivalent to `([[constant]] [])`.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,3,5,$APP.I,[lU,$APP.Lh,J5b],null))],null)],null),new $APP.f(null,3,[$APP.R,cgb,$APP.X,J_,$APP.h,new $APP.f(null,2,[$APP.P,"Fold that tracks the summation of a sequence of floating point numbers, using\n  the [Kahan summation\n  algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) for\n  maintaining stability in the face of accumulating floating point errors.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,
[new $APP.H(null,2,5,$APP.I,[eT,$APP.Hv],null)],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[eT,$APP.Jv],null),$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,NZb,$APP.X,G_,$APP.h,new $APP.f(null,2,[$APP.P,"Fold that stores its minimum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null))],null)],
null),new $APP.f(null,3,[$APP.R,sJb,$APP.X,E_,$APP.h,new $APP.f(null,2,[$APP.P,'Given\n\n  - a 0-argument fn `init` that returns some "empty" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) \x3d\x3e accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator \x3d\x3e final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns the result of accumulating all elements in `xs` using the functions\n  above, then `present`ing the result.\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns the result of\n  accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.',
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,2,5,$APP.I,[lU,$APP.HT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,lU,$APP.HT],null))],null)],null),new $APP.f(null,3,[$APP.R,pec,$APP.X,function(a,b,c){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Yx,null,1,null),$Ta(c))))},$APP.h,new $APP.f(null,4,[$APP.P,"Given some order `n`, returns a fold implementing `n`-th order\n  Kahan-Babushka-Klein summation.\n\n  Given `n` \x3d\x3d 0, this is identical to a naive sum.\n  Given `n` \x3d\x3d 1, identical to [[kahan-babushka-neumaier]].\n  Given `n` \x3d\x3d 2, identical to [[kahan-babushka-klein]].\n\n  `n` \x3e 2 represent new compensated summation algorithms.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,vSb,$APP.X,H_,$APP.h,new $APP.f(null,2,[$APP.P,"Fold that stores its maximum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,YBb,$APP.X,D_,$APP.h,new $APP.f(null,
2,[$APP.P,"Fold-style function. The 2-arity merge operation adds the value `x` into the\n  accumulating stating using [[emmy.generic/+]].\n\n  - given 0 arguments, returns an accumulator of 0.0\n  - given a single argument `acc`, acts as identity.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[eT],null),new $APP.H(null,2,5,$APP.I,[eT,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,gNb,$APP.X,EI,$APP.h,new $APP.f(null,2,[$APP.P,'Given\n\n  - a 0-argument fn `init` that returns some "empty" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) \x3d\x3e accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator \x3d\x3e final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns a lazy sequence of all intermediate results of the summation. For\n  example, given [0 1 2 3], the return sequence would be equivalent to:\n\n  ```clj\n  (def sum-fn (fold-\x3esum-fn init fold present))\n\n  [(sum-fn [0])\n   (sum-fn [0 1])\n   (sum-fn [0 1 2])\n   (sum-fn [0 1 2 3])]\n  ```\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns a lazy sequence of all\n  intermediate results of accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.',
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lU],null),new $APP.H(null,2,5,$APP.I,[lU,$APP.HT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,lU,$APP.HT],null))],null)],null),new $APP.f(null,3,[$APP.R,wKb,$APP.X,DI,$APP.h,$APP.F],null)]),$APP.Zo(h6b)),$APP.ap($APP.fg([$APP.z(k$b,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(svb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given some 2-tensor-shaped structure `s`, returns the corresponding matrix.\n\n  The outer orientation is ignored; If the inner structures are `up`, they're\n  treated as columns. Inner `down` structures are treated as rows."],
null)),$APP.z(z2b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,zV],null))),$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  Variadic equivalent to [[by-rows*]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(zV)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,zV],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(oY,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns true if `m` is a matrix with a single column (a 'column matrix'),\n  false otherwise."],null)),$APP.z(lSb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null)))],null)),$APP.z(b_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns the number of rows of the supplied matrix `m`. Throws if a\n  non-matrix is supplied."],
null)),$APP.z(tfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"If `m` is already a vector, acts as identity. Else, returns the matrix as a\n  vector of rows (or throws if neither of these types is passed)."],null)),$APP.z(ZYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(oY,$APP.Or)],null)],null)))),$APP.P,"Returns the single column from the supplied column matrix as a vector. Errors\n  if some other type is supplied."],
null)),$APP.z(CJb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(Cvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,JV],null))),$APP.P,"Returns a column matrix of `nrows` symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-column-matrix 'x 3)\n     (by-cols ['x0 'x1 'x2]))\n  ```"],null)),$APP.z($APP.AY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),
new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(xY,$APP.Or)],null)],null)))),$APP.P,"Returns the 'dimension', i.e., the number of rows \x26 columns, of the supplied\n  square matrix. Errors if some other type is supplied."],null)),$APP.z(xY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns true if `m` is a square matrix, false otherwise."],null)),$APP.z(WAb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(EAb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))),$APP.P,"Returns true if the supplied matrix `M` is equal to the negation of its own\n  transpose (i.e., antisymmetric), false otherwise."],null)),$APP.z(efb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.uU],null))),$APP.P,"Returns the `n`-th column of the supplied matrix `m` as an `up` structure."],null)),$APP.z(WZb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(ZUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(XUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Vx,gX],null))),$APP.P,"Returns a row matrix of `ncols` symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-row-matrix 'x 3)\n     (by-rows ['x_0 'x_1 'x_2]))\n  ```"],null)),$APP.z(iKb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null))),$APP.P,"Convert the structure `ms`, which would be a scalar if the (compatible)\n  multiplication `(* ls ms rs)` were performed, to a matrix.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(hX,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(CU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),$APP.P,"Return the identity matrix of order `n`."],
null)),$APP.z(Kpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(bY,$APP.Tv)],null)],null)))),$APP.P,"Returns a column matrix with the contents of the supplied `up` structure.\n  Errors if any other type is provided."],null)),$APP.z(Yqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.gT,$APP.JX,YU,$APP.zv],null))),$APP.P,"Given coefficient procedures `add`, `sub`, `mul` and `zero?`, returns a\n  procedure that efficiently computes the determinant of the supplied square\n  matrix `m`.\n\n  [[general-determinant]] is useful for generating fast type-specific\n  determinant routines. See [[determinant]] for a default using generic\n  arithmetic."],
null)),$APP.z(qWb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null))),$APP.P,"Given structural inputs `ls` (optional), `ms` and `rs`, constrained such\n  that `(* ls ms rs)` returns a numerical quantity, returns a result such that\n  the following relationship remains true:\n\n  ```clj\n  (* \x3cls| (* ms |rs\x3e)) \x3d (* \x3crs| (* (s:transpose ms) |ls\x3e))\n  ```\n\n  For example:\n\n  ```clj\n  (let [ls (s/up 1 2)\n      ms (s/up (s/down 1 2) (s/down 3 4))\n      rs (s/down 1 2)]\n  (g/* ls (g/* ms rs))\n  ;;\x3d\x3e 27\n\n  (g/* rs (g/* (s:transpose ls ms rs) ls))\n  ;;\x3d\x3e 27\n  )\n  ```\n\n  `ls` is optional. If `ls` is not supplied, a compatible shape is generated\n  internally.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(THb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.hx,
$APP.fx)],null)],null)))),$APP.P,"Returns a row matrix populated by the supplied `xs`. For a variadic equivalent,\n  see [[row]]."],null)),$APP.z(B4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(oY,$APP.Or)],null)],null)))),$APP.P,"Returns the single column from the supplied column matrix as an `up`. Errors if\n  some other type is supplied."],null)),$APP.z(aY,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(xY,$APP.Or)],null)],null)))),$APP.P,"Returns the trace (the sum of diagonal elements) of the square matrix `m`.\n\n  Generic operations are used, so this works on symbolic square matrices."],null)),$APP.z(tdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))),$APP.P,"Convert a sequence `xs` (typically, of function arguments) to an up-structure.\n\n  Any matrix present in the argument list will be converted to row of columns\n  via [[-\x3estructure]]."],
null)),$APP.z(p7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.hx,$APP.fx)],null)],null)))),$APP.P,"Returns a column matrix populated by the supplied `xs`. For a variadic equivalent,\n  see [[column]]."],null)),$APP.z(Z0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[fX],null))),$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  for a variadic equivalent, see [[by-cols]]."],
null)),$APP.z(jQb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Jv,$APP.Kv],null))),$APP.P,"Returns a matrix with `r` rows and `c` columns, whose entries are generated by\n  the supplied function `f`.\n\n  If you only supply one dimension `n` the returned matrix will be square.\n\n  The entry in the `i`th row and `j`-th column is `(f i j)`.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,
new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Jv,$APP.Kv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Jv,$APP.Kv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(z8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Or,$APP.Ov,sU],null))),$APP.P,"Returns the matrix formed by deleting the `i`-th row and `j`-th column of the\n  given matrix `m`.\n\n  This is also called the 'minor' of m."],
null)),$APP.z(Alb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),$APP.z(new $APP.H(null,4,5,$APP.I,[$APP.Or,nV,gY,wTb],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(u_b,nV),$APP.M(u_b,gY)],null)],null)))),$APP.P,"Returns a structure generated by converting `m` into a nested structure with\n  the supplied `outer-orientation` and `inner-orientation`.\n\n  If `t?` is true, the columns of `m` will form the inner tuples. If `t?` is\n  false, the rows of `m` will form the inner tuples.\n\n  By default, if you supply a single argument (the matrix `m`), a matrix turns\n  into a single outer `::s/down` of inner columns represented as `::up`\n  structures.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.H(null,4,5,$APP.I,[$APP.Or,nV,gY,wTb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.H(null,4,5,$APP.I,[$APP.Or,nV,gY,wTb],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(JPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[yW,$APP.Or,KW],null))),$APP.P,"Convert the matrix `m` into a structure `S`, guided by the requirement that `(*\n  ls S rs)` should be a scalar."],
null)),$APP.z(UAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,dX],null))),$APP.P,"Converts the square structure `s` into a matrix, and calls the supplied\n  continuation `cont` with\n\n  - the generated matrix\n  - a function which will restore a matrix to a structure with the same inner\n    and outer orientations as s\n\n  Returns the result of the continuation call."],null)),$APP.z(bcb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(xY,$APP.Or)],null)],null)))),$APP.P,"Returns the diagonal of the supplied matrix `m` as an up structure. Errors if a\n  type other than a diagonal matrix is supplied."],null)),$APP.z(UHb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,fX],null))),$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  Variadic equivalent to [[by-cols*]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(fX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,fX],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z($APP.Uza,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Or],null))),$APP.P,"Returns true if `f` is true for some element of the matrix `m`, false\n  otherwise. (Also works on arbitrary nested sequences.)"],null)),$APP.z($APP.Wv,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,gSb],null))),$APP.P,"Like [[clojure.core/get-in]] for matrices, but obeying the scmutils convention:\n  only one index is required to get an unboxed element from a column vector.\n\n  NOTE that this is perhaps an unprincipled exception..."],null)),$APP.z(xdb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[FU,oBb],null)))],null)),$APP.z(rsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[AU],null))),$APP.P,"Any one argument function of a structure can be seen as a matrix. This is only\n  useful if the function has a linear multiplier (e.g. derivative)"],null)),$APP.z(ABb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,JV],null),new $APP.H(null,3,5,$APP.I,[$APP.Vx,JV,gX],null))),$APP.P,"Generates a `nrows` x `ncols` matrix of symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  If `ncols` (the third argument) is not supplied, returns a square matrix of\n  size `nrows` x `nrows`.\n\n  NOTE: The symbols in the returned matrix record their Einstein-notation path\n  into the structure that this matrix represents; a `down` of `up` columns. This\n  means that the returned indices embedded in the symbols look flipped, `ji` vs\n  `ij`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-matrix 'x 2 2)\n     (by-rows ['x_00 'x_10]\n              ['x_01 'x_11]))\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Vx,JV],null),new $APP.H(null,3,5,$APP.I,[$APP.Vx,JV,gX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,JV],null),new $APP.H(null,3,5,$APP.I,[$APP.Vx,JV,gX],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Cmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.uU],null))),$APP.P,"Returns the `n`-th row of the supplied matrix `m` as a `down` structure."],
null)),$APP.z(VHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(ePb,$APP.Tv)],null)],null)))),$APP.P,"Returns a row matrix with the contents of the supplied `down` structure.\n  Errors if any other type is provided."],null)),$APP.z(Q5b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.uU],null))),$APP.P,"Return a zero-valued matrix of `m` rows and `n` columns (`nXn` if only `n` is\n  supplied).",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.uU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.uU],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(lGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,
[$APP.M(BV,$APP.Or)],null)],null)))),$APP.P,"Returns the single row from the supplied row matrix as a vector. Errors if some\n  other type is supplied."],null)),$APP.z(c4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Or,$APP.Ov,$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,4,5,$APP.I,[$APP.M(iec,$APP.Or),$APP.M($APP.Uv,0,$APP.Ov),$APP.M($APP.Xv,$APP.Ov,$APP.M(b_b,$APP.Or)),$APP.M($APP.Zv,$APP.M(gsb,$APP.Or),$APP.M($APP.qv,$APP.Tv))],null)],null)))),
$APP.P,"Returns a new matrix of identical shape to `m`, with the vector `v` substituted\n  for the `i`th row."],null)),$APP.z(x8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.gT,$APP.JX,YU,JY,$APP.zv],null))),$APP.P,"Given coefficient procedures `add`, `sub`, `mul`, `div` and `zero?`, returns a\n  procedure that efficiently computes the solution to an inhomogeneous system of\n  linear equations, `A*x\x3db`, where the matrix `A` and the column matrix `b` are\n  given. The returned procedure returns the column matrix `x`.\n\n  Unlike LU decomposition, Cramer's rule generalizes to symbolic solutions.\n\n  [[cramers-rule]] is useful for generating fast type-specific linear equation\n  solvers. See [[solve]] for a default using generic arithmetic."],
null)),$APP.z(rKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given some 2 tensor `s`, returns a structure with elements 'transposed' by\n  swapping the inner and outer orientations and dimensions, like a matrix\n  transpose.\n\n  Orientations are only flipped if they are different in the input. If the inner\n  and outer orientations of `s` are the same, the returned structure has this\n  identical orientation.\n\n  For example:\n\n  ```clj\n  ;; opposite orientation gets flipped:\n  (s:transpose-orientation (s/up (s/down 1 2 3) (s/down 4 5 6)))\n  ;;\x3d\x3e (down (up 1 4) (up 2 5) (up 3 6))\n\n  ;; same orientation stays the same:\n  (s:transpose-orientation (s/down (s/down 1 2 3) (s/down 4 5 6)))\n  ;;\x3d\x3e (down (down 1 4) (down 2 5) (down 3 6))\n  ```\n\n  See [[structure/two-tensor?]] for more detail on 2 tensors.\n\n  NOTE: In scmutils, this function is called `s:transpose2`."],
null)),$APP.z($APP.VBa,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))),$APP.P,"Returns a row matrix populated by the supplied `xs`. Variadic equivalent\n  to [[row*]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.fx)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(T$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[zV],null))),$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  for a variadic equivalent, see [[by-rows]]."],null)),$APP.z(iOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.Vv],null))),$APP.P,"Returns the [characteristic\n  polynomial](https://en.wikipedia.org/wiki/Characteristic_polynomial) of the\n  square matrix `m`.\n\n  If only `m` is supplied, returns a [[polynomial/Polynomial]] instance\n  representing the matrix `m`'s characteristic polynomial.\n\n  If `x` is supplied, returns the value of the characteristic polynomial of `m`\n  evaluated at `x`.\n\n  Typically `x` will be a symbolic variable, but if you wanted to get the value\n  of the characteristic polynomial at some particular numerical point `x` you\n  could pass that too.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.Vv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.Vv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(yXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[oBb,FU],null)))],null)),$APP.z(Bnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[zU,$APP.qU],null)))],null)),$APP.z(p1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(xY,$APP.Or)],null)],null)))),$APP.P,"Returns the matrix of cofactors of the supplied square matrix `m`."],null)),$APP.z(eMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))),$APP.P,"Returns true if the supplied matrix `M` is equal to its own transpose (i.e.,\n  symmetric), false otherwise."],
null)),$APP.z(fac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given some 2-tensor `s` (a 'square' nested structure), returns a structure\n  that represents the multiplicative inverse of the supplied structure. The\n  inner and outer structure orientations of `(s:invert s)` are the SAME as `s`.\n\n  If `s` is an up-of-downs or down-of-ups, `(g/* s (s:invert s))`\n  and `(g/* (s:invert s) s)` will evaluate to an identity-matrix-shaped\n  up-of-downs or down-of-ups.\n\n  If `s` is an up-of-ups or down-of-downs, multiplying `s` `(s:invert s)` will\n  result in a scalar, as both structures collapse.\n\n  NOTE: I DO NOT yet understand the meaning of this scalar! If you do, please\n  open a pull request and explain it here."],
null)),$APP.z($APP.VX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns the transpose of the matrix `m`. The transpose is the original matrix,\n  with rows and columns swapped."],null)),$APP.z($APP.kv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))),$APP.P,"Returns a column matrix populated by the supplied `xs`. Variadic equivalent\n  to [[column*]].",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,
$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.fx)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(j6b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.gT,$APP.JX,YU,JY,$APP.zv],null))),$APP.P,"Given coefficient procedures `add`, `sub`, `mul` and `zero?`, returns a\n  procedure that efficiently computes the inverse of the supplied square\n  matrix `m`.\n\n  [[classical-adjoint-formula]] is useful for generating fast type-specific\n  matrix inversion routines. See [[invert]] for a default using generic\n  arithmetic."],
null)),$APP.z(BV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns true if `m` is a matrix with a single row (a 'row matrix'), false\n  otherwise."],null)),$APP.z(tIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(BV,$APP.Or)],null)],null)))),$APP.P,"Returns the single row from the supplied row matrix as a `down`. Errors if some\n  other type is supplied."],
null)),$APP.z(iec,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns true if the supplied `m` is an instance of [[Matrix]], false\n  otherwise."],null)),$APP.z(gsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns the number of columns of the supplied matrix `m`. Throws if a\n  non-matrix is supplied."],null)),$APP.z(QGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Kv,$APP.Or],null))),$APP.P,"Maps `f` over three arguments:\n\n  - each element of the matrix `m`\n  - its row `i`\n  - its column `j`\n\n  and returns a new matrix of the same dimensions as `m`. "],null)),$APP.z(L_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[sTb,$APP.Sv],null)))],null)),$APP.z(hfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.qU,zU],null))),$APP.P,"Generalization of [[solve]] that can handle `up` and `down` structures, as well\n  as `row` and `column` matrices.\n\n  Given `row` or `down` values for `b`, `A` is appropriately transposed before\n  solving."],
null)),$APP.z(x9b,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,15,[$S,"null",kU,"null",SW,"null",hU,"null",WE,"null",$Lb,"null",xX,"null",SS,"null",rS,"null",LY,"null",gV,"null",uY,"null",RW,"null",jW,"null",RV,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Jv,$APP.Tv],null))),VR,new $APP.ug(null,new $APP.f(null,10,[$S,"null",kU,"null",SW,"null",xX,"null",SS,"null",rS,"null",gV,"null",uY,"null",RW,"null",jW,"null"],null),null),$APP.P,
"Positional factory function for emmy.matrix/Matrix."],null)),$APP.z(Dfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Kv],null))),$APP.P,"Applies matrix operation `f` to square structure `s` and returns a structure of\n  the same type as the supplied structure."],null)),$APP.z(jS,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(sIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns true if `m` is a diagonal matrix (i.e., a square matrix where every\n  non-diagonal element is zero), false otherwise."],
null)),$APP.z(p4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Vv,X2b,ULb,Vac,aVb],null))),$APP.P,"Returns the submatrix of the matrix (or matrix-like structure) `s` generated by\n  taking\n\n  - rows    from `lowrow` -\x3e `hirow` (inclusive)\n  - columns from `lowcol` -\x3e `hicol` (inclusive)"],null))],[new $APP.f(null,3,[$APP.R,Nzb,$APP.X,t2a,$APP.h,new $APP.f(null,2,[$APP.P,"Return an identity matrix whose ones and zeros match the types of the supplied\n  square matrix `M`. Errors if a non-square matrix `M` is supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))],null)],null),new $APP.f(null,3,[$APP.R,Dyb,$APP.X,function(a){return zN(a,function(b){return b})},$APP.h,new $APP.f(null,2,[$APP.P,"Given some 2-tensor-shaped structure `s`, returns the corresponding matrix.\n\n  The outer orientation is ignored; If the inner structures are `up`, they're\n  treated as columns. Inner `down` structures are treated as rows.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,
[$APP.R,sec,$APP.X,CN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  Variadic equivalent to [[by-rows*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,zV],null))],null)],null),new $APP.f(null,3,[$APP.R,Mjb,$APP.X,R1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `m` is a matrix with a single column (a 'column matrix'),\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],
null))],null)],null),new $APP.f(null,3,[$APP.R,hbc,$APP.X,R2,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,jWb,$APP.X,pN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of rows of the supplied matrix `m`. Throws if a\n  non-matrix is supplied.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,s6b,$APP.X,Q1a,$APP.h,new $APP.f(null,2,[$APP.P,"If `m` is already a vector, acts as identity. Else, returns the matrix as a\n  vector of rows (or throws if neither of these types is passed).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,jEb,$APP.X,i2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the single column from the supplied column matrix as a vector. Errors\n  if some other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(oY,$APP.Or)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,O3b,$APP.X,tN,$APP.h,new $APP.f(null,2,[$APP.P,
"Maps `f` over the elements of the matrix `m` returning a new matrix of the same\n  dimensions as `m`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,QKb,$APP.X,function(a,b){return vN.B(b,1,function(c){return $APP.Zg.j([$APP.m.j(a),"",$APP.m.j(c)].join(""))})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a column matrix of `nrows` symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-column-matrix 'x 3)\n     (by-cols ['x0 'x1 'x2]))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,JV],null))],null)],null),new $APP.f(null,3,[$APP.R,g1b,$APP.X,function(a){return pN(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the 'dimension', i.e., the number of rows \x26 columns, of the supplied\n  square matrix. Errors if some other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(xY,$APP.Or)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,
NSb,$APP.X,rN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `m` is a square matrix, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Zib,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,UNb,$APP.X,function(a){return KF.j(bG.j(eH.A(wN(a),a)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied matrix `M` is equal to the negation of its own\n  transpose (i.e., antisymmetric), false otherwise.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[FU],null))],null)],null),new $APP.f(null,3,[$APP.R,$Hb,$APP.X,AN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `n`-th column of the supplied matrix `m` as an `up` structure.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,U8b,$APP.X,T2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a single (sequential) argument `v`, returns the diagonal matrix of\n  order `(count v)` with the elements of the sequence `v` along the diagonal.\n\n  Given two arguments `n` and some constant `x`, returns a diagonal `n` by `n`\n  matrix with `x` in every entry of the diagonal.\n\n  `(make-diagonal \x3cn\x3e 1)` is equivalent to `(I n)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,k4b,$APP.X,JN,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null))],null)],null),new $APP.f(null,3,[$APP.R,Tbc,$APP.X,function(a,b){return vN.B(1,b,function(c,d){return $APP.Zg.j([$APP.m.j(a),"_",$APP.m.j(d)].join(""))})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a row matrix of `ncols` symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-row-matrix 'x 3)\n     (by-rows ['x_0 'x_1 'x_2]))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,gX],null))],null)],null),new $APP.f(null,3,[$APP.R,VJb,$APP.X,RO,$APP.h,new $APP.f(null,2,[$APP.P,"Convert the structure `ms`, which would be a scalar if the (compatible)\n  multiplication `(* ls ms rs)` were performed, to a matrix.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null))],null)],null),new $APP.f(null,3,[$APP.R,wbb,$APP.X,HN,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[zU],null))],null)],null),new $APP.f(null,3,[$APP.R,Tgb,$APP.X,KN,$APP.h,new $APP.f(null,2,[$APP.P,"Return the identity matrix of order `n`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,p8b,$APP.X,h2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a column matrix with the contents of the supplied `up` structure.\n  Errors if any other type is provided.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,
1,5,$APP.I,[$APP.M(bY,$APP.Tv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,MLb,$APP.X,p2a,$APP.h,new $APP.f(null,2,[$APP.P,"Given coefficient procedures `add`, `sub`, `mul` and `zero?`, returns a\n  procedure that efficiently computes the determinant of the supplied square\n  matrix `m`.\n\n  [[general-determinant]] is useful for generating fast type-specific\n  determinant routines. See [[determinant]] for a default using generic\n  arithmetic.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,
[$APP.gT,$APP.JX,YU,$APP.zv],null))],null)],null),new $APP.f(null,3,[$APP.R,qbb,$APP.X,qP,$APP.h,new $APP.f(null,2,[$APP.P,"Given structural inputs `ls` (optional), `ms` and `rs`, constrained such\n  that `(* ls ms rs)` returns a numerical quantity, returns a result such that\n  the following relationship remains true:\n\n  ```clj\n  (* \x3cls| (* ms |rs\x3e)) \x3d (* \x3crs| (* (s:transpose ms) |ls\x3e))\n  ```\n\n  For example:\n\n  ```clj\n  (let [ls (s/up 1 2)\n      ms (s/up (s/down 1 2) (s/down 3 4))\n      rs (s/down 1 2)]\n  (g/* ls (g/* ms rs))\n  ;;\x3d\x3e 27\n\n  (g/* rs (g/* (s:transpose ls ms rs) ls))\n  ;;\x3d\x3e 27\n  )\n  ```\n\n  `ls` is optional. If `ls` is not supplied, a compatible shape is generated\n  internally.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null))],null)],null),new $APP.f(null,3,[$APP.R,Y4b,$APP.X,Y1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a row matrix populated by the supplied `xs`. For a variadic equivalent,\n  see [[row]].",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.hx,$APP.fx)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,oIb,$APP.X,BN,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns the single column from the supplied column matrix as an `up`. Errors if\n  some other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(oY,$APP.Or)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,BBb,$APP.X,o2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the trace (the sum of diagonal elements) of the square matrix `m`.\n\n  Generic operations are used, so this works on symbolic square matrices.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(xY,$APP.Or)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,gnb,$APP.X,Z1a,$APP.h,new $APP.f(null,2,[$APP.P,"Convert a sequence `xs` (typically, of function arguments) to an up-structure.\n\n  Any matrix present in the argument list will be converted to row of columns\n  via [[-\x3estructure]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),
new $APP.f(null,3,[$APP.R,Pjb,$APP.X,uN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a column matrix populated by the supplied `xs`. For a variadic equivalent,\n  see [[column]].",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.hx,$APP.fx)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Lgb,$APP.X,X1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  for a variadic equivalent, see [[by-cols]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[fX],null))],null)],null),new $APP.f(null,3,[$APP.R,Bsb,$APP.X,vN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix with `r` rows and `c` columns, whose entries are generated by\n  the supplied function `f`.\n\n  If you only supply one dimension `n` the returned matrix will be square.\n\n  The entry in the `i`th row and `j`-th column is `(f i j)`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Jv,
$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,GSb,$APP.X,n2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the matrix formed by deleting the `i`-th row and `j`-th column of the\n  given matrix `m`.\n\n  This is also called the 'minor' of m.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Or,$APP.Ov,sU],null))],null)],null),new $APP.f(null,3,[$APP.R,Syb,$APP.X,xN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure generated by converting `m` into a nested structure with\n  the supplied `outer-orientation` and `inner-orientation`.\n\n  If `t?` is true, the columns of `m` will form the inner tuples. If `t?` is\n  false, the rows of `m` will form the inner tuples.\n\n  By default, if you supply a single argument (the matrix `m`), a matrix turns\n  into a single outer `::s/down` of inner columns represented as `::up`\n  structures.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),$APP.z(new $APP.H(null,4,5,$APP.I,[$APP.Or,nV,gY,wTb],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(u_b,nV),$APP.M(u_b,gY)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,q$b,$APP.X,GN,$APP.h,new $APP.f(null,2,[$APP.P,"Convert the matrix `m` into a structure `S`, guided by the requirement that `(*\n  ls S rs)` should be a scalar.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[yW,$APP.Or,KW],null))],null)],null),new $APP.f(null,
3,[$APP.R,MEb,$APP.X,zN,$APP.h,new $APP.f(null,2,[$APP.P,"Converts the square structure `s` into a matrix, and calls the supplied\n  continuation `cont` with\n\n  - the generated matrix\n  - a function which will restore a matrix to a structure with the same inner\n    and outer orientations as s\n\n  Returns the result of the continuation call.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,dX],null))],null)],null),new $APP.f(null,3,[$APP.R,gtb,$APP.X,g2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the diagonal of the supplied matrix `m` as an up structure. Errors if a\n  type other than a diagonal matrix is supplied.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(xY,$APP.Or)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,jmb,$APP.X,P2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  Variadic equivalent to [[by-cols*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,fX],null))],null)],null),new $APP.f(null,3,[$APP.R,uMb,
$APP.X,function(a,b){return $APP.He(a,$APP.ef(b))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `f` is true for some element of the matrix `m`, false\n  otherwise. (Also works on arbitrary nested sequences.)",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Neb,$APP.X,T1a,$APP.h,new $APP.f(null,2,[$APP.P,"Like [[clojure.core/get-in]] for matrices, but obeying the scmutils convention:\n  only one index is required to get an unboxed element from a column vector.\n\n  NOTE that this is perhaps an unprincipled exception...",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,gSb],null))],null)],null),new $APP.f(null,3,[$APP.R,pZb,$APP.X,r2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[FU,oBb],null))],null)],null),new $APP.f(null,3,[$APP.R,sWb,$APP.X,function(a){return function(b){var c=a.j?a.j(b):a.call(null,b);return RO.A(c,b)}},$APP.h,new $APP.f(null,2,[$APP.P,"Any one argument function of a structure can be seen as a matrix. This is only\n  useful if the function has a linear multiplier (e.g. derivative)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null))],null)],null),new $APP.f(null,3,[$APP.R,pyb,$APP.X,O2,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a `nrows` x `ncols` matrix of symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  If `ncols` (the third argument) is not supplied, returns a square matrix of\n  size `nrows` x `nrows`.\n\n  NOTE: The symbols in the returned matrix record their Einstein-notation path\n  into the structure that this matrix represents; a `down` of `up` columns. This\n  means that the returned indices embedded in the symbols look flipped, `ji` vs\n  `ij`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-matrix 'x 2 2)\n     (by-rows ['x_00 'x_10]\n              ['x_01 'x_11]))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,JV],null),new $APP.H(null,3,5,$APP.I,[$APP.Vx,JV,gX],null))],null)],null),new $APP.f(null,3,[$APP.R,Mhb,$APP.X,f2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `n`-th row of the supplied matrix `m` as a `down` structure.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,hdb,$APP.X,j2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a row matrix with the contents of the supplied `down` structure.\n  Errors if any other type is provided.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(ePb,$APP.Tv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,TTb,$APP.X,S2,$APP.h,new $APP.f(null,2,[$APP.P,"Return a zero-valued matrix of `m` rows and `n` columns (`nXn` if only `n` is\n  supplied).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,Fbb,$APP.X,EN,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns the single row from the supplied row matrix as a vector. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(BV,$APP.Or)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,gmb,$APP.X,l2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new matrix of identical shape to `m`, with the vector `v` substituted\n  for the `i`th row.",$APP.U,$APP.M($APP.z(new $APP.H(null,
3,5,$APP.I,[$APP.Or,$APP.Ov,$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,4,5,$APP.I,[$APP.M(iec,$APP.Or),$APP.M($APP.Uv,0,$APP.Ov),$APP.M($APP.Xv,$APP.Ov,$APP.M(b_b,$APP.Or)),$APP.M($APP.Zv,$APP.M(gsb,$APP.Or),$APP.M($APP.qv,$APP.Tv))],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,a4b,$APP.X,v2a,$APP.h,new $APP.f(null,2,[$APP.P,"Given coefficient procedures `add`, `sub`, `mul`, `div` and `zero?`, returns a\n  procedure that efficiently computes the solution to an inhomogeneous system of\n  linear equations, `A*x\x3db`, where the matrix `A` and the column matrix `b` are\n  given. The returned procedure returns the column matrix `x`.\n\n  Unlike LU decomposition, Cramer's rule generalizes to symbolic solutions.\n\n  [[cramers-rule]] is useful for generating fast type-specific linear equation\n  solvers. See [[solve]] for a default using generic arithmetic.",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.gT,$APP.JX,YU,JY,$APP.zv],null))],null)],null),new $APP.f(null,3,[$APP.R,Iyb,$APP.X,function(a){a=c2a(a,wN);return $APP.Uc.A(TK(a),TK($APP.u(a)))?a:mL(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given some 2 tensor `s`, returns a structure with elements 'transposed' by\n  swapping the inner and outer orientations and dimensions, like a matrix\n  transpose.\n\n  Orientations are only flipped if they are different in the input. If the inner\n  and outer orientations of `s` are the same, the returned structure has this\n  identical orientation.\n\n  For example:\n\n  ```clj\n  ;; opposite orientation gets flipped:\n  (s:transpose-orientation (s/up (s/down 1 2 3) (s/down 4 5 6)))\n  ;;\x3d\x3e (down (up 1 4) (up 2 5) (up 3 6))\n\n  ;; same orientation stays the same:\n  (s:transpose-orientation (s/down (s/down 1 2 3) (s/down 4 5 6)))\n  ;;\x3d\x3e (down (down 1 4) (down 2 5) (down 3 6))\n  ```\n\n  See [[structure/two-tensor?]] for more detail on 2 tensors.\n\n  NOTE: In scmutils, this function is called `s:transpose2`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,r7b,$APP.X,Q2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a row matrix populated by the supplied `xs`. Variadic equivalent\n  to [[row*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,qbc,$APP.X,W1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  for a variadic equivalent, see [[by-rows]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[zV],null))],null)],null),new $APP.f(null,3,[$APP.R,ECb,$APP.X,U2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the [characteristic\n  polynomial](https://en.wikipedia.org/wiki/Characteristic_polynomial) of the\n  square matrix `m`.\n\n  If only `m` is supplied, returns a [[polynomial/Polynomial]] instance\n  representing the matrix `m`'s characteristic polynomial.\n\n  If `x` is supplied, returns the value of the characteristic polynomial of `m`\n  evaluated at `x`.\n\n  Typically `x` will be a symbolic variable, but if you wanted to get the value\n  of the characteristic polynomial at some particular numerical point `x` you\n  could pass that too.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Xwb,$APP.X,s2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[oBb,FU],null))],null)],null),new $APP.f(null,3,[$APP.R,Itb,$APP.X,LN,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,Ldc,$APP.X,function(a){var b=pN(a);if(2>b)return a;if($APP.Uc.A(b,2)){var c=
$APP.x.B(a,0,null);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);var d=$APP.x.B(a,1,null),g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return nN(2,2,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[d,PF.j(g)],null),new $APP.H(null,2,5,$APP.I,[PF.j(c),b],null)],null))}return vN.B(b,b,function(l,n){var p=R2(n2a(a,l,n));return $APP.Ie(l+n)?p:PF.j(p)})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the matrix of cofactors of the supplied square matrix `m`.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,
[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(xY,$APP.Or)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,mMb,$APP.X,function(a){return KF.j(bG.j(yG.A(wN(a),a)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied matrix `M` is equal to its own transpose (i.e.,\n  symmetric), false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null))],null)],null),new $APP.f(null,3,[$APP.R,Wac,$APP.X,k2a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some 2-tensor `s` (a 'square' nested structure), returns a structure\n  that represents the multiplicative inverse of the supplied structure. The\n  inner and outer structure orientations of `(s:invert s)` are the SAME as `s`.\n\n  If `s` is an up-of-downs or down-of-ups, `(g/* s (s:invert s))`\n  and `(g/* (s:invert s) s)` will evaluate to an identity-matrix-shaped\n  up-of-downs or down-of-ups.\n\n  If `s` is an up-of-ups or down-of-downs, multiplying `s` `(s:invert s)` will\n  result in a scalar, as both structures collapse.\n\n  NOTE: I DO NOT yet understand the meaning of this scalar! If you do, please\n  open a pull request and explain it here.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,vac,$APP.X,wN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the transpose of the matrix `m`. The transpose is the original matrix,\n  with rows and columns swapped.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Rcb,$APP.X,zR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a column matrix populated by the supplied `xs`. Variadic equivalent\n  to [[column*]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,VLb,$APP.X,q2a,$APP.h,new $APP.f(null,2,[$APP.P,"Given coefficient procedures `add`, `sub`, `mul` and `zero?`, returns a\n  procedure that efficiently computes the inverse of the supplied square\n  matrix `m`.\n\n  [[classical-adjoint-formula]] is useful for generating fast type-specific\n  matrix inversion routines. See [[invert]] for a default using generic\n  arithmetic.",$APP.U,$APP.M(new $APP.H(null,
5,5,$APP.I,[$APP.gT,$APP.JX,YU,JY,$APP.zv],null))],null)],null),new $APP.f(null,3,[$APP.R,f5b,$APP.X,S1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `m` is a matrix with a single row (a 'row matrix'), false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Fzb,$APP.X,DN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the single row from the supplied row matrix as a `down`. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(BV,$APP.Or)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,xVb,$APP.X,oN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `m` is an instance of [[Matrix]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,SFb,$APP.X,qN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of columns of the supplied matrix `m`. Throws if a\n  non-matrix is supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Dzb,$APP.X,U1a,$APP.h,new $APP.f(null,2,[$APP.P,"Maps `f` over three arguments:\n\n  - each element of the matrix `m`\n  - its row `i`\n  - its column `j`\n\n  and returns a new matrix of the same dimensions as `m`. ",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,RRb,$APP.X,function(a,b){return r2a(b,a)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[sTb,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,erb,$APP.X,MN,$APP.h,new $APP.f(null,2,[$APP.P,"Generalization of [[solve]] that can handle `up` and `down` structures, as well\n  as `row` and `column` matrices.\n\n  Given `row` or `down` values for `b`, `A` is appropriately transposed before\n  solving.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.qU,zU],null))],null)],null),new $APP.f(null,3,[$APP.R,R6b,$APP.X,nN,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.matrix/Matrix.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Jv,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,wbc,$APP.X,c2a,$APP.h,new $APP.f(null,2,[$APP.P,"Applies matrix operation `f` to square structure `s` and returns a structure of\n  the same type as the supplied structure.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,nOb,$APP.X,u2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied matrix `m` is an identity matrix, false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,SJb,$APP.X,function(a){var b=rN(a);if(b){var c=pN(a);return $APP.Ge($APP.rd,function(){return function l(g){return new $APP.de(null,function(){for(var n=g;;){var p=$APP.r(n);if(p){var v=p,t=$APP.u(v);if(p=$APP.r(function(A,B,G,J,O,Q){return function fa(Z){return new $APP.de(null,function(ha,ja){return function(){for(var ta=Z;;)if(ta=$APP.r(ta)){if($APP.pd(ta)){var ua=$APP.lc(ta),ca=$APP.Tc(ua),V=$APP.fe(ca);
a:for(var da=0;;)if(da<ca){var Y=$APP.bd(ua,da);$APP.qg.A(ja,Y)&&(Y=$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[ja,Y],null)),$APP.je(V,KF.j(Y)));da+=1}else{ua=!0;break a}return ua?$APP.ie($APP.ke(V),fa($APP.mc(ta))):$APP.ie($APP.ke(V),null)}V=$APP.u(ta);if($APP.qg.A(ja,V))return V=$APP.Zl.A(a,new $APP.H(null,2,5,$APP.I,[ja,V],null)),$APP.Yd(KF.j(V),fa($APP.Fc(ta)));ta=$APP.Fc(ta)}else return null}}(A,B,G,J,O,Q),null,null)}}(n,t,v,p,c,b)($APP.Hj.j(c))))return $APP.N.A(p,l($APP.Fc(n)));n=$APP.Fc(n)}else return null}},
null,null)}($APP.Hj.j(c))}())}return b},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `m` is a diagonal matrix (i.e., a square matrix where every\n  non-diagonal element is zero), false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,p3b,$APP.X,m2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the submatrix of the matrix (or matrix-like structure) `s` generated by\n  taking\n\n  - rows    from `lowrow` -\x3e `hirow` (inclusive)\n  - columns from `lowcol` -\x3e `hicol` (inclusive)",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Vv,X2b,ULb,Vac,aVb],null))],null)],null)]),$APP.Zo(Izb)),$APP.ap(new $APP.f(null,1,[$APP.z(d4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,FT,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[iY],null),$APP.Kl,new $APP.f(null,1,[iY,$APP.M(lY,8,"_")],null)],null)],null))),$APP.P,"Considers an S-expression from the point of view of optimizing its evaluation\n  by isolating common subexpressions into auxiliary variables.\n\n Accepts:\n\n  - A symbolic expression `expr`\n  - a continuation fn `continue` of two arguments:\n    - a new equivalent expression with possibly some subexpressions replaced by\n      new variables (delivered by the supplied generator, see below)\n    - a seq of pairs of `[aux variable, subexpression]` used to reconstitute the\n      value.\n\n  Calls the continuation at completion and returns the continuation's value.\n\n  The special form `(doto v (aset i v_i)...)` is recognized at the top level,\n  and the CSE process is then confined to the $v_i$ expressions.\n\n  ### Optional Arguments\n\n  `:gensym-fn`: side-effecting function that returns a new, unique\n  variable name prefixed by its argument on each invocation.\n  `monotonic-symbol-generator` by default."],
null)),new $APP.f(null,3,[$APP.R,$mb,$APP.X,d8a,$APP.h,new $APP.f(null,2,[$APP.P,"Considers an S-expression from the point of view of optimizing its evaluation\n  by isolating common subexpressions into auxiliary variables.\n\n Accepts:\n\n  - A symbolic expression `expr`\n  - a continuation fn `continue` of two arguments:\n    - a new equivalent expression with possibly some subexpressions replaced by\n      new variables (delivered by the supplied generator, see below)\n    - a seq of pairs of `[aux variable, subexpression]` used to reconstitute the\n      value.\n\n  Calls the continuation at completion and returns the continuation's value.\n\n  The special form `(doto v (aset i v_i)...)` is recognized at the top level,\n  and the CSE process is then confined to the $v_i$ expressions.\n\n  ### Optional Arguments\n\n  `:gensym-fn`: side-effecting function that returns a new, unique\n  variable name prefixed by its argument on each invocation.\n  `monotonic-symbol-generator` by default.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,FT,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[iY],null),$APP.Kl,new $APP.f(null,1,[iY,$APP.M(lY,8,"_")],null)],null)],null))],null)],null)],null),$APP.Zo(zcb)),$APP.ap($APP.fg([$APP.z(sxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),$APP.P,"Returns a function which rotates a vector  radians about the y axis."],null)),$APP.z(oxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,
$APP.I,[pU],null))),$APP.P,"Returns a function which rotates a vector  radians about the x axis."],null)),xEb,$APP.z(ftb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),$APP.P,"Produce the matrix of a rotation of  radians about the y axis."],null)),Ysb,Ndb,Fib,$APP.z(Pzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))],null)),$APP.z(txb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),
$APP.P,"Returns a function which rotates a vector  radians about the z axis."],null)),$APP.z(mRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))],null)),$APP.z(VNb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SX,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null)))],null)),$APP.z(I$b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[zU],null)))],null)),$APP.z(jMb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[SX,WR,WT],null)],null))),$APP.P,"Compute the rotation matrix from a 3-vector of Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)"],null)),$APP.z(ulb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),$APP.P,"Produce the matrix of a rotation of  radians about the z axis."],null)),$APP.z(L3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),$APP.P,"Produce the matrix of a rotation of  radians about the x axis."],null)),$APP.z(rwb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))],null)),$APP.z(Rib,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null),new $APP.H(null,2,5,$APP.I,[FU,TYb],null))),$APP.P,"Given a 3x3 rotation matrix, returns a [[emmy.structure/up]] of the\n  corresponding Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[FU],null),new $APP.H(null,2,5,$APP.I,[FU,TYb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null),new $APP.H(null,2,5,$APP.I,[FU,TYb],null)),$APP.zx,$APP.M(null,null)],null)],null)),Xsb,$sb],[new $APP.f(null,3,[$APP.R,ibc,$APP.X,g3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function which rotates a vector  radians about the y axis.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[pU],null))],null)],null),new $APP.f(null,3,[$APP.R,bbc,$APP.X,f3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function which rotates a vector  radians about the x axis.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))],null)],null),new $APP.f(null,3,[$APP.R,vJb,$APP.X,hO,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,wsb,$APP.X,iO,$APP.h,new $APP.f(null,2,[$APP.P,"Produce the matrix of a rotation of  radians about the y axis.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))],
null)],null),new $APP.f(null,3,[$APP.R,ltb,$APP.X,h3a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Mgb,$APP.X,jO,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,dkb,$APP.X,iO,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,rgb,$APP.X,d3a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))],null)],null),new $APP.f(null,3,[$APP.R,jbc,$APP.X,h3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function which rotates a vector  radians about the z axis.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[pU],null))],null)],null),new $APP.f(null,3,[$APP.R,mcb,$APP.X,c3a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))],null)],null),new $APP.f(null,3,[$APP.R,oeb,$APP.X,b3a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[SX,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,Zcc,$APP.X,i3a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[zU],null))],null)],null),new $APP.f(null,
3,[$APP.R,XRb,$APP.X,nO,$APP.h,new $APP.f(null,2,[$APP.P,"Compute the rotation matrix from a 3-vector of Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[SX,WR,WT],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,MYb,$APP.X,jO,$APP.h,new $APP.f(null,2,[$APP.P,"Produce the matrix of a rotation of  radians about the z axis.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],
null))],null)],null),new $APP.f(null,3,[$APP.R,Y2b,$APP.X,hO,$APP.h,new $APP.f(null,2,[$APP.P,"Produce the matrix of a rotation of  radians about the x axis.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))],null)],null),new $APP.f(null,3,[$APP.R,eyb,$APP.X,e3a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))],null)],null),new $APP.f(null,3,[$APP.R,Smb,$APP.X,W2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a 3x3 rotation matrix, returns a [[emmy.structure/up]] of the\n  corresponding Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FU],null),new $APP.H(null,2,5,$APP.I,[FU,TYb],null))],null)],null),new $APP.f(null,3,[$APP.R,mtb,$APP.X,g3a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ktb,$APP.X,f3a,$APP.h,$APP.F],null)]),$APP.Zo(hsb)),$APP.ap(new $APP.f(null,6,[$APP.z(LUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null)))],null)),new $APP.f(null,3,[$APP.R,m3b,$APP.X,C6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null))],
null)],null),$APP.z(GRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null)))],null)),new $APP.f(null,3,[$APP.R,iib,$APP.X,D6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null))],null)],null),$APP.z(XJb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[IP,TU],null)))],null)),new $APP.f(null,3,[$APP.R,F1b,$APP.X,E6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[IP,TU],null))],null)],null),$APP.z(Vnb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null)))],null)),new $APP.f(null,3,[$APP.R,gFb,$APP.X,F6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null))],null)],null),$APP.z(C8b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null)))],null)),new $APP.f(null,3,[$APP.R,Qwb,$APP.X,G6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null))],null)],null),$APP.z(uTb,new $APP.f(null,1,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[IP,Hvb],null)))],null)),new $APP.f(null,3,[$APP.R,BXb,$APP.X,H6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[IP,Hvb],null))],null)],null)],null),$APP.Zo(Eyb)),$APP.ap($APP.fg([$APP.z(sGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"If `x` is a fixed-precision integer, returns a [[emmy.util/bigint]]\n     version of `x`. Else, acts as identity.\n\n     This is useful in cases where you may want to multiply `x` by other large\n     numbers, but don't want to try and convert something that can't overflow,\n     like a symbol, into `bigint`."],
null)),$APP.z(Msb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M($APP.$v,$APP.uU,0)],null)],null)))),$APP.P,"Returns the factorial of `n`, i.e., the product of 1 to `n` (inclusive).\n\n  [[factorial]] will return a platform-specific [[emmy.util/bigint]] given\n  some `n` that causes integer overflow."],null)),$APP.z(BWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic falling-factorial.\n\nReturns the [falling\n  factorial](https://en.wikipedia.org/wiki/Falling_and_rising_factorials), of\n  `a` to the `b`, defined as the polynomial\n\n  $$(a)_b \x3d a^{\\underline{b}} \x3d a(a - 1)(a - 2) \\cdots (a - b - 1)$$\n\n  Given a negative `b`, `([[falling-factorial]] a b)` is equivalent\n  to `(invert ([[rising-factorial]] (inc a) (- b)))`, or `##Inf` if the\n  denominator evaluates to 0.\n\n  The coefficients that appear in the expansions of [[falling-factorial]] called\n  with a symbolic first argument and positive integral second argument are the\n  Stirling numbers of the first kind (see [[stirling-first-kind]])."],
null)),$APP.z(wpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.$v,$APP.uU,0)],null)],null)))),$APP.P,"Returns the `n`th [Bell number](https://en.wikipedia.org/wiki/Bell_number), i.e.,\n  the number of ways a set of `n` elements can be partitioned into nonempty\n  subsets.\n\n  The `n`th Bell number is denoted $B_n$."],null)),$APP.z(GGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,4,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M(pW,$APP.tU),$APP.M($APP.$v,$APP.uU,0),$APP.M($APP.Yv,$APP.tU,0)],null)],null)))),$APP.P,"Returns the product of the positive integers up to `n` that are congruent\n  to `(mod n k)`.\n\n  When `k` equals 1, equivalent to `([[factorial]] n)`.\n\n  See the [Wikipedia page on generalizations\n  of [[double-factorial]]](https://en.wikipedia.org/wiki/Double_factorial#Generalizations)\n  for more detail.\n\n  If you need to extend [[multi-factorial]] to negative `n` or `k`, that page\n  has suggestions for generalization."],
null)),$APP.z(kdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),$APP.P,"Returns the number of permutations of `n` objects in which no object appears in\n  its original position. (Each of these permutations is called\n  a ['derangement'](https://en.wikipedia.org/wiki/Derangement) of the set.)\n\n  ## References\n\n  - [Subfactorial page at Wolfram Mathworld](https://mathworld.wolfram.com/Subfactorial.html)\n  - John Cook, [Variations on Factorial](https://www.johndcook.com/blog/2010/09/21/variations-on-factorial/)\n  - John Cook, [Subfactorial](https://www.johndcook.com/blog/2010/04/06/subfactorial/)\n  - ['Derangement' on Wikipedia](https://en.wikipedia.org/wiki/Derangement)"],
null)),$APP.z(Wqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pW,$APP.uU)],null)],null)))),$APP.P,"Returns the product of all integers from 1 up to `n` that have the same\n  parity (odd or even) as `n`.\n\n  `([[double-factorial]] 0)` is defined as an empty product and equal to 1.\n\n  [[double-factorial]] with argument `n` is equivalent to `([[multi-factorial]]\n  n 2)`, but slightly more general in that it can handle negative values of\n  `n`.\n\n  If `n` is negative and even, returns `##Inf`.\n\n  If `n` is negative and odd, returns `(/ (double-factorial (+ n 2)) (+ n 2))`.\n\n  For justification, see the [Wikipedia page on the extension of double\n  factorial to negative\n  arguments](https://en.wikipedia.org/wiki/Double_factorial#Negative_arguments)."],
null)),$APP.z(FTb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,4,5,$APP.I,[$APP.uU,$APP.tU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[Drb],null)],null)],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,4,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M(pW,$APP.tU),$APP.M($APP.Uv,0,$APP.tU),$APP.M($APP.Uv,0,$APP.uU)],null)],null)))),$APP.P,"Given `n` and `k`, returns the number of permutations of `n` elements which\n  contain exactly `k` [permutation\n  cycles](https://mathworld.wolfram.com/PermutationCycle.html). This is called\n  the [Stirling number s(n, k) of the first\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind).\n\n  By default, returns the [signed Stirling number of the first\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind#Signs).\n  Pass the `:unsigned? true` keyword option to retrieve the signed Stirling\n  number. (Or take the absolute value of the result...)\n\n  ```clj\n  (stirling-first-kind 13 2)\n  ;;\x3d\x3e -1486442880\n\n  (stirling-first-kind 13 2 :unsigned? true)\n  ;;\x3d\x3e 1486442880\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.uU,$APP.tU,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[Drb],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.uU,$APP.tU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[Drb],null)],null)],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(ICb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M(pW,$APP.tU)],null)],null)))),$APP.P,'Returns the [binomial\n  coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient), i.e., the\n  coefficient of the $x^k$ term in the polynomial expansion of the binomial\n  power $(1 + x)^n$.\n\n  This quantity is sometimes pronounced "n choose k".\n\n  For negative `n` or `k`, [[binomial-coefficient]] matches the behavior\n  provided by Mathematica, described at [this\n  page](https://mathworld.wolfram.com/BinomialCoefficient.html). Given negative\n  `n`, returns\n\n  ```clj\n  ;; for k \x3e\x3d 0\n  (* (expt -1 k)\n     (binomial-coefficient (+ (- n) k -1) k))\n\n  ;; for k \x3e\x3d 0\n  (* (expt -1 (- n k))\n     (binomial-coefficient (+ (- k) -1) (- n k)))\n\n  ;; otherwise:\n  0\n  ```'],
null)),$APP.z(Rlb,new $APP.f(null,1,[$APP.Pu,!0],null)),vKb,$APP.z(aYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,4,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M(pW,$APP.tU),$APP.M($APP.Uv,0,$APP.tU),$APP.M($APP.Uv,0,$APP.uU)],null)],null)))),$APP.P,"Returns $S(n,k)$, the number of ways to partition a set of `n` objects into `k`\n  non-empty subsets.\n\n  This is called a [Stirling number of the second\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind)."],
null)),MFb],[new $APP.f(null,3,[$APP.R,Icb,$APP.X,AXa,$APP.h,new $APP.f(null,2,[$APP.P,"If `x` is a fixed-precision integer, returns a [[emmy.util/bigint]]\n     version of `x`. Else, acts as identity.\n\n     This is useful in cases where you may want to multiply `x` by other large\n     numbers, but don't want to try and convert something that can't overflow,\n     like a symbol, into `bigint`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,frb,
$APP.X,FI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the factorial of `n`, i.e., the product of 1 to `n` (inclusive).\n\n  [[factorial]] will return a platform-specific [[emmy.util/bigint]] given\n  some `n` that causes integer overflow.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M($APP.$v,$APP.uU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,dtb,$APP.X,X0,$APP.h,new $APP.f(null,2,[$APP.P,
"generic falling-factorial.\n\nReturns the [falling\n  factorial](https://en.wikipedia.org/wiki/Falling_and_rising_factorials), of\n  `a` to the `b`, defined as the polynomial\n\n  $$(a)_b \x3d a^{\\underline{b}} \x3d a(a - 1)(a - 2) \\cdots (a - b - 1)$$\n\n  Given a negative `b`, `([[falling-factorial]] a b)` is equivalent\n  to `(invert ([[rising-factorial]] (inc a) (- b)))`, or `##Inf` if the\n  denominator evaluates to 0.\n\n  The coefficients that appear in the expansions of [[falling-factorial]] called\n  with a symbolic first argument and positive integral second argument are the\n  Stirling numbers of the first kind (see [[stirling-first-kind]]).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,bmb,$APP.X,DXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `n`th [Bell number](https://en.wikipedia.org/wiki/Bell_number), i.e.,\n  the number of ways a set of `n` elements can be partitioned into nonempty\n  subsets.\n\n  The `n`th Bell number is denoted $B_n$.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.$v,
$APP.uU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,ybc,$APP.X,BXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the product of the positive integers up to `n` that are congruent\n  to `(mod n k)`.\n\n  When `k` equals 1, equivalent to `([[factorial]] n)`.\n\n  See the [Wikipedia page on generalizations\n  of [[double-factorial]]](https://en.wikipedia.org/wiki/Double_factorial#Generalizations)\n  for more detail.\n\n  If you need to extend [[multi-factorial]] to negative `n` or `k`, that page\n  has suggestions for generalization.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,4,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M(pW,$APP.tU),$APP.M($APP.$v,$APP.uU,0),$APP.M($APP.Yv,$APP.tU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Tbb,$APP.X,function(a){if(0===a)return 1;a=zG.A(FI(a),Math.E);return pZ.j(eH.A(.5,a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of permutations of `n` objects in which no object appears in\n  its original position. (Each of these permutations is called\n  a ['derangement'](https://en.wikipedia.org/wiki/Derangement) of the set.)\n\n  ## References\n\n  - [Subfactorial page at Wolfram Mathworld](https://mathworld.wolfram.com/Subfactorial.html)\n  - John Cook, [Variations on Factorial](https://www.johndcook.com/blog/2010/09/21/variations-on-factorial/)\n  - John Cook, [Subfactorial](https://www.johndcook.com/blog/2010/04/06/subfactorial/)\n  - ['Derangement' on Wikipedia](https://en.wikipedia.org/wiki/Derangement)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,ZBb,$APP.X,function Nsc(a){if(0===a)a=1;else if(0<a)a=BXa(a,2);else if($APP.Ie(a))a=Infinity;else{var c=zG,d=c.A;var g=a+2;g=Nsc.j?Nsc.j(g):Nsc.call(null,g);a=d.call(c,g,a+2)}return a},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the product of all integers from 1 up to `n` that have the same\n  parity (odd or even) as `n`.\n\n  `([[double-factorial]] 0)` is defined as an empty product and equal to 1.\n\n  [[double-factorial]] with argument `n` is equivalent to `([[multi-factorial]]\n  n 2)`, but slightly more general in that it can handle negative values of\n  `n`.\n\n  If `n` is negative and even, returns `##Inf`.\n\n  If `n` is negative and odd, returns `(/ (double-factorial (+ n 2)) (+ n 2))`.\n\n  For justification, see the [Wikipedia page on the extension of double\n  factorial to negative\n  arguments](https://en.wikipedia.org/wiki/Double_factorial#Negative_arguments).",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pW,$APP.uU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,ggb,$APP.X,$0,$APP.h,new $APP.f(null,2,[$APP.P,"Given `n` and `k`, returns the number of permutations of `n` elements which\n  contain exactly `k` [permutation\n  cycles](https://mathworld.wolfram.com/PermutationCycle.html). This is called\n  the [Stirling number s(n, k) of the first\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind).\n\n  By default, returns the [signed Stirling number of the first\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind#Signs).\n  Pass the `:unsigned? true` keyword option to retrieve the signed Stirling\n  number. (Or take the absolute value of the result...)\n\n  ```clj\n  (stirling-first-kind 13 2)\n  ;;\x3d\x3e -1486442880\n\n  (stirling-first-kind 13 2 :unsigned? true)\n  ;;\x3d\x3e 1486442880\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,4,5,$APP.I,[$APP.uU,$APP.tU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[Drb],null)],null)],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,4,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M(pW,$APP.tU),$APP.M($APP.Uv,0,$APP.tU),$APP.M($APP.Uv,0,$APP.uU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,L7b,$APP.X,Z0,$APP.h,new $APP.f(null,2,[$APP.P,'Returns the [binomial\n  coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient), i.e., the\n  coefficient of the $x^k$ term in the polynomial expansion of the binomial\n  power $(1 + x)^n$.\n\n  This quantity is sometimes pronounced "n choose k".\n\n  For negative `n` or `k`, [[binomial-coefficient]] matches the behavior\n  provided by Mathematica, described at [this\n  page](https://mathworld.wolfram.com/BinomialCoefficient.html). Given negative\n  `n`, returns\n\n  ```clj\n  ;; for k \x3e\x3d 0\n  (* (expt -1 k)\n     (binomial-coefficient (+ (- n) k -1) k))\n\n  ;; for k \x3e\x3d 0\n  (* (expt -1 (- n k))\n     (binomial-coefficient (+ (- k) -1) (- n k)))\n\n  ;; otherwise:\n  0\n  ```',
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M(pW,$APP.tU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,rbb,$APP.X,Y0,$APP.h,new $APP.f(null,2,[$APP.P,"generic rising-factorial.\n\nReturns the [rising\n  factorial](https://en.wikipedia.org/wiki/Falling_and_rising_factorials), of\n  `a` to the `b`, defined as the polynomial\n\n  $$(a)^b \x3d a^{\\overline{b}} \x3d a(a + 1)(a + 2) \\cdots (a + b - 1)$$\n\n  Given a negative `b`, `([[rising-factorial]] a b)` is equivalent\n  to `(invert ([[falling-factorial]] (dec a) (- b)))`, or `##Inf` if the\n  denominator evaluates to 0.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,xAb,$APP.X,Y0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,vbb,$APP.X,CXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns $S(n,k)$, the number of ways to partition a set of `n` objects into `k`\n  non-empty subsets.\n\n  This is called a [Stirling number of the second\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind).",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,
$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,4,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M(pW,$APP.tU),$APP.M($APP.Uv,0,$APP.tU),$APP.M($APP.Uv,0,$APP.uU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,mac,$APP.X,X0,$APP.h,$APP.F],null)]),$APP.Zo(rSb)),$APP.ap(new $APP.f(null,3,[$APP.z(f1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,hW],null)))],null)),new $APP.f(null,3,[$APP.R,r9b,$APP.X,I6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,
5,$APP.I,[xU,hW],null))],null)],null),$APP.z(Skb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[TU,hW,oW],null)))],null)),new $APP.f(null,3,[$APP.R,YAb,$APP.X,J6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[TU,hW,oW],null))],null)],null),$APP.z(KSb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[hW,$APP.Aw,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[MT],null),$APP.Kl,new $APP.f(null,1,[MT,!1],null)],
null)],null))),$APP.P,"Takes a `metric` and a `spec` and returns the [Hodge star\n  operator](https://en.wikipedia.org/wiki/Hodge_star_operator) (actually just a\n  function, but I suspect this should be a proper operator!)\n\n  `spec` may be:\n\n  - a coordinate system with an orthonormal basis\n  - an orthonormal basis\n  - a basis\n\n  if the spec is a basis that needs to be orthonormalized, the optional\n  `:orthonormalize?` keyword argument must be a coordinate system.",$APP.hy,new $APP.f(null,
6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(hW,$APP.Aw,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[MT],null),$APP.Kl,new $APP.f(null,1,[MT,!1],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[hW,$APP.Aw,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[MT],null),$APP.Kl,new $APP.f(null,1,[MT,!1],null)],null)],null)),$APP.zx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.R,Zbb,$APP.X,VP,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `metric` and a `spec` and returns the [Hodge star\n  operator](https://en.wikipedia.org/wiki/Hodge_star_operator) (actually just a\n  function, but I suspect this should be a proper operator!)\n\n  `spec` may be:\n\n  - a coordinate system with an orthonormal basis\n  - an orthonormal basis\n  - a basis\n\n  if the spec is a basis that needs to be orthonormalized, the optional\n  `:orthonormalize?` keyword argument must be a coordinate system.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[hW,$APP.Aw,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[MT],null),$APP.Kl,new $APP.f(null,1,[MT,!1],null)],null)],null))],null)],null)],null),$APP.Zo(Pib)),$APP.ap($APP.fg([$APP.z(Gzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null)))],null)),$APP.z(oT,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null)))],null)),$APP.z(yxb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
5,5,$APP.I,[$APP.Vw,qS,oT,zqb,k8b],null)))],null)),$APP.z(NY,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null)))],null)),ITb,$APP.z(mcc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hv,Xqb,$APP.Hv],null)))],null)),$APP.z(Yfb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null)))],null)),$APP.z(Nsb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[pT,gS],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(bY,gS),$APP.M($APP.Zv,$APP.M($APP.qv,gS),4)],null)],null))))],null)),$APP.z(g8b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hv,Xqb,$APP.Hv],null)))],null)),OJb,$APP.z(K_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[tec,i2b],null)))],null)),$APP.z(DTb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null)))],null)),$APP.z(ntb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))),$APP.P,"velocities must be in meters/second, since we don't yet have units support."],null))],[new $APP.f(null,3,[$APP.R,F0b,$APP.X,Fab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null))],null)],null),new $APP.f(null,3,[$APP.R,ZXb,$APP.X,Mab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null))],null)],null),new $APP.f(null,3,[$APP.R,hgb,$APP.X,Jab,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Vw,qS,oT,zqb,k8b],null))],null)],null),new $APP.f(null,3,[$APP.R,cCb,$APP.X,Nab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null))],null)],null),new $APP.f(null,3,[$APP.R,LMb,$APP.X,Dsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,HGb,$APP.X,Kab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hv,Xqb,$APP.Hv],null))],null)],null),new $APP.f(null,3,[$APP.R,sVb,$APP.X,Eab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.nW],null))],null)],null),new $APP.f(null,3,[$APP.R,Bbc,$APP.X,QR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[pT,gS],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(bY,gS),$APP.M($APP.Zv,$APP.M($APP.qv,gS),4)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,tAb,$APP.X,Lab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hv,Xqb,$APP.Hv],null))],null)],null),new $APP.f(null,3,[$APP.R,n7b,$APP.X,Csc,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.R,Qcc,$APP.X,Pab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[tec,i2b],null))],null)],null),new $APP.f(null,3,[$APP.R,osb,$APP.X,Oab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null))],null)],null),new $APP.f(null,3,[$APP.R,j3b,$APP.X,Qab,$APP.h,new $APP.f(null,2,[$APP.P,"velocities must be in meters/second, since we don't yet have units support.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))],
null)],null)]),$APP.Zo(Wbc)),$APP.ap($APP.fg([jOb,$APP.z(HEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),$APP.P,"[[gradient]] implements equation (10.3) in Functional Differential Geometry,\n  defined on page 154."],null)),MQb,MBb,$APP.z(Adb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))],null)),$APP.z(UOb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,CV],null)))],null)),$APP.z(a5b,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[kT],null)))],null)),$APP.z(kub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,CV],null))),$APP.P,"[[curl]] implements equation (10.7) of Functional Differential Geometry,\n  defined on page 155."],null)),hEb,$APP.z(fJb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[hW,CV],null))),$APP.P,"Both arities of [[divergence]] are defined on page 156 of Functional Differential Geometry.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[hW,CV],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[hW,CV],null)),$APP.zx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.R,y3b,$APP.X,Jrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Qgb,$APP.X,K6a,$APP.h,new $APP.f(null,2,[$APP.P,"[[gradient]] implements equation (10.3) in Functional Differential Geometry,\n  defined on page 154.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,tMb,$APP.X,Krc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Tzb,$APP.X,Lrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,qzb,$APP.X,N6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,IOb,$APP.X,M6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,CV],null))],null)],null),new $APP.f(null,3,[$APP.R,Qbc,$APP.X,
function(a){var b=ZO(a),c=N6a(a),d=FO.j(pO(a));return cL(d,XK,function(g){return iG.A($APP.x.A(b,g),QF.A(1,WH.C($APP.y([$APP.C.A(c,g),DO(a)]))))})},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[kT],null))],null)],null),new $APP.f(null,3,[$APP.R,P5b,$APP.X,L6a,$APP.h,new $APP.f(null,2,[$APP.P,"[[curl]] implements equation (10.7) of Functional Differential Geometry,\n  defined on page 155.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,CV],null))],null)],null),new $APP.f(null,3,
[$APP.R,Edc,$APP.X,N3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,rOb,$APP.X,WP,$APP.h,new $APP.f(null,2,[$APP.P,"Both arities of [[divergence]] are defined on page 156 of Functional Differential Geometry.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[hW,CV],null))],null)],null)]),$APP.Zo(VQb)),$APP.ap(new $APP.f(null,5,[gkb,new $APP.f(null,3,[$APP.R,Mlb,$APP.X,L3,$APP.h,new $APP.f(null,4,[$APP.P,"similar to a `let` binding that holds pairs of\n\n  \x3ccoordinate-structure-prototype\x3e, \x3ccoordinate-system\x3e\n\n  And internally binds, for each pair: (take `[x y]` and `m/R2-rect` as\n  examples):\n\n  - The coordinate system symbol `R2-rect` to a new version of the coordinate\n    system with its `coordinate-prototype` replaced by the one you supplied.\n    That's `(up x y)` in this example.\n\n  - the entries `x` and `y` to coordinate functions, i.e., functions from manifold\n    point to this particular coordinate\n\n  - `d:dx` and `d:dy` vector field procedures (I'm fuzzy here!)\n\n  - `dx` and `dy` 1-forms for each coordinate (fuzzy here too!)\n\n  Example:\n\n  ```clojure\n  (let-coordinates [[x y]    R2-rect\n                   [r theta] R2-polar]\n    ;; bindings:\n    ;; R2-rect, x, y, d:dx, d:dy, dx, dy\n    ;; R2-polar, r, theta, d:dr, d:dtheta, dr, dtheta\n    body...)\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Cw,$APP.Lh,$APP.Pw],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),Ubb,new $APP.f(null,3,[$APP.R,sUb,$APP.X,function(a,b,c,d){a=$APP.rg.B(b,zX,!0);b=$APP.Zg.j($APP.Ag(d));var g=$APP.Nj.j([$APP.m.j(b),"-values"].join("")),l=K3(c),n=$APP.Vg.A(k4a,l),p=$APP.Vg.A(J4a,l);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Qh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,GCb,null,1,null),new $APP.D(null,b,null,1,null),$APP.y([new $APP.D(null,
$APP.T.j($APP.r($APP.N.C(new $APP.D(null,zWb,null,1,null),new $APP.D(null,d,null,1,null),$APP.y([new $APP.D(null,b6a(c),null,1,null)])))),null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.di,null,1,null),new $APP.D(null,g,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.qqa,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.J()))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
z$b,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,hS,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,LX,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,vT,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null)]))))),null,1,null)))),null,1,null)])))),null,1,null)])))),null,1,null),
$APP.gp.A(function(v,t){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,GCb,null,1,null),new $APP.D(null,t,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.VCa,null,1,null),new $APP.D(null,g,null,1,null),$APP.y([new $APP.D(null,v,null,1,null)])))),null,1,null)]))))},$APP.N.C(l,n,$APP.y([p]))),new $APP.D(null,$APP.k(zX.j(a))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,sEb,null,1,null),new $APP.D(null,$APP.kx,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
$APP.K,null,1,null),new $APP.D(null,g,null,1,null)))),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Zh,null,1,null),new $APP.D(null,g,null,1,null),$APP.y([new $APP.D(null,null,null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.ai,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null)]))))},$APP.h,new $APP.f(null,4,[$APP.P,"Give some `coordinate-system` like `R2-rect` and a `coordinate-prototype` like\n  `[x y]` or `(up x y), `binds the following definitions into the namespace\n  where [[define-coordinates]] is invoked:\n\n  - `R2-rect` binds to a new version of the coordinate system with its\n    `coordinate-prototype` replaced by the supplied prototype\n\n  - `x` and `y` bind to coordinate functions, i.e., functions from manifold point\n  to that particular coordinate\n\n  - `d:dx` and `d:dy` bind to the corresponding vector field procedures\n\n  - `dx` and `dy` bind to 1-forms for each coordinate.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[nU,oW],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),CCb,new $APP.f(null,3,[$APP.R,G1b,$APP.X,M3,$APP.h,new $APP.f(null,4,[$APP.P,"[[using-coordinates]] wraps [[let-coordinates]] and allows you to supply a\n  single coordinate prototype and a single coordinate system.\n  See [[let-coordinates]] for details about what symbols are bound inside the\n  body.\n\n  Example:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect\n                     body...)\n  ```",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[nU,oW,$APP.Lh,$APP.Pw],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),$APP.z($Nb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),$APP.P,"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point \x3d\x3e\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`."],null)),new $APP.f(null,
3,[$APP.R,hS,$APP.X,a6a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point \x3d\x3e\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),$APP.z(Tyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,
"Scmutils wants to allow forms like this:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect ...)\n  ```\n\n   Note that `x`, `y` are unquoted. This function converts such an unquoted form\n  into a quoted one that could be evaluated to return an up-tuple of the\n  symbols:\n\n  ```clojure\n  (up 'x 'y)\n  ```\n\n  Such an object is useful for [[structure/mapr]]."],null)),new $APP.f(null,3,[$APP.R,Rac,$APP.X,b6a,$APP.h,new $APP.f(null,2,[$APP.P,"Scmutils wants to allow forms like this:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect ...)\n  ```\n\n   Note that `x`, `y` are unquoted. This function converts such an unquoted form\n  into a quoted one that could be evaluated to return an up-tuple of the\n  symbols:\n\n  ```clojure\n  (up 'x 'y)\n  ```\n\n  Such an object is useful for [[structure/mapr]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null)],null),$APP.Zo(NDb)),$APP.ap(new $APP.f(null,4,[$APP.z(Jbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Returns true if the supplied object is an instance of [[Function]], false\n  otherwise."],null)),new $APP.f(null,3,[$APP.R,fLb,$APP.X,C2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied object is an instance of [[Function]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Kv],null))],null)],null),$APP.z($rb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,6,[kU,"null",SW,"null",WE,"null",LY,"null",gV,"null",RV,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$Zb,ZT,cU,$APP.By],null))),VR,new $APP.ug(null,new $APP.f(null,3,[kU,"null",SW,"null",gV,"null"],null),null),$APP.P,"Positional factory function for emmy.abstract.function/Function."],null)),new $APP.f(null,3,[$APP.R,p5b,$APP.X,SN,$APP.h,new $APP.f(null,
2,[$APP.P,"Positional factory function for emmy.abstract.function/Function.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$Zb,ZT,cU,$APP.By],null))],null)],null),Ppb,new $APP.f(null,3,[$APP.R,fWb,$APP.X,VN,$APP.h,new $APP.f(null,3,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[FIb,$APP.Lh,$APP.Pw],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),$APP.z(lob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,aAb],null),new $APP.H(null,3,
5,$APP.I,[$APP.Kv,cU,$APP.By],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,aAb],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,cU,$APP.By],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,aAb],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,cU,$APP.By],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),new $APP.f(null,
3,[$APP.R,UN,$APP.X,TN,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,aAb],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,cU,$APP.By],null))],null)],null)],null),$APP.Zo(cbc)),$APP.ap($APP.fg([$APP.z(YZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UV],null)))),jU,$APP.M($APP.K,qnb)],null)),$APP.z(RLb,new $APP.f(null,3,[$APP.P,"Find the minimum of the function f: R^n -\x3e R, given an initial point q  R^n.\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked with iteration count,\n  the values of X and the value of f(X) at each intermediate point of\n  evaluation.\n\n  `:info?` if true, wraps the result with evaluation information.\n\n  `:adaptive?` if true, the Nelder-Mead parameters for contraction, expansion,\n  reflection and shrinking will be set adaptively, as functions of the number of\n  dimensions. If false they stay constant.\n\n  `:alpha` sets the reflection coefficient used for each step of Nelder-Mead.\n\n  `:beta` sets the expansion coefficient used for each step of Nelder-Mead.\n\n  `:gamma` sets the contraction coefficient used for each step of Nelder-Mead.\n\n  `:sigma` sets the shrink coefficient used for each step of Nelder-Mead.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  200*dimension.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 200*dimension.\n\n  `:simplex-tolerance` When the absolute value of the max difference between the\n  best point and any point in the simplex falls below this tolerance, the\n  minimizer stops. Defaults to 1e-4.\n\n  `:fn-tolerance` When the absolute value of the max difference between the best\n  point's function value and the fn value of any point in the simplex falls\n  below this tolerance, the minimizer stops. Defaults to 1e-4.\n\n  `:zero-delta` controls the value to which 0 entries in the initial vector are\n  set during initial simplex generation. Defaults to 0.00025.\n\n  `:nonzero-delta` factor by which entries in the initial vector are perturbed to\n  generate the initial simplex. Defaults to 0.05.\n\n  See Gao, F. and Han, L.\n      Implementing the Nelder-Mead simplex algorithm with adaptive\n      parameters. 2012. Computational Optimization and Applications.\n      51:1, pp. 259-277\n  I gratefully acknowledge the [Python implementation in\n  SciPy](https://github.com/scipy/scipy/blob/589c9afe41774ee96ec121f1867361146add8276/scipy/optimize/optimize.py#L556:5)\n  which I have imitated here.\n  ",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hy,$APP.NW,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.Dw],null),$APP.ck,$APP.Lx],null)],null)))),jU,$APP.M($APP.K,VUb)],null)),$APP.z(lX,new $APP.f(null,3,[$APP.P,"generic quotient",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,u6b)],null)),$APP.z(drb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.BU],
null)))),jU,$APP.M($APP.K,gub)],null)),$APP.z(NCb,new $APP.f(null,3,[$APP.P,"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null)))),jU,$APP.M($APP.K,XLb)],null)),$APP.z(B5a,new $APP.f(null,3,[$APP.P,"Takes a system derivative `R` and returns a operator that takes a function `F`\n  of coordinatized state and performs the operation described below, from\n  ODE.scm in scmutils:\n\n  Let `(sigma t)` be the state of a system at time `t`. Let the\n  (first-order) system of differential equations governing the evolution of\n  this state be:\n\n  ```clojure\n  ((D sigma) t) \x3d (R (sigma t))\n  ```\n\n  ```clojure\n  (D sigma) \x3d (compose R sigma)\n  ```\n\n  i.e. `R` is a system derivative.\n\n  Let `F` be any function of state, then a differential equation for the\n  evolution of `F`, as it is dragged along the integral curve sigma is:\n\n  ```clojure\n  (D (compose F sigma)) \x3d (* (compose (D F) sigma) (D sigma))\n  \x3d (compose (* (D F) R) sigma)\n  ```\n\n  Let's call this operation `Lie-D` (the Lie derivative for coordinates).",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null)))),jU,$APP.M($APP.K,Sjb)],null)),$APP.z(bDb,new $APP.f(null,3,[$APP.P,"Returns a row matrix populated by the supplied `xs`. Variadic equivalent\n  to [[row*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))),jU,$APP.M($APP.K,r7b)],null)),$APP.z(Jxb,new $APP.f(null,3,[$APP.P,"Returns a data structure representing [Christoffel symbols of the first\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_first_kind).",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[DX,TU],null)))),jU,$APP.M($APP.K,Ebb)],null)),$APP.z(KSb,new $APP.f(null,3,[$APP.P,"Takes a `metric` and a `spec` and returns the [Hodge star\n  operator](https://en.wikipedia.org/wiki/Hodge_star_operator) (actually just a\n  function, but I suspect this should be a proper operator!)\n\n  `spec` may be:\n\n  - a coordinate system with an orthonormal basis\n  - an orthonormal basis\n  - a basis\n\n  if the spec is a basis that needs to be orthonormalized, the optional\n  `:orthonormalize?` keyword argument must be a coordinate system.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[hW,$APP.Aw,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[MT],null),$APP.Kl,new $APP.f(null,1,[MT,!1],null)],null)],null))),jU,$APP.M($APP.K,Zbb)],null)),$APP.z(mLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.DU,vU,IW,JW],null),new $APP.H(null,5,5,$APP.I,[$APP.DU,vU,IW,JW,XV],null))),jU,$APP.M($APP.K,I1b)],null)),$APP.z(mob,new $APP.f(null,3,[$APP.P,"Returns true if `x` implements [[IFrame]], false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,Bxb)],null)),$APP.z(n4b,new $APP.f(null,3,[$APP.P,"Alias for [[solve-linear]]; present for compatibility with the original\n  `scmutils` codebase.\n\n  NOTE: In `scmutils`, `solve-linear-left` and `solve-linear` act identically in\n  all cases except matrices. `solve-linear-left` only accepted a column\n  matrix (or up structure) in the `b` position, while `solve-linear` accepted\n  either a column or row (up or down structure).\n\n  In Emmy, both functions accept either type.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,WLb)],null)),$APP.z($ab,new $APP.f(null,3,[$APP.P,"SICM p. 23. The optional parameter values is a callback which will report\n  intermediate points of the minimization.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,8,5,$APP.I,[$X,HW,AW,IW,BW,$APP.uU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[bW],null)],null)],null))),jU,$APP.M($APP.K,pKb)],null)),$APP.z(Hmb,new $APP.f(null,
3,[$APP.P,"Marks (via metadata) the supplied set of `coords` as being owned by `owner`. If\n  `coords` already has an owner (that is not equal to `owner`), throws.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.nW,q6b],null)))),jU,$APP.M($APP.K,Tfb)],null)),$APP.z(eS,new $APP.f(null,3,[$APP.P,"generic remainder.\n\nReturns the remainder of dividing the dividend `a` by divisor `b`.\n\n The contract satisfied by [[remainder]] is:\n\n```clojure\n(\x3d a (+ (* b (quotient a b))\n        (remainder a b)))\n```\n\n For numbers, this differs from the contract offered by [[modulo]]\n because [[quotient]] rounds toward 0, while `(floor (/ a b))` rounds toward\n negative infinity.\n\n The result will be either `0` or of the same sign as the dividend `a`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,H9b)],null)),$APP.z(k$b,new $APP.f(null,3,[$APP.P,"generic identity-like.\n\nLike `one-like` but works for square matrices.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,s4b)],null)),$APP.z(KMb,new $APP.f(null,3,[$APP.P,"[Chinese Remainder Algorithm](https://en.wikipedia.org/wiki/Chinese_remainder_theorem).\n\n  Accepts a sequence of [[ModInt]] instances (where the `modulus` of\n  all [[ModInt]] instances are relatively prime), and returns a [[ModInt]] `x`\n  such that `(residue input) \x3d\x3d (mod x (modulus input))`.\n\n  For example:\n\n  ```clojure\n  (let [a1 (m/make 2 5)\n        a2 (m/make 3 13)]\n    [(\x3d 42 (chinese-remainder a1 a2))\n     (\x3d (residue a1) (mod cr (modulus a1)))\n     (\x3d (residue a2) (mod cr (modulus a2)))])\n  ;;\x3d\x3e [true true true]\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,mX],null))),jU,$APP.M($APP.K,Bbb)],null)),$APP.z(Vsb,new $APP.f(null,3,[$APP.P,"Return a [[PowerSeries]] starting with the supplied values. The remainder of\n  the series will be filled with the zero-value corresponding to the first of\n  the given values.\n\n  If you have a sequence already, prefer [[power-series*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null))),jU,$APP.M($APP.K,J2b)],null)),$APP.z(qKb,
new $APP.f(null,1,[jU,$APP.M($APP.K,gxb)],null)),$APP.z(jOb,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that\n  calculates the [Divergence](https://en.wikipedia.org/wiki/Divergence) of\n  `f` at its input point.\n\n  The divergence is a one-level contraction of the gradient.",jU,$APP.M($APP.K,y3b)],null)),CCb,$APP.z(eW,new $APP.f(null,3,[$APP.P,"generic csch.\n\nComputes the [hyperbolic\n cosecant](https://mathworld.wolfram.com/HyperbolicCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / sinh(x)`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,m9b)],null)),$APP.z(sxb,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector  radians about the y axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),jU,$APP.M($APP.K,ibc)],null)),$APP.z(eVb,new $APP.f(null,1,[jU,$APP.M($APP.K,rDb)],null)),$APP.z(Aib,new $APP.f(null,3,[$APP.P,"SICM p. 47. Polar to rectangular coordinates of state.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EX],null)))),jU,$APP.M($APP.K,o9b)],null)),$APP.z(exb,new $APP.f(null,1,[jU,$APP.M($APP.K,gpb)],null)),$APP.z(ewb,new $APP.f(null,3,[$APP.P,"p. 334",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))),jU,$APP.M($APP.K,GUb)],null)),$APP.z(EFb,new $APP.f(null,3,[$APP.P,"Alternative definition of [[wedge]] in terms of alternation.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null))),
jU,$APP.M($APP.K,Dmb)],null)),$APP.z(cmb,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null))),jU,$APP.M($APP.K,A_b)],null)),$APP.z(nob,new $APP.f(null,2,[$APP.P,"Alias for [[time]].",jU,$APP.M($APP.K,RDb)],null)),$APP.z(cIb,new $APP.f(null,1,[jU,$APP.M($APP.K,L0b)],null)),$APP.z(DT,new $APP.f(null,3,[$APP.P,"generic make-polar",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,lcc)],null)),$APP.z(OV,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is a form field operator, false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[hWb],null)))),jU,$APP.M($APP.K,Cec)],null)),$APP.z(uwb,new $APP.f(null,3,[$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.Nx],null)))),jU,$APP.M($APP.K,p6b)],null)),$APP.z(mU,new $APP.f(null,3,[$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))),jU,$APP.M($APP.K,Osb)],null)),$APP.z(tV,new $APP.f(null,3,[$APP.P,"generic cube",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,B_b)],null)),$APP.z(kxb,new $APP.f(null,1,[jU,$APP.M($APP.K,Zob)],null)),$APP.z(xP,new $APP.f(null,3,[$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,$APP.fx],null))),jU,$APP.M($APP.K,LP)],null)),$APP.z(HEb,new $APP.f(null,3,[$APP.P,"[[gradient]] implements equation (10.3) in Functional Differential Geometry,\n  defined on page 154.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))),jU,$APP.M($APP.K,Qgb)],null)),$APP.z(MXb,new $APP.f(null,3,[$APP.P,"generic tanc.\n\n`tanc` is defined, by analogy with [[sinc]], to be equal to $\\frac{\\tan\n  x}{x}$ for nonzero $x$ and equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/TancFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,GLb)],null)),$APP.z(lSb,new $APP.f(null,3,[$APP.P,"generic determinant",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,krb)],null)),$APP.z(Heb,new $APP.f(null,3,[$APP.P,"Extract the dual basis from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,
new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null))))),jU,$APP.M($APP.K,Eeb)],null)),$APP.z(hDb,new $APP.f(null,3,[$APP.P,"Make a basis object out of a vector and dual basis.\n\n  The dimensions of `vector-basis` and `dual-basis` must agree.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,rW],null)))),jU,$APP.M($APP.K,bac)],null)),$APP.z(wH,new $APP.f(null,3,[$APP.P,"generic sinh.\n\nComputes the [hyperbolic\n sine](https://mathworld.wolfram.com/HyperbolicSine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x - e^{-x}) / 2`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,tJb)],null)),$APP.z(fgb,new $APP.f(null,3,[$APP.P,"Given a metric and a basis, computes the inverse metric.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))),jU,$APP.M($APP.K,ffb)],null)),$APP.z(sDb,new $APP.f(null,3,[$APP.P,"Find the minimum of the function f: R -\x3e R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id\x3dAITCAgAAQBAJ\x26q\x3dBrent%E2%80%99s#v\x3donepage\x26q\x3dParabolic\x26f\x3dfalse).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  [[brent-min]] supports the following optional keyword arguments:\n\n  - `:callback`: if supplied, the supplied fn will be invoked at each\n    intermediate point with the iteration count and the values of x and f(x) at\n    each search step.\n\n  - `:initial-guess`: the first internal point checked by the algorithm. Defaults\n    to `([[initial-brent-guess]] a b)`.\n\n  - `:relative-threshold`: multiplied by each guess to determine a relative\n    threshold. Defaults to 1.0e-11.\n\n  - `:absolute-threshold`: a smaller absolute threshold that applies when the\n    candidate minimum point is close to 0. defaults to around 1.49e8, the sqrt of\n    the machine tolerance. You won't gain any benefit attempting to set the value\n    less than the default.\n\n  - `:maxiter`: Maximum number of iterations allowed for the minimizer. Defaults\n    to 1000.\n\n  - `:maxfun`: Maximum number of times the function can be evaluated before\n    exiting. Defaults to `(inc maxiter)`.\n  ",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,6,5,$APP.I,[NT,PT,PY,IT,sX,$APP.Dw],null),$APP.Kl,new $APP.f(null,5,[NT,yV,PT,OY,PY,$APP.M(UT,$APP.Iv,$APP.qU),IT,1E3,$APP.Dw,$APP.M($APP.cw,null)],null)],null)],null))),jU,$APP.M($APP.K,fkb)],null)),$APP.z(Q7b,new $APP.f(null,2,[$APP.P,"Alias for [[/]].",jU,$APP.M($APP.K,C_b)],null)),$APP.z(QJb,new $APP.f(null,3,[$APP.P,
"Given a symbolic name `sym` and a `coordinate-system`, returns a one-form field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3eoneform-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-form-field`'s component\n  functions will accept a single non-structural argument.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,oW],null)))),jU,$APP.M($APP.K,QPb)],null)),$APP.z(oxb,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector  radians about the x axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),jU,$APP.M($APP.K,bbc)],null)),$APP.z(HOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Dx,TU],null)))),jU,$APP.M($APP.K,Hhb)],null)),$APP.z(ebc,new $APP.f(null,3,[$APP.P,"One of the two incompatible definitions of differential.\n\n  This differential is a special case of exterior derivative. The other one\n  lives at [[map/differential]].",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(SHb,$APP.Kv)],null)],null))))),jU,$APP.M($APP.K,gfb)],null)),$APP.z(Pdb,new $APP.f(null,2,[$APP.P,"Converts an S-expression to printable infix form. Numeric exponents are\n  written as superscripts. Partial derivatives get subscripts.",jU,$APP.M($APP.K,DHb)],null)),$APP.z(UX,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a basis, false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,YWb)],null)),$APP.z(ZYb,new $APP.f(null,3,[$APP.P,"Returns the single column from the supplied column matrix as a vector. Errors\n  if some other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(oY,$APP.Or)],null)],null))))),jU,$APP.M($APP.K,jEb)],null)),$APP.z(PQb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[hW,TU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,TU)],null)],null))))),jU,$APP.M($APP.K,Rbc)],null)),$APP.z($APP.fU,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from coordinates in\n  `coordinate-system`'s repesentation to the matching point on the manifold\n  associated with `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,j$b)],null)),$APP.z(Uwb,new $APP.f(null,1,[jU,$APP.M($APP.K,Fob)],null)),Ppb,$APP.z(kH,new $APP.f(null,3,[$APP.P,"generic sin.\n\nReturns the [sine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Cib)],null)),$APP.z(MQb,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that\n  calculates the [Curl](https://en.wikipedia.org/wiki/Curl_(mathematics)) of `f`\n  at its input point.\n\n  `f` must be a function from $\\mathbb{R}^3 \\to \\mathbb{R}^3$.",
jU,$APP.M($APP.K,tMb)],null)),$APP.z(MBb,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that calculates\n  the [Vector\n  Laplacian](https://en.wikipedia.org/wiki/Laplace_operator#Vector_Laplacian) of\n  `f` at its input point.",jU,$APP.M($APP.K,Tzb)],null)),$APP.z(yib,new $APP.f(null,3,[$APP.P,"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.fx],
null)))),jU,$APP.M($APP.K,Jdc)],null)),$APP.z(B0b,new $APP.f(null,1,[jU,$APP.M($APP.K,I_b)],null)),$APP.z(VVb,new $APP.f(null,1,[jU,$APP.M($APP.K,GAb)],null)),$APP.z(G6b,new $APP.f(null,3,[$APP.P,"generic exact-divide.\n\nSimilar to the binary case of [[/]], but throws if `(g/exact? \x3cresult\x3e)`\n  returns false.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,v2b)],null)),$APP.z(UFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null)))),jU,$APP.M($APP.K,PAb)],null)),$APP.z(lK,new $APP.f(null,3,[$APP.P,"generic tan.\n\nComputes the trigonometric tangent function of the supplied argument `a`.\n\nEquivalent to `(/ (sin a) (cos a))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,aCb)],null)),$APP.z(M_b,new $APP.f(null,3,[$APP.P,"generic solve-linear.\n\nFor a given `a` and `b`, returns `x` such that `a*x \x3d b`.\n\n  See[[solve-linear-right]] for a similar function that solves for `a \x3d x*b`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,bcc)],null)),$APP.z(U1b,new $APP.f(null,3,[$APP.P,"generic freeze.\n\nFreezing an expression means removing wrappers and other metadata from\n  subexpressions, so that the result is basically a pure S-expression with the\n  same structure as the input. Doing this will rob an expression of useful\n  information for further computation; so this is intended to be done just\n  before simplification and printing, to simplify those processes.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,WUb)],null)),$APP.z(Gzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null)))),jU,$APP.M($APP.K,F0b)],null)),$APP.z(yvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[XT],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(GT,XT)],null)],null))))),jU,$APP.M($APP.K,LJb)],null)),$APP.z(xlb,
new $APP.f(null,3,[$APP.P,"Extract the dimension from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null))))),jU,$APP.M($APP.K,fvb)],null)),$APP.z($APP.AY,new $APP.f(null,3,[$APP.P,"generic dimension",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,jdb)],null)),$APP.z(pvb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))),jU,$APP.M($APP.K,o_b)],null)),$APP.z(C8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null)))),jU,$APP.M($APP.K,Qwb)],null)),$APP.z(dpb,new $APP.f(null,3,[$APP.P,"For making a (0,2) tensor into a (2,0) tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null)))),jU,$APP.M($APP.K,njb)],null)),$APP.z(dQb,new $APP.f(null,3,[$APP.P,"Returns the owning [[IFrame]] instance of the supplied coordinates `coords`,\n  nil if there's no owner otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null)))),jU,$APP.M($APP.K,QLb)],null)),$APP.z(Kxb,new $APP.f(null,1,[jU,$APP.M($APP.K,Rob)],null)),$APP.z(zdb,new $APP.f(null,1,[jU,$APP.M($APP.K,Y6b)],null)),$APP.z(yjb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.Lh,wW],null))),$APP.P,"A shim so that ref can act like nth in SICM contexts, as clojure core ref\n  elsewhere.",$APP.hy,new $APP.f(null,
6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.Lh,wW],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Ijb,new $APP.f(null,3,[$APP.P,"Returns the Jacobian of transition from `from-basis` to `to-basis`.\n\n  The Jacobian is a structure of manifold functions. The outer index is the\n  from-basis index, so this structure can be multiplied by tuple of component\n  functions of a vector field relative to `from-basis` to get component\n  functions for a vector field in `to-basis`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Ksb,QMb],null)))),jU,$APP.M($APP.K,pQb)],null)),$APP.z(ftb,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of  radians about the y axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),jU,$APP.M($APP.K,wsb)],null)),$APP.z(Snb,new $APP.f(null,3,[$APP.P,"generic tanhc.\n\nThe [tanhc function](https://en.wikipedia.org/wiki/Tanhc_function),\n  equivalent to $\\frac{\\tanh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanhc_function)\n   - [Mathworld page on Tanhc](https://mathworld.wolfram.com/TanhcFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,pfb)],null)),$APP.z(sH,new $APP.f(null,3,[$APP.P,"generic cos.\n\nReturns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,dEb)],null)),$APP.z(EGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),$APP.P,
"Returns a string containing a LaTeX representation of `expr`, wrapped in single\n  `$` to mark the string as an inline LaTeX form."],null)),$APP.z(xgb,new $APP.f(null,3,[$APP.P,"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components-\x3evector-field\n     (up x y)\n     (coordinate-system-\x3evector-basis R2-rect)))\n  ;; \x3d\x3e (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[VV,xU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(ZFb,VV,xU)],null)],null))))),jU,$APP.M($APP.K,LYb)],null)),$APP.z(wcc,new $APP.f(null,3,[$APP.P,"Returns the parameters registered with the supplied frame.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))),jU,$APP.M($APP.K,RYb)],null)),$APP.z(C1b,new $APP.f(null,3,[$APP.P,"Given a structure `w` of and a vector field basis `vector-basis`, returns a new\n  structure generated by applying the full vector basis to each element of `w`.\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [vb    (vf/coordinate-system-\x3evector-basis coordsys)\n        basis (coordinate-system-\x3eoneform-basis coordsys)\n        components (down d:dx d:dy)]\n    (\x3d components\n       (-\x3e components\n           (basis-components-\x3eoneform-field basis)\n           (oneform-field-\x3ebasis-components vb))))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Hyb,xU],null)))),jU,$APP.M($APP.K,eSb)],null)),$APP.z(QAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))),jU,$APP.M($APP.K,ZOb)],null)),$APP.z(u1b,new $APP.f(null,3,[$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns the result of aggregating either `xs` or `(map f (range low\n  high))` using the fold dynamically bound to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (sum inc 0 10))\n  ;;\x3d\x3e [55.0 1 10]\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null))),jU,$APP.M($APP.K,mhb)],null)),$APP.z(pmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Vw,$APP.fy,oZb],null)))),jU,$APP.M($APP.K,QRb)],null)),$APP.z(iK,new $APP.f(null,3,[$APP.P,"generic gcd.\n\nReturns the [greatest common\n  divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the two\n  inputs `a` and `b`.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,jUb)],null)),$APP.z(jdc,new $APP.f(null,3,[$APP.P,"generic exp10.\n\nReturns the base-10 exponential of `x`. Equivalent to `(expt 10 x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,GJb)],null)),$APP.z(Z1b,new $APP.f(null,1,[jU,$APP.M($APP.K,ASb)],null)),$APP.z(DXb,new $APP.f(null,3,[$APP.P,"Returns a function that takes a single manifold `point` embedded in the\n  manifold `embedded` and transfers the point to the supplied `embedding`\n  manifold.\n\n  The embedding dimension must be the same for both manifolds.\n\n  NOTE that `embedded` and `embedding` can be either manifolds, or instances\n  of [[ICoordinateSystem]]. In the latter case `embedded` and `embedding` will\n  bind to the manifold associated with the supplied [[ICoordinateSystem]].",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[HKb,V9b],null)))),jU,$APP.M($APP.K,w$b)],null)),$APP.z(Ncc,new $APP.f(null,3,[$APP.P,"generic cross-product",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,m5b)],null)),$APP.z(Rwb,new $APP.f(null,3,[$APP.P,"Returns a predicate that returns true if its argument matches the supplied\n  kind-keyword `k`, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,XVb)],null)),$APP.z(t5a,new $APP.f(null,3,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null)))),jU,$APP.M($APP.K,PNb)],null)),$APP.z(npb,new $APP.f(null,3,[$APP.P,"Returns a data structure representing [Christoffel symbols of the second\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_second_kind_(symmetric_definition)).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[DX,TU],null)))),jU,$APP.M($APP.K,uac)],null)),$APP.z(Nnb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))),jU,$APP.M($APP.K,XXb)],null)),$APP.z(fcc,new $APP.f(null,3,[$APP.P,"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[tNb],
null)))),jU,$APP.M($APP.K,X5b)],null)),$APP.z(KRb,new $APP.f(null,3,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,vV],null)))),jU,$APP.M($APP.K,Y0b)],null)),$APP.z(dhb,new $APP.f(null,3,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null)))),jU,$APP.M($APP.K,ZAb)],null)),$APP.z(vzb,new $APP.f(null,3,[$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null))))),jU,$APP.M($APP.K,S9b)],null)),$APP.z(Dtb,new $APP.f(null,3,[$APP.P,"Returns the velocity element of a local tuple (by convention, the third\n  element).\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),2)],null)],null))))),jU,$APP.M($APP.K,
CLb)],null)),$APP.z(rGb,new $APP.f(null,3,[$APP.P,"Legendre elliptic integral of the first kind F(, k).\n   See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.19\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[WR,$APP.tU],null)))),jU,$APP.M($APP.K,T7b)],null)),$APP.z(YX,new $APP.f(null,3,[$APP.P,"generic modulo.\n\nReturns the result of the\n  mathematical [Modulo](https://en.wikipedia.org/wiki/Modulo_operation)\n  operation between `a` and `b` (using the Knuth definition listed).\n\n The contract satisfied by [[modulo]] is:\n\n```clojure\n(\x3d a (+ (* b (floor (/ a b)))\n        (modulo a b)))\n```\n\n For numbers, this differs from the contract offered by [[remainder]]\n because `(floor (/ a b))` rounds toward negative infinity, while\n the [[quotient]] operation in the contract for [[remainder]] rounds toward 0.\n\n The result will be either `0` or of the same sign as the divisor `b`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,Klb)],null)),$APP.z(y0b,new $APP.f(null,3,[$APP.P,"Forward-mode derivative operator. Takes some function `f` and returns a\n  function whose value at some point can multiply an increment in the arguments\n  to produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D-forward]] computes a derivative. For vector-valued\n  functions, [[D-forward]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,oyb)],null)),$APP.z(Uub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[HU,TU],null)))),jU,$APP.M($APP.K,dOb)],null)),$APP.z($APP.rj,new $APP.f(null,3,[$APP.P,"Generic implementation of `/`.\n\n  If one argument is supplied, returns the multiplicative inverse of `a`. Else\n  returns the result of dividing first argument `a` by the product of all\n  remaining arguments. `(/)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core//`. Dispatch is open,\n  however, making it possible to 'divide' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (/ [2 4 6] 2)\n  ;;\x3d\x3e (up 1 2 3)\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))),jU,$APP.M($APP.K,kqb)],null)),$APP.z(Ldb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[YW,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null)))),jU,$APP.M($APP.K,rIb)],null)),$APP.z(qS,new $APP.f(null,3,[$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))),jU,$APP.M($APP.K,rmb)],null)),$APP.z(qVb,new $APP.f(null,3,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,vV],null)))),jU,$APP.M($APP.K,dRb)],null)),
$APP.z(T3b,new $APP.f(null,3,[$APP.P,"Entrypoint for multidimensional minimization routines.\n\n  See [[emmy.numerical.multimin.nelder-mead/nelder-mead]] for the only\n  supported option.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Hy,$APP.NW,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[cY],null),$APP.ck,$APP.Lx],null)],null))),jU,$APP.M($APP.K,CMb)],null)),$APP.z(B5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Kyb],
null)))),jU,$APP.M($APP.K,cEb)],null)),$APP.z(E7b,new $APP.f(null,3,[$APP.P,"Returns a [[PowerSeries]] instance representing a\n  [Binomial series](https://en.wikipedia.org/wiki/Binomial_series), i.e., the\n  taylor series of the function $f$ given by\n\n  ```\n  $$f(x) \x3d (1 + x)^\\alpha$$\n  ```",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null)))),jU,$APP.M($APP.K,Bhb)],null)),$APP.z(oT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[pT],null)))),jU,$APP.M($APP.K,ZXb)],null)),$APP.z(Jpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gS],null)))),jU,$APP.M($APP.K,iNb)],null)),$APP.z(uxb,new $APP.f(null,1,[jU,$APP.M($APP.K,vpb)],null)),$APP.z(xJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EX],null)))),jU,$APP.M($APP.K,AKb)],null)),$APP.z(Msb,new $APP.f(null,3,[$APP.P,"Returns the factorial of `n`, i.e., the product of 1 to `n` (inclusive).\n\n  [[factorial]] will return a platform-specific [[emmy.util/bigint]] given\n  some `n` that causes integer overflow.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M($APP.$v,$APP.uU,0)],null)],null))))),jU,$APP.M($APP.K,frb)],null)),$APP.z(rdb,new $APP.f(null,1,[jU,$APP.M($APP.K,vrb)],null)),$APP.z(Wzb,new $APP.f(null,1,[jU,$APP.M($APP.K,jwb)],null)),$APP.z(OOb,new $APP.f(null,3,[$APP.P,"Golden Section search attempts to locate the minimum of the supplied function\n  `f` by evaluating points located at golden-ratioed intervals between the two\n  starting endpoints `a` and `b`. This method is slow, steady and reliable.\n\n  Supports the following optional keyword arguments:\n\n  `:converged?` is an optional predicate accepting five arguments:\n\n  - `[a fa]`\n  - `[l fl]`\n  - `[r fr]`\n  - `[b fb]`\n  - `current-iteration`\n\n  If the supplied `fn` returns true, it will signal convergence and the\n  optimizer will return. Returning false will continue.\n\n  `:choose` is called at the final step of optimization with all 4 points and\n  their fn values (see the first four arguments to `:converged?`), and returns\n  the final choice.\n\n  `:callback` receives all 5 arguments on every iteration.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n\n  `:fn-tolerance` check that the minimal value of any of the checked points is\n  within the maximum of f(a) or f(b).\n\n  `:arg-tolerance` check that `a` and `b` are within this supplied absolute\n  distance.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,new $APP.f(null,3,[$APP.zu,new $APP.H(null,2,5,$APP.I,[WX,$APP.Dw],null),$APP.Kl,new $APP.f(null,2,[WX,iW,$APP.Dw,$APP.M($APP.cw,null)],null),$APP.ck,$APP.Lx],null)],null))),jU,$APP.M($APP.K,q9b)],null)),$APP.z(vvb,new $APP.f(null,3,[$APP.P,"generic exact?.\n\nEntries that are exact are available for `gcd`, among other operations.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Clb)],null)),$APP.z(Vnb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null)))),jU,$APP.M($APP.K,gFb)],null)),$APP.z(emb,new $APP.f(null,2,[$APP.P,"Similar to the [[S2-spherical]] coordinate system, with the north pole rotated\n  90 degrees and lying along the positive y axis.",jU,$APP.M($APP.K,umb)],null)),$APP.z(WQb,new $APP.f(null,3,[$APP.P,"generic outer-product",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,Ftb)],null)),$APP.z(mH,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(iKb,new $APP.f(null,3,[$APP.P,"Convert the structure `ms`, which would be a scalar if the (compatible)\n  multiplication `(* ls ms rs)` were performed, to a matrix.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null))),jU,$APP.M($APP.K,VJb)],null)),$APP.z(Ysb,new $APP.f(null,1,[jU,$APP.M($APP.K,ltb)],null)),$APP.z($APP.Iu,
new $APP.f(null,3,[$APP.P,"generic abs",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,idb)],null)),$APP.z(wS,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a coordinate basis, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,e2b)],null)),$APP.z(T5b,new $APP.f(null,3,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold, false\n  otherwise.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null)))),jU,$APP.M($APP.K,i0b)],null)),$APP.z(hX,new $APP.f(null,3,[$APP.P,"generic invert.\n\nReturns the multiplicative inverse of `a`.\n\n  Equivalent to `(/ 1 a)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,TGb)],null)),$APP.z(CU,new $APP.f(null,2,[$APP.P,"Identity function. Returns its argument.",jU,$APP.M($APP.K,wYb)],null)),$APP.z(AOb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,YRb],null)))),jU,$APP.M($APP.K,XZb)],null)),$APP.z(bBb,new $APP.f(null,2,[$APP.P,"Alias for [[lower]].",jU,$APP.M($APP.K,pTb)],null)),$APP.z(LFb,new $APP.f(null,3,[$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  Variadic equivalent to [[by-rows*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,zV],null))),jU,$APP.M($APP.K,sec)],null)),$APP.z(rAb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$X],null)))),jU,$APP.M($APP.K,Rab)],null)),$APP.z(GX,new $APP.f(null,3,[$APP.P,"generic dot-product",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,i9b)],null)),$APP.z(zjb,new $APP.f(null,3,[$APP.P,"Returns a column matrix populated by the supplied `xs`. Variadic equivalent\n  to [[column*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Lh,$APP.fx],null))),jU,$APP.M($APP.K,Rcb)],null)),$APP.z(Ewb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Dcc,Odb],null)))),jU,$APP.M($APP.K,H1b)],null)),$APP.z(xkb,new $APP.f(null,3,[$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  Variadic equivalent to [[by-cols*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,fX],null))),jU,$APP.M($APP.K,jmb)],null)),
$APP.z(gib,new $APP.f(null,3,[$APP.P,"p.324",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SR,$APP.BU],null)))),jU,$APP.M($APP.K,nnb)],null)),$APP.z($T,new $APP.f(null,3,[$APP.P,"generic real-part",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Xkb)],null)),$APP.z(fAb,new $APP.f(null,1,[jU,$APP.M($APP.K,Fwb)],null)),$APP.z(Kpb,new $APP.f(null,3,[$APP.P,"Returns a column matrix with the contents of the supplied `up` structure.\n  Errors if any other type is provided.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(bY,$APP.Tv)],null)],null))))),jU,$APP.M($APP.K,p8b)],null)),$APP.z(EEb,new $APP.f(null,3,[$APP.P,"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\n\n  See [[brent-min]] for all supported `opts`.",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,$APP.Lx],null)))),jU,$APP.M($APP.K,A6b)],null)),$APP.z(Kbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null)))),jU,$APP.M($APP.K,F9b)],null)),$APP.z(BJ,new $APP.f(null,3,[$APP.P,"generic log.\n\nReturns the natural logarithm of `x`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,$bc)],null)),$APP.z(WR,new $APP.f(null,
1,[$APP.Kw,!0],null)),$APP.z(O1b,new $APP.f(null,3,[$APP.P,"Returns a concrete manifold generated by specializing the supplied manifold\n  `family` into a concrete manifold of dimension `n`. `n` must be a positive\n  integer.\n\n  Optionally takes an `embedding-dimension`; this must be \x3e\x3d the value of `n`.\n  Use this in cases like an n-sphere embedded in a euclidean space of dimension\n  n+1.\n\n  A [manifold](https://en.wikipedia.org/wiki/Manifold) is a topological space\n  that locally resembles Euclidean space near each point.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[uV,$APP.uU],null),new $APP.H(null,3,5,$APP.I,[uV,$APP.uU,tX],null))),jU,$APP.M($APP.K,pAb)],null)),$APP.z(MY,new $APP.f(null,3,[$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))),jU,$APP.M($APP.K,IAb)],null)),$APP.z(avb,new $APP.f(null,3,[$APP.P,"Return a structure with the same shape as s but with f applied to each\n  primitive (that is, not structural) component.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null))),jU,$APP.M($APP.K,wyb)],null)),$APP.z(iS,new $APP.f(null,3,[$APP.P,"generic partial-derivative",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,aEb)],null)),$APP.z(xrb,new $APP.f(null,1,[jU,$APP.M($APP.K,WGb)],null)),$APP.z(E8b,new $APP.f(null,3,[$APP.P,"Returns the sum of all elements in the input series `s` up to order\n  `n` (inclusive). For example:\n\n  ```clojure\n  (sum (series 1 1 1 1 1 1 1) 3)\n  ;; \x3d\x3e 4\n  ```\n\n  NOTE that [[sum]] sums the first `n + 1` terms, since a series starts with an\n  order 0 term.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.uU],null)))),jU,$APP.M($APP.K,SRb)],null)),$APP.z(yxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Vw,qS,oT,zqb,k8b],null)))),jU,$APP.M($APP.K,hgb)],null)),$APP.z(wtb,new $APP.f(null,3,[$APP.P,"Given a structure of `components` functions defined on manifold points and and\n  a matching `oneform-basis` (of identical structure),\n\n  Returns a new one-form field that\n\n  - passes its vector-field argument to `oneform-basis`, returning a new\n    equivalent structure with each slot populated by functions from a manifold\n    point to the directional derivative (using the vector field) in that\n    coordinate direction\n\n  - contracts the result of that operation with the result of applying each\n    component in `components` to the manifold point.\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[oneform-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,MHb],null)))),jU,$APP.M($APP.K,CIb)],null)),$APP.z(lBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null)))),jU,$APP.M($APP.K,z4b)],null)),$APP.z(UBb,new $APP.f(null,3,[$APP.P,"Computes the trace of a (0,2) tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null)))),jU,$APP.M($APP.K,i5b)],null)),$APP.z(Bdc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Pv],null)))),jU,$APP.M($APP.K,lJb)],null)),$APP.z(nH,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(zsb,new $APP.f(null,3,[$APP.P,"Extract the vector basis from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null))))),jU,$APP.M($APP.K,Mdb)],null)),$APP.z(vHb,new $APP.f(null,3,[$APP.P,
"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null)))),jU,$APP.M($APP.K,cTb)],null)),$APP.z(IFb,new $APP.f(null,3,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q`, velocity tuple (or scalar)\n  `qdot` and any number of additional higher-order derivative tuples (or\n  scalars), returns a 'Local tuple', i.e., the state expected by a Lagrangian.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Rv,vU,RY,$APP.Lh,tT],null))),jU,$APP.M($APP.K,Yvb)],null)),$APP.z(O7b,new $APP.f(null,3,[$APP.P,"Return the structure `s` in unoriented vector form.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))),jU,$APP.M($APP.K,K4b)],null)),$APP.z(uTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[IP,Hvb],null)))),jU,$APP.M($APP.K,BXb)],null)),$APP.z(uvb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,B9b],null)))),jU,$APP.M($APP.K,DQb)],null)),$APP.z(Omb,new $APP.f(null,3,[$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null)))),jU,$APP.M($APP.K,Thb)],
null)),$APP.z(NY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null)))),jU,$APP.M($APP.K,cCb)],null)),$APP.z(qNb,new $APP.f(null,3,[$APP.P,"Return a [[Series]] starting with the supplied values. The remainder of the\n  series will be filled with the zero-value corresponding to the first of the\n  given values.\n\n  If you have a sequence already, prefer [[series*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null))),jU,
$APP.M($APP.K,Wtb)],null)),$APP.z(GRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null)))),jU,$APP.M($APP.K,iib)],null)),$APP.z(A5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,rU],null)))),jU,$APP.M($APP.K,$Rb)],null)),$APP.z(Y1b,new $APP.f(null,3,[$APP.P,"Returns a series (of the same type as the input) of partial sums of the terms\n  in the supplied series `s`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))),jU,$APP.M($APP.K,Vyb)],null)),$APP.z(nub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,Psb)],null)),$APP.z(i4a,new $APP.f(null,3,[$APP.P,"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Hv],null)))),jU,$APP.M($APP.K,gyb)],null)),$APP.z($APP.Zv,new $APP.f(null,1,[jU,$APP.M($APP.K,G5b)],null)),$APP.z(zdc,new $APP.f(null,3,[$APP.P,"Returns a matrix with `r` rows and `c` columns, whose entries are generated by\n  the supplied function `f`.\n\n  If you only supply one dimension `n` the returned matrix will be square.\n\n  The entry in the `i`th row and `j`-th column is `(f i j)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null),new $APP.H(null,
3,5,$APP.I,[$APP.mO,$APP.Jv,$APP.Kv],null))),jU,$APP.M($APP.K,Bsb)],null)),$APP.z(DY,new $APP.f(null,3,[$APP.P,"Returns true if `p` is a manifold point, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null)))),jU,$APP.M($APP.K,n8b)],null)),$APP.z(t0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null)))),jU,$APP.M($APP.K,FWb)],null)),$APP.z(OGb,new $APP.f(null,2,[$APP.P,"Converts an S-expression to JavaScript.",
jU,$APP.M($APP.K,P9b)],null)),$APP.z(uH,new $APP.f(null,3,[$APP.P,"generic cosh.\n\nComputes the [hyperbolic\n cosine](https://mathworld.wolfram.com/HyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x + e^{-x}) / 2`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,AXb)],null)),$APP.z(G8b,new $APP.f(null,3,[$APP.P,"Given a vector field `vf` generated from [[basis-components-\x3evector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis-\x3edual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system-\x3evector-basis coordsys)\n        dual  (basis/vector-basis-\x3edual basis coordsys)]\n    (\x3d basis-components\n       (-\x3e basis-components\n           (basis-components-\x3evector-field basis)\n           (vector-field-\x3ebasis-components dual))))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ex,rW],null)))),jU,$APP.M($APP.K,qvb)],null)),$APP.z(tW,new $APP.f(null,3,[$APP.P,"generic coth.\n\nComputes the [hyperbolic\n cotangent](https://mathworld.wolfram.com/HyperbolicCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `cosh(x) / sinh(x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,KXb)],null)),$APP.z(KIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[rY,pX,sW],null)))),jU,$APP.M($APP.K,Qib)],null)),$APP.z(RCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RX],null)))),jU,$APP.M($APP.K,lzb)],null)),$APP.z(Ypb,new $APP.f(null,3,[$APP.P,"generic one-like.\n\nIn general, this procedure returns the multiplicative identity of the type of\n  its argument, if it exists. For numbers this is 1.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Iv],null)))),jU,$APP.M($APP.K,qib)],null)),$APP.z(E5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.NW,$APP.OW,$APP.uU],null)))),jU,$APP.M($APP.K,Sfb)],null)),$APP.z(y5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null),new $APP.H(null,2,5,$APP.I,[KT,RX],null))),jU,$APP.M($APP.K,Zqb)],null)),$APP.z(aZb,new $APP.f(null,1,[jU,$APP.M($APP.K,Inb)],null)),$APP.z(PCb,new $APP.f(null,1,[jU,$APP.M($APP.K,wac)],null)),
$APP.z(aac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,QY)],null)),$APP.z(DJ,new $APP.f(null,3,[$APP.P,"generic expt",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,A9b)],null)),$APP.z(nrb,new $APP.f(null,1,[jU,$APP.M($APP.K,J_b)],null)),$APP.z(d$b,new $APP.f(null,3,[$APP.P,"Returns an [[ICoordinateSystem]] instance specialized to the patch named\n  `patch-name` on `manifold`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[ZR,TX,gW],null)))),jU,$APP.M($APP.K,xyb)],null)),$APP.z(iSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null))),jU,$APP.M($APP.K,WFb)],null)),$APP.z(pwb,new $APP.f(null,3,[$APP.P,"p.327",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null)))),jU,$APP.M($APP.K,Ghb)],null)),$APP.z(yfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))),jU,$APP.M($APP.K,Qub)],null)),$APP.z(TIb,new $APP.f(null,3,[$APP.P,"Returns a structure compatible for multiplication with `s` down to 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))),jU,$APP.M($APP.K,J1b)],null)),$APP.z(ITb,new $APP.f(null,1,[jU,$APP.M($APP.K,LMb)],null)),$APP.z(xW,new $APP.f(null,3,[$APP.P,"generic fractional-part.\n\nReturns the fractional part of the given value, defined as `x - x`.\n\n  For positive numbers, this is identical to `(- a (integer-part a))`. For\n  negative `a`, because [[floor]] truncates toward negative infinity, you might\n  be surprised to find that [[fractional-part]] returns the distance between `a`\n  and the next-lowest integer:\n\n```clojure\n(\x3d 0.6 (fractional-part -0.4))\n```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,cRb)],null)),$APP.z(JRb,new $APP.f(null,3,[$APP.P,"Returns true if `e` is an event, false otherwise.\n\n  Make new events with [[make-event]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null)))),jU,$APP.M($APP.K,P$b)],null)),$APP.z(AUb,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation, returns a\n  one-form field.\n\n  The returned one-form field at each structural spot takes a vector field and\n  returns a function that takes the directional derivative in that coordinate's\n  direction using the vector field.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null))),jU,$APP.M($APP.K,EIb)],null)),$APP.z(B4b,new $APP.f(null,3,[$APP.P,"Returns the single column from the supplied column matrix as an `up`. Errors if\n  some other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(oY,$APP.Or)],null)],null))))),jU,$APP.M($APP.K,oIb)],null)),Ubb,$APP.z(aY,new $APP.f(null,
3,[$APP.P,"generic trace",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,fmb)],null)),$APP.z($APP.Fv,new $APP.f(null,3,[$APP.P,"Generic implementation of `+`. Returns the sum of all supplied arguments. `(+)`\n  returns 0, the additive identity.\n\n  When applied between numbers, acts like `clojure.core/+`. Dispatch is open,\n  however, making it possible to 'add' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (+ [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up 3 5 7)\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))),jU,$APP.M($APP.K,mqb)],null)),$APP.z(zJb,new $APP.f(null,3,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q` and momentum tuple (or\n  scalar) `p`, returns a 'Hamiltonian state tuple', i.e., the state expected by a\n  Hamiltonian.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,
5,$APP.I,[$APP.Rv,vU,$APP.Pv],null)))),jU,$APP.M($APP.K,Btb)],null)),$APP.z(Yfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null)))),jU,$APP.M($APP.K,sVb)],null)),$APP.z($Nb,new $APP.f(null,3,[$APP.P,"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point \x3d\x3e\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,hS)],null)),$APP.z(mvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,RX],null)))),jU,$APP.M($APP.K,Akb)],null)),$APP.z(UOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,CV],null)))),jU,$APP.M($APP.K,IOb)],null)),$APP.z(SQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,
5,$APP.I,[hW,TU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,TU)],null)],null))))),jU,$APP.M($APP.K,Pbc)],null)),$APP.z(zac,new $APP.f(null,3,[$APP.P,"Marks the input event `e` as an event via its metadata. The return value will\n  return `true` when passed to [[event?]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null)))),jU,$APP.M($APP.K,ssb)],null)),$APP.z(aqb,new $APP.f(null,2,[$APP.P,"Alias for [[compatible-zero]].",jU,$APP.M($APP.K,
Fkb)],null)),lob,$APP.z(eac,new $APP.f(null,1,[jU,$APP.M($APP.K,Phb)],null)),$APP.z(zNb,new $APP.f(null,1,[jU,$APP.M($APP.K,Qcb)],null)),$APP.z(BOb,new $APP.f(null,1,[jU,$APP.M($APP.K,AJb)],null)),$APP.z(AQb,new $APP.f(null,3,[$APP.P,"Construct a ratio.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.jP],null))),jU,$APP.M($APP.K,KX)],null)),$APP.z(POb,new $APP.f(null,3,[$APP.P,"Given a one-form field `form` and a `coordinate-system`, returns a function\n  from the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the form field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-oneform-field 'f R2-rect)]\n      ((oneform-field-\x3ecomponents f R2-rect)\n       (up 'x0 'y0))))\n\n  ;;\x3d\x3e (down (f_0 (up x0 y0))\n  ;;         (f_1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Bv,oW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(OV,$APP.Bv)],null)],null))))),jU,$APP.M($APP.K,qjb)],null)),$APP.z(K5b,new $APP.f(null,3,[$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null))))),jU,$APP.M($APP.K,inb)],null)),$APP.z(CDb,new $APP.f(null,1,[jU,$APP.M($APP.K,qxb)],null)),$APP.z(wdc,new $APP.f(null,3,[$APP.P,"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field-\x3ecomponents f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;\x3d\x3e (up (f0 (up x0 y0))\n  ;;       (f1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.ex,oW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(cV,$APP.ex)],null)],null))))),jU,$APP.M($APP.K,RVb)],null)),$APP.z(LM,new $APP.f(null,3,[$APP.P,"generic sec.\n\nComputes the secant of the supplied argument `a`.\n\nEquivalent to `(invert (cos a))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,ahb)],null)),$APP.z(sZb,new $APP.f(null,
2,[$APP.P,"Alias for [[-\x3eL-state]].",jU,$APP.M($APP.K,cxb)],null)),$APP.z(a6b,new $APP.f(null,3,[$APP.P,"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.ex,oW],null)))),jU,$APP.M($APP.K,MTb)],null)),$APP.z(uhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,TU],null)))),jU,$APP.M($APP.K,sCb)],null)),$APP.z(ibb,new $APP.f(null,3,[$APP.P,"Computes the trace of a (2,0) tensor",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null)))),jU,$APP.M($APP.K,Ohb)],null)),$APP.z(PX,new $APP.f(null,3,[$APP.P,"generic negate.\n\nReturns the negation of `a`.\n\n  Equivalent to `(- (g/zero-like a) a)`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,klb)],null)),$APP.z(aFb,new $APP.f(null,3,[$APP.P,"generic acoth.\n\nComputes the [inverse hyperbolic\n cotangent](https://mathworld.wolfram.com/InverseHyperbolicCotangent.html) of\n the supplied argument `a`.\n\ndefaults to `1/2 ln((x+1)/(x-1))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,z1b)],null)),$APP.z(pBb,new $APP.f(null,2,
[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,TU],null)))),jU,$APP.M($APP.K,DSb)],null)),$APP.z(sT,new $APP.f(null,3,[$APP.P,"generic sech.\n\nComputes the [hyperbolic\n secant](https://mathworld.wolfram.com/HyperbolicSecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / cosh(x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Opb)],null)),$APP.z(dIb,new $APP.f(null,3,[$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))),jU,$APP.M($APP.K,$6b)],null)),$APP.z(Fpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))),jU,$APP.M($APP.K,O_b)],null)),$APP.z(D5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ON],null)))),jU,$APP.M($APP.K,Fac)],null)),$APP.z(kob,new $APP.f(null,3,[$APP.P,"generic log10.\n\nReturns the base-10 logarithm of `x`, i.e., $log_10(x)$.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,sdb)],null)),$APP.z(JPb,new $APP.f(null,3,[$APP.P,"Convert the matrix `m` into a structure `S`, guided by the requirement that `(*\n  ls S rs)` should be a scalar.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[yW,$APP.Or,KW],null)))),jU,$APP.M($APP.K,q$b)],null)),$APP.z($Vb,new $APP.f(null,3,[$APP.P,"Returns the acceleration element of a local tuple (by convention, the fourth\n  element).\n\n  See [[coordinate]] for more detail.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),3)],null)],null))))),jU,$APP.M($APP.K,T6b)],null)),$APP.z(LZb,new $APP.f(null,3,[$APP.P,"p.326",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))),jU,$APP.M($APP.K,kyb)],null)),$APP.z(qZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,
4,5,$APP.I,[$APP.Hv,$APP.Vv,$APP.SP,$APP.TP],null)],null)))),jU,$APP.M($APP.K,$ib)],null)),$APP.z(Wfb,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is an [form field of rank\n  n](https://en.wikipedia.org/wiki/Differential_form), false otherwise.\n\n  A form-field of rank n is an operator that takes n vector fields to a\n  real-valued function on the manifold.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null)))),jU,$APP.M($APP.K,tbc)],null)),
$APP.z(NPb,new $APP.f(null,3,[$APP.P,"Returns a [[PowerSeries]] representing the supplied constant term.\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[$APP.Jv,YV],null))),jU,$APP.M($APP.K,wwb)],null)),$APP.z(fPb,new $APP.f(null,3,[$APP.P,"For convenience, we also provide the sister-procedure for finding\n  the maximum of a unimodal function using the golden section method.\n\n  Negate the function, minimize, negate the result.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,$APP.Lx],null))),jU,$APP.M($APP.K,vdc)],null)),$APP.z(aT,new $APP.f(null,3,[$APP.P,"generic square",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,iAb)],null)),$APP.z(wQb,new $APP.f(null,3,[$APP.P,"generic exp2.\n\nReturns the base-2 exponential of `x`. Equivalent to `(expt 2 x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,i$b)],null)),$APP.z(zLb,new $APP.f(null,3,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(DY,$APP.fU)],null)],null))))),jU,$APP.M($APP.K,w1b)],null)),$APP.z(qQb,new $APP.f(null,3,[$APP.P,"Gamma takes a path function (from time to coordinates) to a state\n  function (from time to local tuple).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[vU,$APP.uU],null))),jU,$APP.M($APP.K,jsb)],null)),$APP.z(LK,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))),$APP.P,"Given a sequence of `selectors`, return a function that accepts some object `x`\n  and returns:\n\n  ```clojure\n  (apply ref x selectors)\n  ```\n  ",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,
[$APP.M(QT)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(AK,new $APP.f(null,3,[$APP.P,"generic magnitude",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,yQb)],null)),$APP.z(x7b,new $APP.f(null,1,[jU,$APP.M($APP.K,z5b)],null)),$APP.z(bxb,new $APP.f(null,3,[$APP.P,"A convenience function on local tuples. A local tuple describes\n  the state of a system at a particular time:\n\n  ```\n  [t, q, D q, D^2 q]\n  ```\n\n  representing time, position, velocity (and optionally acceleration etc.)\n\n  [[coordinate]] returns the `q` element, which is expected to be a mapping from\n  time to a structure of coordinates.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),1)],null)],null))))),jU,$APP.M($APP.K,mBb)],null)),$APP.z(UV,new $APP.f(null,3,[$APP.P,"Returns function signature for a Hamiltonian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Hamiltonian literal functions.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.uU],null)))),jU,$APP.M($APP.K,g9b)],null)),$APP.z($APP.sw,new $APP.f(null,3,[$APP.P,"Comparator. Clone of [[cljs.core/compare]] that works with the expanded\n      Emmy numeric tower.\n\n  Returns a negative number, zero, or a positive number when x is logically\n  'less than', 'equal to', or 'greater than' y. Uses IComparable if available\n  and google.array.defaultCompare for objects of the same type and special-cases\n  nil to be less than any other object.",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null)))),jU,$APP.M($APP.K,lnb)],null)),$APP.z($APP.aw,new $APP.f(null,3,[$APP.P,"generic infinite?.\n\nReturns true if `a` is either numerically infinite (i.e., equal to `##Inf`) or\n  a compound number (complex or quaterion, for example) with some infinite\n  component.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,g3b)],null)),$APP.z(Hgb,new $APP.f(null,1,[jU,$APP.M($APP.K,
EMb)],null)),$APP.z(iDb,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-oneform-field` instances.\n\n  The one-form field at each structural spot takes a vector field and returns a\n  function that takes the directional derivative in that coordinate's direction\n  using the vector field.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-oneform-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,vT)],null)),$APP.z(zgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EU],null)))),jU,$APP.M($APP.K,uVb)],null)),$APP.z(Fsb,new $APP.f(null,3,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 1.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,
1,5,$APP.I,[$APP.M(DY,$APP.fU)],null)],null))))),jU,$APP.M($APP.K,Ceb)],null)),$APP.z(Eob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[fGb],null)))),jU,$APP.M($APP.K,llb)],null)),$APP.z(wlb,new $APP.f(null,3,[$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,eeb)],null)),$APP.z(gjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[chb,TU],null)))),jU,$APP.M($APP.K,s9b)],null)),$APP.z(MM,new $APP.f(null,3,[$APP.P,"generic cot.\n\nComputes the trigonometric cotangent function of the supplied argument `a`.\n\nEquivalent to `(invert (tan a))`, or `(/ (cos a) (sin a))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,eEb)],null)),$APP.z(Pzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),
jU,$APP.M($APP.K,rgb)],null)),$APP.z(GT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,Mdc)],null)),$APP.z(Nsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[pT,gS],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(bY,gS),$APP.M($APP.Zv,$APP.M($APP.qv,gS),4)],null)],null))))),jU,$APP.M($APP.K,Bbc)],null)),$APP.z($APP.Ev,new $APP.f(null,3,[$APP.P,'Generic implementation of `*`. Returns the product of all supplied\n  arguments. `(*)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core/*`. Dispatch is open,\n  however, making it possible to \'multiply\' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (* 2 #emmy/complex "3 + 1i")\n  ;;\x3d\x3e #emmy/complex "6 + 2i"\n  ```',
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))),jU,$APP.M($APP.K,lqb)],null)),$APP.z(cV,new $APP.f(null,3,[$APP.P,"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ex],null)))),jU,$APP.M($APP.K,Eec)],null)),$APP.z(USb,new $APP.f(null,
1,[jU,$APP.M($APP.K,Okb)],null)),$APP.z($nb,new $APP.f(null,3,[$APP.P,"generic asec.\n\nComputes the [inverse\n secant](https://mathworld.wolfram.com/InverseSecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(sqrt(x^2 - 1))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,mbb)],null)),$APP.z(kFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[YW],null)],null)))),
jU,$APP.M($APP.K,Tpb)],null)),$APP.z(vDb,new $APP.f(null,3,[$APP.P,"generic solve-linear-right.\n\nFor a given `a` and `b`, returns `x` such that `a \x3d x*b`.\n\n  See[[solve-linear]] for a similar function that solves for `a*x \x3d b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,Kdb)],null)),$APP.z(ilb,new $APP.f(null,3,[$APP.P,"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,OCb)],null)),$APP.z(cwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(wS,$APP.qU)],null)],null))))),jU,$APP.M($APP.K,qOb)],null)),$APP.z(FAb,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a unique, symbolically-represented\n  point on the manifold associated with `coordinate-system`.\n\n  See [[typical-coords]] for a coordinate-based version of this function.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,Djb)],null)),$APP.z(w3b,new $APP.f(null,1,[jU,$APP.M($APP.K,$_b)],null)),$APP.z(txb,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector  radians about the z axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),jU,$APP.M($APP.K,jbc)],null)),$APP.z(Ihb,new $APP.f(null,3,[$APP.P,"generic acsch.\n\nComputes the [inverse hyperbolic\n cosecant](https://mathworld.wolfram.com/InverseHyperbolicCosecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1+x^2)) / x)`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,kib)],null)),$APP.z(Vtb,new $APP.f(null,3,[$APP.P,"generic log2.\n\nReturns the base-2 logarithm of `x`, i.e., $log_2(x)$.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,w5b)],null)),$APP.z(twb,new $APP.f(null,1,[jU,$APP.M($APP.K,DZb)],null)),$APP.z(Gyb,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,Tqb)],null)),$APP.z(tYb,new $APP.f(null,3,[$APP.P,"Takes a coordinate representation `coords` of a manifold point with all\n  symbolic entries, and returns a structure of the same shape with `v:`\n  prepended to all symbols.\n\n  This structure is appropriate for representing the velocities associated with\n  each coordinate.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.nW],null)))),jU,$APP.M($APP.K,ifb)],null)),$APP.z(kjb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(S5b,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `x` is a `BigInt`, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,nXb)],null)),$APP.z($APP.zv,new $APP.f(null,3,[$APP.P,"generic zero?.\n\nIs true if `x` is an additive identity.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),
jU,$APP.M($APP.K,x3b)],null)),$APP.z(WTb,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))),jU,$APP.M($APP.K,V1b)],null)),$APP.z(Xrb,new $APP.f(null,3,[$APP.P,"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,XMb)],null)),$APP.z(qDb,new $APP.f(null,3,[$APP.P,"Returns the momentum element of a local Hamiltonian state tuple (by convention,\n  the third element).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[WU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(bY,WU),$APP.M($APP.Yv,$APP.M($APP.qv,WU),2)],null)],null))))),jU,$APP.M($APP.K,NOb)],null)),
$APP.z(hK,new $APP.f(null,3,[$APP.P,"generic atan.\n\nComputes the inverse tangent of the supplied argument `a`. Given two\n  arguments `a` and `b`, returns the inverse tangent of the angle formed by the\n  point `(b, a)` in a 2-dimensional euclidean plane.\n\n  The two-argument version is sometimes\n  called [Atan2](https://en.wikipedia.org/wiki/Atan2).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,
$fb)],null)),$APP.z(ABb,new $APP.f(null,3,[$APP.P,"Generates a `nrows` x `ncols` matrix of symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  If `ncols` (the third argument) is not supplied, returns a square matrix of\n  size `nrows` x `nrows`.\n\n  NOTE: The symbols in the returned matrix record their Einstein-notation path\n  into the structure that this matrix represents; a `down` of `up` columns. This\n  means that the returned indices embedded in the symbols look flipped, `ji` vs\n  `ij`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-matrix 'x 2 2)\n     (by-rows ['x_00 'x_10]\n              ['x_01 'x_11]))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,JV],null),new $APP.H(null,3,5,$APP.I,[$APP.Vx,JV,gX],null))),jU,$APP.M($APP.K,pyb)],null)),$APP.z(Mbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(VW,NV)],null)],null))))),jU,$APP.M($APP.K,bec)],null)),$APP.z(Lqb,new $APP.f(null,3,[$APP.P,"p. 334 (used, but not defined there)",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.uU],null)))),jU,$APP.M($APP.K,sob)],null)),$APP.z(Lbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null)))),jU,$APP.M($APP.K,G9b)],null)),$APP.z(iTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,TU],null)))),jU,$APP.M($APP.K,eec)],null)),$APP.z(PV,new $APP.f(null,3,[$APP.P,"generic make-rectangular",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,
$APP.qU],null)))),jU,$APP.M($APP.K,ZMb)],null)),$APP.z(aob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null)))),jU,$APP.M($APP.K,Vcb)],null)),$APP.z(SKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[lxb,mxb],null)))),jU,$APP.M($APP.K,Vjb)],null)),$APP.z(mRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),jU,$APP.M($APP.K,mcb)],null)),$APP.z(grb,
new $APP.f(null,3,[$APP.P,"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null))),jU,$APP.M($APP.K,wcb)],null)),$APP.z(OJb,new $APP.f(null,1,[jU,$APP.M($APP.K,n7b)],null)),$APP.z(kub,new $APP.f(null,3,[$APP.P,"[[curl]] implements equation (10.7) of Functional Differential Geometry,\n  defined on page 155.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,CV],null)))),jU,$APP.M($APP.K,P5b)],null)),$APP.z(kXb,new $APP.f(null,3,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold family, false\n  otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null)))),jU,$APP.M($APP.K,Dxb)],null)),$APP.z(NM,new $APP.f(null,3,[$APP.P,"generic csc.\n\nComputes the cosecant of the supplied argument `a`.\n\nEquivalent to `(invert (sin a))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,aGb)],null)),$APP.z(Esb,new $APP.f(null,1,[jU,$APP.M($APP.K,yhb)],null)),$APP.z(b3b,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a structure that matches\n  the [[coordinate-prototype]] of `coordinate-system`, with all unique,\n  gensym-ed entries.\n\n  Use [[typical-coords]] if you require a unique symbolic coordinate\n  representation compatible with `coordinate-system`.\n\n  See [[typical-point]] for a coordinate-free version of this function.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,fNb)],null)),$APP.z(DV,new $APP.f(null,3,[$APP.P,"generic lcm.\n\nReturns the [least common\n  multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of the two\n  inputs `a` and `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,sbc)],null)),$APP.z(dY,new $APP.f(null,3,[$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null))),jU,$APP.M($APP.K,uG)],null)),$APP.z(Hpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))),jU,$APP.M($APP.K,oib)],null)),$APP.z(pCb,new $APP.f(null,3,[$APP.P,"Convert the given expression to TeX format, as a string.\n\n  If you set the `:equation` keyword argument to a truthy value, the result will\n  be wrapped in an equation environment. `:equation \x3cstring\x3e` will insert a\n  `\\label{\x3cstring\x3e}` entry inside the equation environment.\n\n  For example:\n\n  ```clojure\n  (let [expr (+ 'x 'xy)]\n    (println\n      (-\x3eTeX expr :equation \"label!\")))\n\n  \\begin{equation}\n  \\label{label!}\n  x + y\n  \\end{equation}\n  ```\n  ",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[dV],null)],null)],null))),jU,$APP.M($APP.K,Rdb)],null)),$APP.z(oAb,new $APP.f(null,1,[jU,$APP.M($APP.K,Iob)],null)),$APP.z(SPb,new $APP.f(null,3,[$APP.P,"The supplied manifold `m` locally resembles some vector space; this function\n  returns the field over which that vector space was specified.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ZR],null)))),
jU,$APP.M($APP.K,kdc)],null)),$APP.z(yWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null)))),jU,$APP.M($APP.K,Eub)],null)),$APP.z(P2b,new $APP.f(null,3,[$APP.P,"Given a state tuple (of finite length), reconstitutes the initial segment of\n  the Taylor series corresponding to the state tuple data as a function of t.\n\n  Time is measured beginning at the point of time specified in the input state\n  tuple.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[Brb],null)))),jU,$APP.M($APP.K,ODb)],null)),$APP.z(aib,new $APP.f(null,3,[$APP.P,"generic acsc.\n\nComputes the [inverse\n cosecant](https://mathworld.wolfram.com/InverseCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(1 / sqrt(x^2 - 1))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,JCb)],null)),$APP.z(U9b,new $APP.f(null,3,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses forward-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))),jU,$APP.M($APP.K,TRb)],null)),$APP.z(ACb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,RX],null)))),jU,$APP.M($APP.K,gvb)],null)),$APP.z(kK,new $APP.f(null,3,[$APP.P,"generic acos.\n\nComputes the inverse cosine of the supplied argument `a`.\n\nDefaults to `atan(sqrt(1-x^2)/x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,
jDb)],null)),$APP.z(s0b,new $APP.f(null,1,[jU,$APP.M($APP.K,vZb)],null)),$APP.z(Odc,new $APP.f(null,3,[$APP.P,"Accepts a single symbolic expression and returns a factored version of that\n  expression.\n\n  Differs from [[factor-expression]] in that it can handle any expression, not\n  just expressions limited to polynomial operations.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null)))),jU,$APP.M($APP.K,xUb)],null)),$APP.z(XS,new $APP.f(null,3,[$APP.P,"generic acot.\n\nComputes the [inverse\n cotangent](https://mathworld.wolfram.com/InverseCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `pi/2 - atan(x)`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,oDb)],null)),$APP.z(bT,new $APP.f(null,3,[$APP.P,"generic floor.\n\nReturns the largest integer less than or equal to `a`.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,
Nhb)],null)),$APP.z(ZKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null)))),jU,$APP.M($APP.K,UKb)],null)),$APP.z(yTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))),jU,$APP.M($APP.K,Gwb)],null)),$APP.z(Skb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[TU,hW,oW],null)))),jU,$APP.M($APP.K,YAb)],null)),$APP.z(Wib,new $APP.f(null,1,[jU,$APP.M($APP.K,zIb)],
null)),$APP.z(Ejb,new $APP.f(null,1,[jU,$APP.M($APP.K,mOb)],null)),$APP.z(hV,new $APP.f(null,3,[$APP.P,"generic imag-part",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Q1b)],null)),$APP.z(Wwb,new $APP.f(null,1,[jU,$APP.M($APP.K,Hob)],null)),$APP.z(VHb,new $APP.f(null,3,[$APP.P,"Returns a row matrix with the contents of the supplied `down` structure.\n  Errors if any other type is provided.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(ePb,$APP.Tv)],null)],null))))),jU,$APP.M($APP.K,hdb)],null)),$APP.z(XJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[IP,TU],null)))),jU,$APP.M($APP.K,F1b)],null)),$APP.z(Pob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null)))),jU,$APP.M($APP.K,Vdc)],null)),$APP.z(NMb,new $APP.f(null,1,[jU,$APP.M($APP.K,a$b)],null)),$APP.z(GHb,
new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))),jU,$APP.M($APP.K,l$b)],null)),$APP.z(ERb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[oac,nac,tac,TU,hW],null)))),jU,$APP.M($APP.K,GZb)],null)),$APP.z(lGb,new $APP.f(null,3,[$APP.P,"Returns the single row from the supplied row matrix as a vector. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(BV,$APP.Or)],null)],null))))),jU,$APP.M($APP.K,Fbb)],null)),$APP.z(xzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,cHb)],null)),$APP.z(dU,new $APP.f(null,3,[$APP.P,"Takes a function `f` and a sequence of `factors`, and returns a new function\n  that multiplies each factor by the corresponding argument of `f`. Too many or\n  two few factors are ignored.\n\n  ```clojure\n  ((arg-scale square 3) 4) \x3d\x3d\x3e 144\n  ((arg-scale square 3 2 1) 4) \x3d\x3d\x3e 144\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,mV],null))),jU,$APP.M($APP.K,hJb)],null)),$APP.z(hEb,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a new function that\n  calculates the [Gradient](https://en.wikipedia.org/wiki/Gradient) of `f`.\n\n  The related [[emmy.env/D]] operator returns a function that produces a\n  structure of the opposite orientation as [[Grad]]. Both of these functions use\n  reverse-mode automatic differentiation.",jU,
$APP.M($APP.K,Edc)],null)),$APP.z(VNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SX,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null)))),jU,$APP.M($APP.K,oeb)],null)),$APP.z(azb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null))),jU,$APP.M($APP.K,iHb)],null)),$APP.z(I$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[zU],null)))),jU,$APP.M($APP.K,Zcc)],null)),$APP.z(Nkb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[TU,uW],null)))),jU,$APP.M($APP.K,m8b)],null)),$APP.z(tKb,new $APP.f(null,3,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses reverse-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,QT],null))),jU,$APP.M($APP.K,Wsb)],null)),$APP.z(IZb,new $APP.f(null,3,[$APP.P,"Returns the symbolic name of the suppplied frame.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))),jU,$APP.M($APP.K,$Ob)],null)),$APP.z(xfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))),jU,$APP.M($APP.K,Rub)],null)),$APP.z(LUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[IP],null)))),jU,$APP.M($APP.K,m3b)],null)),$APP.z(zib,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.HY],null)],null)],null))),$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in an\n  `equation` environment.\n\n  Optionally supply a `:label` keyword argument to set a custom label.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,
1,5,$APP.I,[$APP.M($APP.Tw,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.HY],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.HY],null)],null)],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(aR,new $APP.f(null,3,[$APP.P,"generic Lie-derivative",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Ytb)],null)),$APP.z(DJb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pV],null)))),jU,$APP.M($APP.K,yKb)],null)),$APP.z(K_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[tec,i2b],null)))),jU,$APP.M($APP.K,Qcc)],null)),$APP.z(DTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null)))),jU,$APP.M($APP.K,osb)],null)),$APP.z(tQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[kT],
null)))),jU,$APP.M($APP.K,CGb)],null)),$APP.z(Ygb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null)))),jU,$APP.M($APP.K,Pcb)],null)),$APP.z(P4a,new $APP.f(null,3,[$APP.P,"Returns the alternation of the supplied differential `form`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null)))),jU,$APP.M($APP.K,l8b)],null)),$APP.z(M$b,new $APP.f(null,1,[jU,$APP.M($APP.K,aLb)],null)),$APP.z(S_b,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ieb],null)))),jU,$APP.M($APP.K,lTb)],null)),$APP.z(Zwb,new $APP.f(null,1,[jU,$APP.M($APP.K,hpb)],null)),$APP.z(pXb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(G2b,new $APP.f(null,1,[jU,$APP.M($APP.K,Nfb)],null)),$APP.z($APP.Gv,new $APP.f(null,3,[$APP.P,"Generic implementation of `-`.\n\n  If one argument is supplied, returns the negation of `a`. Else returns the\n  difference of the first argument `a` and the sum of all remaining\n  arguments. `(-)` returns 0.\n\n  When applied between numbers, acts like `clojure.core/-`. Dispatch is open,\n  however, making it possible to 'subtract' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (- [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up -1 -1 -1)\n\n  (- [1 10])\n  ;;\x3d\x3e (up -1 -10)\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))),jU,$APP.M($APP.K,jqb)],null)),$APP.z(fjb,new $APP.f(null,3,[$APP.P,"Given `ys` (a sequence of function values) and `xs` (an equal-length sequence\n  of function inputs), returns a [[emmy.polynomial/Polynomial]] instance\n  guaranteed to pass through all supplied `xs` and `ys`.\n\n  The contract for inputs is that `(map vector xs ys)` should return a sequence\n  of pairs of points.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qUb,$APP.fx],null)))),jU,$APP.M($APP.K,ofb)],null)),$APP.z(m6a,new $APP.f(null,3,[$APP.P,"To make a one-form field into a vector field, i.e., a (0,1) tensor into a (1,0)\n  tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))),jU,$APP.M($APP.K,s8b)],null)),$APP.z(Ptb,new $APP.f(null,2,[$APP.P,"Alias for [[F-\x3eCH]].",jU,$APP.M($APP.K,H$b)],null)),$APP.z(mYb,new $APP.f(null,3,[$APP.P,"Takes a unit 3-vector `direction` (representing a direction) and a velocity\n  `v:c` normalized by `C`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xFb,NY],null)))),jU,$APP.M($APP.K,dac)],null)),$APP.z(wgb,new $APP.f(null,3,[$APP.P,"Returns the standard basis object for `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,Bgb)],null)),$APP.z(jMb,new $APP.f(null,3,[$APP.P,"Compute the rotation matrix from a 3-vector of Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[SX,WR,WT],null)],null)))),jU,$APP.M($APP.K,XRb)],null)),$APP.z(X1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[rY,pX,sW],null)))),jU,$APP.M($APP.K,OEb)],null)),$APP.z(Vwb,new $APP.f(null,1,[jU,$APP.M($APP.K,Gob)],null)),$APP.z(i_b,new $APP.f(null,1,[jU,$APP.M($APP.K,vkb)],null)),$APP.z(R5b,new $APP.f(null,3,[$APP.P,"Returns true if `x` implements [[ICoordinateSystem]], false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,dUb)],null)),$APP.z(pnb,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null))),jU,$APP.M($APP.K,xQb)],null)),$APP.z(yyb,new $APP.f(null,3,[$APP.P,"Returns its argument, wrapped in a marker type that responds to the generic\n  operations registered in [[emmy.numsymb]].\n\n  Symbols are automatically treated as [[literal-number]] instances, so\n\n  ```clojure\n  (* 10 (literal-number 'x))\n  ```\n\n  is equivalent to\n\n  ```clojure\n  (* 10 'x)\n  ```\n\n  If you pass an actual number, emmy will attempt to preserve exact values\n  through various operations:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 4))))\n  ;;\x3d\x3e (+ 1 (cos 8))\n  ```\n\n  Notice that the `(g/* 2 ...)` is evaluated, but `cos` evaluation is deferred,\n  since the result is inexact. On the other hand, if the number is inexact to\n  begin with:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 2.2))))\n  ;;\x3d\x3e 0.6926671300215806\n  ```\n\n  the system will go ahead and evaluate it.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,Obc)],null)),$APP.z(dKb,new $APP.f(null,1,[jU,$APP.M($APP.K,Rcc)],null)),$APP.z(oWb,new $APP.f(null,1,[jU,$APP.M($APP.K,adc)],null)),$APP.z(F4b,new $APP.f(null,3,[$APP.P,"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null)))),jU,$APP.M($APP.K,wib)],null)),$APP.z($APP.mNb,new $APP.f(null,3,[$APP.P,"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null))),jU,$APP.M($APP.K,kpb)],null)),
$APP.z(C3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))),jU,$APP.M($APP.K,Rrb)],null)),$APP.z(FX,new $APP.f(null,3,[$APP.P,"Takes a function `f` and a sequence of `shifts`, and returns a new function\n  that adds each shift to the corresponding argument of `f`. Too many or two few\n  shifts are ignored.\n\n  ```clojure\n  ((arg-shift square 3) 4) \x3d\x3d\x3e 49\n  ((arg-shift square 3 2 1) 4) \x3d\x3d\x3e 49\n  ```",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,yY],null))),jU,$APP.M($APP.K,Yab)],null)),$APP.z($APP.Rw,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))),$APP.P,"A shim. Dispatches to [[d/partial]] when all the arguments are integers; falls\n  back to [[clojure.core/partial]] (partial function application) otherwise.",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(QT)],null),$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,QT],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(rX,new $APP.f(null,3,[$APP.P,"generic inner-product",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null)))),jU,$APP.M($APP.K,cNb)],null)),$APP.z(oV,new $APP.f(null,3,[$APP.P,"generic acosh.\n\nComputes the [inverse hyperbolic\n cosine](https://mathworld.wolfram.com/InverseHyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `2 ln(sqrt((x+1)/2) + sqrt((x-1)/2))`.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,v1b)],null)),$APP.z(jY,new $APP.f(null,3,[$APP.P,"generic ceiling.\n\nReturns the result of rounding `a` up to the next largest integer.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),
jU,$APP.M($APP.K,XGb)],null)),$APP.z(O$b,new $APP.f(null,3,[$APP.P,"generic sinc.\n\nThe unnormalized [sinc\n  function](https://en.wikipedia.org/wiki/Sinc_function), equivalent to\n  $\\frac{\\sin x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/SincFunction.html)\n   - [Boost notes on [[sinc]]\n     and [[sinch]]](https://www.boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sinc/sinc_overview.html)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,wJb)],null)),$APP.z(BVb,new $APP.f(null,1,[jU,$APP.M($APP.K,KFb)],null)),gkb,$APP.z(gwb,new $APP.f(null,3,[$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null))),jU,$APP.M($APP.K,ZDb)],
null)),$APP.z(kSb,new $APP.f(null,3,[$APP.P,"Takes a function `f: R \x3d\x3e R` (function of a single real variable), and returns\n  a new function of `x` that approximates the derivative $Df(x)$ (or $D^2f(x)$\n  if you pass `:method :central-d2`).\n\n  Returns the estimated value of the derivative at `x`. If you pass `:info?\n  true`, the fn returns a dictionary of the results of `us/seq-limit`:\n\n  ```clojure\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3cderivative estimate\x3e}\n  ```\n\n  Make sure to visit [[emmy.calculus.derivative/D]] if you want symbolic or\n  automatic differentiation.\n\n  ### Roundoff Estimate\n\n  The returned function will attempt to estimate how many times it can halve the\n  step size used to estimate the derivative before roundoff error swamps the\n  calculation, and force the function to return (with `:converged? false`, if\n  you pass `:info?`)\n\n  ### Optional Arguments\n\n  `D-numeric` takes optional args as its second param. Any of these can be\n  overridden by passing a second argument to the function returned by\n  `D-numeric`; helpful for setting defaults and then overriding them later.\n\n  The returned function passes through these and any other options to\n  `us/seq-limit`, where they control the sequence of richardson\n  extrapolation-accelerated estimates.\n\n  Options:\n\n  - `:method`: one of `:central`, `:central-d2`, `:forward` or `:backward`.\n  `:central-d2` forces a second derivative estimate; the other methods configure\n  a first derivative estimator.\n\n  - `:info?` if false (default), returns the estimated value of `x`. If true,\n  returns a dictionary with more information (see `D-numeric`'s docstring for\n  more info.)\n\n  - `:initial-h`: the initial `h` to use for derivative estimates before $h \to\n  0$. Defaults to `0.1 * abs(x)`.\n\n  - `:tolerance`: see `us/stream-limit` for a discussion of how this value\n  handles relative vs absolute tolerance. $\\sqrt(\\epsilon)$ by default, where\n  $\\epsilon$ \x3d machine tolerance.\n\n  - `:maxterms`: the maximum number of terms to consider when hunting for a\n  derivative estimate. This defaults to an estimate generated internally,\n  designed to prevent roundoff error from swamping the result. If you want to\n  disable this feature, set `:maxterms` to something moderately large, like\n  `:maxterms 100`. But do so carefully! See the surrounding namespace for a\n  larger discussion.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null))),jU,$APP.M($APP.K,Ovb)],null)),$APP.z(k_b,new $APP.f(null,3,[$APP.P,"Returns a function which will pull a form back across a map (without needing\n  its inverse)",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null)))),jU,$APP.M($APP.K,jPb)],null)),$APP.z(f1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,
hW],null)))),jU,$APP.M($APP.K,r9b)],null)),$APP.z(bVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gS],null)))),jU,$APP.M($APP.K,dBb)],null)),$APP.z(ulb,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of  radians about the z axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),jU,$APP.M($APP.K,MYb)],null)),$APP.z(E0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Or],null)))),jU,$APP.M($APP.K,Vub)],null)),$APP.z(VEb,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from a point on the\n  coordinate system's manifold to the coordinate representation specified by the\n  supplied `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,g$b)],null)),$APP.z($vb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(xxb,new $APP.f(null,2,[$APP.P,"Alias for [[-\x3eL-state]].",
jU,$APP.M($APP.K,qdc)],null)),$APP.z(Anb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,oW],null)))),jU,$APP.M($APP.K,Ttb)],null)),$APP.z(ntb,new $APP.f(null,3,[$APP.P,"velocities must be in meters/second, since we don't yet have units support.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null)))),jU,$APP.M($APP.K,j3b)],null)),$APP.z(nY,new $APP.f(null,3,[$APP.P,"generic conjugate",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Orb)],null)),$APP.z(Rdc,new $APP.f(null,3,[$APP.P,"Flat coordinate systems here only.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,oW],null)))),jU,$APP.M($APP.K,UIb)],null)),$APP.z(Y_b,new $APP.f(null,3,[$APP.P,"generic sinhc.\n\nThe [sinhc function](https://en.wikipedia.org/wiki/Sinhc_function),\n  equivalent to $\\frac{\\sinh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinhc_function)\n   - [Mathworld page on Sinhc](https://mathworld.wolfram.com/SinhcFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Ozb)],null)),$APP.z(wP,new $APP.f(null,3,[$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null))),jU,$APP.M($APP.K,MP)],null)),$APP.z(N5b,new $APP.f(null,3,[$APP.P,"f is a function of (x y continue fail), which calls continue with the values of\n  x' y' that follow x y in the mapping.\n\n  Returns a map of the same shape that iterates the iterated map n times before\n  invoking the continuation, or invokes the fail continuation if the inner map\n  fails.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Gu,$APP.M($APP.jv,$APP.uU))],null)],null))))),jU,$APP.M($APP.K,Arb)],null)),$APP.z(pFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Pv],null)))),jU,$APP.M($APP.K,Acc)],null)),$APP.z(FJ,new $APP.f(null,3,[$APP.P,"generic sqrt",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,A8b)],null)),$APP.z(MNb,new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and an [[ICoordinateSystem]], returns a literal\n  function that maps coordinate-free manifold points to a scalar output.\n\n  Also aliased as [[literal-manifold-function]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,oW],null)))),jU,$APP.M($APP.K,zKb)],null)),$APP.z(yac,new $APP.f(null,3,[$APP.P,"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.fx],null)))),jU,$APP.M($APP.K,l2b)],null)),$APP.z(Zvb,new $APP.f(null,1,[jU,$APP.M($APP.K,rhb)],null)),$APP.z(k1b,new $APP.f(null,2,[$APP.P,"Alias for [[Hamiltonian-\x3estate-derivative]], for compatibility with\n  1st edition of SICM.",jU,$APP.M($APP.K,Crb)],null)),$APP.z(ZT,new $APP.f(null,3,[$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,wBb)],null)),$APP.z(Y3b,new $APP.f(null,3,[$APP.P,"generic asech.\n\nComputes the [inverse hyperbolic\n secant](https://mathworld.wolfram.com/InverseHyperbolicSecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1-x^2)) / x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,zwb)],null)),$APP.z(Lnb,new $APP.f(null,3,[$APP.P,
"For making a (2,0) tensor into a (0,2) tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null)))),jU,$APP.M($APP.K,m2b)],null)),$APP.z(jK,new $APP.f(null,3,[$APP.P,"generic asin.\n\nComputes the inverse sine of the supplied argument `a`.\n\nDefaults to `atan(x/sqrt(1-x^2))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Xcb)],null)),$APP.z(VW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null)))),jU,$APP.M($APP.K,OAb)],null)),$APP.z(L3b,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of  radians about the x axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),jU,$APP.M($APP.K,Y2b)],null)),$APP.z(JWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[udb,TU],null)))),jU,$APP.M($APP.K,A0b)],null)),$APP.z($APP.VX,new $APP.f(null,3,[$APP.P,"generic transpose",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Vvb)],null)),$APP.z(Swb,new $APP.f(null,1,[jU,$APP.M($APP.K,Kob)],null)),$APP.z(jib,new $APP.f(null,2,[$APP.P,"Alias for [[differential-of-map]].",jU,$APP.M($APP.K,AHb)],null)),$APP.z(nbb,new $APP.f(null,3,[$APP.P,"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,3,[$APP.zu,new $APP.H(null,3,5,$APP.I,[bS,VT,cY],null),$APP.Kl,new $APP.f(null,3,[bS,RT,VT,!1,cY,!1],null),$APP.ck,$APP.Lx],null)],null))),jU,$APP.M($APP.K,Scc)],null)),$APP.z(Dvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in double\n  `$$` to mark the string as a block LaTeX form."],
null)),$APP.z(w5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null)))),jU,$APP.M($APP.K,dLb)],null)),$APP.z(OKb,new $APP.f(null,3,[$APP.P,"Returns a form field that returns, for any supplied vector field `vf`, a\n  manifold function [[manifold/zero-manifold-function]] that maps every input\n  manifold `point` to the scalar value 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))),jU,$APP.M($APP.K,INb)],null)),
$APP.z(zJ,new $APP.f(null,3,[$APP.P,"generic exp.\n\nReturns the base-e exponential of `x`. Equivalent to `(expt e x)`, given\n  some properly-defined `e` symbol.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Twb)],null)),$APP.z(lEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UU],null)))),jU,$APP.M($APP.K,isb)],null)),$APP.z(aNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[SR],null)))),jU,$APP.M($APP.K,EXb)],null)),$APP.z(yX,new $APP.f(null,3,[$APP.P,"generic negative?.\n\nReturns true if the argument `a` is less than `(g/zero-like a)`,\n  false otherwise. The default implementation depends on a proper Comparable\n  implementation on the type.`",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,tSb)],null)),$APP.z(lRb,new $APP.f(null,3,[$APP.P,"Reverse-mode derivative operator. Takes some function `f` and returns a\n  function whose value at some point can multiply an increment in the arguments\n  to produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D-reverse]] computes a derivative. For vector-valued\n  functions, [[D-reverse]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,a8b)],null)),$APP.z(WV,new $APP.f(null,3,[$APP.P,"generic integer-part.\n\nReturns the integer part of `a` by removing any fractional digits.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Cbb)],null)),$APP.z(rwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null)))),jU,$APP.M($APP.K,eyb)],
null)),$APP.z(Vib,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,LX)],null)),$APP.z(LCb,new $APP.f(null,3,[$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))),jU,$APP.M($APP.K,ymb)],null)),$APP.z(LVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null)))),jU,$APP.M($APP.K,xOb)],null)),
$APP.z(l6a,new $APP.f(null,3,[$APP.P,"To make a vector field into a one-form field, i.e., a (1,0) tensor into a (0,1)\n  tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[hW],null)))),jU,$APP.M($APP.K,Adc)],null)),$APP.z(jNb,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - `c-\x3ee`, a function mapping coordinates to events\n  - `e-\x3ec`, a function mapping events to coordinates\n\n  and returns a function that takes:\n\n  - a symbolic name\n  - an ancestor frame\n  - a dictionary of params\n\n  and returns instance of [[IFrame]].\n\n  Both `c-\x3ee` and `e-\x3ec` must accept three arguments:\n\n  - `ancestor-frame`\n  - the [[IFrame]] instance\n  - a map of parameters supplied to the returned function (possibly empty!).",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qX,ZS],null)))),jU,$APP.M($APP.K,zSb)],null)),$APP.z($APP.KK,new $APP.f(null,3,[$APP.P,"Arity-preserving version of `clojure.core/comp`.\n\n  The arity of a composition is the arity of the rightmost (that is, first to be\n  applied) function term in `fns`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$V],null))),jU,$APP.M($APP.K,y9b)],null)),$APP.z(gKb,new $APP.f(null,3,[$APP.P,"SICM p. 83",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pV],null)))),jU,$APP.M($APP.K,Iwb)],null)),$APP.z(Xtb,new $APP.f(null,2,[$APP.P,"Alias for [[raise]].",jU,$APP.M($APP.K,Eib)],null)),$APP.z(zMb,new $APP.f(null,3,[$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],null))),jU,$APP.M($APP.K,rqb)],null)),
$APP.z(tIb,new $APP.f(null,3,[$APP.P,"Returns the single row from the supplied row matrix as a `down`. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(BV,$APP.Or)],null)],null))))),jU,$APP.M($APP.K,Fzb)],null)),$APP.z(uFb,new $APP.f(null,3,[$APP.P,"Find the minimum of the function `f: R -\x3e R` in the interval `[a, b]`.\n\n  If an `observe` function is supplied, it will be invoked with the iteration\n  count and the values of x and f(x) at each search step.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,bW],null))),jU,$APP.M($APP.K,vNb)],null)),$APP.z(fW,new $APP.f(null,3,[$APP.P,"generic asinh.\n\nComputes the [inverse hyperbolic\n sine](https://mathworld.wolfram.com/InverseHyperbolicSine.html) of the\n supplied argument `a`.\n\ndefaults to `ln(x + sqrt(1 + x^2))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,
QOb)],null)),$APP.z(zYb,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - a `down` tuple of `components` of the one-form field relative to\n    `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a full one-form field.\n\n  A one-field field is an operator that takes a vector field to a real-valued\n  function on the manifold.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null))),jU,$APP.M($APP.K,bUb)],null)),$APP.z(FUb,new $APP.f(null,
2,[$APP.U,null,jU,$APP.M($APP.K,a_b)],null)),$APP.z(orb,new $APP.f(null,3,[$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x0 'x1 'x2))\n  ```",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null)))),jU,$APP.M($APP.K,I6b)],null)),$APP.z(leb,new $APP.f(null,1,[jU,$APP.M($APP.K,Ehb)],null)),$APP.z(Xsb,
new $APP.f(null,1,[jU,$APP.M($APP.K,mtb)],null)),$APP.z(VGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))),jU,$APP.M($APP.K,U2b)],null)),$APP.z(YFb,new $APP.f(null,1,[jU,$APP.M($APP.K,oHb)],null)),$APP.z(Dub,new $APP.f(null,3,[$APP.P,"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[emmy.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to handle [[Dual]]\n  inputs in addition to any types that a normal `(f x)` call would present. This\n  restriction does _not_ apply to operations like putting `x` into a container\n  or destructuring; just primitive function calls.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,Uyb)],null)),$APP.z(epb,new $APP.f(null,2,[$APP.P,"Alias for [[raise]].",jU,$APP.M($APP.K,ojb)],null)),$APP.z(esb,new $APP.f(null,3,[$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.AY,mU,$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,
1,5,$APP.I,[$APP.M(qW,mU)],null)],null))))),jU,$APP.M($APP.K,BUb)],null)),$APP.z(E4b,new $APP.f(null,3,[$APP.P,"Optionally takes a dissipation function.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null))),jU,$APP.M($APP.K,ngb)],null)),$APP.z(T9a,new $APP.f(null,3,[$APP.P,"p. 428, the Lie transform is just the time-advance operator using the Lie\n  derivative (see Hamiltonian.scm).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.BU,$APP.Rv],null)))),jU,$APP.M($APP.K,Qqb)],null)),$APP.z(Bac,new $APP.f(null,3,[$APP.P,"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[aW,MV,$APP.SU,IW,$APP.aX],null)))),jU,
$APP.M($APP.K,YIb)],null)),$APP.z(Knb,new $APP.f(null,2,[$APP.P,"Alias for [[lower]].",jU,$APP.M($APP.K,n2b)],null)),$APP.z(XAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[HU,wU,$APP.jP,$APP.uU],null)))),jU,$APP.M($APP.K,$Ib)],null)),$APP.z(Eac,new $APP.f(null,3,[$APP.P,"Renders an expression through the simplifier and onto the stream.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tw,bU],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,bU,$APP.yu],
null))),jU,$APP.M($APP.K,Owb)],null)),$APP.z(x6b,new $APP.f(null,1,[jU,$APP.M($APP.K,Bmb)],null)),$APP.z($APP.jP,new $APP.f(null,1,[jU,$APP.M($APP.K,Rsb)],null)),$APP.z(ZZb,new $APP.f(null,3,[$APP.P,"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null)))),jU,$APP.M($APP.K,uPb)],null)),$APP.z(NIb,new $APP.f(null,3,[$APP.P,"Accepts a coordinate transformation `F` from a local tuple to a new coordinate\n  structure, and returns a function from `local -\x3e local` that applies the\n  transformation directly.\n\n  [[F-\x3eC]] handles local tuples of arbitrary length.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null)))),jU,$APP.M($APP.K,UJb)],null)),$APP.z(oX,new $APP.f(null,3,[$APP.P,"generic tanh.\n\nComputes the [hyperbolic\n tangent](https://mathworld.wolfram.com/HyperbolicTangent.html) of the supplied\n argument `a`.\n\ndefaults to `sinh(x) / cosh(x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,TKb)],null)),$APP.z(Mcb,new $APP.f(null,3,[$APP.P,"Returns a set of patch names registered in the supplied manifold.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ZR],null)))),jU,$APP.M($APP.K,Sob)],null)),$APP.z(DCb,new $APP.f(null,1,[jU,$APP.M($APP.K,Dwb)],null)),$APP.z(uec,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null)))),jU,$APP.M($APP.K,$$b)],null)),$APP.z(Ojb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[hW,TU,$APP.Or],null)))),jU,$APP.M($APP.K,W9b)],null)),$APP.z(jS,new $APP.f(null,3,[$APP.P,
"generic identity?.\n\nLike `one?`, but this is true of square identity matrices as well.\n  No matrix is considered `one?` because its function as a multiplicative\n  identity depends on the shape of the other multiplicand.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,IDb)],null)),$APP.z($sb,new $APP.f(null,1,[jU,$APP.M($APP.K,ktb)],null)),$APP.z(Bcc,new $APP.f(null,3,[$APP.P,"generic zero-like.\n\nIn general, this procedure returns the additive identity of the type of its\n  argument, if it exists. For numbers this is 0.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,rFb)],null)),$APP.z(Prb,new $APP.f(null,1,[jU,$APP.M($APP.K,nvb)],null)),$APP.z(Znb,new $APP.f(null,1,[jU,$APP.M($APP.K,lrb)],null)),$APP.z(fJb,new $APP.f(null,3,[$APP.P,"Both arities of [[divergence]] are defined on page 156 of Functional Differential Geometry.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[hW,CV],null))),jU,$APP.M($APP.K,rOb)],
null)),$APP.z(w2b,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z($2b,new $APP.f(null,3,[$APP.P,"Returns a set of names of all coordinate system constructors registered in the\n  supplied patch.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Ufb],null)))),jU,$APP.M($APP.K,nRb)],null)),$APP.z(CY,new $APP.f(null,3,[$APP.P,"generic angle",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,Yub)],null)),$APP.z(Dnb,new $APP.f(null,
1,[jU,$APP.M($APP.K,Mpb)],null)),$APP.z(cH,new $APP.f(null,3,[$APP.P,"Derivative operator. Takes some function `f` and returns a function whose value\n  at some point can multiply an increment in the arguments to produce the best\n  linear estimate of the increment in the function value.\n\n  For univariate functions, [[D]] computes a derivative. For vector-valued\n  functions, [[D]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.\n\n  The related [[emmy.env/Grad]] returns a function that produces a structure of\n  the opposite orientation as [[D]]. Both of these functions use reverse-mode\n  automatic differentiation.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,Pwb)],null)),$APP.z(I3b,new $APP.f(null,1,[jU,$APP.M($APP.K,Xab)],null)),$APP.z(N4a,new $APP.f(null,3,[$APP.P,"Computes the wedge product of the sequence `fs` of one-forms.\n\n  Higher rank forms can be constructed from one-forms by wedging them together.\n  This antisymmetric tensor product is computed as a determinant. The purpose of\n  this is to allow us to use the construction dx^dy to compute the area\n  described by the vectors that are given to it.\n\n  See Spivak p275 v1 of 'Differential Geometry' to see the correct definition.\n  The key is that the wedge of the coordinate basis forms had better be the\n  volume element.",
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.lx],null))),jU,$APP.M($APP.K,ohb)],null)),$APP.z(YV,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qu],null)))),jU,$APP.M($APP.K,xbb)],null)),$APP.z(obb,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is\n  a [One-form](https://en.wikipedia.org/wiki/One-form), false\n  otherwise.\n\n  A [One-form](https://en.wikipedia.org/wiki/One-form) takes a single vector\n  field to a real-valued function on the manifold.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),jU,$APP.M($APP.K,gLb)],null)),$APP.z(dxb,new $APP.f(null,1,[jU,$APP.M($APP.K,ipb)],null)),$APP.z(N1b,new $APP.f(null,3,[$APP.P,"Takes some constant `c` and returns a manifold function that maps every input\n  manifold `point` to `c.`",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null)))),jU,$APP.M($APP.K,Lpb)],null)),$APP.z(w8b,new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3evector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,oW],null)))),jU,$APP.M($APP.K,lAb)],null)),$APP.z(cDb,new $APP.f(null,3,[$APP.P,"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[emmy.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, i.e., the Taylor series expansion at `(\x3d x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[emmy.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[emmy.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null))),jU,$APP.M($APP.K,YUb)],null)),$APP.z($R,new $APP.f(null,3,[$APP.P,"generic simplify",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,t6b)],null)),$APP.z(FV,new $APP.f(null,3,[$APP.P,"generic atanh.\n\nComputes the [inverse hyperbolic\n tangent](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) of the\n supplied argument `a`.\n\ndefaults to `1/2 ln((1+x)/(1-x))`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,fec)],null)),$APP.z(D$b,new $APP.f(null,3,[$APP.P,"generic one?.\n\nIs true if `x` is a multiplicative identity.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null)))),jU,$APP.M($APP.K,BJb)],null)),$APP.z(p4b,new $APP.f(null,3,[$APP.P,"Returns the submatrix of the matrix (or matrix-like structure) `s` generated by\n  taking\n\n  - rows    from `lowrow` -\x3e `hirow` (inclusive)\n  - columns from `lowcol` -\x3e `hicol` (inclusive)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Vv,X2b,ULb,Vac,aVb],null)))),jU,$APP.M($APP.K,p3b)],null))],[new $APP.f(null,3,[$APP.R,bqb,$APP.X,M9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UV],null))),jU,qnb],null)],null),new $APP.f(null,3,[$APP.R,DLb,$APP.X,H7a,$APP.h,new $APP.f(null,3,[$APP.P,"Find the minimum of the function f: R^n -\x3e R, given an initial point q  R^n.\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked with iteration count,\n  the values of X and the value of f(X) at each intermediate point of\n  evaluation.\n\n  `:info?` if true, wraps the result with evaluation information.\n\n  `:adaptive?` if true, the Nelder-Mead parameters for contraction, expansion,\n  reflection and shrinking will be set adaptively, as functions of the number of\n  dimensions. If false they stay constant.\n\n  `:alpha` sets the reflection coefficient used for each step of Nelder-Mead.\n\n  `:beta` sets the expansion coefficient used for each step of Nelder-Mead.\n\n  `:gamma` sets the contraction coefficient used for each step of Nelder-Mead.\n\n  `:sigma` sets the shrink coefficient used for each step of Nelder-Mead.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  200*dimension.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 200*dimension.\n\n  `:simplex-tolerance` When the absolute value of the max difference between the\n  best point and any point in the simplex falls below this tolerance, the\n  minimizer stops. Defaults to 1e-4.\n\n  `:fn-tolerance` When the absolute value of the max difference between the best\n  point's function value and the fn value of any point in the simplex falls\n  below this tolerance, the minimizer stops. Defaults to 1e-4.\n\n  `:zero-delta` controls the value to which 0 entries in the initial vector are\n  set during initial simplex generation. Defaults to 0.00025.\n\n  `:nonzero-delta` factor by which entries in the initial vector are perturbed to\n  generate the initial simplex. Defaults to 0.05.\n\n  See Gao, F. and Han, L.\n      Implementing the Nelder-Mead simplex algorithm with adaptive\n      parameters. 2012. Computational Optimization and Applications.\n      51:1, pp. 259-277\n  I gratefully acknowledge the [Python implementation in\n  SciPy](https://github.com/scipy/scipy/blob/589c9afe41774ee96ec121f1867361146add8276/scipy/optimize/optimize.py#L556:5)\n  which I have imitated here.\n  ",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Hy,$APP.NW,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.Dw],null),$APP.ck,$APP.Lx],null)],null))),jU,VUb],null)],null),new $APP.f(null,3,[$APP.R,Yrb,$APP.X,qI,$APP.h,new $APP.f(null,3,[$APP.P,"generic quotient",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,u6b],null)],null),new $APP.f(null,3,[$APP.R,Kkb,$APP.X,$APP.YQ,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.BU],null))),jU,gub],null)],null),new $APP.f(null,3,[$APP.R,phb,$APP.X,X2a,$APP.h,new $APP.f(null,3,[$APP.P,"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null))),jU,XLb],null)],null),new $APP.f(null,3,[$APP.R,$Gb,$APP.X,C5a,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a system derivative `R` and returns a operator that takes a function `F`\n  of coordinatized state and performs the operation described below, from\n  ODE.scm in scmutils:\n\n  Let `(sigma t)` be the state of a system at time `t`. Let the\n  (first-order) system of differential equations governing the evolution of\n  this state be:\n\n  ```clojure\n  ((D sigma) t) \x3d (R (sigma t))\n  ```\n\n  ```clojure\n  (D sigma) \x3d (compose R sigma)\n  ```\n\n  i.e. `R` is a system derivative.\n\n  Let `F` be any function of state, then a differential equation for the\n  evolution of `F`, as it is dragged along the integral curve sigma is:\n\n  ```clojure\n  (D (compose F sigma)) \x3d (* (compose (D F) sigma) (D sigma))\n  \x3d (compose (* (D F) R) sigma)\n  ```\n\n  Let's call this operation `Lie-D` (the Lie derivative for coordinates).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null))),jU,Sjb],null)],null),new $APP.f(null,3,[$APP.R,mec,$APP.X,Q2,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a row matrix populated by the supplied `xs`. Variadic equivalent\n  to [[row*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),jU,r7b],null)],null),new $APP.f(null,3,[$APP.R,wfb,$APP.X,t6a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a data structure representing [Christoffel symbols of the first\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_first_kind).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[DX,TU],null))),jU,Ebb],null)],null),new $APP.f(null,3,[$APP.R,fpb,$APP.X,VP,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a `metric` and a `spec` and returns the [Hodge star\n  operator](https://en.wikipedia.org/wiki/Hodge_star_operator) (actually just a\n  function, but I suspect this should be a proper operator!)\n\n  `spec` may be:\n\n  - a coordinate system with an orthonormal basis\n  - an orthonormal basis\n  - a basis\n\n  if the spec is a basis that needs to be orthonormalized, the optional\n  `:orthonormalize?` keyword argument must be a coordinate system.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[hW,$APP.Aw,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[MT],null),$APP.Kl,new $APP.f(null,1,[MT,!1],null)],null)],null)),jU,Zbb],null)],null),new $APP.f(null,3,[$APP.R,wXb,$APP.X,SQ,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.DU,vU,IW,JW],null),new $APP.H(null,5,5,$APP.I,[$APP.DU,vU,IW,JW,XV],null)),jU,I1b],null)],null),new $APP.f(null,3,[$APP.R,bhb,$APP.X,L2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` implements [[IFrame]], false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,Bxb],null)],null),new $APP.f(null,3,[$APP.R,hKb,$APP.X,XSa,$APP.h,new $APP.f(null,3,[$APP.P,"Alias for [[solve-linear]]; present for compatibility with the original\n  `scmutils` codebase.\n\n  NOTE: In `scmutils`, `solve-linear-left` and `solve-linear` act identically in\n  all cases except matrices. `solve-linear-left` only accepted a column\n  matrix (or up structure) in the `b` position, while `solve-linear` accepted\n  either a column or row (up or down structure).\n\n  In Emmy, both functions accept either type.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,WLb],null)],null),new $APP.f(null,3,[$APP.R,W6b,$APP.X,w4,$APP.h,new $APP.f(null,3,[$APP.P,"SICM p. 23. The optional parameter values is a callback which will report\n  intermediate points of the minimization.",$APP.U,$APP.M(new $APP.H(null,8,5,$APP.I,[$X,HW,AW,IW,BW,$APP.uU,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[bW],null)],null)],null)),jU,pKb],null)],null),new $APP.f(null,3,[$APP.R,DYb,$APP.X,
R2a,$APP.h,new $APP.f(null,3,[$APP.P,"Marks (via metadata) the supplied set of `coords` as being owned by `owner`. If\n  `coords` already has an owner (that is not equal to `owner`), throws.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.nW,q6b],null))),jU,Tfb],null)],null),new $APP.f(null,3,[$APP.R,Q$b,$APP.X,AG,$APP.h,new $APP.f(null,3,[$APP.P,"generic remainder.\n\nReturns the remainder of dividing the dividend `a` by divisor `b`.\n\n The contract satisfied by [[remainder]] is:\n\n```clojure\n(\x3d a (+ (* b (quotient a b))\n        (remainder a b)))\n```\n\n For numbers, this differs from the contract offered by [[modulo]]\n because [[quotient]] rounds toward 0, while `(floor (/ a b))` rounds toward\n negative infinity.\n\n The result will be either `0` or of the same sign as the dividend `a`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,H9b],null)],null),new $APP.f(null,3,[$APP.R,Kvb,$APP.X,jZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic identity-like.\n\nLike `one-like` but works for square matrices.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,s4b],null)],null),new $APP.f(null,3,[$APP.R,nFb,$APP.X,x0,$APP.h,new $APP.f(null,3,[$APP.P,"[Chinese Remainder Algorithm](https://en.wikipedia.org/wiki/Chinese_remainder_theorem).\n\n  Accepts a sequence of [[ModInt]] instances (where the `modulus` of\n  all [[ModInt]] instances are relatively prime), and returns a [[ModInt]] `x`\n  such that `(residue input) \x3d\x3d (mod x (modulus input))`.\n\n  For example:\n\n  ```clojure\n  (let [a1 (m/make 2 5)\n        a2 (m/make 3 13)]\n    [(\x3d 42 (chinese-remainder a1 a2))\n     (\x3d (residue a1) (mod cr (modulus a1)))\n     (\x3d (residue a2) (mod cr (modulus a2)))])\n  ;;\x3d\x3e [true true true]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,mX],null)),jU,Bbb],null)],null),new $APP.f(null,3,[$APP.R,Gac,$APP.X,g1,$APP.h,new $APP.f(null,3,[$APP.P,"Return a [[PowerSeries]] starting with the supplied values. The remainder of\n  the series will be filled with the zero-value corresponding to the first of\n  the given values.\n\n  If you have a sequence already, prefer [[power-series*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ox],null)),jU,J2b],null)],null),new $APP.f(null,3,
[$APP.R,Nxb,$APP.X,mrc,$APP.h,new $APP.f(null,1,[jU,gxb],null)],null),new $APP.f(null,3,[$APP.R,ycc,$APP.X,Jrc,$APP.h,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that\n  calculates the [Divergence](https://en.wikipedia.org/wiki/Divergence) of\n  `f` at its input point.\n\n  The divergence is a one-level contraction of the gradient.",jU,y3b],null)],null),new $APP.f(null,3,[$APP.R,NQb,$APP.X,P4,$APP.h,new $APP.f(null,4,[$APP.P,"[[using-coordinates]] wraps [[let-coordinates]] and allows you to supply a\n  single coordinate prototype and a single coordinate system.\n  See [[let-coordinates]] for details about what symbols are bound inside the\n  body.\n\n  Example:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect\n                     body...)\n  ```",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[nU,oW,$APP.Lh,$APP.Pw],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,mwb,$APP.X,EZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic csch.\n\nComputes the [hyperbolic\n cosecant](https://mathworld.wolfram.com/HyperbolicCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / sinh(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,m9b],null)],null),new $APP.f(null,3,[$APP.R,uBb,$APP.X,g3a,$APP.h,new $APP.f(null,
3,[$APP.P,"Returns a function which rotates a vector  radians about the y axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,ibc],null)],null),new $APP.f(null,3,[$APP.R,skb,$APP.X,grc,$APP.h,new $APP.f(null,1,[jU,rDb],null)],null),new $APP.f(null,3,[$APP.R,H5b,$APP.X,D9a,$APP.h,new $APP.f(null,3,[$APP.P,"SICM p. 47. Polar to rectangular coordinates of state.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EX],null))),jU,o9b],null)],null),new $APP.f(null,3,[$APP.R,
FBb,$APP.X,q3,$APP.h,new $APP.f(null,1,[jU,gpb],null)],null),new $APP.f(null,3,[$APP.R,dZb,$APP.X,l$a,$APP.h,new $APP.f(null,3,[$APP.P,"p. 334",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),jU,GUb],null)],null),new $APP.f(null,3,[$APP.R,K6b,$APP.X,H3,$APP.h,new $APP.f(null,3,[$APP.P,"Alternative definition of [[wedge]] in terms of alternation.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null)),jU,Dmb],null)],null),new $APP.f(null,3,[$APP.R,Qsb,$APP.X,YO,$APP.h,
new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null)),jU,A_b],
null)],null),new $APP.f(null,3,[$APP.R,Xmb,$APP.X,KQ,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[time]].",jU,RDb],null)],null),new $APP.f(null,3,[$APP.R,nmb,$APP.X,Tqc,$APP.h,new $APP.f(null,1,[jU,L0b],null)],null),new $APP.f(null,3,[$APP.R,RTb,$APP.X,OZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic make-polar",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,lcc],null)],null),new $APP.f(null,3,[$APP.R,vLb,$APP.X,cP,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is a form field operator, false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[hWb],null))),jU,Cec],null)],null),new $APP.f(null,3,[$APP.R,k2b,$APP.X,aO,$APP.h,new $APP.f(null,3,[$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.Nx],null))),jU,p6b],null)],null),new $APP.f(null,3,[$APP.R,f3b,$APP.X,TK,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),jU,Osb],null)],null),new $APP.f(null,3,[$APP.R,Aqb,$APP.X,oZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic cube",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,B_b],null)],null),new $APP.f(null,3,[$APP.R,HBb,$APP.X,k3,$APP.h,new $APP.f(null,1,[jU,Zob],null)],null),new $APP.f(null,3,[$APP.R,dgb,$APP.X,uL,$APP.h,new $APP.f(null,3,[$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),jU,LP],null)],null),new $APP.f(null,3,[$APP.R,TFb,$APP.X,K6a,$APP.h,new $APP.f(null,3,[$APP.P,"[[gradient]] implements equation (10.3) in Functional Differential Geometry,\n  defined on page 154.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),jU,Qgb],null)],null),new $APP.f(null,3,[$APP.R,JFb,$APP.X,LZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic tanc.\n\n`tanc` is defined, by analogy with [[sinc]], to be equal to $\\frac{\\tan\n  x}{x}$ for nonzero $x$ and equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/TancFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,GLb],null)],null),new $APP.f(null,3,[$APP.R,AZb,$APP.X,ZQ,$APP.h,new $APP.f(null,3,[$APP.P,"generic determinant",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,krb],null)],null),new $APP.f(null,3,[$APP.R,VMb,$APP.X,mP,$APP.h,new $APP.f(null,3,[$APP.P,"Extract the dual basis from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null)))),jU,Eeb],null)],null),new $APP.f(null,3,[$APP.R,PPb,$APP.X,Z4a,$APP.h,new $APP.f(null,3,[$APP.P,"Make a basis object out of a vector and dual basis.\n\n  The dimensions of `vector-basis` and `dual-basis` must agree.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,rW],null))),jU,bac],null)],null),new $APP.f(null,3,[$APP.R,S1b,$APP.X,vH,$APP.h,new $APP.f(null,3,[$APP.P,"generic sinh.\n\nComputes the [hyperbolic\n sine](https://mathworld.wolfram.com/HyperbolicSine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x - e^{-x}) / 2`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,tJb],null)],null),new $APP.f(null,3,[$APP.R,VFb,$APP.X,j6a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a metric and a basis, computes the inverse metric.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),jU,ffb],null)],null),new $APP.f(null,3,[$APP.R,heb,$APP.X,tQ,$APP.h,new $APP.f(null,3,[$APP.P,"Find the minimum of the function f: R -\x3e R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id\x3dAITCAgAAQBAJ\x26q\x3dBrent%E2%80%99s#v\x3donepage\x26q\x3dParabolic\x26f\x3dfalse).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  [[brent-min]] supports the following optional keyword arguments:\n\n  - `:callback`: if supplied, the supplied fn will be invoked at each\n    intermediate point with the iteration count and the values of x and f(x) at\n    each search step.\n\n  - `:initial-guess`: the first internal point checked by the algorithm. Defaults\n    to `([[initial-brent-guess]] a b)`.\n\n  - `:relative-threshold`: multiplied by each guess to determine a relative\n    threshold. Defaults to 1.0e-11.\n\n  - `:absolute-threshold`: a smaller absolute threshold that applies when the\n    candidate minimum point is close to 0. defaults to around 1.49e8, the sqrt of\n    the machine tolerance. You won't gain any benefit attempting to set the value\n    less than the default.\n\n  - `:maxiter`: Maximum number of iterations allowed for the minimizer. Defaults\n    to 1000.\n\n  - `:maxfun`: Maximum number of times the function can be evaluated before\n    exiting. Defaults to `(inc maxiter)`.\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,6,5,$APP.I,[NT,PT,PY,IT,sX,$APP.Dw],null),$APP.Kl,new $APP.f(null,5,[NT,yV,PT,OY,PY,$APP.M(UT,$APP.Iv,$APP.qU),IT,1E3,$APP.Dw,$APP.M($APP.cw,null)],null)],null)],null)),jU,fkb],null)],null),new $APP.f(null,3,[$APP.R,feb,$APP.X,QF,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[/]].",jU,C_b],null)],null),new $APP.f(null,3,[$APP.R,tyb,
$APP.X,I4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a one-form field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3eoneform-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-form-field`'s component\n  functions will accept a single non-structural argument.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,oW],null))),jU,QPb],null)],null),new $APP.f(null,3,[$APP.R,tBb,$APP.X,f3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector  radians about the x axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,bbc],null)],null),new $APP.f(null,3,[$APP.R,SZb,$APP.X,EP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Dx,TU],null))),jU,Hhb],null)],null),new $APP.f(null,
3,[$APP.R,uZb,$APP.X,kP,$APP.h,new $APP.f(null,3,[$APP.P,"One of the two incompatible definitions of differential.\n\n  This differential is a special case of exterior derivative. The other one\n  lives at [[map/differential]].",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(SHb,$APP.Kv)],null)],null)))),jU,gfb],null)],null),new $APP.f(null,3,[$APP.R,zUb,$APP.X,Vrc,$APP.h,new $APP.f(null,2,[$APP.P,"Converts an S-expression to printable infix form. Numeric exponents are\n  written as superscripts. Partial derivatives get subscripts.",
jU,DHb],null)],null),new $APP.f(null,3,[$APP.R,kec,$APP.X,$4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a basis, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,YWb],null)],null),new $APP.f(null,3,[$APP.R,mib,$APP.X,i2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the single column from the supplied column matrix as a vector. Errors\n  if some other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],
null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(oY,$APP.Or)],null)],null)))),jU,jEb],null)],null),new $APP.f(null,3,[$APP.R,v8b,$APP.X,v6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[hW,TU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,TU)],null)],null)))),jU,Rbc],null)],null),new $APP.f(null,3,[$APP.R,wec,$APP.X,EO,$APP.h,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from coordinates in\n  `coordinate-system`'s repesentation to the matching point on the manifold\n  associated with `coordinate-system`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,j$b],null)],null),new $APP.f(null,3,[$APP.R,PBb,$APP.X,Uqc,$APP.h,new $APP.f(null,1,[jU,Fob],null)],null),new $APP.f(null,3,[$APP.R,$db,$APP.X,N4,$APP.h,new $APP.f(null,3,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,iYb,$APP.X,gO,$APP.h,new $APP.f(null,3,[$APP.P,"generic sin.\n\nReturns the [sine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Cib],null)],null),new $APP.f(null,3,[$APP.R,nzb,$APP.X,Krc,$APP.h,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that\n  calculates the [Curl](https://en.wikipedia.org/wiki/Curl_(mathematics)) of `f`\n  at its input point.\n\n  `f` must be a function from $\\mathbb{R}^3 \\to \\mathbb{R}^3$.",jU,tMb],null)],null),new $APP.f(null,3,[$APP.R,Erb,$APP.X,Lrc,$APP.h,new $APP.f(null,2,[$APP.P,
"Operator that takes a function `f` and returns a function that calculates\n  the [Vector\n  Laplacian](https://en.wikipedia.org/wiki/Laplace_operator#Vector_Laplacian) of\n  `f` at its input point.",jU,Tzb],null)],null),new $APP.f(null,3,[$APP.R,rTb,$APP.X,V2a,$APP.h,new $APP.f(null,3,[$APP.P,"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.fx],null))),jU,Jdc],null)],null),new $APP.f(null,3,[$APP.R,
aBb,$APP.X,lrc,$APP.h,new $APP.f(null,1,[jU,I_b],null)],null),new $APP.f(null,3,[$APP.R,Tsb,$APP.X,Tqc,$APP.h,new $APP.f(null,1,[jU,GAb],null)],null),new $APP.f(null,3,[$APP.R,jAb,$APP.X,iM,$APP.h,new $APP.f(null,3,[$APP.P,"generic exact-divide.\n\nSimilar to the binary case of [[/]], but throws if `(g/exact? \x3cresult\x3e)`\n  returns false.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,v2b],null)],null),new $APP.f(null,3,[$APP.R,tHb,$APP.X,fTa,$APP.h,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),jU,PAb],null)],null),new $APP.f(null,3,[$APP.R,OUb,$APP.X,tZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic tan.\n\nComputes the trigonometric tangent function of the supplied argument `a`.\n\nEquivalent to `(/ (sin a) (cos a))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,aCb],null)],null),new $APP.f(null,3,[$APP.R,Ktb,$APP.X,VF,$APP.h,new $APP.f(null,3,[$APP.P,"generic solve-linear.\n\nFor a given `a` and `b`, returns `x` such that `a*x \x3d b`.\n\n  See[[solve-linear-right]] for a similar function that solves for `a \x3d x*b`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,bcc],null)],null),new $APP.f(null,3,[$APP.R,ekb,$APP.X,aG,$APP.h,new $APP.f(null,3,[$APP.P,"generic freeze.\n\nFreezing an expression means removing wrappers and other metadata from\n  subexpressions, so that the result is basically a pure S-expression with the\n  same structure as the input. Doing this will rob an expression of useful\n  information for further computation; so this is intended to be done just\n  before simplification and printing, to simplify those processes.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,WUb],null)],null),new $APP.f(null,3,[$APP.R,P_b,$APP.X,Fab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null))),jU,F0b],null)],null),new $APP.f(null,3,[$APP.R,Usb,$APP.X,N5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[XT],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(GT,XT)],null)],null)))),jU,LJb],null)],null),
new $APP.f(null,3,[$APP.R,Jdb,$APP.X,a5a,$APP.h,new $APP.f(null,3,[$APP.P,"Extract the dimension from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null)))),jU,fvb],null)],null),new $APP.f(null,3,[$APP.R,lLb,$APP.X,LO,$APP.h,new $APP.f(null,3,[$APP.P,"generic dimension",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,jdb],null)],
null),new $APP.f(null,3,[$APP.R,uUb,$APP.X,K5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),jU,o_b],null)],null),new $APP.f(null,3,[$APP.R,h0b,$APP.X,G6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null))),jU,Qwb],null)],null),new $APP.f(null,3,[$APP.R,bbb,$APP.X,o6a,$APP.h,new $APP.f(null,3,[$APP.P,"For making a (0,2) tensor into a (2,0) tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],
null))),jU,njb],null)],null),new $APP.f(null,3,[$APP.R,ZPb,$APP.X,Q2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the owning [[IFrame]] instance of the supplied coordinates `coords`,\n  nil if there's no owner otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null))),jU,QLb],null)],null),new $APP.f(null,3,[$APP.R,ezb,$APP.X,QN,$APP.h,new $APP.f(null,1,[jU,Rob],null)],null),new $APP.f(null,3,[$APP.R,wnb,$APP.X,brc,$APP.h,new $APP.f(null,1,[jU,Y6b],null)],null),new $APP.f(null,
3,[$APP.R,bLb,$APP.X,Q4,$APP.h,new $APP.f(null,2,[$APP.P,"A shim so that ref can act like nth in SICM contexts, as clojure core ref\n  elsewhere.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.Lh,wW],null))],null)],null),new $APP.f(null,3,[$APP.R,Mob,$APP.X,d5a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the Jacobian of transition from `from-basis` to `to-basis`.\n\n  The Jacobian is a structure of manifold functions. The outer index is the\n  from-basis index, so this structure can be multiplied by tuple of component\n  functions of a vector field relative to `from-basis` to get component\n  functions for a vector field in `to-basis`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Ksb,QMb],null))),jU,pQb],null)],null),new $APP.f(null,3,[$APP.R,b6b,$APP.X,iO,$APP.h,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of  radians about the y axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,wsb],null)],null),new $APP.f(null,3,[$APP.R,Gub,$APP.X,MZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic tanhc.\n\nThe [tanhc function](https://en.wikipedia.org/wiki/Tanhc_function),\n  equivalent to $\\frac{\\tanh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanhc_function)\n   - [Mathworld page on Tanhc](https://mathworld.wolfram.com/TanhcFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,pfb],null)],null),new $APP.f(null,3,[$APP.R,xSb,$APP.X,fO,$APP.h,new $APP.f(null,3,[$APP.P,"generic cos.\n\nReturns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,dEb],null)],null),new $APP.f(null,3,[$APP.R,Enb,$APP.X,function(a){return["$",$APP.m.j(Q3(bG.j(a))),"$"].join("")},$APP.h,new $APP.f(null,2,
[$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in single\n  `$` to mark the string as an inline LaTeX form.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null),new $APP.f(null,3,[$APP.R,FFb,$APP.X,l4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components-\x3evector-field\n     (up x y)\n     (coordinate-system-\x3evector-basis R2-rect)))\n  ;; \x3d\x3e (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[VV,xU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(ZFb,VV,xU)],null)],null)))),jU,LYb],null)],null),new $APP.f(null,3,[$APP.R,jbb,$APP.X,cO,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the parameters registered with the supplied frame.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),jU,RYb],null)],null),new $APP.f(null,3,[$APP.R,kDb,$APP.X,M4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a structure `w` of and a vector field basis `vector-basis`, returns a new\n  structure generated by applying the full vector basis to each element of `w`.\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [vb    (vf/coordinate-system-\x3evector-basis coordsys)\n        basis (coordinate-system-\x3eoneform-basis coordsys)\n        components (down d:dx d:dy)]\n    (\x3d components\n       (-\x3e components\n           (basis-components-\x3eoneform-field basis)\n           (oneform-field-\x3ebasis-components vb))))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Hyb,xU],null))),jU,eSb],null)],null),new $APP.f(null,3,[$APP.R,E3b,$APP.X,o9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))),jU,ZOb],null)],null),new $APP.f(null,3,[$APP.R,AVb,$APP.X,FQ,$APP.h,new $APP.f(null,3,[$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns the result of aggregating either `xs` or `(map f (range low\n  high))` using the fold dynamically bound to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (sum inc 0 10))\n  ;;\x3d\x3e [55.0 1 10]\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null)),jU,mhb],null)],null),new $APP.f(null,3,[$APP.R,BPb,$APP.X,s5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Vw,$APP.fy,oZb],null))),jU,QRb],null)],null),new $APP.f(null,3,[$APP.R,qac,$APP.X,wM,$APP.h,new $APP.f(null,3,[$APP.P,"generic gcd.\n\nReturns the [greatest common\n  divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the two\n  inputs `a` and `b`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,jUb],null)],null),new $APP.f(null,3,[$APP.R,kBb,$APP.X,lZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic exp10.\n\nReturns the base-10 exponential of `x`. Equivalent to `(expt 10 x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,GJb],null)],null),new $APP.f(null,3,[$APP.R,zXb,$APP.X,p3,$APP.h,new $APP.f(null,1,[jU,ASb],null)],null),new $APP.f(null,3,[$APP.R,nSb,$APP.X,I3a,$APP.h,new $APP.f(null,
3,[$APP.P,"Returns a function that takes a single manifold `point` embedded in the\n  manifold `embedded` and transfers the point to the supplied `embedding`\n  manifold.\n\n  The embedding dimension must be the same for both manifolds.\n\n  NOTE that `embedded` and `embedding` can be either manifolds, or instances\n  of [[ICoordinateSystem]]. In the latter case `embedded` and `embedding` will\n  bind to the manifold associated with the supplied [[ICoordinateSystem]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[HKb,V9b],null))),jU,w$b],null)],null),new $APP.f(null,3,[$APP.R,tGb,$APP.X,TZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic cross-product",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,m5b],null)],null),new $APP.f(null,3,[$APP.R,Hsb,$APP.X,RSa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a predicate that returns true if its argument matches the supplied\n  kind-keyword `k`, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null))),jU,XVb],null)],null),new $APP.f(null,3,[$APP.R,GOb,$APP.X,u5a,$APP.h,new $APP.f(null,3,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))),jU,PNb],null)],null),new $APP.f(null,3,[$APP.R,hob,$APP.X,HP,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a data structure representing [Christoffel symbols of the second\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_second_kind_(symmetric_definition)).",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[DX,TU],null))),jU,uac],null)],null),new $APP.f(null,3,[$APP.R,hYb,$APP.X,L5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),jU,XXb],null)],null),new $APP.f(null,3,[$APP.R,Keb,$APP.X,p4a,$APP.h,new $APP.f(null,3,[$APP.P,"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[tNb],null))),jU,X5b],null)],null),new $APP.f(null,3,[$APP.R,MOb,$APP.X,vP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,vV],null))),jU,Y0b],null)],null),new $APP.f(null,3,[$APP.R,kcc,$APP.X,AP,$APP.h,new $APP.f(null,
3,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))),jU,ZAb],null)],null),new $APP.f(null,3,[$APP.R,eTb,$APP.X,ZZa,$APP.h,new $APP.f(null,3,[$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null)))),jU,S9b],null)],null),new $APP.f(null,3,[$APP.R,Rbb,$APP.X,MQ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the velocity element of a local tuple (by convention, the third\n  element).\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,
$APP.M($APP.qv,pV),2)],null)],null)))),jU,CLb],null)],null),new $APP.f(null,3,[$APP.R,Geb,$APP.X,vab,$APP.h,new $APP.f(null,3,[$APP.P,"Legendre elliptic integral of the first kind F(, k).\n   See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.19\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[WR,$APP.tU],null))),jU,T7b],null)],null),new $APP.f(null,3,[$APP.R,w7b,$APP.X,lI,$APP.h,new $APP.f(null,3,[$APP.P,"generic modulo.\n\nReturns the result of the\n  mathematical [Modulo](https://en.wikipedia.org/wiki/Modulo_operation)\n  operation between `a` and `b` (using the Knuth definition listed).\n\n The contract satisfied by [[modulo]] is:\n\n```clojure\n(\x3d a (+ (* b (floor (/ a b)))\n        (modulo a b)))\n```\n\n For numbers, this differs from the contract offered by [[remainder]]\n because `(floor (/ a b))` rounds toward negative infinity, while\n the [[quotient]] operation in the contract for [[remainder]] rounds toward 0.\n\n The result will be either `0` or of the same sign as the divisor `b`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,Klb],null)],null),new $APP.f(null,3,[$APP.R,cFb,$APP.X,Hrc,$APP.h,new $APP.f(null,3,[$APP.P,"Forward-mode derivative operator. Takes some function `f` and returns a\n  function whose value at some point can multiply an increment in the arguments\n  to produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D-forward]] computes a derivative. For vector-valued\n  functions, [[D-forward]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,oyb],null)],null),new $APP.f(null,3,[$APP.R,QCb,$APP.X,m5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[HU,TU],null))),jU,dOb],null)],null),new $APP.f(null,3,[$APP.R,QEb,$APP.X,QF,$APP.h,new $APP.f(null,3,[$APP.P,"Generic implementation of `/`.\n\n  If one argument is supplied, returns the multiplicative inverse of `a`. Else\n  returns the result of dividing first argument `a` by the product of all\n  remaining arguments. `(/)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core//`. Dispatch is open,\n  however, making it possible to 'divide' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (/ [2 4 6] 2)\n  ;;\x3d\x3e (up 1 2 3)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null)),jU,kqb],null)],null),new $APP.f(null,3,[$APP.R,scb,$APP.X,NR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[YW,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null))),jU,rIb],null)],null),new $APP.f(null,3,[$APP.R,Wab,$APP.X,K2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),jU,rmb],null)],null),new $APP.f(null,3,[$APP.R,pRb,$APP.X,tP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,vV],null))),jU,dRb],null)],null),new $APP.f(null,
3,[$APP.R,GTb,$APP.X,Z3,$APP.h,new $APP.f(null,3,[$APP.P,"Entrypoint for multidimensional minimization routines.\n\n  See [[emmy.numerical.multimin.nelder-mead/nelder-mead]] for the only\n  supported option.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Hy,$APP.NW,$APP.Lh,new $APP.f(null,2,[$APP.zu,new $APP.H(null,1,5,$APP.I,[cY],null),$APP.ck,$APP.Lx],null)],null)),jU,CMb],null)],null),new $APP.f(null,3,[$APP.R,EYb,$APP.X,O5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[Kyb],null))),jU,cEb],null)],null),new $APP.f(null,3,[$APP.R,agb,$APP.X,VXa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a [[PowerSeries]] instance representing a\n  [Binomial series](https://en.wikipedia.org/wiki/Binomial_series), i.e., the\n  taylor series of the function $f$ given by\n\n  ```\n  $$f(x) \x3d (1 + x)^\\alpha$$\n  ```",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null))),jU,Bhb],null)],null),new $APP.f(null,3,[$APP.R,shb,$APP.X,Mab,$APP.h,new $APP.f(null,2,
[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null))),jU,ZXb],null)],null),new $APP.f(null,3,[$APP.R,nJb,$APP.X,yab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gS],null))),jU,iNb],null)],null),new $APP.f(null,3,[$APP.R,zBb,$APP.X,n3,$APP.h,new $APP.f(null,1,[jU,vpb],null)],null),new $APP.f(null,3,[$APP.R,Apb,$APP.X,B9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EX],null))),jU,AKb],null)],null),new $APP.f(null,
3,[$APP.R,hTb,$APP.X,FI,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the factorial of `n`, i.e., the product of 1 to `n` (inclusive).\n\n  [[factorial]] will return a platform-specific [[emmy.util/bigint]] given\n  some `n` that causes integer overflow.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(pW,$APP.uU),$APP.M($APP.$v,$APP.uU,0)],null)],null)))),jU,frb],null)],null),new $APP.f(null,3,[$APP.R,Bcb,$APP.X,
qrc,$APP.h,new $APP.f(null,1,[jU,vrb],null)],null),new $APP.f(null,3,[$APP.R,xIb,$APP.X,UQ,$APP.h,new $APP.f(null,1,[jU,jwb],null)],null),new $APP.f(null,3,[$APP.R,wub,$APP.X,S3,$APP.h,new $APP.f(null,3,[$APP.P,"Golden Section search attempts to locate the minimum of the supplied function\n  `f` by evaluating points located at golden-ratioed intervals between the two\n  starting endpoints `a` and `b`. This method is slow, steady and reliable.\n\n  Supports the following optional keyword arguments:\n\n  `:converged?` is an optional predicate accepting five arguments:\n\n  - `[a fa]`\n  - `[l fl]`\n  - `[r fr]`\n  - `[b fb]`\n  - `current-iteration`\n\n  If the supplied `fn` returns true, it will signal convergence and the\n  optimizer will return. Returning false will continue.\n\n  `:choose` is called at the final step of optimization with all 4 points and\n  their fn values (see the first four arguments to `:converged?`), and returns\n  the final choice.\n\n  `:callback` receives all 5 arguments on every iteration.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n\n  `:fn-tolerance` check that the minimal value of any of the checked points is\n  within the maximum of f(a) or f(b).\n\n  `:arg-tolerance` check that `a` and `b` are within this supplied absolute\n  distance.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,new $APP.f(null,3,[$APP.zu,new $APP.H(null,2,5,$APP.I,[WX,$APP.Dw],null),$APP.Kl,new $APP.f(null,2,[WX,iW,$APP.Dw,$APP.M($APP.cw,null)],null),$APP.ck,$APP.Lx],null)],null)),jU,q9b],null)],null),new $APP.f(null,3,[$APP.R,awb,$APP.X,TF,$APP.h,new $APP.f(null,3,[$APP.P,"generic exact?.\n\nEntries that are exact are available for `gcd`, among other operations.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),jU,Clb],null)],null),new $APP.f(null,3,[$APP.R,Urb,$APP.X,F6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null))),jU,gFb],null)],null),new $APP.f(null,3,[$APP.R,r5b,$APP.X,hrc,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to the [[S2-spherical]] coordinate system, with the north pole rotated\n  90 degrees and lying along the positive y axis.",jU,umb],null)],null),new $APP.f(null,3,[$APP.R,H4b,$APP.X,SZ,$APP.h,new $APP.f(null,3,[$APP.P,
"generic outer-product",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,Ftb],null)],null),new $APP.f(null,3,[$APP.R,SNb,$APP.X,Fsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,GEb,$APP.X,RO,$APP.h,new $APP.f(null,3,[$APP.P,"Convert the structure `ms`, which would be a scalar if the (compatible)\n  multiplication `(* ls ms rs)` were performed, to a matrix.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zW,KW],null),new $APP.H(null,3,5,$APP.I,[yW,zW,KW],null)),jU,VJb],
null)],null),new $APP.f(null,3,[$APP.R,zGb,$APP.X,h3a,$APP.h,new $APP.f(null,1,[jU,ltb],null)],null),new $APP.f(null,3,[$APP.R,jLb,$APP.X,hG,$APP.h,new $APP.f(null,3,[$APP.P,"generic abs",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,idb],null)],null),new $APP.f(null,3,[$APP.R,m7b,$APP.X,W4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a coordinate basis, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,e2b],null)],
null),new $APP.f(null,3,[$APP.R,tkb,$APP.X,l3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold, false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),jU,i0b],null)],null),new $APP.f(null,3,[$APP.R,K7b,$APP.X,OF,$APP.h,new $APP.f(null,3,[$APP.P,"generic invert.\n\nReturns the multiplicative inverse of `a`.\n\n  Equivalent to `(/ 1 a)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,
TGb],null)],null),new $APP.f(null,3,[$APP.R,eFb,$APP.X,$APP.Kd,$APP.h,new $APP.f(null,2,[$APP.P,"Identity function. Returns its argument.",jU,wYb],null)],null),new $APP.f(null,3,[$APP.R,fUb,$APP.X,k6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,YRb],null))),jU,XZb],null)],null),new $APP.f(null,3,[$APP.R,ctb,$APP.X,PP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[lower]].",jU,pTb],null)],null),new $APP.f(null,3,[$APP.R,qBb,$APP.X,CN,$APP.h,new $APP.f(null,3,
[$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  Variadic equivalent to [[by-rows*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,zV],null)),jU,sec],null)],null),new $APP.f(null,3,[$APP.R,Vfb,$APP.X,z9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$X],null))),jU,Rab],null)],null),new $APP.f(null,3,[$APP.R,qtb,$APP.X,BH,$APP.h,new $APP.f(null,3,[$APP.P,"generic dot-product",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,i9b],null)],null),new $APP.f(null,3,[$APP.R,KZb,$APP.X,zR,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a column matrix populated by the supplied `xs`. Variadic equivalent\n  to [[column*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),jU,Rcb],null)],null),new $APP.f(null,3,[$APP.R,qgb,$APP.X,R5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Dcc,Odb],null))),jU,H1b],null)],
null),new $APP.f(null,3,[$APP.R,crb,$APP.X,P2,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  Variadic equivalent to [[by-cols*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,fX],null)),jU,jmb],null)],null),new $APP.f(null,3,[$APP.R,Z3b,$APP.X,Z9a,$APP.h,new $APP.f(null,3,[$APP.P,"p.324",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SR,$APP.BU],null))),jU,nnb],null)],null),new $APP.f(null,
3,[$APP.R,t$b,$APP.X,xH,$APP.h,new $APP.f(null,3,[$APP.P,"generic real-part",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Xkb],null)],null),new $APP.f(null,3,[$APP.R,Mrb,$APP.X,uL,$APP.h,new $APP.f(null,1,[jU,Fwb],null)],null),new $APP.f(null,3,[$APP.R,Dkb,$APP.X,h2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a column matrix with the contents of the supplied `up` structure.\n  Errors if any other type is provided.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,
5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(bY,$APP.Tv)],null)],null)))),jU,p8b],null)],null),new $APP.f(null,3,[$APP.R,Ggb,$APP.X,Z7a,$APP.h,new $APP.f(null,3,[$APP.P,"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\n\n  See [[brent-min]] for all supported `opts`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Kv,
$APP.Iv,$APP.qU,$APP.Lx],null))),jU,A6b],null)],null),new $APP.f(null,3,[$APP.R,U0b,$APP.X,x6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null))),jU,F9b],null)],null),new $APP.f(null,3,[$APP.R,iyb,$APP.X,pG,$APP.h,new $APP.f(null,3,[$APP.P,"generic log.\n\nReturns the natural logarithm of `x`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,$bc],null)],null),new $APP.f(null,3,[$APP.R,RAb,$APP.X,Jsc,$APP.h,$APP.F],null),
new $APP.f(null,3,[$APP.R,pHb,$APP.X,d3,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a concrete manifold generated by specializing the supplied manifold\n  `family` into a concrete manifold of dimension `n`. `n` must be a positive\n  integer.\n\n  Optionally takes an `embedding-dimension`; this must be \x3e\x3d the value of `n`.\n  Use this in cases like an n-sphere embedded in a euclidean space of dimension\n  n+1.\n\n  A [manifold](https://en.wikipedia.org/wiki/Manifold) is a topological space\n  that locally resembles Euclidean space near each point.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[uV,$APP.uU],null),new $APP.H(null,3,5,$APP.I,[uV,$APP.uU,tX],null)),jU,pAb],null)],null),new $APP.f(null,3,[$APP.R,P4b,$APP.X,WK,$APP.h,new $APP.f(null,3,[$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),jU,IAb],null)],null),new $APP.f(null,3,[$APP.R,Vlb,$APP.X,kL,$APP.h,new $APP.f(null,3,[$APP.P,"Return a structure with the same shape as s but with f applied to each\n  primitive (that is, not structural) component.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null)),jU,wyb],null)],null),new $APP.f(null,3,[$APP.R,Utb,$APP.X,mR,$APP.h,new $APP.f(null,3,[$APP.P,"generic partial-derivative",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,aEb],null)],null),new $APP.f(null,3,[$APP.R,O0b,$APP.X,krc,$APP.h,new $APP.f(null,1,[jU,WGb],null)],null),new $APP.f(null,3,[$APP.R,ADb,$APP.X,TXa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the sum of all elements in the input series `s` up to order\n  `n` (inclusive). For example:\n\n  ```clojure\n  (sum (series 1 1 1 1 1 1 1) 3)\n  ;; \x3d\x3e 4\n  ```\n\n  NOTE that [[sum]] sums the first `n + 1` terms, since a series starts with an\n  order 0 term.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.uU],null))),jU,SRb],null)],null),new $APP.f(null,3,[$APP.R,vOb,$APP.X,Jab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Vw,qS,oT,zqb,k8b],null))),jU,hgb],null)],null),new $APP.f(null,3,[$APP.R,MUb,$APP.X,L4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a structure of `components` functions defined on manifold points and and\n  a matching `oneform-basis` (of identical structure),\n\n  Returns a new one-form field that\n\n  - passes its vector-field argument to `oneform-basis`, returning a new\n    equivalent structure with each slot populated by functions from a manifold\n    point to the directional derivative (using the vector field) in that\n    coordinate direction\n\n  - contracts the result of that operation with the result of applying each\n    component in `components` to the manifold point.\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[oneform-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,MHb],null))),jU,CIb],null)],null),new $APP.f(null,3,[$APP.R,Jcc,$APP.X,P5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null))),jU,z4b],null)],null),new $APP.f(null,3,[$APP.R,Qac,$APP.X,p6a,$APP.h,new $APP.f(null,3,[$APP.P,"Computes the trace of a (0,2) tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))),jU,i5b],null)],null),new $APP.f(null,3,[$APP.R,yec,$APP.X,KZa,$APP.h,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Pv],null))),jU,lJb],null)],null),new $APP.f(null,3,[$APP.R,Kgb,$APP.X,Esc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,jyb,$APP.X,nP,$APP.h,new $APP.f(null,3,[$APP.P,"Extract the vector basis from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null)))),jU,Mdb],null)],null),
new $APP.f(null,3,[$APP.R,ubc,$APP.X,$N,$APP.h,new $APP.f(null,3,[$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null))),jU,cTb],null)],null),new $APP.f(null,3,[$APP.R,Qfb,$APP.X,OQ,$APP.h,new $APP.f(null,3,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q`, velocity tuple (or scalar)\n  `qdot` and any number of additional higher-order derivative tuples (or\n  scalars), returns a 'Local tuple', i.e., the state expected by a Lagrangian.",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Rv,vU,RY,$APP.Lh,tT],null)),jU,Yvb],null)],null),new $APP.f(null,3,[$APP.R,iFb,$APP.X,RK,$APP.h,new $APP.f(null,3,[$APP.P,"Return the structure `s` in unoriented vector form.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),jU,K4b],null)],null),new $APP.f(null,3,[$APP.R,fHb,$APP.X,H6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[IP,Hvb],null))),jU,BXb],null)],null),new $APP.f(null,3,[$APP.R,
RKb,$APP.X,x5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,B9b],null))),jU,DQb],null)],null),new $APP.f(null,3,[$APP.R,mSb,$APP.X,gL,$APP.h,new $APP.f(null,3,[$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],
null))),jU,Thb],null)],null),new $APP.f(null,3,[$APP.R,W5b,$APP.X,Nab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null))),jU,cCb],null)],null),new $APP.f(null,3,[$APP.R,NRb,$APP.X,f1,$APP.h,new $APP.f(null,3,[$APP.P,"Return a [[Series]] starting with the supplied values. The remainder of the\n  series will be filled with the zero-value corresponding to the first of the\n  given values.\n\n  If you have a sequence already, prefer [[series*]].",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,$APP.ox],null)),jU,Wtb],null)],null),new $APP.f(null,3,[$APP.R,Rhb,$APP.X,D6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null))),jU,iib],null)],null),new $APP.f(null,3,[$APP.R,HJb,$APP.X,$Q,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,rU],null))),jU,$Rb],null)],null),new $APP.f(null,3,[$APP.R,xsb,$APP.X,SXa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a series (of the same type as the input) of partial sums of the terms\n  in the supplied series `s`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),jU,Vyb],null)],null),new $APP.f(null,3,[$APP.R,yOb,$APP.X,e6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,Psb],null)],null),new $APP.f(null,3,[$APP.R,Hub,$APP.X,h4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),jU,gyb],null)],null),new $APP.f(null,3,[$APP.R,YEb,$APP.X,fG,$APP.h,new $APP.f(null,1,[jU,G5b],null)],null),new $APP.f(null,3,[$APP.R,DDb,$APP.X,vN,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a matrix with `r` rows and `c` columns, whose entries are generated by\n  the supplied function `f`.\n\n  If you only supply one dimension `n` the returned matrix will be square.\n\n  The entry in the `i`th row and `j`-th column is `(f i j)`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.mO,$APP.Jv,$APP.Kv],null)),jU,Bsb],null)],null),new $APP.f(null,3,[$APP.R,neb,$APP.X,B3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `p` is a manifold point, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),jU,n8b],null)],null),new $APP.f(null,3,[$APP.R,zfb,$APP.X,o5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],
null))),jU,FWb],null)],null),new $APP.f(null,3,[$APP.R,V0b,$APP.X,zQ,$APP.h,new $APP.f(null,2,[$APP.P,"Converts an S-expression to JavaScript.",jU,P9b],null)],null),new $APP.f(null,3,[$APP.R,oNb,$APP.X,tH,$APP.h,new $APP.f(null,3,[$APP.P,"generic cosh.\n\nComputes the [hyperbolic\n cosine](https://mathworld.wolfram.com/HyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x + e^{-x}) / 2`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,AXb],null)],
null),new $APP.f(null,3,[$APP.R,pcb,$APP.X,m4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a vector field `vf` generated from [[basis-components-\x3evector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis-\x3edual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system-\x3evector-basis coordsys)\n        dual  (basis/vector-basis-\x3edual basis coordsys)]\n    (\x3d basis-components\n       (-\x3e basis-components\n           (basis-components-\x3evector-field basis)\n           (vector-field-\x3ebasis-components dual))))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ex,rW],null))),jU,qvb],null)],null),new $APP.f(null,3,[$APP.R,hNb,$APP.X,DZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic coth.\n\nComputes the [hyperbolic\n cotangent](https://mathworld.wolfram.com/HyperbolicCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `cosh(x) / sinh(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,KXb],null)],null),new $APP.f(null,3,[$APP.R,j7b,$APP.X,Z5a,$APP.h,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[rY,pX,sW],null))),jU,Qib],null)],null),new $APP.f(null,3,[$APP.R,N4b,$APP.X,p5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RX],null))),jU,lzb],null)],null),new $APP.f(null,3,[$APP.R,Scb,$APP.X,NF,$APP.h,new $APP.f(null,3,[$APP.P,"generic one-like.\n\nIn general, this procedure returns the multiplicative identity of the type of\n  its argument, if it exists. For numbers this is 1.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,qib],null)],null),new $APP.f(null,3,[$APP.R,J0b,$APP.X,q9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.NW,$APP.OW,$APP.uU],null))),jU,Sfb],null)],null),new $APP.f(null,3,[$APP.R,NWb,$APP.X,I3,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null),new $APP.H(null,2,5,$APP.I,[KT,RX],null)),jU,Zqb],null)],null),new $APP.f(null,3,[$APP.R,BHb,$APP.X,arc,$APP.h,new $APP.f(null,1,[jU,
Inb],null)],null),new $APP.f(null,3,[$APP.R,Zzb,$APP.X,x4,$APP.h,new $APP.f(null,1,[jU,wac],null)],null),new $APP.f(null,3,[$APP.R,Uib,$APP.X,wD,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,QY],null)],null),new $APP.f(null,3,[$APP.R,QBb,$APP.X,rI,$APP.h,new $APP.f(null,3,[$APP.P,"generic expt",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,A9b],null)],null),new $APP.f(null,3,[$APP.R,d6b,$APP.X,orc,$APP.h,
new $APP.f(null,1,[jU,J_b],null)],null),new $APP.f(null,3,[$APP.R,zkb,$APP.X,tO,$APP.h,new $APP.f(null,3,[$APP.P,"Returns an [[ICoordinateSystem]] instance specialized to the patch named\n  `patch-name` on `manifold`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[ZR,TX,gW],null))),jU,xyb],null)],null),new $APP.f(null,3,[$APP.R,nEb,$APP.X,KP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null)),jU,WFb],null)],null),new $APP.f(null,
3,[$APP.R,b8b,$APP.X,e$a,$APP.h,new $APP.f(null,3,[$APP.P,"p.327",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[OX],null))),jU,Ghb],null)],null),new $APP.f(null,3,[$APP.R,nWb,$APP.X,B6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),jU,Qub],null)],null),new $APP.f(null,3,[$APP.R,WKb,$APP.X,nL,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a structure compatible for multiplication with `s` down to 0.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null))),jU,J1b],null)],null),new $APP.f(null,3,[$APP.R,uzb,$APP.X,Dsc,$APP.h,new $APP.f(null,1,[jU,LMb],null)],null),new $APP.f(null,3,[$APP.R,CFb,$APP.X,sZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic fractional-part.\n\nReturns the fractional part of the given value, defined as `x - x`.\n\n  For positive numbers, this is identical to `(- a (integer-part a))`. For\n  negative `a`, because [[floor]] truncates toward negative infinity, you might\n  be surprised to find that [[fractional-part]] returns the distance between `a`\n  and the next-lowest integer:\n\n```clojure\n(\x3d 0.6 (fractional-part -0.4))\n```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,cRb],null)],null),new $APP.f(null,3,[$APP.R,YJb,$APP.X,O2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `e` is an event, false otherwise.\n\n  Make new events with [[make-event]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))),jU,P$b],null)],null),new $APP.f(null,3,[$APP.R,Dgb,$APP.X,hP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation, returns a\n  one-form field.\n\n  The returned one-form field at each structural spot takes a vector field and\n  returns a function that takes the directional derivative in that coordinate's\n  direction using the vector field.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null)),jU,EIb],null)],null),new $APP.f(null,3,[$APP.R,geb,$APP.X,BN,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the single column from the supplied column matrix as an `up`. Errors if\n  some other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(oY,$APP.Or)],null)],null)))),jU,oIb],null)],null),new $APP.f(null,3,[$APP.R,Mqb,$APP.X,
function(a,b,c,d){$APP.rg.B(b,zX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,sUb,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)]))))},$APP.h,new $APP.f(null,4,[$APP.P,"Given some `coordinate-system` like `R2-rect` and a `coordinate-prototype` like\n  `[x y]` or `(up x y), `binds the following definitions into the namespace\n  where [[define-coordinates]] is invoked:\n\n  - `R2-rect` binds to a new version of the coordinate system with its\n    `coordinate-prototype` replaced by the supplied prototype\n\n  - `x` and `y` bind to coordinate functions, i.e., functions from manifold point\n  to that particular coordinate\n\n  - `d:dx` and `d:dy` bind to the corresponding vector field procedures\n\n  - `dx` and `dy` bind to 1-forms for each coordinate.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[nU,oW],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,mFb,$APP.X,QZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic trace",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,fmb],null)],null),new $APP.f(null,3,[$APP.R,PEb,$APP.X,kG,$APP.h,new $APP.f(null,3,[$APP.P,"Generic implementation of `+`. Returns the sum of all supplied arguments. `(+)`\n  returns 0, the additive identity.\n\n  When applied between numbers, acts like `clojure.core/+`. Dispatch is open,\n  however, making it possible to 'add' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (+ [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up 3 5 7)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null)),jU,mqb],null)],null),new $APP.f(null,3,[$APP.R,S4b,$APP.X,WQ,$APP.h,new $APP.f(null,3,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q` and momentum tuple (or\n  scalar) `p`, returns a 'Hamiltonian state tuple', i.e., the state expected by a\n  Hamiltonian.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,
$APP.I,[$APP.Rv,vU,$APP.Pv],null))),jU,Btb],null)],null),new $APP.f(null,3,[$APP.R,Ukb,$APP.X,Eab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null))),jU,sVb],null)],null),new $APP.f(null,3,[$APP.R,bib,$APP.X,a6a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point \x3d\x3e\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,hS],null)],null),new $APP.f(null,3,[$APP.R,Vgb,$APP.X,A5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,RX],null))),jU,Akb],null)],null),new $APP.f(null,3,[$APP.R,Q2b,$APP.X,M6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,CV],null))),jU,IOb],null)],null),new $APP.f(null,3,[$APP.R,u8b,$APP.X,u6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
2,5,$APP.I,[hW,TU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,TU)],null)],null)))),jU,Pbc],null)],null),new $APP.f(null,3,[$APP.R,Oib,$APP.X,N2a,$APP.h,new $APP.f(null,3,[$APP.P,"Marks the input event `e` as an event via its metadata. The return value will\n  return `true` when passed to [[event?]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))),jU,ssb],null)],null),new $APP.f(null,3,[$APP.R,kPb,$APP.X,nL,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[compatible-zero]].",
jU,Fkb],null)],null),new $APP.f(null,3,[$APP.R,GYb,$APP.X,M4,$APP.h,new $APP.f(null,3,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,n5b],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,cU,$APP.By],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,vnb,$APP.X,Vqc,$APP.h,new $APP.f(null,1,[jU,Phb],null)],null),new $APP.f(null,3,[$APP.R,STb,$APP.X,UP,$APP.h,new $APP.f(null,1,[jU,Qcb],null)],null),new $APP.f(null,3,[$APP.R,Qnb,$APP.X,crc,$APP.h,
new $APP.f(null,1,[jU,AJb],null)],null),new $APP.f(null,3,[$APP.R,jac,$APP.X,WZ,$APP.h,new $APP.f(null,3,[$APP.P,"Construct a ratio.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.jP],null)),jU,KX],null)],null),new $APP.f(null,3,[$APP.R,FZb,$APP.X,H4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a one-form field `form` and a `coordinate-system`, returns a function\n  from the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the form field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-oneform-field 'f R2-rect)]\n      ((oneform-field-\x3ecomponents f R2-rect)\n       (up 'x0 'y0))))\n\n  ;;\x3d\x3e (down (f_0 (up x0 y0))\n  ;;         (f_1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Bv,oW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(OV,$APP.Bv)],null)],null)))),jU,qjb],null)],null),new $APP.f(null,3,[$APP.R,ETb,$APP.X,YZa,$APP.h,new $APP.f(null,3,[$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient.",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Yw,$APP.Tv)],null)],null)))),jU,inb],null)],null),new $APP.f(null,3,[$APP.R,nLb,$APP.X,erc,$APP.h,new $APP.f(null,1,[jU,qxb],null)],null),new $APP.f(null,3,[$APP.R,XFb,$APP.X,g4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field-\x3ecomponents f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;\x3d\x3e (up (f0 (up x0 y0))\n  ;;       (f1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.ex,oW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(cV,$APP.ex)],null)],null)))),jU,RVb],null)],null),new $APP.f(null,3,[$APP.R,SXb,$APP.X,wZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic sec.\n\nComputes the secant of the supplied argument `a`.\n\nEquivalent to `(invert (cos a))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,ahb],null)],null),new $APP.f(null,3,[$APP.R,Zdc,$APP.X,
OQ,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[-\x3eL-state]].",jU,cxb],null)],null),new $APP.f(null,3,[$APP.R,uib,$APP.X,o4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ex,oW],null))),jU,MTb],null)],null),new $APP.f(null,3,[$APP.R,o0b,$APP.X,h6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,TU],null))),jU,sCb],null)],null),new $APP.f(null,3,[$APP.R,v4b,$APP.X,q6a,$APP.h,new $APP.f(null,3,[$APP.P,"Computes the trace of a (2,0) tensor",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))),jU,Ohb],null)],null),new $APP.f(null,3,[$APP.R,BSb,$APP.X,PF,$APP.h,new $APP.f(null,
3,[$APP.P,"generic negate.\n\nReturns the negation of `a`.\n\n  Equivalent to `(- (g/zero-like a) a)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,klb],null)],null),new $APP.f(null,3,[$APP.R,qcc,$APP.X,IZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acoth.\n\nComputes the [inverse hyperbolic\n cotangent](https://mathworld.wolfram.com/InverseHyperbolicCotangent.html) of\n the supplied argument `a`.\n\ndefaults to `1/2 ln((x+1)/(x-1))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),jU,z1b],null)],null),new $APP.f(null,3,[$APP.R,RPb,$APP.X,h5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,TU],null))),jU,DSb],null)],null),new $APP.f(null,3,[$APP.R,jgb,$APP.X,CZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic sech.\n\nComputes the [hyperbolic\n secant](https://mathworld.wolfram.com/HyperbolicSecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / cosh(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[$APP.Iv],null))),jU,Opb],null)],null),new $APP.f(null,3,[$APP.R,KOb,$APP.X,VK,$APP.h,new $APP.f(null,3,[$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),jU,$6b],null)],null),new $APP.f(null,3,[$APP.R,CZb,$APP.X,OP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),jU,O_b],null)],null),new $APP.f(null,3,[$APP.R,ocb,
$APP.X,E5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ON],null))),jU,Fac],null)],null),new $APP.f(null,3,[$APP.R,oXb,$APP.X,nZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic log10.\n\nReturns the base-10 logarithm of `x`, i.e., $log_10(x)$.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,sdb],null)],null),new $APP.f(null,3,[$APP.R,cyb,$APP.X,GN,$APP.h,new $APP.f(null,3,[$APP.P,"Convert the matrix `m` into a structure `S`, guided by the requirement that `(*\n  ls S rs)` should be a scalar.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[yW,$APP.Or,KW],null))),jU,q$b],null)],null),new $APP.f(null,3,[$APP.R,zmb,$APP.X,NQ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the acceleration element of a local tuple (by convention, the fourth\n  element).\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),3)],null)],null)))),
jU,T6b],null)],null),new $APP.f(null,3,[$APP.R,CNb,$APP.X,d$a,$APP.h,new $APP.f(null,3,[$APP.P,"p.326",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),jU,kyb],null)],null),new $APP.f(null,3,[$APP.R,PXb,$APP.X,PR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[$APP.Hv,$APP.Vv,$APP.SP,$APP.TP],null)],null))),jU,$ib],null)],null),new $APP.f(null,3,[$APP.R,DMb,$APP.X,D4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is an [form field of rank\n  n](https://en.wikipedia.org/wiki/Differential_form), false otherwise.\n\n  A form-field of rank n is an operator that takes n vector fields to a\n  real-valued function on the manifold.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null))),jU,tbc],null)],null),new $APP.f(null,3,[$APP.R,EKb,$APP.X,h1,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a [[PowerSeries]] representing the supplied constant term.\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[$APP.Jv,YV],null)),jU,wwb],null)],null),new $APP.f(null,3,[$APP.R,
Fvb,$APP.X,T3,$APP.h,new $APP.f(null,3,[$APP.P,"For convenience, we also provide the sister-procedure for finding\n  the maximum of a unimodal function using the golden section method.\n\n  Negate the function, minimize, negate the result.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,$APP.Lx],null)),jU,vdc],null)],null),new $APP.f(null,3,[$APP.R,$eb,$APP.X,lG,$APP.h,new $APP.f(null,3,[$APP.P,"generic square",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),jU,iAb],null)],null),new $APP.f(null,3,[$APP.R,hCb,$APP.X,kZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic exp2.\n\nReturns the base-2 exponential of `x`. Equivalent to `(expt 2 x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,i$b],null)],null),new $APP.f(null,3,[$APP.R,gOb,$APP.X,L3a,$APP.h,new $APP.f(null,3,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.fU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(DY,$APP.fU)],null)],null)))),jU,w1b],null)],null),new $APP.f(null,3,[$APP.R,zvb,$APP.X,RQ,$APP.h,new $APP.f(null,3,[$APP.P,"Gamma takes a path function (from time to coordinates) to a state\n  function (from time to local tuple).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[vU],null),new $APP.H(null,2,5,$APP.I,[vU,$APP.uU],null)),jU,jsb],null)],null),new $APP.f(null,3,[$APP.R,Ubc,$APP.X,R4,$APP.h,new $APP.f(null,
2,[$APP.P,"Given a sequence of `selectors`, return a function that accepts some object `x`\n  and returns:\n\n  ```clojure\n  (apply ref x selectors)\n  ```\n  ",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))],null)],null),new $APP.f(null,3,[$APP.R,Dqb,$APP.X,xG,$APP.h,new $APP.f(null,3,[$APP.P,"generic magnitude",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,yQb],null)],null),new $APP.f(null,3,[$APP.R,gcb,$APP.X,vrc,$APP.h,new $APP.f(null,1,[jU,z5b],null)],
null),new $APP.f(null,3,[$APP.R,r_b,$APP.X,$APP.LQ,$APP.h,new $APP.f(null,3,[$APP.P,"A convenience function on local tuples. A local tuple describes\n  the state of a system at a particular time:\n\n  ```\n  [t, q, D q, D^2 q]\n  ```\n\n  representing time, position, velocity (and optionally acceleration etc.)\n\n  [[coordinate]] returns the `q` element, which is expected to be a mapping from\n  time to a structure of coordinates.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[pV],
null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(MY,pV),$APP.M($APP.Yv,$APP.M($APP.qv,pV),1)],null)],null)))),jU,mBb],null)],null),new $APP.f(null,3,[$APP.R,AFb,$APP.X,I9a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns function signature for a Hamiltonian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Hamiltonian literal functions.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),jU,g9b],null)],null),
new $APP.f(null,3,[$APP.R,DVb,$APP.X,HF,$APP.h,new $APP.f(null,3,[$APP.P,"Comparator. Clone of [[cljs.core/compare]] that works with the expanded\n      Emmy numeric tower.\n\n  Returns a negative number, zero, or a positive number when x is logically\n  'less than', 'equal to', or 'greater than' y. Uses IComparable if available\n  and google.array.defaultCompare for objects of the same type and special-cases\n  nil to be less than any other object.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,
5,$APP.I,[$APP.Vv,$APP.SP],null))),jU,lnb],null)],null),new $APP.f(null,3,[$APP.R,Xob,$APP.X,mG,$APP.h,new $APP.f(null,3,[$APP.P,"generic infinite?.\n\nReturns true if `a` is either numerically infinite (i.e., equal to `##Inf`) or\n  a compound number (complex or quaterion, for example) with some infinite\n  component.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,g3b],null)],null),new $APP.f(null,3,[$APP.R,rRb,$APP.X,Xqc,$APP.h,new $APP.f(null,1,[jU,EMb],null)],null),
new $APP.f(null,3,[$APP.R,hkb,$APP.X,iP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-oneform-field` instances.\n\n  The one-form field at each structural spot takes a vector field and returns a\n  function that takes the directional derivative in that coordinate's direction\n  using the vector field.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-oneform-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,vT],null)],null),new $APP.f(null,3,[$APP.R,oKb,$APP.X,V9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EU],null))),jU,uVb],null)],null),new $APP.f(null,3,[$APP.R,wOb,$APP.X,M3a,$APP.h,new $APP.f(null,3,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 1.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fU],null),new $APP.f(null,1,[$APP.yw,
new $APP.H(null,1,5,$APP.I,[$APP.M(DY,$APP.fU)],null)],null)))),jU,Ceb],null)],null),new $APP.f(null,3,[$APP.R,O2b,$APP.X,USa,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[fGb],null))),jU,llb],null)],null),new $APP.f(null,3,[$APP.R,FVb,$APP.X,vG,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,eeb],null)],null),new $APP.f(null,3,[$APP.R,
kcb,$APP.X,i5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[chb,TU],null))),jU,s9b],null)],null),new $APP.f(null,3,[$APP.R,wSb,$APP.X,uZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic cot.\n\nComputes the trigonometric cotangent function of the supplied argument `a`.\n\nEquivalent to `(invert (tan a))`, or `(/ (cos a) (sin a))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,eEb],null)],null),new $APP.f(null,3,[$APP.R,bzb,$APP.X,d3a,$APP.h,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,rgb],null)],null),new $APP.f(null,3,[$APP.R,gUb,$APP.X,J5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,Mdc],null)],null),new $APP.f(null,3,[$APP.R,aub,$APP.X,QR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[pT,gS],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(bY,gS),$APP.M($APP.Zv,$APP.M($APP.qv,
gS),4)],null)],null)))),jU,Bbc],null)],null),new $APP.f(null,3,[$APP.R,KEb,$APP.X,iG,$APP.h,new $APP.f(null,3,[$APP.P,'Generic implementation of `*`. Returns the product of all supplied\n  arguments. `(*)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core/*`. Dispatch is open,\n  however, making it possible to \'multiply\' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (* 2 #emmy/complex "3 + 1i")\n  ;;\x3d\x3e #emmy/complex "6 + 2i"\n  ```',
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null)),jU,lqb],null)],null),new $APP.f(null,3,[$APP.R,Vab,$APP.X,UO,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ex],null))),jU,Eec],null)],null),new $APP.f(null,3,[$APP.R,Jgb,$APP.X,
fTa,$APP.h,new $APP.f(null,1,[jU,Okb],null)],null),new $APP.f(null,3,[$APP.R,Nbc,$APP.X,zZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic asec.\n\nComputes the [inverse\n secant](https://mathworld.wolfram.com/InverseSecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(sqrt(x^2 - 1))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,mbb],null)],null),new $APP.f(null,3,[$APP.R,Ntb,$APP.X,OR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[new $APP.H(null,1,5,$APP.I,[YW],null)],null))),jU,Tpb],null)],null),new $APP.f(null,3,[$APP.R,IGb,$APP.X,cR,$APP.h,new $APP.f(null,3,[$APP.P,"generic solve-linear-right.\n\nFor a given `a` and `b`, returns `x` such that `a \x3d x*b`.\n\n  See[[solve-linear]] for a similar function that solves for `a*x \x3d b`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,Kdb],null)],null),new $APP.f(null,3,[$APP.R,Jzb,$APP.X,uP,$APP.h,new $APP.f(null,3,[$APP.P,"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,OCb],null)],null),new $APP.f(null,3,[$APP.R,lUb,$APP.X,X4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(wS,$APP.qU)],null)],null)))),jU,qOb],null)],null),new $APP.f(null,3,[$APP.R,r0b,$APP.X,H3a,$APP.h,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a unique, symbolically-represented\n  point on the manifold associated with `coordinate-system`.\n\n  See [[typical-coords]] for a coordinate-based version of this function.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,Djb],null)],null),new $APP.f(null,3,[$APP.R,Isb,$APP.X,irc,$APP.h,new $APP.f(null,1,[jU,$_b],null)],null),new $APP.f(null,3,[$APP.R,vBb,$APP.X,h3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector  radians about the z axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,jbc],null)],null),new $APP.f(null,3,[$APP.R,D_b,$APP.X,KZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acsch.\n\nComputes the [inverse hyperbolic\n cosecant](https://mathworld.wolfram.com/InverseHyperbolicCosecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1+x^2)) / x)`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,kib],null)],null),new $APP.f(null,3,[$APP.R,ppb,$APP.X,mZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic log2.\n\nReturns the base-2 logarithm of `x`, i.e., $log_2(x)$.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,w5b],null)],null),new $APP.f(null,3,[$APP.R,Cbc,$APP.X,Irc,$APP.h,new $APP.f(null,1,[jU,DZb],null)],null),new $APP.f(null,3,[$APP.R,e0b,$APP.X,zF,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,Tqb],null)],null),new $APP.f(null,3,[$APP.R,Rqb,$APP.X,J3a,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a coordinate representation `coords` of a manifold point with all\n  symbolic entries, and returns a structure of the same shape with `v:`\n  prepended to all symbols.\n\n  This structure is appropriate for representing the velocities associated with\n  each coordinate.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.nW],null))),jU,ifb],null)],null),new $APP.f(null,3,[$APP.R,xmb,$APP.X,.5772156649015329,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Egb,$APP.X,$Na,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `x` is a `BigInt`, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,nXb],null)],null),new $APP.f(null,3,[$APP.R,tcb,$APP.X,KF,$APP.h,new $APP.f(null,3,[$APP.P,"generic zero?.\n\nIs true if `x` is an additive identity.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,x3b],null)],null),new $APP.f(null,3,[$APP.R,kfb,$APP.X,BG,$APP.h,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),jU,V1b],null)],null),new $APP.f(null,3,[$APP.R,ZWb,$APP.X,sP,$APP.h,new $APP.f(null,3,[$APP.P,"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,XMb],null)],null),new $APP.f(null,3,[$APP.R,yCb,$APP.X,XQ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the momentum element of a local Hamiltonian state tuple (by convention,\n  the third element).",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[WU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(bY,WU),$APP.M($APP.Yv,$APP.M($APP.qv,WU),2)],null)],null)))),jU,NOb],null)],null),new $APP.f(null,
3,[$APP.R,Z$b,$APP.X,rG,$APP.h,new $APP.f(null,3,[$APP.P,"generic atan.\n\nComputes the inverse tangent of the supplied argument `a`. Given two\n  arguments `a` and `b`, returns the inverse tangent of the angle formed by the\n  point `(b, a)` in a 2-dimensional euclidean plane.\n\n  The two-argument version is sometimes\n  called [Atan2](https://en.wikipedia.org/wiki/Atan2).",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),
jU,$fb],null)],null),new $APP.f(null,3,[$APP.R,WDb,$APP.X,O2,$APP.h,new $APP.f(null,3,[$APP.P,"Generates a `nrows` x `ncols` matrix of symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  If `ncols` (the third argument) is not supplied, returns a square matrix of\n  size `nrows` x `nrows`.\n\n  NOTE: The symbols in the returned matrix record their Einstein-notation path\n  into the structure that this matrix represents; a `down` of `up` columns. This\n  means that the returned indices embedded in the symbols look flipped, `ji` vs\n  `ij`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-matrix 'x 2 2)\n     (by-rows ['x_00 'x_10]\n              ['x_01 'x_11]))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,JV],null),new $APP.H(null,3,5,$APP.I,[$APP.Vx,JV,gX],null)),jU,pyb],null)],null),new $APP.f(null,3,[$APP.R,U_b,$APP.X,M5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(VW,NV)],null)],null)))),jU,bec],null)],null),new $APP.f(null,3,[$APP.R,Uhb,$APP.X,h$a,$APP.h,new $APP.f(null,3,[$APP.P,"p. 334 (used, but not defined there)",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),jU,sob],null)],null),new $APP.f(null,3,[$APP.R,W0b,$APP.X,y6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null))),jU,G9b],null)],null),new $APP.f(null,3,[$APP.R,Exb,$APP.X,pP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,TU],null))),jU,eec],null)],null),new $APP.f(null,3,[$APP.R,S6b,$APP.X,NZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic make-rectangular",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,ZMb],null)],null),new $APP.f(null,3,[$APP.R,Sqb,$APP.X,z6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null))),jU,Vcb],null)],null),new $APP.f(null,3,[$APP.R,zcc,$APP.X,j5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[lxb,mxb],null))),jU,Vjb],null)],null),new $APP.f(null,3,[$APP.R,kRb,$APP.X,c3a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,mcb],null)],null),new $APP.f(null,3,[$APP.R,jnb,$APP.X,H4,$APP.h,new $APP.f(null,3,[$APP.P,"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null)),jU,wcb],null)],null),new $APP.f(null,3,[$APP.R,Nrb,$APP.X,Csc,$APP.h,new $APP.f(null,1,[jU,n7b],null)],null),new $APP.f(null,3,[$APP.R,Aob,$APP.X,L6a,$APP.h,new $APP.f(null,3,[$APP.P,"[[curl]] implements equation (10.7) of Functional Differential Geometry,\n  defined on page 155.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,CV],null))),jU,P5b],null)],null),new $APP.f(null,3,[$APP.R,OXb,$APP.X,k3a,$APP.h,new $APP.f(null,
3,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold family, false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),jU,Dxb],null)],null),new $APP.f(null,3,[$APP.R,bTb,$APP.X,vZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic csc.\n\nComputes the cosecant of the supplied argument `a`.\n\nEquivalent to `(invert (sin a))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,aGb],null)],null),new $APP.f(null,3,[$APP.R,b0b,$APP.X,
urc,$APP.h,new $APP.f(null,1,[jU,yhb],null)],null),new $APP.f(null,3,[$APP.R,F_b,$APP.X,G3a,$APP.h,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a structure that matches\n  the [[coordinate-prototype]] of `coordinate-system`, with all unique,\n  gensym-ed entries.\n\n  Use [[typical-coords]] if you require a unique symbolic coordinate\n  representation compatible with `coordinate-system`.\n\n  See [[typical-point]] for a coordinate-free version of this function.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,fNb],null)],null),new $APP.f(null,3,[$APP.R,Ljb,$APP.X,oM,$APP.h,new $APP.f(null,3,[$APP.P,"generic lcm.\n\nReturns the [least common\n  multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of the two\n  inputs `a` and `b`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,sbc],null)],null),new $APP.f(null,3,[$APP.R,Leb,$APP.X,wG,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null)),jU,uG],null)],null),new $APP.f(null,3,[$APP.R,Fdc,$APP.X,y9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))),jU,oib],null)],null),new $APP.f(null,3,[$APP.R,Wdc,$APP.X,Q3,$APP.h,new $APP.f(null,3,[$APP.P,"Convert the given expression to TeX format, as a string.\n\n  If you set the `:equation` keyword argument to a truthy value, the result will\n  be wrapped in an equation environment. `:equation \x3cstring\x3e` will insert a\n  `\\label{\x3cstring\x3e}` entry inside the equation environment.\n\n  For example:\n\n  ```clojure\n  (let [expr (+ 'x 'xy)]\n    (println\n      (-\x3eTeX expr :equation \"label!\")))\n\n  \\begin{equation}\n  \\label{label!}\n  x + y\n  \\end{equation}\n  ```\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[dV],null)],null)],null)),jU,Rdb],null)],null),new $APP.f(null,3,[$APP.R,v6b,$APP.X,yrc,$APP.h,new $APP.f(null,1,[jU,Iob],null)],null),new $APP.f(null,3,[$APP.R,Rfb,$APP.X,o3a,$APP.h,new $APP.f(null,3,[$APP.P,"The supplied manifold `m` locally resembles some vector space; this function\n  returns the field over which that vector space was specified.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[ZR],null))),jU,kdc],null)],null),new $APP.f(null,3,[$APP.R,qub,$APP.X,Cab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null))),jU,Eub],null)],null),new $APP.f(null,3,[$APP.R,b4b,$APP.X,v9a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a state tuple (of finite length), reconstitutes the initial segment of\n  the Taylor series corresponding to the state tuple data as a function of t.\n\n  Time is measured beginning at the point of time specified in the input state\n  tuple.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Brb],null))),jU,ODb],null)],null),new $APP.f(null,3,[$APP.R,J8b,$APP.X,AZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acsc.\n\nComputes the [inverse\n cosecant](https://mathworld.wolfram.com/InverseCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(1 / sqrt(x^2 - 1))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,JCb],null)],null),new $APP.f(null,3,[$APP.R,Etb,$APP.X,y3,$APP.h,new $APP.f(null,3,
[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses forward-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null)),jU,TRb],null)],null),new $APP.f(null,3,[$APP.R,jFb,$APP.X,r5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KT,RX],null))),jU,gvb],null)],null),new $APP.f(null,3,[$APP.R,
Z8b,$APP.X,kO,$APP.h,new $APP.f(null,3,[$APP.P,"generic acos.\n\nComputes the inverse cosine of the supplied argument `a`.\n\nDefaults to `atan(sqrt(1-x^2)/x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,jDb],null)],null),new $APP.f(null,3,[$APP.R,fSb,$APP.X,xrc,$APP.h,new $APP.f(null,1,[jU,vZb],null)],null),new $APP.f(null,3,[$APP.R,akb,$APP.X,qM,$APP.h,new $APP.f(null,3,[$APP.P,"Accepts a single symbolic expression and returns a factored version of that\n  expression.\n\n  Differs from [[factor-expression]] in that it can handle any expression, not\n  just expressions limited to polynomial operations.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),jU,xUb],null)],null),new $APP.f(null,3,[$APP.R,Y8b,$APP.X,yZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acot.\n\nComputes the [inverse\n cotangent](https://mathworld.wolfram.com/InverseCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `pi/2 - atan(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,oDb],null)],null),new $APP.f(null,3,[$APP.R,m1b,$APP.X,pZ,$APP.h,new $APP.f(null,3,[$APP.P,
"generic floor.\n\nReturns the largest integer less than or equal to `a`.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Nhb],null)],null),new $APP.f(null,3,[$APP.R,iMb,$APP.X,b4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null))),jU,UKb],null)],null),
new $APP.f(null,3,[$APP.R,L1b,$APP.X,m9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))),jU,Gwb],null)],null),new $APP.f(null,3,[$APP.R,kmb,$APP.X,J6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[TU,hW,oW],null))),jU,YAb],null)],null),new $APP.f(null,3,[$APP.R,qYb,$APP.X,trc,$APP.h,new $APP.f(null,1,[jU,zIb],null)],null),new $APP.f(null,3,[$APP.R,MZb,$APP.X,wrc,$APP.h,new $APP.f(null,1,[jU,mOb],null)],null),new $APP.f(null,
3,[$APP.R,cdc,$APP.X,AH,$APP.h,new $APP.f(null,3,[$APP.P,"generic imag-part",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Q1b],null)],null),new $APP.f(null,3,[$APP.R,SBb,$APP.X,$qc,$APP.h,new $APP.f(null,1,[jU,Hob],null)],null),new $APP.f(null,3,[$APP.R,hIb,$APP.X,j2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a row matrix with the contents of the supplied `down` structure.\n  Errors if any other type is provided.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,
5,$APP.I,[$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(ePb,$APP.Tv)],null)],null)))),jU,hdb],null)],null),new $APP.f(null,3,[$APP.R,Bub,$APP.X,E6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[IP,TU],null))),jU,F1b],null)],null),new $APP.f(null,3,[$APP.R,ckb,$APP.X,Y5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null))),jU,Vdc],null)],null),new $APP.f(null,3,[$APP.R,Jrb,$APP.X,osc,$APP.h,
new $APP.f(null,1,[jU,a$b],null)],null),new $APP.f(null,3,[$APP.R,ycb,$APP.X,CG,$APP.h,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),jU,l$b],null)],null),new $APP.f(null,3,[$APP.R,u3b,$APP.X,RP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[oac,nac,tac,TU,hW],null))),jU,GZb],null)],null),new $APP.f(null,3,[$APP.R,oGb,$APP.X,EN,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the single row from the supplied row matrix as a vector. Errors if some\n  other type is supplied.",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(BV,$APP.Or)],null)],null)))),jU,Fbb],null)],null),new $APP.f(null,3,[$APP.R,xqb,$APP.X,TQ,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,cHb],null)],null),new $APP.f(null,3,[$APP.R,fdc,$APP.X,cI,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a function `f` and a sequence of `factors`, and returns a new function\n  that multiplies each factor by the corresponding argument of `f`. Too many or\n  two few factors are ignored.\n\n  ```clojure\n  ((arg-scale square 3) 4) \x3d\x3d\x3e 144\n  ((arg-scale square 3 2 1) 4) \x3d\x3d\x3e 144\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,mV],null)),jU,hJb],null)],null),new $APP.f(null,3,[$APP.R,yub,$APP.X,N3,$APP.h,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a new function that\n  calculates the [Gradient](https://en.wikipedia.org/wiki/Gradient) of `f`.\n\n  The related [[emmy.env/D]] operator returns a function that produces a\n  structure of the opposite orientation as [[Grad]]. Both of these functions use\n  reverse-mode automatic differentiation.",
jU,Edc],null)],null),new $APP.f(null,3,[$APP.R,DNb,$APP.X,b3a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[SX,new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.TP],null)],null))),jU,oeb],null)],null),new $APP.f(null,3,[$APP.R,cPb,$APP.X,u4,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null)),jU,iHb],null)],null),new $APP.f(null,3,[$APP.R,Ixb,$APP.X,i3a,$APP.h,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[zU],null))),jU,Zcc],null)],null),new $APP.f(null,3,[$APP.R,tLb,$APP.X,c5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[TU,uW],null))),jU,m8b],null)],null),new $APP.f(null,3,[$APP.R,HWb,$APP.X,QQ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses reverse-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null)),jU,Wsb],null)],null),new $APP.f(null,3,[$APP.R,ujb,$APP.X,bO,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the symbolic name of the suppplied frame.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),jU,$Ob],null)],null),new $APP.f(null,3,[$APP.R,lWb,$APP.X,A6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),jU,Rub],null)],null),new $APP.f(null,3,[$APP.R,bPb,$APP.X,C6a,
$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[IP],null))),jU,m3b],null)],null),new $APP.f(null,3,[$APP.R,mkb,$APP.X,T4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in an\n  `equation` environment.\n\n  Optionally supply a `:label` keyword argument to set a custom label.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[$APP.HY],null)],null)],
null))],null)],null),new $APP.f(null,3,[$APP.R,f7b,$APP.X,bR,$APP.h,new $APP.f(null,3,[$APP.P,"generic Lie-derivative",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Ytb],null)],null),new $APP.f(null,3,[$APP.R,zpb,$APP.X,H9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pV],null))),jU,yKb],null)],null),new $APP.f(null,3,[$APP.R,Ugb,$APP.X,Pab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[tec,i2b],
null))),jU,Qcc],null)],null),new $APP.f(null,3,[$APP.R,QWb,$APP.X,Oab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pT],null))),jU,osb],null)],null),new $APP.f(null,3,[$APP.R,smb,$APP.X,NP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[kT],null))),jU,CGb],null)],null),new $APP.f(null,3,[$APP.R,D3b,$APP.X,S5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[NV,$APP.qw],null))),jU,Pcb],null)],null),
new $APP.f(null,3,[$APP.R,ySb,$APP.X,Q4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the alternation of the supplied differential `form`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Bv],null))),jU,l8b],null)],null),new $APP.f(null,3,[$APP.R,I0b,$APP.X,irc,$APP.h,new $APP.f(null,1,[jU,aLb],null)],null),new $APP.f(null,3,[$APP.R,Rkb,$APP.X,Aab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ieb],null))),jU,lTb],null)],null),new $APP.f(null,3,[$APP.R,
CBb,$APP.X,o3,$APP.h,new $APP.f(null,1,[jU,hpb],null)],null),new $APP.f(null,3,[$APP.R,kGb,$APP.X,Hsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Gnb,$APP.X,drc,$APP.h,new $APP.f(null,1,[jU,Nfb],null)],null),new $APP.f(null,3,[$APP.R,NEb,$APP.X,RF,$APP.h,new $APP.f(null,3,[$APP.P,"Generic implementation of `-`.\n\n  If one argument is supplied, returns the negation of `a`. Else returns the\n  difference of the first argument `a` and the sum of all remaining\n  arguments. `(-)` returns 0.\n\n  When applied between numbers, acts like `clojure.core/-`. Dispatch is open,\n  however, making it possible to 'subtract' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (- [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up -1 -1 -1)\n\n  (- [1 10])\n  ;;\x3d\x3e (up -1 -10)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null)),jU,jqb],null)],null),new $APP.f(null,3,[$APP.R,Xhb,$APP.X,r9a,$APP.h,new $APP.f(null,3,[$APP.P,"Given `ys` (a sequence of function values) and `xs` (an equal-length sequence\n  of function inputs), returns a [[emmy.polynomial/Polynomial]] instance\n  guaranteed to pass through all supplied `xs` and `ys`.\n\n  The contract for inputs is that `(map vector xs ys)` should return a sequence\n  of pairs of points.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qUb,$APP.fx],null))),jU,ofb],null)],null),new $APP.f(null,3,[$APP.R,gYb,$APP.X,QP,$APP.h,new $APP.f(null,3,[$APP.P,"To make a one-form field into a vector field, i.e., a (0,1) tensor into a (1,0)\n  tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),jU,s8b],null)],null),new $APP.f(null,3,[$APP.R,Dbb,$APP.X,X9a,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[F-\x3eCH]].",jU,H$b],null)],null),new $APP.f(null,3,[$APP.R,
VZb,$APP.X,Bab,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a unit 3-vector `direction` (representing a direction) and a velocity\n  `v:c` normalized by `C`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xFb,NY],null))),jU,dac],null)],null),new $APP.f(null,3,[$APP.R,web,$APP.X,lP,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the standard basis object for `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,Bgb],null)],null),new $APP.f(null,3,[$APP.R,Trb,$APP.X,
nO,$APP.h,new $APP.f(null,3,[$APP.P,"Compute the rotation matrix from a 3-vector of Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[SX,WR,WT],null)],null))),jU,XRb],null)],null),new $APP.f(null,3,[$APP.R,X6b,$APP.X,$5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[rY,pX,sW],null))),jU,OEb],null)],null),new $APP.f(null,3,[$APP.R,
RBb,$APP.X,l3,$APP.h,new $APP.f(null,1,[jU,Gob],null)],null),new $APP.f(null,3,[$APP.R,Cqb,$APP.X,Zqc,$APP.h,new $APP.f(null,1,[jU,vkb],null)],null),new $APP.f(null,3,[$APP.R,j8b,$APP.X,F3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` implements [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,dUb],null)],null),new $APP.f(null,3,[$APP.R,n1b,$APP.X,XO,$APP.h,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null)),jU,xQb],null)],null),new $APP.f(null,3,[$APP.R,UUb,$APP.X,QM,$APP.h,new $APP.f(null,3,[$APP.P,"Returns its argument, wrapped in a marker type that responds to the generic\n  operations registered in [[emmy.numsymb]].\n\n  Symbols are automatically treated as [[literal-number]] instances, so\n\n  ```clojure\n  (* 10 (literal-number 'x))\n  ```\n\n  is equivalent to\n\n  ```clojure\n  (* 10 'x)\n  ```\n\n  If you pass an actual number, emmy will attempt to preserve exact values\n  through various operations:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 4))))\n  ;;\x3d\x3e (+ 1 (cos 8))\n  ```\n\n  Notice that the `(g/* 2 ...)` is evaluated, but `cos` evaluation is deferred,\n  since the result is inexact. On the other hand, if the number is inexact to\n  begin with:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 2.2))))\n  ;;\x3d\x3e 0.6926671300215806\n  ```\n\n  the system will go ahead and evaluate it.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,Obc],null)],null),new $APP.f(null,3,[$APP.R,ljb,$APP.X,frc,$APP.h,new $APP.f(null,1,[jU,Rcc],null)],null),new $APP.f(null,3,[$APP.R,ejb,$APP.X,prc,$APP.h,new $APP.f(null,1,[jU,adc],null)],null),new $APP.f(null,3,[$APP.R,BDb,$APP.X,YF,$APP.h,new $APP.f(null,3,[$APP.P,"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),jU,wib],null)],null),new $APP.f(null,3,[$APP.R,CRb,$APP.X,I4,$APP.h,new $APP.f(null,3,[$APP.P,"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[aW,$APP.Lh,MV],null)),jU,
kpb],null)],null),new $APP.f(null,3,[$APP.R,zhb,$APP.X,n9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))),jU,Rrb],null)],null),new $APP.f(null,3,[$APP.R,QDb,$APP.X,bI,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a function `f` and a sequence of `shifts`, and returns a new function\n  that adds each shift to the corresponding argument of `f`. Too many or two few\n  shifts are ignored.\n\n  ```clojure\n  ((arg-shift square 3) 4) \x3d\x3d\x3e 49\n  ((arg-shift square 3 2 1) 4) \x3d\x3d\x3e 49\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,yY],null)),jU,Yab],null)],null),new $APP.f(null,3,[$APP.R,o6b,$APP.X,S4,$APP.h,new $APP.f(null,2,[$APP.P,"A shim. Dispatches to [[d/partial]] when all the arguments are integers; falls\n  back to [[clojure.core/partial]] (partial function application) otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,QT],null))],null)],null),new $APP.f(null,3,[$APP.R,mlb,$APP.X,RZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic inner-product",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),jU,cNb],null)],null),new $APP.f(null,3,[$APP.R,jcc,$APP.X,FZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acosh.\n\nComputes the [inverse hyperbolic\n cosine](https://mathworld.wolfram.com/InverseHyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `2 ln(sqrt((x+1)/2) + sqrt((x-1)/2))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,v1b],null)],null),new $APP.f(null,3,[$APP.R,SLb,
$APP.X,rZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic ceiling.\n\nReturns the result of rounding `a` up to the next largest integer.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,XGb],null)],null),new $APP.f(null,3,[$APP.R,T1b,$APP.X,rR,$APP.h,new $APP.f(null,3,[$APP.P,"generic sinc.\n\nThe unnormalized [sinc\n  function](https://en.wikipedia.org/wiki/Sinc_function), equivalent to\n  $\\frac{\\sin x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/SincFunction.html)\n   - [Boost notes on [[sinc]]\n     and [[sinch]]](https://www.boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sinc/sinc_overview.html)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,wJb],null)],null),new $APP.f(null,3,[$APP.R,J6b,$APP.X,Yqc,$APP.h,new $APP.f(null,1,[jU,KFb],null)],null),new $APP.f(null,3,[$APP.R,Amb,$APP.X,O4,$APP.h,new $APP.f(null,4,[$APP.P,"similar to a `let` binding that holds pairs of\n\n  \x3ccoordinate-structure-prototype\x3e, \x3ccoordinate-system\x3e\n\n  And internally binds, for each pair: (take `[x y]` and `m/R2-rect` as\n  examples):\n\n  - The coordinate system symbol `R2-rect` to a new version of the coordinate\n    system with its `coordinate-prototype` replaced by the one you supplied.\n    That's `(up x y)` in this example.\n\n  - the entries `x` and `y` to coordinate functions, i.e., functions from manifold\n    point to this particular coordinate\n\n  - `d:dx` and `d:dy` vector field procedures (I'm fuzzy here!)\n\n  - `dx` and `dy` 1-forms for each coordinate (fuzzy here too!)\n\n  Example:\n\n  ```clojure\n  (let-coordinates [[x y]    R2-rect\n                   [r theta] R2-polar]\n    ;; bindings:\n    ;; R2-rect, x, y, d:dx, d:dy, dx, dy\n    ;; R2-polar, r, theta, d:dr, d:dtheta, dr, dtheta\n    body...)\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Cw,$APP.Lh,$APP.Pw],null)),$APP.Rl,!0,$APP.Bl,!0],null)],null),new $APP.f(null,3,[$APP.R,Mib,$APP.X,oP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,AV],null)),jU,ZDb],null)],null),new $APP.f(null,3,[$APP.R,pbb,$APP.X,G4,$APP.h,new $APP.f(null,
3,[$APP.P,"Takes a function `f: R \x3d\x3e R` (function of a single real variable), and returns\n  a new function of `x` that approximates the derivative $Df(x)$ (or $D^2f(x)$\n  if you pass `:method :central-d2`).\n\n  Returns the estimated value of the derivative at `x`. If you pass `:info?\n  true`, the fn returns a dictionary of the results of `us/seq-limit`:\n\n  ```clojure\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3cderivative estimate\x3e}\n  ```\n\n  Make sure to visit [[emmy.calculus.derivative/D]] if you want symbolic or\n  automatic differentiation.\n\n  ### Roundoff Estimate\n\n  The returned function will attempt to estimate how many times it can halve the\n  step size used to estimate the derivative before roundoff error swamps the\n  calculation, and force the function to return (with `:converged? false`, if\n  you pass `:info?`)\n\n  ### Optional Arguments\n\n  `D-numeric` takes optional args as its second param. Any of these can be\n  overridden by passing a second argument to the function returned by\n  `D-numeric`; helpful for setting defaults and then overriding them later.\n\n  The returned function passes through these and any other options to\n  `us/seq-limit`, where they control the sequence of richardson\n  extrapolation-accelerated estimates.\n\n  Options:\n\n  - `:method`: one of `:central`, `:central-d2`, `:forward` or `:backward`.\n  `:central-d2` forces a second derivative estimate; the other methods configure\n  a first derivative estimator.\n\n  - `:info?` if false (default), returns the estimated value of `x`. If true,\n  returns a dictionary with more information (see `D-numeric`'s docstring for\n  more info.)\n\n  - `:initial-h`: the initial `h` to use for derivative estimates before $h \to\n  0$. Defaults to `0.1 * abs(x)`.\n\n  - `:tolerance`: see `us/stream-limit` for a discussion of how this value\n  handles relative vs absolute tolerance. $\\sqrt(\\epsilon)$ by default, where\n  $\\epsilon$ \x3d machine tolerance.\n\n  - `:maxterms`: the maximum number of terms to consider when hunting for a\n  derivative estimate. This defaults to an estimate generated internally,\n  designed to prevent roundoff error from swamping the result. If you want to\n  disable this feature, set `:maxterms` to something moderately large, like\n  `:maxterms 100`. But do so carefully! See the surrounding namespace for a\n  larger discussion.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Lx],null)),jU,Ovb],null)],null),new $APP.f(null,3,[$APP.R,tob,$APP.X,z5a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a function which will pull a form back across a map (without needing\n  its inverse)",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))),jU,jPb],null)],null),new $APP.f(null,3,[$APP.R,QXb,$APP.X,I6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,
5,$APP.I,[xU,hW],null))),jU,r9b],null)],null),new $APP.f(null,3,[$APP.R,oSb,$APP.X,zab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gS],null))),jU,dBb],null)],null),new $APP.f(null,3,[$APP.R,fFb,$APP.X,jO,$APP.h,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of  radians about the z axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,MYb],null)],null),new $APP.f(null,3,[$APP.R,Hxb,$APP.X,k$a,$APP.h,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),jU,Vub],null)],null),new $APP.f(null,3,[$APP.R,tcc,$APP.X,DO,$APP.h,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from a point on the\n  coordinate system's manifold to the coordinate representation specified by the\n  supplied `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,g$b],null)],null),new $APP.f(null,3,[$APP.R,occ,$APP.X,Isc,$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.R,vwb,$APP.X,OQ,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[-\x3eL-state]].",jU,qdc],null)],null),new $APP.f(null,3,[$APP.R,JZb,$APP.X,b5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,oW],null))),jU,Ttb],null)],null),new $APP.f(null,3,[$APP.R,nIb,$APP.X,Qab,$APP.h,new $APP.f(null,3,[$APP.P,"velocities must be in meters/second, since we don't yet have units support.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.LW,$APP.MW],null))),jU,
j3b],null)],null),new $APP.f(null,3,[$APP.R,Frb,$APP.X,qL,$APP.h,new $APP.f(null,3,[$APP.P,"generic conjugate",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Orb],null)],null),new $APP.f(null,3,[$APP.R,scc,$APP.X,g6a,$APP.h,new $APP.f(null,3,[$APP.P,"Flat coordinate systems here only.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,oW],null))),jU,UIb],null)],null),new $APP.f(null,3,[$APP.R,bIb,$APP.X,tR,$APP.h,new $APP.f(null,3,[$APP.P,"generic sinhc.\n\nThe [sinhc function](https://en.wikipedia.org/wiki/Sinhc_function),\n  equivalent to $\\frac{\\sinh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinhc_function)\n   - [Mathworld page on Sinhc](https://mathworld.wolfram.com/SinhcFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Ozb],null)],null),new $APP.f(null,3,[$APP.R,hXb,$APP.X,QN,$APP.h,new $APP.f(null,3,[$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.fx],null)),jU,MP],null)],null),new $APP.f(null,3,[$APP.R,Azb,$APP.X,W9a,$APP.h,new $APP.f(null,3,[$APP.P,"f is a function of (x y continue fail), which calls continue with the values of\n  x' y' that follow x y in the mapping.\n\n  Returns a map of the same shape that iterates the iterated map n times before\n  invoking the continuation, or invokes the fail continuation if the inner map\n  fails.",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Gu,$APP.M($APP.jv,$APP.uU))],null)],null)))),jU,Arb],null)],null),new $APP.f(null,3,[$APP.R,Kac,$APP.X,NK,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Pv],null))),jU,Acc],null)],null),new $APP.f(null,3,[$APP.R,Wvb,$APP.X,jG,$APP.h,new $APP.f(null,3,[$APP.P,"generic sqrt",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),jU,A8b],null)],null),new $APP.f(null,3,[$APP.R,cKb,$APP.X,HO,$APP.h,new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and an [[ICoordinateSystem]], returns a literal\n  function that maps coordinate-free manifold points to a scalar output.\n\n  Also aliased as [[literal-manifold-function]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,oW],null))),jU,zKb],null)],null),new $APP.f(null,3,[$APP.R,LHb,$APP.X,W2a,$APP.h,new $APP.f(null,3,[$APP.P,"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.fx],null))),jU,l2b],null)],null),new $APP.f(null,3,[$APP.R,PTb,$APP.X,qrc,$APP.h,new $APP.f(null,1,[jU,rhb],null)],null),new $APP.f(null,3,[$APP.R,RGb,$APP.X,$APP.YQ,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[Hamiltonian-\x3estate-derivative]], for compatibility with\n  1st edition of SICM.",jU,Crb],null)],null),new $APP.f(null,3,[$APP.R,Bdb,$APP.X,SH,$APP.h,new $APP.f(null,3,[$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,wBb],null)],null),new $APP.f(null,3,[$APP.R,uJb,$APP.X,JZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic asech.\n\nComputes the [inverse hyperbolic\n secant](https://mathworld.wolfram.com/InverseHyperbolicSecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1-x^2)) / x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,zwb],null)],null),new $APP.f(null,3,[$APP.R,iRb,$APP.X,n6a,
$APP.h,new $APP.f(null,3,[$APP.P,"For making a (2,0) tensor into a (0,2) tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MX,TU],null))),jU,m2b],null)],null),new $APP.f(null,3,[$APP.R,gbc,$APP.X,xZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic asin.\n\nComputes the inverse sine of the supplied argument `a`.\n\nDefaults to `atan(x/sqrt(1-x^2))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Xcb],null)],null),new $APP.f(null,3,[$APP.R,oub,$APP.X,G5a,$APP.h,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),jU,OAb],null)],null),new $APP.f(null,3,[$APP.R,G_b,$APP.X,hO,$APP.h,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of  radians about the x axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,Y2b],null)],null),new $APP.f(null,3,[$APP.R,e_b,$APP.X,n5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[udb,TU],null))),jU,A0b],null)],null),
new $APP.f(null,3,[$APP.R,JVb,$APP.X,eR,$APP.h,new $APP.f(null,3,[$APP.P,"generic transpose",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Vvb],null)],null),new $APP.f(null,3,[$APP.R,OBb,$APP.X,Sqc,$APP.h,new $APP.f(null,1,[jU,Kob],null)],null),new $APP.f(null,3,[$APP.R,qRb,$APP.X,AP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[differential-of-map]].",jU,AHb],null)],null),new $APP.f(null,3,[$APP.R,QFb,$APP.X,s4,$APP.h,new $APP.f(null,3,[$APP.P,"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,3,[$APP.zu,new $APP.H(null,3,5,$APP.I,[bS,VT,cY],null),$APP.Kl,new $APP.f(null,3,[bS,RT,VT,!1,cY,!1],null),$APP.ck,$APP.Lx],null)],null)),jU,Scc],null)],null),new $APP.f(null,3,[$APP.R,Gcb,$APP.X,function(a){return["$$",$APP.m.j(Q3(bG.j(a))),"$$"].join("")},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in double\n  `$$` to mark the string as a block LaTeX form.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))],null)],null),new $APP.f(null,3,[$APP.R,xHb,$APP.X,BP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KT],null))),jU,dLb],null)],null),new $APP.f(null,3,[$APP.R,iJb,$APP.X,B4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a form field that returns, for any supplied vector field `vf`, a\n  manifold function [[manifold/zero-manifold-function]] that maps every input\n  manifold `point` to the scalar value 0.",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),jU,INb],null)],null),new $APP.f(null,3,[$APP.R,Z_b,$APP.X,oG,$APP.h,new $APP.f(null,3,[$APP.P,"generic exp.\n\nReturns the base-e exponential of `x`. Equivalent to `(expt e x)`, given\n  some properly-defined `e` symbol.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Twb],null)],null),new $APP.f(null,3,[$APP.R,Ecc,$APP.X,h9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[UU],null))),jU,isb],null)],null),new $APP.f(null,3,[$APP.R,q7b,$APP.X,GP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),jU,EXb],null)],null),new $APP.f(null,3,[$APP.R,Jkb,$APP.X,qG,$APP.h,new $APP.f(null,3,[$APP.P,"generic negative?.\n\nReturns true if the argument `a` is less than `(g/zero-like a)`,\n  false otherwise. The default implementation depends on a proper Comparable\n  implementation on the type.`",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),jU,tSb],null)],null),new $APP.f(null,3,[$APP.R,Tcb,$APP.X,SO,$APP.h,new $APP.f(null,3,[$APP.P,"Reverse-mode derivative operator. Takes some function `f` and returns a\n  function whose value at some point can multiply an increment in the arguments\n  to produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D-reverse]] computes a derivative. For vector-valued\n  functions, [[D-reverse]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,a8b],null)],null),new $APP.f(null,3,[$APP.R,Qeb,$APP.X,qZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic integer-part.\n\nReturns the integer part of `a` by removing any fractional digits.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Cbb],null)],null),new $APP.f(null,3,[$APP.R,lsb,$APP.X,e3a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pU],null))),jU,eyb],null)],
null),new $APP.f(null,3,[$APP.R,g6b,$APP.X,ZO,$APP.h,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,LX],null)],null),new $APP.f(null,3,[$APP.R,afb,$APP.X,oL,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),jU,ymb],null)],null),new $APP.f(null,3,[$APP.R,sbb,$APP.X,FP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SR],null))),
jU,xOb],null)],null),new $APP.f(null,3,[$APP.R,KUb,$APP.X,PP,$APP.h,new $APP.f(null,3,[$APP.P,"To make a vector field into a one-form field, i.e., a (1,0) tensor into a (0,1)\n  tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[hW],null))),jU,Adc],null)],null),new $APP.f(null,3,[$APP.R,Wcc,$APP.X,U2a,$APP.h,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - `c-\x3ee`, a function mapping coordinates to events\n  - `e-\x3ec`, a function mapping events to coordinates\n\n  and returns a function that takes:\n\n  - a symbolic name\n  - an ancestor frame\n  - a dictionary of params\n\n  and returns instance of [[IFrame]].\n\n  Both `c-\x3ee` and `e-\x3ec` must accept three arguments:\n\n  - `ancestor-frame`\n  - the [[IFrame]] instance\n  - a map of parameters supplied to the returned function (possibly empty!).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qX,ZS],null))),jU,zSb],null)],null),new $APP.f(null,3,[$APP.R,F6b,$APP.X,WH,$APP.h,new $APP.f(null,3,[$APP.P,"Arity-preserving version of `clojure.core/comp`.\n\n  The arity of a composition is the arity of the rightmost (that is, first to be\n  applied) function term in `fns`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$V],null)),jU,y9b],null)],null),new $APP.f(null,3,[$APP.R,zEb,$APP.X,F9a,$APP.h,new $APP.f(null,3,[$APP.P,"SICM p. 83",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pV],null))),jU,Iwb],null)],null),new $APP.f(null,3,[$APP.R,vjb,$APP.X,QP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[raise]].",jU,Eib],null)],null),new $APP.f(null,3,[$APP.R,A1b,$APP.X,k2,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ov],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.Ov],
null)),jU,rqb],null)],null),new $APP.f(null,3,[$APP.R,lHb,$APP.X,DN,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the single row from the supplied row matrix as a `down`. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Or],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(BV,$APP.Or)],null)],null)))),jU,Fzb],null)],null),new $APP.f(null,3,[$APP.R,pEb,$APP.X,Y3,$APP.h,new $APP.f(null,3,[$APP.P,"Find the minimum of the function `f: R -\x3e R` in the interval `[a, b]`.\n\n  If an `observe` function is supplied, it will be invoked with the iteration\n  count and the values of x and f(x) at each search step.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,bW],null)),jU,vNb],null)],null),new $APP.f(null,3,[$APP.R,Dpb,$APP.X,GZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic asinh.\n\nComputes the [inverse hyperbolic\n sine](https://mathworld.wolfram.com/InverseHyperbolicSine.html) of the\n supplied argument `a`.\n\ndefaults to `ln(x + sqrt(1 + x^2))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,QOb],
null)],null),new $APP.f(null,3,[$APP.R,pSb,$APP.X,gP,$APP.h,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - a `down` tuple of `components` of the one-form field relative to\n    `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a full one-form field.\n\n  A one-field field is an operator that takes a vector field to a real-valued\n  function on the manifold.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null)),jU,bUb],null)],null),new $APP.f(null,
3,[$APP.R,EPb,$APP.X,JTa,$APP.h,new $APP.f(null,2,[$APP.U,null,jU,a_b],null)],null),new $APP.f(null,3,[$APP.R,g2b,$APP.X,fL,$APP.h,new $APP.f(null,3,[$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x0 'x1 'x2))\n  ```",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,$APP.wY],null))),jU,I6b],null)],null),new $APP.f(null,3,[$APP.R,
Nwb,$APP.X,uL,$APP.h,new $APP.f(null,1,[jU,Ehb],null)],null),new $APP.f(null,3,[$APP.R,yGb,$APP.X,g3a,$APP.h,new $APP.f(null,1,[jU,mtb],null)],null),new $APP.f(null,3,[$APP.R,wFb,$APP.X,i6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))),jU,U2b],null)],null),new $APP.f(null,3,[$APP.R,h$b,$APP.X,src,$APP.h,new $APP.f(null,1,[jU,oHb],null)],null),new $APP.f(null,3,[$APP.R,D0b,$APP.X,FWa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[emmy.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to handle [[Dual]]\n  inputs in addition to any types that a normal `(f x)` call would present. This\n  restriction does _not_ apply to operations like putting `x` into a container\n  or destructuring; just primitive function calls.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,Uyb],null)],null),new $APP.f(null,3,[$APP.R,abb,$APP.X,QP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[raise]].",jU,ojb],null)],null),new $APP.f(null,3,[$APP.R,t4b,$APP.X,cL,$APP.h,new $APP.f(null,3,[$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.AY,mU,$APP.Kv],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,mU)],null)],null)))),jU,BUb],null)],null),new $APP.f(null,3,[$APP.R,qHb,$APP.X,$APP.PQ,$APP.h,new $APP.f(null,3,[$APP.P,"Optionally takes a dissipation function.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null),new $APP.H(null,2,5,$APP.I,[$APP.DU,vY],null)),jU,ngb],null)],null),new $APP.f(null,3,[$APP.R,wZb,$APP.X,U9a,$APP.h,new $APP.f(null,3,[$APP.P,"p. 428, the Lie transform is just the time-advance operator using the Lie\n  derivative (see Hamiltonian.scm).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.BU,$APP.Rv],null))),jU,Qqb],null)],null),new $APP.f(null,3,[$APP.R,lgb,$APP.X,rab,$APP.h,new $APP.f(null,3,[$APP.P,"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
5,5,$APP.I,[aW,MV,$APP.SU,IW,$APP.aX],null))),jU,YIb],null)],null),new $APP.f(null,3,[$APP.R,KQb,$APP.X,PP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[lower]].",jU,n2b],null)],null),new $APP.f(null,3,[$APP.R,dbc,$APP.X,l5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[HU,wU,$APP.jP,$APP.uU],null))),jU,$Ib],null)],null),new $APP.f(null,3,[$APP.R,Icc,$APP.X,VZ,$APP.h,new $APP.f(null,3,[$APP.P,"Renders an expression through the simplifier and onto the stream.",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tw,bU],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,bU,$APP.yu],null)),jU,Owb],null)],null),new $APP.f(null,3,[$APP.R,Mmb,$APP.X,nrc,$APP.h,new $APP.f(null,1,[jU,Bmb],null)],null),new $APP.f(null,3,[$APP.R,KDb,$APP.X,UP,$APP.h,new $APP.f(null,1,[jU,Rsb],null)],null),new $APP.f(null,3,[$APP.R,IUb,$APP.X,eTa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null))),jU,uPb],null)],null),new $APP.f(null,3,[$APP.R,$pb,$APP.X,$APP.VQ,$APP.h,new $APP.f(null,3,[$APP.P,"Accepts a coordinate transformation `F` from a local tuple to a new coordinate\n  structure, and returns a function from `local -\x3e local` that applies the\n  transformation directly.\n\n  [[F-\x3eC]] handles local tuples of arbitrary length.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[AU],null))),jU,UJb],null)],null),new $APP.f(null,
3,[$APP.R,GFb,$APP.X,BZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic tanh.\n\nComputes the [hyperbolic\n tangent](https://mathworld.wolfram.com/HyperbolicTangent.html) of the supplied\n argument `a`.\n\ndefaults to `sinh(x) / cosh(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,TKb],null)],null),new $APP.f(null,3,[$APP.R,Ecb,$APP.X,q3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a set of patch names registered in the supplied manifold.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[ZR],null))),jU,Sob],null)],null),new $APP.f(null,3,[$APP.R,Qbb,$APP.X,zrc,$APP.h,new $APP.f(null,1,[jU,Dwb],null)],null),new $APP.f(null,3,[$APP.R,Qjb,$APP.X,d6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),jU,$$b],null)],null),new $APP.f(null,3,[$APP.R,eKb,$APP.X,r6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[hW,TU,$APP.Or],null))),jU,W9b],null)],null),new $APP.f(null,3,[$APP.R,NGb,$APP.X,iZ,$APP.h,
new $APP.f(null,3,[$APP.P,"generic identity?.\n\nLike `one?`, but this is true of square identity matrices as well.\n  No matrix is considered `one?` because its function as a multiplicative\n  identity depends on the shape of the other multiplicand.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,IDb],null)],null),new $APP.f(null,3,[$APP.R,xGb,$APP.X,f3a,$APP.h,new $APP.f(null,1,[jU,ktb],null)],null),new $APP.f(null,3,[$APP.R,$Eb,$APP.X,tG,$APP.h,new $APP.f(null,3,[$APP.P,
"generic zero-like.\n\nIn general, this procedure returns the additive identity of the type of its\n  argument, if it exists. For numbers this is 0.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,rFb],null)],null),new $APP.f(null,3,[$APP.R,l4b,$APP.X,rrc,$APP.h,new $APP.f(null,1,[jU,nvb],null)],null),new $APP.f(null,3,[$APP.R,qpb,$APP.X,uL,$APP.h,new $APP.f(null,1,[jU,lrb],null)],null),new $APP.f(null,3,[$APP.R,D9b,$APP.X,WP,$APP.h,new $APP.f(null,3,[$APP.P,"Both arities of [[divergence]] are defined on page 156 of Functional Differential Geometry.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NV],null),new $APP.H(null,2,5,$APP.I,[hW,CV],null)),jU,rOb],null)],null),new $APP.f(null,3,[$APP.R,hVb,$APP.X,Gsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,sPb,$APP.X,u3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a set of names of all coordinate system constructors registered in the\n  supplied patch.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Ufb],null))),jU,nRb],null)],null),new $APP.f(null,3,[$APP.R,RFb,$APP.X,PZ,$APP.h,new $APP.f(null,
3,[$APP.P,"generic angle",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,Yub],null)],null),new $APP.f(null,3,[$APP.R,Uob,$APP.X,jrc,$APP.h,new $APP.f(null,1,[jU,Mpb],null)],null),new $APP.f(null,3,[$APP.R,dFb,$APP.X,SO,$APP.h,new $APP.f(null,3,[$APP.P,"Derivative operator. Takes some function `f` and returns a function whose value\n  at some point can multiply an increment in the arguments to produce the best\n  linear estimate of the increment in the function value.\n\n  For univariate functions, [[D]] computes a derivative. For vector-valued\n  functions, [[D]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.\n\n  The related [[emmy.env/Grad]] returns a function that produces a structure of\n  the opposite orientation as [[D]]. Both of these functions use reverse-mode\n  automatic differentiation.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,Pwb],null)],null),new $APP.f(null,3,[$APP.R,D8b,$APP.X,Wqc,$APP.h,new $APP.f(null,1,[jU,Xab],null)],null),new $APP.f(null,3,[$APP.R,Cgb,$APP.X,F3,$APP.h,new $APP.f(null,3,[$APP.P,"Computes the wedge product of the sequence `fs` of one-forms.\n\n  Higher rank forms can be constructed from one-forms by wedging them together.\n  This antisymmetric tensor product is computed as a determinant. The purpose of\n  this is to allow us to use the construction dx^dy to compute the area\n  described by the vectors that are given to it.\n\n  See Spivak p275 v1 of 'Differential Geometry' to see the correct definition.\n  The key is that the wedge of the coordinate basis forms had better be the\n  volume element.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.lx],null)),jU,ohb],null)],null),new $APP.f(null,3,[$APP.R,$zb,$APP.X,BF,$APP.h,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qu],null))),jU,xbb],null)],null),new $APP.f(null,3,[$APP.R,Xfb,$APP.X,E4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is\n  a [One-form](https://en.wikipedia.org/wiki/One-form), false\n  otherwise.\n\n  A [One-form](https://en.wikipedia.org/wiki/One-form) takes a single vector\n  field to a real-valued function on the manifold.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),jU,gLb],null)],null),new $APP.f(null,3,[$APP.R,EBb,$APP.X,m3,$APP.h,new $APP.f(null,1,[jU,ipb],null)],null),new $APP.f(null,3,[$APP.R,SSb,$APP.X,N3a,$APP.h,new $APP.f(null,3,[$APP.P,"Takes some constant `c` and returns a manifold function that maps every input\n  manifold `point` to `c.`",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null))),jU,Lpb],null)],null),new $APP.f(null,3,[$APP.R,ZVb,$APP.X,j4a,$APP.h,
new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3evector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,oW],null))),jU,lAb],null)],null),new $APP.f(null,3,[$APP.R,A2b,$APP.X,z3,$APP.h,new $APP.f(null,3,[$APP.P,"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[emmy.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, i.e., the Taylor series expansion at `(\x3d x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[emmy.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[emmy.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Lh,$APP.fx],null)),jU,YUb],null)],null),new $APP.f(null,3,[$APP.R,Cub,$APP.X,bG,$APP.h,new $APP.f(null,3,[$APP.P,"generic simplify",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,t6b],null)],null),new $APP.f(null,3,[$APP.R,I7b,$APP.X,HZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic atanh.\n\nComputes the [inverse hyperbolic\n tangent](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) of the\n supplied argument `a`.\n\ndefaults to `1/2 ln((1+x)/(1-x))`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,fec],null)],null),new $APP.f(null,3,[$APP.R,R1b,$APP.X,sG,$APP.h,new $APP.f(null,3,[$APP.P,"generic one?.\n\nIs true if `x` is a multiplicative identity.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),jU,BJb],null)],null),new $APP.f(null,3,[$APP.R,Uqb,$APP.X,m2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the submatrix of the matrix (or matrix-like structure) `s` generated by\n  taking\n\n  - rows    from `lowrow` -\x3e `hirow` (inclusive)\n  - columns from `lowcol` -\x3e `hicol` (inclusive)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Vv,X2b,ULb,Vac,aVb],null))),jU,p3b],null)],null)]),$APP.Zo(XCb)),$APP.ap(new $APP.f(null,3,[$APP.z(cac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`"],
null)),new $APP.f(null,3,[$APP.R,eJ,$APP.X,dJ,$APP.h,new $APP.f(null,2,[$APP.P,"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),$APP.z($APP.rra,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given a form returned by a consequence function, unwraps the top level\n  `succeed` wrapper if present to return the final value."],null)),new $APP.f(null,3,[$APP.R,mmb,$APP.X,bYa,$APP.h,new $APP.f(null,2,[$APP.P,"Given a form returned by a consequence function, unwraps the top level\n  `succeed` wrapper if present to return the final value.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),$APP.z(c$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[nUb,Occ],null))),$APP.P,"Takes:\n\n  - a symbol `frame-sym` meant to reference a map of bindings\n  - a skeleton expression `skel`\n\n  and returns an unevaluated body that, when evaluated, will produce a form\n  structure of identical shape to `skel`, with:\n\n  - all variable binding forms replaced by forms that look up the binding in a\n    map bound to `frame-sym`\n  - same with any segment binding form, with the added note that these should\n    be spliced in\n  - any `unquote` or `unquote-splicing` forms respected."],
null)),new $APP.f(null,3,[$APP.R,f_b,$APP.X,fYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - a symbol `frame-sym` meant to reference a map of bindings\n  - a skeleton expression `skel`\n\n  and returns an unevaluated body that, when evaluated, will produce a form\n  structure of identical shape to `skel`, with:\n\n  - all variable binding forms replaced by forms that look up the binding in a\n    map bound to `frame-sym`\n  - same with any segment binding form, with the added note that these should\n    be spliced in\n  - any `unquote` or `unquote-splicing` forms respected.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[nUb,Occ],null))],null)],null)],null),$APP.Zo(mHb)),$APP.ap(new $APP.f(null,3,[fyb,new $APP.f(null,3,[$APP.R,jkb,$APP.X,nsc,$APP.h,$APP.F],null),$APP.z(RSb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[bS,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[bS,$APP.Iv,$APP.qU,$APP.Or],null))),$APP.P,"Takes:\n\n  - An integration method, specified as either:\n    - a keyword naming one of the available methods in `available-methods`\n    - a function with the proper integrator signature\n    - a dictionary of integrator options with a `:method` key\n\n  - `a` and `b` integration endpoints\n  - an optional dictionary of options `m`\n\n  And returns a pair of an integrator function and a possibly-enhanced options\n  dictionary.\n\n  (Some integration functions require extra options, so the returned dictionary\n  may have more entries than the `m` you pass in.)\n\n  If either endpoint is infinite, the returned integrator is wrapped in\n  `qi/improper` and able to handle infinite endpoints (as well as non-infinite\n  endpoints by passing through directly to the underlying integrator).",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[bS,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[bS,$APP.Iv,$APP.qU,$APP.Or],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[bS,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[bS,$APP.Iv,$APP.qU,$APP.Or],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,Tnb,$APP.X,r4,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - An integration method, specified as either:\n    - a keyword naming one of the available methods in `available-methods`\n    - a function with the proper integrator signature\n    - a dictionary of integrator options with a `:method` key\n\n  - `a` and `b` integration endpoints\n  - an optional dictionary of options `m`\n\n  And returns a pair of an integrator function and a possibly-enhanced options\n  dictionary.\n\n  (Some integration functions require extra options, so the returned dictionary\n  may have more entries than the `m` you pass in.)\n\n  If either endpoint is infinite, the returned integrator is wrapped in\n  `qi/improper` and able to handle infinite endpoints (as well as non-infinite\n  endpoints by passing through directly to the underlying integrator).",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[bS,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[bS,$APP.Iv,$APP.qU,$APP.Or],null))],null)],null),$APP.z(nbb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,3,[$APP.zu,new $APP.H(null,3,5,$APP.I,[bS,VT,cY],null),$APP.Kl,new $APP.f(null,3,[bS,RT,VT,!1,cY,!1],null),$APP.ck,$APP.Lx],null)],null))),$APP.P,"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,3,[$APP.zu,new $APP.H(null,3,5,$APP.I,[bS,VT,cY],null),$APP.Kl,new $APP.f(null,3,[bS,RT,VT,!1,cY,!1],null),$APP.ck,$APP.Lx],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,
3,[$APP.zu,new $APP.H(null,3,5,$APP.I,[bS,VT,cY],null),$APP.Kl,new $APP.f(null,3,[bS,RT,VT,!1,cY,!1],null),$APP.ck,$APP.Lx],null)],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,Scc,$APP.X,s4,$APP.h,new $APP.f(null,2,[$APP.P,"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Iv,$APP.qU,new $APP.f(null,3,[$APP.zu,new $APP.H(null,3,5,$APP.I,[bS,VT,cY],null),$APP.Kl,new $APP.f(null,3,[bS,RT,VT,!1,cY,!1],null),$APP.ck,$APP.Lx],null)],null))],null)],null)],null),$APP.Zo(t5b)),$APP.ap(new $APP.f(null,2,[$APP.z(KAb,new $APP.f(null,1,[$APP.gm,!0],null)),new $APP.f(null,3,[$APP.R,rcb,$APP.X,!0,$APP.h,$APP.F],null),$APP.z(qhb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[YT,$APP.iw],null),new $APP.H(null,3,5,$APP.I,[YT,$APP.iw,d7b],null))),$APP.P,"Log an assumption.\n\n  NOTE that `if-false` is not used right now. Currently this always returns true.\n\n  NOTE: what this WILL do is check if the assumption is correct, to the extent\n  that this is possible, and fail if it's provably false.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[YT,$APP.iw],null),new $APP.H(null,
3,5,$APP.I,[YT,$APP.iw,d7b],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[YT,$APP.iw],null),new $APP.H(null,3,5,$APP.I,[YT,$APP.iw,d7b],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,GIb,$APP.X,EJ,$APP.h,new $APP.f(null,2,[$APP.P,"Log an assumption.\n\n  NOTE that `if-false` is not used right now. Currently this always returns true.\n\n  NOTE: what this WILL do is check if the assumption is correct, to the extent\n  that this is possible, and fail if it's provably false.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[YT,$APP.iw],null),new $APP.H(null,3,5,$APP.I,[YT,$APP.iw,d7b],null))],null)],null)],null),$APP.Zo(qyb)),$APP.ap(new $APP.f(null,7,[$APP.z($3b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.uU,$APP.Lx],null))),$APP.P,"Returns a compiled, simplified version of `f`, given a function `f` of arity\n  `n` (i.e., able to accept `n` symbolic arguments).\n\n  `n` defaults to `([[f/arity]] f)`.\n\n  You may also specify options in the third argument. See [[compile-state-fn]]\n  for information on the options supported.\n\n  The returned, compiled function expects `n` `Double` (or `js/Number`)\n  arguments. The function body is simplified and all common subexpressions\n  identified during compilation are extracted and computed only once.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.uU,$APP.Lx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.uU,$APP.Lx],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),new $APP.f(null,3,[$APP.R,yHb,$APP.X,
$APP.$3,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a compiled, simplified version of `f`, given a function `f` of arity\n  `n` (i.e., able to accept `n` symbolic arguments).\n\n  `n` defaults to `([[f/arity]] f)`.\n\n  You may also specify options in the third argument. See [[compile-state-fn]]\n  for information on the options supported.\n\n  The returned, compiled function expects `n` `Double` (or `js/Number`)\n  arguments. The function body is simplified and all common subexpressions\n  identified during compilation are extracted and computed only once.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.uU],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.uU,$APP.Lx],null))],null)],null),$APP.z(kKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[kW],null))),$APP.P,"Set the default compilation mode by supplying an entry from [[valid-modes]]."],null)),new $APP.f(null,3,[$APP.R,$1b,$APP.X,function(a){h8a(a);return Yrc=a},$APP.h,new $APP.f(null,2,[$APP.P,"Set the default compilation mode by supplying an entry from [[valid-modes]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[kW],null))],null)],null),$APP.z(CTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"Validates and returns the dynamically bound compilation [[*mode*]].\n  Throws on an invalid setting."],null)),new $APP.f(null,3,[$APP.R,dqb,$APP.X,function(){return h8a(Yrc)},$APP.h,new $APP.f(null,2,[$APP.P,"Validates and returns the dynamically bound compilation [[*mode*]].\n  Throws on an invalid setting.",$APP.U,$APP.M($APP.sf)],null)],null),$APP.z(j9b,
new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Fw,$APP.SU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Fw,$APP.SU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,7,5,$APP.I,[kW,UW,ZT,IY,iY,kS,fY],null),$APP.Kl,new $APP.f(null,6,[kW,cW,UW,iV,IY,$APP.M($APP.wv,$APP.Fw),iY,$APP.M(lY,4),kS,!0,fY,!0],null)],null)],null))),$APP.P,"Returns a compiled, simplified function with signature `(f state params?)`,\n  given:\n\n  - a state function that can accept a symbolic arguments\n\n  - `params`: really any sequence of count equal to the number of arguments\n    taken by `f`. The values are ignored. If the specific value `false` is\n    provided, then `f` is considered to be the function to compile itself, and not\n    the producer of such a function via application of parameters.\n\n  - `initial-state`: Some structure of the same shape as the argument expected\n    by the fn returned by the state function `f`. Only the shape matters; the\n    values are ignored.\n\n  - an optional argument `opts`. Options accepted are:\n\n    - `:calling-convention`: May have one of the following values. (In\n      each of these examples, assume that the initial state\n      `(up 1 (up 2 3) (up 3 4)) has been provided.)\n\n      - `:structure`: The arguments to the compiled function will have\n        the same shape as the initial-state, and elements of that state\n        will be made available to the function via argument destructuring\n        in function signature, e.g.:\n\n        ```clojure\n        (fn [[y1 [y2 y3] [y4 y5]]] [p1 ...] ...)\n        ```\n\n      - `:primitive`: The compiled function will expect a primitive array\n        containing the state in flat form to be passed as the first\n        argument, and will return its value by mutating its second argument,\n        which will also be a primitive array of the same size. The parameters\n        will be provided via a third primitive array:\n\n        ```clojure\n        (fn [ys yps ps] ...)\n        ```\n\n        This is the fastest form, as no allocations are needed to destructure\n        arguments list or to construct the return value, but requires the use\n        of primitive arrays (not general Clojure sequences, even if mutable) by\n        the caller. The generated code will use `aget` and `aset` on the arrays.\n\n    - `:generic-params?`: if `true` (default), the returned function will take a\n      second argument for the parameters of the state derivative and keep params\n      generic. If false, the returned function will take a single state argument,\n      and the supplied params will be hardcoded; moreover, the resulting compiled\n      function will not be cached.\n\n    - `:mode`: Explicitly set the compilation mode to one of the values\n      in [[valid-modes]]. Explicit alternative to dynamically binding [[*mode*]].\n\n    - `:cache`: If falsy, the compilation cache is avoided (it will neither\n      be consulted nor updated).\n\n    - `:gensym-fn` allows injection of a symbol generator for unit test\n      purposes\n\n    - `:arity` records the arity selected for a compiled non-state function\n      and is ordinarily provided automatically by [[compile-fn]].\n\n    - `:simplify?` If `true`, simplify the expanded function body before proceeding\n      to subexpression elimination and successive steps. If `false`, skip this step.\n      Defaults to `true`.\n\n  The returned, compiled function expects all `Double` (or `js/Number`) for all\n  state primitives. The function body is simplified and all common\n  subexpressions identified during compilation are extracted and computed only\n  once.\n\n  Function compilations are cached with a key that attempts to capture all of\n  the relevant information ",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Fw,$APP.SU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Fw,$APP.SU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,7,5,$APP.I,[kW,UW,ZT,IY,iY,kS,fY],null),$APP.Kl,new $APP.f(null,6,[kW,cW,UW,iV,IY,$APP.M($APP.wv,$APP.Fw),iY,$APP.M(lY,4),kS,!0,fY,!0],null)],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Fw,$APP.SU],null),new $APP.H(null,4,
5,$APP.I,[$APP.Kv,$APP.Fw,$APP.SU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,7,5,$APP.I,[kW,UW,ZT,IY,iY,kS,fY],null),$APP.Kl,new $APP.f(null,6,[kW,cW,UW,iV,IY,$APP.M($APP.wv,$APP.Fw),iY,$APP.M(lY,4),kS,!0,fY,!0],null)],null)],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,Pdc,$APP.X,$APP.KR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a compiled, simplified function with signature `(f state params?)`,\n  given:\n\n  - a state function that can accept a symbolic arguments\n\n  - `params`: really any sequence of count equal to the number of arguments\n    taken by `f`. The values are ignored. If the specific value `false` is\n    provided, then `f` is considered to be the function to compile itself, and not\n    the producer of such a function via application of parameters.\n\n  - `initial-state`: Some structure of the same shape as the argument expected\n    by the fn returned by the state function `f`. Only the shape matters; the\n    values are ignored.\n\n  - an optional argument `opts`. Options accepted are:\n\n    - `:calling-convention`: May have one of the following values. (In\n      each of these examples, assume that the initial state\n      `(up 1 (up 2 3) (up 3 4)) has been provided.)\n\n      - `:structure`: The arguments to the compiled function will have\n        the same shape as the initial-state, and elements of that state\n        will be made available to the function via argument destructuring\n        in function signature, e.g.:\n\n        ```clojure\n        (fn [[y1 [y2 y3] [y4 y5]]] [p1 ...] ...)\n        ```\n\n      - `:primitive`: The compiled function will expect a primitive array\n        containing the state in flat form to be passed as the first\n        argument, and will return its value by mutating its second argument,\n        which will also be a primitive array of the same size. The parameters\n        will be provided via a third primitive array:\n\n        ```clojure\n        (fn [ys yps ps] ...)\n        ```\n\n        This is the fastest form, as no allocations are needed to destructure\n        arguments list or to construct the return value, but requires the use\n        of primitive arrays (not general Clojure sequences, even if mutable) by\n        the caller. The generated code will use `aget` and `aset` on the arrays.\n\n    - `:generic-params?`: if `true` (default), the returned function will take a\n      second argument for the parameters of the state derivative and keep params\n      generic. If false, the returned function will take a single state argument,\n      and the supplied params will be hardcoded; moreover, the resulting compiled\n      function will not be cached.\n\n    - `:mode`: Explicitly set the compilation mode to one of the values\n      in [[valid-modes]]. Explicit alternative to dynamically binding [[*mode*]].\n\n    - `:cache`: If falsy, the compilation cache is avoided (it will neither\n      be consulted nor updated).\n\n    - `:gensym-fn` allows injection of a symbol generator for unit test\n      purposes\n\n    - `:arity` records the arity selected for a compiled non-state function\n      and is ordinarily provided automatically by [[compile-fn]].\n\n    - `:simplify?` If `true`, simplify the expanded function body before proceeding\n      to subexpression elimination and successive steps. If `false`, skip this step.\n      Defaults to `true`.\n\n  The returned, compiled function expects all `Double` (or `js/Number`) for all\n  state primitives. The function body is simplified and all common\n  subexpressions identified during compilation are extracted and computed only\n  once.\n\n  Function compilations are cached with a key that attempts to capture all of\n  the relevant information ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Fw,$APP.SU],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Fw,$APP.SU,new $APP.f(null,2,[$APP.zu,new $APP.H(null,7,5,$APP.I,[kW,UW,ZT,IY,iY,kS,fY],null),$APP.Kl,new $APP.f(null,6,[kW,cW,UW,iV,IY,$APP.M($APP.wv,$APP.Fw),iY,$APP.M(lY,4),kS,!0,fY,!0],null)],null)],null))],null)],null),gcc,new $APP.f(null,3,[$APP.R,vRb,$APP.X,uQ,$APP.h,$APP.F],null),$APP.z(gXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[kW],null))),
$APP.P,"Given a keyword `mode` specifying a compilation mode, returns `mode` if valid,\n  and throws otherwise."],null)),new $APP.f(null,3,[$APP.R,lub,$APP.X,h8a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a keyword `mode` specifying a compilation mode, returns `mode` if valid,\n  and throws otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[kW],null))],null)],null),$APP.z(nPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[I9b],null))),$APP.P,"Given an unevaluated source code form `f-form` representing a function,\n  evaluates `f-form` using the bindings in [[sci-context]].\n\n  Generate these forms by setting `*mode*` to `:source`."],
null)),new $APP.f(null,3,[$APP.R,k0b,$APP.X,q8a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an unevaluated source code form `f-form` representing a function,\n  evaluates `f-form` using the bindings in [[sci-context]].\n\n  Generate these forms by setting `*mode*` to `:source`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[I9b],null))],null)],null)],null),$APP.Zo(RQb)),$APP.ap($APP.fg([$APP.z(j_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,
5,$APP.I,[$APP.Kv,IV,zY],null)))],null)),$APP.z(u1b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null))),$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns the result of aggregating either `xs` or `(map f (range low\n  high))` using the fold dynamically bound to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (sum inc 0 10))\n  ;;\x3d\x3e [55.0 1 10]\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z($APP.R3b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[ET,rT,hX,$APP.tx],null),new $APP.H(null,5,5,$APP.I,[ET,rT,hX,$APP.tx,
TV],null))),$APP.P,"Similar to [[monoid]] for types with invertible elements. Accepts:\n\n  - binary `minus` and (associative) `plus` functions\n  - a unary `negate` function\n  - an element `id` that obeys `(plus id other) \x3d\x3d (plus other id) \x3d\x3d other`\n  - optionally, an `annihilate?` function that should return true for any `x`\n    such that `(plus x \x3cany\x3e) \x3d\x3d x`.\n\n  And returns a function that will SUBTRACT elements. Given `x`, `y`, `z`, for\n  example, the returned function will return `(- x y z)`, implemented as `(minus\n  x (plus y z))`\n\n  If the `annihilate?` function is supplied, then if the aggregation produces a\n  value that returns `(annihilate? true)` at any point, the reduction will\n  return immediately.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,5,$APP.nw,5,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[ET,rT,hX,$APP.tx],null),new $APP.H(null,5,5,$APP.I,[ET,rT,hX,$APP.tx,TV],null)],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[ET,rT,hX,$APP.tx],null),new $APP.H(null,5,5,$APP.I,[ET,rT,hX,$APP.tx,TV],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(BZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.sw,$APP.gT,$APP.zv,gU],null))),$APP.P,"NOTE that the returned function recurs on increasing indices internally instead\n  of walking through the lists directly. This method of traversing vectors is\n  more efficient, and this function is called so often that the performance gain\n  is worth it, and reads almost like the explicit sequence traversal."],
null)),$APP.z(Gjb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[rT,$APP.tx],null),new $APP.H(null,3,5,$APP.I,[rT,$APP.tx,TV],null))),$APP.P,"Accepts a binary (associative) aggregation function `plus` and an identity\n  element `id` and returns a multi-arity function that will combine its\n  arguments via `plus`. A 0-arity call returns `id`.\n\n  optionally takes an `annihilate?` function that should return true for any `x`\n  such that `(plus x \x3cany\x3e) \x3d\x3d x`.\n\n  If the `annihilate?` function is supplied, then if the aggregation produces a\n  value that returns `(annihilate? true)` at any point, the reduction will\n  return immediately.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[rT,$APP.tx],null),new $APP.H(null,3,5,$APP.I,[rT,$APP.tx,TV],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[rT,$APP.tx],null),new $APP.H(null,3,5,$APP.I,[rT,$APP.tx,TV],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(CSb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null))),$APP.P,
"Given a vector of numbers, returns the [pairwise\n  summation](https://en.wikipedia.org/wiki/Pairwise_summation) of the vector\n  generated by arranging the vector into a binary tree and summing leaves\n  together all the way up to the root.\n\n  If `xs` is _not_ a vector, [[pairwise-sum]] will realize all elements into a\n  vector before operating.\n\n  If the initial vector, or some recursive slice, reaches a count\n  \x3c\x3d [[*cutoff*]], [[pairwise-sum]] defers to `(reduce + xs)`.\n\n  ### Performance Discussion\n\n  [[pairwise-sum]] is perhaps 10% faster than [[sum]]\n  with [[emmy.algebra.fold/kbn]] bound to [[*fold*]], but has poorer bounds\n  on its error growth. Instead of having roughly constant error regardless of\n  the size of the input, in the worst case its accumulated error grows with\n  $O(\\log n)$.\n\n  This improvement is due to the fact that [[pairwise-sum]] tends to add up\n  numbers of similar magnitude, instead of adding deltas into a progressively\n  larger sum.\n\n  This implementation was inspired by the `pairwiseSum` implementation in\n  the [`math-functions`](https://hackage.haskell.org/package/math-functions-0.3.4.2/docs/src/Numeric.Sum.html#pairwiseSum)\n  Haskell package. The notes above were adapted from that function's docs.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(oJb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(fEb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(hvb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null))),$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns a lazy sequence of all intermediate values seen while aggregating\n  either `xs` or `(map f (range low high))` using the fold dynamically bound\n  to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (scan inc 0 3))\n  ;;\x3d\x3e ([1.0 1 1] [3.0 1 2] [6.0 1 3])\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null)),$APP.zx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.R,oVb,$APP.X,hL,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,
IV,zY],null))],null)],null),new $APP.f(null,3,[$APP.R,mhb,$APP.X,FQ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns the result of aggregating either `xs` or `(map f (range low\n  high))` using the fold dynamically bound to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (sum inc 0 10))\n  ;;\x3d\x3e [55.0 1 10]\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null))],null)],null),new $APP.f(null,3,[$APP.R,n6b,$APP.X,N_,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[monoid]] for types with invertible elements. Accepts:\n\n  - binary `minus` and (associative) `plus` functions\n  - a unary `negate` function\n  - an element `id` that obeys `(plus id other) \x3d\x3d (plus other id) \x3d\x3d other`\n  - optionally, an `annihilate?` function that should return true for any `x`\n    such that `(plus x \x3cany\x3e) \x3d\x3d x`.\n\n  And returns a function that will SUBTRACT elements. Given `x`, `y`, `z`, for\n  example, the returned function will return `(- x y z)`, implemented as `(minus\n  x (plus y z))`\n\n  If the `annihilate?` function is supplied, then if the aggregation produces a\n  value that returns `(annihilate? true)` at any point, the reduction will\n  return immediately.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[ET,rT,hX,$APP.tx],null),new $APP.H(null,5,5,$APP.I,[ET,rT,hX,$APP.tx,TV],null))],null)],null),new $APP.f(null,3,[$APP.R,Umb,$APP.X,bUa,$APP.h,new $APP.f(null,2,[$APP.P,"NOTE that the returned function recurs on increasing indices internally instead\n  of walking through the lists directly. This method of traversing vectors is\n  more efficient, and this function is called so often that the performance gain\n  is worth it, and reads almost like the explicit sequence traversal.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.sw,$APP.gT,$APP.zv,gU],null))],null)],null),new $APP.f(null,3,[$APP.R,Wgb,$APP.X,M_,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a binary (associative) aggregation function `plus` and an identity\n  element `id` and returns a multi-arity function that will combine its\n  arguments via `plus`. A 0-arity call returns `id`.\n\n  optionally takes an `annihilate?` function that should return true for any `x`\n  such that `(plus x \x3cany\x3e) \x3d\x3d x`.\n\n  If the `annihilate?` function is supplied, then if the aggregation produces a\n  value that returns `(annihilate? true)` at any point, the reduction will\n  return immediately.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[rT,$APP.tx],null),new $APP.H(null,3,5,$APP.I,[rT,$APP.tx,TV],null))],null)],null),new $APP.f(null,3,[$APP.R,stb,$APP.X,L_,$APP.h,new $APP.f(null,2,[$APP.P,"Given a vector of numbers, returns the [pairwise\n  summation](https://en.wikipedia.org/wiki/Pairwise_summation) of the vector\n  generated by arranging the vector into a binary tree and summing leaves\n  together all the way up to the root.\n\n  If `xs` is _not_ a vector, [[pairwise-sum]] will realize all elements into a\n  vector before operating.\n\n  If the initial vector, or some recursive slice, reaches a count\n  \x3c\x3d [[*cutoff*]], [[pairwise-sum]] defers to `(reduce + xs)`.\n\n  ### Performance Discussion\n\n  [[pairwise-sum]] is perhaps 10% faster than [[sum]]\n  with [[emmy.algebra.fold/kbn]] bound to [[*fold*]], but has poorer bounds\n  on its error growth. Instead of having roughly constant error regardless of\n  the size of the input, in the worst case its accumulated error grows with\n  $O(\\log n)$.\n\n  This improvement is due to the fact that [[pairwise-sum]] tends to add up\n  numbers of similar magnitude, instead of adding deltas into a progressively\n  larger sum.\n\n  This implementation was inspired by the `pairwiseSum` implementation in\n  the [`math-functions`](https://hackage.haskell.org/package/math-functions-0.3.4.2/docs/src/Numeric.Sum.html#pairwiseSum)\n  Haskell package. The notes above were adapted from that function's docs.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null))],null)],null),new $APP.f(null,3,[$APP.R,tPb,$APP.X,DI,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Vzb,$APP.X,128,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,g0b,$APP.X,BI,$APP.h,new $APP.f(null,2,[$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns a lazy sequence of all intermediate values seen while aggregating\n  either `xs` or `(map f (range low high))` using the fold dynamically bound\n  to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (scan inc 0 3))\n  ;;\x3d\x3e ([1.0 1 1] [3.0 1 2] [6.0 1 3])\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,IV,zY],null))],null)],null)]),$APP.Zo(V6b)),$APP.ap($APP.fg([$APP.z(fsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.f(null,1,[$APP.zu,new $APP.H(null,3,5,$APP.I,[IT,sX,eib],null)],null)],null))),$APP.P,"Returns a fn that returns true if any of the following are true::\n\n  - the supplied `fn-counter` atom contains a value \x3e `maxfun`\n  - the loop has exceeded `maxiter` iterations\n\n  false otherwise.\n  "],
null)),$APP.z(dT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.f(null,1,[$APP.zu,new $APP.H(null,3,5,$APP.I,[Vkb,ptb,xnb],null)],null)],null))),$APP.P,"Returns a fn that returns true if any of the following are true:\n\n  - the max interior value is within `fn-tolerance` of the smallest bound,\n  - `convergence?` (if supplied) returns true\n  - the bounds are within `arg-tolerance` absolute distance,\n\n  false otherwise."],null)),$APP.z(dbb,new $APP.f(null,2,
[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Zab,LTb],null))),$APP.P,"Returns the point between `from` and `to` that cuts the region between the two\n  into two sections in golden-ratioed proportion to each other.\n\n  For example, depending on the ordering of `from` and `to`, `x` would be\n  either:\n\n  ```\n  from------x1---to\n  to---x2------from\n  ```\n\n  Such that `from-\x3ex1 / from-\x3eto \x3d\x3d to-\x3ex2 / from-\x3ex1`."],null)),$APP.z(OOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,new $APP.f(null,3,[$APP.zu,new $APP.H(null,2,5,$APP.I,[WX,$APP.Dw],null),$APP.Kl,new $APP.f(null,2,[WX,iW,$APP.Dw,$APP.M($APP.cw,null)],null),$APP.ck,$APP.Lx],null)],null))),$APP.P,"Golden Section search attempts to locate the minimum of the supplied function\n  `f` by evaluating points located at golden-ratioed intervals between the two\n  starting endpoints `a` and `b`. This method is slow, steady and reliable.\n\n  Supports the following optional keyword arguments:\n\n  `:converged?` is an optional predicate accepting five arguments:\n\n  - `[a fa]`\n  - `[l fl]`\n  - `[r fr]`\n  - `[b fb]`\n  - `current-iteration`\n\n  If the supplied `fn` returns true, it will signal convergence and the\n  optimizer will return. Returning false will continue.\n\n  `:choose` is called at the final step of optimization with all 4 points and\n  their fn values (see the first four arguments to `:converged?`), and returns\n  the final choice.\n\n  `:callback` receives all 5 arguments on every iteration.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n\n  `:fn-tolerance` check that the minimal value of any of the checked points is\n  within the maximum of f(a) or f(b).\n\n  `:arg-tolerance` check that `a` and `b` are within this supplied absolute\n  distance.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,new $APP.f(null,3,[$APP.zu,new $APP.H(null,2,5,$APP.I,[WX,$APP.Dw],null),$APP.Kl,new $APP.f(null,2,[WX,iW,$APP.Dw,$APP.M($APP.cw,null)],null),$APP.ck,$APP.Lx],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,new $APP.f(null,3,[$APP.zu,new $APP.H(null,
2,5,$APP.I,[WX,$APP.Dw],null),$APP.Kl,new $APP.f(null,2,[WX,iW,$APP.Dw,$APP.M($APP.cw,null)],null),$APP.ck,$APP.Lx],null)],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(WR,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z($Ab,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(iW,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Ybc],null))),$APP.P,"Default selection function for the best possible point. This function chooses\n  the point out of (a, l, r, b) with the minimum function value.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(Ybc)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Ybc],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(fPb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,$APP.Lx],null))),$APP.P,"For convenience, we also provide the sister-procedure for finding\n  the maximum of a unimodal function using the golden section method.\n\n  Negate the function, minimize, negate the result.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,4,$APP.nw,4,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,$APP.Lx],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,$APP.Lx],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(zVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,OHb],null))),$APP.P,"generate a new point by extending x away from `away-from`. The invariant is\n  that `x` sits between the new point and `away-from` at the golden ratio\n  point."],
null)),$APP.z(Hdc,new $APP.f(null,1,[$APP.Kw,!0],null))],[new $APP.f(null,3,[$APP.R,rVb,$APP.X,S7a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a fn that returns true if any of the following are true::\n\n  - the supplied `fn-counter` atom contains a value \x3e `maxfun`\n  - the loop has exceeded `maxiter` iterations\n\n  false otherwise.\n  ",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.f(null,1,[$APP.zu,new $APP.H(null,3,5,$APP.I,[IT,sX,eib],null)],null)],null))],null)],null),new $APP.f(null,
3,[$APP.R,rLb,$APP.X,Q7a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a fn that returns true if any of the following are true:\n\n  - the max interior value is within `fn-tolerance` of the smallest bound,\n  - `convergence?` (if supplied) returns true\n  - the bounds are within `arg-tolerance` absolute distance,\n\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.f(null,1,[$APP.zu,new $APP.H(null,3,5,$APP.I,[Vkb,ptb,xnb],null)],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,
rXb,$APP.X,rQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the point between `from` and `to` that cuts the region between the two\n  into two sections in golden-ratioed proportion to each other.\n\n  For example, depending on the ordering of `from` and `to`, `x` would be\n  either:\n\n  ```\n  from------x1---to\n  to---x2------from\n  ```\n\n  Such that `from-\x3ex1 / from-\x3eto \x3d\x3d to-\x3ex2 / from-\x3ex1`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[Zab,LTb],null))],null)],null),new $APP.f(null,
3,[$APP.R,q9b,$APP.X,S3,$APP.h,new $APP.f(null,2,[$APP.P,"Golden Section search attempts to locate the minimum of the supplied function\n  `f` by evaluating points located at golden-ratioed intervals between the two\n  starting endpoints `a` and `b`. This method is slow, steady and reliable.\n\n  Supports the following optional keyword arguments:\n\n  `:converged?` is an optional predicate accepting five arguments:\n\n  - `[a fa]`\n  - `[l fl]`\n  - `[r fr]`\n  - `[b fb]`\n  - `current-iteration`\n\n  If the supplied `fn` returns true, it will signal convergence and the\n  optimizer will return. Returning false will continue.\n\n  `:choose` is called at the final step of optimization with all 4 points and\n  their fn values (see the first four arguments to `:converged?`), and returns\n  the final choice.\n\n  `:callback` receives all 5 arguments on every iteration.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n\n  `:fn-tolerance` check that the minimal value of any of the checked points is\n  within the maximum of f(a) or f(b).\n\n  `:arg-tolerance` check that `a` and `b` are within this supplied absolute\n  distance.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,new $APP.f(null,3,[$APP.zu,new $APP.H(null,2,5,$APP.I,[WX,$APP.Dw],null),$APP.Kl,new $APP.f(null,2,[WX,iW,$APP.Dw,$APP.M($APP.cw,null)],null),$APP.ck,$APP.Lx],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,ozb,$APP.X,K7a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,oOb,$APP.X,I7a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,NJb,$APP.X,R3,$APP.h,new $APP.f(null,2,[$APP.P,"Default selection function for the best possible point. This function chooses\n  the point out of (a, l, r, b) with the minimum function value.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Ybc],null))],null)],null),new $APP.f(null,3,[$APP.R,vdc,$APP.X,T3,$APP.h,new $APP.f(null,2,[$APP.P,"For convenience, we also provide the sister-procedure for finding\n  the maximum of a unimodal function using the golden section method.\n\n  Negate the function, minimize, negate the result.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,PW,QW],null),new $APP.H(null,4,5,$APP.I,[$APP.Kv,PW,QW,$APP.Lx],null))],null)],null),new $APP.f(null,3,[$APP.R,
Aeb,$APP.X,sQ,$APP.h,new $APP.f(null,2,[$APP.P,"generate a new point by extending x away from `away-from`. The invariant is\n  that `x` sits between the new point and `away-from` at the golden ratio\n  point.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,OHb],null))],null)],null),new $APP.f(null,3,[$APP.R,Hwb,$APP.X,J7a,$APP.h,$APP.F],null)]),$APP.Zo(Ekb)),$APP.ap(new $APP.f(null,8,[$APP.z(WMb,new $APP.f(null,1,[$APP.Kw,!0],null)),new $APP.f(null,3,[$APP.R,N9b,$APP.X,qTa,$APP.h,$APP.F],null),
$APP.z(acc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null))),$APP.P,"Used as a [data reader](https://www.clojurescript.org/guides/reader#_clojurescript_compilation).\n  In Clojure, we could get away with just using the constructor above, but in\n  ClojureScript we need to act as a macro to delay evaluation of the constructor."],null)),new $APP.f(null,3,[$APP.R,Whb,$APP.X,ETa,$APP.h,new $APP.f(null,2,[$APP.P,"Used as a [data reader](https://www.clojurescript.org/guides/reader#_clojurescript_compilation).\n  In Clojure, we could get away with just using the constructor above, but in\n  ClojureScript we need to act as a macro to delay evaluation of the constructor.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null))],null)],null),$APP.z(Wrb,new $APP.f(null,1,[$APP.Kw,!0],null)),new $APP.f(null,3,[$APP.R,v0b,$APP.X,sTa,$APP.h,$APP.F],null),$APP.z(CU,new $APP.f(null,1,[$APP.Kw,!0],null)),new $APP.f(null,3,[$APP.R,Dsb,$APP.X,nG,$APP.h,$APP.F],null),$APP.z(dY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null))),$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,uG,$APP.X,wG,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null))],null)],null),$APP.z(wlb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise."],null)),new $APP.f(null,3,[$APP.R,eeb,$APP.X,vG,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],
null)],null),$APP.z(y5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.TP],null))),$APP.P,"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values. (Note: the use of cast-to-double is\n   unfortunate here, as complex numbers can now contain exact fractions, and\n   we'd want a nearest integer generic function for those)"],null)),
new $APP.f(null,3,[$APP.R,GNb,$APP.X,FTa,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values. (Note: the use of cast-to-double is\n   unfortunate here, as complex numbers can now contain exact fractions, and\n   we'd want a nearest integer generic function for those)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.TP],
null))],null)],null),$APP.z(Bpb,new $APP.f(null,1,[$APP.Kw,!0],null)),new $APP.f(null,3,[$APP.R,$xb,$APP.X,mnc,$APP.h,$APP.F],null)],null),$APP.Zo(Rgb)),$APP.ap($APP.fg([$APP.z(cmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null))),$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(oW,$APP.Vw,oS)],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(xgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[VV,xU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(ZFb,VV,xU)],null)],null)))),$APP.P,"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components-\x3evector-field\n     (up x y)\n     (coordinate-system-\x3evector-basis R2-rect)))\n  ;; \x3d\x3e (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field-\x3ebasis-components]]"],
null)),$APP.z(fcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[tNb],null))),$APP.P,"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!"],null)),$APP.z(i4a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))),$APP.P,"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0."],
null)),$APP.z(G8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ex,rW],null))),$APP.P,"Given a vector field `vf` generated from [[basis-components-\x3evector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis-\x3edual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system-\x3evector-basis coordsys)\n        dual  (basis/vector-basis-\x3edual basis coordsys)]\n    (\x3d basis-components\n       (-\x3e basis-components\n           (basis-components-\x3evector-field basis)\n           (vector-field-\x3ebasis-components dual))))\n  ```"],
null)),$APP.z(wdc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.ex,oW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(cV,$APP.ex)],null)],null)))),$APP.P,"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field-\x3ecomponents f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;\x3d\x3e (up (f0 (up x0 y0))\n  ;;       (f1 (up x0 y0)))\n  ```"],
null)),$APP.z(a6b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ex,oW],null))),$APP.P,"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`."],null)),$APP.z(cV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ex],null))),$APP.P,"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise."],null)),$APP.z(pnb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null))),$APP.P,"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Vib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied."],
null)),$APP.z(w8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,oW],null))),$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3evector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument."],
null))],[new $APP.f(null,3,[$APP.R,A_b,$APP.X,YO,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.",$APP.U,$APP.M(new $APP.H(null,
4,5,$APP.I,[oW,$APP.Vw,$APP.Lh,oS],null))],null)],null),new $APP.f(null,3,[$APP.R,LYb,$APP.X,l4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components-\x3evector-field\n     (up x y)\n     (coordinate-system-\x3evector-basis R2-rect)))\n  ;; \x3d\x3e (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[VV,xU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(ZFb,VV,xU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,X5b,$APP.X,p4a,$APP.h,new $APP.f(null,2,[$APP.P,"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[tNb],null))],null)],null),new $APP.f(null,3,[$APP.R,
gyb,$APP.X,h4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))],null)],null),new $APP.f(null,3,[$APP.R,qvb,$APP.X,m4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a vector field `vf` generated from [[basis-components-\x3evector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis-\x3edual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system-\x3evector-basis coordsys)\n        dual  (basis/vector-basis-\x3edual basis coordsys)]\n    (\x3d basis-components\n       (-\x3e basis-components\n           (basis-components-\x3evector-field basis)\n           (vector-field-\x3ebasis-components dual))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ex,rW],null))],null)],null),new $APP.f(null,3,[$APP.R,RVb,$APP.X,g4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field-\x3ecomponents f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;\x3d\x3e (up (f0 (up x0 y0))\n  ;;       (f1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.ex,oW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(cV,$APP.ex)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,MTb,$APP.X,o4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ex,oW],null))],null)],null),new $APP.f(null,3,[$APP.R,Eec,$APP.X,UO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ex],null))],null)],null),new $APP.f(null,3,[$APP.R,xQb,$APP.X,XO,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[VV,oW],null),new $APP.H(null,3,5,$APP.I,[VV,oW,$APP.Vw],null))],null)],null),new $APP.f(null,3,[$APP.R,LX,$APP.X,ZO,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,lAb,$APP.X,j4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3evector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,oW],null))],null)],null)]),$APP.Zo(fZb)),$APP.ap($APP.fg([B2b,$APP.z(QYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[DW,YS],null))),$APP.P,"Takes an operator symbol `op` and an identity element `constant` and returns a\n  rule that turns binary forms with `constant` on either side into `constant`.\n\n  This rule is useful for commutative annihilators like:\n\n  ```clojure\n  (* 0 \x3canything\x3e) \x3d\x3e 0\n  (and false \x3canything\x3e) \x3d\x3e false\n  (or true \x3canything\x3e) \x3d\x3e true\n  ```"],
null)),Pnb,edc,$APP.z(K8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))),$APP.P,"Returns a rule simplifier of rules that are almost always helpful."],null)),$APP.z($APP.Hw,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(qcb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null)))],null)),Tcc,$APP.z(tEb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Lh,cS],null))),$APP.P,"Returns a simplifier that will remove consecutive duplicate arguments to any\n  of the operations supplied as `ops`. Acts as identity otherwise.\n\n  ```clojure\n  (let [rule (idempotent 'and)]\n    (\x3d '(and a b c d)\n       (rule '(and a b b c c c d))))\n  ```",$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(cS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null)),$APP.zx,$APP.M(null)],null)],null)),
$APP.z(rpb,new $APP.f(null,1,[$APP.gm,!0],null)),qTb,$APP.z(yAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),fnb,Yxb,Q0b,g_b,Gsb,$APP.z(LAb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(jBb,new $APP.f(null,1,[$APP.gm,!0],null)),Cnb,$APP.z(PSb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(kWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))),$APP.P,
"Simplifications for various exponent forms (assuming commutative multiplication).\n\n  NOTE that we have some similarities to [[exponent-contract]] above - that\n  function works for non-commutative multiplication - AND that this needs a new\n  name."],null)),fYb,$APP.z(vyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))),$APP.P,"TODO consolidate the symbolic checkers here with the constructor\n  simplifications in [[trig:special]]. "],null)),$APP.z($Kb,new $APP.f(null,
1,[$APP.gm,!0],null)),$APP.z(zQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null)))],null)),$APP.z(Pfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[DW,YS],null))),$APP.P,"Takes an operator symbol `op` and an identity element `constant` and returns a\n  rule that eliminates instances of `constant` inside any-arity forms like\n\n  ```clojure\n  (\x3cop\x3e ,,,args,,,)\n  ```"],null)),KJb,$APP.z(BQb,new $APP.f(null,1,[$APP.gm,!0],null)),
$APP.z(Ulb,new $APP.f(null,1,[$APP.gm,!0],null)),Slb,xhb,$APP.z(Tmb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null)))],null)),Ibb,$APP.z(hec,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(ecc,new $APP.f(null,1,[$APP.gm,!0],null)),A7b,$APP.z(OMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))),$APP.P,"Returns a rule simplifier that attempts to simplify nested exp and log forms.\n\n  You can tune the behavior of this simplifier with [[*log-exp-simplify?*]]\n  and [[*sqrt-expt-simplify?*]].\n\n  NOTE: [[logexp]] returns a `rule-simplifier`, which memoizes its traversal\n  through the supplied expression. This means that if you try to\n  customize [[logexp]] with dynamic binding variables AFTER passing an\n  expression into it, you may get a memoized result which used the previous\n  dynamic binding.\n\n  This is a problem we should address!"],
null)),wHb,$APP.z(UTb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null))),$APP.P,"Takes any number of operator symbols `ops` like `'+`, `'*` and returns a rule\n  that sorts the argument list of any multiple-arity call to any of the supplied\n  operators. Sorting is accomplished with [[emmy.expression/sort]].\n\n  For example:\n\n  ```clojure\n  (let [rule (commutative '* '+)]\n    (\x3d '(* 2 3 a b c (+ c a b))\n       (rule '(* c a b (+ c a b) 3 2))))\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(cS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(o1b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.tx],null),new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.tx],null))),$APP.P,"Takes one or two simplified expressions `x` and `y` and a symbolic identifier\n  `id` and registers an assumption that both sides are non-negative.\n\n  Returns the conjuction of both assumptions in the two argument case, or the\n  single assumption in the one-argument case.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.tx],null),new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.tx],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.tx],null),new $APP.H(null,3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.tx],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(JQb,new $APP.f(null,1,[$APP.gm,!0],null)),AK,whb,$APP.z(ILb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$R],null))),$APP.P,"Returns a rule simplifier that distributes the radical sign across products and\n  quotients. The companion rule [[sqrt-contract]] reassembles what remains.\n\n  NOTE that doing this may allow equal subexpressions within the radicals to\n  cancel in various ways.\n\n  Turn this simplifier on and off with [[*sqrt-factor-simplify?*]]."],null)),Fnb,Zcb,$APP.z(Zmb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null)))],null)),$APP.z(qSb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null)))],null)),$APP.z(b2b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(eZb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(imb,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(Ujb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(Yac,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],
null)))],null)),$APP.z(eXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null)))],null)),y1b,$APP.z(M3b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null))),$APP.P,"Takes a sequence `ops` of operator symbols like `'+`, `'*` and returns a rule\n  that strips these operations off of unary applications.\n\n  ```clojure\n  (let [rule (unary-elimination '+ '*)\n        f    (rule-simplifier rule)]\n    (f '(+ x y (* z) (+ a))))\n  ;;\x3d\x3e (+ x y z a)\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(cS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null)),$APP.zx,$APP.M(null)],null)],null)),W$b,$APP.z($APP.FAa,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),kLb,$APP.z(F7b,new $APP.f(null,1,[$APP.gm,!0],null)),$APP.z(eNb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null)))],null)),$APP.z(rnb,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null))),$APP.P,"Takes any number of operator symbols `ops` like `'+`, `'*` and returns a rule\n  that collapses nested applications of each operation into a single\n  sequence. (The associative property lets us strip parentheses.)\n\n  ```clojure\n  (let [rule (associative '+ '*)\n        f    (rule-simplifier rule)]\n    (\x3d (+ x y z a (* b c d) cake face)\n       (f '(+ x (+ y (+ z a) (* b (* c d))\n                   (+ cake face))))))\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M(cS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null)),$APP.zx,$APP.M(null)],null)],null))],[new $APP.f(null,3,[$APP.R,Qdc,$APP.X,Qpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,h3b,$APP.X,function(a,b){return uJ.C($APP.y([kJ(vJ.A(new $APP.D(null,a,new $APP.D(null,$APP.Hv,new $APP.D(null,b,null,1,null),2,null),3,null),xJ),function(){return $APP.k(b)?b:dJ(b)}),kJ(vJ.A(new $APP.D(null,
a,new $APP.D(null,b,new $APP.D(null,$APP.Hv,null,1,null),2,null),3,null),xJ),function(){return $APP.k(b)?b:dJ(b)})]))},$APP.h,new $APP.f(null,2,[$APP.P,"Takes an operator symbol `op` and an identity element `constant` and returns a\n  rule that turns binary forms with `constant` on either side into `constant`.\n\n  This rule is useful for commutative annihilators like:\n\n  ```clojure\n  (* 0 \x3canything\x3e) \x3d\x3e 0\n  (and false \x3canything\x3e) \x3d\x3e false\n  (or true \x3canything\x3e) \x3d\x3e true\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[DW,YS],null))],null)],null),new $APP.f(null,3,[$APP.R,qsb,$APP.X,w1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,M6b,$APP.X,y1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,X4b,$APP.X,zZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule simplifier of rules that are almost always helpful.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,hjb,$APP.X,GYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,p0b,$APP.X,uZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,Ogb,$APP.X,Upc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,onb,$APP.X,b2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a simplifier that will remove consecutive duplicate arguments to any\n  of the operations supplied as `ops`. Acts as identity otherwise.\n\n  ```clojure\n  (let [rule (idempotent 'and)]\n    (\x3d '(and a b c d)\n       (rule '(and a b b c c c d))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null))],null)],null),new $APP.f(null,3,[$APP.R,v$b,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Feb,$APP.X,i1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,$tb,$APP.X,JYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,JEb,$APP.X,Mpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,hxb,$APP.X,q1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,BMb,$APP.X,Npc,
$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,HSb,$APP.X,Rpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,qdb,$APP.X,t1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,uNb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,alb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,e8b,$APP.X,Vpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,cGb,$APP.X,EYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Sac,$APP.X,
UYa,$APP.h,new $APP.f(null,2,[$APP.P,"Simplifications for various exponent forms (assuming commutative multiplication).\n\n  NOTE that we have some similarities to [[exponent-contract]] above - that\n  function works for non-commutative multiplication - AND that this needs a new\n  name.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,DWb,$APP.X,s1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Lib,$APP.X,tZa,$APP.h,new $APP.f(null,2,[$APP.P,"TODO consolidate the symbolic checkers here with the constructor\n  simplifications in [[trig:special]]. ",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,iQb,$APP.X,!1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,uQb,$APP.X,hZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,TLb,$APP.X,LYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes an operator symbol `op` and an identity element `constant` and returns a\n  rule that eliminates instances of `constant` inside any-arity forms like\n\n  ```clojure\n  (\x3cop\x3e ,,,args,,,)\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[DW,YS],null))],null)],null),new $APP.f(null,3,[$APP.R,iEb,$APP.X,o1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,uHb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,xZb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,srb,$APP.X,Ppc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ajb,$APP.X,Tpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,oFb,$APP.X,sZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],
null),new $APP.f(null,3,[$APP.R,cJb,$APP.X,Kpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ZEb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,H_b,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,R4b,$APP.X,n1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,rfb,$APP.X,OYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule simplifier that attempts to simplify nested exp and log forms.\n\n  You can tune the behavior of this simplifier with [[*log-exp-simplify?*]]\n  and [[*sqrt-expt-simplify?*]].\n\n  NOTE: [[logexp]] returns a `rule-simplifier`, which memoizes its traversal\n  through the supplied expression. This means that if you try to\n  customize [[logexp]] with dynamic binding variables AFTER passing an\n  expression into it, you may get a memoized result which used the previous\n  dynamic binding.\n\n  This is a problem we should address!",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,f0b,$APP.X,vZa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,E9b,$APP.X,a2,$APP.h,new $APP.f(null,2,[$APP.P,"Takes any number of operator symbols `ops` like `'+`, `'*` and returns a rule\n  that sorts the argument list of any multiple-arity call to any of the supplied\n  operators. Sorting is accomplished with [[emmy.expression/sort]].\n\n  For example:\n\n  ```clojure\n  (let [rule (commutative '* '+)]\n    (\x3d '(* 2 3 a b c (+ c a b))\n       (rule '(* c a b (+ c a b) 3 2))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null))],null)],null),new $APP.f(null,3,[$APP.R,Ikb,$APP.X,RJ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes one or two simplified expressions `x` and `y` and a symbolic identifier\n  `id` and registers an assumption that both sides are non-negative.\n\n  Returns the conjuction of both assumptions in the two argument case, or the\n  single assumption in the one-argument case.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.tx],null),new $APP.H(null,
3,5,$APP.I,[$APP.Vv,$APP.SP,$APP.tx],null))],null)],null),new $APP.f(null,3,[$APP.R,z_b,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,YYb,$APP.X,yZa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,bjb,$APP.X,Spc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,FLb,$APP.X,bZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule simplifier that distributes the radical sign across products and\n  quotients. The companion rule [[sqrt-contract]] reassembles what remains.\n\n  NOTE that doing this may allow equal subexpressions within the radicals to\n  cancel in various ways.\n\n  Turn this simplifier on and off with [[*sqrt-factor-simplify?*]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,aHb,$APP.X,Lpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Unb,$APP.X,m1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,EJb,$APP.X,function(a){function b(d){var g=a.j?a.j(d):a.call(null,d),l=EJ.A;g=$APP.r(new $APP.H(null,2,5,$APP.I,[rM,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Fv,nH,g,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,4,nH,$APP.r(new $APP.H(null,2,5,$APP.I,[bT,$APP.r(new $APP.H(null,3,5,$APP.I,
[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,nH,g],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,4,nH],null))],null))],null))],null))],null))],null));l=l.call(EJ,g?g:dJ(g),zob);return $APP.k(l)?(d=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Fv,1,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,d],null))],null)),2],null))],null)))?d:dJ(d):l}function c(d){var g=a.j?a.j(d):a.call(null,d),l=EJ.A;g=$APP.r(new $APP.H(null,2,5,
$APP.I,[rM,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Fv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,2,nH],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,-1,g],null)),$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Ev,4,nH,$APP.r(new $APP.H(null,2,5,$APP.I,[bT,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.rj,g,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Ev,4,nH],null))],null))],null))],null))],null))],null));l=l.call(EJ,g?g:dJ(g),kHb);return $APP.k(l)?(d=$APP.r(new $APP.H(null,2,5,$APP.I,[FJ,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.rj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Gv,1,$APP.r(new $APP.H(null,2,5,$APP.I,[sH,d],null))],null)),2],null))],null)))?d:dJ(d):l}return nJ(pJ(function(){return!0},yJ.C($APP.y([uJ.C($APP.y([kJ(vJ.j(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,1,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,CJ,new $APP.D(null,BT,null,1,null),2,null),3,null),4,null),null,1,null),2,null)),function(d){d=$APP.r($APP.N.A(new $APP.H(null,
2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(d):CJ.call(null,d)],null),BT.j?BT.j(d):BT.call(null,d)));return c(d?d:dJ(d))}),kJ(vJ.j(new $APP.D(null,kH,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,CJ,new $APP.D(null,2,null,1,null),2,null),3,null),null,1,null),2,null)),function(d){return c(d.j?d.j(CJ):d.call(null,CJ))}),kJ(vJ.j(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.Ev,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,1,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,
CJ,new $APP.D(null,BT,null,1,null),2,null),3,null),4,null),null,1,null),2,null)),function(d){d=$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Ev,CJ.j?CJ.j(d):CJ.call(null,d)],null),BT.j?BT.j(d):BT.call(null,d)));return b(d?d:dJ(d))}),kJ(vJ.j(new $APP.D(null,sH,new $APP.D(null,new $APP.D(null,$APP.rj,new $APP.D(null,CJ,new $APP.D(null,2,null,1,null),2,null),3,null),null,1,null),2,null)),function(d){return b(d.j?d.j(CJ):d.call(null,CJ))})]))]))))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,Z6b,$APP.X,XYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,QTb,$APP.X,qJ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Htb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Fxb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Bqb,$APP.X,IYa,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,M2b,$APP.X,wZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,psb,$APP.X,iZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,Udb,$APP.X,x1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Elb,$APP.X,Z1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a sequence `ops` of operator symbols like `'+`, `'*` and returns a rule\n  that strips these operations off of unary applications.\n\n  ```clojure\n  (let [rule (unary-elimination '+ '*)\n        f    (rule-simplifier rule)]\n    (f '(+ x y (* z) (+ a))))\n  ;;\x3d\x3e (+ x y z a)\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null))],null)],null),new $APP.f(null,3,[$APP.R,Z4b,$APP.X,u1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,jhb,$APP.X,FYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Ajb,$APP.X,Opc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,MSb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,wWb,$APP.X,xZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$R],null))],null)],null),new $APP.f(null,3,[$APP.R,X9b,$APP.X,$1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes any number of operator symbols `ops` like `'+`, `'*` and returns a rule\n  that collapses nested applications of each operation into a single\n  sequence. (The associative property lets us strip parentheses.)\n\n  ```clojure\n  (let [rule (associative '+ '*)\n        f    (rule-simplifier rule)]\n    (\x3d (+ x y z a (* b c d) cake face)\n       (f '(+ x (+ y (+ z a) (* b (* c d))\n                   (+ cake face))))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,cS],null))],null)],null)]),$APP.Zo(wGb)),$APP.ap($APP.fg([$APP.z(bGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if x is an integral number that Clojure's math operations work\n  with, false otherwise."],null)),$APP.z(aKb,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,$APP.F],null),$APP.Lv,$APP.F,eU,$APP.M("@interface")],null)),$APP.z(Ezb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$8b],null)))],null)),$APP.z(hrb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,0,$APP.nw,0,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Mu)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null)),$APP.zx,$APP.M(null)],null)],null)),$APP.z(aXb,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,$APP.F],null),$APP.Lv,$APP.F,eU,$APP.M("@interface")],
null)),$APP.z(ZHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is either an integral number or a floating point number (i.e.,\n  in the numeric tower but not complex), false otherwise."],null)),$APP.z(hhb,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,new $APP.f(null,1,[$APP.z(YV,new $APP.f(null,1,[$APP.P,null],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Qu],null)],null)],null)],null),$APP.Lv,
new $APP.f(null,1,[z3b,new $APP.f(null,3,[$APP.R,YV,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qu],null)),$APP.P,null],null)],null),eU,$APP.M("@interface")],null)),$APP.z(gMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if x is an integral number, false otherwise."],null)),$APP.z(Ckb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(Rwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,
"Returns a predicate that returns true if its argument matches the supplied\n  kind-keyword `k`, false otherwise."],null)),$APP.z(tbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(Oxb,new $APP.f(null,1,[$APP.sj,$APP.my],null))],null))),$APP.P,"Returns a function that tests whether two values are within  of each other."],null)),$APP.Zv,tub,$APP.z($APP.sw,new $APP.f(null,3,[$APP.sj,$APP.Yu,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],
null))),$APP.P,"Comparator. Clone of [[cljs.core/compare]] that works with the expanded\n      Emmy numeric tower.\n\n  Returns a negative number, zero, or a positive number when x is logically\n  'less than', 'equal to', or 'greater than' y. Uses IComparable if available\n  and google.array.defaultCompare for objects of the same type and special-cases\n  nil to be less than any other object."],null)),$APP.z(Eob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[fGb],null)))],
null)),$APP.z($ac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Or],null))),$APP.P,"Mutates the native JS object `o` to have the given metadata. The\n       previous metadata, if any, is discarded. `o` is returned."],null)),$APP.z(Gyb,new $APP.f(null,4,[$APP.Nm,Bvb,$APP.sj,$APP.wv,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved."],
null)),$APP.z(Axb,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,new $APP.f(null,1,[$APP.z(Gyb,new $APP.f(null,2,[$APP.sj,$APP.wv,$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null)],null)],null)],null),$APP.Lv,new $APP.f(null,1,[iac,new $APP.f(null,3,[$APP.R,$APP.z(Gyb,new $APP.f(null,1,[$APP.sj,$APP.wv],null)),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)),$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved."],null)],null),eU,
$APP.M("@interface")],null)),$APP.z(AWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.tU],null))),$APP.P,"Make s callable. This is done by re-hosting all of the object properties of `s`\n      in a new native JS function which delegates to the Clojure application. The\n      result of the application of this new function is supplied to the continuation `k`."],null)),$APP.z($APP.Rx,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null))),$APP.P,"Returns true if `x` is any number type in the numeric tower:\n\n  - integral\n  - floating point\n  - complex\n  - fraction\n\n  false otherwise."],null)),$APP.z(szb,new $APP.f(null,1,[$APP.Kw,!0],null)),$APP.z(N$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true for anything that derives from `::scalar`, i.e., any numeric type in\n  the numeric tower that responds true to [[number?]], plus symbolic expressions\n  generated by [[emmy.abstract.number/literal-number]],\n\n  false otherwise."],
null)),$APP.z(YV,new $APP.f(null,3,[$APP.Nm,LY,$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qu],null)))],null))],[new $APP.f(null,3,[$APP.R,lMb,$APP.X,function(a){return $APP.xd(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if x is an integral number that Clojure's math operations work\n  with, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,yJb,$APP.X,function(){},$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.R,Kmb,$APP.X,TSa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$8b],null))],null)],null),new $APP.f(null,3,[$APP.R,cob,$APP.X,JP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Mu],null))],null)],null),new $APP.f(null,3,[$APP.R,msb,$APP.X,OSa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,E1b,$APP.X,DF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is either an integral number or a floating point number (i.e.,\n  in the numeric tower but not complex), false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,LY,$APP.X,AF,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,UPb,$APP.X,CF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if x is an integral number, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,dYb,$APP.X,JF,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,XVb,$APP.X,RSa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a predicate that returns true if its argument matches the supplied\n  kind-keyword `k`, false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,JXb,$APP.X,IF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that tests whether two values are within  of each other.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(Oxb,new $APP.f(null,1,[$APP.sj,$APP.my],null))],null))],null)],null),new $APP.f(null,3,[$APP.R,G5b,$APP.X,fG,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,qMb,$APP.X,SSa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,lnb,$APP.X,
HF,$APP.h,new $APP.f(null,2,[$APP.P,"Comparator. Clone of [[cljs.core/compare]] that works with the expanded\n      Emmy numeric tower.\n\n  Returns a negative number, zero, or a positive number when x is logically\n  'less than', 'equal to', or 'greater than' y. Uses IComparable if available\n  and google.array.defaultCompare for objects of the same type and special-cases\n  nil to be less than any other object.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null))],null)],null),new $APP.f(null,
3,[$APP.R,llb,$APP.X,USa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[fGb],null))],null)],null),new $APP.f(null,3,[$APP.R,dib,$APP.X,QSa,$APP.h,new $APP.f(null,2,[$APP.P,"Mutates the native JS object `o` to have the given metadata. The\n       previous metadata, if any, is discarded. `o` is returned.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qv,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,Tqb,$APP.X,zF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Bvb,$APP.X,NSa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,sRb,$APP.X,function(a,b){var c=function(){function v(A){var B=null;if(0<arguments.length){B=0;for(var G=Array(arguments.length-0);B<G.length;)G[B]=arguments[B+0],++B;B=new $APP.Bc(G,0,null)}return t.call(this,B)}function t(A){A=$APP.Je.A(a,A);return b.j?b.j(A):b.call(null,A)}v.G=0;v.K=function(A){A=$APP.r(A);return t(A)};v.C=t;return v}();
Object.setPrototypeOf(c,Object.getPrototypeOf(a));for(var d=$APP.r(Object.getOwnPropertyNames(a)),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n);c[p]=$APP.Na(a,p);n+=1}else if(d=$APP.r(d))g=d,$APP.pd(g)?(d=$APP.lc(g),n=$APP.mc(g),g=d,l=$APP.Tc(d),d=n):(d=$APP.u(g),c[d]=$APP.Na(a,d),d=$APP.w(g),g=null,l=0),n=0;else break;d=$APP.r(Object.getOwnPropertySymbols(a));g=null;for(n=l=0;;)if(n<l)p=g.aa(null,n),c[p]=$APP.Na(a,p),n+=1;else if(d=$APP.r(d))g=d,$APP.pd(g)?(d=$APP.lc(g),n=$APP.mc(g),g=d,l=$APP.Tc(d),
d=n):(d=$APP.u(g),c[d]=$APP.Na(a,d),d=$APP.w(g),g=null,l=0),n=0;else break;return c},$APP.h,new $APP.f(null,2,[$APP.P,"Make s callable. This is done by re-hosting all of the object properties of `s`\n      in a new native JS function which delegates to the Clojure application. The\n      result of the application of this new function is supplied to the continuation `k`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.tU],null))],null)],null),new $APP.f(null,3,[$APP.R,Kqb,$APP.X,EF,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if `x` is any number type in the numeric tower:\n\n  - integral\n  - floating point\n  - complex\n  - fraction\n\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Llb,$APP.X,YR,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,PRb,$APP.X,GF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true for anything that derives from `::scalar`, i.e., any numeric type in\n  the numeric tower that responds true to [[number?]], plus symbolic expressions\n  generated by [[emmy.abstract.number/literal-number]],\n\n  false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,xbb,$APP.X,BF,$APP.h,new $APP.f(null,2,[$APP.P,null,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qu],null))],null)],null)]),$APP.Zo(yrb)),$APP.ap(new $APP.f(null,6,[$APP.z(rib,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$X],null)))],null)),new $APP.f(null,3,[$APP.R,fBb,$APP.X,function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);
var g=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);var l=P9a(function(n){n=uL.C($APP.y([c,d,uL.C($APP.y([g,n]))]));return a.j?a.j(n):a.call(null,n)});return l.j?l.j(b):l.call(null,b)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$X],null))],null)],null),$APP.z(vUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Tdc],null)))],null)),new $APP.f(null,3,[$APP.R,cYb,$APP.X,function(a){return function(b,c,d){return function(g){function l(p){var v=$APP.x.B(p,
0,null),t=$APP.x.B(p,1,null);p=$APP.x.B(p,2,null);var A=uL.C;t=uL.C($APP.y([b.j?b.j(v):b.call(null,v),t]));var B=uL.C;var G=SO.j?SO.j(b):SO.call(null,b);G=G.j?G.j(v):G.call(null,v);v=A.call(uL,$APP.y([v,t,B.call(uL,$APP.y([G,p]))]));return a.j?a.j(v):a.call(null,v)}function n(p){var v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);p=$APP.x.B(p,2,null);v=uL.C($APP.y([v,uL.C($APP.y([t,c.j?c.j(v):c.call(null,v)])),uL.C($APP.y([p,d.j?d.j(v):d.call(null,v)]))]));return a.j?a.j(v):a.call(null,v)}return uL.C($APP.y([function(){var p=
u4.j(n);p=p.j?p.j(b):p.call(null,b);return p.j?p.j(g):p.call(null,g)}(),function(){var p=M9a(l)(c,d);return p.j?p.j(g):p.call(null,g)}()]))}}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Tdc],null))],null)],null),$APP.z(CXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null),new $APP.H(null,2,5,$APP.I,[$APP.GU,vY],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,
[$APP.GU],null),new $APP.H(null,2,5,$APP.I,[$APP.GU,vY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null),new $APP.H(null,2,5,$APP.I,[$APP.GU,vY],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,Z7b,$APP.X,E4,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null),new $APP.H(null,2,5,$APP.I,[$APP.GU,vY],null))],null)],null),$APP.z(gac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null),new $APP.H(null,
2,5,$APP.I,[$APP.GU,vY],null))),$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.GU],null),new $APP.H(null,2,5,$APP.I,[$APP.GU,vY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null),new $APP.H(null,2,5,$APP.I,[$APP.GU,vY],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,G4b,$APP.X,$APP.F4,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null),new $APP.H(null,
2,5,$APP.I,[$APP.GU,vY],null))],null)],null),$APP.z(Pac,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))],null)),new $APP.f(null,3,[$APP.R,Jsb,$APP.X,function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null),g=$APP.x.B(b,2,null);g=$APP.x.B(g,0,null);var l=$APP.x,n=l.A;var p=QQ.j?QQ.j(2):QQ.call(null,2);p=p.j?p.j(a):p.call(null,a);b=p.j?p.j(b):p.call(null,b);b=n.call(l,b,1);return uL.C($APP.y([c,d,uL.C($APP.y([g,b]))]))}},$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),$APP.z(MKb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null)))],null)),new $APP.f(null,3,[$APP.R,XQb,$APP.X,function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null),g=$APP.x.B(b,2,null);g=$APP.x.B(g,0,null);var l=$APP.x,n=l.A;var p=QQ.j?QQ.j(2):QQ.call(null,2);p=p.j?p.j(a):p.call(null,a);b=p.j?p.j(b):p.call(null,b);b=n.call(l,b,1);return uL.C($APP.y([c,d,uL.C($APP.y([g,
b]))]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.GU],null))],null)],null)],null),$APP.Zo(m0b)),$APP.ap($APP.fg([$APP.z(Hcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))),$APP.P,"Returns the value of `P(x)`, where `P` is rational function fit (using the\n  Bulirsch-Stoer algorithm, of similar style to Neville's algorithm described in\n  [[emmy.numerical.interpolate.polynomial]]) to every point in the supplied\n  sequence `points`.\n\n  `points`: is a sequence of pairs of the form `[x (f x)]`.\n\n  \"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  References:\n\n    - Stoer \x26 Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)"],
null)),$APP.z(yBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-bulirsch-stoer]]."],
null)),$APP.z(wNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[modified-bulirsch-stoer]] xs x)`."],
null)),$APP.z(W_b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.sS,$APP.Vv,$APP.kv],null))),$APP.P,"Takes\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  `P(x)` is rational function fit (using the Bulirsch-Stoer algorithm, of\n  similar style to Neville's algorithm described\n  in [[emmy.numerical.interpolate.polynomial]]) to every point in the\n  supplied sequence `points`.\n\n  \"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  ### Column\n\n  If you supply an integer for the third (optional) `column` argument,\n  `bulirsch-stoer` will return that /column/ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  polynomial approximations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of 2-point approximations\n  between pairs of points; `2` gives 3-point approximations between successive\n  triplets, etc.\n\n  References:\n\n    - Stoer \x26 Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.sS,$APP.Vv,$APP.kv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.sS,$APP.Vv,$APP.kv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(mKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[bulirsch-stoer]] xs x)`."],
null)),$APP.z(S0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Vv,cX],null)],null)))],null)),$APP.z(fRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[bulirsch-stoer]]."],
null)),$APP.z(Mzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[bulirsch-stoer]] xs x))`"],null)),$APP.z(bQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(aeb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[modified-bulirsch-stoer]] xs x))`"],
null)),$APP.z($4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))),$APP.P,"Similar to [[bulirsch-stoer]] (the interface is identical) but slightly more\n  efficient. Internally this builds up its estimates by tracking the delta from\n  the previous estimate.\n\n  This non-obvious change lets us swap an addition in for a division,\n  making the algorithm slightly more efficient.\n\n  See [[bulirsch-stoer]] for usage information, and info about the required\n  structure of the arguments.\n\n  References:\n\n   - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)"],
null))],[new $APP.f(null,3,[$APP.R,Hcb,$APP.X,A0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the value of `P(x)`, where `P` is rational function fit (using the\n  Bulirsch-Stoer algorithm, of similar style to Neville's algorithm described in\n  [[emmy.numerical.interpolate.polynomial]]) to every point in the supplied\n  sequence `points`.\n\n  `points`: is a sequence of pairs of the form `[x (f x)]`.\n\n  \"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  References:\n\n    - Stoer \x26 Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,C6b,$APP.X,G0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-bulirsch-stoer]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,hcc,$APP.X,H0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[modified-bulirsch-stoer]] xs x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,c7b,$APP.X,J2,$APP.h,new $APP.f(null,2,[$APP.P,"Takes\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  `P(x)` is rational function fit (using the Bulirsch-Stoer algorithm, of\n  similar style to Neville's algorithm described\n  in [[emmy.numerical.interpolate.polynomial]]) to every point in the\n  supplied sequence `points`.\n\n  \"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  ### Column\n\n  If you supply an integer for the third (optional) `column` argument,\n  `bulirsch-stoer` will return that /column/ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  polynomial approximations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of 2-point approximations\n  between pairs of points; `2` gives 3-point approximations between successive\n  triplets, etc.\n\n  References:\n\n    - Stoer \x26 Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.sS,$APP.Vv,$APP.kv],null))],null)],null),new $APP.f(null,3,[$APP.R,Fjb,$APP.X,function(a){return EI.j(F0a(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[bulirsch-stoer]] xs x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,RMb,$APP.X,B0a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Vv,cX],null)],null))],null)],null),new $APP.f(null,3,[$APP.R,arb,$APP.X,F0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[bulirsch-stoer]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,C2b,$APP.X,function(a){return E_.j(F0a(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[bulirsch-stoer]] xs x))`",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,IMb,$APP.X,C0a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,$Cb,$APP.X,function(a){return E_.j(G0a(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[modified-bulirsch-stoer]] xs x))`",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,GVb,$APP.X,function(a,b){return vXa(zI(AI(D0a,E0a(b),a)))},$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[bulirsch-stoer]] (the interface is identical) but slightly more\n  efficient. Internally this builds up its estimates by tracking the delta from\n  the previous estimate.\n\n  This non-obvious change lets us swap an addition in for a division,\n  making the algorithm slightly more efficient.\n\n  See [[bulirsch-stoer]] for usage information, and info about the required\n  structure of the arguments.\n\n  References:\n\n   - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sS,$APP.Vv],null))],null)],null)]),$APP.Zo(Jhb)),$APP.ap($APP.fg([$APP.z(Heb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null)))),$APP.P,"Extract the dual basis from the given basis object `b`."],null)),$APP.z(hDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,rW],null))),$APP.P,"Make a basis object out of a vector and dual basis.\n\n  The dimensions of `vector-basis` and `dual-basis` must agree."],
null)),$APP.z(UX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is a basis, false otherwise."],null)),$APP.z(xlb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null)))),$APP.P,"Extract the dimension from the given basis object `b`."],null)),$APP.z(Ijb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[Ksb,QMb],null))),$APP.P,"Returns the Jacobian of transition from `from-basis` to `to-basis`.\n\n  The Jacobian is a structure of manifold functions. The outer index is the\n  from-basis index, so this structure can be multiplied by tuple of component\n  functions of a vector field relative to `from-basis` to get component\n  functions for a vector field in `to-basis`."],null)),$APP.z(wS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,
"Returns true if `x` is a coordinate basis, false otherwise."],null)),$APP.z(zsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null)))),$APP.P,"Extract the vector basis from the given basis object `b`."],null)),$APP.z(cwb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,
[$APP.M(wS,$APP.qU)],null)],null))))],null)),$APP.z(iTb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,TU],null)))],null)),$APP.z(Nkb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[TU,uW],null)))],null)),$APP.z(wgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),$APP.P,"Returns the standard basis object for `coordinate-system`."],null)),$APP.z(Anb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[xU,oW],null)))],null))],[new $APP.f(null,3,[$APP.R,Eeb,$APP.X,mP,$APP.h,new $APP.f(null,2,[$APP.P,"Extract the dual basis from the given basis object `b`.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,bac,$APP.X,Z4a,$APP.h,new $APP.f(null,2,[$APP.P,"Make a basis object out of a vector and dual basis.\n\n  The dimensions of `vector-basis` and `dual-basis` must agree.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,rW],null))],null)],null),new $APP.f(null,3,[$APP.R,YWb,$APP.X,$4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is a basis, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,fvb,$APP.X,a5a,$APP.h,new $APP.f(null,2,[$APP.P,"Extract the dimension from the given basis object `b`.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,
1,5,$APP.I,[$APP.M(UX,$APP.qU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,pQb,$APP.X,d5a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the Jacobian of transition from `from-basis` to `to-basis`.\n\n  The Jacobian is a structure of manifold functions. The outer index is the\n  from-basis index, so this structure can be multiplied by tuple of component\n  functions of a vector field relative to `from-basis` to get component\n  functions for a vector field in `to-basis`.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[Ksb,QMb],null))],null)],null),new $APP.f(null,3,[$APP.R,e2b,$APP.X,W4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is a coordinate basis, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Mdb,$APP.X,nP,$APP.h,new $APP.f(null,2,[$APP.P,"Extract the vector basis from the given basis object `b`.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,
[$APP.M(UX,$APP.qU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,qOb,$APP.X,X4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.qU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(wS,$APP.qU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,eec,$APP.X,pP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,m8b,$APP.X,c5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[TU,uW],null))],null)],null),new $APP.f(null,3,[$APP.R,Bgb,$APP.X,lP,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the standard basis object for `coordinate-system`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,Ttb,$APP.X,b5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,oW],null))],null)],null)]),$APP.Zo(bAb)),$APP.ap($APP.fg([$APP.z($9b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[lW],
null)))],null)),$APP.z(Rnb,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,4,[WE,"null",lS,"null",uX,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,3,[lS,"null",uX,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,10,5,$APP.I,[$APP.tv,$APP.Iv,Nbb,$APP.Qv,GQb,$APP.uU,yVb,xRb,$APP.Jv,Jfb],null))),$APP.P,"Positional factory function for emmy.util.permute/t_emmy$util$permute49487."],null)),$APP.z(MPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))),$APP.P,"Returns a lazy sequence of every possible arrangement of the elements of `xs`."],null)),$APP.z(Cpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jeb,$APP.fx],null))),$APP.P,"Given a `permutation` (represented as a list of numbers), and a sequence `xs`\n  to be permuted, construct the list so permuted."],null)),$APP.z(Byb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,$APP.fx],
null))),$APP.P,"Given a sequence `xs` and a map `m` of replacement indices, returns a new\n  version of `xs` with the element at the position marked by each key in `m`\n  replaced by the element at each value in the original `xs`."],null)),$APP.z(x$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M($APP.$v,$APP.uU,0),$APP.M($APP.$v,$APP.tU,0)],null)],null)))),$APP.P,"Returns the number of possible ways of choosing a multiset with cardinality `k`\n  from a set of `n` items, where each item is allowed to be chosen multiple\n  times."],
null)),$APP.z(EHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[lW,lV],null))),$APP.P,"Given a `permuted-list` and the `original-list`, returns the number of\n  interchanges required to generate the permuted list from the original list."],null)),$APP.z(UDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jra],null))),$APP.P,"Accepts a sequence of collections `colls` and returns a lazy sequence of the\n  cartesian product of all collections.\n\n  The cartesian product of N collections is a sequences of sequences, each `N`\n  long, of every possible way of choosing `N` items where the first comes from\n  the first entry in `colls`, the second from the second entry and so on.\n\n  NOTE: This implementation comes from Alan Malloy at this [StackOverflow\n  post](https://stackoverflow.com/a/18248031). Thanks, Alan!"],
null)),$APP.z(FMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[Rmb,Fyb,dX],null))),$APP.P,"cont \x3d (fn [ulist slist perm iperm] ...)\n\n  Given a short list and a comparison function, to sort the list by the\n  comparison, returning the original list, the sorted list, the permutation\n  procedure and the inverse permutation procedure developed by the sort."],null)),$APP.z(M8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,
$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.$v,$APP.uU,0)],null)],null)))),$APP.P,"Returns 'n choose k', the number of possible ways of choosing `k` distinct\n  elements from a collection of `n` total items."],null)),$APP.z(uSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),$APP.P,"Returns the number of possible ways of permuting a collection of `n` distinct\n  elements."],null)),$APP.z(HMb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[yVb],null))),$APP.P,"Produces an iterable sequence developing the permutations of the input sequence\n  of objects (which are considered distinct) in church-bell-changes order - that\n  is, each permutation differs from the previous by a transposition of adjacent\n  elements (Algorithm P from 7.2.1.2 of Knuth).\n\n  This is an unusual way to go about this in a functional language, but it's\n  fun.\n\n  This approach has the side-effect of arranging for the parity of the generated\n  permutations to alternate; the first permutation yielded is the identity\n  permutation (which of course is even).\n\n  Inside, there is a great deal of mutable state, but this cannot be observed by\n  the user."],
null)),$APP.z(YLb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[lW],null),new $APP.H(null,2,5,$APP.I,[lW,lV],null))),$APP.P,"If a single `permuted-list` is supplied, returns the parity of the number of\n  interchanges required to sort the permutation.\n\n  NOTE that the requirement that elements be sortable currently constrains\n  `permuted-list`'s elements to be numbers that respond to `\x3e\x3d`.\n\n  For two arguments, given a `permuted-list` and the `original-list`, returns\n  the parity (1 for even, -1 for odd) of the number of the number of\n  interchanges required to generate the permuted list from the original list.\n\n  In the two-argument case, if the two lists aren't permutations of each other,\n  returns 0.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[lW],null),new $APP.H(null,2,5,$APP.I,[lW,lV],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lW],null),new $APP.H(null,2,5,$APP.I,[lW,lV],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(LIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Pv],null))),$APP.P,"Returns a lazy sequence of every possible set of `p` elements chosen from\n  `xs`."],
null))],[new $APP.f(null,3,[$APP.R,T4b,$APP.X,r4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lW],null))],null)],null),new $APP.f(null,3,[$APP.R,IPb,$APP.X,x4a,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.util.permute/t_emmy$util$permute49487.",$APP.U,$APP.M(new $APP.H(null,10,5,$APP.I,[$APP.tv,$APP.Iv,Nbb,$APP.Qv,GQb,$APP.uU,yVb,xRb,$APP.Jv,Jfb],null))],null)],null),new $APP.f(null,3,[$APP.R,gZb,$APP.X,function Osc(a){return $APP.hd(a)?$APP.M($APP.Ec):
$APP.T.A($APP.Hl.A($APP.gp.j(function(c,d){return $APP.Vg.A(function(g){return $APP.Yd(d,g)},function(){var g=$APP.N.A($APP.We.A(c,a),$APP.Se.A(c+1,a));return Osc.j?Osc.j(g):Osc.call(null,g)}())}),$APP.eh),a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a lazy sequence of every possible arrangement of the elements of `xs`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,kCb,$APP.X,s4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a `permutation` (represented as a list of numbers), and a sequence `xs`\n  to be permuted, construct the list so permuted.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jeb,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,elb,$APP.X,function(a,b){return $APP.Jd(function(c,d,g){return $APP.rg.B(c,d,$APP.C.A(b,g))},b,a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence `xs` and a map `m` of replacement indices, returns a new\n  version of `xs` with the element at the position marked by each key in `m`\n  replaced by the element at each value in the original `xs`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Or,
$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,Y$b,$APP.X,function(a,b){if(0===b)return 1;a=Y0.A(a,b);b=FI(b);return QF.A?QF.A(a,b):QF.call(null,a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of possible ways of choosing a multiset with cardinality `k`\n  from a set of `n` items, where each item is allowed to be chosen multiple\n  times.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M($APP.$v,
$APP.uU,0),$APP.M($APP.$v,$APP.tU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,l9b,$APP.X,q4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a `permuted-list` and the `original-list`, returns the number of\n  interchanges required to generate the permuted list from the original list.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[lW,lV],null))],null)],null),new $APP.f(null,3,[$APP.R,Mac,$APP.X,yP,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a sequence of collections `colls` and returns a lazy sequence of the\n  cartesian product of all collections.\n\n  The cartesian product of N collections is a sequences of sequences, each `N`\n  long, of every possible way of choosing `N` items where the first comes from\n  the first entry in `colls`, the second from the second entry and so on.\n\n  NOTE: This implementation comes from Alan Malloy at this [StackOverflow\n  post](https://stackoverflow.com/a/18248031). Thanks, Alan!",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jra],null))],null)],null),new $APP.f(null,3,[$APP.R,CUb,$APP.X,function(a,b,c){function d(t){return s4a(v,t)}function g(t){return s4a(p,t)}var l=$APP.Tc(a),n=$APP.Vg.B($APP.ns,a,$APP.Hj.j(l));b=$APP.Ts.B($APP.u,$APP.rda(b),n);n=$APP.Fl.A($APP.u,b);var p=$APP.Fl.A($APP.Xc,b),v=$APP.Vg.A(function(t){return v4a(p,t)},$APP.Hj.j(l));return c.M?c.M(a,n,g,d):c.call(null,a,n,g,d)},$APP.h,new $APP.f(null,2,[$APP.P,"cont \x3d (fn [ulist slist perm iperm] ...)\n\n  Given a short list and a comparison function, to sort the list by the\n  comparison, returning the original list, the sorted list, the permutation\n  procedure and the inverse permutation procedure developed by the sort.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[Rmb,Fyb,dX],null))],null)],null),new $APP.f(null,3,[$APP.R,sHb,$APP.X,function(a,b){return Z0(a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns 'n choose k', the number of possible ways of choosing `k` distinct\n  elements from a collection of `n` total items.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.tU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.$v,$APP.uU,0)],null)],null)))],null)],null),new $APP.f(null,
3,[$APP.R,pib,$APP.X,function(a){return FI(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of possible ways of permuting a collection of `n` distinct\n  elements.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,jzb,$APP.X,A4a,$APP.h,new $APP.f(null,2,[$APP.P,"Produces an iterable sequence developing the permutations of the input sequence\n  of objects (which are considered distinct) in church-bell-changes order - that\n  is, each permutation differs from the previous by a transposition of adjacent\n  elements (Algorithm P from 7.2.1.2 of Knuth).\n\n  This is an unusual way to go about this in a functional language, but it's\n  fun.\n\n  This approach has the side-effect of arranging for the parity of the generated\n  permutations to alternate; the first permutation yielded is the identity\n  permutation (which of course is even).\n\n  Inside, there is a great deal of mutable state, but this cannot be observed by\n  the user.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[yVb],null))],null)],null),new $APP.f(null,3,[$APP.R,ROb,$APP.X,D3,$APP.h,new $APP.f(null,2,[$APP.P,"If a single `permuted-list` is supplied, returns the parity of the number of\n  interchanges required to sort the permutation.\n\n  NOTE that the requirement that elements be sortable currently constrains\n  `permuted-list`'s elements to be numbers that respond to `\x3e\x3d`.\n\n  For two arguments, given a `permuted-list` and the `original-list`, returns\n  the parity (1 for even, -1 for odd) of the number of the number of\n  interchanges required to generate the permuted list from the original list.\n\n  In the two-argument case, if the two lists aren't permutations of each other,\n  returns 0.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lW],null),new $APP.H(null,2,5,$APP.I,[lW,lV],null))],null)],null),new $APP.f(null,3,[$APP.R,X3b,$APP.X,C3,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a lazy sequence of every possible set of `p` elements chosen from\n  `xs`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.fx,$APP.Pv],null))],null)],null)]),$APP.Zo(w4b)),$APP.ap($APP.fg([$APP.z(s_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,3,5,$APP.I,[$APP.M(LU,wU),$APP.M(LU,$APP.Tv),$APP.M($APP.Gu,$APP.M(Hac,$APP.Tv))],null)],null)))),$APP.P,"Returns the pseudo-remainder of univariate polynomials `u` and `v`.\n\n  NOTE: Fractions won't appear in the result; instead the divisor is multiplied\n  by the leading coefficient of the dividend before quotient terms are generated\n  so that division will not result in fractions.\n\n  Returns a pair of\n\n  - the remainder\n  - the integerizing factor needed to make this happen.\n\n  Similar in spirit to Knuth's algorithm 4.6.1R, except we don't multiply the\n  remainder through during gaps in the remainder. Since you don't know up front\n  how many times the integerizing multiplication will be done, we also return\n  the number d for which d * u \x3d q * v + r."],
null)),$APP.z(sV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,BY],null))),$APP.P,"Accepts a [[Polynomial]] `p` and a sequence of symbols for each indeterminate,\n  and emits the canonical form of the symbolic expression that\n  represents [[Polynomial]] `p`.\n\n  A similar result could be achieved by calling `(apply p vars)`;\n  but [[Polynomial]] application uses [Horner's\n  rule](https://en.wikipedia.org/wiki/Horner%27s_method), and form of the\n  returned result will be different.\n\n  NOTE: this is the output stage of Flat Polynomial canonical form\n  simplification. The input stage is handled by [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]]."],
null)),$APP.z(VTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if the supplied argument is an instance of [[Polynomial]], false\n  otherwise."],null)),$APP.z($APP.Lac,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Jv],null))),$APP.P,"Given a polynomial `p`, returns a normalized polynomial generated by dividing\n  through either the [[leading-coefficient]] of `p` or an optional, explicitly\n  supplied scaling factor `c`.\n\n  For example:\n\n  ```clojure\n  (let [p (make [5 3 2 2 10])]\n    (univariate-\x3edense (normalize p)))\n  ;;\x3d\x3e [1/2 3/10 1/5 1/5 1]\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Jv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Jv],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(vcc,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,10,[kU,"null",SW,"null",hU,"null",WE,"null",rS,"null",lS,"null",LY,"null",gV,"null",nT,"null",
RV,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[ZT,mZb,$APP.Or],null))),VR,new $APP.ug(null,new $APP.f(null,6,[kU,"null",SW,"null",rS,"null",lS,"null",gV,"null",nT,"null"],null),null),$APP.P,"Positional factory function for emmy.polynomial/Polynomial."],null)),$APP.z(tV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the cube of polynomial `p`. Equivalent to `(mul p (mul p p))`."],null)),$APP.z(NXb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Similar to [[leading-coefficient]], but of the coefficient itself is\n  a [[Polynomial]], recurses down until it reaches a non-[[Polynomial]] lead\n  coefficient.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity."],null)),$APP.z(cZb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,bSb],null))),$APP.P,"Given a univariate [[Polynomial]] (see [[univariate?]]) returns a dense vector\n  of the coefficients of each term in ascending order.\n\n  For example:\n\n  ```clojure\n  (univariate-\x3edense (make [1 0 0 2 3 4]))\n  ;;\x3d\x3e [1 0 0 2 3 4]\n  ```\n\n  Supplying the second argument `x-degree` will pad the right side of the\n  returning coefficient vector to be the max of `x-degree` and `(degree x)`.\n\n  NOTE use [[lower-arity]] to generate a univariate polynomial in the first\n  indeterminate, given a multivariate polynomial.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,bSb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,bSb],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(Q7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))),$APP.P,"Given two polynomials `u` and `v`, returns a pair of polynomials of the form\n  `[quotient, remainder]` using [polynomial long\n  division](https://en.wikipedia.org/wiki/Polynomial_long_division).\n\n  The contract satisfied by this returned pair is that\n\n  ```\n  u \x3d\x3d (add (mul quotient v) remainder)\n  ```"],
null)),$APP.z(cXb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(l5b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.TP],null),$APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.TP,dX],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(LU,$APP.Iv),$APP.M($APP.Rx,$APP.TP)],null)],null)))),$APP.P,"Takes a univariate polynomial `a`, an argument `z` and a continuation\n  `cont` (`vector` by default) and calls the continuation with (SEE BELOW).\n\n  This Horner's rule evaluator is restricted to numerical coefficients and\n  univariate polynomials. It returns by calling `cont` with 4 arguments:\n\n  - the computed value\n  - the values of the first two derivatives\n  - an estimate of the roundoff error incurred in computing the value\n\n  The recurrences used are from Kahan's 18 Nov 1986 paper ['Roundoff in\n  Polynomial\n  Evaluation'](https://people.eecs.berkeley.edu/~wkahan/Math128/Poly.pdf),\n  generalized for sparse representations and another derivative by GJS.\n\n  For $p \x3d A(z)$, $q \x3d A'(z)$, $r \x3d A''(z)$, and $e$ \x3d error in $A(x)$,\n\n  $$p_{j+n} \x3d z^n p_j + a_{j+n}$$\n\n  $$e_{j+n} \x3d |z|^n ( e_j + (n-1) p_j ) + |p_{j+n}|$$\n\n  $$q_{j+n} \x3d z^n q_j + n z^{n-1} p_j$$\n\n  $$r_{j+n} \x3d z^n r_j + n z^{n-1} q_j + 1/2 n (n-1) z^{n-2} p_j$$",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.TP],null),new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.TP,dX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.TP],null),new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.TP,dX],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(kMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Given a univariate polynomial `p`, returns a [[series/PowerSeries]]\n  representation of the supplied [[Polynomial]].\n\n  Given a [[series/PowerSeries]], acts as identity.\n\n  Non-[[Polynomial]] coefficients return [[series/PowerSeries]] instances\n  via [[series/constant]]; any multivariate [[Polynomial]] throws an exception.\n\n  NOTE use [[lower-arity]] to generate a univariate polynomial in the first\n  indeterminate, given a multivariate polynomial."],
null)),$APP.z(U7b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Pv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Pv,f9b],null))),$APP.P,"Given a [[Polynomial]], returns a new [[Polynomial]] instance generated by\n  applying `f` to the exponents of each term in `p` and filtering out all\n  resulting zeros. The resulting [[Polynomial]] will have either the\n  same [[arity]] as `p`, or the explicit, optional `new-arity` argument. (This\n  is because `f` might increase or decrease the total arity.)\n\n  Given a non-[[Polynomial]] coefficient, if `(f empty-exponents)` produces a\n  non-zero result, errors without an explicit `new-arity` argument..\n\n  NOTE that [[map-exponents]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Pv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Pv,f9b],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Pv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Pv,f9b],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(YS,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(Qhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Pv],null))),$APP.P,"Returns the coefficient of the leading (highest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity."],null)),$APP.z(EVb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null))),$APP.P,"Returns the [degree](https://en.wikipedia.org/wiki/Degree_of_a_polynomial) of\n  the supplied polynomial.\n\n  the degree of a polynomial is the highest of the degrees of the polynomial's\n  individual terms with non-zero coefficients. The degree of an individual term\n  is the sum of all exponents in the term.\n\n  Optionally, [[degree]] takes an indeterminate index `i`; in this\n  case, [[degree]] returns the maximum power found for the `i`th indeterminate\n  across all terms.\n\n  NOTE when passed either a `0` or a zero-polynomial, [[degree]] returns -1. See\n  Wikipedia's ['degree of the zero\n  polynomial'](https://en.wikipedia.org/wiki/Degree_of_a_polynomial#Degree_of_the_zero_polynomial)\n  for color on why this is the case.\n  ",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(LU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns true if `p` is a [[Polynomial]] of arity 1, false otherwise."],
null)),$APP.z(Ivb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Iv],null))),$APP.P,"Given either a non-[[Polynomial]] coefficient or a univariate [[Polynomial]]\n  with possibly-[[Polynomial]] coefficients, returns a new [[Polynomial]] of\n  arity `a` generated by attaching the polynomial coefficients back as variables\n  starting with `1`.\n\n  [[raise-arity]] undoes the transformation of [[lower-arity]].\n  See [[with-lower-arity]] for a function that packages these two\n  transformations."],
null)),$APP.z($APP.JX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,vU],null))),$APP.P,"Returns the difference of polynomials `p` and `q`, with appropriate handling\n  for non-[[Polynomial]] coefficient inputs on either or both sides."],null)),$APP.z(bX,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z($APP.Iu,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"If the [[leading-coefficient]] of `p` is negative, returns `(negate p)`, else\n  acts as identity."],
null)),$APP.z(kQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the sequence of partial derivatives of [[Polynomial]] `p` with respect\n  to each indeterminate. The returned sequence has length equal to the [[arity]]\n  of `p`.\n\n  For non-[[Polynomial]] inputs, returns an empty sequence."],null)),$APP.z($APP.Cx,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[ZT],null),$APP.z(new $APP.H(null,2,5,$APP.I,
[ZT,$APP.Ov],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.io,$APP.M($APP.$v,$APP.Ov,0),$APP.M($APP.Xv,$APP.Ov,ZT))],null)],null)))),$APP.P,"Generates a [[Polynomial]] instance representing a single indeterminate with\n  constant 1.\n\n  When called with no arguments, returns a monomial of arity 1 that acts as\n  identity in the first indeterminate.\n\n  The one-argument version takes an explicit `arity`, but still sets the\n  identity to the first indeterminate.\n\n  The two-argument version takes an explicit `i` and returns a monomial of arity\n  `arity` with an exponent of 1 in the `i`th indeterminate.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[ZT],null),new $APP.H(null,2,5,$APP.I,[ZT,$APP.Ov],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[ZT],null),new $APP.H(null,2,5,$APP.I,[ZT,$APP.Ov],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(Ebc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Jv,$APP.Pv],null))),$APP.P,"Given some polynomial `p` and a coefficient `c`, returns a new [[Polynomial]]\n  generated by multiplying each coefficient of `p` by `c` (on the left).\n\n  See [[scale]] if right multiplication is important.\n\n  NOTE that [[scale-l]] will return a non-[[Polynomial]] if the result of the\n  mapping has only a constant term."],
null)),$APP.z(iS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null))),$APP.P,"Given some [[Polynomial]] `p`, returns the partial derivative of `p` with\n  respect to the `i`th indeterminate. Throws if `i` is an invalid indeterminate\n  index for `p`.\n\n  For non-[[Polynomial]] inputs, returns `0`."],null)),$APP.z(Qpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns true if `p` is a [[Polynomial]] of arity \x3e 1, false otherwise."],
null)),$APP.z(xtb,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[lS,"null",XX,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ddc],null))),$APP.P,"Positional factory function for emmy.polynomial/t_emmy$polynomial48706."],null)),$APP.z(b5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Given some [[Polynomial]] `p`, returns `p` without its [[leading-term]].\n  non-[[Polynomial]] `p` inputs are treated at constant polynomials and return\n  `0`.\n\n  NOTE that [[drop-leading-term]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term."],
null)),$APP.z(nHb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(bWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Given some [[Polynomial]], returns the `terms` entry of the type. Handles other types as well:\n\n  - Acts as identity on vectors, interpreting them as vectors of terms\n  - any zero-valued `p` returns `[]`\n  - any other coefficient returns a vector of a single constant term."],null)),$APP.z(gU,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[kbc],null),new $APP.H(null,2,5,$APP.I,[ZT,V7b],null))),$APP.P,"Generates a [[Polynomial]] instance (or a bare coefficient!) from either:\n\n  - a sequence of dense coefficients of a univariate polynomial (in ascending\n  order)\n  - an explicit `arity`, and a sparse mapping (or sequence of pairs) of exponent\n  \x3d\x3e coefficient\n\n  In the first case, the sequence is interpreted as a dense sequence of\n  coefficients of an arity-1 (univariate) polynomial. The coefficients begin\n  with the constant term and proceed to each higher power of the indeterminate.\n  For example, x^2 - 1 can be constructed by (make [-1 0 1]).\n\n  In the 2-arity case,\n\n  - `arity` is the number of indeterminates\n  - `expts-\x3ecoef` is a map of an exponent representation to a coefficient.\n\n  The `exponent` portion of the mapping can be any of:\n\n  - a proper exponent entry created by `emmy.polynomial.exponent`\n  - a map of the form `{variable-index, power}`\n  - a dense vector of variable powers, like `[3 0 1]` for $x^3z$. The length of\n    each vector should be equal to `arity`, in this case.\n\n  For example, any of the following would generate $4x^2y + 5xy^2$:\n\n  ```clojure\n  (make 2 [[[2 1] 4] [[1 2] 5]])\n  (make 2 {[2 1] 4, [1 2] 5})\n  (make 2 {{0 2, 1 1} 4, {0 1, 1 2} 5})\n  ```\n\n  NOTE: [[make]] will try and return a bare coefficient if possible. For\n  example, the following form will return a constant, since there are no\n  explicit indeterminates with powers \x3e 0:\n\n  ```clojure\n  (make 10 {{} 1 {} 2})\n  ;;\x3d\x3e 3\n  ```\n\n  See [[constant]] if you need an explicit [[Polynomial]] instance wrapping a\n  constant.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[kbc],null),new $APP.H(null,2,5,$APP.I,[ZT,V7b],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[kbc],null),new $APP.H(null,2,5,$APP.I,[ZT,V7b],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(DJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.uU],null))),$APP.P,"Returns a polynomial generated by raising the input polynomial `p` to\n  the (integer) power `n`.\n\n  Negative exponents are not supported. For negative polynomial exponentation,\n  see [[rational-function/expt]]."],
null)),$APP.z(gIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[ZT,$APP.Ov,$APP.Qua],null))),$APP.P,"Given some `arity`, an indeterminate index `i` and some constant `root`,\n  returns a polynomial of the form `x_i - root`. The returned polynomial\n  represents a linear equation in the `i`th indeterminate.\n\n  If `root` is 0, [[linear]] is equivalent to the two-argument version\n  of [[identity]]."],null)),$APP.z(DAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.uU],null))),$APP.P,"Returns a sequence of `n` monomials of arity `n`, each with an exponent of `1`\n  for the `i`th indeterminate (where `i` matches the position in the returned\n  sequence)."],null)),$APP.z(Ueb,new $APP.f(null,1,[$APP.Pu,!0],null)),WS,$APP.z(lcb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the lowest degree found across any term in the supplied [[Polynomial]].\n  If a non-[[Polynomial]] is supplied, returns either `0` or `-1` if the input\n  is itself a `0`.\n\n  See [[degree]] for a discussion of this `-1` case."],
null)),$APP.z(PX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the negation of polynomial `p`, i.e., a polynomial with all coefficients\n  negated."],null)),$APP.z(h_b,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(NTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if the input `x` is explicitly _not_ an instance\n  of [[Polynomial]], false otherwise.\n\n  Equivalent to `(not (polynomial? x))`."],
null)),$APP.z(Ucc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null))),$APP.P,"Given some input `p` and an indeterminate index `i`, returns true if `0 \x3c\x3d i\n  \x3c (arity p)`, false otherwise."],null)),$APP.z(aT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the square of polynomial `p`. Equivalent to `(mul p p)`."],null)),$APP.z(L2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.fx],null))),$APP.P,"Given a sequence of points of the form `[x, f(x)]`, returns a univariate\n  polynomial that passes through each input point.\n\n  The degree of the returned polynomial is equal to `(dec (count xs))`."],null)),$APP.z(x4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[ZT,$APP.Jv,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.$v,$APP.uU,0)],null)],null)))),$APP.P,"Given some `arity`, a coefficient `c` and an exponent `n`, returns a monomial\n  representing $c{x_0}^n$. The first indeterminate is always exponentiated.\n\n  Similar to [[make]], this function attempts to drop down to scalar-land if\n  possible:\n\n  - If `c` is [[emmy.value/zero?]], returns `c`\n  - if `n` is `zero?`, returns `(constant arity c)`\n\n  NOTE that negative exponents are not allowed."],
null)),$APP.z(Wdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.jP],null))),$APP.P,"Returns true if the numerator `n` is evenly divisible by `d` (i.e., leaves no\n  remainder), false otherwise.\n\n  NOTE that this performs a full division with [[divide]]. If you're planning on\n  doing this, you may as well call [[divide]] and check that the remainder\n  satisfies [[emmy.value/zero?]]."],null)),$APP.z(Tjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Pv,$APP.uU],null))),$APP.P,"Returns true if `n` is a valid variable index for the [[Polynomial]] `p`, and\n  the variable with that index has no powers greater than `0` in `p`, false\n  otherwise."],null)),$APP.z(iTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.uU],null))),$APP.P,"If `p` is [[contractible?]] at index `n`, returns a new [[Polynomial]] instance\n  of [[arity]] `1` less than `p` with all variable indices \x3e `n` decremented.\n\n  For non-[[Polynomial]] inputs, acts as identity. Throws if `p` is not\n  explicitly [[contractible?]].\n\n  For example:\n\n  ```clojure\n  (\x3d (make 2 {[1 2] 3 [3 4] 5})\n     (contract\n       (make 3 {[0 1 2] 3 [0 3 4] 5}) 0))\n  ```"],
null)),$APP.z($APP.oy,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.uU],null))),$APP.P,"Interpolates a new variable into the supplied [[Polynomial]] `p` at index `n`\n  by incrementing any existing variable index \x3e\x3d `n`.\n\n  Returns a new [[Polynomial]] of [[arity]] 1 greater than the [[arity]] of `p`,\n  or equal to `(inc n)` if `n` is greater than the [[arity]] of `p`.\n\n  For non-[[Polynomial]] inputs (or negative `n`), acts as identity."],null)),
$APP.z(Jwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[wU,$APP.Tv,FT],null))),$APP.P,"Given:\n\n  - multivariate [[Polynomial]]s `u` and `v`\n  - a `continue` function that accepts two univariate [[Polynomial]]s with\n    possibly-[[Polynomial]] coefficients,\n\n  Returns the result of calling [[lower-arity]] on `u` and `v`, passing the\n  results to `continue` and using [[raise-arity]] to raise the result back to\n  the original shared [[arity]] of `u` and `v`.\n\n  The exception is that if `continue` returns a\n  non-[[Polynomial]], [[with-lower-arity]] will not attempt to re-package it as\n  a [[Polynomial]]."],
null)),$APP.z(HCb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(dU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Pv,mV],null),new $APP.f(null,1,[$APP.yw,$APP.M($APP.Zv,$APP.M(ZT,$APP.Pv),$APP.M($APP.qv,mV))],null)))),$APP.P,"Given some [[Polynomial]] `p`, returns a new [[Polynomial]] generated by\n  substituting each indeterminate `x_i` for `f_i * x_i`, where `f_i` is a factor\n  supplied in the `factors` sequence.\n\n  When `p` is a multivariate [[Polynomial]], each factor must be either a\n  non-[[Polynomial]] or a [[Polynomial]] with the same [[arity]] as `p`."],
null)),$APP.z($APP.gT,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(Jjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the exponents of the leading (highest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, returns [[exponent/empty]]."],null)),$APP.z(FX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Pv,yY],null),new $APP.f(null,1,[$APP.yw,$APP.M($APP.Zv,$APP.M(ZT,
$APP.Pv),$APP.M($APP.qv,yY))],null)))),$APP.P,"Given some [[Polynomial]] `p`, returns a new [[Polynomial]] generated by\n  substituting each indeterminate `x_i` for `s_i + x_i`, where `s_i` is a shift\n  supplied in the `shifts` sequence.\n\n  When `p` is a multivariate [[Polynomial]], each shift must be either a\n  non-[[Polynomial]] or a [[Polynomial]] with the same [[arity]] as `p`."],null)),$APP.z($APP.iX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Jv],
null))),$APP.P,"Given some polynomial `p` and a coefficient `c`, returns a new [[Polynomial]]\n  generated by multiplying each coefficient of `p` by `c` (on the right).\n\n  See [[scale-l]] if left multiplication is important.\n\n  NOTE that [[scale]] will return a non-[[Polynomial]] if the result of the\n  mapping has only a constant term."],null)),$APP.z(ZT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the declared arity of the supplied [[Polynomial]], or `0` for\n  non-polynomial arguments."],
null)),$APP.z(JOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null))),$APP.P,"Given a polynomial `p`, returns the [reciprocal\n  polynomial](https://en.wikipedia.org/wiki/Reciprocal_polynomial) with respect\n  to the `i`th indeterminate. `i` defaults to 0.\n\n  The reciprocal polynomial of `p` with respect to `i` is generated by\n\n  - treating the polynomial as univariate with respect to `i` and pushing all\n    other terms into the coefficients of the polynomial\n  - reversing the order of these coefficients\n  - flattening the polynomial out again\n\n  For example, note that the entries for the first indeterminate are reversed:\n\n  ```clojure\n  (\x3d (make 3 {[3 0 0] 5 [2 0 1] 2 [0 2 1] 3})\n     (reciprocal\n       (make 3 {[0 0 0] 5 [1 0 1] 2 [3 2 1] 3})))\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null)),$APP.zx,$APP.M(null,null)],null)],null)),$APP.z(vfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),$APP.P,"Returns the nth [Touchard\n  polynomial](https://en.wikipedia.org/wiki/Touchard_polynomials).\n\n  These are also called [Bell\n  polynomials](https://mathworld.wolfram.com/BellPolynomial.html) (in\n  Mathematica, implemented as `BellB`) or /exponential polynomials/."],
null)),$APP.z(Lbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns a sequence of the coefficients of the supplied polynomial `p`. A\n  coefficient is treated here as a monomial, and returns a sequence of itself.\n\n  If `p` is zero, returns an empty list."],null)),$APP.z(yX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns true if the [[leading-base-coefficient]] of `p`\n  is [[generic/negative?]], false otherwise."],
null)),$APP.z(pdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns true if `p` is either:\n\n  - a [[Polynomial]] instance with a single term, or\n  - a non-[[Polynomial]] coefficient,\n\n  false otherwise."],null)),$APP.z(ucc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns the coefficient of the trailing (lowest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity."],
null)),$APP.z(eCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,KYb],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(khb,$APP.Sv)],null)],null)))),$APP.P,"Returns a univariate polynomial of all terms in the\n  supplied [[series/PowerSeries]] instance, up to (and including) order\n  `n-terms`.\n\n  ```clojure\n  (g/simplify\n    ((from-power-series series/exp-series 3) 'x))\n  ;; \x3d\x3e (+ (* 1/6 (expt x 3)) (* 1/2 (expt x 2)) x 1)\n  ```"],
null)),$APP.z(IX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,dX],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,dX,iU],null))),$APP.P,"Converts the supplied symbolic expression `expr` into Flat Polynomial canonical\n  form (i.e., a [[Polynomial]] instance). `expr` should be a bare, unwrapped\n  expression built out of Clojure data structures.\n\n  Returns the result of calling continuation `cont` with the [[Polynomial]] and\n  the list of variables corresponding to each indeterminate in\n  the [[Polynomial]]. (`cont `defaults to `vector`).\n\n  The second optional argument `v-compare` allows you to provide a Comparator\n  between variables. Sorting indeterminates by `v-compare` will determine the\n  order of the indeterminates in the generated [[Polynomial]]. The list of\n  variables passed to `cont` will be sorted using `v-compare`.\n\n  Absorbing an expression with [[expression-\x3e]] and emitting it again\n  with [[-\x3eexpression]] will generate the canonical form of an expression, with\n  respect to the operations in the [[operators-known]] set.\n\n  This kind of simplification proceeds purely symbolically over the known Flat\n  Polynomial operations; other operations outside the arithmetic available in\n  polynomials over commutative rings should be factored out by an expression\n  analyzer (see [[emmy.expression.analyze/make-analyzer]]) before\n  calling [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,dX],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,dX,iU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,dX],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,dX,iU],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(gAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns true if `p` is a [monic\n  polynomial](https://en.wikipedia.org/wiki/Monic_polynomial), false otherwise.\n\n  A monic polynomial is a univariate polynomial with a leading coefficient that\n  responds `true` to [[emmy.value/one?]]. This means that any coefficient\n  that responds `true` to [[emmy.value/one?]] also qualifies as a monic\n  polynomial."],null)),$APP.z(O5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Pv],
null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(Qpb,$APP.Pv)],null)],null)))),$APP.P,"Given a multivariate [[Polynomial]] `p`, returns an equivalent\n  univariate [[Polynomial]] whose coefficients are polynomials of [[arity]]\n  equal to one less than the [[arity]] of `p`.\n\n  Use [[raise-arity]] to undo this transformation. See [[with-lower-arity]] for\n  a function that packages these two transformations.\n\n  NOTE that [[lower-arity]] will drop a coefficient down to a non-[[Polynomial]]\n  if the result of extracting the first variable leaves a constant term."],
null)),$APP.z(YU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,vU],null))),$APP.P,"Returns the product of polynomials `p` and `q`, with appropriate handling for\n  non-[[Polynomial]] coefficient inputs on either or both sides."],null))],[new $APP.f(null,3,[$APP.R,v7b,$APP.X,C_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the pseudo-remainder of univariate polynomials `u` and `v`.\n\n  NOTE: Fractions won't appear in the result; instead the divisor is multiplied\n  by the leading coefficient of the dividend before quotient terms are generated\n  so that division will not result in fractions.\n\n  Returns a pair of\n\n  - the remainder\n  - the integerizing factor needed to make this happen.\n\n  Similar in spirit to Knuth's algorithm 4.6.1R, except we don't multiply the\n  remainder through during gaps in the remainder. Since you don't know up front\n  how many times the integerizing multiplication will be done, we also return\n  the number d for which d * u \x3d q * v + r.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,3,5,$APP.I,[$APP.M(LU,wU),$APP.M(LU,$APP.Tv),$APP.M($APP.Gu,$APP.M(Hac,$APP.Tv))],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,S3b,$APP.X,WL,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a [[Polynomial]] `p` and a sequence of symbols for each indeterminate,\n  and emits the canonical form of the symbolic expression that\n  represents [[Polynomial]] `p`.\n\n  A similar result could be achieved by calling `(apply p vars)`;\n  but [[Polynomial]] application uses [Horner's\n  rule](https://en.wikipedia.org/wiki/Horner%27s_method), and form of the\n  returned result will be different.\n\n  NOTE: this is the output stage of Flat Polynomial canonical form\n  simplification. The input stage is handled by [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,BY],null))],null)],null),new $APP.f(null,3,[$APP.R,Ycc,$APP.X,xL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied argument is an instance of [[Polynomial]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,o$b,$APP.X,y2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a polynomial `p`, returns a normalized polynomial generated by dividing\n  through either the [[leading-coefficient]] of `p` or an optional, explicitly\n  supplied scaling factor `c`.\n\n  For example:\n\n  ```clojure\n  (let [p (make [5 3 2 2 10])]\n    (univariate-\x3edense (normalize p)))\n  ;;\x3d\x3e [1/2 3/10 1/5 1/5 1]\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Jv],null))],null)],null),new $APP.f(null,3,[$APP.R,lVb,$APP.X,wL,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.polynomial/Polynomial.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[ZT,mZb,$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,ldc,$APP.X,OL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the cube of polynomial `p`. Equivalent to `(mul p (mul p p))`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,j4b,$APP.X,q_a,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[leading-coefficient]], but of the coefficient itself is\n  a [[Polynomial]], recurses down until it reaches a non-[[Polynomial]] lead\n  coefficient.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,OFb,$APP.X,x2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a univariate [[Polynomial]] (see [[univariate?]]) returns a dense vector\n  of the coefficients of each term in ascending order.\n\n  For example:\n\n  ```clojure\n  (univariate-\x3edense (make [1 0 0 2 3 4]))\n  ;;\x3d\x3e [1 0 0 2 3 4]\n  ```\n\n  Supplying the second argument `x-degree` will pad the right side of the\n  returning coefficient vector to be the max of `x-degree` and `(degree x)`.\n\n  NOTE use [[lower-arity]] to generate a univariate polynomial in the first\n  indeterminate, given a multivariate polynomial.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,bSb],null))],null)],null),new $APP.f(null,3,[$APP.R,ATb,$APP.X,QL,$APP.h,new $APP.f(null,2,[$APP.P,"Given two polynomials `u` and `v`, returns a pair of polynomials of the form\n  `[quotient, remainder]` using [polynomial long\n  division](https://en.wikipedia.org/wiki/Polynomial_long_division).\n\n  The contract satisfied by this returned pair is that\n\n  ```\n  u \x3d\x3d (add (mul quotient v) remainder)\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,jrb,$APP.X,RL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of dividing the polynomial `u` by `v` (non-[[Polynomial]]\n  instances are allowed).\n\n  Throws an exception if the division leaves a remainder. Else, returns the\n  quotient.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,g7b,$APP.X,A2,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a univariate polynomial `a`, an argument `z` and a continuation\n  `cont` (`vector` by default) and calls the continuation with (SEE BELOW).\n\n  This Horner's rule evaluator is restricted to numerical coefficients and\n  univariate polynomials. It returns by calling `cont` with 4 arguments:\n\n  - the computed value\n  - the values of the first two derivatives\n  - an estimate of the roundoff error incurred in computing the value\n\n  The recurrences used are from Kahan's 18 Nov 1986 paper ['Roundoff in\n  Polynomial\n  Evaluation'](https://people.eecs.berkeley.edu/~wkahan/Math128/Poly.pdf),\n  generalized for sparse representations and another derivative by GJS.\n\n  For $p \x3d A(z)$, $q \x3d A'(z)$, $r \x3d A''(z)$, and $e$ \x3d error in $A(x)$,\n\n  $$p_{j+n} \x3d z^n p_j + a_{j+n}$$\n\n  $$e_{j+n} \x3d |z|^n ( e_j + (n-1) p_j ) + |p_{j+n}|$$\n\n  $$q_{j+n} \x3d z^n q_j + n z^{n-1} p_j$$\n\n  $$r_{j+n} \x3d z^n r_j + n z^{n-1} q_j + 1/2 n (n-1) z^{n-2} p_j$$",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.TP],null),$APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.TP,dX],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[$APP.M(LU,$APP.Iv),$APP.M($APP.Rx,$APP.TP)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,Deb,$APP.X,function(a){return RI(a)?a:s_a(a)?TI(x2.j(a)):xL(a)?AD("Only univariate polynomials can be converted to [[PowerSeries]].\n         Use [[polynomial/lower]] to generate a univariate."):h1.j(a)},$APP.h,new $APP.f(null,
2,[$APP.P,"Given a univariate polynomial `p`, returns a [[series/PowerSeries]]\n  representation of the supplied [[Polynomial]].\n\n  Given a [[series/PowerSeries]], acts as identity.\n\n  Non-[[Polynomial]] coefficients return [[series/PowerSeries]] instances\n  via [[series/constant]]; any multivariate [[Polynomial]] throws an exception.\n\n  NOTE use [[lower-arity]] to generate a univariate polynomial in the first\n  indeterminate, given a multivariate polynomial.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,swb,$APP.X,hM,$APP.h,new $APP.f(null,2,[$APP.P,"Given a [[Polynomial]], returns a new [[Polynomial]] instance generated by\n  applying `f` to the exponents of each term in `p` and filtering out all\n  resulting zeros. The resulting [[Polynomial]] will have either the\n  same [[arity]] as `p`, or the explicit, optional `new-arity` argument. (This\n  is because `f` might increase or decrease the total arity.)\n\n  Given a non-[[Polynomial]] coefficient, if `(f empty-exponents)` produces a\n  non-zero result, errors without an explicit `new-arity` argument..\n\n  NOTE that [[map-exponents]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Pv],null),new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Pv,f9b],null))],null)],null),new $APP.f(null,3,[$APP.R,rec,$APP.X,BL,$APP.h,new $APP.f(null,2,[$APP.P,"Given some coefficient `c`, returns a [[Polynomial]] instance with a single\n  constant term referencing `c`.\n\n  `arity` defaults to 1; supply it to set the arity of the\n  returned [[Polynomial]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[ZT,$APP.Jv],
null))],null)],null),new $APP.f(null,3,[$APP.R,Fcc,$APP.X,GL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the coefficient of the leading (highest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,jJb,$APP.X,SL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the [degree](https://en.wikipedia.org/wiki/Degree_of_a_polynomial) of\n  the supplied polynomial.\n\n  the degree of a polynomial is the highest of the degrees of the polynomial's\n  individual terms with non-zero coefficients. The degree of an individual term\n  is the sum of all exponents in the term.\n\n  Optionally, [[degree]] takes an indeterminate index `i`; in this\n  case, [[degree]] returns the maximum power found for the `i`th indeterminate\n  across all terms.\n\n  NOTE when passed either a `0` or a zero-polynomial, [[degree]] returns -1. See\n  Wikipedia's ['degree of the zero\n  polynomial'](https://en.wikipedia.org/wiki/Degree_of_a_polynomial#Degree_of_the_zero_polynomial)\n  for color on why this is the case.\n  ",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null))],null)],null),new $APP.f(null,3,[$APP.R,MDb,$APP.X,s_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `p` is a [[Polynomial]] of arity 1, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,JKb,$APP.X,F_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given either a non-[[Polynomial]] coefficient or a univariate [[Polynomial]]\n  with possibly-[[Polynomial]] coefficients, returns a new [[Polynomial]] of\n  arity `a` generated by attaching the polynomial coefficients back as variables\n  starting with `1`.\n\n  [[raise-arity]] undoes the transformation of [[lower-arity]].\n  See [[with-lower-arity]] for a function that packages these two\n  transformations.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,wzb,$APP.X,LL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the difference of polynomials `p` and `q`, with appropriate handling\n  for non-[[Polynomial]] coefficient inputs on either or both sides.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,vU],null))],null)],null),new $APP.f(null,3,[$APP.R,xeb,$APP.X,DL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the [[Polynomial]] this is equal to `that`. If `that` is\n  a [[Polynomial]], `this` and `that` are equal if they have equal terms and\n  equal arity. Coefficients are compared using [[emmy.value/\x3d]].\n\n  If `that` is non-[[Polynomial]], `eq` only returns true if `this` is a\n  monomial and its coefficient is equal to `that` (again\n  using [[emmy.value/\x3d]]).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.z($APP.Qu,new $APP.f(null,1,[$APP.sj,ZJb],null)),plb],null))],null)],null),new $APP.f(null,3,[$APP.R,Wnb,$APP.X,A_a,$APP.h,new $APP.f(null,2,[$APP.P,"If the [[leading-coefficient]] of `p` is negative, returns `(negate p)`, else\n  acts as identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,ncc,$APP.X,K_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sequence of partial derivatives of [[Polynomial]] `p` with respect\n  to each indeterminate. The returned sequence has length equal to the [[arity]]\n  of `p`.\n\n  For non-[[Polynomial]] inputs, returns an empty sequence.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,Czb,$APP.X,zL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [[Polynomial]] instance representing a single indeterminate with\n  constant 1.\n\n  When called with no arguments, returns a monomial of arity 1 that acts as\n  identity in the first indeterminate.\n\n  The one-argument version takes an explicit `arity`, but still sets the\n  identity to the first indeterminate.\n\n  The two-argument version takes an explicit `i` and returns a monomial of arity\n  `arity` with an exponent of 1 in the `i`th indeterminate.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[ZT],null),$APP.z(new $APP.H(null,2,5,$APP.I,[ZT,$APP.Ov],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.io,$APP.M($APP.$v,$APP.Ov,0),$APP.M($APP.Xv,$APP.Ov,ZT))],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,kkb,$APP.X,v_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some polynomial `p` and a coefficient `c`, returns a new [[Polynomial]]\n  generated by multiplying each coefficient of `p` by `c` (on the left).\n\n  See [[scale]] if right multiplication is important.\n\n  NOTE that [[scale-l]] will return a non-[[Polynomial]] if the result of the\n  mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Jv,$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,gBb,$APP.X,VL,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]] `p`, returns the partial derivative of `p` with\n  respect to the `i`th indeterminate. Throws if `i` is an invalid indeterminate\n  index for `p`.\n\n  For non-[[Polynomial]] inputs, returns `0`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null))],null)],null),new $APP.f(null,3,[$APP.R,UQb,$APP.X,t_a,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if `p` is a [[Polynomial]] of arity \x3e 1, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,bFb,$APP.X,Poc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.polynomial/t_emmy$polynomial48706.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[ddc],null))],null)],null),new $APP.f(null,3,[$APP.R,Xib,$APP.X,w_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]] `p`, returns `p` without its [[leading-term]].\n  non-[[Polynomial]] `p` inputs are treated at constant polynomials and return\n  `0`.\n\n  NOTE that [[drop-leading-term]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,vlb,$APP.X,FL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the leading (highest degree) term of the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, returns a term with zero exponents\n  and `p` as its coefficient.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,Bfb,$APP.X,m_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]], returns the `terms` entry of the type. Handles other types as well:\n\n  - Acts as identity on vectors, interpreting them as vectors of terms\n  - any zero-valued `p` returns `[]`\n  - any other coefficient returns a vector of a single constant term.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,xbc,$APP.X,TL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [[Polynomial]] instance (or a bare coefficient!) from either:\n\n  - a sequence of dense coefficients of a univariate polynomial (in ascending\n  order)\n  - an explicit `arity`, and a sparse mapping (or sequence of pairs) of exponent\n  \x3d\x3e coefficient\n\n  In the first case, the sequence is interpreted as a dense sequence of\n  coefficients of an arity-1 (univariate) polynomial. The coefficients begin\n  with the constant term and proceed to each higher power of the indeterminate.\n  For example, x^2 - 1 can be constructed by (make [-1 0 1]).\n\n  In the 2-arity case,\n\n  - `arity` is the number of indeterminates\n  - `expts-\x3ecoef` is a map of an exponent representation to a coefficient.\n\n  The `exponent` portion of the mapping can be any of:\n\n  - a proper exponent entry created by `emmy.polynomial.exponent`\n  - a map of the form `{variable-index, power}`\n  - a dense vector of variable powers, like `[3 0 1]` for $x^3z$. The length of\n    each vector should be equal to `arity`, in this case.\n\n  For example, any of the following would generate $4x^2y + 5xy^2$:\n\n  ```clojure\n  (make 2 [[[2 1] 4] [[1 2] 5]])\n  (make 2 {[2 1] 4, [1 2] 5})\n  (make 2 {{0 2, 1 1} 4, {0 1, 1 2} 5})\n  ```\n\n  NOTE: [[make]] will try and return a bare coefficient if possible. For\n  example, the following form will return a constant, since there are no\n  explicit indeterminates with powers \x3e 0:\n\n  ```clojure\n  (make 10 {{} 1 {} 2})\n  ;;\x3d\x3e 3\n  ```\n\n  See [[constant]] if you need an explicit [[Polynomial]] instance wrapping a\n  constant.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[kbc],null),new $APP.H(null,2,5,$APP.I,[ZT,V7b],null))],null)],null),new $APP.f(null,3,[$APP.R,JSb,$APP.X,PL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a polynomial generated by raising the input polynomial `p` to\n  the (integer) power `n`.\n\n  Negative exponents are not supported. For negative polynomial exponentation,\n  see [[rational-function/expt]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,
HYb,$APP.X,function(a,b,c){if($APP.k(KF.j(c)))return zL.A(a,b);c=BL.A(a,PF.j(c));a=zL.A(a,b);return KL.A?KL.A(c,a):KL.call(null,c,a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given some `arity`, an indeterminate index `i` and some constant `root`,\n  returns a polynomial of the form `x_i - root`. The returned polynomial\n  represents a linear equation in the `i`th indeterminate.\n\n  If `root` is 0, [[linear]] is equivalent to the two-argument version\n  of [[identity]].",$APP.U,$APP.M(new $APP.H(null,3,
5,$APP.I,[ZT,$APP.Ov,$APP.Qua],null))],null)],null),new $APP.f(null,3,[$APP.R,H3b,$APP.X,AL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a sequence of `n` monomials of arity `n`, each with an exponent of `1`\n  for the `i`th indeterminate (where `i` matches the position in the returned\n  sequence).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,Kfb,$APP.X,IL,$APP.h,new $APP.f(null,2,[$APP.P,"Given a [[Polynomial]], returns a new [[Polynomial]] instance generated by\n  applying `f` to the coefficient of each term in `p` and filtering out all\n  resulting zeros.\n\n  Given a non-[[Polynomial]] coefficient, returns `(f p)`.\n\n  NOTE that [[map-coefficients]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Kv,$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,hnb,$APP.X,e1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,r2b,$APP.X,function(a){return xL(a)?tI(vI($APP.x.A(a.Ra,0))):$APP.k(KF.j(a))?-1:0},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the lowest degree found across any term in the supplied [[Polynomial]].\n  If a non-[[Polynomial]] is supplied, returns either `0` or `-1` if the input\n  is itself a `0`.\n\n  See [[degree]] for a discussion of this `-1` case.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,rzb,$APP.X,JL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the negation of polynomial `p`, i.e., a polynomial with all coefficients\n  negated.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,wVb,$APP.X,w2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string representation of the supplied [[Polynomial]] instance `p`.\n\n  The optional argument `n` specifies how many terms to include in the returned\n  string before an ellipsis cuts them off.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),$APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,2,5,$APP.I,[VTb,$APP.Pv],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,tDb,$APP.X,function(a){return!xL(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the input `x` is explicitly _not_ an instance\n  of [[Polynomial]], false otherwise.\n\n  Equivalent to `(not (polynomial? x))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null))],null)],null),new $APP.f(null,3,[$APP.R,jVb,$APP.X,o_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some input `p` and an indeterminate index `i`, returns true if `0 \x3c\x3d i\n  \x3c (arity p)`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null))],null)],null),new $APP.f(null,3,[$APP.R,vEb,$APP.X,NL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the square of polynomial `p`. Equivalent to `(mul p p)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],
null),new $APP.f(null,3,[$APP.R,dPb,$APP.X,k_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence of points of the form `[x, f(x)]`, returns a univariate\n  polynomial that passes through each input point.\n\n  The degree of the returned polynomial is equal to `(dec (count xs))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,xPb,$APP.X,l_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `arity`, a coefficient `c` and an exponent `n`, returns a monomial\n  representing $c{x_0}^n$. The first indeterminate is always exponentiated.\n\n  Similar to [[make]], this function attempts to drop down to scalar-land if\n  possible:\n\n  - If `c` is [[emmy.value/zero?]], returns `c`\n  - if `n` is `zero?`, returns `(constant arity c)`\n\n  NOTE that negative exponents are not allowed.",
$APP.U,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[ZT,$APP.Jv,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.$v,$APP.uU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,rMb,$APP.X,function(a,b){a=QL(a,b);$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return KF.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the numerator `n` is evenly divisible by `d` (i.e., leaves no\n  remainder), false otherwise.\n\n  NOTE that this performs a full division with [[divide]]. If you're planning on\n  doing this, you may as well call [[divide]] and check that the remainder\n  satisfies [[emmy.value/zero?]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.jP],null))],null)],null),new $APP.f(null,3,[$APP.R,Jnb,$APP.X,D_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `n` is a valid variable index for the [[Polynomial]] `p`, and\n  the variable with that index has no powers greater than `0` in `p`, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,TXb,$APP.X,function(a,b){return xL(a)?D_a(a,b)?hM.B(function(c){return YWa(c,
b)},a,a.arity-1):AD(["Polynomial not contractible: ",$APP.m.j(a)," in position ",$APP.m.j(b)].join("")):a},$APP.h,new $APP.f(null,2,[$APP.P,"If `p` is [[contractible?]] at index `n`, returns a new [[Polynomial]] instance\n  of [[arity]] `1` less than `p` with all variable indices \x3e `n` decremented.\n\n  For non-[[Polynomial]] inputs, acts as identity. Throws if `p` is not\n  explicitly [[contractible?]].\n\n  For example:\n\n  ```clojure\n  (\x3d (make 2 {[1 2] 3 [3 4] 5})\n     (contract\n       (make 3 {[0 1 2] 3 [0 3 4] 5}) 0))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,vTb,$APP.X,function(a,b){if(!xL(a)||0>b)return a;var c=a.arity;return b>c?wL(b+1,a.Ra,$APP.ed(a)):hM.B(function(d){return ZWa(d,b,0)},a,c+1)},$APP.h,new $APP.f(null,2,[$APP.P,"Interpolates a new variable into the supplied [[Polynomial]] `p` at index `n`\n  by incrementing any existing variable index \x3e\x3d `n`.\n\n  Returns a new [[Polynomial]] of [[arity]] 1 greater than the [[arity]] of `p`,\n  or equal to `(inc n)` if `n` is greater than the [[arity]] of `p`.\n\n  For non-[[Polynomial]] inputs (or negative `n`), acts as identity.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,Hfb,$APP.X,G_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given:\n\n  - multivariate [[Polynomial]]s `u` and `v`\n  - a `continue` function that accepts two univariate [[Polynomial]]s with\n    possibly-[[Polynomial]] coefficients,\n\n  Returns the result of calling [[lower-arity]] on `u` and `v`, passing the\n  results to `continue` and using [[raise-arity]] to raise the result back to\n  the original shared [[arity]] of `u` and `v`.\n\n  The exception is that if `continue` returns a\n  non-[[Polynomial]], [[with-lower-arity]] will not attempt to re-package it as\n  a [[Polynomial]].",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[wU,$APP.Tv,FT],null))],null)],null),new $APP.f(null,3,[$APP.R,NVb,$APP.X,UL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of evaluating a multivariate [[Polynomial]] `p` at the\n  values in the sequence `xs` using [Horner's\n  rule](https://en.wikipedia.org/wiki/Horner%27s_method).\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity.\n\n  Supplying too many arguments in `xs` (i.e., a greater number than the [[arity]]\n  of `p`) will throw an exception. Too few arguments will result in a partial\n  evaluation of `p`, leaving the remaining indeterminates with their variable\n  indices shifted down.\n\n  For example:\n\n  ```clojure\n  (\x3d (make [0 0 '(* 3 (expt x 2) y) 0 '(* 5 (expt x 2) (expt y 3))])\n     (simplify\n       (evaluate\n         (make 3 {[2 1 2] 3 [2 3 4] 5}) ['x 'y])))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,nBb,$APP.X,I_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]] `p`, returns a new [[Polynomial]] generated by\n  substituting each indeterminate `x_i` for `f_i * x_i`, where `f_i` is a factor\n  supplied in the `factors` sequence.\n\n  When `p` is a multivariate [[Polynomial]], each factor must be either a\n  non-[[Polynomial]] or a [[Polynomial]] with the same [[arity]] as `p`.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Pv,mV],null),new $APP.f(null,1,[$APP.yw,$APP.M($APP.Zv,$APP.M(ZT,$APP.Pv),$APP.M($APP.qv,mV))],null)))],null)],null),new $APP.f(null,3,[$APP.R,dvb,$APP.X,KL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sum of polynomials `p` and `q`, with appropriate handling for\n  non-[[Polynomial]] coefficient inputs on either or both sides.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,vU],null))],null)],null),new $APP.f(null,3,[$APP.R,vhb,$APP.X,function(a){return xL(a)?
vI($APP.fd(a.Ra)):sI},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the exponents of the leading (highest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, returns [[exponent/empty]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,Dac,$APP.X,J_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]] `p`, returns a new [[Polynomial]] generated by\n  substituting each indeterminate `x_i` for `s_i + x_i`, where `s_i` is a shift\n  supplied in the `shifts` sequence.\n\n  When `p` is a multivariate [[Polynomial]], each shift must be either a\n  non-[[Polynomial]] or a [[Polynomial]] with the same [[arity]] as `p`.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Pv,yY],null),new $APP.f(null,1,[$APP.yw,$APP.M($APP.Zv,$APP.M(ZT,$APP.Pv),$APP.M($APP.qv,yY))],null)))],null)],null),new $APP.f(null,3,[$APP.R,Xnb,$APP.X,u_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some polynomial `p` and a coefficient `c`, returns a new [[Polynomial]]\n  generated by multiplying each coefficient of `p` by `c` (on the right).\n\n  See [[scale-l]] if left multiplication is important.\n\n  NOTE that [[scale]] will return a non-[[Polynomial]] if the result of the\n  mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Jv],null))],null)],null),new $APP.f(null,3,[$APP.R,t9b,$APP.X,CL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the declared arity of the supplied [[Polynomial]], or `0` for\n  non-polynomial arguments.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,lbb,$APP.X,z2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a polynomial `p`, returns the [reciprocal\n  polynomial](https://en.wikipedia.org/wiki/Reciprocal_polynomial) with respect\n  to the `i`th indeterminate. `i` defaults to 0.\n\n  The reciprocal polynomial of `p` with respect to `i` is generated by\n\n  - treating the polynomial as univariate with respect to `i` and pushing all\n    other terms into the coefficients of the polynomial\n  - reversing the order of these coefficients\n  - flattening the polynomial out again\n\n  For example, note that the entries for the first indeterminate are reversed:\n\n  ```clojure\n  (\x3d (make 3 {[3 0 0] 5 [2 0 1] 2 [0 2 1] 3})\n     (reciprocal\n       (make 3 {[0 0 0] 5 [1 0 1] 2 [3 2 1] 3})))\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.H(null,2,5,$APP.I,[$APP.Pv,$APP.Ov],null))],null)],null),new $APP.f(null,3,[$APP.R,odb,$APP.X,function(a){return TL.j($APP.Vg.A(function(b){return CXa(a,b)},$APP.Hj.j(a+1)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the nth [Touchard\n  polynomial](https://en.wikipedia.org/wiki/Touchard_polynomials).\n\n  These are also called [Bell\n  polynomials](https://mathworld.wolfram.com/BellPolynomial.html) (in\n  Mathematica, implemented as `BellB`) or /exponential polynomials/.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))],null)],null),new $APP.f(null,3,[$APP.R,SDb,$APP.X,EL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a sequence of the coefficients of the supplied polynomial `p`. A\n  coefficient is treated here as a monomial, and returns a sequence of itself.\n\n  If `p` is zero, returns an empty list.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,QZb,$APP.X,HL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the [[leading-base-coefficient]] of `p`\n  is [[generic/negative?]], false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,Jeb,$APP.X,r_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `p` is either:\n\n  - a [[Polynomial]] instance with a single term, or\n  - a non-[[Polynomial]] coefficient,\n\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,kgb,$APP.X,function(a){return xL(a)?wI($APP.x.B(a.Ra,0,$APP.sf)):a},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the coefficient of the trailing (lowest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,thb,$APP.X,function(a,b){var c=zL.J();a=a.j?a.j(c):a.call(null,c);return TXa(a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a univariate polynomial of all terms in the\n  supplied [[series/PowerSeries]] instance, up to (and including) order\n  `n-terms`.\n\n  ```clojure\n  (g/simplify\n    ((from-power-series series/exp-series 3) 'x))\n  ;; \x3d\x3e (+ (* 1/6 (expt x 3)) (* 1/2 (expt x 2)) x 1)\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,KYb],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(khb,$APP.Sv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,pUb,$APP.X,B2,$APP.h,new $APP.f(null,2,[$APP.P,"Converts the supplied symbolic expression `expr` into Flat Polynomial canonical\n  form (i.e., a [[Polynomial]] instance). `expr` should be a bare, unwrapped\n  expression built out of Clojure data structures.\n\n  Returns the result of calling continuation `cont` with the [[Polynomial]] and\n  the list of variables corresponding to each indeterminate in\n  the [[Polynomial]]. (`cont `defaults to `vector`).\n\n  The second optional argument `v-compare` allows you to provide a Comparator\n  between variables. Sorting indeterminates by `v-compare` will determine the\n  order of the indeterminates in the generated [[Polynomial]]. The list of\n  variables passed to `cont` will be sorted using `v-compare`.\n\n  Absorbing an expression with [[expression-\x3e]] and emitting it again\n  with [[-\x3eexpression]] will generate the canonical form of an expression, with\n  respect to the operations in the [[operators-known]] set.\n\n  This kind of simplification proceeds purely symbolically over the known Flat\n  Polynomial operations; other operations outside the arithmetic available in\n  polynomials over commutative rings should be factored out by an expression\n  analyzer (see [[emmy.expression.analyze/make-analyzer]]) before\n  calling [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,dX],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,dX,iU],null))],null)],null),new $APP.f(null,3,[$APP.R,V_b,$APP.X,function(a){if(xL(a)){var b=$APP.Uc.A(1,CL(a));return b?sG.j(GL(a)):b}return sG.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `p` is a [monic\n  polynomial](https://en.wikipedia.org/wiki/Monic_polynomial), false otherwise.\n\n  A monic polynomial is a univariate polynomial with a leading coefficient that\n  responds `true` to [[emmy.value/one?]]. This means that any coefficient\n  that responds `true` to [[emmy.value/one?]] also qualifies as a monic\n  polynomial.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,Zgb,$APP.X,E_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a multivariate [[Polynomial]] `p`, returns an equivalent\n  univariate [[Polynomial]] whose coefficients are polynomials of [[arity]]\n  equal to one less than the [[arity]] of `p`.\n\n  Use [[raise-arity]] to undo this transformation. See [[with-lower-arity]] for\n  a function that packages these two transformations.\n\n  NOTE that [[lower-arity]] will drop a coefficient down to a non-[[Polynomial]]\n  if the result of extracting the first variable leaves a constant term.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(Qpb,$APP.Pv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,mbc,$APP.X,ML,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the product of polynomials `p` and `q`, with appropriate handling for\n  non-[[Polynomial]] coefficient inputs on either or both sides.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Pv,vU],null))],null)],null)]),$APP.Zo(v3b)),$APP.ap(new $APP.f(null,
6,[Pdb,new $APP.f(null,3,[$APP.R,DHb,$APP.X,Vrc,$APP.h,$APP.F],null),e$b,new $APP.f(null,3,[$APP.R,r$b,$APP.X,Urc,$APP.h,$APP.F],null),$APP.z(pCb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[dV],null)],null)],null))),$APP.P,"Convert the given expression to TeX format, as a string.\n\n  If you set the `:equation` keyword argument to a truthy value, the result will\n  be wrapped in an equation environment. `:equation \x3cstring\x3e` will insert a\n  `\\label{\x3cstring\x3e}` entry inside the equation environment.\n\n  For example:\n\n  ```clojure\n  (let [expr (+ 'x 'xy)]\n    (println\n      (-\x3eTeX expr :equation \"label!\")))\n\n  \\begin{equation}\n  \\label{label!}\n  x + y\n  \\end{equation}\n  ```\n  ",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,1,$APP.nw,1,$APP.ty,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Tw,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[dV],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[dV],null)],null)],null)),$APP.zx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.R,Rdb,$APP.X,Q3,$APP.h,new $APP.f(null,2,[$APP.P,"Convert the given expression to TeX format, as a string.\n\n  If you set the `:equation` keyword argument to a truthy value, the result will\n  be wrapped in an equation environment. `:equation \x3cstring\x3e` will insert a\n  `\\label{\x3cstring\x3e}` entry inside the equation environment.\n\n  For example:\n\n  ```clojure\n  (let [expr (+ 'x 'xy)]\n    (println\n      (-\x3eTeX expr :equation \"label!\")))\n\n  \\begin{equation}\n  \\label{label!}\n  x + y\n  \\end{equation}\n  ```\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Tw,$APP.Lh,new $APP.f(null,1,[$APP.zu,new $APP.H(null,1,5,$APP.I,[dV],null)],null)],null))],null)],null),OGb,new $APP.f(null,3,[$APP.R,P9b,$APP.X,zQ,$APP.h,$APP.F],null),$APP.z(Xgb,new $APP.f(null,1,[$APP.gm,!0],null)),new $APP.f(null,3,[$APP.R,vIb,$APP.X,!0,$APP.h,$APP.F],null),$APP.z(MGb,new $APP.f(null,1,[$APP.gm,!0],null)),new $APP.f(null,3,[$APP.R,e9b,$APP.X,!1,$APP.h,$APP.F],null)],null),$APP.Zo(Vqb)),$APP.ap($APP.fg([$APP.z(sV,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,BY],null))),$APP.P,"Accepts a [[RationalFunction]] `r` and a sequence of symbols for each indeterminate,\n  and emits the canonical form of the symbolic expression that\n  represents [[RationalFunction]] `r`.\n\n  NOTE: this is the output stage of Rational Function canonical form\n  simplification. The input stage is handled by [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]]."],
null)),$APP.z(tV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Returns the cube of rational function `r`. Equivalent to `(mul r (mul r r))`."],null)),$APP.z(zFb,new $APP.f(null,5,[VE,new $APP.ug(null,new $APP.f(null,10,[kU,"null",SW,"null",WE,"null",nKb,"null",rS,"null",lS,"null",LY,"null",gV,"null",nT,"null",RV,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[ZT,wU,$APP.Tv,$APP.Or],null))),VR,new $APP.ug(null,
new $APP.f(null,6,[kU,"null",SW,"null",rS,"null",lS,"null",gV,"null",nT,"null"],null),null),$APP.P,"Positional factory function for emmy.rational-function/RationalFunction."],null)),$APP.z(iK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))),$APP.P,"Returns the greatest common divisor of rational functions `r` and `s`, with\n  appropriate handling of [[RationalFunction]], [[polynomial/Polynomial]] or\n  coefficients of neither type on either side. "],
null)),$APP.z($APP.JX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))),$APP.P,"Returns the difference of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side."],null)),$APP.z(bX,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z($APP.Iu,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"If the numerator of `r` is negative, returns `(negate r)`, else acts as\n  identity."],
null)),$APP.z(hX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Given some rational function `r`, returns the inverse of `r`, i.e., a rational\n  function with numerator and denominator reversed. The returned rational\n  function guarantees a positive denominator.\n\n  Acts as [[generic/invert]] for non-[[RationalFunction]] inputs."],null)),$APP.z(kQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,
"Returns the sequence of partial derivatives\n  of [[RationalFunction]] (or [[polynomial/Polynomial]]) `r` with respect to\n  each indeterminate. The returned sequence has length equal to the [[arity]] of\n  `r`.\n\n  For non-polynomial or rational function inputs, returns an empty sequence."],null)),$APP.z(iS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Ov],null))),$APP.P,"Given some [[RationalFunction]] or [[polynomial/Polynomial]] `r`, returns the\n  partial derivative of `r` with respect to the `i`th indeterminate. Throws if\n  `i` is an invalid indeterminate index for `r`.\n\n  For non-polynomial or rational function inputs, returns `0`."],
null)),$APP.z(gU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))),$APP.P,"Given a numerator `u` and denominator `v`, attempts to form\n  a [[RationalFunction]] instance by\n\n  - cancelling out any common factors between `u` and `v`\n  - normalizing `u` and `v` such that `v` is always positive\n  - multiplying `u` and `v` through by a commo factor, such that neither term\n    contains any rational coefficients\n\n  Returns a [[RationalFunction]] instance if either `u` or `v` remains\n  a [[polynomial/Polynomial]] after this process; else, returns `(g/div u' v')`,\n  where `u'` and `v'` are the reduced numerator and denominator."],
null)),$APP.z(DJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pW,$APP.uU)],null)],null)))),$APP.P,"Returns a rational function generated by raising the input rational function\n  `r` to the (integer) power `n`."],null)),$APP.z(lbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Returns true if the supplied argument is an instance of [[RationalFunction]],\n  false otherwise."],
null)),WS,$APP.z(PX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Returns the negation of rational function `r`, i.e., a [[RationalFunction]] with\n  its numerator negated.\n\n  Acts as [[generic/negate]] for non-[[RationalFunction]] inputs."],null)),$APP.z(NTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is explicitly _not_ an instance of [[RationalFunction]]\n  or [[polynomial/Polynomial]], false if it is."],
null)),$APP.z(aT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Returns the square of rational function `r`. Equivalent to `(mul r r)`."],null)),$APP.z(JY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))),$APP.P,"Returns the quotient of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side."],
null)),$APP.z(L2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))),$APP.P,"Given a sequence of points of the form `[x, f(x)]`, returns a rational function\n  that passes through each input point."],null)),$APP.z(HCb,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(dU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,mV],null))),$APP.P,"Given some [[RationalFunction]] `r`, returns a new [[RationalFunction]]\n  generated by substituting each indeterminate `x_i` for `f_i * x_i`, where\n  `f_i` is a factor supplied in the `factors` sequence.\n\n  Given a non-[[RationalFunction]], delegates to [[polynomial/arg-scale]]."],
null)),$APP.z($APP.gT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))),$APP.P,"Returns the sum of rational functions `r` and `s`, with appropriate handling\n  of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of neither\n  type on either side."],null)),$APP.z(yqb,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[lS,"null",XX,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),
null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$Pb],null))),$APP.P,"Positional factory function for emmy.rational-function/t_emmy$rational_function48980."],null)),$APP.z(FX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,yY],null))),$APP.P,"Given some [[RationalFunction]] `r`, returns a new [[RationalFunction]]\n  generated by substituting each indeterminate `x_i` for `s_i + x_i`, where\n  `s_i` is a shift supplied in the `shifts` sequence.\n\n  Given a non-[[RationalFunction]], delegates to [[polynomial/arg-shift]]."],
null)),$APP.z(ZT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Returns the declared arity of the supplied [[RationalFunction]]\n  or [[polynomial/Polynomial]], or `0` for arguments of other types."],null)),$APP.z(yX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))),$APP.P,"Returns true if the numerator of `r` is [[polynomial/negative?]], false\n  otherwise."],null)),$APP.z(IX,new $APP.f(null,3,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,dX],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,dX,iU],null))),$APP.P,"Converts the supplied symbolic expression `expr` into Rational Function\n  canonical form (i.e., a [[RationalFunction]] instance). `expr` should be a bare,\n  unwrapped expression built out of Clojure data structures.\n\n  Returns the result of calling continuation `cont` with\n  the [[RationalFunction]] and the list of variables corresponding to each\n  indeterminate in the [[RationalFunction]]. (`cont `defaults to `vector`).\n\n  The second optional argument `v-compare` allows you to provide a Comparator\n  between variables. Sorting indeterminates by `v-compare` will determine the\n  order of the indeterminates in the generated [[RationalFunction]]. The list of\n  variables passed to `cont` will be sorted using `v-compare`.\n\n  Absorbing an expression with [[expression-\x3e]] and emitting it again\n  with [[-\x3eexpression]] will generate the canonical form of an expression, with\n  respect to the operations in the [[operators-known]] set.\n\n  This kind of simplification proceeds purely symbolically over the known\n  Rational Function operations; other operations outside the arithmetic\n  available should be factored out by an expression\n  analyzer (see [[emmy.expression.analyze/make-analyzer]]) before\n  calling [[expression-\x3e]].\n\n  NOTE that `cont` might receive a scalar, fraction or [[polynomial/Polynomial]]\n  instance; both are valid 'rational functions'. The latter as a rational\n  function with a denominator equal to `1`, and the former 2 result from\n  non-polynomial numerator and denominator.\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,dX],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,dX,iU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,dX],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,dX,iU],null)),$APP.zx,$APP.M(null,null,null)],null)],null)),$APP.z(YU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.mO,$APP.Sv],null))),$APP.P,"Returns the product of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side."],null))],[new $APP.f(null,3,[$APP.R,A3b,$APP.X,c1a,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a [[RationalFunction]] `r` and a sequence of symbols for each indeterminate,\n  and emits the canonical form of the symbolic expression that\n  represents [[RationalFunction]] `r`.\n\n  NOTE: this is the output stage of Rational Function canonical form\n  simplification. The input stage is handled by [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,BY],null))],null)],null),new $APP.f(null,3,[$APP.R,qAb,$APP.X,Y0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the cube of rational function `r`. Equivalent to `(mul r (mul r r))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,x_b,$APP.X,tM,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.rational-function/RationalFunction.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[ZT,wU,$APP.Tv,
$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,cUb,$APP.X,a1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the greatest common divisor of rational functions `r` and `s`, with\n  appropriate handling of [[RationalFunction]], [[polynomial/Polynomial]] or\n  coefficients of neither type on either side. ",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,u9b,$APP.X,V0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the difference of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,g4b,$APP.X,vM,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the [[RationalFunction]] this is equal to `that`. If `that` is\n  a [[RationalFunction]], `this` and `that` are equal if they have equal `u` and\n  `v` and equal arity. `u` and `v` entries are compared\n  using [[emmy.value/\x3d]].\n\n  If `that` is non-[[RationalFunction]], `eq` only returns true if `u` and `v`\n  respectively match the [[ratio/numerator]] and [[ratio/denominator]] of\n  `that`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.z($APP.Qu,new $APP.f(null,1,[$APP.sj,rxb],null)),plb],null))],null)],null),new $APP.f(null,3,[$APP.R,cbb,$APP.X,T0a,$APP.h,new $APP.f(null,2,[$APP.P,"If the numerator of `r` is negative, returns `(negate r)`, else acts as\n  identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,ZRb,$APP.X,$0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some rational function `r`, returns the inverse of `r`, i.e., a rational\n  function with numerator and denominator reversed. The returned rational\n  function guarantees a positive denominator.\n\n  Acts as [[generic/invert]] for non-[[RationalFunction]] inputs.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,eJb,$APP.X,b1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sequence of partial derivatives\n  of [[RationalFunction]] (or [[polynomial/Polynomial]]) `r` with respect to\n  each indeterminate. The returned sequence has length equal to the [[arity]] of\n  `r`.\n\n  For non-polynomial or rational function inputs, returns an empty sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],
null),new $APP.f(null,3,[$APP.R,btb,$APP.X,AM,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[RationalFunction]] or [[polynomial/Polynomial]] `r`, returns the\n  partial derivative of `r` with respect to the `i`th indeterminate. Throws if\n  `i` is an invalid indeterminate index for `r`.\n\n  For non-polynomial or rational function inputs, returns `0`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Ov],null))],null)],null),new $APP.f(null,3,[$APP.R,Vxb,$APP.X,xM,$APP.h,new $APP.f(null,2,[$APP.P,
"Given a numerator `u` and denominator `v`, attempts to form\n  a [[RationalFunction]] instance by\n\n  - cancelling out any common factors between `u` and `v`\n  - normalizing `u` and `v` such that `v` is always positive\n  - multiplying `u` and `v` through by a commo factor, such that neither term\n    contains any rational coefficients\n\n  Returns a [[RationalFunction]] instance if either `u` or `v` remains\n  a [[polynomial/Polynomial]] after this process; else, returns `(g/div u' v')`,\n  where `u'` and `v'` are the reduced numerator and denominator.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wU,$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.R,XTb,$APP.X,Z0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rational function generated by raising the input rational function\n  `r` to the (integer) power `n`.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.uU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pW,$APP.uU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,sKb,$APP.X,uM,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns true if the supplied argument is an instance of [[RationalFunction]],\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,jtb,$APP.X,g1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,TQb,$APP.X,S0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the negation of rational function `r`, i.e., a [[RationalFunction]] with\n  its numerator negated.\n\n  Acts as [[generic/negate]] for non-[[RationalFunction]] inputs.",$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,Mfb,$APP.X,I0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is explicitly _not_ an instance of [[RationalFunction]]\n  or [[polynomial/Polynomial]], false if it is.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Jtb,$APP.X,X0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the square of rational function `r`. Equivalent to `(mul r r)`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,o3b,$APP.X,yM,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the quotient of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,FEb,$APP.X,function(a){return bG.j(A0a(a,zL.J()))},$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence of points of the form `[x, f(x)]`, returns a rational function\n  that passes through each input point.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,x5b,$APP.X,zM,$APP.h,new $APP.f(null,2,[$APP.P,"Given some rational function `xs` and a sequence of arguments with length \x3e\x3d 0\n  and \x3c the [[arity]] of `r`, returns the result of evaluating the numerator and\n  denominator using `xs` and re-forming a rational function with the results.\n\n  Supplying fewer arguments than the arity will result in a partial evaluation.\n  Supplying too many arguments will error.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.fx],null))],null)],null),new $APP.f(null,3,[$APP.R,sNb,$APP.X,function(a,b){return uM(a)?yM(I_a(a.Kb,b),I_a(a.v,b)):I_a(a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[RationalFunction]] `r`, returns a new [[RationalFunction]]\n  generated by substituting each indeterminate `x_i` for `f_i * x_i`, where\n  `f_i` is a factor supplied in the `factors` sequence.\n\n  Given a non-[[RationalFunction]], delegates to [[polynomial/arg-scale]].",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,mV],null))],null)],null),new $APP.f(null,3,[$APP.R,kbb,$APP.X,U0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sum of rational functions `r` and `s`, with appropriate handling\n  of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of neither\n  type on either side.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.R,aQb,$APP.X,Hqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.rational-function/t_emmy$rational_function48980.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$Pb],null))],null)],null),new $APP.f(null,3,[$APP.R,oqb,$APP.X,function(a,b){return uM(a)?yM(J_a(a.Kb,b),J_a(a.v,b)):J_a(a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[RationalFunction]] `r`, returns a new [[RationalFunction]]\n  generated by substituting each indeterminate `x_i` for `s_i + x_i`, where\n  `s_i` is a shift supplied in the `shifts` sequence.\n\n  Given a non-[[RationalFunction]], delegates to [[polynomial/arg-shift]].",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.mO,yY],null))],null)],null),new $APP.f(null,3,[$APP.R,K0b,$APP.X,J0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the declared arity of the supplied [[RationalFunction]]\n  or [[polynomial/Polynomial]], or `0` for arguments of other types.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,Hbb,$APP.X,L0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the numerator of `r` is [[polynomial/negative?]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.mO],null))],null)],null),new $APP.f(null,3,[$APP.R,Wub,$APP.X,K2,$APP.h,new $APP.f(null,2,[$APP.P,"Converts the supplied symbolic expression `expr` into Rational Function\n  canonical form (i.e., a [[RationalFunction]] instance). `expr` should be a bare,\n  unwrapped expression built out of Clojure data structures.\n\n  Returns the result of calling continuation `cont` with\n  the [[RationalFunction]] and the list of variables corresponding to each\n  indeterminate in the [[RationalFunction]]. (`cont `defaults to `vector`).\n\n  The second optional argument `v-compare` allows you to provide a Comparator\n  between variables. Sorting indeterminates by `v-compare` will determine the\n  order of the indeterminates in the generated [[RationalFunction]]. The list of\n  variables passed to `cont` will be sorted using `v-compare`.\n\n  Absorbing an expression with [[expression-\x3e]] and emitting it again\n  with [[-\x3eexpression]] will generate the canonical form of an expression, with\n  respect to the operations in the [[operators-known]] set.\n\n  This kind of simplification proceeds purely symbolically over the known\n  Rational Function operations; other operations outside the arithmetic\n  available should be factored out by an expression\n  analyzer (see [[emmy.expression.analyze/make-analyzer]]) before\n  calling [[expression-\x3e]].\n\n  NOTE that `cont` might receive a scalar, fraction or [[polynomial/Polynomial]]\n  instance; both are valid 'rational functions'. The latter as a rational\n  function with a denominator equal to `1`, and the former 2 result from\n  non-polynomial numerator and denominator.\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tw],null),new $APP.H(null,2,5,$APP.I,[$APP.Tw,dX],null),new $APP.H(null,3,5,$APP.I,[$APP.Tw,dX,iU],null))],null)],null),new $APP.f(null,3,[$APP.R,Qrb,$APP.X,W0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the product of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.mO,$APP.Sv],null))],null)],
null)]),$APP.Zo(rZb)),$APP.ap($APP.fg([$APP.z(Jxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[DX,TU],null))),$APP.P,"Returns a data structure representing [Christoffel symbols of the first\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_first_kind)."],null)),$APP.z(PQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[hW,TU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,TU)],
null)],null))))],null)),$APP.z(Kbc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null)))],null)),$APP.z(yfb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))],null)),$APP.z(SQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[hW,TU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,TU)],null)],null))))],null)),$APP.z(Lbc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Vw,kT],null)))],null)),$APP.z(aob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null)))],null)),$APP.z(ERb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[oac,nac,tac,TU,hW],null)))],null)),$APP.z(xfb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null)))],null))],[new $APP.f(null,3,[$APP.R,Ebb,$APP.X,t6a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a data structure representing [Christoffel symbols of the first\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_first_kind).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[DX,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,Rbc,$APP.X,v6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[hW,TU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,TU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,F9b,$APP.X,x6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null))],null)],null),new $APP.f(null,3,[$APP.R,Qub,$APP.X,B6a,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))],null)],null),new $APP.f(null,3,[$APP.R,Pbc,$APP.X,u6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[hW,TU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,TU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,G9b,$APP.X,y6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null))],null)],null),new $APP.f(null,3,[$APP.R,Vcb,$APP.X,z6a,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vw,kT],null))],null)],null),new $APP.f(null,3,[$APP.R,GZb,$APP.X,RP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[oac,nac,tac,TU,hW],null))],null)],null),new $APP.f(null,3,[$APP.R,Rub,$APP.X,A6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hW,TU],null))],null)],null)]),$APP.Zo(fXb)),$APP.ap(new $APP.f(null,3,[$APP.z(yyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null))),$APP.P,"Returns its argument, wrapped in a marker type that responds to the generic\n  operations registered in [[emmy.numsymb]].\n\n  Symbols are automatically treated as [[literal-number]] instances, so\n\n  ```clojure\n  (* 10 (literal-number 'x))\n  ```\n\n  is equivalent to\n\n  ```clojure\n  (* 10 'x)\n  ```\n\n  If you pass an actual number, emmy will attempt to preserve exact values\n  through various operations:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 4))))\n  ;;\x3d\x3e (+ 1 (cos 8))\n  ```\n\n  Notice that the `(g/* 2 ...)` is evaluated, but `cos` evaluation is deferred,\n  since the result is inexact. On the other hand, if the number is inexact to\n  begin with:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 2.2))))\n  ;;\x3d\x3e 0.6926671300215806\n  ```\n\n  the system will go ahead and evaluate it."],
null)),new $APP.f(null,3,[$APP.R,Obc,$APP.X,QM,$APP.h,new $APP.f(null,2,[$APP.P,"Returns its argument, wrapped in a marker type that responds to the generic\n  operations registered in [[emmy.numsymb]].\n\n  Symbols are automatically treated as [[literal-number]] instances, so\n\n  ```clojure\n  (* 10 (literal-number 'x))\n  ```\n\n  is equivalent to\n\n  ```clojure\n  (* 10 'x)\n  ```\n\n  If you pass an actual number, emmy will attempt to preserve exact values\n  through various operations:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 4))))\n  ;;\x3d\x3e (+ 1 (cos 8))\n  ```\n\n  Notice that the `(g/* 2 ...)` is evaluated, but `cos` evaluation is deferred,\n  since the result is inexact. On the other hand, if the number is inexact to\n  begin with:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 2.2))))\n  ;;\x3d\x3e 0.6926671300215806\n  ```\n\n  the system will go ahead and evaluate it.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),$APP.z(y_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is an explicit symbolic expression or something passed to\n  `literal-number`, false otherwise.\n\n  See [[abstract-number?]] for a similar function that also responds true to\n  symbols."],null)),new $APP.f(null,3,[$APP.R,bCb,$APP.X,A1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is an explicit symbolic expression or something passed to\n  `literal-number`, false otherwise.\n\n  See [[abstract-number?]] for a similar function that also responds true to\n  symbols.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),$APP.z(vmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is:\n\n  - a symbolic expression\n  - some object wrapped by a call to [[literal-number]]\n  - a symbol (which implicitly acts as a [[literal-number]])\n\n  See [[literal-number?]] for a similar function that won't respond true to\n  symbols, only to explicit symbolic expressions or wrapped literal numbers."],
null)),new $APP.f(null,3,[$APP.R,Afb,$APP.X,function(a){return A1a(a)||a instanceof $APP.q},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is:\n\n  - a symbolic expression\n  - some object wrapped by a call to [[literal-number]]\n  - a symbol (which implicitly acts as a [[literal-number]])\n\n  See [[literal-number?]] for a similar function that won't respond true to\n  symbols, only to explicit symbolic expressions or wrapped literal numbers.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null))],null)],null)],null),$APP.Zo(o5b)),$APP.ap(new $APP.f(null,8,[$APP.z(WMb,new $APP.f(null,1,[$APP.Kw,!0],null)),new $APP.f(null,3,[$APP.R,N9b,$APP.X,qTa,$APP.h,$APP.F],null),$APP.z(acc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null))),$APP.P,"Used as a [data reader](https://www.clojurescript.org/guides/reader#_clojurescript_compilation).\n  In Clojure, we could get away with just using the constructor above, but in\n  ClojureScript we need to act as a macro to delay evaluation of the constructor."],
null)),new $APP.f(null,3,[$APP.R,Whb,$APP.X,ETa,$APP.h,new $APP.f(null,2,[$APP.P,"Used as a [data reader](https://www.clojurescript.org/guides/reader#_clojurescript_compilation).\n  In Clojure, we could get away with just using the constructor above, but in\n  ClojureScript we need to act as a macro to delay evaluation of the constructor.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null))],null)],null),$APP.z(Wrb,new $APP.f(null,1,[$APP.Kw,!0],null)),new $APP.f(null,3,[$APP.R,v0b,$APP.X,sTa,
$APP.h,$APP.F],null),$APP.z(CU,new $APP.f(null,1,[$APP.Kw,!0],null)),new $APP.f(null,3,[$APP.R,Dsb,$APP.X,nG,$APP.h,$APP.F],null),$APP.z(dY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null))),$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,
1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,uG,$APP.X,wG,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null),new $APP.H(null,2,5,$APP.I,[GW,eX],null))],null)],
null),$APP.z(wlb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise."],null)),new $APP.f(null,3,[$APP.R,eeb,$APP.X,vG,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),$APP.z(y5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.TP],
null))),$APP.P,"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values. (Note: the use of cast-to-double is\n   unfortunate here, as complex numbers can now contain exact fractions, and\n   we'd want a nearest integer generic function for those)"],null)),new $APP.f(null,3,[$APP.R,GNb,$APP.X,FTa,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values. (Note: the use of cast-to-double is\n   unfortunate here, as complex numbers can now contain exact fractions, and\n   we'd want a nearest integer generic function for those)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.TP],null))],null)],null),$APP.z(Bpb,new $APP.f(null,1,[$APP.Kw,!0],null)),new $APP.f(null,3,[$APP.R,$xb,$APP.X,mnc,$APP.h,$APP.F],null)],null),$APP.Zo(Z2b)),$APP.ap(new $APP.f(null,1,[$APP.z(cVb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.DU,p9b],null)))],null)),new $APP.f(null,3,[$APP.R,UZb,$APP.X,function(a,b){var c=$APP.Xc(SH(b));c=$APP.Uj.A(c,0);var d=iG.A,g=QQ.j?QQ.j(2):QQ.call(null,2);a=g.j?g.j(a):g.call(null,
a);return d.call(iG,a,$APP.Je.A(SO.j?SO.j(b):SO.call(null,b),c))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.DU,p9b],null))],null)],null)],null),$APP.Zo(fzb)),$APP.ap(new $APP.f(null,6,[$APP.z(FRb,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,new $APP.f(null,2,[$APP.z(WTb,new $APP.f(null,1,[$APP.P,null],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)],null),$APP.z(GHb,new $APP.f(null,1,[$APP.P,null],null)),new $APP.H(null,1,5,$APP.I,
[new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)],null)],null)],null),$APP.Lv,new $APP.f(null,2,[d1b,new $APP.f(null,3,[$APP.R,WTb,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)),$APP.P,null],null),UCb,new $APP.f(null,3,[$APP.R,GHb,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)),$APP.P,null],null)],null),eU,$APP.M("@interface")],null)),new $APP.f(null,3,[$APP.R,nKb,$APP.X,KTa,$APP.h,$APP.F],null),$APP.z(WTb,new $APP.f(null,3,[$APP.Nm,nKb,$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Hv],null)))],null)),new $APP.f(null,3,[$APP.R,V1b,$APP.X,BG,$APP.h,new $APP.f(null,2,[$APP.P,null,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))],null)],null),FUb,new $APP.f(null,3,[$APP.R,a_b,$APP.X,JTa,$APP.h,$APP.F],null),$APP.z(Sib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Parser for the `#emmy/ratio` literal."],null)),new $APP.f(null,3,[$APP.R,xvb,$APP.X,function(a){if(EF(a))return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,
KX,null,1,null),new $APP.D(null,a,null,1,null))));if("string"===typeof a){var b=$APP.Lg(nnc,a);return $APP.k(b)?($APP.x.B(b,0,null),a=$APP.x.B(b,1,null),b=$APP.x.B(b,2,null),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,KX,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,QY,null,1,null),new $APP.D(null,a,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,QY,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null)]))))):AD(["Invalid ratio: ",
a].join(""))}return $APP.od(a)&&$APP.Uc.A(2,$APP.Tc(a))?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,KX,null,1,null),a))):AD(["Invalid ratio: ",$APP.m.j(a)].join(""))},$APP.h,new $APP.f(null,2,[$APP.P,"Parser for the `#emmy/ratio` literal.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),$APP.z(AQb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.jP],null))),$APP.P,"Construct a ratio.",$APP.hy,new $APP.f(null,
6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.jP],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,$APP.jP],null)),$APP.zx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.R,KX,$APP.X,WZ,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a ratio.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.uU,
$APP.jP],null))],null)],null),$APP.z(GHb,new $APP.f(null,3,[$APP.Nm,nKb,$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null)))],null)),new $APP.f(null,3,[$APP.R,l$b,$APP.X,CG,$APP.h,new $APP.f(null,2,[$APP.P,null,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null))],null)],null)],null),$APP.Zo(Mub)),$APP.ap($APP.fg([$APP.z(lX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic quotient"],null)),$APP.z(n4b,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"Alias for [[solve-linear]]; present for compatibility with the original\n  `scmutils` codebase.\n\n  NOTE: In `scmutils`, `solve-linear-left` and `solve-linear` act identically in\n  all cases except matrices. `solve-linear-left` only accepted a column\n  matrix (or up structure) in the `b` position, while `solve-linear` accepted\n  either a column or row (up or down structure).\n\n  In Emmy, both functions accept either type."],
null)),$APP.z(eS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic remainder.\n\nReturns the remainder of dividing the dividend `a` by divisor `b`.\n\n The contract satisfied by [[remainder]] is:\n\n```clojure\n(\x3d a (+ (* b (quotient a b))\n        (remainder a b)))\n```\n\n For numbers, this differs from the contract offered by [[modulo]]\n because [[quotient]] rounds toward 0, while `(floor (/ a b))` rounds toward\n negative infinity.\n\n The result will be either `0` or of the same sign as the dividend `a`."],
null)),$APP.z(k$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic identity-like.\n\nLike `one-like` but works for square matrices."],null)),$APP.z(eW,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(DT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic make-polar"],null)),$APP.z(tV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,
"generic cube"],null)),$APP.z(MXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic tanc.\n\n`tanc` is defined, by analogy with [[sinc]], to be equal to $\\frac{\\tan\n  x}{x}$ for nonzero $x$ and equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/TancFunction.html)"],null)),$APP.z(lSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic determinant"],null)),$APP.z(wH,new $APP.f(null,1,[$APP.Pu,!0],null)),Q7b,$APP.z(kH,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(G6b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic exact-divide.\n\nSimilar to the binary case of [[/]], but throws if `(g/exact? \x3cresult\x3e)`\n  returns false."],null)),$APP.z(lK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic tan.\n\nComputes the trigonometric tangent function of the supplied argument `a`.\n\nEquivalent to `(/ (sin a) (cos a))`."],null)),$APP.z(M_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic solve-linear.\n\nFor a given `a` and `b`, returns `x` such that `a*x \x3d b`.\n\n  See[[solve-linear-right]] for a similar function that solves for `a \x3d x*b`."],null)),$APP.z(U1b,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic freeze.\n\nFreezing an expression means removing wrappers and other metadata from\n  subexpressions, so that the result is basically a pure S-expression with the\n  same structure as the input. Doing this will rob an expression of useful\n  information for further computation; so this is intended to be done just\n  before simplification and printing, to simplify those processes."],null)),$APP.z($APP.AY,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic dimension"],null)),$APP.z(Snb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic tanhc.\n\nThe [tanhc function](https://en.wikipedia.org/wiki/Tanhc_function),\n  equivalent to $\\frac{\\tanh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanhc_function)\n   - [Mathworld page on Tanhc](https://mathworld.wolfram.com/TanhcFunction.html)"],
null)),$APP.z(sH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic cos.\n\nReturns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`."],null)),$APP.z(iK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic gcd.\n\nReturns the [greatest common\n  divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the two\n  inputs `a` and `b`."],
null)),$APP.z(jdc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic exp10.\n\nReturns the base-10 exponential of `x`. Equivalent to `(expt 10 x)`."],null)),$APP.z(Ncc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic cross-product"],null)),$APP.z(YX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic modulo.\n\nReturns the result of the\n  mathematical [Modulo](https://en.wikipedia.org/wiki/Modulo_operation)\n  operation between `a` and `b` (using the Knuth definition listed).\n\n The contract satisfied by [[modulo]] is:\n\n```clojure\n(\x3d a (+ (* b (floor (/ a b)))\n        (modulo a b)))\n```\n\n For numbers, this differs from the contract offered by [[remainder]]\n because `(floor (/ a b))` rounds toward negative infinity, while\n the [[quotient]] operation in the contract for [[remainder]] rounds toward 0.\n\n The result will be either `0` or of the same sign as the divisor `b`."],
null)),$APP.z($APP.rj,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))),$APP.P,"Generic implementation of `/`.\n\n  If one argument is supplied, returns the multiplicative inverse of `a`. Else\n  returns the result of dividing first argument `a` by the product of all\n  remaining arguments. `(/)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core//`. Dispatch is open,\n  however, making it possible to 'divide' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (/ [2 4 6] 2)\n  ;;\x3d\x3e (up 1 2 3)\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null,null)],null)],null)),$APP.z(vvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic exact?.\n\nEntries that are exact are available for `gcd`, among other operations."],null)),$APP.z(WQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic outer-product"],null)),$APP.z($APP.Iu,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic abs"],null)),$APP.z(hX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Iv],null))),$APP.P,"generic invert.\n\nReturns the multiplicative inverse of `a`.\n\n  Equivalent to `(/ 1 a)`."],null)),$APP.z(GX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic dot-product"],null)),$APP.z($T,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic real-part"],null)),$APP.z(BJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],
null))),$APP.P,"generic log.\n\nReturns the natural logarithm of `x`."],null)),$APP.z(iS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic partial-derivative"],null)),$APP.z(uH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic cosh.\n\nComputes the [hyperbolic\n cosine](https://mathworld.wolfram.com/HyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x + e^{-x}) / 2`."],
null)),$APP.z(tW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic coth.\n\nComputes the [hyperbolic\n cotangent](https://mathworld.wolfram.com/HyperbolicCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `cosh(x) / sinh(x)`."],null)),$APP.z(Ypb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic one-like.\n\nIn general, this procedure returns the multiplicative identity of the type of\n  its argument, if it exists. For numbers this is 1."],
null)),$APP.z(DJ,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(xW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic fractional-part.\n\nReturns the fractional part of the given value, defined as `x - x`.\n\n  For positive numbers, this is identical to `(- a (integer-part a))`. For\n  negative `a`, because [[floor]] truncates toward negative infinity, you might\n  be surprised to find that [[fractional-part]] returns the distance between `a`\n  and the next-lowest integer:\n\n```clojure\n(\x3d 0.6 (fractional-part -0.4))\n```"],
null)),$APP.z(aY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic trace"],null)),$APP.z($APP.Fv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))),$APP.P,"Generic implementation of `+`. Returns the sum of all supplied arguments. `(+)`\n  returns 0, the additive identity.\n\n  When applied between numbers, acts like `clojure.core/+`. Dispatch is open,\n  however, making it possible to 'add' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (+ [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up 3 5 7)\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null,null)],null)],null)),$APP.z(LM,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic sec.\n\nComputes the secant of the supplied argument `a`.\n\nEquivalent to `(invert (cos a))`."],null)),$APP.z(PX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic negate.\n\nReturns the negation of `a`.\n\n  Equivalent to `(- (g/zero-like a) a)`."],null)),$APP.z(aFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic acoth.\n\nComputes the [inverse hyperbolic\n cotangent](https://mathworld.wolfram.com/InverseHyperbolicCotangent.html) of\n the supplied argument `a`.\n\ndefaults to `1/2 ln((x+1)/(x-1))`."],
null)),$APP.z(sT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic sech.\n\nComputes the [hyperbolic\n secant](https://mathworld.wolfram.com/HyperbolicSecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / cosh(x)`."],null)),$APP.z(kob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic log10.\n\nReturns the base-10 logarithm of `x`, i.e., $log_10(x)$."],null)),$APP.z(aT,new $APP.f(null,
1,[$APP.Pu,!0],null)),$APP.z(wQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic exp2.\n\nReturns the base-2 exponential of `x`. Equivalent to `(expt 2 x)`."],null)),$APP.z(AK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic magnitude"],null)),$APP.z(JY,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z($APP.aw,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],
null))),$APP.P,"generic infinite?.\n\nReturns true if `a` is either numerically infinite (i.e., equal to `##Inf`) or\n  a compound number (complex or quaterion, for example) with some infinite\n  component."],null)),$APP.z(MM,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic cot.\n\nComputes the trigonometric cotangent function of the supplied argument `a`.\n\nEquivalent to `(invert (tan a))`, or `(/ (cos a) (sin a))`."],null)),$APP.z($APP.Ev,
new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))),$APP.P,'Generic implementation of `*`. Returns the product of all supplied\n  arguments. `(*)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core/*`. Dispatch is open,\n  however, making it possible to \'multiply\' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (* 2 #emmy/complex "3 + 1i")\n  ;;\x3d\x3e #emmy/complex "6 + 2i"\n  ```',
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null,null)],null)],null)),$APP.z($nb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic asec.\n\nComputes the [inverse\n secant](https://mathworld.wolfram.com/InverseSecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(sqrt(x^2 - 1))`."],null)),$APP.z(vDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic solve-linear-right.\n\nFor a given `a` and `b`, returns `x` such that `a \x3d x*b`.\n\n  See[[solve-linear]] for a similar function that solves for `a*x \x3d b`."],
null)),$APP.z(Ihb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic acsch.\n\nComputes the [inverse hyperbolic\n cosecant](https://mathworld.wolfram.com/InverseHyperbolicCosecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1+x^2)) / x)`."],null)),$APP.z(uqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` is either:\n\n  - [[integral?]],\n  - a floating point number either \x3c [[absolute-integer-tolerance]] (if near\n    zero) or within [[relative-integer-tolerance]] of the closest integer,\n\n  false otherwise."],
null)),$APP.z(Vtb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic log2.\n\nReturns the base-2 logarithm of `x`, i.e., $log_2(x)$."],null)),$APP.z($APP.zv,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic zero?.\n\nIs true if `x` is an additive identity."],null)),$APP.z(hK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,2,5,
$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic atan.\n\nComputes the inverse tangent of the supplied argument `a`. Given two\n  arguments `a` and `b`, returns the inverse tangent of the angle formed by the\n  point `(b, a)` in a 2-dimensional euclidean plane.\n\n  The two-argument version is sometimes\n  called [Atan2](https://en.wikipedia.org/wiki/Atan2)."],null)),$APP.z(PV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic make-rectangular"],
null)),$APP.z(NM,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(DV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic lcm.\n\nReturns the [least common\n  multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of the two\n  inputs `a` and `b`."],null)),$APP.z(aib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic acsc.\n\nComputes the [inverse\n cosecant](https://mathworld.wolfram.com/InverseCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(1 / sqrt(x^2 - 1))`."],
null)),$APP.z(kK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic acos.\n\nComputes the inverse cosine of the supplied argument `a`.\n\nDefaults to `atan(sqrt(1-x^2)/x)`."],null)),$APP.z(XS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic acot.\n\nComputes the [inverse\n cotangent](https://mathworld.wolfram.com/InverseCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `pi/2 - atan(x)`."],
null)),$APP.z(bT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic floor.\n\nReturns the largest integer less than or equal to `a`.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail."],null)),$APP.z(hV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic imag-part"],
null)),$APP.z(aR,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic Lie-derivative"],null)),$APP.z(pgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],null))),$APP.P,"Returns true if the supplied argument is an exact numerical zero, false\n  otherwise."],null)),$APP.z($APP.Gv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,
$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))),$APP.P,"Generic implementation of `-`.\n\n  If one argument is supplied, returns the negation of `a`. Else returns the\n  difference of the first argument `a` and the sum of all remaining\n  arguments. `(-)` returns 0.\n\n  When applied between numbers, acts like `clojure.core/-`. Dispatch is open,\n  however, making it possible to 'subtract' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (- [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up -1 -1 -1)\n\n  (- [1 10])\n  ;;\x3d\x3e (up -1 -10)\n  ```",
$APP.hy,new $APP.f(null,6,[$APP.ru,!0,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null)),$APP.zx,$APP.M(null,null,null,null)],null)],null)),$APP.z(CYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns `true` if `x` is both a [[number?]] and [[zero?]], false otherwise."],null)),$APP.z(rX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))),$APP.P,"generic inner-product"],null)),$APP.z(oV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic acosh.\n\nComputes the [inverse hyperbolic\n cosine](https://mathworld.wolfram.com/InverseHyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `2 ln(sqrt((x+1)/2) + sqrt((x-1)/2))`."],
null)),$APP.z(jY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic ceiling.\n\nReturns the result of rounding `a` up to the next largest integer.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail."],null)),$APP.z(O$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,
"generic sinc.\n\nThe unnormalized [sinc\n  function](https://en.wikipedia.org/wiki/Sinc_function), equivalent to\n  $\\frac{\\sin x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/SincFunction.html)\n   - [Boost notes on [[sinc]]\n     and [[sinch]]](https://www.boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sinc/sinc_overview.html)"],
null)),$APP.z(nY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic conjugate"],null)),$APP.z(Y_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic sinhc.\n\nThe [sinhc function](https://en.wikipedia.org/wiki/Sinhc_function),\n  equivalent to $\\frac{\\sinh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinhc_function)\n   - [Mathworld page on Sinhc](https://mathworld.wolfram.com/SinhcFunction.html)"],
null)),$APP.z(FJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic sqrt"],null)),$APP.z(Y3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic asech.\n\nComputes the [inverse hyperbolic\n secant](https://mathworld.wolfram.com/InverseHyperbolicSecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1-x^2)) / x)`."],null)),$APP.z(jK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic asin.\n\nComputes the inverse sine of the supplied argument `a`.\n\nDefaults to `atan(x/sqrt(1-x^2))`."],null)),$APP.z($APP.VX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic transpose"],null)),$APP.z(zJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic exp.\n\nReturns the base-e exponential of `x`. Equivalent to `(expt e x)`, given\n  some properly-defined `e` symbol."],
null)),$APP.z(yX,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(WV,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(fW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic asinh.\n\nComputes the [inverse hyperbolic\n sine](https://mathworld.wolfram.com/InverseHyperbolicSine.html) of the\n supplied argument `a`.\n\ndefaults to `ln(x + sqrt(1 + x^2))`."],null)),$APP.z(oX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],
null))),$APP.P,"generic tanh.\n\nComputes the [hyperbolic\n tangent](https://mathworld.wolfram.com/HyperbolicTangent.html) of the supplied\n argument `a`.\n\ndefaults to `sinh(x) / cosh(x)`."],null)),$APP.z(jS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic identity?.\n\nLike `one?`, but this is true of square identity matrices as well.\n  No matrix is considered `one?` because its function as a multiplicative\n  identity depends on the shape of the other multiplicand."],
null)),$APP.z(Bcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic zero-like.\n\nIn general, this procedure returns the additive identity of the type of its\n  argument, if it exists. For numbers this is 0."],null)),$APP.z(CY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic angle"],null)),$APP.z($R,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],
null))),$APP.P,"generic simplify"],null)),$APP.z(FV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic atanh.\n\nComputes the [inverse hyperbolic\n tangent](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) of the\n supplied argument `a`.\n\ndefaults to `1/2 ln((1+x)/(1-x))`."],null)),$APP.z(D$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))),$APP.P,"generic one?.\n\nIs true if `x` is a multiplicative identity."],
null))],[new $APP.f(null,3,[$APP.R,u6b,$APP.X,qI,$APP.h,new $APP.f(null,2,[$APP.P,"generic quotient",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,WLb,$APP.X,XSa,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[solve-linear]]; present for compatibility with the original\n  `scmutils` codebase.\n\n  NOTE: In `scmutils`, `solve-linear-left` and `solve-linear` act identically in\n  all cases except matrices. `solve-linear-left` only accepted a column\n  matrix (or up structure) in the `b` position, while `solve-linear` accepted\n  either a column or row (up or down structure).\n\n  In Emmy, both functions accept either type.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,H9b,$APP.X,AG,$APP.h,new $APP.f(null,2,[$APP.P,"generic remainder.\n\nReturns the remainder of dividing the dividend `a` by divisor `b`.\n\n The contract satisfied by [[remainder]] is:\n\n```clojure\n(\x3d a (+ (* b (quotient a b))\n        (remainder a b)))\n```\n\n For numbers, this differs from the contract offered by [[modulo]]\n because [[quotient]] rounds toward 0, while `(floor (/ a b))` rounds toward\n negative infinity.\n\n The result will be either `0` or of the same sign as the dividend `a`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,s4b,$APP.X,jZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic identity-like.\n\nLike `one-like` but works for square matrices.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,m9b,$APP.X,EZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic csch.\n\nComputes the [hyperbolic\n cosecant](https://mathworld.wolfram.com/HyperbolicCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / sinh(x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,lcc,$APP.X,OZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic make-polar",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,B_b,$APP.X,oZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic cube",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,GLb,$APP.X,LZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic tanc.\n\n`tanc` is defined, by analogy with [[sinc]], to be equal to $\\frac{\\tan\n  x}{x}$ for nonzero $x$ and equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/TancFunction.html)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,krb,$APP.X,ZQ,$APP.h,new $APP.f(null,2,[$APP.P,"generic determinant",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,tJb,$APP.X,vH,$APP.h,new $APP.f(null,2,[$APP.P,"generic sinh.\n\nComputes the [hyperbolic\n sine](https://mathworld.wolfram.com/HyperbolicSine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x - e^{-x}) / 2`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,C_b,$APP.X,QF,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Cib,$APP.X,gO,$APP.h,new $APP.f(null,2,[$APP.P,"generic sin.\n\nReturns the [sine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,v2b,$APP.X,iM,$APP.h,new $APP.f(null,2,[$APP.P,"generic exact-divide.\n\nSimilar to the binary case of [[/]], but throws if `(g/exact? \x3cresult\x3e)`\n  returns false.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,aCb,$APP.X,tZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic tan.\n\nComputes the trigonometric tangent function of the supplied argument `a`.\n\nEquivalent to `(/ (sin a) (cos a))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,bcc,$APP.X,VF,$APP.h,new $APP.f(null,2,[$APP.P,"generic solve-linear.\n\nFor a given `a` and `b`, returns `x` such that `a*x \x3d b`.\n\n  See[[solve-linear-right]] for a similar function that solves for `a \x3d x*b`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,WUb,$APP.X,aG,$APP.h,new $APP.f(null,2,[$APP.P,"generic freeze.\n\nFreezing an expression means removing wrappers and other metadata from\n  subexpressions, so that the result is basically a pure S-expression with the\n  same structure as the input. Doing this will rob an expression of useful\n  information for further computation; so this is intended to be done just\n  before simplification and printing, to simplify those processes.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,jdb,$APP.X,LO,$APP.h,new $APP.f(null,2,[$APP.P,"generic dimension",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,pfb,$APP.X,MZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic tanhc.\n\nThe [tanhc function](https://en.wikipedia.org/wiki/Tanhc_function),\n  equivalent to $\\frac{\\tanh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanhc_function)\n   - [Mathworld page on Tanhc](https://mathworld.wolfram.com/TanhcFunction.html)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,dEb,$APP.X,fO,$APP.h,new $APP.f(null,2,[$APP.P,"generic cos.\n\nReturns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,jUb,$APP.X,wM,$APP.h,new $APP.f(null,2,[$APP.P,"generic gcd.\n\nReturns the [greatest common\n  divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the two\n  inputs `a` and `b`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,GJb,$APP.X,lZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic exp10.\n\nReturns the base-10 exponential of `x`. Equivalent to `(expt 10 x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,m5b,$APP.X,TZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic cross-product",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,
3,[$APP.R,Klb,$APP.X,lI,$APP.h,new $APP.f(null,2,[$APP.P,"generic modulo.\n\nReturns the result of the\n  mathematical [Modulo](https://en.wikipedia.org/wiki/Modulo_operation)\n  operation between `a` and `b` (using the Knuth definition listed).\n\n The contract satisfied by [[modulo]] is:\n\n```clojure\n(\x3d a (+ (* b (floor (/ a b)))\n        (modulo a b)))\n```\n\n For numbers, this differs from the contract offered by [[remainder]]\n because `(floor (/ a b))` rounds toward negative infinity, while\n the [[quotient]] operation in the contract for [[remainder]] rounds toward 0.\n\n The result will be either `0` or of the same sign as the divisor `b`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,kqb,$APP.X,QF,$APP.h,new $APP.f(null,2,[$APP.P,"Generic implementation of `/`.\n\n  If one argument is supplied, returns the multiplicative inverse of `a`. Else\n  returns the result of dividing first argument `a` by the product of all\n  remaining arguments. `(/)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core//`. Dispatch is open,\n  however, making it possible to 'divide' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (/ [2 4 6] 2)\n  ;;\x3d\x3e (up 1 2 3)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,Clb,$APP.X,TF,$APP.h,new $APP.f(null,2,[$APP.P,"generic exact?.\n\nEntries that are exact are available for `gcd`, among other operations.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Ftb,$APP.X,SZ,$APP.h,new $APP.f(null,2,
[$APP.P,"generic outer-product",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,idb,$APP.X,hG,$APP.h,new $APP.f(null,2,[$APP.P,"generic abs",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,TGb,$APP.X,OF,$APP.h,new $APP.f(null,2,[$APP.P,"generic invert.\n\nReturns the multiplicative inverse of `a`.\n\n  Equivalent to `(/ 1 a)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],
null),new $APP.f(null,3,[$APP.R,i9b,$APP.X,BH,$APP.h,new $APP.f(null,2,[$APP.P,"generic dot-product",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,Xkb,$APP.X,xH,$APP.h,new $APP.f(null,2,[$APP.P,"generic real-part",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,$bc,$APP.X,pG,$APP.h,new $APP.f(null,2,[$APP.P,"generic log.\n\nReturns the natural logarithm of `x`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,aEb,$APP.X,mR,$APP.h,new $APP.f(null,2,[$APP.P,"generic partial-derivative",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,AXb,$APP.X,tH,$APP.h,new $APP.f(null,2,[$APP.P,"generic cosh.\n\nComputes the [hyperbolic\n cosine](https://mathworld.wolfram.com/HyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x + e^{-x}) / 2`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,KXb,$APP.X,DZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic coth.\n\nComputes the [hyperbolic\n cotangent](https://mathworld.wolfram.com/HyperbolicCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `cosh(x) / sinh(x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,qib,$APP.X,NF,$APP.h,new $APP.f(null,2,[$APP.P,"generic one-like.\n\nIn general, this procedure returns the multiplicative identity of the type of\n  its argument, if it exists. For numbers this is 1.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,A9b,$APP.X,rI,$APP.h,new $APP.f(null,2,[$APP.P,"generic expt",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,cRb,$APP.X,sZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic fractional-part.\n\nReturns the fractional part of the given value, defined as `x - x`.\n\n  For positive numbers, this is identical to `(- a (integer-part a))`. For\n  negative `a`, because [[floor]] truncates toward negative infinity, you might\n  be surprised to find that [[fractional-part]] returns the distance between `a`\n  and the next-lowest integer:\n\n```clojure\n(\x3d 0.6 (fractional-part -0.4))\n```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,fmb,$APP.X,QZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic trace",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,mqb,$APP.X,kG,$APP.h,new $APP.f(null,2,[$APP.P,"Generic implementation of `+`. Returns the sum of all supplied arguments. `(+)`\n  returns 0, the additive identity.\n\n  When applied between numbers, acts like `clojure.core/+`. Dispatch is open,\n  however, making it possible to 'add' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (+ [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up 3 5 7)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,ahb,$APP.X,wZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic sec.\n\nComputes the secant of the supplied argument `a`.\n\nEquivalent to `(invert (cos a))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,klb,$APP.X,PF,$APP.h,new $APP.f(null,
2,[$APP.P,"generic negate.\n\nReturns the negation of `a`.\n\n  Equivalent to `(- (g/zero-like a) a)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,z1b,$APP.X,IZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acoth.\n\nComputes the [inverse hyperbolic\n cotangent](https://mathworld.wolfram.com/InverseHyperbolicCotangent.html) of\n the supplied argument `a`.\n\ndefaults to `1/2 ln((x+1)/(x-1))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],
null)],null),new $APP.f(null,3,[$APP.R,Opb,$APP.X,CZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic sech.\n\nComputes the [hyperbolic\n secant](https://mathworld.wolfram.com/HyperbolicSecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / cosh(x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,sdb,$APP.X,nZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic log10.\n\nReturns the base-10 logarithm of `x`, i.e., $log_10(x)$.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,iAb,$APP.X,lG,$APP.h,new $APP.f(null,2,[$APP.P,"generic square",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,i$b,$APP.X,kZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic exp2.\n\nReturns the base-2 exponential of `x`. Equivalent to `(expt 2 x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,yQb,$APP.X,xG,$APP.h,new $APP.f(null,2,[$APP.P,
"generic magnitude",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,PHb,$APP.X,zG,$APP.h,new $APP.f(null,2,[$APP.P,"generic div.\n\nReturns the result of dividing `a` and `b`.\n\n  Equivalent to `(* a (negate b))`.\n\n  See [[/]] for a variadic version of [[div]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,g3b,$APP.X,mG,$APP.h,new $APP.f(null,2,[$APP.P,"generic infinite?.\n\nReturns true if `a` is either numerically infinite (i.e., equal to `##Inf`) or\n  a compound number (complex or quaterion, for example) with some infinite\n  component.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,eEb,$APP.X,uZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic cot.\n\nComputes the trigonometric cotangent function of the supplied argument `a`.\n\nEquivalent to `(invert (tan a))`, or `(/ (cos a) (sin a))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,lqb,$APP.X,iG,$APP.h,new $APP.f(null,2,[$APP.P,'Generic implementation of `*`. Returns the product of all supplied\n  arguments. `(*)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core/*`. Dispatch is open,\n  however, making it possible to \'multiply\' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (* 2 #emmy/complex "3 + 1i")\n  ;;\x3d\x3e #emmy/complex "6 + 2i"\n  ```',
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,mbb,$APP.X,zZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic asec.\n\nComputes the [inverse\n secant](https://mathworld.wolfram.com/InverseSecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(sqrt(x^2 - 1))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],
null)],null),new $APP.f(null,3,[$APP.R,Kdb,$APP.X,cR,$APP.h,new $APP.f(null,2,[$APP.P,"generic solve-linear-right.\n\nFor a given `a` and `b`, returns `x` such that `a \x3d x*b`.\n\n  See[[solve-linear]] for a similar function that solves for `a*x \x3d b`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,kib,$APP.X,KZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acsch.\n\nComputes the [inverse hyperbolic\n cosecant](https://mathworld.wolfram.com/InverseHyperbolicCosecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1+x^2)) / x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Wlb,$APP.X,SF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is either:\n\n  - [[integral?]],\n  - a floating point number either \x3c [[absolute-integer-tolerance]] (if near\n    zero) or within [[relative-integer-tolerance]] of the closest integer,\n\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,w5b,$APP.X,mZ,$APP.h,new $APP.f(null,
2,[$APP.P,"generic log2.\n\nReturns the base-2 logarithm of `x`, i.e., $log_2(x)$.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,x3b,$APP.X,KF,$APP.h,new $APP.f(null,2,[$APP.P,"generic zero?.\n\nIs true if `x` is an additive identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,$fb,$APP.X,rG,$APP.h,new $APP.f(null,2,[$APP.P,"generic atan.\n\nComputes the inverse tangent of the supplied argument `a`. Given two\n  arguments `a` and `b`, returns the inverse tangent of the angle formed by the\n  point `(b, a)` in a 2-dimensional euclidean plane.\n\n  The two-argument version is sometimes\n  called [Atan2](https://en.wikipedia.org/wiki/Atan2).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,ZMb,$APP.X,NZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic make-rectangular",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,aGb,$APP.X,vZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic csc.\n\nComputes the cosecant of the supplied argument `a`.\n\nEquivalent to `(invert (sin a))`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,sbc,$APP.X,oM,$APP.h,new $APP.f(null,2,[$APP.P,"generic lcm.\n\nReturns the [least common\n  multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of the two\n  inputs `a` and `b`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,JCb,$APP.X,AZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acsc.\n\nComputes the [inverse\n cosecant](https://mathworld.wolfram.com/InverseCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(1 / sqrt(x^2 - 1))`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,jDb,$APP.X,kO,$APP.h,new $APP.f(null,2,[$APP.P,"generic acos.\n\nComputes the inverse cosine of the supplied argument `a`.\n\nDefaults to `atan(sqrt(1-x^2)/x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,oDb,$APP.X,yZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acot.\n\nComputes the [inverse\n cotangent](https://mathworld.wolfram.com/InverseCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `pi/2 - atan(x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Nhb,$APP.X,pZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic floor.\n\nReturns the largest integer less than or equal to `a`.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Q1b,$APP.X,
AH,$APP.h,new $APP.f(null,2,[$APP.P,"generic imag-part",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Ytb,$APP.X,bR,$APP.h,new $APP.f(null,2,[$APP.P,"generic Lie-derivative",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,pxb,$APP.X,UF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied argument is an exact numerical zero, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.uU],
null))],null)],null),new $APP.f(null,3,[$APP.R,jqb,$APP.X,RF,$APP.h,new $APP.f(null,2,[$APP.P,"Generic implementation of `-`.\n\n  If one argument is supplied, returns the negation of `a`. Else returns the\n  difference of the first argument `a` and the sum of all remaining\n  arguments. `(-)` returns 0.\n\n  When applied between numbers, acts like `clojure.core/-`. Dispatch is open,\n  however, making it possible to 'subtract' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (- [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up -1 -1 -1)\n\n  (- [1 10])\n  ;;\x3d\x3e (up -1 -10)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.SP],null),new $APP.H(null,4,5,$APP.I,[$APP.Vv,$APP.SP,$APP.Lh,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.R,YKb,$APP.X,LF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `x` is both a [[number?]] and [[zero?]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,cNb,$APP.X,RZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic inner-product",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.qU],null))],null)],null),new $APP.f(null,3,[$APP.R,v1b,$APP.X,FZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acosh.\n\nComputes the [inverse hyperbolic\n cosine](https://mathworld.wolfram.com/InverseHyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `2 ln(sqrt((x+1)/2) + sqrt((x-1)/2))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,XGb,$APP.X,rZ,$APP.h,new $APP.f(null,2,[$APP.P,
"generic ceiling.\n\nReturns the result of rounding `a` up to the next largest integer.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,wJb,$APP.X,rR,$APP.h,new $APP.f(null,2,[$APP.P,"generic sinc.\n\nThe unnormalized [sinc\n  function](https://en.wikipedia.org/wiki/Sinc_function), equivalent to\n  $\\frac{\\sin x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/SincFunction.html)\n   - [Boost notes on [[sinc]]\n     and [[sinch]]](https://www.boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sinc/sinc_overview.html)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Orb,$APP.X,qL,$APP.h,new $APP.f(null,2,[$APP.P,"generic conjugate",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Ozb,$APP.X,tR,$APP.h,new $APP.f(null,2,[$APP.P,"generic sinhc.\n\nThe [sinhc function](https://en.wikipedia.org/wiki/Sinhc_function),\n  equivalent to $\\frac{\\sinh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinhc_function)\n   - [Mathworld page on Sinhc](https://mathworld.wolfram.com/SinhcFunction.html)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,A8b,$APP.X,jG,$APP.h,new $APP.f(null,2,[$APP.P,"generic sqrt",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,zwb,$APP.X,JZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic asech.\n\nComputes the [inverse hyperbolic\n secant](https://mathworld.wolfram.com/InverseHyperbolicSecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1-x^2)) / x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Xcb,$APP.X,xZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic asin.\n\nComputes the inverse sine of the supplied argument `a`.\n\nDefaults to `atan(x/sqrt(1-x^2))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Vvb,$APP.X,eR,$APP.h,new $APP.f(null,2,[$APP.P,"generic transpose",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,
3,[$APP.R,Twb,$APP.X,oG,$APP.h,new $APP.f(null,2,[$APP.P,"generic exp.\n\nReturns the base-e exponential of `x`. Equivalent to `(expt e x)`, given\n  some properly-defined `e` symbol.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,tSb,$APP.X,qG,$APP.h,new $APP.f(null,2,[$APP.P,"generic negative?.\n\nReturns true if the argument `a` is less than `(g/zero-like a)`,\n  false otherwise. The default implementation depends on a proper Comparable\n  implementation on the type.`",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Cbb,$APP.X,qZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic integer-part.\n\nReturns the integer part of `a` by removing any fractional digits.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,QOb,$APP.X,GZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic asinh.\n\nComputes the [inverse hyperbolic\n sine](https://mathworld.wolfram.com/InverseHyperbolicSine.html) of the\n supplied argument `a`.\n\ndefaults to `ln(x + sqrt(1 + x^2))`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,TKb,$APP.X,BZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic tanh.\n\nComputes the [hyperbolic\n tangent](https://mathworld.wolfram.com/HyperbolicTangent.html) of the supplied\n argument `a`.\n\ndefaults to `sinh(x) / cosh(x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,IDb,$APP.X,iZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic identity?.\n\nLike `one?`, but this is true of square identity matrices as well.\n  No matrix is considered `one?` because its function as a multiplicative\n  identity depends on the shape of the other multiplicand.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,rFb,$APP.X,tG,$APP.h,new $APP.f(null,2,[$APP.P,"generic zero-like.\n\nIn general, this procedure returns the additive identity of the type of its\n  argument, if it exists. For numbers this is 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,Yub,$APP.X,PZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic angle",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],
null))],null)],null),new $APP.f(null,3,[$APP.R,t6b,$APP.X,bG,$APP.h,new $APP.f(null,2,[$APP.P,"generic simplify",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null),new $APP.f(null,3,[$APP.R,fec,$APP.X,HZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic atanh.\n\nComputes the [inverse hyperbolic\n tangent](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) of the\n supplied argument `a`.\n\ndefaults to `1/2 ln((1+x)/(1-x))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],
null))],null)],null),new $APP.f(null,3,[$APP.R,BJb,$APP.X,sG,$APP.h,new $APP.f(null,2,[$APP.P,"generic one?.\n\nIs true if `x` is a multiplicative identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null))],null)],null)]),$APP.Zo(jZb)),$APP.ap($APP.fg([qKb,$APP.z(Ofb,new $APP.f(null,3,[$APP.Nm,mW,$APP.P,"Returns a coordinate representation of the supplied manifold point `point`,\n    as specified by this [[ICoordinateSystem]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,
$APP.fU],null)))],null)),eVb,exb,cIb,kxb,$APP.z($APP.fU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),$APP.P,"Given an [[ICoordinateSystem]], returns a function from coordinates in\n  `coordinate-system`'s repesentation to the matching point on the manifold\n  associated with `coordinate-system`."],null)),Uwb,$APP.z(lCb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bV],null),$APP.z(new $APP.H(null,2,5,$APP.I,[bV,dW],null),new $APP.f(null,
1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.qpa,new $APP.ug(null,new $APP.f(null,3,[$APP.M($APP.K,NN),"null",$APP.M($APP.K,p$b),"null",$APP.M($APP.K,kX),"null"],null),null),dW)],null)],null)))),$APP.P,"Generates a manifold family (a template for building manifolds) from the\n  supplied `name-format`.\n\n  Generated manifolds locally resemble Euclidean space (Rn) by default. You can\n  optionally pass `'Complex` or `'Quaternion` to `over` to customize the field\n  of the vector space that the manifold locally resembles at each point.\n\n  NOTE: only `'Real` does anything as of 3.15.2021.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,2,$APP.nw,2,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[bV],null),new $APP.H(null,2,5,$APP.I,[bV,dW],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bV],null),new $APP.H(null,2,5,$APP.I,[bV,dW],null)),$APP.zx,$APP.M(null,null)],null)],null)),B0b,VVb,$APP.z(nU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[kT],null))),$APP.P,"Returns the symbolic coordinate prototype associated with `coordsys`. This is\n   a structure of the correct dimension for this coordinate system, with all\n   symbolic entries.\n\n  Returns nil for non-valid inputs."],
null)),zdb,Z1b,$APP.z(DXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[HKb,V9b],null))),$APP.P,"Returns a function that takes a single manifold `point` embedded in the\n  manifold `embedded` and transfers the point to the supplied `embedding`\n  manifold.\n\n  The embedding dimension must be the same for both manifolds.\n\n  NOTE that `embedded` and `embedding` can be either manifolds, or instances\n  of [[ICoordinateSystem]]. In the latter case `embedded` and `embedding` will\n  bind to the manifold associated with the supplied [[ICoordinateSystem]]."],
null)),$APP.z(TVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fU],null))),$APP.P,"Returns the backing Euclidean space representation of the supplied manifold\n  point."],null)),$APP.z(ydc,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[ZR,nU,$APP.uU,$APP.tx,jjb],null))),
$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57547."],null)),uxb,$APP.z(yIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[Qxb,oW,eY],null))),$APP.P,"Returns the representation of `manifold-point` in `coordinate-system`.\n\n  If an entry for the given `coordinate-system` is not found, `thunk` is called\n  to produce the representation. The representation is cached in the point."],null)),rdb,emb,$APP.z(T5b,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns `true` if `m` is a dictionary representing a manifold, false\n  otherwise."],null)),$APP.z($APP.wx,new $APP.f(null,1,[$APP.Pu,!0],null)),$APP.z(S3a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.uU,mU,$APP.Kv],null))),$APP.P,"Generates a coordinate structure of the supplied dimension `n`, and\n  `orientation` using the supplied function `f` for entries. See the very\n  similar [[emmy.structure/generate]] for more details.\n\n  NOTE from GJS: this is a kludge introduced only to allow a coordinate of\n  dimension 1 to automatically unwrap itself."],
null)),$APP.z(O1b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[uV,$APP.uU],null),$APP.z(new $APP.H(null,3,5,$APP.I,[uV,$APP.uU,tX],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,3,5,$APP.I,[$APP.M($APP.rsa,$APP.uU),$APP.M($APP.Yv,$APP.uU,0),$APP.M($APP.$v,tX,$APP.uU)],null)],null)))),$APP.P,"Returns a concrete manifold generated by specializing the supplied manifold\n  `family` into a concrete manifold of dimension `n`. `n` must be a positive\n  integer.\n\n  Optionally takes an `embedding-dimension`; this must be \x3e\x3d the value of `n`.\n  Use this in cases like an n-sphere embedded in a euclidean space of dimension\n  n+1.\n\n  A [manifold](https://en.wikipedia.org/wiki/Manifold) is a topological space\n  that locally resembles Euclidean space near each point.",
$APP.hy,new $APP.f(null,6,[$APP.ru,!1,$APP.Sn,3,$APP.nw,3,$APP.ty,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[uV,$APP.uU],null),new $APP.H(null,3,5,$APP.I,[uV,$APP.uU,tX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[uV,$APP.uU],null),new $APP.H(null,3,5,$APP.I,[uV,$APP.uU,tX],null)),$APP.zx,$APP.M(null,null)],null)],null)),xrb,$APP.z(lPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[uV,gW],null))),$APP.P,"Takes a manifold `family` and attaches a patch template with the supplied\n  `patch-name`. Returns a new manifold family.\n\n  All manifolds generated from the returned family will have this coordinate\n  patch attached."],
null)),$APP.z(DY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns true if `p` is a manifold point, false otherwise."],null)),$APP.z(o8b,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[ZR,nU,$APP.tx,hub],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57497."],
null)),$APP.z(Zac,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,9,5,$APP.I,[VU,GV,ZR,nU,$APP.uU,OT,sY,$APP.tx,Gqb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57524."],null)),$APP.z(bub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[uV,
TX,gW,L8b],null))),$APP.P,"Returns a new manifold family generated by attaching the supplied coordinate\n  system constructor to `family`, indexed by the supplied patch and coordinate\n  system names."],null)),aZb,nrb,$APP.z(h5b,new $APP.f(null,3,[$APP.Nm,mW,$APP.P,"Returns the manifold point on this [[ICoordinateSystem]]'s manifold\n    corresponding to the supplied `coords`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null)))],null)),$APP.z(d$b,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[ZR,TX,gW],null))),$APP.P,"Returns an [[ICoordinateSystem]] instance specialized to the patch named\n  `patch-name` on `manifold`."],null)),eac,BOb,CDb,$APP.z(ZR,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"If `m` is a manifold, acts as identity. Else, if given some structure\n  associated with a manifold (like a coordinate system), returns the associated\n  manifold."],null)),$APP.z(zLb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(DY,$APP.fU)],null)],null)))),$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 0."],null)),$APP.z(Lxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fU],null))),$APP.P,"Return the manifold upon which this `point` was defined."],null)),x7b,Hgb,$APP.z(Fsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(DY,$APP.fU)],null)],null)))),$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 1."],null)),$APP.z(U5b,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,
[ZR,nU,$APP.tx,Aub],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57486."],null)),$APP.z(FAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),$APP.P,"Given an [[ICoordinateSystem]], returns a unique, symbolically-represented\n  point on the manifold associated with `coordinate-system`.\n\n  See [[typical-coords]] for a coordinate-based version of this function."],null)),w3b,$APP.z(tYb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.nW],null))),$APP.P,"Takes a coordinate representation `coords` of a manifold point with all\n  symbolic entries, and returns a structure of the same shape with `v:`\n  prepended to all symbols.\n\n  This structure is appropriate for representing the velocities associated with\n  each coordinate."],null)),$APP.z(bXb,new $APP.f(null,3,[$APP.Nm,mW,$APP.P,"Returns true if the supplied coordinates `coords` can be converted into a\n    point by this [[ICoordinateSystem]], false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null)))],null)),$APP.z(kXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))),$APP.P,"Returns `true` if `m` is a dictionary representing a manifold family, false\n  otherwise."],null)),Esb,$APP.z(b3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),$APP.P,"Given an [[ICoordinateSystem]], returns a structure that matches\n  the [[coordinate-prototype]] of `coordinate-system`, with all unique,\n  gensym-ed entries.\n\n  Use [[typical-coords]] if you require a unique symbolic coordinate\n  representation compatible with `coordinate-system`.\n\n  See [[typical-point]] for a coordinate-free version of this function."],
null)),oAb,$APP.z(SPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ZR],null))),$APP.P,"The supplied manifold `m` locally resembles some vector space; this function\n  returns the field over which that vector space was specified."],null)),s0b,Wib,Ejb,Wwb,$APP.z(J7b,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,4,5,$APP.I,[ZR,nU,$APP.tx,wxb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57475."],null)),$APP.z(hdc,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,9,5,$APP.I,[VU,GV,ZR,nU,$APP.uU,OT,sY,$APP.tx,fqb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57534."],
null)),M$b,Zwb,G2b,$APP.z(Q8b,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,7,5,$APP.I,[mU,wLb,GV,ZR,nU,$APP.tx,Qtb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57506."],null)),Vwb,Uxb,i_b,$APP.z(R5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `x` implements [[ICoordinateSystem]], false otherwise."],null)),dKb,oWb,BVb,$APP.z(VEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))),$APP.P,"Given an [[ICoordinateSystem]], returns a function from a point on the\n  coordinate system's manifold to the coordinate representation specified by the\n  supplied `coordinate-system`."],null)),$APP.z(Vdb,new $APP.f(null,4,[DE,!0,dS,new $APP.f(null,1,[$APP.Mm,new $APP.f(null,
5,[$APP.z(bXb,new $APP.f(null,1,[$APP.P,"Returns true if the supplied coordinates `coords` can be converted into a\n    point by this [[ICoordinateSystem]], false otherwise."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null)],null),$APP.z(KGb,new $APP.f(null,1,[$APP.P,"Returns true if the supplied `point` can be converted into coordinates by\n    this [[ICoordinateSystem]], false otherwise."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Qu,
$APP.fU],null)],null),$APP.z(h5b,new $APP.f(null,1,[$APP.P,"Returns the manifold point on this [[ICoordinateSystem]]'s manifold\n    corresponding to the supplied `coords`."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null)],null),$APP.z(Ofb,new $APP.f(null,1,[$APP.P,"Returns a coordinate representation of the supplied manifold point `point`,\n    as specified by this [[ICoordinateSystem]]."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Qu,
$APP.fU],null)],null),$APP.z($APP.wx,new $APP.f(null,1,[$APP.P,"Returns a unique identifier for this instance of [[ICoordinateSystem]].\n\n    (This is an internal implementation detail to allow us to attach coordinate\n    prototypes and other items as metadata to an [[ICoordinateSystem]] without\n    affecting equality.)"],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Qu],null)],null)],null)],null),$APP.Lv,new $APP.f(null,5,[c9b,new $APP.f(null,3,[$APP.R,bXb,$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Qu,$APP.nW],null)),$APP.P,"Returns true if the supplied coordinates `coords` can be converted into a\n    point by this [[ICoordinateSystem]], false otherwise."],null),U3a,new $APP.f(null,3,[$APP.R,KGb,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.fU],null)),$APP.P,"Returns true if the supplied `point` can be converted into coordinates by\n    this [[ICoordinateSystem]], false otherwise."],null),uRb,new $APP.f(null,3,[$APP.R,h5b,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,
$APP.nW],null)),$APP.P,"Returns the manifold point on this [[ICoordinateSystem]]'s manifold\n    corresponding to the supplied `coords`."],null),Ztb,new $APP.f(null,3,[$APP.R,Ofb,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.fU],null)),$APP.P,"Returns a coordinate representation of the supplied manifold point `point`,\n    as specified by this [[ICoordinateSystem]]."],null),B8b,new $APP.f(null,3,[$APP.R,$APP.wx,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qu],null)),$APP.P,"Returns a unique identifier for this instance of [[ICoordinateSystem]].\n\n    (This is an internal implementation detail to allow us to attach coordinate\n    prototypes and other items as metadata to an [[ICoordinateSystem]] without\n    affecting equality.)"],
null)],null),eU,$APP.M("@interface")],null)),$APP.z(MNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,oW],null))),$APP.P,"Given a symbolic name `sym` and an [[ICoordinateSystem]], returns a literal\n  function that maps coordinate-free manifold points to a scalar output.\n\n  Also aliased as [[literal-manifold-function]]."],null)),Zvb,Swb,$APP.z(zbc,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,
new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,10,5,$APP.I,[Lhb,GV,VU,$APP.uU,ZR,$APP.tx,sY,OT,nU,Otb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57516."],null)),$APP.z(sQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[ZR,gW],null))),$APP.P,"Returns the patch named by `patch-name` within the supplied `manifold` if\n  registered. Throws otherwise.\n\n  NOTE that the returned patch will keep a reference to the supplied `manifold`\n  under a `:manifold` key.\n\n  A coordinate patch is a simply-connected open set around a point in the\n  manifold. A manifold might have many patches. Coordinate systems are defined\n  on patches; these allow the parameterization of any point on the patch in\n  terms of a tuple of real numbers (the coordinates)."],
null)),YFb,$APP.z(a3b,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[ZR,nU,$APP.tx,kvb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57470."],null)),x6b,$APP.z(Xcc,new $APP.f(null,6,[lE,!0,VE,new $APP.ug(null,new $APP.f(null,3,[mW,"null",lS,"null",nT,"null"],
null),null),VR,new $APP.ug(null,new $APP.f(null,2,[lS,"null",nT,"null"],null),null),$APP.lw,ST,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[ZR,nU,$APP.uU,$APP.tx,Jlb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57539."],null)),$APP.z(Mcb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[ZR],null))),$APP.P,"Returns a set of patch names registered in the supplied manifold."],null)),DCb,$APP.z(KGb,new $APP.f(null,
3,[$APP.Nm,mW,$APP.P,"Returns true if the supplied `point` can be converted into coordinates by\n    this [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.fU],null)))],null)),$APP.z(CVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[kT,oE],null))),$APP.P,"Returns an identical `coordsys` with the new `coordinate-prototype` installed."],null)),Prb,$APP.z($2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[Ufb],null))),$APP.P,"Returns a set of names of all coordinate system constructors registered in the\n  supplied patch."],null)),Dnb,I3b,dxb,$APP.z(N1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null))),$APP.P,"Takes some constant `c` and returns a manifold function that maps every input\n  manifold `point` to `c.`"],null))],[new $APP.f(null,3,[$APP.R,gxb,$APP.X,mrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,IVb,$APP.X,AO,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a coordinate representation of the supplied manifold point `point`,\n    as specified by this [[ICoordinateSystem]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.fU],null))],null)],null),new $APP.f(null,3,[$APP.R,rDb,$APP.X,grc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,gpb,$APP.X,q3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,L0b,$APP.X,Tqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Zob,$APP.X,k3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,j$b,$APP.X,EO,
$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from coordinates in\n  `coordinate-system`'s repesentation to the matching point on the manifold\n  associated with `coordinate-system`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,Fob,$APP.X,Uqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,RWb,$APP.X,c3,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a manifold family (a template for building manifolds) from the\n  supplied `name-format`.\n\n  Generated manifolds locally resemble Euclidean space (Rn) by default. You can\n  optionally pass `'Complex` or `'Quaternion` to `over` to customize the field\n  of the vector space that the manifold locally resembles at each point.\n\n  NOTE: only `'Real` does anything as of 3.15.2021.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bV],null),$APP.z(new $APP.H(null,2,5,$APP.I,[bV,dW],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.qpa,new $APP.ug(null,new $APP.f(null,3,[$APP.M($APP.K,NN),"null",$APP.M($APP.K,p$b),"null",$APP.M($APP.K,kX),"null"],null),null),dW)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,I_b,$APP.X,lrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,GAb,$APP.X,Tqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,veb,$APP.X,CO,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns the symbolic coordinate prototype associated with `coordsys`. This is\n   a structure of the correct dimension for this coordinate system, with all\n   symbolic entries.\n\n  Returns nil for non-valid inputs.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[kT],null))],null)],null),new $APP.f(null,3,[$APP.R,Y6b,$APP.X,brc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ASb,$APP.X,p3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,w$b,$APP.X,I3a,$APP.h,new $APP.f(null,2,
[$APP.P,"Returns a function that takes a single manifold `point` embedded in the\n  manifold `embedded` and transfers the point to the supplied `embedding`\n  manifold.\n\n  The embedding dimension must be the same for both manifolds.\n\n  NOTE that `embedded` and `embedding` can be either manifolds, or instances\n  of [[ICoordinateSystem]]. In the latter case `embedded` and `embedding` will\n  bind to the manifold associated with the supplied [[ICoordinateSystem]].",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[HKb,V9b],null))],null)],null),new $APP.f(null,3,[$APP.R,TWb,$APP.X,wO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the backing Euclidean space representation of the supplied manifold\n  point.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fU],null))],null)],null),new $APP.f(null,3,[$APP.R,qPb,$APP.X,JO.El,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57547.",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[ZR,nU,$APP.uU,$APP.tx,
jjb],null))],null)],null),new $APP.f(null,3,[$APP.R,vpb,$APP.X,n3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,KVb,$APP.X,yO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the representation of `manifold-point` in `coordinate-system`.\n\n  If an entry for the given `coordinate-system` is not found, `thunk` is called\n  to produce the representation. The representation is cached in the point.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[Qxb,oW,eY],null))],null)],null),new $APP.f(null,3,[$APP.R,vrb,$APP.X,
qrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,umb,$APP.X,hrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,i0b,$APP.X,l3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,W3a,$APP.X,uO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a unique identifier for this instance of [[ICoordinateSystem]].\n\n    (This is an internal implementation detail to allow us to attach coordinate\n    prototypes and other items as metadata to an [[ICoordinateSystem]] without\n    affecting equality.)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qu],null))],null)],null),new $APP.f(null,3,[$APP.R,SMb,$APP.X,O3a,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a coordinate structure of the supplied dimension `n`, and\n  `orientation` using the supplied function `f` for entries. See the very\n  similar [[emmy.structure/generate]] for more details.\n\n  NOTE from GJS: this is a kludge introduced only to allow a coordinate of\n  dimension 1 to automatically unwrap itself.",$APP.U,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.uU,mU,$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.R,pAb,$APP.X,d3,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a concrete manifold generated by specializing the supplied manifold\n  `family` into a concrete manifold of dimension `n`. `n` must be a positive\n  integer.\n\n  Optionally takes an `embedding-dimension`; this must be \x3e\x3d the value of `n`.\n  Use this in cases like an n-sphere embedded in a euclidean space of dimension\n  n+1.\n\n  A [manifold](https://en.wikipedia.org/wiki/Manifold) is a topological space\n  that locally resembles Euclidean space near each point.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[uV,$APP.uU],null),$APP.z(new $APP.H(null,3,5,$APP.I,[uV,$APP.uU,tX],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,3,5,$APP.I,[$APP.M($APP.rsa,$APP.uU),$APP.M($APP.Yv,$APP.uU,0),$APP.M($APP.$v,tX,$APP.uU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,WGb,$APP.X,krc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Q3a,$APP.X,rO,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a manifold `family` and attaches a patch template with the supplied\n  `patch-name`. Returns a new manifold family.\n\n  All manifolds generated from the returned family will have this coordinate\n  patch attached.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[uV,gW],null))],null)],null),new $APP.f(null,3,[$APP.R,n8b,$APP.X,B3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `p` is a manifold point, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.R,LWb,$APP.X,JO.yl,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57497.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[ZR,nU,$APP.tx,hub],
null))],null)],null),new $APP.f(null,3,[$APP.R,vVb,$APP.X,JO.Bl,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57524.",$APP.U,$APP.M(new $APP.H(null,9,5,$APP.I,[VU,GV,ZR,nU,$APP.uU,OT,sY,$APP.tx,Gqb],null))],null)],null),new $APP.f(null,3,[$APP.R,vCb,$APP.X,sO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new manifold family generated by attaching the supplied coordinate\n  system constructor to `family`, indexed by the supplied patch and coordinate\n  system names.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[uV,TX,gW,L8b],null))],null)],null),new $APP.f(null,3,[$APP.R,Inb,$APP.X,arc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,J_b,$APP.X,orc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Gib,$APP.X,zO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the manifold point on this [[ICoordinateSystem]]'s manifold\n    corresponding to the supplied `coords`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null))],null)],null),new $APP.f(null,3,[$APP.R,xyb,$APP.X,
tO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an [[ICoordinateSystem]] instance specialized to the patch named\n  `patch-name` on `manifold`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[ZR,TX,gW],null))],null)],null),new $APP.f(null,3,[$APP.R,Phb,$APP.X,Vqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,AJb,$APP.X,crc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,qxb,$APP.X,erc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,MWb,$APP.X,pO,$APP.h,new $APP.f(null,2,[$APP.P,"If `m` is a manifold, acts as identity. Else, if given some structure\n  associated with a manifold (like a coordinate system), returns the associated\n  manifold.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,w1b,$APP.X,L3a,$APP.h,new $APP.f(null,2,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 0.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(DY,$APP.fU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.R,EQb,$APP.X,A3a,$APP.h,new $APP.f(null,2,[$APP.P,"Return the manifold upon which this `point` was defined.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.fU],null))],null)],null),new $APP.f(null,3,[$APP.R,z5b,$APP.X,vrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,EMb,$APP.X,Xqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Ceb,$APP.X,M3a,$APP.h,new $APP.f(null,2,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 1.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.fU],null),new $APP.f(null,1,[$APP.yw,new $APP.H(null,1,5,$APP.I,[$APP.M(DY,$APP.fU)],null)],null)))],
null)],null),new $APP.f(null,3,[$APP.R,UVb,$APP.X,JO.xl,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57486.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[ZR,nU,$APP.tx,Aub],null))],null)],null),new $APP.f(null,3,[$APP.R,Djb,$APP.X,H3a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[ICoordinateSystem]], returns a unique, symbolically-represented\n  point on the manifold associated with `coordinate-system`.\n\n  See [[typical-coords]] for a coordinate-based version of this function.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,$_b,$APP.X,irc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ifb,$APP.X,J3a,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a coordinate representation `coords` of a manifold point with all\n  symbolic entries, and returns a structure of the same shape with `v:`\n  prepended to all symbols.\n\n  This structure is appropriate for representing the velocities associated with\n  each coordinate.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.nW],null))],null)],null),new $APP.f(null,3,[$APP.R,lNb,$APP.X,D3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied coordinates `coords` can be converted into a\n    point by this [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.nW],null))],null)],null),new $APP.f(null,3,[$APP.R,Dxb,$APP.X,k3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold family, false\n  otherwise.",$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Or],null))],null)],null),new $APP.f(null,3,[$APP.R,yhb,$APP.X,urc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,fNb,$APP.X,G3a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[ICoordinateSystem]], returns a structure that matches\n  the [[coordinate-prototype]] of `coordinate-system`, with all unique,\n  gensym-ed entries.\n\n  Use [[typical-coords]] if you require a unique symbolic coordinate\n  representation compatible with `coordinate-system`.\n\n  See [[typical-point]] for a coordinate-free version of this function.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,Iob,$APP.X,yrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,kdc,$APP.X,o3a,$APP.h,new $APP.f(null,2,[$APP.P,"The supplied manifold `m` locally resembles some vector space; this function\n  returns the field over which that vector space was specified.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[ZR],null))],null)],null),new $APP.f(null,3,[$APP.R,vZb,$APP.X,xrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,
zIb,$APP.X,trc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,mOb,$APP.X,wrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Hob,$APP.X,$qc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,EWb,$APP.X,JO.wl,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57475.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[ZR,nU,$APP.tx,wxb],null))],null)],null),new $APP.f(null,3,[$APP.R,kVb,$APP.X,JO.Cl,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57534.",
$APP.U,$APP.M(new $APP.H(null,9,5,$APP.I,[VU,GV,ZR,nU,$APP.uU,OT,sY,$APP.tx,fqb],null))],null)],null),new $APP.f(null,3,[$APP.R,aLb,$APP.X,irc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,hpb,$APP.X,o3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Nfb,$APP.X,drc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,fTb,$APP.X,JO.zl,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57506.",$APP.U,$APP.M(new $APP.H(null,7,5,$APP.I,[mU,wLb,GV,
ZR,nU,$APP.tx,Qtb],null))],null)],null),new $APP.f(null,3,[$APP.R,Gob,$APP.X,l3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,hcb,$APP.X,HO,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,vkb,$APP.X,Zqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,dUb,$APP.X,F3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` implements [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.R,Rcc,$APP.X,frc,$APP.h,$APP.F],null),
new $APP.f(null,3,[$APP.R,adc,$APP.X,prc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,KFb,$APP.X,Yqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,g$b,$APP.X,DO,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from a point on the\n  coordinate system's manifold to the coordinate representation specified by the\n  supplied `coordinate-system`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[oW],null))],null)],null),new $APP.f(null,3,[$APP.R,mW,$APP.X,C3a,$APP.h,$APP.F],
null),new $APP.f(null,3,[$APP.R,zKb,$APP.X,HO,$APP.h,new $APP.f(null,2,[$APP.P,"Given a symbolic name `sym` and an [[ICoordinateSystem]], returns a literal\n  function that maps coordinate-free manifold points to a scalar output.\n\n  Also aliased as [[literal-manifold-function]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vx,oW],null))],null)],null),new $APP.f(null,3,[$APP.R,rhb,$APP.X,qrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Kob,$APP.X,Sqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,
LSb,$APP.X,JO.Al,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57516.",$APP.U,$APP.M(new $APP.H(null,10,5,$APP.I,[Lhb,GV,VU,$APP.uU,ZR,$APP.tx,sY,OT,nU,Otb],null))],null)],null),new $APP.f(null,3,[$APP.R,Cxb,$APP.X,t3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the patch named by `patch-name` within the supplied `manifold` if\n  registered. Throws otherwise.\n\n  NOTE that the returned patch will keep a reference to the supplied `manifold`\n  under a `:manifold` key.\n\n  A coordinate patch is a simply-connected open set around a point in the\n  manifold. A manifold might have many patches. Coordinate systems are defined\n  on patches; these allow the parameterization of any point on the patch in\n  terms of a tuple of real numbers (the coordinates).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[ZR,gW],null))],null)],null),new $APP.f(null,3,[$APP.R,oHb,$APP.X,src,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,KWb,$APP.X,JO.vl,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57470.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[ZR,nU,$APP.tx,kvb],null))],null)],null),new $APP.f(null,3,[$APP.R,Bmb,$APP.X,nrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,RUb,$APP.X,JO.Dl,$APP.h,new $APP.f(null,
2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57539.",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[ZR,nU,$APP.uU,$APP.tx,Jlb],null))],null)],null),new $APP.f(null,3,[$APP.R,Sob,$APP.X,q3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a set of patch names registered in the supplied manifold.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[ZR],null))],null)],null),new $APP.f(null,3,[$APP.R,Dwb,$APP.X,zrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Zhb,$APP.X,E3a,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if the supplied `point` can be converted into coordinates by\n    this [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qu,$APP.fU],null))],null)],null),new $APP.f(null,3,[$APP.R,zWb,$APP.X,function(a,b){var c=CO(a);return $APP.Uc.A(c,b)?a:$APP.Xj.M(a,$APP.rg,BO,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns an identical `coordsys` with the new `coordinate-prototype` installed.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[kT,oE],null))],null)],null),new $APP.f(null,3,[$APP.R,nvb,$APP.X,rrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,nRb,$APP.X,u3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a set of names of all coordinate system constructors registered in the\n  supplied patch.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Ufb],null))],null)],null),new $APP.f(null,3,[$APP.R,Mpb,$APP.X,jrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,Xab,$APP.X,Wqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.R,ipb,$APP.X,m3,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.R,Lpb,$APP.X,N3a,$APP.h,new $APP.f(null,2,[$APP.P,"Takes some constant `c` and returns a manifold function that maps every input\n  manifold `point` to `c.`",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Jv],null))],null)],null)]),$APP.Zo(tib))]);$APP.Qsc=new $APP.f(null,2,[$APP.$l,Psc,$APP.Uo,new $APP.f(null,2,[$APP.Zw,$APP.ia,$APP.Vm,$APP.gn],null)],null);$APP.fka($APP.Qsc);$APP.hp($APP.Qsc);
}).call(this);