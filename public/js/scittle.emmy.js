(function(){
shadow$provide[2]=function(G,y,X,g){Object.defineProperty(g,"__esModule",{value:!0});g.Solver=void 0;var A;(function(m){m[m.Start=0]="Start";m[m.BasicIntegrationStep=1]="BasicIntegrationStep";m[m.ConvergenceStep=2]="ConvergenceStep";m[m.HopeForConvergence=3]="HopeForConvergence";m[m.Accept=4]="Accept";m[m.Reject=5]="Reject"})(A||(A={}));class u{constructor(m,e,c={}){this.nEval=this.hMax=0;this.t=[];this.err=0;this.errOld=1E10;this.iPt=this.nReject=this.nAccept=this.nStep=0;this.options=Object.assign({},
u.defaults,c);this.n=e;this.f=this.options.rawFunction?m:(l,n,p)=>{this.copy(p,m(l,n,[]))};if(0>=this.options.maxSteps)throw Error("maxSteps must be positive");if(2>=this.options.maxExtrapolationColumns)throw Error("maxExtrapolationColumns must be \x3e 2");e=this.options.maxExtrapolationColumns;this.options.stepSizeSequence=this.options.stepSizeSequence||(this.options.denseOutput?4:1);if(3>=this.options.stepSizeSequence&&this.options.denseOutput)throw Error("stepSizeSequence incompatible with denseOutput");
if(0>=this.options.interpolationFormulaDegree||7<=this.options.interpolationFormulaDegree)throw Error("bad interpolationFormulaDegree");if(this.options.denseOutput){if(!Array.isArray(this.options.denseComponents)||0==this.options.denseComponents.length)for(this.options.denseComponents=[],c=0;c<this.n;++c)this.options.denseComponents.push(c);for(var h of this.options.denseComponents)if(0>h||h>=this.n)throw Error("illegal dense component index "+h);}if(1E-35>=this.options.uRound||1<this.options.uRound)throw Error("suspicious value of uRound");
h=2*e*e+e;this.aTol=this.expandToArray(this.options.absoluteTolerance);this.rTol=this.expandToArray(this.options.relativeTolerance);this.ySafe=Array(e);this.fSafe=Array(h);for(h=0;h<this.fSafe.length;++h)this.fSafe[h]=Array(this.options.denseComponents.length);for(h=0;h<this.ySafe.length;++h)this.ySafe[h]=Array(this.options.denseComponents.length);this.hh=Array(e);this.t=Array(e);for(h=0;h<this.t.length;++h)this.t[h]=Array(this.n);this.nj=u.stepSizeSequence(this.options.stepSizeSequence,e);this.a=
Array(e);this.a[0]=1+this.nj[0];for(h=1;h<e;++h)this.a[h]=this.a[h-1]+this.nj[h];this.w=Array(e);this.w[0]=0;this.scal=Array(this.n);this.fx=Array(this.n);this.dy=Array(this.n);this.dz=Array(this.n);this.yh1=Array(this.n);this.yh2=Array(this.n);this.iPoint=Array(e+1);this.errfac=Array(2*e);this.dens=Array(2*this.options.maxExtrapolationColumns+5+this.options.denseComponents.length);this.ap=Array(31);this.t0i=Array(this.n);this.posNeg=1}grid(m,e){if(!this.options.denseOutput)throw Error("Must set .denseOutput to true when using grid");
const c=this.options.denseComponents;let h;return(l,n,p,v)=>{for(h=null!==h&&void 0!==h?h:l;h<=n;){l=Array(c.length);for(p=0;p<c.length;++p)l[p]=v(c[p],h);if(!1===e(h,l))return!1;h+=m}}}expandToArray(m){return Array.isArray(m)?m:Array(this.n).fill(m,0)}copy(m,e){if(m.length!==e.length)throw Error("copy used on arrays of differing size");for(let c=0;c<m.length;++c)m[c]=e[c]}noDenseOutput(m,e){throw Error("denseOutput not enabled for this problem");}static stepSizeSequence(m,e){const c=Array(e);switch(m){case 1:for(m=
0;m<e;++m)c[m]=2*(m+1);break;case 2:c[0]=2;for(m=1;m<e;++m)c[m]=4*m;break;case 3:c[0]=2;c[1]=4;c[2]=6;for(m=3;m<e;++m)c[m]=2*c[m-2];break;case 4:for(m=0;m<e;++m)c[m]=4*m+2;break;case 5:for(m=0;m<e;++m)c[m]=4*(m+1);break;default:throw Error("invalid stepSizeSequence selected");}return c}interp(m,e){const c=this.options.denseComponents.length;for(let w=0;w<c;++w){var h=m[w];const z=m[2*c+w];var l=m[c+w];const x=m[3*c+w];var n=z-h,p=-x+n,v=l-n;m[c+w]=n;m[2*c+w]=p;m[3*c+w]=v;if(!(0>e)){h=.5*(h+z)+.125*
(p+v);n+=.25*(p-v);l=-(l-x);p=6*(v-p);if(1<=e&&(this.ap[1]=16*(m[5*c+w]-n),3<=e&&(this.ap[3]=16*(m[7*c+w]-p+3*this.ap[1]),5<=e)))for(p=5;p<=e;p+=2)v=p*(p-1)/2,this.ap[p]=16*(m[(p+4)*c+w]+v*this.ap[p-2]-v*(p-2)*(p-3)*2*this.ap[p-4]);this.ap[0]=16*(m[4*c+w]-h);if(2<=e&&(this.ap[2]=16*(m[6*c+w]-l+this.ap[0]),4<=e))for(h=4;h<=e;h+=2)this.ap[h]=16*(m[c*(h+4)+w]+h*(h-1)/2*this.ap[h-2]-this.ap[h-4]*h*(h-1)*(h-2)*(h-3));for(h=0;h<=e;++h)m[c*(h+4)+w]=this.ap[h]}}}contex(m,e,c){const h=this.dens.slice();return(l,
n)=>{const p=this.options.denseComponents.length;let v=this.options.denseComponents.indexOf(l);if(0>v)throw Error("no dense output available for component "+l);l=(n-m)/e;n=1-l;const w=h[v]+l*(h[p+v]+n*(h[2*p+v]*l+h[3*p+v]*n));if(0>c)return w;const z=l-.5;let x=h[p*(c+4)+v];for(let E=c;1<=E;--E)x=h[p*(E+3)+v]+x*z/E;return w+Math.pow(l*n,2)*x}}midEx(m,e,c,h,l){var n=e/this.nj[m];for(var p=0;p<this.n;++p)this.yh1[p]=h[p],this.yh2[p]=h[p]+n*l[p];p=this.nj[m]-1;const v=this.nj[m]/2|0;for(let x=1;x<=p;++x){if(this.options.denseOutput&&
x===v)for(var w=0;w<this.options.denseComponents.length;++w)this.ySafe[m][w]=this.yh2[this.options.denseComponents[w]];this.f(c+n*x,this.yh2,this.dy);if(this.options.denseOutput&&Math.abs(x-v)<=2*m+1)for(++this.iPt,w=0;w<this.options.denseComponents.length;++w)this.fSafe[this.iPt-1][w]=this.dy[this.options.denseComponents[w]];for(w=0;w<this.n;++w){var z=this.yh1[w];this.yh1[w]=this.yh2[w];this.yh2[w]=z+2*n*this.dy[w]}if(x<=this.options.stabilityCheckCount&&m<this.options.stabilityCheckTableLines){w=
0;for(z=0;z<this.n;++z)w+=Math.pow(l[z]/this.scal[z],2);z=0;for(let E=0;E<this.n;++E)z+=Math.pow((this.dy[E]-l[E])/this.scal[E],2);if(4<z/Math.max(this.options.uRound,w))return++this.nEval,!1}}this.f(c+e,this.yh2,this.dy);if(this.options.denseOutput&&v<=2*m+1)for(++this.iPt,c=0;c<this.options.denseComponents.length;++c)this.fSafe[this.iPt-1][c]=this.dy[this.options.denseComponents[c]];for(c=0;c<this.n;++c)this.t[m][c]=(this.yh1[c]+this.yh2[c]+n*this.dy[c])/2;this.nEval+=this.nj[m];if(0===m)return!0;
for(c=m;0<c;--c)for(n=Math.pow(this.nj[m]/this.nj[c-1],2)-1,l=0;l<this.n;++l)this.t[c-1][l]=this.t[c][l]+(this.t[c][l]-this.t[c-1][l])/n;this.err=0;for(n=0;n<this.n;++n)this.scal[n]=this.aTol[n]+this.rTol[n]*Math.max(Math.abs(h[n]),Math.abs(this.t[0][n])),this.err+=Math.pow((this.t[0][n]-this.t[1][n])/this.scal[n],2);this.err=Math.sqrt(this.err/this.n);if(1<=this.err*this.options.uRound||1<m&&this.err>=this.errOld)return!1;this.errOld=Math.max(4*this.err,1);h=1/(2*m+1);n=Math.pow(this.options.stepSizeFac1,
h);n=Math.min(this.options.stepSizeFac2/n,Math.max(n,Math.pow(this.err/this.options.stepSafetyFactor1,h)/this.options.stepSafetyFactor2));this.hh[m]=Math.min(1/n*Math.abs(e),this.hMax);this.w[m]=this.a[m]/this.hh[m];return!0}acceptStep(m,e,c,h,l){const n=2*m-this.options.interpolationFormulaDegree+1;var p=void 0;if(this.options.denseOutput){const H=this.options.denseComponents.length;for(var v=0;v<H;++v)this.dens[v]=h[this.options.denseComponents[v]];for(v=0;v<H;++v)this.dens[H+v]=e*l[this.options.denseComponents[v]];
v=2*H;for(var w=0;w<H;++w)this.dens[v+w]=this.t[0][this.options.denseComponents[w]];for(v=2;v<=m;++v)for(w=v;2<=w;--w){var z=Math.pow(this.nj[v-1]/this.nj[w-2],2)-1;for(var x=0;x<H;++x)this.ySafe[w-2][x]=this.ySafe[w-1][x]+(this.ySafe[w-1][x]-this.ySafe[w-2][x])/z}z=4*H;for(v=0;v<H;++v)this.dens[z+v]=this.ySafe[0][v];for(v=0;v<this.n;++v)this.t0i[v]=this.t[0][v];this.f(c+e,this.t0i,this.fx);z=3*H;for(v=0;v<H;++v)this.dens[z+v]=this.fx[this.options.denseComponents[v]]*e;for(v=1;v<=n;++v){w=(v+1)/2|
0;for(z=w;z<=m;++z){x=Math.pow(this.nj[z-1]/2,v-1);this.iPt=this.iPoint[z]-2*z+v;for(var E=0;E<H;++E)this.ySafe[z-1][E]=this.fSafe[this.iPt-1][E]*x}for(z=w+1;z<=m;++z)for(x=z;x>=w+1;--x){E=Math.pow(this.nj[z-1]/this.nj[x-2],2)-1;for(let I=0;I<H;++I)this.ySafe[x-2][I]=this.ySafe[x-1][I]+(this.ySafe[x-1][I]-this.ySafe[x-2][I])/E}z=(v+4)*H;for(x=0;x<H;++x)this.dens[z+x]=this.ySafe[w-1][x]*e;if(v!==n){for(w=(v+2)/2|0;w<=m;++w){x=this.iPoint[w];z=this.iPoint[w-1]+v+1;for(1===v&&4===this.options.stepSizeSequence&&
(z+=2);x>=z;x-=2)for(E=0;E<H;++E)this.fSafe[x-1][E]-=this.fSafe[x-3][E];if(1===v&&4===this.options.stepSizeSequence)for(x=z-2,z=0;z<H;++z)this.fSafe[x-1][z]-=l[this.options.denseComponents[z]]}for(w=(v+2)/2|0;w<=m;++w)for(x=this.iPoint[w]-1,z=this.iPoint[w-1]+v+2;x>=z;x-=2)for(E=0;E<H;++E)this.fSafe[x-1][E]-=this.fSafe[x-3][E]}}this.interp(this.dens,n);if(this.options.denseOutputErrorEstimator&&1<=n){m=0;for(p=0;p<H;++p)m+=Math.pow(this.dens[(n+4)*H+p]/this.scal[this.options.denseComponents[p]],2);
m=Math.sqrt(m/H)*this.errfac[n-1];p=e/Math.max(Math.pow(m,1/(n+4)),.01);if(10<m)return++this.nReject,{accept:!1,hoptde:p}}this.copy(l,this.fx)}this.copy(h,this.t[0]);++this.nAccept;return{accept:!0,hoptde:p,densef:this.options.denseOutput?this.contex(c,e,n):this.noDenseOutput}}newOrderAndStepSize(m,e,c,h){let l;2===e?(l=Math.min(3,this.options.maxExtrapolationColumns-1),m&&(l=2)):e<=c?(l=e,this.w[e-2]<this.w[e-1]*this.options.stepSizeFac3&&(l=e-1),this.w[e-1]<this.w[e-2]*this.options.stepSizeFac4&&
(l=Math.min(e+1,this.options.maxExtrapolationColumns-1))):(l=e-1,3<e&&this.w[e-3]<this.w[e-2]*this.options.stepSizeFac3&&(l=e-2),this.w[e-1]<this.w[l-1]*this.options.stepSizeFac4&&(l=Math.min(e,this.options.maxExtrapolationColumns-1)));if(m)return{k:Math.min(l,e),h:this.posNeg*Math.min(Math.abs(h),Math.abs(this.hh[c-1]))};m={h:0,k:0};m.h=l<=e?this.hh[l-1]:e<c&&this.w[e-1]<this.w[e-2]*this.options.stepSizeFac4?this.hh[e-1]*this.a[l]/this.a[e-1]:this.hh[e-1]*this.a[l-1]/this.a[e-1];m.h=this.posNeg*
Math.abs(m.h);m.k=l;return m}solve(m,e,c,h){if(this.options.denseOutput&&!h)throw Error("solve: denseOutput requires a solution observer function");let l=e;for(let n of this.solutionSegments(m,e,c))h&&h(n.x0,n.x1,n.y,n.f),l=n.y;return{y:l,nStep:this.nStep,xEnd:c,nAccept:this.nAccept,nReject:this.nReject,nEval:this.nEval}}integrate(m,e){if(!this.options.denseOutput)throw Error("integrate interface requires denseOutput");const c=this.options.denseComponents,h=this.solutionSegments(m,e);let l=h.next(),
n=!1;return(p,v)=>{if(void 0===p)return h.next(!1),n=!0,[];if(p<l.value.x0)throw Error("cannot use interpolation function in backwards direction");if(n)throw Error("cannot use interpolation function after closing integrator");for(;!l.done&&p>l.value.x1;)l=h.next();if(void 0!==v){for(var w=0;w<c.length;++w)v[w]=l.value.f(c[w],p);return v}v=Array(c.length);for(w=0;w<c.length;++w)v[w]=l.value.f(c[w],p);return v}}*solutionSegments(m,e,c){var h,l;if(!Array.isArray(e)||e.length!=this.n)throw Error("y0 must be an array sized to the dimension of the problem");
e=e.slice();this.hMax=(this.hMax=this.options.maxStepSize)?this.options.maxStepSize:c?Math.abs(c-m):1;this.nStep=this.nAccept=this.nReject=0;this.posNeg=c?0<=c-m?1:-1:1;for(var n=0;n<this.n;++n)this.scal[n]=this.aTol[n]+this.rTol[n]+Math.abs(e[n]);n=Math.max(2,Math.min(this.options.maxExtrapolationColumns-1,Math.floor(.6*-Math.log10(this.rTol[0]+1E-40)+1.5)));let p=Math.max(Math.abs(this.options.initialStepSize),1E-4);p=this.posNeg*Math.min(p,this.hMax,c?Math.abs(c-m)/2:Infinity);let v=m;this.iPt=
0;if(this.options.denseOutput){this.iPoint[0]=0;for(var w=0;w<this.options.maxExtrapolationColumns;++w){var z=4*(w+1)-2;this.nj[w]>z&&++z;this.iPoint[w+1]=this.iPoint[w]+z}for(w=0;w<2*this.options.maxExtrapolationColumns;++w){z=.5*Math.sqrt((w+1)/(w+5));var x=Math.pow(1/(w+5),2);for(var E=1;E<=w+1;++E)x*=z/E;this.errfac[w]=x}}this.err=0;this.errOld=1E10;w=this.posNeg*this.hMax;x=z=!1;E=0;var H=A.Start;a:for(;;)switch(this.options.debug&&console.log(`#${this.nStep} ${A[H]} [${v},${m}] h=${p} k=${n}`),
H){case A.Start:if(void 0!==c){if(.1*Math.abs(c-m)<=Math.abs(m)*this.options.uRound)break a;p=this.posNeg*Math.min(Math.abs(p),Math.abs(c-m),this.hMax,Math.abs(w));0<(m+1.01*p-c)*this.posNeg&&(p=c-m,x=!0)}else p=this.posNeg*Math.min(Math.abs(p),this.hMax,Math.abs(w));0!==this.nStep&&this.options.denseOutput||(this.f(m,e,this.dz),++this.nEval);if(0===this.nStep||x){this.iPt=0;++this.nStep;for(var I=1;I<=n;++I){E=I;if(!this.midEx(I-1,p,m,e,this.dz)){p*=this.options.stepSizeReductionFactor;z=!0;continue a}if(1<
I&&1>=this.err){H=A.Accept;continue a}}H=A.HopeForConvergence;continue}H=A.BasicIntegrationStep;continue;case A.BasicIntegrationStep:this.iPt=0;if(++this.nStep>=this.options.maxSteps)throw Error("maximum allowed steps exceeded: "+this.nStep);E=n-1;for(H=0;H<E;++H)if(!this.midEx(H,p,m,e,this.dz)){p*=this.options.stepSizeReductionFactor;z=!0;H=A.Start;continue a}H=2===n||z?A.ConvergenceStep:1>=this.err?A.Accept:this.err>Math.pow(this.nj[n]*this.nj[n-1]/4,2)?A.Reject:A.ConvergenceStep;continue;case A.ConvergenceStep:if(!this.midEx(n-
1,p,m,e,this.dz)){p*=this.options.stepSizeReductionFactor;z=!0;H=A.Start;continue}E=n;if(1>=this.err){H=A.Accept;continue}H=A.HopeForConvergence;continue;case A.HopeForConvergence:if(this.err>Math.pow(this.nj[n]/2,2)){H=A.Reject;continue}E=n+1;this.midEx(E-1,p,m,e,this.dz)?H=1<this.err?A.Reject:A.Accept:(p*=this.options.stepSizeReductionFactor,z=!0,H=A.Start);continue;case A.Accept:I=this.acceptStep(E,p,m,e,this.dz);H=A.Start;w=null!==(h=I.hoptde)&&void 0!==h?h:w;if(!I.accept){p=w;z=!0;continue}v=
m;m+=p;if(!1===(yield{x0:v,x1:m,y:e.slice(),f:null!==(l=I.densef)&&void 0!==l?l:this.noDenseOutput}))return;({k:n,h:p}=this.newOrderAndStepSize(z,E,n,p));z=!1;continue;case A.Reject:n=Math.min(n,E,this.options.maxExtrapolationColumns-1),2<n&&this.w[n-1]<this.w[n]*this.options.stepSizeFac3&&--n,++this.nReject,p=this.posNeg*this.hh[n-1],z=!0,H=A.BasicIntegrationStep}}}g.Solver=u;u.defaults={uRound:2.3E-16,maxSteps:1E4,initialStepSize:1E-4,maxStepSize:0,maxExtrapolationColumns:9,stepSizeSequence:0,stabilityCheckCount:1,
stabilityCheckTableLines:2,denseOutput:!0,denseOutputErrorEstimator:!0,denseComponents:[],interpolationFormulaDegree:4,stepSizeReductionFactor:.5,stepSizeFac1:.02,stepSizeFac2:4,stepSizeFac3:.8,stepSizeFac4:.9,stepSafetyFactor1:.65,stepSafetyFactor2:.94,relativeTolerance:1E-5,absoluteTolerance:1E-5,debug:!1,rawFunction:!1}};
'use strict';var lD,MNa,NNa,mD,nD,oD,PNa,qD,RNa,rD,sD,tD,uD,SNa,TNa,UNa,vD,wD,xD,yD,zD,AD,VNa,WNa,XNa,YNa,BD,ZNa,$Na,aOa,GD,cOa,eOa,gOa,hOa,ND,PD,QD,SD,TD,iOa,mOa,VD,WD,nOa,XD,YD,$D,pOa,qOa,cE,gE,fE,wOa,zOa,AOa,iE,DOa,GOa,KOa,LOa,kE,MOa,NOa,SOa,UOa,VOa,oE,WOa,ZOa,rE,dPa,cPa,fPa,gPa,hPa,iPa,pPa,tPa,vPa,wPa,xPa,vE,xE,wE,APa,BPa,CPa,FPa,GPa,LPa,NPa,OPa,QPa,UPa,VPa,WPa,XPa,YPa,ZPa,$Pa,bQa,gQa,kQa,oQa,pQa,rQa,sQa,tQa,uQa,vQa,wQa,xQa,AQa,SE,BQa,CQa,DQa,TE,FQa,GQa,HQa,JQa,KQa,LQa,MQa,WQa,aRa,dRa,jRa,kRa,
mRa,oRa,pRa,tRa,uRa,vRa,wRa,xRa,yRa,ERa,IRa,KRa,LRa,hE,PRa,QRa,URa,WRa,pF,VRa,aSa,XRa,dSa,fSa,iSa,mF,kSa,mSa,JE,IE,nSa,YRa,pSa,uF,qSa,rSa,wF,yF,sSa,tSa,uSa,vSa,wSa,ySa,AF,zSa,ASa,BSa,BF,CSa,CF,DF,EF,FF,GF,IF,ESa,FSa,JF,HSa,KF,ISa,NF,JSa,UF,WF,LSa,YF,MSa,NSa,OSa,ZF,PSa,QSa,$F,aG,RSa,SSa,TSa,USa,eG,fG,gG,VSa,iG,WSa,ZSa,$Sa,aTa,dTa,fTa,hTa,iTa,jTa,kTa,mTa,nTa,oTa,pTa,qTa,rTa,sTa,xG,tTa,uTa,vTa,wTa,xTa,yTa,DG,EG,zTa,ATa,BTa,CTa,DTa,ETa,FTa,OTa,PTa,QTa,JG,RTa,STa,TTa,UTa,VTa,YTa,ZTa,KG,$Ta,aUa,bUa,cUa,
kUa,lUa,LG,MG,NG,OG,tUa,vUa,uUa,zUa,yUa,DUa,EUa,GUa,FUa,SG,KUa,TG,JUa,IUa,UG,VG,NUa,OUa,QUa,WG,RUa,TUa,VUa,WUa,XUa,cVa,dVa,iVa,jVa,oVa,bH,cH,PVa,fH,QVa,iH,RVa,SVa,kH,lH,TVa,WVa,XVa,YVa,ZVa,BH,$Va,aWa,cWa,dWa,eWa,fWa,FH,hWa,iWa,jWa,lWa,GH,nWa,HH,IH,JH,KH,oWa,LH,MH,qWa,NH,OH,QH,rWa,sWa,tWa,uWa,UH,WH,XH,YH,$H,aI,bI,wWa,yWa,dI,eI,zWa,fI,AWa,BWa,gI,CWa,iI,kI,jI,DWa,EWa,FWa,mI,GWa,HWa,IWa,oI,pI,qI,rI,JWa,KWa,LWa,MWa,NWa,vI,wI,OWa,QWa,PWa,SWa,xI,yI,TWa,UWa,VWa,WWa,XWa,ZWa,$Wa,aXa,bXa,cXa,dXa,eXa,fXa,BI,
CI,gXa,hXa,iXa,jXa,EI,kXa,lXa,mXa,nXa,oXa,HI,pXa,qXa,rXa,II,sXa,tXa,uXa,vXa,wXa,JI,xXa,KI,yXa,MI,zXa,OI,AXa,PI,QI,RI,SI,BXa,TI,CXa,UI,VI,DXa,EXa,WI,XI,FXa,GXa,HXa,IXa,JXa,YI,KXa,$I,aJ,bJ,NXa,cJ,dJ,eJ,OXa,fJ,QXa,RXa,UXa,VXa,WXa,XXa,YXa,ZXa,$Xa,bYa,cYa,dYa,iJ,jJ,eYa,fYa,mJ,gYa,hYa,iYa,jYa,kYa,lYa,nYa,nJ,pJ,rJ,oYa,pYa,qYa,sJ,tJ,uJ,rYa,sYa,tYa,uYa,vYa,wYa,xYa,yYa,vJ,zYa,CYa,IYa,LYa,QYa,WYa,XYa,gZa,hZa,iZa,kZa,lZa,BK,nZa,DK,EK,FK,GK,HK,IK,JK,KK,oZa,pZa,qZa,rZa,sZa,tZa,uZa,vZa,wZa,xZa,PK,yZa,zZa,AZa,RK,
SK,TK,VK,WK,BZa,CZa,XK,YK,DZa,EZa,FZa,$K,KZa,LZa,aL,bL,MZa,cL,NZa,dL,eL,gL,hL,iL,OZa,PZa,kL,lL,RZa,SZa,nL,pL,qL,TZa,UZa,rL,VZa,uL,vL,WZa,XZa,YZa,xL,yL,zL,AL,CL,ZZa,$Za,EL,a_a,b_a,c_a,d_a,FL,GL,HL,IL,e_a,f_a,g_a,h_a,JL,KL,i_a,j_a,k_a,m_a,l_a,LL,o_a,ML,NL,OL,PL,QL,RL,SL,TL,p_a,q_a,r_a,s_a,t_a,u_a,v_a,WL,w_a,x_a,XL,y_a,YL,aM,C_a,D_a,bM,cM,E_a,H_a,dM,K_a,M_a,N_a,O_a,P_a,Q_a,U_a,V_a,W_a,X_a,Z_a,mM,$_a,b0a,c0a,d0a,e0a,f0a,g0a,h0a,i0a,j0a,l0a,n0a,o0a,p0a,q0a,r0a,s0a,t0a,u0a,v0a,uM,vM,wM,w0a,x0a,y0a,z0a,
xM,A0a,zM,B0a,C0a,D0a,E0a,F0a,G0a,H0a,I0a,J0a,K0a,L0a,M0a,N0a,O0a,AM,P0a,BM,CM,Q0a,R0a,EM,S0a,U0a,W0a,JM,KM,LM,MM,n1a,SM,o1a,UM,WM,q1a,XM,r1a,YM,s1a,t1a,ZM,u1a,v1a,w1a,x1a,y1a,z1a,cN,A1a,C1a,B1a,iN,hN,mN,lN,nN,D1a,oN,pN,qN,rN,sN,E1a,tN,F1a,G1a,uN,H1a,vN,I1a,J1a,K1a,L1a,M1a,wN,yN,N1a,O1a,P1a,Q1a,AN,BN,R1a,S1a,T1a,U1a,CN,V1a,W1a,DN,X1a,Y1a,FN,GN,IN,Z1a,KN,$1a,a2a,b2a,c2a,d2a,e2a,f2a,g2a,MN,h2a,i2a,j2a,ON,RN,o2a,p2a,UN,q2a,r2a,VN,s2a,XN,t2a,u2a,v2a,w2a,aO,ZN,x2a,bO,cO,y2a,dO,eO,z2a,B2a,C2a,E2a,F2a,I2a,
J2a,K2a,L2a,M2a,N2a,jO,O2a,kO,P2a,lO,Q2a,R2a,S2a,T2a,U2a,V2a,W2a,X2a,pO,Z2a,$2a,c3a,rO,tO,e3a,h3a,uO,i3a,vO,n3a,xO,yO,o3a,p3a,zO,AO,q3a,r3a,s3a,BO,CO,wO,t3a,EO,FO,GO,u3a,v3a,w3a,x3a,JO,z3a,A3a,B3a,C3a,KO,F3a,H3a,J3a,L3a,M3a,N3a,O3a,P3a,Q3a,WO,YO,U3a,V3a,W3a,T3a,S3a,Y3a,Z3a,aP,$3a,a4a,c4a,d4a,e4a,f4a,g4a,j4a,o4a,p4a,cP,eP,r4a,s4a,fP,hP,u4a,v4a,w4a,x4a,kP,z4a,A4a,mP,C4a,E4a,G4a,nP,K4a,L4a,N4a,O4a,oP,pP,P4a,rP,Q4a,R4a,S4a,T4a,U4a,uP,vP,wP,xP,W4a,X4a,Y4a,Z4a,$4a,a5a,b5a,c5a,d5a,CP,f5a,g5a,i5a,DP,l5a,
n5a,o5a,q5a,s5a,GP,u5a,HP,IP,JP,x5a,y5a,z5a,A5a,B5a,C5a,D5a,F5a,G5a,H5a,I5a,J5a,K5a,L5a,M5a,N5a,O5a,P5a,Q5a,R5a,PP,S5a,T5a,U5a,V5a,W5a,X5a,Y5a,QP,Z5a,RP,SP,b6a,c6a,d6a,e6a,f6a,h6a,i6a,j6a,k6a,l6a,m6a,n6a,TP,o6a,p6a,q6a,r6a,s6a,t6a,u6a,v6a,w6a,x6a,y6a,z6a,A6a,B6a,F6a,G6a,ZP,$P,H6a,cQ,L6a,dQ,eQ,M6a,fQ,N6a,a7a,b7a,iQ,jQ,c7a,d7a,kQ,lQ,g7a,h7a,i7a,j7a,p7a,q7a,t7a,u7a,v7a,tQ,uQ,z7a,A7a,B7a,C7a,E7a,G7a,H7a,I7a,J7a,L7a,M7a,N7a,O7a,P7a,S7a,U7a,W7a,X7a,Z7a,$7a,b8a,c8a,d8a,e8a,g8a,i8a,j8a,k8a,l8a,m8a,n8a,o8a,
q8a,r8a,GQ,t8a,u8a,v8a,w8a,x8a,y8a,z8a,B8a,C8a,D8a,E8a,F8a,G8a,KQ,H8a,I8a,J8a,K8a,O8a,P8a,U8a,MQ,OQ,PQ,V8a,W8a,Y8a,Z8a,$8a,a9a,b9a,c9a,d9a,e9a,f9a,g9a,i9a,j9a,VQ,k9a,l9a,m9a,n9a,o9a,p9a,q9a,r9a,s9a,t9a,u9a,v9a,w9a,YQ,x9a,ZQ,y9a,z9a,A9a,B9a,D9a,E9a,G9a,I9a,J9a,K9a,L9a,M9a,N9a,fR,O9a,P9a,Q9a,R9a,S9a,T9a,U9a,V9a,W9a,Y9a,Z9a,$9a,hR,iR,a$a,b$a,c$a,d$a,jR,kR,e$a,f$a,lR,g$a,nR,h$a,pR,i$a,j$a,k$a,qR,l$a,m$a,n$a,rR,sR,o$a,uR,p$a,q$a,r$a,s$a,t$a,u$a,v$a,w$a,AR,y$a,z$a,A$a,B$a,C$a,D$a,E$a,F$a,CR,G$a,H$a,I$a,
J$a,K$a,M$a,P$a,S$a,W$a,X$a,Y$a,aab,bab,eab,fab,NR,gab,hab,iab,jab,kab,lab,PR,QR,RR,mab,nab,oab,pab,qab,SR,sab,tab,xab,yab,zab,Aab,Bab,Cab,Dab,Eab,Fab,Gab,Hab,Iab,Jab,Kab,VR,Lab,Mab,Nab,Oab,Pab,Qab,Rab,Sab,Tab,ZK,Uab,jK,o7a,Vab,Wab,Xab,Yab,Zab,eRa,$ab,abb,bbb,cbb,jSa,dbb,ebb,fbb,gbb,hbb,ibb,jbb,kbb,lbb,DPa,mbb,nbb,obb,pbb,qbb,rbb,sbb,tbb,ubb,vbb,t5a,wbb,xbb,ybb,zbb,Abb,Bbb,Cbb,Dbb,WR,Ebb,Fbb,Gbb,h9a,Hbb,Ibb,Jbb,YR,Kbb,Lbb,Mbb,Nbb,Obb,Pbb,Qbb,Rbb,Sbb,Tbb,Ubb,Vbb,Wbb,Xbb,ZR,Ybb,Zbb,$bb,acb,bcb,ccb,
dcb,ecb,fcb,gcb,hcb,icb,jcb,$R,kcb,lcb,mcb,ncb,ocb,pcb,qcb,rcb,aS,scb,tcb,ucb,vcb,wcb,xcb,ycb,zcb,Acb,bS,gJ,Bcb,Ccb,Dcb,Ecb,Fcb,Gcb,Hcb,xUa,Icb,Jcb,Kcb,Lcb,Mcb,Ncb,Ocb,cS,Pcb,Qcb,Rcb,Scb,Tcb,Ucb,Vcb,Wcb,Xcb,Ycb,H4a,Zcb,$cb,adb,BRa,bdb,cdb,ddb,edb,fdb,gdb,hdb,dS,idb,jdb,kdb,ldb,mdb,ndb,DD,odb,pdb,qdb,rdb,eS,sdb,tdb,udb,vdb,wdb,fS,xdb,ydb,zdb,Adb,qRa,Bdb,Cdb,xOa,Ddb,Edb,Fdb,gS,Gdb,Hdb,Idb,Jdb,RRa,Kdb,Ldb,Mdb,Ndb,TQa,Odb,Pdb,Qdb,Rdb,Sdb,Tdb,Udb,Vdb,Wdb,Xdb,Ydb,Zdb,hS,iS,$db,aeb,beb,ceb,deb,eeb,feb,geb,
heb,ieb,jeb,jS,keb,leb,neb,oeb,peb,kS,qeb,reb,seb,teb,ueb,lS,veb,mS,web,qPa,xeb,yeb,nS,zeb,Aeb,Beb,Ceb,Deb,Eeb,Feb,Geb,Heb,Ieb,Jeb,YSa,Keb,Leb,Meb,Neb,Oeb,Peb,Qeb,Reb,tVa,Seb,oS,Teb,zVa,pS,Ueb,Veb,Web,Xeb,qS,Yeb,Zeb,$eb,HF,WN,afb,bfb,zPa,cfb,dfb,HOa,rS,efb,ffb,gfb,vK,hfb,ifb,wK,xK,sS,tS,jfb,bZa,kfb,lfb,mfb,nfb,ofb,pfb,qfb,rfb,oPa,tE,sfb,tfb,ufb,vfb,wfb,EPa,xfb,yfb,zfb,Afb,Bfb,Cfb,vS,Dfb,Efb,Ffb,wS,xS,Gfb,Hfb,jOa,Ifb,Jfb,Kfb,Lfb,Mfb,QS,Nfb,Ofb,Pfb,Qfb,pUa,RS,SS,zK,HTa,AK,Rfb,Sfb,Tfb,Ufb,Vfb,Wfb,Xfb,
Yfb,Zfb,$fb,agb,bgb,cgb,CD,TS,dgb,egb,fgb,ggb,hgb,igb,jgb,PG,kgb,l2a,lgb,dK,eK,US,gK,hK,mgb,ngb,ogb,pgb,yOa,qgb,rgb,sVa,sgb,tgb,ugb,vgb,wgb,xgb,ygb,VS,WS,zgb,Agb,xVa,FOa,Bgb,Cgb,Dgb,Egb,Fgb,Ggb,XS,Hgb,Igb,Jgb,M8a,Kgb,Q7a,Lgb,Mgb,Ngb,Ogb,Pgb,Qgb,Z$a,rPa,Rgb,Sgb,Tgb,YS,Ugb,Vgb,Wgb,Xgb,Ygb,cQa,Zgb,$gb,ahb,ZS,bhb,chb,dhb,ehb,fhb,ghb,uOa,hhb,ZH,mK,ihb,jhb,khb,$S,lhb,mhb,nhb,aT,ohb,phb,qhb,rhb,shb,thb,uhb,vhb,whb,bE,xhb,yhb,g6a,zhb,Ahb,Bhb,Chb,ROa,Dhb,Ehb,Fhb,Ghb,Hhb,Ihb,Jhb,iRa,Khb,Lhb,Mhb,Nhb,Ohb,Phb,
Qhb,Rhb,Shb,Thb,bT,Uhb,Vhb,Whb,cT,Xhb,Yhb,Zhb,$hb,aib,bib,cib,dib,eib,fib,dT,gib,hib,rUa,iib,jib,kib,lib,dZa,mib,nib,oib,pib,qib,rib,sib,tib,uib,vib,wib,kWa,xib,yib,zib,Aib,Bib,Cib,Dib,VM,Eib,Fib,Gib,Hib,Iib,Jib,Kib,FP,Lib,Mib,Nib,Oib,Pib,Qib,Rib,Sib,Tib,Uib,Vib,Wib,sOa,Xib,Yib,JVa,Zib,$ib,aN,QNa,ajb,bjb,cjb,djb,ejb,fT,fjb,gjb,hjb,ijb,gT,jjb,hT,kjb,ljb,EYa,mjb,njb,ojb,pjb,qjb,rjb,sjb,tjb,ujb,jT,uPa,BUa,vjb,wjb,xjb,yjb,zjb,Ajb,kT,YQa,Bjb,Cjb,Djb,lT,Ejb,Fjb,Gjb,Hjb,Ijb,Jjb,Kjb,mT,Ljb,WE,Mjb,Njb,Ojb,
Pjb,k5a,Qjb,fZa,Rjb,Sjb,Tjb,Ujb,ZL,yVa,Vjb,Wjb,PQa,Xjb,Yjb,Zjb,$jb,akb,bkb,nT,ckb,dkb,ekb,fkb,gkb,hkb,D6a,ikb,jkb,kkb,lkb,mkb,nkb,okb,pkb,ZYa,$Ya,oT,k7a,qkb,R7a,rkb,skb,tkb,ukb,vkb,TXa,wkb,xkb,ykb,zkb,pT,Akb,Bkb,Ckb,Dkb,Ekb,Fkb,Gkb,Hkb,Ikb,x$a,Jkb,Kkb,Lkb,XOa,Mkb,Nkb,Okb,Pkb,Qkb,qT,Rkb,Skb,rT,Tkb,Ukb,Vkb,Wkb,Xkb,b4a,Ykb,Zkb,$kb,sT,alb,blb,clb,dlb,elb,PN,mWa,flb,glb,hlb,tT,ilb,jlb,klb,llb,mlb,nlb,olb,plb,qlb,rlb,slb,tlb,ulb,vlb,wlb,xlb,ylb,T6a,k3a,zlb,yPa,Alb,Blb,Clb,Dlb,Elb,Flb,Glb,uT,Hlb,Ilb,Jlb,
mPa,Klb,Llb,Mlb,Nlb,Olb,Plb,Qlb,Rlb,Slb,Tlb,Ulb,Vlb,Wlb,Xlb,Ylb,lQa,Zlb,$lb,amb,bmb,cmb,KP,dmb,emb,fmb,gmb,hmb,imb,jmb,kmb,Y6a,lmb,mmb,nmb,omb,pmb,qmb,qQa,rmb,r5a,sPa,smb,tmb,umb,vmb,wmb,QOa,xmb,ymb,zmb,vT,Amb,Bmb,Cmb,Dmb,oH,Emb,Fmb,Gmb,Hmb,Imb,Jmb,Kmb,wT,Lmb,Mmb,Nmb,Omb,Pmb,Qmb,xT,Rmb,Smb,Tmb,Umb,Vmb,Wmb,Xmb,Ymb,Zmb,$mb,anb,bnb,cnb,dnb,enb,fnb,gnb,hnb,inb,jnb,knb,lnb,yT,YJ,mnb,XJ,nnb,onb,WJ,VJ,RJ,pnb,qnb,zT,rnb,AT,BT,snb,CT,QJ,PJ,tnb,SJ,unb,vnb,wnb,DT,xnb,ynb,znb,Anb,Bnb,Cnb,Dnb,Enb,pVa,ET,Fnb,Gnb,
Hnb,Inb,Jnb,Knb,Lnb,Mnb,Nnb,Onb,ZQa,Pnb,Qnb,JRa,Rnb,Snb,Tnb,Unb,FT,Vnb,gP,GT,Wnb,Xnb,Ynb,Znb,$nb,aob,bob,cob,dob,a6a,eob,fob,gob,hob,iob,lK,job,JD,kob,HT,lob,mob,nob,oob,pob,qob,rob,IT,cSa,rH,sob,tob,uob,vob,wob,xob,yob,D2a,zob,Aob,Bob,Cob,Dob,Eob,Fob,Gob,KT,Hob,Iob,Job,Kob,Lob,Mob,Nob,Oob,Pob,Qob,Rob,Sob,Tob,Uob,Vob,Wob,Xob,Yob,Zob,mYa,$ob,apb,LT,bpb,cpb,dpb,$Ra,MT,epb,fpb,gpb,hpb,ipb,NT,jpb,kpb,lpb,mpb,npb,opb,ppb,DRa,qpb,d3a,OT,PT,rpb,spb,tpb,upb,vpb,wpb,xpb,J6a,ypb,zpb,Apb,Bpb,QT,Cpb,Dpb,Epb,
Fpb,Gpb,Hpb,Ipb,Jpb,Kpb,Lpb,Mpb,CE,X3a,Npb,Opb,Ppb,Qpb,Rpb,Spb,Tpb,RT,Upb,Vpb,Wpb,ST,Xpb,Ypb,Zpb,$pb,TT,aqb,bqb,cqb,UT,dqb,eqb,fqb,jF,gqb,hqb,iqb,jqb,kqb,rab,lqb,mqb,VT,nqb,oqb,pqb,qqb,rqb,WT,sqb,tqb,G_a,XT,uqb,vqb,CRa,qF,wqb,RQa,xqb,YT,yqb,zqb,Aqb,Bqb,VH,Cqb,Dqb,Eqb,Fqb,Gqb,Hqb,eF,$5a,Iqb,Jqb,Kqb,Lqb,Mqb,Nqb,ZT,Oqb,$E,Pqb,Qqb,KYa,JYa,Rqb,Sqb,Tqb,Uqb,BVa,rVa,HO,Vqb,Wqb,H9a,Xqb,Yqb,Zqb,$qb,arb,brb,crb,drb,erb,frb,grb,hrb,irb,jrb,krb,lrb,cI,mrb,nrb,orb,prb,qrb,rrb,srb,trb,urb,vrb,wrb,xrb,yrb,zrb,Arb,
Brb,Crb,Drb,Erb,Frb,Grb,Hrb,Irb,Jrb,Krb,Lrb,Mrb,Nrb,Orb,Prb,Qrb,Rrb,Srb,Urb,Vrb,Wrb,Xrb,Yrb,Zrb,$T,$rb,asb,bsb,csb,dsb,esb,fsb,aU,gsb,$6a,hsb,isb,jsb,ksb,CQ,lsb,msb,nsb,osb,psb,qsb,rsb,ssb,tsb,usb,vsb,bU,wsb,cU,dU,xsb,ysb,zsb,Asb,Bsb,Csb,Dsb,oK,Esb,Fsb,Gsb,Hsb,Isb,Jsb,Ksb,Lsb,KVa,E6a,v5a,Msb,Nsb,Osb,UQa,Psb,Qsb,Rsb,eU,Ssb,Tsb,Usb,Vsb,Wsb,Xsb,Ysb,Zsb,$sb,atb,btb,ctb,QG,dtb,etb,ftb,gtb,htb,itb,jtb,ktb,OK,ltb,mtb,ntb,otb,fU,ptb,qtb,rtb,stb,ttb,utb,vtb,wtb,xtb,ytb,ztb,Atb,gU,Btb,Ctb,Dtb,Etb,Ftb,Gtb,Htb,
Itb,R$a,Jtb,Ktb,Ltb,Mtb,sUa,Ntb,Otb,Ptb,Qtb,nQ,Rtb,Stb,Ttb,Utb,BE,Vtb,Wtb,Xtb,Ytb,Ztb,$tb,aub,bub,cub,dub,eub,fub,gub,KE,hub,iub,jub,kub,eVa,lub,mub,nub,iU,oub,pub,qub,rub,sub,tub,uub,vub,jU,wub,h8a,xub,yub,zub,Aub,K6a,Bub,kU,Cub,Dub,Eub,Fub,Gub,MXa,Hub,Iub,Jub,Kub,Lub,Mub,Nub,Oub,Pub,Qub,BYa,Rub,Sub,Tub,Uub,Vub,OJ,Wub,Xub,Yub,Zub,$ub,avb,bvb,cvb,dvb,evb,fvb,gvb,EVa,hvb,ivb,jvb,kvb,lvb,mvb,cZa,nvb,ovb,pvb,qvb,rvb,svb,AYa,tvb,lU,uvb,vvb,wvb,xvb,yvb,zvb,Avb,Bvb,Cvb,Dvb,Evb,Fvb,XO,N$a,Gvb,Hvb,Ivb,Jvb,
Kvb,Lvb,Mvb,Nvb,Ovb,Pvb,Qvb,Rvb,Svb,Tvb,Uvb,Vvb,Wvb,Xvb,Yvb,Zvb,$vb,awb,bwb,cwb,dwb,ewb,fwb,gwb,mU,hwb,iwb,NK,jwb,kwb,lwb,j5a,GZa,mwb,nwb,owb,pwb,qwb,rwb,nU,swb,twb,uwb,vwb,wwb,xwb,ywb,zwb,Awb,Bwb,JOa,Cwb,Dwb,Ewb,oU,Fwb,Gwb,pU,Hwb,Iwb,Jwb,Kwb,Lwb,Mwb,Nwb,Owb,Pwb,Qwb,Rwb,Swb,Twb,Uwb,qU,Vwb,Wwb,Xwb,Ywb,Zwb,$wb,axb,bxb,cxb,dxb,exb,k2a,fxb,gxb,hxb,ixb,jxb,kxb,lxb,mxb,nxb,oxb,pxb,PXa,rU,qxb,rxb,sxb,ZRa,txb,uxb,vxb,wxb,n2a,xxb,yxb,zxb,Axb,Bxb,Cxb,Dxb,Exb,Fxb,SPa,Gxb,$Qa,Hxb,Ixb,Jxb,Kxb,TR,Lxb,Mxb,Nxb,Oxb,
Pxb,Qxb,Rxb,Sxb,Txb,Uxb,Vxb,Wxb,Xxb,$Ua,Yxb,Zxb,$xb,ayb,byb,cyb,dyb,eyb,fyb,gyb,hyb,iyb,jyb,kyb,lyb,myb,tU,uU,nO,nyb,xU,oyb,yU,pyb,qyb,zU,ryb,syb,ZI,ZG,AU,BU,eH,ER,UR,CU,tyb,uyb,vyb,EU,GU,HU,wyb,xyb,JU,KU,yyb,QN,zyb,Ayb,Byb,gQ,Cyb,Dyb,Eyb,MRa,Fyb,P6a,Gyb,Hyb,Iyb,Jyb,LU,Kyb,Lyb,Myb,Nyb,Oyb,Pyb,Qyb,LXa,Ryb,Syb,NU,Tyb,Uyb,Vyb,Wyb,JJ,OU,Xyb,PU,Yyb,IJ,QU,RU,SU,CJ,Zyb,$yb,azb,bzb,czb,TU,dzb,ezb,fzb,EJ,LJ,gzb,hzb,izb,jzb,kzb,lzb,mzb,nzb,ozb,pzb,qzb,rzb,sH,pK,XQa,szb,tzb,uzb,vzb,wzb,xzb,wVa,yzb,zzb,Azb,Bzb,
VU,zQa,SQa,Czb,Dzb,Ezb,Fzb,Gzb,Hzb,Izb,Jzb,Kzb,Lzb,Mzb,Nzb,Ozb,Pzb,Qzb,Rzb,Szb,Tzb,Uzb,Vzb,WU,Wzb,Xzb,Yzb,n4a,Zzb,$zb,aAb,bAb,cAb,dAb,eAb,fAb,gAb,hAb,iAb,jAb,kAb,lAb,mAb,nAb,oAb,pAb,XU,UK,qAb,rAb,sAb,tAb,uAb,gVa,vAb,wAb,xAb,yAb,zAb,YU,AAb,BAb,CAb,LVa,DAb,tOa,EAb,FAb,GAb,$U,HAb,IAb,JAb,KAb,TOa,LAb,MAb,aV,bPa,NAb,OAb,PAb,QAb,RAb,SAb,TAb,UAb,VAb,WAb,JZa,XAb,YAb,ZAb,cab,$Ab,aBb,bBb,bV,cBb,dBb,eBb,fBb,gBb,hBb,iBb,dV,jBb,kBb,lBb,mBb,nBb,oBb,eV,gRa,pBb,qBb,rBb,sBb,fV,tBb,uBb,yQ,vBb,wBb,xBb,yBb,zBb,ABb,BBb,
CBb,DBb,EBb,FBb,kF,GBb,HBb,IBb,JBb,KBb,oUa,LBb,MBb,NBb,OBb,PBb,QBb,RBb,SBb,W6a,TBb,UBb,VBb,ARa,WBb,XBb,kVa,YBb,gV,ZBb,$Bb,aCb,bCb,cCb,yE,dCb,eCb,fCb,gCb,hCb,iCb,jCb,kCb,lCb,mCb,nCb,oCb,pCb,qCb,rCb,sCb,tCb,uCb,vCb,wCb,RWa,xCb,yCb,hV,iV,zCb,ACb,jV,BCb,CCb,DCb,ECb,FCb,kV,GCb,HCb,ICb,JCb,KCb,LCb,MCb,NCb,OCb,PCb,lV,QCb,h4a,RCb,SCb,TCb,UCb,VCb,WCb,XCb,YCb,ZCb,$Cb,aDb,bDb,cDb,dDb,eDb,fDb,gDb,hDb,iDb,jDb,kDb,lDb,mDb,V7a,nDb,oDb,pDb,qDb,rDb,sDb,tDb,uDb,vDb,mV,wDb,nV,xDb,yDb,zDb,ADb,BDb,ZE,oV,CDb,DDb,EDb,FDb,
GDb,HDb,IDb,JDb,KDb,LDb,MDb,NDb,ODb,PDb,QDb,RDb,SDb,TDb,UDb,LTa,VDb,WDb,XDb,YDb,ZDb,$Db,pV,aEb,bEb,cEb,dEb,eEb,fEb,gEb,hEb,iEb,jEb,kEb,cRa,lEb,mEb,VO,nEb,oEb,pEb,qEb,rEb,qV,sEb,tEb,uEb,vEb,rV,wEb,xEb,yEb,zEb,AEb,BEb,CEb,DEb,EEb,FEb,GEb,HEb,IEb,JEb,KEb,LEb,MEb,NEb,OEb,PEb,QEb,REb,SEb,TEb,UEb,VEb,WEb,XEb,YEb,ZEb,$Eb,aFb,bFb,RD,cFb,dFb,eFb,fFb,gFb,hFb,wUa,iFb,jFb,kFb,lFb,mFb,nFb,oFb,pFb,qFb,rFb,sFb,tFb,uFb,vFb,wFb,xFb,yFb,sV,zFb,AFb,BFb,CFb,tV,DFb,EFb,FFb,GFb,HFb,IFb,JFb,KFb,LFb,MFb,HD,NFb,OFb,PFb,QFb,
RFb,SFb,uV,vV,TFb,UFb,VFb,WFb,XFb,YFb,ZFb,$Fb,aGb,bGb,cGb,dGb,eGb,RM,fGb,gGb,hGb,iGb,jGb,kGb,lGb,wV,mGb,nGb,oGb,kN,pGb,qGb,rGb,sGb,tGb,vGb,wGb,xGb,yGb,zGb,AGb,BGb,WTa,CGb,DGb,EGb,FGb,nE,GGb,HGb,IGb,JGb,KGb,LGb,MGb,NGb,OGb,PGb,QGb,RGb,SGb,GR,AE,TGb,UGb,VGb,WGb,XGb,YGb,ZGb,$Gb,xV,yV,aHb,bHb,zV,D3a,cHb,dHb,eHb,NP,AV,fHb,gHb,hHb,iHb,jHb,kHb,lHb,mHb,nHb,oHb,sO,pHb,qHb,BV,rHb,sHb,tHb,VE,m7a,uHb,vHb,wHb,TH,X6a,xHb,F4a,yHb,zHb,AHb,CV,DV,BHb,CHb,DHb,EHb,FHb,f7a,GHb,HHb,IHb,JHb,KHb,LHb,MHb,NHb,OHb,PHb,aVa,
QHb,RHb,SHb,EV,THb,FV,UHb,VHb,WHb,XHb,YHb,ZHb,$Hb,aIb,bIb,cIb,dIb,eIb,fIb,GV,HV,gIb,hIb,IV,iIb,jIb,kIb,lIb,mIb,JV,s8a,nIb,oIb,pIb,qIb,rIb,EP,sIb,DJ,tIb,uIb,KV,vIb,wIb,xIb,yIb,zIb,AIb,BIb,CIb,DIb,qUa,EIb,FIb,GIb,HIb,IIb,JIb,KIb,LIb,MIb,NIb,OIb,PIb,QIb,RIb,SIb,SXa,TIb,UIb,VIb,WIb,XIb,YIb,ZIb,$Ib,aJb,cJb,jPa,dJb,eJb,n_a,LV,fJb,gJb,hJb,iJb,jJb,kJb,lJb,mJb,nJb,oJb,pJb,qO,qJb,rJb,sJb,tJb,uJb,vJb,wJb,xJb,yJb,zJb,AJb,BJb,CJb,MV,DJb,EJb,FJb,B4a,UE,s7a,GJb,HJb,IJb,JJb,KJb,LJb,NV,OV,MJb,NJb,OJb,PJb,QJb,PV,RJb,
SJb,TJb,UJb,VJb,WJb,mUa,QV,XJb,YJb,ZJb,$Jb,aKb,bF,bKb,cKb,dKb,eKb,fKb,gKb,m3a,hKb,rRa,dUa,iKb,jKb,kKb,MVa,lKb,mKb,nKb,oKb,pKb,qKb,rKb,sKb,tKb,RV,SV,uKb,vKb,EQ,wKb,xKb,fF,yKb,zKb,AKb,m5a,BKb,CKb,DKb,EKb,FKb,GKb,HKb,IKb,CUa,JKb,KKb,N8a,LKb,qH,TV,MKb,NKb,UV,OKb,PKb,QKb,RKb,SKb,TKb,UKb,VKb,WKb,jQa,XKb,YKb,ZKb,KD,$Kb,aLb,bLb,cLb,dLb,eLb,fLb,gLb,hLb,iLb,jLb,kLb,lLb,mLb,nLb,oLb,pLb,qLb,rLb,sLb,tLb,uLb,vLb,wLb,xLb,yLb,zLb,ALb,BLb,CLb,DLb,ELb,FLb,GLb,HLb,ILb,JLb,KLb,LLb,rQ,VV,MLb,NLb,OLb,PLb,QLb,RLb,aZa,SLb,
PUa,TRa,TLb,mVa,ULb,sQ,VLb,WLb,DO,XLb,V4a,YLb,ZLb,$Lb,aMb,bMb,cMb,dMb,eMb,fMb,gMb,hMb,iMb,jMb,kMb,lMb,mMb,nMb,IZa,oMb,pMb,qMb,rMb,sMb,tMb,uMb,vMb,wMb,xMb,yMb,zMb,AMb,BMb,CMb,DMb,EMb,nVa,FMb,HMb,WV,IMb,XV,JMb,KMb,LMb,MMb,YV,NMb,OMb,PMb,QMb,lI,RMb,SMb,TMb,UMb,VMb,WMb,XMb,YMb,ZMb,aNb,bNb,ZV,cNb,dNb,eNb,fNb,gNb,hNb,iNb,jNb,kNb,lNb,mNb,nNb,oNb,pNb,qNb,rNb,sNb,tNb,kK,uNb,vNb,wNb,xNb,yNb,zNb,ANb,BNb,CNb,DNb,ENb,FNb,GNb,HNb,XG,INb,JNb,KNb,LNb,MNb,NNb,ONb,PNb,QNb,RNb,SNb,TNb,UNb,VNb,WNb,XNb,YNb,ZNb,$Nb,OE,
aOb,fUa,eUa,bOb,cOb,dOb,iUa,$V,eOb,aW,fOb,bW,gOb,hOb,iOb,FD,jOb,cW,dW,kOb,lOb,hRa,mOb,nOb,oOb,pOb,qOb,rOb,sOb,tOb,uOb,vOb,wOb,xOb,Q$a,a8a,yOb,zOb,AOb,BOb,vVa,COb,eW,q4a,DOb,EOb,FOb,iQa,GOb,HOb,IOb,JOb,KOb,fW,LOb,MOb,gW,NOb,OOb,POb,QOb,A2a,ROb,SOb,TOb,UOb,VOb,WOb,XOb,YOb,ZOb,$Ob,aPb,bPb,Z6a,cPb,dPb,ePb,l3a,fPb,gPb,hPb,iPb,jPb,kPb,hW,lPb,mPb,nPb,oPb,iW,jW,pPb,qPb,rPb,sPb,tPb,j3a,uPb,vPb,wPb,xPb,yPb,zPb,APb,BPb,CPb,DPb,EPb,FPb,GPb,HPb,IPb,JPb,YYa,KPb,HJ,LPb,kW,MPb,NPb,OPb,PPb,QPb,RPb,SPb,TPb,UPb,VPb,
WPb,lW,XPb,YPb,ZPb,$Pb,aQb,bQb,cQb,dQb,eQb,fQb,gQb,hQb,iQb,jQb,kQb,lQb,mW,mQb,nQb,oQb,pQb,qQb,rQb,sQb,tQb,uQb,aPa,nW,n7a,oW,vQb,wQb,ID,xQb,yQb,zQb,AQb,jN,BQb,lOa,CQb,DQb,EQb,FQb,GQb,HQb,IQb,JQb,KQb,LQb,MQb,NQb,Y7a,CK,OQb,JTa,PQb,QQb,RQb,qVa,FJ,BJ,SQb,TQb,UQb,VQb,GE,WQb,XQb,YQb,ZQb,$Qb,aRb,bRb,eZa,cRb,dRb,eRb,fRb,gRb,hRb,iRb,jRb,nQa,kRb,pE,sRa,lRb,mRb,oRb,pRb,qRb,rRb,sRb,tRb,qW,uRb,vRb,wRb,xRb,yRb,zRb,ARb,BRb,i4a,rW,CRb,DRb,ERb,FRb,GRb,HRb,sW,IRb,JRb,KRb,LRb,tW,MRb,NRb,F9a,fQa,uW,ORb,PRb,QRb,RRb,SRb,
TRb,URb,VRb,WRb,vW,XRb,YRb,ZRb,$Rb,aSb,bSb,cSb,dSb,eSb,wH,fSb,gSb,wW,xW,hSb,iSb,jSb,yW,zW,kSb,lSb,mSb,nSb,oSb,pSb,AW,qSb,rSb,sSb,tSb,BW,uSb,vSb,wSb,xSb,ySb,zSb,ASb,BSb,CSb,DSb,ESb,FSb,CW,DW,EW,FW,GSb,HSb,Y2a,ISb,uE,JSb,KSb,LSb,MSb,NSb,pH,OSb,PSb,QSb,RSb,SSb,vOa,TSb,USb,GW,VSb,WSb,XSb,YSb,mE,HW,ZSb,AVa,$Sb,aTb,bTb,IW,FYa,cTb,dTb,eTb,fTb,IG,JW,KW,LW,gTb,hTb,iTb,jTb,MW,kTb,lTb,V6a,mTb,nTb,oTb,pTb,ORa,hQ,qTb,rTb,sTb,tTb,uTb,vTb,wTb,xTb,yTb,zTb,ATb,BTb,IOa,CTb,hI,DTb,ETb,zP,eN,fN,K7a,FTb,GTb,HTb,ITb,JTb,
KTb,LTb,MTb,NTb,OTb,DYa,PTb,QTb,RTb,STb,TTb,UTb,RW,VTb,SW,WTb,XTb,YTb,ZTb,$Tb,aUb,TW,bUb,cUb,dUb,eUb,fUb,gUb,hUb,iUb,jUb,UW,kUb,lUb,mUb,nUb,oUb,pUb,vWa,qUb,rUb,sUb,tUb,uUb,IQa,vUb,wUb,xUb,yUb,zUb,AUb,BUb,CUb,DUb,EUb,FUb,eQa,GUb,HUb,IUb,JUb,KUb,$L,LUb,MUb,NUb,OUb,PUb,QUb,RUb,SUb,TUb,UUb,VUb,WUb,XUb,YUb,ZUb,$Ub,aVb,bVb,WW,cVb,dVb,eVb,fVb,gVb,hVb,YOa,iVb,OVa,jVb,RYa,kVb,lVb,SYa,TYa,UYa,VYa,mVb,nVb,XW,oVb,pVb,YW,qVb,ZW,rVb,sVb,tVb,uVb,MYa,NYa,OYa,vVb,wVb,PYa,kOa,xVb,$W,yVb,zVb,AVb,BVb,CVb,DVb,EVb,FVb,
bX,GVb,HVb,IVb,JVb,dX,KVb,LVb,MVb,fOa,NVb,OVb,PVb,QVb,RVb,SVb,TVb,gUa,UVb,VVb,eX,WVb,XVb,YVb,ZVb,fX,$Vb,aWb,bWb,cWb,dWb,RE,eWb,fWb,gWb,hWb,iWb,jWb,gX,kWb,hX,lWb,mWb,nWb,oWb,pWb,qWb,rWb,sWb,lF,tWb,uWb,vWb,g3a,wWb,xWb,yWb,zWb,AWb,BWb,CWb,qE,DWb,EWb,FWb,GWb,HWb,IWb,JWb,KWb,XTa,LWb,MWb,NWb,dP,OWb,PWb,QWb,RWb,SWb,TWb,UWb,iX,R6a,bRa,VWb,WWb,XWb,YWb,ZWb,$Wb,aXb,bXb,cXb,dXb,eXb,fXb,gXb,hXb,iXb,jXb,kXb,lXb,mXb,nXb,oXb,pXb,qXb,rXb,sXb,tXb,uXb,vXb,wXb,xXb,yXb,zXb,AXb,BXb,CXb,DXb,EXb,FXb,tH,GXb,qK,HXb,jX,IXb,
JXb,KXb,LXb,MXb,lX,NXb,OXb,PXb,QXb,RXb,SXb,TXb,mX,UXb,VXb,WXb,XXb,YXb,ZXb,$Xb,aYb,bYb,cYb,dYb,eYb,nX,fYb,gYb,hYb,jYb,kYb,oX,lYb,mYb,nYb,fVa,oYb,pYb,qYb,rYb,pX,qX,sYb,tYb,uYb,vYb,J4a,wYb,rX,xYb,yYb,zYb,AYb,BYb,CYb,DYb,EYb,FYb,kPa,GYb,HYb,IYb,JYb,KYb,DM,LYb,MYb,sX,NYb,PE,OYb,PYb,FVa,QYb,RYb,SYb,TYb,UYb,VYb,WYb,FG,XYb,YYb,ZYb,$Yb,aZb,tX,bZb,y4a,uX,cZb,dZb,vX,eZb,fZb,gZb,hZb,wX,xX,iZb,jZb,kZb,lZb,oQ,mZb,yX,nZb,oZb,TPa,pZb,qZb,rZb,sZb,tZb,uZb,vZb,wZb,xZb,yZb,zZb,AZb,BZb,zX,CZb,DZb,yQa,EZb,FZb,GZb,HZb,
IZb,JZb,KZb,KTa,LZb,MZb,NZb,OZb,PZb,QZb,FRa,aYa,RZb,SZb,TZb,UZb,VZb,WZb,AX,XZb,BX,YZb,ZZb,lVa,$Zb,a_b,EOa,b_b,POa,c_b,d_b,MPa,CX,e_b,f_b,g_b,h_b,i_b,j_b,k_b,l_b,m_b,n_b,o_b,p_b,q_b,gSa,r_b,nUa,s_b,t_b,u_b,v_b,w_b,x_b,y_b,z_b,A_b,B_b,C_b,D_b,E_b,F_b,G_b,H_b,I_b,J_b,K_b,L_b,M_b,N_b,O_b,P_b,Q_b,R_b,S_b,T_b,U_b,V_b,Q6a,W_b,X_b,Y_b,Z_b,$_b,a0b,b0b,c0b,d0b,e0b,f0b,g0b,h0b,i0b,j0b,k0b,l0b,m0b,n0b,o0b,p0b,q0b,OM,uH,r0b,s0b,t0b,u0b,FX,v0b,w0b,D4a,x0b,ITa,DE,y0b,z0b,A0b,B0b,C0b,GX,D0b,HX,rOa,xWa,E0b,F0b,fRa,
G0b,H0b,I0b,GRa,J0b,K0b,L0b,M0b,IX,N0b,O0b,P0b,Q0b,R0b,S0b,T0b,U0b,V0b,W0b,X0b,Y0b,Z0b,$0b,a1b,KPa,b1b,a3a,c1b,JX,d1b,e1b,f1b,KX,g1b,h1b,i1b,j1b,k1b,l1b,m1b,n1b,MX,NX,OX,o1b,p1b,q1b,r1b,s1b,t1b,PX,u1b,v1b,w1b,x1b,QX,y1b,RX,z1b,A1b,B1b,C1b,D1b,HPa,E1b,F1b,G1b,H1b,I1b,SX,J1b,K1b,L1b,M1b,N1b,O1b,P1b,Q1b,AUa,dQa,R1b,S1b,T1b,U1b,V1b,W1b,TX,X1b,Y1b,Z1b,$1b,a2b,b2b,c2b,d2b,e2b,f2b,g2b,h2b,i2b,j2b,nK,k2b,l2b,m2b,n2b,o2b,p2b,q2b,UX,r2b,s2b,t2b,u2b,hSa,v2b,w2b,x2b,FE,y2b,z2b,A2b,B2b,C2b,jUa,D2b,E2b,F2b,G2b,
H2b,I2b,J2b,K2b,L2b,VX,cR,M2b,NM,oOa,N2b,O2b,P2b,Q2b,R2b,S2b,OP,T2b,U2b,V2b,W2b,X2b,Y2b,Z2b,$2b,a3b,b3b,c3b,d3b,e3b,f3b,g3b,h3b,i3b,j3b,k3b,WX,l3b,m3b,n3b,o3b,p3b,q3b,HZa,r3b,s3b,t3b,u3b,iF,v3b,w3b,x3b,y3b,A3b,RG,p5a,B3b,C3b,D3b,E3b,F3b,e5a,G3b,I3b,J3b,K3b,L3b,YX,M3b,N3b,O3b,lE,P3b,Q3b,yK,R3b,S3b,T3b,U3b,V3b,ZX,W3b,X3b,Y3b,Z3b,$X,$3b,aY,b3a,a4b,bY,GTa,b4b,qQ,c4b,d4b,e4b,f4b,g4b,h4b,cY,i4b,j4b,k4b,l4b,m4b,n4b,o4b,p4b,q4b,dY,r4b,mH,s4b,EQa,IO,t4b,u4b,v4b,w4b,x4b,y4b,z4b,A4b,B4b,C4b,D4b,E4b,dOa,F4b,
eY,NQa,G4b,H4b,I4b,J4b,fY,K4b,L4b,M4b,N4b,O4b,XE,P4b,Q4b,R4b,S4b,T4b,U4b,sK,V4b,gY,W4b,hY,X4b,iY,Y4b,LE,Z4b,$4b,a5b,b5b,c5b,d5b,e5b,f5b,g5b,wab,iK,h5b,I4a,i5b,j5b,m4a,k5b,jY,l5b,m5b,n5b,kY,o5b,COa,p5b,NVa,q5b,r5b,s5b,t5b,$Oa,u5b,v5b,lY,w5b,x5b,y5b,z5b,A5b,B5b,YE,C5b,D5b,E5b,F5b,G5b,H5b,I5b,J5b,bK,$J,K5b,L5b,M5b,N5b,O5b,HYa,P5b,GYa,Q5b,R5b,mY,S5b,A8a,T5b,U5b,V5b,W5b,X5b,Y5b,Z5b,$5b,nY,a6b,b6b,c6b,d6b,e6b,f6b,g6b,h6b,QQa,i6b,j6b,h5a,k6b,l6b,m6b,n6b,o6b,p6b,q6b,r6b,s6b,t6b,u6b,v6b,w6b,x6b,y6b,hQa,z6b,
A6b,B6b,C6b,D6b,E6b,F6b,k0a,G6b,H6b,I6b,J6b,K6b,L6b,M6b,N6b,U6a,O6b,P6b,Q6b,R6b,S6b,oY,T6b,U6b,V6b,W6b,pY,X6b,qY,NJ,Y6b,MJ,KJ,Z6b,$6b,rY,a7b,b7b,c7b,d7b,e7b,f7b,g7b,nPa,sY,h7b,i7b,j7b,k7b,l7b,Q8a,m7b,n7b,o7b,p7b,q7b,r7b,s7b,t7b,tY,u7b,v7b,w7b,x7b,y7b,z7b,E5a,A7b,B7b,C7b,l7a,uY,D7b,E7b,F7b,G7b,H7b,I7b,J7b,K7b,L7b,mQa,M7b,N7b,O7b,P7b,Q7b,R7b,S7b,vY,T7b,V7b,W7b,wY,X7b,Y7b,Z7b,xY,$7b,D7a,a8b,b8b,c8b,d8b,e8b,f8b,g8b,h8b,i8b,j8b,k8b,l8b,m8b,n8b,o8b,p8b,q8b,zY,r8b,s8b,t8b,u8b,v8b,w8b,x8b,y8b,z8b,A8b,B8b,
C8b,D8b,AY,E8b,F8b,G8b,hF,H8b,I8b,lPa,J8b,SRa,K8b,HVa,L8b,OQa,ZUa,M8b,N8b,O8b,P8b,Q8b,bVa,TN,zRa,R8b,S8b,m2a,T8b,wG,U8b,GVa,V8b,W8b,X8b,Y8b,Z8b,$8b,a9b,b9b,c9b,d9b,e9b,f9b,g9b,h9b,i9b,j9b,k9b,l9b,m9b,n9b,o9b,p9b,q9b,r9b,s9b,t9b,u9b,v9b,w9b,x9b,y9b,z9b,A9b,BY,B9b,C9b,D9b,E9b,HRa,F9b,G9b,H9b,I9b,J9b,K9b,L9b,M9b,N9b,O9b,P9b,Q9b,R9b,S9b,T9b,U9b,V9b,DY,W9b,X9b,Y9b,EY,Z9b,$9b,a$b,eSa,b$b,c$b,FY,d$b,dF,e$b,f$b,g$b,h$b,i$b,j$b,k$b,l$b,m$b,n$b,y3a,o$b,p$b,yJ,cF,q$b,r$b,s$b,GY,HY,t$b,u$b,v$b,w$b,x$b,y$b,IY,
pQ,z$b,yH,ZJ,fK,aK,A$b,B$b,C$b,cK,D$b,E$b,F$b,G$b,H$b,I$b,J$b,K$b,L$b,M$b,N$b,O$b,P$b,Q$b,R$b,S$b,T$b,U$b,V$b,W$b,X$b,Y$b,Z$b,$$b,aac,bac,cac,dac,eac,KY,fac,gac,hac,iac,jac,kac,lac,mac,nac,oac,tM,pac,qac,rac,sac,UJ,tac,uac,vac,wac,xac,yac,aQa,zac,Aac,Bac,Cac,Dac,Eac,Gac,F7a,Hac,Iac,Jac,Kac,Lac,Mac,Nac,Oac,Pac,Qac,Rac,Sac,Tac,Uac,Vac,Wac,LY,Xac,Yac,Zac,$ac,abc,bbc,cbc,dbc,ebc,fbc,gbc,hbc,ibc,jbc,kbc,lbc,mbc,nbc,obc,pbc,qbc,rbc,sbc,f3a,tbc,ubc,vbc,wbc,xbc,ybc,zbc,Abc,Bbc,MY,Cbc,CVa,Dbc,Ebc,Fbc,Gbc,
Hbc,Ibc,Jbc,Kbc,Lbc,Mbc,Nbc,Obc,Pbc,Qbc,Rbc,Sbc,Tbc,Ubc,O$a,Vbc,w5a,Wbc,Xbc,bSa,Ybc,Zbc,$bc,acc,bcc,ccc,dcc,ecc,fcc,gcc,hcc,yP,icc,jcc,kcc,lcc,GG,mcc,ncc,occ,pcc,qcc,rcc,scc,tcc,ucc,vcc,wcc,NY,xcc,ycc,zcc,Acc,Bcc,Ccc,hUa,Dcc,Ecc,Fcc,Gcc,OY,Hcc,Icc,Jcc,Kcc,uVa,Lcc,QZa,vab,Mcc,Ncc,Occ,Pcc,Qcc,Rcc,L_a,Scc,Tcc,ED,DR,PY,YG,Vcc,Wcc,Xcc,Ycc,MTa,Zcc,$cc,adc,M4a,bQ,e7a,bdc,cdc,r7a,ddc,edc,fdc,gdc,hdc,idc,X9a,C9a,kdc,ldc,mdc,ndc,odc,HG,pdc,qdc,rdc,PM,sdc,tdc,udc,vdc,wdc,xdc,ydc,zdc,Adc,NTa,Bdc,Cdc,Ddc,Edc,
I6a,Fdc,QY,Gdc,Hdc,Idc,ME,Jdc,Kdc,Ldc,RY,Mdc,Ndc,Odc,Pdc,Qdc,Rdc,Sdc,Tdc,Udc,Vdc,Wdc,Xdc,Ydc,SY,Zdc,C6a,$dc,aec,bec,cec,dec,TY,eec,fec,gec,hec,iec,jec,kec,lec,mec,nec,oec,pec,qec,rec,UY,sec,tec,LD;lD=function(a,b){a=String(a);let c=a.indexOf(".");-1===c&&(c=a.length);const d="-"===a[0]?"-":"";d&&(a=a.substring(1));return d+(0,$APP.Js)("0",Math.max(0,b-c))+a};MNa=function(a,b){return function(){return $APP.Na(a,b)}};
NNa=function(a){a:{a=$APP.hi($APP.m.j(a)).split(".");for(var b=$APP.ha;;){if(null==b){a=null;break a}if(null==a){a=b;break a}b=$APP.Na(b,$APP.u(a));a=$APP.w(a)}}return a};mD=function(a,b){this.ve=a;this.name=b;this.O=6291456;this.U=0};nD=function(a,b){var c=$APP.hi($APP.m.j(b)),d=a.ve;return null!==d&&c in d?(b=$APP.Zg.A($APP.m.j(a.name),$APP.m.j(b)),new $APP.Ac(MNa(a.ve,c),b,new $APP.f(null,1,[$APP.yl,a],null))):null};
oD=function(a,b){return a===b?!0:a instanceof $APP.q&&b instanceof $APP.q?a.str===b.str:!1};PNa=function(){return $APP.Gj.B(ONa,$APP.Xl,function(a){return $APP.kh.j($APP.Fb(a))})};qD=function(a){null==pD&&(pD=$APP.kh.j($APP.F));var b=$APP.m.j(a);a=$APP.La(b,"$macros")?a:$APP.Zg.j([b,"$macros"].join(""));b=$APP.C.A($APP.Fb(pD),a);if(null!=b)return b;b=NNa(a);if(null==b)return null;b=new mD(b,a);$APP.lh.K(pD,$APP.rg,a,b);return b};
RNa=function(){var a=QNa,b=NNa(a),c=new mD(b,a);return $APP.Id.B(function(d,g){var l=$APP.Zg.j($APP.Dda(g));return $APP.rg.B(d,l,new $APP.Ac(function(){return $APP.Na(b,g)},$APP.Zg.A($APP.m.j(a),$APP.m.j(l)),new $APP.f(null,1,[$APP.yl,c],null)))},$APP.F,$APP.Ma(b))};rD=function(a){return $APP.Lf.A($APP.vg,$APP.ng(a))};sD=function(a,b){return $APP.Jd(function(c,d,g){return $APP.rg.B(c,d,a.j?a.j(g):a.call(null,g))},$APP.ad(b),b)};tD=function(a,b){return a.test(b)};uD=function(a){return BigInt(a)};
SNa=function(a){return $APP.Uc.A("bigint",$APP.la(a))};TNa=function(a){return $APP.Ca(a)};UNa=function(a){return $APP.xa(a)};vD=function(a){return"number"===typeof a?a:Number(a)};wD=function(a){throw Error(a);};xD=function(){return $APP.m.j($APP.Gh())};yD=function(a){throw Error(a);};zD=function(a){throw Error(a);};AD=function(a){throw Error(a);};VNa=function(a){throw Error(a);};WNa=function(a){throw Error(a);};XNa=function(a){return Number.parseInt(a)};YNa=function(a){return Number.parseFloat(a)};
BD=function(a){return null!=a?a.O&4096||$APP.xc===a.Th?!0:!1:!1};
ZNa=function(a,b){return $APP.Id.B(function(c,d){if(d instanceof $APP.q||d instanceof $APP.E)var g=new $APP.f(null,1,[CD,d],null);else{var l=$APP.r(d);g=$APP.u(l);l=$APP.w(l);var n=$APP.Jg($APP.Ke(new $APP.ug(null,new $APP.f(null,1,[$APP.ek,null],null),null)),l);l=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);var p=$APP.r(n);$APP.u(p);var v=$APP.w(p);p=$APP.u(v);v=$APP.w(v);$APP.r(n)?(d=$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[g],null),$APP.N.A(l,v)),g=new $APP.f(null,1,[$APP.ek,$APP.pe([p,g])],null),g=1<
$APP.Tc(d)?$APP.rg.B(g,CD,d):g):g=new $APP.f(null,1,[CD,d],null)}d=$APP.qe(g);g=$APP.C.A(d,$APP.ek);d=$APP.C.A(d,CD);a:for(DD.j(c),l=$APP.r(g),n=null,v=p=0;;)if(v<p){var t=n.aa(null,v);$APP.x.B(t,0,null);$APP.x.B(t,1,null);v+=1}else if(l=$APP.r(l))n=l,$APP.pd(n)?(l=$APP.lc(n),v=$APP.mc(n),n=l,p=$APP.Tc(l),l=v):(l=$APP.u(n),$APP.x.B(l,0,null),$APP.x.B(l,1,null),l=$APP.w(n),n=null,p=0),v=0;else break a;c=$APP.k(d)?$APP.Gj.K(c,ED,$APP.Vd,d):c;return $APP.k(g)?$APP.Gj.K(c,DD,$APP.Ni,g):c},new $APP.f(null,
2,[DD,b,ED,$APP.sf],null),a)};$Na=function(a){return $APP.Id.B(function(b,c){b=$APP.qe(b);var d=$APP.C.A(b,DD),g=$APP.r(c);c=$APP.u(g);g=$APP.w(g);if($APP.Uc.A(FD,c))return $APP.Gj.K(b,ED,$APP.Vd,$APP.Mn.A(c,g));d=ZNa(g,d);g=$APP.qe(d);d=$APP.C.A(g,DD);g=$APP.C.A(g,ED);b=$APP.hd(d)?b:$APP.Gj.K(b,DD,$APP.Ni,d);return $APP.hd(g)?b:$APP.Gj.K(b,ED,$APP.Vd,$APP.Mn.A(c,g))},new $APP.f(null,2,[DD,$APP.F,ED,$APP.sf],null),a)};
aOa=function(a,b,c){return $APP.Id.B(function(d,g){var l=$APP.Xl.j(d);return g.B?g.B(l,d,c):g.call(null,l,d,c)},a,b)};GD=function(a,b,c){return $APP.Id.B(function(d,g){return $APP.rg.B(d,g,function(){var l=$APP.C.A(d,g);return $APP.od(l)?$APP.Lf.B($APP.sf,$APP.Vg.j(function(n){return GD(n,b,c)}),l):GD(l,b,c)}())},null==a?null:aOa(a,b,c),HD.j(a))};
cOa=function(a){a=$APP.qe(a);var b=$APP.C.A(a,$APP.cy);var c=$APP.Bd(bOa,$APP.cy.j(a));c?(c=$APP.tj.j(a),$APP.k(c)?a=c:(c=new $APP.ug(null,new $APP.f(null,2,[$APP.Gk,null,$APP.Bl,null],null),null),b=c.j?c.j(b):c.call(null,b),a=$APP.k(b)?$APP.tj.j($APP.Yu.j(a)):null),b=new $APP.ug(null,new $APP.f(null,2,[$APP.$x,"null",$APP.zv,"null"],null),null),a=b.j?b.j(a):b.call(null,a)):a=c;return $APP.vd(a)};
eOa=function(a){return $APP.Uc.A($APP.Ju,$APP.cy.j(a))&&$APP.Uc.A(1,$APP.Tc($APP.Vl.j(a)))&&$APP.Uc.A($APP.sf,ID.j($APP.gm.j(a)))&&cOa(JD.j($APP.u($APP.Vl.j(a))))&&$APP.Uc.A(dOa,$APP.cy.j(KD.j($APP.gm.j(a))))};gOa=function(a,b){return $APP.Gj.B(a,fOa,function(c){return $APP.Vg.A(function(d){return $APP.Gj.B(d,$APP.fm,function(g){return $APP.un.A(function(l){return $APP.Uc.A(b,$APP.Q.j(l))},g)})},c)})};
hOa=function(a){return function(b,c){b=$APP.Li.K(c,new $APP.H(null,2,5,$APP.I,[$APP.Xl,LD],null),$APP.Oi,a);return $APP.Uc.A($APP.Hk,$APP.cy.j(c))?gOa(b,a):b}};ND=function(){return $APP.C.A($APP.Fb(null),$APP.MD)};PD=function(a,b,c){a=$APP.C.B(a,b,OD);return a===OD?null:$APP.C.A(a,c)};QD=function(a,b,c,d){a=$APP.C.B(a,b,OD);if(a===OD)return null;c=$APP.C.B(a,c,OD);return c===OD?null:$APP.C.A(c,d)};
SD=function(a,b,c,d){a=$APP.C.B(a,RD,OD);if(a===OD)return null;b=$APP.C.B(a,b,OD);if(b===OD)return null;c=$APP.C.B(b,c,OD);return c===OD?null:$APP.C.A(c,d)};TD=function(a,b){return[$APP.ki($APP.hi($APP.m.j(a)),".","/"),".",$APP.Ag(b)].join("")};
iOa=function(a){if(a instanceof $APP.E)var b="cst$kw$";else{if(!(a instanceof $APP.q))throw Error(["constant type ",$APP.m.j($APP.hb(a))," not supported"].join(""));b="cst$sym$"}a=a instanceof $APP.E?$APP.Og.A($APP.m.j(a),1):$APP.m.j(a);a=$APP.Uc.A(".",a)?"_DOT_":$APP.ki($APP.ki($APP.hi($APP.ki(a,"-","_DASH_")),".","$"),/[^a-z0-9$_]/i,function(c){c=c.charCodeAt(0).toString(16);var d=c.length;if(4>d){var g=$APP.m,l=g.j;a:{var n="0";for(d=4-d;;)if(0<d)n=[$APP.m.j(n),$APP.m.j("0")].join(""),--d;else break a}c=
[l.call(g,n),$APP.m.j(c)].join("")}return["_u",$APP.m.j(c),"_"].join("")});return $APP.Zg.j([b,a].join(""))};
mOa=function(a,b){$APP.lh.A(null,function(c){c=$APP.Li.B(c,new $APP.H(null,1,5,$APP.I,[jOa],null),function(d){return $APP.k($APP.C.A(d,b))?d:$APP.rg.B(d,b,iOa(b))});return $APP.k(a)?$APP.Li.B(c,new $APP.H(null,3,5,$APP.I,[RD,$APP.Q.j($APP.yl.j(a)),kOa],null),function(d){d=$APP.qe(d);var g=$APP.C.B(d,lOa,$APP.vg),l=$APP.C.B(d,$APP.UD,$APP.sf);return $APP.Bd(g,b)?d:$APP.rg.C(d,lOa,$APP.Vd.A(g,b),$APP.y([$APP.UD,$APP.Vd.A(l,b)]))}):c})};VD=function(a,b){a=$APP.Xi.j($APP.ed(a));return $APP.k(a)?a:$APP.Xi.j(b)};
WD=function(a,b){a=$APP.Aj.j($APP.ed(a));return $APP.k(a)?a:$APP.Aj.j(b)};nOa=function(a){return $APP.k($APP.Xi.j(a))?XD(null,a):null};XD=function(a,b){a=new $APP.f(null,3,[$APP.Wi,$APP.Uc.A($APP.Q.j($APP.yl.j(b)),$APP.An)?"cljs/core.cljs":null,$APP.Xi,VD(a,b),$APP.Aj,WD(a,b)],null);return $APP.k(oOa.j(b))?$APP.Ni.C($APP.y([a,$APP.sg(b,new $APP.H(null,1,5,$APP.I,[oOa],null))])):a};
YD=function(a,b){return[$APP.m.j(b),$APP.k($APP.Xi.j(a))?[" at line ",$APP.m.j($APP.Xi.j(a))," ",$APP.m.j(null)].join(""):$APP.k(null)?[" in file ",$APP.m.j(null)].join(""):null].join("")};$D=function(a,b,c){for(var d=$APP.r(ZD),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n);p.B?p.B(a,b,c):p.call(null,a,b,c);n+=1}else if(d=$APP.r(d))g=d,$APP.pd(g)?(d=$APP.lc(g),l=$APP.mc(g),g=d,p=$APP.Tc(d),d=l,l=p):(p=$APP.u(g),p.B?p.B(a,b,c):p.call(null,a,b,c),d=$APP.w(g),g=null,l=0),n=0;else return null};
pOa=function(a){return function(b,c,d){return $APP.k(b.j?b.j(aE):b.call(null,aE))?$APP.lh.B(a,$APP.Vd,new $APP.H(null,3,5,$APP.I,[b,c,d],null)):null}};qOa=function(a){$APP.gh(function(b){return $APP.Je.A($D,b)},$APP.Fb(a))};
cE=function(a,b,c){var d=$APP.Ni.C;a=nOa(a);var g=$APP.qe(a);a=$APP.C.A(g,$APP.Wi);var l=$APP.C.A(g,$APP.Xi);g=$APP.C.A(g,$APP.Aj);return d.call($APP.Ni,$APP.y([new $APP.f(null,3,[rOa,a,sOa,l,tOa,g],null),new $APP.f(null,1,[bE,b],null),$APP.k(c)?new $APP.f(null,1,[uOa,c],null):null]))};gE=function(a,b){return fE(a,b,null)};fE=function(a,b,c){return $APP.Zi.B(YD(a,b),$APP.rg.B(nOa(a),$APP.tj,vOa),c)};wOa=function(a){return $APP.Uc.A(vOa,$APP.tj.j($APP.Ih(a)))};
zOa=function(){return function(a,b,c){var d=$APP.Zg.A($APP.m.j(b),$APP.m.j(c));d=hE.A?hE.A(d,a):hE.call(null,d,a);return $D(xOa,a,new $APP.f(null,3,[$APP.Dv,b,$APP.rq,c,yOa,null!=d],null))}};AOa=function(a){var b=$APP.Lg(/(.*)\$(.*)/,$APP.m.j(a));return $APP.k(b)?$APP.Se.A(1,b):new $APP.H(null,2,5,$APP.I,[a,null],null)};iE=function(a){return BOa($APP.am.A($APP.Fb(null),new $APP.H(null,1,5,$APP.I,[COa],null)),a)};
DOa=function(a){try{var b;if(b=$APP.Uc.A("default","nodejs")){var c=require.resolve($APP.m.j(a));var d=$APP.k(c)?c:require.resolve($APP.u(AOa(a)));b=$APP.vd(d)}return b}catch(g){return!1}};GOa=function(a){var b=AOa(a);a=$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.am.A($APP.Fb(null),new $APP.H(null,3,5,$APP.I,[EOa,$APP.m.j(a),FOa],null));return $APP.Bd(b,$APP.Zg.j(a))||$APP.Bd(b,$APP.Ag(a))};
KOa=function(a){a=AOa(a);var b=$APP.x.B(a,0,null);$APP.x.B(a,1,null);a=$APP.m.j(b);b=ND();b=HOa.j(b);$APP.k(b)&&(b=new $APP.ug(null,new $APP.f(null,2,["goog.array",null,"goog.object",null],null),null),b=b.j?b.j(a):b.call(null,a));return $APP.k(b)?!1:$APP.Uc.A(IOa,$APP.am.A($APP.Fb(null),new $APP.H(null,3,5,$APP.I,[EOa,a,JOa],null)))};LOa=function(){return function(a,b,c){return jE.K(a,b,c,function(d,g,l){throw gE(d,["Unable to resolve var: ",$APP.m.j(l)," in this context"].join(""));})}};
kE=function(a,b){return MOa(a,b,$APP.Zg.j(b))};MOa=function(a,b,c){b=$APP.Zg.j(b);return $APP.C.B($APP.bk.j($APP.yl.j(a)),b,c)};NOa=function(a,b,c){b=$APP.Zg.j(b);return $APP.C.B($APP.vn.j($APP.yl.j(a)),b,c)};SOa=function(a,b){$APP.qg.A($APP.An,b)&&null==$APP.C.A(OOa,b)&&null==$APP.C.A($APP.bk.j($APP.yl.j(a)),b)&&null==PD($APP.Fb(null),RD,b)&&$APP.eb(iE(b))&&$D(POa,a,new $APP.f(null,2,[QOa,b,ROa,b],null))};
UOa=function(a,b){var c=function(){var d=null!=SD($APP.Fb(null),$APP.An,lE,b);if(d)return d;d=hE.A?hE.A(b,a):hE.call(null,b,a);if(null==d)return!1;d=$APP.yl.j($APP.ed(d));return $APP.Uc.A(d.getName(),TOa)}();return c?!$APP.Bd(mE.j($APP.yl.j(a)),b):c};VOa=function(a,b){var c=function(){var d=SD($APP.Fb(null),a,lE,b);return $APP.k(d)?d:SD($APP.Fb(null),$APP.Zg.j([$APP.Ag(a),"$macros"].join("")),lE,b)}();return null!=c&&$APP.eb(function(){var d=$APP.No.j(c);return $APP.k(d)?d:nE.j(c)}())};
oE=function(a){return a instanceof $APP.q&&($APP.Uc.A($APP.bx,a)||$APP.Uc.A("js",$APP.ae(a)))};WOa=function(a){return a instanceof $APP.q?a:$APP.hd(a)?null:1===$APP.Tc(a)?$APP.u(a):$APP.Bd(a,$APP.jy)?$APP.jy:$APP.Bd(a,$APP.$x)?(a=$APP.Am.A(a,pE),1===$APP.Tc(a)?$APP.$x:a):a};
ZOa=function(a,b,c){for(;;){if($APP.hd(a))return!0;var d=$APP.u(a);b=$APP.Dd(b,d);if($APP.eb(b))return!1;d=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);d=$APP.ed(d);var g=$APP.Uc.A(XOa,$APP.tj.j(d));d=g?YOa.j(d):g;if($APP.k(d))return d=ZOa($APP.Lf.A(new $APP.H(null,1,5,$APP.I,[qE],null),$APP.w(a)),b,c),$APP.k(d)?d:ZOa($APP.w(a),b,c);a=$APP.w(a)}};
rE=function(a){var b=$Oa.j($APP.Fb(null));var c=$APP.Dd($APP.am.A(b,new $APP.H(null,2,5,$APP.I,[aPa,qE],null)),$APP.u(a));null==c?c=a:(c=$APP.tj.j($APP.ed($APP.u(c))),c=null==c?a:$APP.Lf.A(new $APP.H(null,2,5,$APP.I,[c,qE],null),$APP.w(a)));c=ZOa(c,b,b);if($APP.k(c))return c;if($APP.Uc.A(1,$APP.Tc(a))){c=$APP.u(a);var d=$APP.am.A(b,$APP.Vd.A(new $APP.H(null,2,5,$APP.I,[aPa,qE],null),c));b=$APP.k(d)?d:$APP.am.A(b,$APP.Vd.A(new $APP.H(null,1,5,$APP.I,[bPa],null),c))}else b=null;return $APP.k(b)?b:$APP.ri($APP.m.j($APP.$c(a)),
"cljs$")};dPa=function(a,b){var c=$Oa.j($APP.Fb(null));return cPa(a,b,c,c)};cPa=function(a,b,c,d){c=$APP.Dd(c,$APP.u(a));if($APP.k(c)){var g=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);g=$APP.ed(g);g=b.j?b.j(g):b.call(null,g);if($APP.Uc.A($APP.Tc(a),1))return $APP.k(g)?$APP.Zg.A("js",$APP.m.j(ePa.A?ePa.A(g,g):ePa.call(null,g,g))):null;c=cPa($APP.w(a),b,c,d);return $APP.k(c)?c:cPa($APP.Lf.A(new $APP.H(null,1,5,$APP.I,[qE],null),$APP.w(a)),b,$APP.C.A(d,g),d)}return null};
fPa=function(a){a=$APP.m.j(a);return $APP.La(a,".")&&!$APP.La(a,"..")};gPa=function(a){return["node$module$",$APP.m.j($APP.hi($APP.ki($APP.m.j(a),/[.\\/]/,"$$")))].join("")};hPa=function(a){return["goog$module$",$APP.m.j($APP.hi($APP.ki($APP.m.j(a),/[.\\/]/,"$$")))].join("")};iPa=function(a){return["global$module$",$APP.m.j($APP.hi($APP.ki($APP.m.j(a),/[.\\/]/,"$$")))].join("")};
pPa=function(a){var b;if(b=$APP.Uc.A($APP.An,$APP.An))b=new $APP.ug(null,new $APP.f(null,2,[$APP.Zx,"null",$APP.Xu,"null"],null),null),b=b.j?b.j(a):b.call(null,a),b=$APP.k(b)?$APP.qg.A(jPa,kPa.j(ND()))?!1:null:b;return $APP.k(b)?$APP.am.A(new $APP.f(null,2,[$APP.kw,new $APP.f(null,2,[$APP.Zx,lPa,$APP.Xu,mPa],null),$APP.hw,new $APP.f(null,2,[$APP.Zx,nPa,$APP.Xu,oPa],null)],null),new $APP.H(null,2,5,$APP.I,[$APP.qg.A(jPa,kPa.j(ND()))?!1:null,a],null)):a};
tPa=function(a){return KOa(a)?qPa:$APP.k(iE(a))?$APP.sE:DOa(a)?rPa:GOa(a)?sPa:null};vPa=function(a,b){a=$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[$APP.Jx],null),$APP.tf($APP.Vg.A($APP.Zg,$APP.qi.A($APP.Ag(a),/\./))));$APP.k(rE(a))||$APP.lh.C(null,$APP.Li,$APP.Lf.A(new $APP.H(null,3,5,$APP.I,[RD,b,uPa],null),a),$APP.Ni,$APP.y([$APP.F]));return a};
wPa=function(a,b){a=kE(b,a);return(b=$APP.Bd($APP.yg($APP.pg(PD(b,$APP.yl,$APP.bk))),a)||$APP.Bd($APP.yg($APP.pg(PD(b,$APP.yl,tE))),a))?(b=iE(a),$APP.k(b)?b:DOa(a)||GOa(a)):b};
xPa=function(a,b,c){a=kE(c,a);var d=tPa(a);d=d instanceof $APP.E?d.ga:null;switch(d){case "js":return b=$APP.Zg.j,d=QD($APP.Fb(null),COa,a,$APP.Q),c=$APP.k(d)?d:kE(c,a),new $APP.f(null,3,[$APP.Q,b.call($APP.Zg,c),$APP.cy,uE,$APP.yl,$APP.bx],null);case "node":return new $APP.f(null,3,[$APP.Q,$APP.Zg.A($APP.m.j(b),gPa(kE(c,a))),$APP.cy,uE,$APP.yl,b],null);case "global":return new $APP.f(null,3,[$APP.Q,$APP.Zg.A($APP.m.j(b),iPa(kE(c,a))),$APP.cy,uE,$APP.yl,b],null);default:throw Error(["No matching clause: ",
$APP.m.j(d)].join(""));}};vE=function(a,b){return b instanceof $APP.q?new $APP.f(null,1,[$APP.Q,a],null):b};xE=function(a,b){return wE(a,b,null,!0)};
wE=function(a,b,c,d){for(;;){var g=LD.j(a);if("js"===$APP.ae(b)){c=$APP.Zg.j($APP.Ag(b));c=vE(c,$APP.C.A(g,c));if(null!=c)return $D(yPa,a,new $APP.f(null,1,[$APP.Q,b],null)),$APP.rg.B(c,$APP.cy,$APP.Bl);var l=$APP.tf($APP.Vg.A($APP.Zg,$APP.qi.A($APP.Ag(b),/\./)));$APP.eb(rE(l))&&$APP.eb($APP.pw.j($APP.ed(b)))&&$APP.lh.C(null,$APP.Li,$APP.Lf.A(new $APP.H(null,3,5,$APP.I,[RD,$APP.Q.j($APP.yl.j(a)),uPa],null),l),$APP.Ni,$APP.y([$APP.F]));return $APP.Ni.C($APP.y([new $APP.f(null,4,[$APP.Q,b,$APP.cy,uE,
$APP.yl,$APP.bx,$APP.tj,$APP.z(function(){var R=dPa(l,$APP.tj);if($APP.k(R))return R;R=$APP.tj.j($APP.ed(b));return $APP.k(R)?R:$APP.bx}(),new $APP.f(null,1,[$APP.Dv,l],null))],null),function(){var R=dPa(l,yE);return $APP.k(R)?new $APP.f(null,2,[zPa,!0,yE,R],null):null}()]))}var n=$APP.m.j(b),p=vE(b,$APP.C.A(g,b)),v=$APP.Q.j($APP.yl.j(a));if(null!=p)return $APP.rg.B(p,$APP.cy,$APP.Bl);if(null!=$APP.ae(b)){d=$APP.ae(b);var t="clojure.core"===d?"cljs.core":d;d=MOa(a,t,function(){var R=iE(t);R=$APP.k(R)?
QD($APP.Fb(null),COa,t,$APP.Q):R;return $APP.k(R)?R:$APP.Zg.j(t)}());if(null!=c){$APP.qg.A(v,d)&&SOa(a,d);g=a;p=d;var A=$APP.Zg.j($APP.Ag(b));c.B?c.B(g,p,A):c.call(null,g,p,A)}return zE.K(a,b,d,v)}if(fPa(b)){A=n.indexOf(".");var B=$APP.Zg.j($APP.Og.B(n,0,A)),G=$APP.Og.A(n,A+1),J=wE(a,B,null,!1);if($APP.k(J)){var O=J;return $APP.Gj.B(O,$APP.Q,function(R,W,Z,fa,ia,ja,ta,ua,ca){return function(V){return $APP.Zg.j([$APP.m.j(V),".",ca].join(""))}}(a,b,c,d,O,J,A,B,G,n,p,v,g))}c=$APP.m.j(function(){var R=
n;if(KOa(b)){var W=a;if(KOa(R)){var Z=$APP.Zg.j;W=$APP.Q.j($APP.yl.j(W));R=[$APP.m.j($APP.hi(W)),".",hPa(R)].join("");Z=Z.call($APP.Zg,R)}else Z=R}else Z=R;return Z}());v=c.lastIndexOf(".");l=$APP.Og.B(c,0,v);c=$APP.Og.A(c,v+1);return new $APP.f(null,3,[$APP.cy,$APP.Gk,$APP.Q,$APP.Zg.A(l,c),$APP.yl,$APP.Zg.j(l)],null)}if(null!=SD($APP.Fb(null),v,tE,b))return d=SD($APP.Fb(null),v,tE,b),zE.K(a,b,d,v);if(null!=SD($APP.Fb(null),v,AE,b))return c=SD($APP.Fb(null),v,AE,b),d=$APP.Zg.j($APP.ae(c)),g=$APP.Zg.j($APP.Ag(c)),
zE.K(a,g,d,v);if(null!=SD($APP.Fb(null),v,$APP.um,b))g=a,v=SD($APP.Fb(null),v,$APP.um,b),a=g,b=v;else return null!=SD($APP.Fb(null),v,lE,b)?(null!=c&&(c.B?c.B(a,v,b):c.call(null,a,v,b)),$APP.Ni.C($APP.y([SD($APP.Fb(null),v,lE,b),new $APP.f(null,3,[$APP.Q,$APP.Zg.A($APP.m.j(v),$APP.m.j(b)),$APP.cy,$APP.Gk,$APP.yl,v],null)]))):UOa(a,b)?(g=pPa(b),null!=c&&(v=a,d=$APP.An,p=g,c.B?c.B(v,d,p):c.call(null,v,d,p)),$APP.Ni.C($APP.y([SD($APP.Fb(null),$APP.An,lE,g),new $APP.f(null,3,[$APP.Q,$APP.Zg.A("cljs.core",
$APP.m.j(g)),$APP.cy,$APP.Gk,$APP.yl,$APP.An],null)]))):$APP.k(wPa(n,a))?xPa(n,v,a):$APP.k(d)?(null!=c&&(c.B?c.B(a,v,b):c.call(null,a,v,b)),$APP.Ni.C($APP.y([SD($APP.Fb(null),v,lE,b),new $APP.f(null,3,[$APP.Q,$APP.Zg.A($APP.m.j(v),$APP.m.j(b)),$APP.cy,$APP.Gk,$APP.yl,v],null)]))):null}};APa=function(a,b){return $APP.eb($APP.pw.j($APP.ed(b)))?wE(a,b,jE,!0):xE(a,b)};
BPa=function(a,b){var c=$APP.Q.j($APP.yl.j(a)),d=$APP.C.A($APP.Fb(null),RD);if(null!=$APP.ae(b))return c=$APP.ae(b),c=$APP.Uc.A("clojure.core",c)?"cljs.core":c,a=NOa(a,c,$APP.Zg.j(c)),a=$APP.Sda($APP.m.j(a),"$macros")?a:$APP.Zg.j([$APP.m.j(a),"$macros"].join("")),$APP.am.A(d,new $APP.H(null,3,5,$APP.I,[a,lE,$APP.Zg.j($APP.Ag(b))],null));if(null!=$APP.am.A(d,new $APP.H(null,3,5,$APP.I,[c,BE,b],null)))return a=$APP.am.A(d,new $APP.H(null,3,5,$APP.I,[c,BE,b],null)),$APP.am.A(d,new $APP.H(null,3,5,$APP.I,
[a,CE,b],null));if(null!=$APP.am.A(d,new $APP.H(null,3,5,$APP.I,[c,DE,b],null)))return b=$APP.am.A(d,new $APP.H(null,3,5,$APP.I,[c,DE,b],null)),a=$APP.Zg.j($APP.ae(b)),b=$APP.Zg.j($APP.Ag(b)),$APP.am.A(d,new $APP.H(null,3,5,$APP.I,[a,CE,b],null));c=null!=$APP.am.A(d,new $APP.H(null,3,5,$APP.I,[c,CE,b],null))?c:UOa(a,b)?TOa:null;return null!=c?$APP.am.A(d,new $APP.H(null,3,5,$APP.I,[c,lE,b],null)):null};
CPa=function(a,b){var c=function(){var g=$APP.Om.j(a);return $APP.k(g)?g:$APP.Om.j($APP.Yu.j(a))}(),d=$APP.Tc(b);return $APP.He(function(g){var l=(l=$APP.Un.j(g)===d)?l:$APP.tu.j(g);return $APP.k(l)?g:l},c)};FPa=function(a,b){if(null!=b&&b instanceof $APP.q){a:{var c=EE;EE=!0;try{var d=xE(a,b);break a}finally{EE=c}d=void 0}a=$APP.Ui.j(d);return null==a?(a=$APP.Ui.j($APP.Yu.j(d)),null==a?(d=FE.j(d),null==d?$APP.C.A(new $APP.ug(null,new $APP.f(null,2,[DPa,"null",EPa,"null"],null),null),b):d):a):a}return null};
GPa=function(a){a=$APP.qe(a);var b=$APP.C.A(a,$APP.cy);return $APP.$d(b,$APP.Ok)?$APP.Ck.j(a):a};
LPa=function(a,b){var c=GPa($APP.Pr.j(b)),d=$APP.qe(c);c=$APP.C.A(d,$APP.cy);var g=$APP.C.A(d,$APP.Qw);d=function(){var l=GE.j(b);return HE.A?HE.A(a,l):HE.call(null,a,l)}();if($APP.$d(c,$APP.Nw)&&null!=g&&!1!==g)return d;c=function(){var l=$APP.vr.j(b);return HE.A?HE.A(a,l):HE.call(null,a,l)}();if(oD(d,c)||oD(c,HPa))return d;if(oD(d,HPa))return c;if(null==$APP.C.A(IPa,d)&&!FPa(a,d)||null==$APP.C.A(IPa,c)&&!FPa(a,c)){if(null!=$APP.C.A(JPa,d)&&null!=$APP.C.A(JPa,c))return $APP.$x;d=BD(d)?d:$APP.wg([d]);
c=BD(c)?c:$APP.wg([c]);return $APP.Lf.A(d,c)}return KPa};
NPa=function(a,b){var c=$APP.Q.j(a),d=new $APP.H(null,5,5,$APP.I,[$APP.yl,$APP.P,$APP.Wi,$APP.Xi,$APP.Aj],null);c=$APP.Ni.C($APP.y([function(){var g=$APP.h.j(a),l=$APP.ng(g);return $APP.Bg(l,$APP.Vg.A(function(n){return new $APP.D(null,$APP.K,new $APP.D(null,$APP.C.A(g,n),null,1,null),2,null)},l))}(),$APP.rg.C($APP.Bg(d,$APP.Vg.A(function(g){return new $APP.D(null,$APP.K,new $APP.D(null,$APP.C.A(a,g),null,1,null),2,null)},d)),$APP.Q,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,
$APP.Zg.j($APP.Ag($APP.Q.j(a))),null,1,null)))),$APP.y([$APP.Pr,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.su,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,MPa,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)])))),$APP.U,function(){var g=$APP.U.j(a);g=$APP.Uc.A($APP.K,$APP.u(g))?$APP.Xc(g):g;return new $APP.D(null,$APP.K,new $APP.D(null,$APP.Ej.j($APP.Vg.B($APP.z,g,$APP.Cx.j(a))),null,1,null),2,null)}()]))]));return $APP.k(b)?
IE?IE(b,c):JE.call(null,b,c):c};OPa=function(a,b){var c=EE;EE=!0;try{var d=$APP.Oi.A(a,LD),g=wE(d,b,LOa(),!0),l=$APP.rg.B(d,KE,$APP.Ck),n=$APP.yl.j(g);if(null==n)var p=null;else{var v=IE?IE(l,b):JE.call(null,l,b),t=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,$APP.Zg.A($APP.Ag(n),$APP.Ag($APP.Q.j(g))),null,1,null))));var A=IE?IE(l,t):JE.call(null,l,t);p=new $APP.f(null,3,[$APP.Gk,v,$APP.mx,A,$APP.h,NPa(g,l)],null)}return p}finally{EE=c}};
QPa=function(a,b){if($APP.Td(b)&&2===$APP.Tc(b)&&$APP.Ge($APP.zc,b)){var c=function(){var l=aE;aE=$APP.Bg($APP.ng(aE),$APP.Vj.j(!1));try{var n=$APP.rg.B(a,KE,$APP.Ck),p=$APP.u(b);return IE?IE(n,p):JE.call(null,n,p)}finally{aE=l}}();if($APP.Uc.A($APP.Gk,$APP.cy.j(c))){var d=function(){var l=$APP.Q.j(c);return PPa.j?PPa.j(l):PPa.call(null,l)}();if($APP.k(d)){var g=$APP.$c(b);return $APP.k(function(){var l=null==$APP.ae(g);return l?$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[LD,g],null)):l}())?new $APP.H(null,
2,5,$APP.I,[g,d],null):null}}}return null};
UPa=function(a,b){if($APP.Td(b)&&3===$APP.Tc(b)&&$APP.Ge($APP.zc,b)&&!$APP.Bd(RPa,$APP.u(b))){var c=function(){var n=aE;aE=$APP.Bg($APP.ng(aE),$APP.Vj.j(!1));try{var p=$APP.rg.B(a,KE,$APP.Ck),v=$APP.u(b);return IE?IE(p,v):JE.call(null,p,v)}finally{aE=n}}();if($APP.Uc.A($APP.Gk,$APP.cy.j(c))&&$APP.k(function(){var n=$APP.Q.j(c),p=new $APP.ug(null,new $APP.f(null,2,[SPa,"null",TPa,"null"],null),null);return p.j?p.j(n):p.call(null,n)}())){var d=function(){var n=aE;aE=$APP.Bg($APP.ng(aE),$APP.Vj.j(!1));
try{var p=$APP.rg.B(a,KE,$APP.Ck),v=$APP.Xc(b);return IE?IE(p,v):JE.call(null,p,v)}finally{aE=n}}(),g=$APP.Q.j(d),l=$APP.$c(b);return $APP.k(function(){var n=$APP.Uc.A($APP.Gk,$APP.cy.j(d));return n?(n=null==$APP.ae(l))?$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[LD,l],null)):n:n}())?new $APP.H(null,2,5,$APP.I,[l,g],null):null}}return null};
VPa=function(a,b){if($APP.k(function(){var d=b instanceof $APP.q;return d?(d=null==$APP.ae(b))?$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[LD,b],null)):d:d}())){var c=function(){var d=aE;aE=$APP.Bg($APP.ng(aE),$APP.Vj.j(!1));try{var g=$APP.rg.B(a,KE,$APP.Ck);return IE?IE(g,b):JE.call(null,g,b)}finally{aE=d}}();c=$APP.tj.j(c);return $APP.k(c)?$APP.jd(c)&&$APP.Bd(c,pE)?new $APP.H(null,2,5,$APP.I,[b,WOa($APP.Am.A(c,pE))],null):null:null}return null};
WPa=function(a,b){var c=QPa(a,b);$APP.k(c)||(c=UPa(a,b),c=$APP.k(c)?c:VPa(a,b));b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return $APP.k(b)?$APP.cm(a,new $APP.H(null,3,5,$APP.I,[LD,b,$APP.tj],null),c):a};XPa=function(a){return a instanceof $APP.q?a:null};YPa=function(){var a=new $APP.f(null,1,[KE,$APP.Ck],null);return function(b,c){return $APP.rg.B(c,$APP.Xl,a)}};ZPa=function(a){return $APP.bf.C(function(b){b=$APP.C.A(a,b);return $APP.od(b)?b:$APP.k(b)?new $APP.H(null,1,5,$APP.I,[b],null):null},$APP.y([HD.j(a)]))};
$Pa=function(a){a=$APP.Ag(a);return 2<a.length&&$APP.Ia(a,"*")&&$APP.Ja(a,"*")};bQa=function(a){var b=$APP.Ag(a);return $APP.qg.A(aQa,a)&&($APP.Ia(b,"cljs.")||$APP.Ia(b,"clojure."))};
gQa=function(a){return function(b,c){var d=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);var g=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);if($APP.k($APP.ae(c)))throw gE(a,["Can't use qualified name as parameter: ",$APP.m.j(c)].join(""));var l=VD(c,a),n=WD(c,a),p=$APP.ed(c);p=$APP.tj.j(p);var v=null!=d?vE(c,d.j?d.j(c):d.call(null,c)):null,t=$APP.Ni.C($APP.y([$APP.sg(a,new $APP.H(null,1,5,$APP.I,[KE],null)),new $APP.f(null,2,[$APP.Xi,l,$APP.Aj,n],null)]));g=$APP.fg([$APP.Q,cQa,$APP.cy,$APP.Xl,$APP.Aj,$APP.Xi,
dQa,$APP.Yu,$APP.tj,LE,$APP.Bl],[c,!0,eQa,t,n,l,g,new $APP.f(null,2,[$APP.Q,c,LE,v],null),p,v,fQa]);return new $APP.H(null,2,5,$APP.I,[$APP.rg.B(d,c,g),$APP.Vd.A(b,g)],null)}};
kQa=function(a,b,c,d,g){var l=$APP.u(c),n=$APP.vd($APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.Lh,"null"],null),null),l)),p=$APP.tf($APP.un.A(new $APP.ug(null,new $APP.f(null,1,[$APP.Lh,"null"],null),null),l));l=$APP.w(c);b=$APP.Id.B(gQa(a),new $APP.H(null,2,5,$APP.I,[b,$APP.sf],null),$APP.ip.A($APP.ps,p));var v=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);p=!0===n?$APP.zg(b):b;p=$APP.Tc(p);var t=new $APP.f(null,4,[ME,ME.j(a),$APP.fm,b,hQa,$APP.kh.j(null),$APP.Ay,$APP.kh.j($APP.sf)],null),A=$APP.Yd(t,
NE);v=$APP.rg.C(a,KE,OE,$APP.y([LD,v]));l=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Qh,null,1,null),l)));if($APP.k(g))a:{g=NE;NE=A;try{var B=IE?IE(v,l):JE.call(null,v,l);break a}finally{NE=g}B=void 0}else B=null;g=$APP.Fb(hQa.j(t));return $APP.Ni.C($APP.y([new $APP.f(null,8,[$APP.Xl,a,$APP.cy,iQa,$APP.tu,n,$APP.fm,b,$APP.Un,p,$APP.Ui,d,$APP.Qw,c,jQa,g],null),null!=B?new $APP.f(null,2,[$APP.gm,$APP.rg.B(B,PE,!0),HD,new $APP.H(null,2,5,$APP.I,[$APP.fm,$APP.gm],null)],null):new $APP.f(null,1,[HD,
new $APP.H(null,1,5,$APP.I,[$APP.fm],null)],null)]))};oQa=function(a,b,c){if(null!=c){var d=$APP.Q.j($APP.yl.j(a));b=vE(c,$APP.C.A(b,c));b=$APP.k(b)?b:$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[lQa,c],null));a=mQa.j(a);d=new $APP.f(null,4,[$APP.Q,c,$APP.cy,eQa,$APP.Bl,$APP.Hk,$APP.Yu,new $APP.f(null,4,[nQa,!0,mQa,a,$APP.yl,d,LE,b],null)],null);c=$APP.tj.j($APP.ed(c));return $APP.Ni.C($APP.y([d,null!=c?new $APP.f(null,1,[yE,c],null):null]))}return null};
pQa=function(a,b,c,d){return $APP.Hl.A(function(g){return kQa(a,b,g,c,!0)},d)};rQa=function(a,b){return $APP.Hl.A(function(c){var d=$APP.rg.B(a,KE,qQa);return IE?IE(d,c):JE.call(null,d,c)},$APP.zg(b))};sQa=function(a,b){var c=NE;NE=$APP.Yd(null,NE);try{return rQa(a,b)}finally{NE=c}};tQa=function(a,b,c){var d=QE;QE=c;try{return IE?IE(a,b):JE.call(null,a,b)}finally{QE=d}};uQa=function(a,b){a=$APP.tj.j($APP.ed(a));return null==a?(a=$APP.tj.j(b),null==a?$APP.tj.j($APP.Yu.j(b)):a):a};
vQa=function(a,b,c){var d=$APP.sf,g=$APP.rg.B(a,KE,$APP.Ck);for(b=$APP.r($APP.Ll.A(2,b));;){var l=$APP.u(b);if(null==l)return new $APP.H(null,2,5,$APP.I,[d,g],null);var n=l,p=$APP.x.B(n,0,null),v=$APP.x.B(n,1,null);if(null!=$APP.ae(p)||$APP.La($APP.m.j(p),"."))throw gE(a,["Invalid local name: ",$APP.m.j(p)].join(""));var t=tQa(g,v,$APP.Yd(new $APP.f(null,1,[$APP.fm,d],null),QE)),A=VD(p,g),B=WD(p,g),G=function(){var O=vE(p,$APP.am.A(g,new $APP.H(null,2,5,$APP.I,[LD,p],null)));return $APP.k(O)?O:$APP.am.A(g,
new $APP.H(null,2,5,$APP.I,[lQa,p],null))}(),J=$APP.fg([HD,JD,$APP.Q,cQa,$APP.cy,$APP.Xl,$APP.Aj,$APP.Xi,$APP.Yu,$APP.tj,LE,$APP.Bl],[new $APP.H(null,1,5,$APP.I,[JD],null),t,p,!0,eQa,new $APP.f(null,2,[$APP.Xi,A,$APP.Aj,B],null),B,A,new $APP.f(null,2,[$APP.Q,p,LE,G],null),uQa(p,t),G,c]);l=$APP.Uc.A($APP.Hk,$APP.cy.j(t))?$APP.Ni.C($APP.y([J,new $APP.f(null,5,[RE,!0,$APP.Om,$APP.Lf.A($APP.sf,$APP.Vg.A(function(){return function(O){return $APP.sg(O,new $APP.H(null,3,5,$APP.I,[$APP.tj,$APP.Un,$APP.tu],
null))}}(d,g,b,t,A,B,G,J,n,p,v,l),$APP.Om.j(t))),$APP.tu,$APP.tu.j(t),$APP.qw,$APP.qw.j(t),$APP.wy,$APP.Vg.A($APP.fm,$APP.Om.j(t))],null)])):J;d=$APP.Vd.A(d,l);l=$APP.cm(g,new $APP.H(null,2,5,$APP.I,[LD,p],null),l);b=$APP.w(b);g=l}};wQa=function(a,b,c){var d=NE;NE=$APP.Yd(null,NE);try{return vQa(a,b,c)}finally{NE=d}};
xQa=function(a,b,c,d,g){var l=NE,n=QE;NE=d;QE=g;try{var p=$APP.rg.B(a,KE,$APP.Uc.A($APP.Ck,b)?OE:b),v=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Qh,null,1,null),c)));return IE?IE(p,v):JE.call(null,p,v)}finally{QE=n,NE=l}};
AQa=function(a,b,c){for(var d=null;;){var g=b,l=$APP.r(g),n=$APP.u(l),p=$APP.w(l),v=n,t=$APP.u(p),A=$APP.w(p),B=t,G=A,J=g;if(!$APP.od(B)||!$APP.Ie($APP.Tc(B)))throw gE(a,"bindings must be vector of even number of elements");var O=KE.j(a),R=!0===c?yQa:$APP.Ju;b=$APP.k(d)?$APP.tf($APP.bf.C(function(){return function(ca,V){var da=$APP.x.B(ca,0,null);ca=$APP.x.B(ca,1,null);return new $APP.H(null,2,5,$APP.I,[$APP.Yj.K(da,$APP.rg,$APP.tj,V),ca],null)}}(a,b,c,d,O,R,g,l,n,p,v,t,A,B,G,J),$APP.y([$APP.Ll.A(2,
B),d]))):B;b=wQa(function(){var ca=a;return!0===c?$APP.rg.B(ca,zQa,!0):ca}(),b,R);var W=$APP.x.B(b,0,null),Z=$APP.x.B(b,1,null),fa=!0===c?new $APP.f(null,3,[$APP.fm,W,hQa,$APP.kh.j(null),$APP.Ay,$APP.kh.j($APP.Hl.A($APP.tj,W))],null):null,ia=$APP.k(fa)?$APP.Yd(fa,NE):NE,ja=!0===c?QE:null!=QE?$APP.Yd(new $APP.f(null,1,[$APP.fm,W],null),QE):null,ta=$APP.k(function(){var ca=c;return $APP.k(ca)?$APP.eb(d):ca}())?$APP.kh.j($APP.sf):null;b=$APP.k(ta)?function(){var ca=ZD;ZD=new $APP.H(null,1,5,$APP.I,[pOa(ta)],
null);try{return xQa(Z,O,G,ia,ja)}finally{ZD=ca}}():xQa(Z,O,G,ia,ja);g=new $APP.H(null,2,5,$APP.I,[$APP.Vl,$APP.gm],null);var ua=$APP.fn.A($APP.Kd,$APP.jy);if($APP.k(function(){var ca=c;return $APP.k(ca)?$APP.eb(d)&&$APP.qg.A($APP.Hl.A(ua,$APP.Fb($APP.Ay.j(fa))),$APP.Hl.A($APP.Jl.A(ua,$APP.tj),W)):ca}()))R=a,b=J,J=c,g=$APP.Fb($APP.Ay.j(fa)),a=R,c=J,d=g;else return $APP.k(ta)&&qOa(ta),new $APP.f(null,6,[$APP.cy,R,$APP.Xl,a,$APP.Vl,W,$APP.gm,$APP.rg.B(b,PE,!0),$APP.Qw,J,HD,g],null)}};
SE=function(a,b){return[$APP.m.j(b),"; offending spec: ",$APP.jh.C($APP.y([a]))].join("")};
BQa=function(a,b){if(!(b instanceof $APP.q||"string"===typeof b||$APP.kd(b)))throw gE(a,SE(b,"Only [lib.ns \x26 options] and lib.ns specs supported in :require / :require-macros"));if($APP.kd(b)){if(!($APP.u(b)instanceof $APP.q||"string"===typeof $APP.u(b)))throw gE(a,SE(b,"Library name must be specified as a symbol in :require / :require-macros"));if($APP.Ie($APP.Tc(b)))throw gE(a,SE(b,"Only :as alias, :refer (names) and :rename {from to} options supported in :require"));if(!$APP.Ge(new $APP.ug(null,
new $APP.f(null,3,[$APP.dk,null,$APP.dn,null,$APP.cn,null],null),null),$APP.Vg.A($APP.u,$APP.Ll.A(2,$APP.w(b)))))throw gE(a,SE(b,"Only :as, :refer and :rename options supported in :require / :require-macros"));var c=$APP.Kg($APP.w(b));if(!(1>=(c.A?c.A($APP.dk,0):c.call(null,$APP.dk,0))&&1>=(c.A?c.A($APP.cn,0):c.call(null,$APP.cn,0))))throw gE(a,SE(b,"Each of :as and :refer options may only be specified once in :require / :require-macros"));}};
CQa=function(a,b){return $APP.Id.B(function(c,d){var g=$APP.r(d),l=$APP.u(g),n=$APP.w(g);if($APP.Uc.A(l,FD)){if($APP.r(mE.j(c)))throw gE(a,"Only one :refer-clojure form is allowed per namespace definition");var p=new $APP.ug(null,new $APP.f(null,2,[$APP.en,null,$APP.dn,null],null),null),v=function(){for(var t=$APP.r(n),A=new $APP.f(null,2,[mE,$APP.vg,AE,$APP.F],null),B=!$APP.Ie($APP.Tc(n));;){if(!0===B)throw gE(a,"Only [:refer-clojure :exclude (names)] and optionally `:rename {from to}` specs supported");
if(null!=t){var G=$APP.u(t);if($APP.k(p.j?p.j(G):p.call(null,G))){var J=$APP.Xc(t);if($APP.Uc.A(G,$APP.en)&&$APP.kd(J)&&$APP.Ge($APP.zc,J)||$APP.Uc.A(G,$APP.dn)&&$APP.md(J)&&$APP.Ge(function(){return function(O){return $APP.Ge($APP.zc,O)}}(t,A,B,J,G,p,d,g,l,n,l,n),J))if($APP.Uc.A(G,$APP.en))t=$APP.Zc(t),A=$APP.Li.K(A,new $APP.H(null,1,5,$APP.I,[mE],null),$APP.Lf,J),B=!1;else if($APP.Uc.A(G,$APP.dn))t=$APP.Zc(t),A=$APP.Li.K(A,new $APP.H(null,1,5,$APP.I,[AE],null),$APP.Ni,J),B=!1;else return null;else B=
!0}else B=!0}else return A}}();return $APP.Qo.C($APP.Lf,$APP.y([c,v]))}return c},new $APP.f(null,2,[mE,$APP.vg,AE,$APP.F],null),b)};
DQa=function(a,b){var c=$APP.r(b),d=$APP.u(c),g=$APP.w(c);if(!(d instanceof $APP.q)||$APP.Ie($APP.Tc(b)))throw gE(a,SE(b,"Only [lib.ns :only (names)] and optionally `:rename {from to}` specs supported in :use / :use-macros"));for(var l=$APP.r(g),n=new $APP.H(null,1,5,$APP.I,[d],null),p=!1;;){if(!0===p)throw gE(a,SE(b,"Only [lib.ns :only (names)] and optionally `:rename {from to}` specs supported in :use / :use-macros"));if(null!=l){var v=$APP.u(l),t=$APP.Uc.A(v,$APP.Hha);if(t||$APP.Uc.A(v,$APP.dn)){if(null!=
$APP.He($APP.wg([t?$APP.cn:v]),n))throw gE(a,SE(b,"Each of :only and :rename options may only be specified once in :use / :use-macros"));var A=$APP.Xc(l);t&&$APP.kd(A)&&$APP.Ge($APP.zc,A)||$APP.Uc.A(v,$APP.dn)&&$APP.md(A)&&$APP.Ge(function(){return function(B){return $APP.Ge($APP.zc,B)}}(l,n,p,A,v,t,b,c,d,g,d,g,b),A)?(l=$APP.Zc(l),n=$APP.Lf.A(n,new $APP.H(null,2,5,$APP.I,[t?$APP.cn:v,A],null)),p=!1):p=!0}else p=!0}else{if(null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.cn,null],null),null),
n))return n;p=!0}}};
TE=function(a,b,c,d,g){for(;;)if(g instanceof $APP.q||"string"===typeof g)g=new $APP.H(null,1,5,$APP.I,[g],null);else{BQa(a,g);var l=g,n=$APP.r(l),p=$APP.u(n),v=$APP.w(n),t=p,A=v,B=function(){var Y=QD($APP.Fb(null),COa,$APP.m.j(t),$APP.Q);return null==Y?new $APP.H(null,2,5,$APP.I,[t,null],null):new $APP.H(null,2,5,$APP.I,[$APP.Zg.j(Y),t],null)}(),G=$APP.x.B(B,0,null),J=$APP.x.B(B,1,null),O=$APP.Je.A($APP.Lk,A),R=$APP.qe(O),W=$APP.C.B(R,$APP.dk,"string"===typeof G?$APP.Zg.j($APP.hi(G)):G),Z=$APP.C.A(R,
$APP.cn),fa=$APP.C.A(R,$APP.dn),ia=$APP.r($APP.un.A($APP.yg($APP.ng(fa)),Z)),ja=$APP.k(b)?new $APP.H(null,3,5,$APP.I,[$APP.vn,BE,DE],null):new $APP.H(null,3,5,$APP.I,[$APP.Zj,$APP.gn,$APP.dn],null),ta=$APP.x.B(ja,0,null),ua=$APP.x.B(ja,1,null),ca=$APP.x.B(ja,2,null);if(!(W instanceof $APP.q||null==W))throw gE(a,SE(g,":as must be followed by a symbol in :require / :require-macros"));if(null!=W){var V=$APP.k(b)?CE:EQa,da=function(){var Y=V.j($APP.Fb(d));return Y.j?Y.j(W):Y.call(null,W)}();if(null!=
da&&$APP.qg.A(G,da))throw gE(a,SE(g,":as alias must be unique"));$APP.lh.C(d,$APP.Li,new $APP.H(null,1,5,$APP.I,[V],null),$APP.Vd,$APP.y([new $APP.H(null,2,5,$APP.I,[W,G],null),$APP.k(J)?new $APP.H(null,2,5,$APP.I,[J,G],null):null]))}if(!($APP.kd(Z)&&$APP.Ge($APP.zc,Z)||null==Z))throw gE(a,SE(g,":refer must be followed by a sequence of symbols in :require / :require-macros"));$APP.k(b)||$APP.lh.B(c,$APP.Vd,G);return $APP.Ni.C($APP.y([null!=W?$APP.pe([ta,$APP.Ni.C($APP.y([$APP.pe([W,G]),$APP.pe([G,
G]),$APP.k(J)?$APP.pe([J,G]):null]))]):null,null!=ia?$APP.pe([ua,$APP.Je.A($APP.Lk,$APP.Uj.A(ia,$APP.Vj.j(G)))]):null,null!=fa?$APP.pe([ca,$APP.Id.B(function(Y,ea,ya,wa,Ba,Qa,Va,cb,pb,rb,yb,Ub,Db,Nb,gc,Gc,yd,ve){return function(Xe,qf){var oi=$APP.x.B(qf,0,null);qf=$APP.x.B(qf,1,null);if(!$APP.k($APP.He($APP.wg([oi]),ve)))throw gE(Y,["Renamed symbol ",$APP.m.j(oi)," not referred"].join(""));return $APP.rg.B(Xe,qf,$APP.Zg.A($APP.m.j(Db),$APP.m.j(oi)))}}(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja,
ta,ua,ca),$APP.F,fa)]):null]))}};
FQa=function(a,b,c){if(!($APP.kd(c)&&$APP.Ge($APP.zc,c)||c instanceof $APP.q&&null==$APP.ae(c)))throw gE(a,SE(c,"Only lib.ns.Ctor or [lib.ns Ctor*] spec supported in :import"));a=$APP.kd(c)?$APP.Lf.A($APP.F,$APP.Vg.A(function(v){return new $APP.H(null,2,5,$APP.I,[v,$APP.Zg.j([$APP.m.j($APP.u(c)),".",$APP.m.j(v)].join(""))],null)},$APP.Fc(c))):-1!==$APP.m.j(c).indexOf(".")?$APP.pe([$APP.Zg.j($APP.$c($APP.qi.A($APP.m.j(c),/\./))),c]):$APP.F;for(var d=$APP.r(a),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,
n);$APP.x.B(p,0,null);p=$APP.x.B(p,1,null);$APP.lh.B(b,$APP.Vd,p);n+=1}else if(d=$APP.r(d))$APP.pd(d)?(l=$APP.lc(d),d=$APP.mc(d),g=l,l=$APP.Tc(l)):(g=$APP.u(d),$APP.x.B(g,0,null),g=$APP.x.B(g,1,null),$APP.lh.B(b,$APP.Vd,g),d=$APP.w(d),g=null,l=0),n=0;else break;return new $APP.f(null,2,[UE,a,$APP.Zj,a],null)};GQa=function(a){return $APP.Vg.A(function(b){if(b instanceof $APP.E)return b;b=$APP.Xc(b);return $APP.od(b)||$APP.md(b)?b:new $APP.H(null,1,5,$APP.I,[b],null)},a)};
HQa=function(a){return $APP.Vg.A(function(b){return b instanceof $APP.E?b:$APP.Xc(b)},a)};
JQa=function(a){function b(v){var t=new $APP.ug(null,new $APP.f(null,2,[$APP.nn,null,$APP.on,null],null),null);return t.j?t.j(v):t.call(null,v)}function c(v){return $APP.kd(v)?$APP.Vg.A(function(t){return $APP.Uc.A(t,$APP.Gha)?$APP.cn:t},v):v}function d(v,t){for(;;){var A=(A=$APP.kd(t))?$APP.He(v,t):A;if($APP.eb(A))return t;A=$APP.Jg($APP.Ke(v),t);t=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);t=$APP.N.A(t,$APP.Se.A(2,A))}}var g=$APP.Lf.A($APP.F,$APP.Vg.A(function(v){var t=$APP.r(v);v=$APP.u(t);t=$APP.w(t);
return new $APP.H(null,2,5,$APP.I,[v,$APP.Lf.A($APP.sf,t)],null)},a));g=$APP.qe(g);var l=$APP.C.A(g,$APP.Zj),n=new $APP.ug(null,new $APP.f(null,2,[IQa,null,$APP.Gha,null],null),null),p=$APP.Pi.A(d,n);l=$APP.r(function(v){return $APP.Vg.A(function(t){return $APP.eb(b(t))?c(d(new $APP.ug(null,new $APP.f(null,1,[$APP.dn,null],null),null),d(new $APP.ug(null,new $APP.f(null,1,[$APP.cn,null],null),null),d(new $APP.ug(null,new $APP.f(null,1,[IQa,null],null),null),t)))):t},$APP.df.A(function(t){var A=(A=
$APP.kd(t))?$APP.He(n,t):A;if($APP.k(A))return A;A=b(t);if($APP.k(A))t=A;else if($APP.k(!0)){t=$APP.kd(t)?$APP.u(t):t;A=$APP.am.A($APP.Fb(null),new $APP.H(null,2,5,$APP.I,[RD,t],null));var B=$APP.qe(A);A=$APP.C.A(B,BE);B=$APP.C.A(B,$APP.vn);A=$APP.He($APP.wg([t]),$APP.pg(A));t=$APP.k(A)?A:$APP.He($APP.wg([t]),$APP.pg(B))}else t=null;return t},v))}(l));return null==l?a:$APP.Vg.A(function(v){if($APP.eb(b(v))){var t=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);return $APP.Yd(t,$APP.Vg.A(p,v))}return v},$APP.Li.K(g,
new $APP.H(null,1,5,$APP.I,[$APP.vn],null),$APP.fn.A($APP.Lf,$APP.sf),l))};
KQa=function(a,b,c){c=$APP.Vg.A(function(v){return new $APP.H(null,2,5,$APP.I,[$APP.Zg.j($APP.Kl.A(".",$APP.zg(v))),$APP.Zg.j($APP.$c(v))],null)},$APP.Se.A(2,$APP.Ut.B($APP.Vd,$APP.sf,c)));c=$APP.r(c);for(var d=null,g=0,l=0;;)if(l<g){var n=d.aa(null,l),p=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);$APP.k($APP.am.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[RD,p,lE,n],null)))&&$D(VE,a,new $APP.f(null,2,[$APP.yl,b,$APP.Gk,$APP.Zg.A($APP.m.j(p),$APP.m.j(n))],null));l+=1}else if(c=$APP.r(c))$APP.pd(c)?(d=
$APP.lc(c),c=$APP.mc(c),p=d,g=$APP.Tc(d),d=p):(d=$APP.u(c),p=$APP.x.B(d,0,null),n=$APP.x.B(d,1,null),$APP.k($APP.am.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[RD,p,lE,n],null)))&&$D(VE,a,new $APP.f(null,2,[$APP.yl,b,$APP.Gk,$APP.Zg.A($APP.m.j(p),$APP.m.j(n))],null)),c=$APP.w(c),d=null,g=0),l=0;else break};LQa=function(a){var b=$APP.m.j(a);return $APP.eb($APP.Ja(b,"$macros"))?$APP.Zg.j([b,"$macros"].join("")):a};
MQa=function(a,b){if(0<$APP.Tc(a)){var c=new $APP.H(null,8,5,$APP.I,[BE,$APP.vn,DE,tE,$APP.bk,AE,$APP.um,DD],null);return $APP.Ni.C($APP.y([a,$APP.sg(b,new $APP.H(null,1,5,$APP.I,[mE],null)),$APP.Qo.C($APP.Ni,$APP.y([$APP.sg(a,c),$APP.sg(b,c)]))]))}return b};
WQa=function(a,b,c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(c,2,null),l=$APP.x.B(c,3,null),n=$APP.x.B(c,4,null),p=$APP.Q.j(xE($APP.Oi.A(b,LD),d)),v=$APP.Id.B(function(A,B){return $APP.rg.B(A,B,$APP.fg([$APP.Q,WE,$APP.Aj,NQa,$APP.Xi,$APP.tj,$APP.io,$APP.by,LE,$APP.Bl],[B,!0,WD(B,b),NQa.j($APP.ed(B)),VD(B,b),$APP.tj.j($APP.ed(B)),$APP.io.j($APP.ed(B)),$APP.by.j($APP.ed(B)),A.j?A.j(B):A.call(null,B),WE]))},$APP.F,$APP.Uc.A(OQa,a)?$APP.N.A(g,new $APP.H(null,3,5,$APP.I,[PQa,QQa,$APP.z($APP.jya,
new $APP.f(null,1,[$APP.io,!0],null))],null)):g),t=XE.j($APP.ed(d));$APP.lh.K(null,$APP.Li,new $APP.H(null,4,5,$APP.I,[RD,$APP.Q.j($APP.yl.j(b)),lE,d],null),function(A){A=$APP.rg.C($APP.k(A)?A:$APP.F,$APP.Q,p,$APP.y([$APP.tj,$APP.jx,$APP.Ui,!0,RQa,$APP.Tc(g),SQa,$APP.Uc.A(OQa,a)]));return $APP.Ni.C($APP.y([A,$APP.Oi.A($APP.ed(d),XE),new $APP.f(null,1,[XE,t],null),XD(d,b)]))});return $APP.fg([HD,TQa,XE,UQa,$APP.cy,$APP.Xl,$APP.VQa,$APP.Qw,$APP.tj,$APP.gm],[new $APP.H(null,1,5,$APP.I,[$APP.gm],null),
l,$APP.Am.A(t,YE),g,a,b,p,c,$APP.jx,function(){var A=$APP.rg.B(b,LD,v);return IE?IE(A,n):JE.call(null,A,n)}()])};aRa=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);var d=$APP.I;var g=(g=c instanceof $APP.q)?$APP.Lg(/^-.*/,$APP.Ag(c)):g;return new $APP.H(null,3,5,d,[null==b?XQa:ZE,$APP.vd(g)?YQa:c instanceof $APP.q?ZQa:$APP.td(c)?$Qa:XQa,null==a?$APP.Ec:ZE],null)};
dRa=function(a,b,c){return b instanceof $APP.q?new $APP.f(null,4,[bRa,cRa,$E,a,$APP.ny,b,$APP.Xj,c],null):new $APP.f(null,4,[bRa,cRa,$E,a,$APP.ny,$APP.u(b),$APP.Xj,c],null)};
jRa=function(a,b,c,d,g){b=aF.j(new $APP.H(null,3,5,$APP.I,[b,c,d],null));var l=$APP.qe(b),n=$APP.C.A(l,bRa);d=$APP.C.A(l,$E);b=$APP.C.A(l,$APP.ny);c=$APP.C.A(l,WE);l=$APP.C.A(l,$APP.Xj);var p=$APP.rg.B(a,KE,$APP.Ck);d=IE?IE(p,d):JE.call(null,p,d);var v=$APP.ed(g),t=$APP.tj.j(d),A=$APP.k(c)?c:b,B=function(){var R=$APP.tj.j(v);if($APP.k(R))return R;if(R=oE(t)){R=$APP.Yj.S;var W=$APP.Uc.A($APP.bx,t)?t:$APP.z($APP.bx,new $APP.f(null,1,[$APP.Dv,$APP.Vd.A($APP.tf($APP.Vg.A($APP.Zg,$APP.qi.A($APP.Ag(t),
/\./))),qE)],null));R=R.call($APP.Yj,W,$APP.Li,new $APP.H(null,1,5,$APP.I,[$APP.Dv],null),$APP.fn.A($APP.Vd,new $APP.H(null,1,5,$APP.I,[$APP.Jx],null)),A)}return $APP.k(R)?R:null}();if($APP.qg.A(bF,A)&&!$APP.ri($APP.m.j(A),"cljs$")&&$APP.eb(eRa.j($APP.ed(A)))&&($APP.Uc.A($APP.Jx,$APP.u($APP.Dv.j($APP.ed(B))))&&$D(cF,a,new $APP.f(null,3,[fRa,gRa,$APP.Qw,g,dF,A],null)),$APP.qg.A($APP.bx,t))){$APP.k(function(){var R=null==t;if(R)return R;R=new $APP.ug(null,new $APP.f(null,1,[$APP.jy,"null"],null),null);
return R.j?R.j(t):R.call(null,t)}())&&$D(cF,a,new $APP.f(null,3,[fRa,$E,$APP.Qw,g,dF,A],null));var G=$APP.wi.A($APP.zg,$APP.Kd)($APP.Dv.j($APP.ed(B))),J=$APP.x.B(G,0,null),O=$APP.x.B(G,1,null);$APP.k(function(){var R=rE(J);return $APP.k(R)?$APP.eb(rE(O)):R}())&&$D(cF,a,new $APP.f(null,4,[fRa,dF,$APP.Qw,g,$APP.Ui,$APP.Zg.A("js",$APP.Kl.A(".",$APP.Uc.A(qE,$APP.$c(J))?$APP.zg(J):J)),dF,A],null))}oE(B)&&(G=$APP.Dv.j($APP.ed(B)),$APP.k(rE(G))||$APP.lh.C(null,$APP.Li,$APP.Lf.A(new $APP.H(null,3,5,$APP.I,
[RD,$APP.Q.j($APP.yl.j(a)),uPa],null),G),$APP.Ni,$APP.y([$APP.F])));n=n instanceof $APP.E?n.ga:null;switch(n){case "cljs.analyzer/access":return n=new $APP.H(null,1,5,$APP.I,[$E],null),new $APP.f(null,7,[$APP.cy,hRa,$APP.Xl,a,$APP.Qw,g,$E,d,WE,c,HD,n,$APP.tj,oE(B)?function(){var R=$APP.Dv.j($APP.ed(B));R=dPa(R,$APP.tj);return $APP.k(R)?R:B}():B],null);case "cljs.analyzer/call":return c=$APP.Hl.A(function(R){return IE?IE(p,R):JE.call(null,p,R)},l),n=new $APP.H(null,2,5,$APP.I,[$E,$APP.Xj],null),new $APP.f(null,
8,[$APP.cy,iRa,$APP.Xl,a,$APP.Qw,g,$E,d,$APP.ny,b,$APP.Xj,c,HD,n,$APP.tj,oE(B)?function(){var R=$APP.Dv.j($APP.ed(B));R=dPa(R,yE);return $APP.k(R)?R:$APP.bx}():B],null);default:throw Error(["No matching clause: ",$APP.m.j(n)].join(""));}};kRa=function(a){a=$APP.ed(a);var b=$APP.tj.j(a);return null==b?!0===eF.j(a)?$APP.$u:null:b};
mRa=function(a){return null==a?!0:$APP.Uc.A(pE,a)?!0:oE(a)?!0:a instanceof $APP.q&&null!=$APP.C.A(lRa,a)?!0:BD(a)?$APP.Bd(a,$APP.$u)||$APP.Bd(a,$APP.Av)||$APP.Bd(a,$APP.py)||$APP.Bd(a,$APP.jy)||$APP.Bd(a,$APP.bx):null};oRa=function(a){if(null==a)a=!0;else if($APP.Uc.A(pE,a))a=!0;else if(oE(a))a=!0;else if($APP.Uc.A($APP.jy,a))a=!0;else if($APP.Bd(nRa,a))a=!0;else{if(BD(a)){var b=$APP.Bd(a,$APP.jy);a=b?b:(b=$APP.Bd(a,$APP.bx))?b:$APP.He(nRa,a)}else a=null;a=$APP.vd(a)}return a};
pRa=function(a,b,c){return $APP.u($APP.Id.B(function(d,g){var l=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return new $APP.H(null,2,5,$APP.I,[$APP.Vd.A(l,IE?IE(d,g):JE.call(null,d,g)),$APP.Uc.A(a,$APP.xu)?WPa(d,g):d],null)},new $APP.H(null,2,5,$APP.I,[$APP.sf,b],null),c))};
tRa=function(a,b,c,d){function g(A,B){var G=$APP.Vg.A(function(J){return HE(a,J)},t);return $APP.k(B.j?B.j(G):B.call(null,G))?null:$D(A,a,new $APP.f(null,2,[fF,v,qRa,$APP.Lf.A($APP.sf,G)],null))}var l=$APP.rg.B(a,KE,$APP.Ck),n=$APP.ed(d);b=gF(b);var p=kRa(d),v=fF.j(n),t=pRa(v,l,c);c=eF.j(n);!0===c&&g(rRa,function(A){return $APP.Ge(mRa,A)});return $APP.fg([$APP.Xj,HD,eF,sRa,$APP.cy,$APP.Xl,fF,$APP.Qw,$APP.tj],[t,new $APP.H(null,1,5,$APP.I,[$APP.Xj],null),c,b,$APP.sE,a,v,d,p])};
uRa=function(a){return $APP.md(a)&&!$APP.ld(a)?$APP.rg.B(a,hF,!0):$APP.Yj.K(a,$APP.rg,hF,!0)};vRa=function(a){return $APP.vd($APP.md(a)&&!$APP.ld(a)?hF.j(a):hF.j($APP.ed(a)))};wRa=function(a){return $APP.Ge(function(b){return null==b||b instanceof $APP.q||"string"===typeof b||"number"===typeof b||!0===b||!1===b},a)};
xRa=function(a,b){var c;if(c=a instanceof $APP.q)c=(c=null!=$APP.ae(a))?$APP.am.A($APP.Fb(null),new $APP.H(null,5,5,$APP.I,[RD,$APP.Zg.j($APP.ae(a)),lE,$APP.Zg.j($APP.Ag(a)),SQa],null)):c;if(c=$APP.vd(c))c=$APP.Zg.j(["-\x3e",$APP.Ag(a)].join("")),a=$APP.u($APP.am.A($APP.Fb(null),new $APP.H(null,5,5,$APP.I,[RD,$APP.Zg.j($APP.ae(a)),lE,c,$APP.wy],null))),a=$APP.Lf.A($APP.vg,a),c=$APP.Bd(a,b);return c};
yRa=function(a,b,c,d){return(b=!(null==b||$APP.vd($APP.He($APP.wg([a]),$APP.Vg.A($APP.Tc,b)))))?(b=$APP.eb(c))?b:$APP.k(c)?a<d:c:b};
ERa=function(a,b){var c=$APP.r(b),d=$APP.u(c),g=$APP.w(c),l=$APP.rg.B(a,KE,$APP.Ck),n=IE?IE(l,d):JE.call(null,l,d),p=$APP.Tc(g),v=function(){var ja=RE.j($APP.Yu.j(n));return $APP.k(ja)?ja:zPa.j($APP.Yu.j(n))}();c=$APP.Uc.A(iF,$APP.tj.j(n));var t=$APP.Q.j($APP.yl.j(a)),A=$APP.vd(!1)&&$APP.eb(v)&&!oE(d)&&!c&&!vRa(d),B=A&&!(d instanceof $APP.q),G=A&&!wRa(g);if(v){v=$APP.Yu.j(n);v=$APP.qe(v);var J=$APP.C.A(v,$APP.tu),O=$APP.C.A(v,$APP.qw),R=$APP.C.A(v,$APP.wy);A=$APP.C.A(v,$APP.Q);var W=$APP.C.A(v,$APP.yl),
Z=$APP.C.A(v,$APP.Dl);$APP.k(function(){var ja=$APP.Ja($APP.m.j(t),"$macros");return(ja=$APP.eb($APP.k(ja)?oD(t,W)&&!0===Z:ja))?yRa(p,R,J,O):ja}())&&$D(jF,a,new $APP.f(null,2,[$APP.Q,A,kF,p],null))}c&&1!==p&&2!==p&&$D(jF,a,new $APP.f(null,2,[$APP.Q,$APP.u(b),kF,p],null));c=$APP.iBa.j($APP.Yu.j(n));v=zRa.j($APP.ed(b));$APP.vd(c)&&!$APP.vd(v)&&$D(ARa,a,new $APP.f(null,1,[BRa,n],null));null!=$APP.Ui.j($APP.Yu.j(n))&&$D(CRa,a,new $APP.f(null,1,[BRa,n],null));if(G||B){var fa=G?$APP.We.A(p,$APP.Pn.j($APP.Oj)):
null,ia=B?$APP.Oj.j("fexpr__"):null;c=function(){var ja=G?$APP.Lf.A($APP.sf,$APP.Uj.A(fa,g)):$APP.sf;return B?$APP.Vd.C(ja,ia,$APP.y([uRa(d)])):ja}();b=$APP.tj.j($APP.ed(b));b=$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(c)))),null,1,null),$APP.y([new $APP.D(null,$APP.z($APP.T.j($APP.r($APP.N.A(new $APP.D(null,uRa(B?ia:d),null,1,null),G?fa:g))),new $APP.f(null,1,[$APP.tj,b],null)),null,1,null)]))));return IE?IE(a,b):JE.call(null,a,
b)}c=$APP.Hl.A(function(ja){return IE?IE(l,ja):JE.call(null,l,ja)},g);if(d instanceof $APP.E&&null==$APP.ae(d)&&1===$APP.Tc(g)&&xRa($APP.tj.j($APP.u(c)),$APP.Zg.j($APP.Ag(d)))){b=$APP.Mn.A($APP.Zg.j([".-",$APP.Ag(d)].join("")),g);c=aE;aE=$APP.Bg($APP.ng(aE),$APP.Vj.j(!1));try{return IE?IE(a,b):JE.call(null,a,b)}finally{aE=c}}else return new $APP.f(null,6,[$APP.Xl,a,$APP.cy,DRa,$APP.Qw,b,$APP.Hk,n,$APP.Xj,c,HD,new $APP.H(null,2,5,$APP.I,[$APP.Hk,$APP.Xj],null)],null)};
IRa=function(a,b){if(FRa.j(a))return mOa(a,b),b=new $APP.f(null,5,[$APP.cy,$APP.Nw,$APP.X,b,$APP.Xl,a,$APP.Qw,b,$APP.tj,lF],null),mF.j?mF.j(b):mF.call(null,b);var c=$APP.ed(b),d=$APP.qe(c);c=$APP.C.A(d,$APP.Xi);d=$APP.C.A(d,$APP.Aj);a=null!=c?$APP.rg.B(a,$APP.Xi,c):a;var g=null!=d?$APP.rg.B(a,$APP.Aj,d):a,l=new $APP.f(null,2,[$APP.Xl,g,$APP.Qw,b],null);a=LD.j(g);a=vE(b,$APP.C.A(a,b));if(null==a){a=$APP.ed(b);var n=$APP.ae(b),p=$APP.m.j($APP.Q.j($APP.yl.j(g))),v=$APP.k(function(){if($APP.k(n)){var A=
$APP.qg.A(n,"cljs.core");return A?(A=$APP.Ja(p,"$macros"),$APP.k(A)?$APP.eb($APP.Ja(n,"$macros"))&&$APP.Uc.A(n,$APP.Og.B(p,0,p.length-7)):A):A}return n}())?$APP.Zg.A([n,"$macros"].join(""),$APP.Ag(b)):b,t=$APP.Bd(a,hF)?xE(g,v):APa(g,v);return nF(!0!==GRa.j(g)?$APP.Ni.C($APP.y([$APP.rg.B(l,$APP.Yu,t),$APP.sg(t,new $APP.H(null,4,5,$APP.I,[$APP.cy,$APP.Q,$APP.yl,$APP.tj],null)),function(){var A=HRa.j(t);return $APP.k(A)?new $APP.f(null,1,[HRa,A],null):null}()])):function(){var A=xE(g,v);return $APP.Ni.C($APP.y([$APP.rg.C(l,
$APP.cy,$APP.Gk,$APP.y([$APP.Yu,A])),$APP.sg(A,new $APP.H(null,4,5,$APP.I,[$APP.cy,$APP.Q,$APP.yl,$APP.tj],null))]))}())}return $APP.Ni.C($APP.y([$APP.rg.C(l,$APP.cy,$APP.Bl,$APP.y([$APP.Yu,a])),$APP.md(a)?$APP.sg(a,new $APP.H(null,5,5,$APP.I,[$APP.Q,$APP.Bl,dQa,$APP.tu,JD],null)):null]))};
KRa=function(a,b){var c=NOa(a,b,null);c=$APP.k(c)?c:MOa(a,b,null);b=null!=c?$APP.m.j(c):b;if("clojure.core"===b)return qD(TOa);if("clojure.repl"===b)return qD(JRa);if($APP.k($APP.La(b,".")))return qD($APP.Zg.j(b));a=null==a?null:$APP.yl.j(a);a=null==a?null:$APP.vn.j(a);a=null==a?null:$APP.C.A(a,$APP.Zg.j(b));return null==a?null:qD(a)};
LRa=function(a,b){var c;!(c=null!=PD(b,LD,a))&&(c=null!=QD(b,$APP.yl,mE,a)||null!=SD($APP.Fb(null),PD(b,$APP.yl,$APP.Q),mE,a))&&(c=!(null!=QD(b,$APP.yl,BE,a)||null!=SD($APP.Fb(null),PD(b,$APP.yl,$APP.Q),BE,a)));if(c)return null;c=$APP.ae(a);if(null!=c)return b=KRa(b,c),null!=b?nD(b,$APP.Zg.j($APP.Ag(a))):null;if(null!=QD(b,$APP.yl,DE,a))return a=QD(b,$APP.yl,DE,a),b=$APP.Zg.j($APP.ae(a)),a=$APP.Zg.j($APP.Ag(a)),nD(qD(b),a);b=QD(b,$APP.yl,BE,a);return null!=b&&b instanceof $APP.q?nD(qD(b),a):nD(qD(TOa),
a)};hE=function(a,b){a=LRa(a,b);if(b=null!=a)b=(a.val.J?a.val.J():a.val.call(null)).Nj;return b?a:null};PRa=function(a,b,c){if($APP.eb(MRa.j($APP.MD.j($APP.Fb(null))))){var d=null!=NNa(QNa)?$APP.Fb(NRa):null;if(null!=d)try{var g=$APP.w(b);d.A?d.A(c,g):d.call(null,c,g)}catch(l){throw b=l,$APP.Zi.B(null,cE(a,ORa,c.pc),b);}}};
QRa=function(a,b){a=a.pc;var c=$APP.am.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[RD,$APP.Zg.j($APP.ae(a)),lE,$APP.Zg.j($APP.Ag(a))],null));if($APP.k(c)){var d=$APP.qe(c);c=$APP.C.A(d,$APP.tu);var g=$APP.C.A(d,$APP.qw);d=$APP.C.A(d,$APP.wy);b=$APP.Tc($APP.Fc(b));var l=$APP.Uc.A($APP.Cha,$APP.Yc(d))?2:0;if($APP.k(yRa(b,$APP.Vg.A(function(n){return $APP.zba(n,l)},d),c,$APP.k(g)?g-l:null)))throw Error(oF.A(jF,new $APP.f(null,2,[kF,b,$APP.Q,a],null)));}};
URa=function(a,b){var c=$APP.u(b);if($APP.Bd(RPa,c))return $APP.Uc.A($APP.Th,c)&&PRa(a,b,hE(RRa,a)),b;var d=c instanceof $APP.q?hE(c,a):null;if(null==d){if(c instanceof $APP.q){c=$APP.m.j(c);if("."===c.charAt(0)){var g=$APP.w(b),l=$APP.r(g);g=$APP.u(l);l=$APP.w(l);return $APP.z($APP.Mn.K($APP.$h,g,$APP.Zg.j($APP.Og.A(c,1)),l),$APP.ed(b))}return"."===c.charAt(c.length-1)?$APP.z($APP.Mn.B($APP.Sh,$APP.Zg.j($APP.Og.B(c,0,c.length-1)),$APP.w(b)),$APP.ed(b)):b}return b}PRa(a,b,d);c=function(){try{return QRa(d,
b),$APP.Je.K($APP.Fb(d),b,a,$APP.Fc(b))}catch(p){var n=p;throw $APP.Zi.B(null,cE(a,SRa,d.pc),n);}}();return null!=c&&(c.O&64||$APP.xc===c.zd)&&(g=$APP.u(c),l=$APP.u(b),oD(g,$APP.Wh))?(g=null!=$APP.ae(l)?l:$APP.Zg.A("cljs.core",$APP.m.j(l)),g=new $APP.f(null,1,[fF,g],null),g=!0===function(){var n=$APP.Zg.j($APP.ae(d.pc)),p=$APP.Zg.j($APP.Ag(d.pc));return $APP.am.A($APP.Fb(null),new $APP.H(null,6,5,$APP.I,[RD,n,lE,p,$APP.h,TRa],null))}()?$APP.rg.B(g,eF,!0):g,$APP.Yj.B(c,$APP.Ni,g)):c};
WRa=function(a){switch(arguments.length){case 3:return pF(arguments[0],arguments[1],arguments[2]);case 4:return VRa(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};pF=function(a,b,c){return VRa(a,b,c,$APP.k(null)?$APP.MD.j($APP.Fb(null)):null)};
VRa=function(a,b,c,d){if(FRa.j(a))return XRa.A?XRa.A(a,b):XRa.call(null,a,b);var g=$APP.Xi.j($APP.ed(b));g=null==g?$APP.Xi.j(a):g;var l=$APP.Aj.j($APP.ed(b));l=null==l?$APP.Aj.j(a):l;a=$APP.rg.C(a,$APP.Xi,g,$APP.y([$APP.Aj,l]));g=$APP.u(b);if(null==g)throw gE(a,"Can't call nil");try{var n=URa(a,b)}catch(t){b=t;if($APP.Bd($APP.Ih(b),bE))throw b;if(wOa(b))throw $APP.Zi.B(null,cE(a,qF,null),b);throw $APP.Zi.B(null,cE(a,qF,null),fE(a,b.message,b));}if(b===n)try{if($APP.Bd(RPa,g))var p=rF.S(g,a,b,c,d);
else b:{c=NE;NE=$APP.Yd(null,NE);try{p=ERa(a,b);break b}finally{NE=c}p=void 0}var v=p}catch(t){b=t;if($APP.Bd($APP.Ih(b),bE))throw b;if(wOa(b))throw $APP.Zi.B(null,cE(a,qF,null),b);throw $APP.Zi.B(null,cE(a,qF,null),fE(a,b.message,b));}else v=YRa?YRa(a,n,c,d):JE.call(null,a,n,c,d);return v};
aSa=function(a,b){var c=$APP.rg.B(a,KE,$APP.Ck),d=function(){var l=NE;NE=$APP.Yd(null,NE);try{return $APP.Hl.A(function(n){return IE?IE(c,n):JE.call(null,c,n)},$APP.ng(b))}finally{NE=l}}(),g=function(){var l=NE;NE=$APP.Yd(null,NE);try{return $APP.Hl.A(function(n){return IE?IE(c,n):JE.call(null,c,n)},$APP.pg(b))}finally{NE=l}}();a=new $APP.f(null,7,[$APP.cy,$APP.oj,$APP.Xl,a,$APP.Qw,b,$APP.Bu,d,ZRa,g,HD,new $APP.H(null,2,5,$APP.I,[$APP.Bu,ZRa],null),$APP.tj,$Ra],null);return mF.j?mF.j(a):mF.call(null,
a)};XRa=function(a,b){var c=$APP.rg.B(a,KE,$APP.Ck),d=function(){var g=NE;NE=$APP.Yd(null,NE);try{return $APP.Hl.A(function(l){return IE?IE(c,l):JE.call(null,c,l)},b)}finally{NE=g}}();a=new $APP.f(null,6,[$APP.cy,$APP.mj,$APP.Xl,a,$APP.Qw,b,$APP.sF,d,HD,new $APP.H(null,1,5,$APP.I,[$APP.sF],null),$APP.tj,bSa],null);return mF.j?mF.j(a):mF.call(null,a)};
dSa=function(a,b){var c=$APP.rg.B(a,KE,$APP.Ck),d=function(){var g=NE;NE=$APP.Yd(null,NE);try{return $APP.Hl.A(function(l){return IE?IE(c,l):JE.call(null,c,l)},b)}finally{NE=g}}();a=new $APP.f(null,6,[$APP.cy,$APP.nj,$APP.Xl,a,$APP.Qw,b,$APP.sF,d,HD,new $APP.H(null,1,5,$APP.I,[$APP.sF],null),$APP.tj,cSa],null);return mF.j?mF.j(a):mF.call(null,a)};
fSa=function(a,b){var c=$APP.rg.B(a,KE,$APP.Ck),d=function(){var g=NE;NE=$APP.Yd(null,NE);try{return $APP.Hl.A(function(l){return IE?IE(c,l):JE.call(null,c,l)},b)}finally{NE=g}}();a=new $APP.f(null,6,[$APP.cy,$APP.uj,$APP.Xl,a,$APP.Qw,b,$APP.sF,d,HD,new $APP.H(null,1,5,$APP.I,[$APP.sF],null),$APP.tj,eSa],null);return mF.j?mF.j(a):mF.call(null,a)};
iSa=function(a,b){var c=b.val,d=$APP.rg.B(a,KE,$APP.Ck);if($APP.md(c)){var g=$APP.tf($APP.ng(c)),l=function(){var n=NE;NE=$APP.Yd(null,NE);try{return $APP.Hl.A(function(p){return IE?IE(d,p):JE.call(null,d,p)},$APP.pg(c))}finally{NE=n}}();return new $APP.f(null,7,[$APP.cy,gSa,$APP.Xl,a,$APP.Qw,b,$APP.Bu,g,ZRa,l,HD,new $APP.H(null,1,5,$APP.I,[ZRa],null),$APP.tj,$APP.dy],null)}g=function(){var n=NE;NE=$APP.Yd(null,NE);try{return $APP.Hl.A(function(p){return IE?IE(d,p):JE.call(null,d,p)},c)}finally{NE=
n}}();return new $APP.f(null,6,[$APP.cy,hSa,$APP.Xl,a,$APP.Qw,b,$APP.sF,g,HD,new $APP.H(null,1,5,$APP.I,[$APP.sF],null),$APP.tj,$APP.Sx],null)};
mF=function(a){var b=$APP.Qw.j(a),c=$APP.Oi.A($APP.Oi.C($APP.ed(b),$APP.Wi,$APP.y([$APP.Xi,$APP.Aj,$APP.Nr,$APP.Or,$APP.Mi])),hF);if(null!=$APP.r(c)){var d=$APP.Xl.j(a);a=$APP.cm(a,new $APP.H(null,2,5,$APP.I,[$APP.Xl,KE],null),$APP.Ck);c=aSa($APP.Xl.j(a),c);return new $APP.f(null,6,[$APP.cy,jSa,$APP.Xl,d,$APP.Qw,b,$APP.h,c,$APP.Ck,a,HD,new $APP.H(null,2,5,$APP.I,[$APP.h,$APP.Ck],null)],null)}return a};
kSa=function(a,b,c,d){if(b instanceof $APP.q)return IRa(a,b);if(null!=b&&(b.O&64||$APP.xc===b.zd)&&null!=$APP.r(b))return VRa(a,b,c,d);if($APP.nd(b)){c=NE;NE=$APP.Yd(null,NE);try{var g=$APP.rg.B(a,KE,$APP.Ck),l=$APP.Lf.A($APP.F,b);IE?IE(g,l):JE.call(null,g,l)}finally{NE=c}l=$APP.Vg.A($APP.Zg,$APP.qi.A($APP.jh.C($APP.y([$APP.hb(b)])),/\//));g=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);return new $APP.f(null,5,[$APP.cy,$APP.Nw,$APP.X,b,$APP.Xl,a,$APP.Qw,b,$APP.tj,$APP.Zg.A($APP.m.j(g),$APP.m.j(l))],null)}if(null!=
b&&(b.O&1024||$APP.xc===b.Mh))return aSa(a,b);if(null!=b&&(b.O&16384||$APP.xc===b.Lj))return dSa(a,b);if(BD(b))return fSa(a,b);if(b instanceof $APP.E)return mOa(a,b),new $APP.f(null,5,[$APP.cy,$APP.Nw,$APP.X,b,$APP.Xl,a,$APP.Qw,b,$APP.tj,iF],null);if(b instanceof $APP.afa)return iSa(a,b);g=null==b?pE:"number"===typeof b?$APP.$u:"string"===typeof b?$APP.Gy:!0===b?$APP.zv:!1===b?$APP.zv:$APP.Uc.A($APP.Ec,b)?bSa:null;a=new $APP.f(null,4,[$APP.cy,$APP.Nw,$APP.X,b,$APP.Xl,a,$APP.Qw,b],null);return $APP.k(g)?
$APP.rg.B(a,$APP.tj,g):a};mSa=function(a,b,c,d){var g=tF;g=null==g?lSa:g;b=b instanceof $APP.de?$APP.r(b)?b:$APP.Ec:b;c=kSa(a,b,c,d);return $APP.Id.B(function(l,n){return n.B?n.B(a,l,d):n.call(null,a,l,d)},c,g)};
JE=function(a){switch(arguments.length){case 2:return IE(arguments[0],arguments[1]);case 3:return nSa(arguments[0],arguments[1],arguments[2]);case 4:return YRa(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};IE=function(a,b){return nSa(a,b,null)};nSa=function(a,b,c){return YRa(a,b,c,$APP.k(null)?$APP.MD.j($APP.Fb(null)):null)};
YRa=function(a,b,c,d){try{if(vRa(b)){var g=aE;aE=$APP.Bg($APP.ng(aE),$APP.Vj.j(!1));try{return mSa(a,b,c,d)}finally{aE=g}}else return mSa(a,b,c,d)}catch(l){b=l;if($APP.Bd($APP.Ih(b),bE))throw b;if(wOa(b))throw $APP.Zi.B(null,cE(a,qF,null),b);throw $APP.Zi.B(null,cE(a,qF,null),fE(a,b.message,b));}};$APP.GEa=function(a,b){try{var c=EE;EE=!0;try{return wE(a,b,LOa(),!0)}finally{EE=c}}catch(d){return BPa(a,b)}};
pSa=function(a,b){a=$APP.k(b)?$APP.Jj.A(a,b+1):new $APP.H(null,1,5,$APP.I,[a],null);return $APP.Vg.A(function(c){return $APP.Lf.B($APP.sf,$APP.We.j(c),oSa)},a)};uF=function(a,b){this.n=a;this.d=b;this.O=4194304;this.U=2048};qSa=function(){throw Error("Fraction with zero denominator");};rSa=function(a,b){for(;;){if(b===vF)return a;var c=a%b;a=b;b=c}};wF=function(a){return Number(a.n)/Number(a.d)};
yF=function(a,b){vF===b&&qSa();var c=0>a?xF*a:a,d=0>b?xF*b:b,g=rSa(c,d);a=$APP.qg.A(0>a,0>b);c/=g;return new uF(a?xF*c:c,d/g)};sSa=function(a){var b=a.n,c=a.d;return 0>b?new uF(xF*b,c):a};tSa=function(a,b){var c=a.d,d=b.d;return yF(a.n*d+c*b.n,c*d)};uSa=function(a,b){var c=a.d,d=b.d;return yF(a.n*d-c*b.n,c*d)};vSa=function(a,b){return yF(a.n*b.n,a.d*b.d)};wSa=function(a,b){a=a.n*b.d-a.d*b.n;return 0>a?-1:0<a?1:0};
ySa=function(a,b){var c=a.n,d=a.d,g=BigInt(b);return $APP.Uc.A(b,vF)?xSa:$APP.Uc.A(b,zF)?a:g>vF?yF(c**g,d**g):yF(d**-g,c**-g)};AF=function(a){return zF===a.d?a.n:a};zSa=function(a,b){a=yF(a.n*b.d,a.d*b.n);0>a.n?(b=a.n,a=a.d,a=b/a+(0>b||b%a===vF?vF:zF)):(b=a.n,a=a.d,a=b/a-(0<b||b%a===vF?vF:zF));return a};ASa=function(a,b){return uSa(a,vSa(new uF(zSa(a,b),zF),b))};BSa=function(){};
BF=function(a){if(null!=a&&null!=a.nd)a=a.nd(a);else{var b=BF[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=BF._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("Numerical.numerical?",a);}return a};CSa=function(){};CF=function(){};DF=function(a){if(null!=a&&null!=a.rb)a=a.rb(a);else{var b=DF[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=DF._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IKind.kind",a);}return a};
EF=function(a){return $APP.Cba(a)||$APP.Uc.A("bigint",$APP.la(a))};FF=function(a){return"number"===typeof a||a instanceof $APP.za||a instanceof $APP.qa||$APP.Uc.A("bigint",$APP.la(a))||a instanceof uF};GF=function(a){var b="number"===typeof a;return b||(b=a instanceof $APP.za)||(b=a instanceof $APP.qa)||(b=$APP.Uc.A("bigint",$APP.la(a)))?b:(b=a instanceof uF)?b:null!=a?$APP.xc===a.bi?!0:a.$c?!1:$APP.gb(CSa,a):$APP.gb(CSa,a)};IF=function(a){return $APP.vh(DF(a),HF)};ESa=function(a,b){a[DSa]=b;return a};
FSa=function(a){var b=DF(a);return function(c){return $APP.vh(DF(c),b)}};
JF=function(a,b){if(a===b)return 0;if(null==a)return-1;if(null==b)return 1;if("number"===typeof a){var c=b.valueOf();if(FF(c))return $APP.Oa(a,c);throw Error(["Cannot compare ",$APP.m.j(a)," to ",$APP.m.j(b)].join(""));}if(null!=a?a.U&2048||$APP.xc===a.qc||(a.U?0:$APP.gb($APP.ic,a)):$APP.gb($APP.ic,a))return $APP.jc(a,b);if("string"!==typeof a&&!$APP.db(a)&&!0!==a&&!1!==a||$APP.hb(a)!==$APP.hb(b))throw Error(["Cannot compare ",$APP.m.j(a)," to ",$APP.m.j(b)].join(""));return $APP.Oa(a,b)};
HSa=function(a){return $APP.lh.B(GSa,$APP.Lf,a)};KF=function(a){return function(b,c){return Math.abs(b-c)<a}};ISa=function(a){var b=a-LF;return function(c){if(b<=c&&c<a)return c;c-=LF*Math.floor(c/LF);return c<a?c:c-LF}};NF=function(a){var b=GF(a);return b?MF.j(a):b};
JSa=function(a,b){var c=DF(a),d=$APP.Dh(OF,new $APP.H(null,2,5,$APP.I,[c,c],null));return $APP.k(d)?(c=function(g,l){var n=l;for(l=PF.j(g);;){var p=$APP.Ie(n);n=$APP.Pd(n,2);if(p)g=d.A?d.A(g,g):d.call(null,g,g);else{if($APP.k(MF.j(n)))return d.A?d.A(g,l):d.call(null,g,l);l=d.A?d.A(g,l):d.call(null,g,l);g=d.A?d.A(g,g):d.call(null,g,g)}}},0<b?c(a,b):$APP.k(MF.j(b))?PF.j(a):QF.j(c(a,RF.j(b)))):yD(["No g/mul implementation registered for kind ",$APP.m.j(c)].join(""))};
UF=function(a){var b=EF(a);return b?b:(b=$APP.Eba(a))?(b=Math.round(a),$APP.k(MF.j(b))?1E-20>Math.abs(a):Math.abs(SF.A(TF.A(a,b),b))<KSa):b};WF=function(a){var b=GF(a);return b?(b=VF.j(a),$APP.k(b)?MF.j(a):b):b};LSa=function(a,b){return XF.A(a,b)};YF=function(a,b,c){this.type=a;this.expression=b;this.ca=c;this.O=2149974016;this.U=2048};MSa=function(a,b,c){return new YF(a,b,c)};NSa=function(a,b){return MSa(a,b,null)};OSa=function(a,b,c){return NSa(a,$APP.Yd(b,$APP.r(c)))};
ZF=function(a){return a instanceof YF};PSa=function(a){return ZF(a)?a.type:null};QSa=function(a,b){var c=b.type,d=b.expression;a=a.j?a.j(d):a.call(null,d);return MSa(c,a,b.ca)};$F=function(a){return ZF(a)?a.expression:a};aG=function(a){for(;;){if(a instanceof $APP.q)return $APP.wg([a]);if(ZF(a))a=$F(a);else return a=$APP.Fc($APP.cf($APP.kd,$APP.r,a)),$APP.Lf.B($APP.vg,$APP.df.j($APP.zc),a)}};
RSa=function(a,b,c){return function l(g){if(g instanceof $APP.q)return b.A?b.A(g,g):b.call(null,g,g);if($APP.kd(g)){var n=$APP.r(g);g=$APP.u(n);n=$APP.w(n);var p=c.j?c.j(g):c.call(null,g);return $APP.k(p)?$APP.Je.A(p,$APP.Hl.A(l,n)):yD(["Missing fn for symbol - ",$APP.m.j(g)].join(""))}return g}($F(a))};SSa=function(a){return $APP.kd(a)?$APP.gi.A(bG,a):a};TSa=function(a){return $APP.jh.C($APP.y([cG.j(dG.j(a))]))};USa=function(a){return $APP.$A.j(cG.j(dG.j(a)))};
eG=function(a,b){this.ha=a;this.ia=b;this.O=2149580800;this.U=0};fG=function(a,b){return new eG(a,b)};gG=function(a){return["#emmy/complex ",$APP.m.j(new $APP.H(null,2,5,$APP.I,[a.ha,a.ia],null))].join("")};VSa=function(a,b){var c=a.ha,d=a.ia;return b instanceof eG?(a=hG.A(c,b.ha),$APP.k(a)?hG.A(d,b.ia):a):FF(b)?(a=MF.j(d),$APP.k(a)?hG.A(c,b):a):hG.A(a,b)};iG=function(a){var b=MF.j(a.ha);return $APP.k(b)?MF.j(a.ia):b};
WSa=function(a){var b=a.ha;a=a.ia;var c=jG.j(b);var d=jG.j(a);c=c>d?c:d;if($APP.k(MF.j(c)))return c;b=SF.A(b,c);a=SF.A(a,c);return kG.A(c,lG.j(mG.A(nG.j(b),nG.j(a))))};
ZSa=function(a){var b=$APP.Lg(XSa,a);if($APP.k(b)){$APP.x.B(b,0,null);var c=$APP.x.B(b,1,null),d=$APP.x.B(b,2,null),g=$APP.x.B(b,3,null);$APP.x.B(b,4,null);a=$APP.x.B(b,5,null);var l=$APP.x.B(b,6,null),n=$APP.x.B(b,7,null),p=$APP.x.B(b,8,null);return fG(function(){var v=$APP.k($APP.k(d)?d:g)?YNa:XNa;return v.j?v.j(c):v.call(null,c)}(),($APP.Uc.A(a,"-")?-1:1)*($APP.k(l)?function(){var v=$APP.k($APP.k(n)?n:p)?YNa:XNa;return v.j?v.j(l):v.call(null,l)}():0))}throw $APP.Zi.A("invalid complex number",new $APP.f(null,
1,[YSa,a],null));};$Sa=function(a,b){return fG(mG.A(a.ha,b.ha),mG.A(a.ia,b.ia))};aTa=function(a,b){return fG(TF.A(a.ha,b.ha),TF.A(a.ia,b.ia))};
dTa=function(a,b){if($APP.k(function(){var n=oG.j(a);n=$APP.k(n)?iG(b):n;if($APP.k(n))return n;n=iG(a);return $APP.k(n)?oG.j(b):n}()))return bTa;if($APP.k(function(){var n=oG.j(a);return $APP.k(n)?n:oG.j(b)}()))return cTa;var c=a.ha,d=a.ia,g=b.ha,l=b.ia;return $APP.k(function(){var n=MF.j(d);return $APP.k(n)?MF.j(l):n}())?kG.A(c,g):fG(TF.A(kG.A(c,g),kG.A(d,l)),mG.A(kG.A(c,l),kG.A(d,g)))};
fTa=function(a,b){if($APP.k(function(){var p=iG(a);p=$APP.k(p)?iG(b):p;if($APP.k(p))return p;p=oG.j(a);return $APP.k(p)?oG.j(b):p}()))return bTa;if($APP.k(function(){var p=oG.j(a);return $APP.k(p)?p:iG(b)}()))return cTa;if($APP.k(function(){var p=iG(a);return $APP.k(p)?p:oG.j(b)}()))return eTa;var c=a.ha,d=a.ia,g=b.ha,l=b.ia;if($APP.k(MF.j(l)))return fG(SF.A(c,g),SF.A(d,g));if(jG.j(g)<jG.j(l)){var n=SF.A(g,l);g=mG.A(kG.A(g,n),l);return fG(SF.A(mG.A(kG.A(c,n),d),g),SF.A(TF.A(kG.A(d,n),c),g))}n=SF.A(l,
g);g=mG.A(kG.A(l,n),g);return fG(SF.A(mG.A(c,kG.A(d,n)),g),SF.A(TF.A(d,kG.A(c,n)),g))};hTa=function(a,b){if($APP.k(MF.j(a)))a=$APP.k(MF.j(b.ia))?a:bTa;else{var c;if(c=$APP.Uc.A(pG,a))c=MF.j(b.ia),c=$APP.k(c)?EF(b.ha):c;a=$APP.k(c)?$APP.x.A(new $APP.H(null,4,5,$APP.I,[1,pG,-1,gTa],null),$APP.Od(b.ha,4)):qG.j(kG.A(b,rG.j(a)))}return a};
iTa=function(a){var b=a.ha,c=0<=b,d=a.ia,g=MF.j(d);if($APP.k($APP.k(g)?c:g))return fG(lG.j(b),0);g=jG.j(a);a=c?SF.A(lG.j(kG.A(2,mG.A(g,b))),2):SF.A(jG.j(d),lG.j(kG.A(2,TF.A(g,b))));b=c?SF.A(jG.j(d),lG.j(kG.A(2,mG.A(g,b)))):SF.A(lG.j(kG.A(2,TF.A(g,b))),2);return fG(a,$APP.k(sG.j(d))?RF.j(b):b)};jTa=function(a){return fG(rG.j(WSa(a)),tG.A(a.ia,a.ha))};
kTa=function(a){var b=a.ha;a=a.ia;var c=iTa(fG(TF.C(kG.A(a,a),kG.A(b,b),$APP.y([-1])),kG.C(-2,b,$APP.y([a]))));b=jTa(fG(TF.A(c.ha,a),mG.A(c.ia,b)));return fG(b.ia,RF.j(b.ha))};mTa=function(a){var b=a.ha;a=a.ia;var c=iTa(fG(TF.C(kG.A(a,a),kG.A(b,b),$APP.y([-1])),kG.C(-2,b,$APP.y([a]))));b=jTa(fG(TF.A(c.ha,a),mG.A(c.ia,b)));return fG(lTa-b.ia,b.ha)};
nTa=function(a){var b=a.ha,c=a.ia;if($APP.k(function(){var d=MF.j(b);return $APP.k(d)?uG.j(c):d}()))return fG(0,Infinity);if($APP.k(function(){var d=MF.j(b);return $APP.k(d)?uG.j(RF.j(c)):d}()))return fG(0,-Infinity);a=mG.A(kG.A(b,b),nG.j(TF.A(1,c)));a=jTa(fG(SF.A(TF.C(1,nG.j(c),$APP.y([nG.j(b)])),a),SF.A(kG.A(-2,b),a)));return fG(SF.A(a.ia,-2),SF.A(a.ha,2))};oTa=function(a){a=kTa(fG(a.ia,RF.j(a.ha)));return fG(RF.j(a.ia),a.ha)};
pTa=function(a){var b=mTa(a);a=b.ha;b=b.ia;return 0>b?fG(-b,a):fG(b,-a)};qTa=function(a){var b=a.ha;a=a.ia;var c=(c=1<b)?MF.j(a):c;var d=TF.A(1,b),g=mG.A(1,b),l=mG.A(nG.j(d),nG.j(a));b=$APP.k(MF.j(l))?fG(-1===b?0:SF.A(b,0),$APP.k(MF.j(a))?0:SF.A(a,0)):fG(SF.A(TF.A(kG.A(g,d),nG.j(a)),l),SF.A(mG.A(kG.A(a,d),kG.A(g,a)),l));return fG(SF.A(rG.j(WSa(b)),2),SF.A(tG.A(b.ia,b.ha),$APP.k(c)?-2:2))};rTa=function(a){return fG(PF.j(a.ha),vG.j(a.ia))};
sTa=function(a){return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,wG,null,1,null),new $APP.D(null,a,null,1,null))))};xG=function(a){return a instanceof eG};tTa=function(a){return xG(a)?yG.A($APP.Ca(Math.round(vD(a.ha))),$APP.Ca(Math.round(vD(a.ia)))):$APP.xd(a)?a:Math.round(vD(a))};uTa=function(a){return xG(a)?$APP.k(sG.j(a.ha))?RF.j(a):a:FF(a)?jG.j(a):yD("not supported!")};
vTa=function(a,b){if($APP.k(MF.j(a)))return b;if($APP.k(MF.j(b)))return a;if($APP.k(hG.A(a,b)))return uTa(a);var c=VF.j(a);c=$APP.k(c)?VF.j(b):c;if($APP.eb(c))return yD("gcd can only be computed for gaussian integers.");b=zG.j(a)>zG.j(b)?new $APP.H(null,2,5,$APP.I,[a,b],null):new $APP.H(null,2,5,$APP.I,[b,a],null);a=$APP.x.B(b,0,null);for(c=b=$APP.x.B(b,1,null);;){if($APP.k(MF.j(c)))return uTa(a);b=c;c=AG.A(a,OF.A(tTa(BG.A(a,c)),c));a=b}};
wTa=function(a,b){if($APP.k(MF.j(a)))return jG.j(b);var c;(c=$APP.k(MF.j(b)))||(c=hG.A(a,b),c=$APP.k(c)?c:hG.A(a,RF.j(b)),c=$APP.k(c));if(c)return jG.j(a);if(EF(a)&&EF(b))for(a=jG.j(a),c=jG.j(b);;){if($APP.k(MF.j(c)))return a;b=c;c=CG.A(a,c);a=b}else return 1};xTa=function(a){return a instanceof uF};yTa=function(){};
DG=function(a){if(null!=a&&null!=a.Lg)a=a.Lg(a);else{var b=DG[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=DG._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IRational.numerator",a);}return a};EG=function(a){if(null!=a&&null!=a.Kg)a=a.Kg(a);else{var b=EG[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=EG._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IRational.denominator",a);}return a};
zTa=function(a){a.F(null,new $APP.H(null,2,5,$APP.I,[uF,FG],null),function(b,c){b=wF(b);return a.A?a.A(b,c):a.call(null,b,c)});a.F(null,new $APP.H(null,2,5,$APP.I,[FG,uF],null),function(b,c){c=wF(c);return a.A?a.A(b,c):a.call(null,b,c)})};
ATa=function(a){a.F(null,new $APP.H(null,2,5,$APP.I,[uF,GG],null),function(b,c){c=new uF(BigInt(c),zF);return a.A?a.A(b,c):a.call(null,b,c)});a.F(null,new $APP.H(null,2,5,$APP.I,[GG,uF],null),function(b,c){b=new uF(BigInt(b),zF);return a.A?a.A(b,c):a.call(null,b,c)})};BTa=function(a,b){return $APP.k(hG.A(b,a))?PF.j(b):$APP.k(hG.A(b,RF.j(a)))?RF.j(PF.j(b)):$APP.k(uG.j(b))?a:$APP.k(uG.j(RF.j(b)))?RF.j(a):null};CTa=function(a,b){a=0>a?-a:a;for(b=0>b?-b:b;;){if(0==b)return a;var c=a%b;a=b;b=c}};
DTa=function(a,b){for(var c=$APP.Hs;;){var d=b.fd(1);if($APP.eb(b.Ve()))b=d,a=a.multiply(a);else{if($APP.k(d.Rb()))return a.multiply(c);b=d;c=a.multiply(c);a=a.multiply(a)}}};ETa=function(a,b){for(var c=$APP.Ha;;){var d=b.fd(1);if($APP.eb(b.Ve()))b=d,a=a.multiply(a);else{if($APP.k(d.Rb()))return a.multiply(c);b=d;c=a.multiply(c);a=a.multiply(a)}}};
FTa=function(a){return function(){function b(c){if(0<arguments.length)for(var d=0,g=Array(arguments.length-0);d<g.length;)g[d]=arguments[d+0],++d;return a}b.G=0;b.M=function(c){$APP.r(c);return a};b.C=function(){return a};return b}()};
OTa=function(a){var b=$APP.Lf.A($APP.sf,$APP.Pn.A(a+1,$APP.Oj)),c=$APP.gd(b),d=$APP.fd(b),g=$APP.Oj.J();return $APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.J()))),null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j($APP.Vj.A(a+1,0))))),null,1,null)))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,GTa,null,1,null))))),null,1,null),new $APP.D(null,
$APP.T.j($APP.r($APP.N.C(new $APP.D(null,HTa,null,1,null),new $APP.D(null,HG,null,1,null),$APP.y([new $APP.D(null,GTa,null,1,null)])))),null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,b,null,1,null),new $APP.D(null,g,null,1,null))))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j($APP.bf.C(function(l){return $APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,
ITa,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,HG,null,1,null),new $APP.D(null,l,null,1,null),$APP.y([new $APP.D(null,g,null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,g,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Rh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,JTa,null,1,null),new $APP.D(null,IG,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,KTa,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
LTa,null,1,null),new $APP.D(null,$APP.z(l,new $APP.f(null,1,[$APP.tj,$APP.py],null)),null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,LTa,null,1,null),new $APP.D(null,$APP.z(g,new $APP.f(null,1,[$APP.tj,$APP.py],null)),null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,$APP.Uu,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,KTa,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,MTa,null,1,null),new $APP.D(null,
NTa,null,1,null),$APP.y([new $APP.D(null,l,null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,MTa,null,1,null),new $APP.D(null,NTa,null,1,null),$APP.y([new $APP.D(null,g,null,1,null)])))),null,1,null)])))),null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,HG,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Jy,null,1,null),new $APP.D(null,l,null,1,null),$APP.y([new $APP.D(null,ITa,null,
1,null)])))),null,1,null),$APP.y([new $APP.D(null,g,null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,HG,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Jy,null,1,null),new $APP.D(null,g,null,1,null),$APP.y([new $APP.D(null,ITa,null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,l,null,1,null)])))),null,1,null)])))),null,1,null),new $APP.D(null,l,null,1,null),new $APP.D(null,ITa,null,1,null)])))))},$APP.y([c])))))),null,1,null),$APP.y([new $APP.D(null,
$APP.tf($APP.T.j($APP.r($APP.N.A(c,new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,HG,null,1,null),new $APP.D(null,d,null,1,null),$APP.y([new $APP.D(null,g,null,1,null)])))),null,1,null))))),null,1,null)])))),null,1,null)))),null,1,null)])))))};PTa=function(a,b){return $APP.k(b)?function(c,d){return $APP.k(b.j?b.j(c):b.call(null,c))?$APP.Mc(c):a.A?a.A(c,d):a.call(null,c,d)}:a};
QTa=function(a,b,c,d){return function(){function g(n,p){for(var v=$APP.Nd(0),t=$APP.Nd(0),A=$APP.bc($APP.sf);;){var B=$APP.x.B(n,v,null),G=$APP.x.B(p,t,null);if($APP.eb(B))return $APP.Lf.A($APP.dc(A),$APP.pi.A(p,t));if($APP.eb(G))return $APP.Lf.A($APP.dc(A),$APP.pi.A(n,v));var J=B,O=$APP.x.B(J,0,null);J=$APP.x.B(J,1,null);var R=G,W=$APP.x.B(R,0,null);R=$APP.x.B(R,1,null);W=a.A?a.A(O,W):a.call(null,O,W);$APP.k(c.j?c.j(W):c.call(null,W))?(B=b.A?b.A(J,R):b.call(null,J,R),v+=1,t+=1,A=$APP.k(c.j?c.j(B):
c.call(null,B))?A:$APP.mf.A(A,d.A?d.A(O,B):d.call(null,O,B))):0>W?(v+=1,A=$APP.mf.A(A,B)):(t+=1,A=$APP.mf.A(A,G))}}var l=null;l=function(n,p){switch(arguments.length){case 0:return $APP.sf;case 1:return n;case 2:return g.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.J=function(){return $APP.sf};l.j=function(n){return n};l.A=g;return l}()};
JG=function(a,b){const c=Array.prototype.slice.call(arguments),d=c.shift();if("undefined"==typeof d)throw Error("[goog.string.format] Template required");return d.replace(/%([0\- \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g,function(g,l,n,p,v,t,A,B){if("%"==t)return"%";const G=c.shift();if("undefined"==typeof G)throw Error("[goog.string.format] Not enough arguments");arguments[0]=G;return JG.ld[t].apply(null,arguments)})};RTa=function(a){return"string"===typeof a?$APP.Uc.A(a,"")?null:a:null};
STa=function(a){return"number"===typeof a?$APP.Nd(a):"string"===typeof a?(a=parseInt(a,10),$APP.k(isNaN(a))?null:a):null};TTa=function(a,b,c){return $APP.Xs.K($APP.Qt.j(2),$APP.Ws.j(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return a.B?a.B(d,l,g):a.call(null,d,l,g)}),b,c)};UTa=function(a){return function(b,c){b=a.j?a.j(c):a.call(null,c);return $APP.k(b)?$APP.Mc(b):null}};VTa=function(a,b){return $APP.Id.B(UTa(a),null,b)};
YTa=function(a){a=$APP.qi.B($APP.m.j(a),/-/,2);var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);b=$APP.Oca(/\d+/,b);b=$APP.k(b)?$APP.Hl.A(STa,b):null;return new $APP.f(null,2,[WTa,b,XTa,$APP.k(a)?$APP.mi(a):null],null)};ZTa=function(a){return 1<$APP.Tc(a)?$APP.pi.A(a,1):$APP.sf};KG=function(a){return Math.random()<=a};$Ta=function(a,b){this.n=a;this.Vg=b};aUa=function(a,b){this.n=a;this.oh=b};bUa=function(a,b,c){this.ca=a;this.ej=b;this.th=c};
cUa=function(a){if($APP.md(a))return $APP.Jd(function(c,d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return $APP.rg.B(c,d,new $Ta(l,g))},$APP.F,a);if($APP.od(a)){var b=$APP.Pe(-1);return $APP.Id.B(function(c,d){var g=$APP.x.B(d,0,null),l=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return $APP.rg.B(c,$APP.k(d)?d:b.mc(null,b.Wa(null)+1),new $Ta(g,l))},$APP.F,a)}throw $APP.Zi.A("[encore/cond!] No matching clause",$APP.F);};
kUa=function(a){function b(t,A){var B=(new Date).getTime();t=n.j?n.j(t):n.call(null,t);$APP.k(function(){var W=$APP.eb(A);return W?KG.j?KG.j(v):KG.call(null,v):W}())&&($APP.Ne(c,null),$APP.lh.A(d,function(W){return $APP.dc($APP.Jd(function(Z,fa,ia){ia=$APP.Jd(function(ja,ta,ua){var ca=$APP.C.A(g,ta);return $APP.k(ca)?B>=ua.oh+ca.Vg?$APP.Oi.A(ja,ta):ja:$APP.Oi.A(ja,ta)},ia,ia);return $APP.hd(ia)?$APP.tt.A(Z,fa):$APP.Nf.B(Z,fa,ia)},$APP.bc($APP.k(W)?W:$APP.F),W))}));for(;;){var G=$APP.Fb(d),J=$APP.C.A(G,
t),O=null==J?null:$APP.Jd(function(W,Z,fa,ia,ja,ta,ua){return function(ca,V,da){var Y=$APP.C.A(ua,V);if($APP.k(Y)){if(da.n<Y.n)return ca;da=da.oh+Y.Vg-fa;return 0>=da?ca:null==ca?new bUa($APP.pe([V,da]),V,da):da>ca.th?new bUa($APP.rg.B(ca.ca,V,da),V,da):new bUa($APP.rg.B(ca.ca,V,da),ca.ej,ca.th)}return ca}}(G,J,B,t,c,d,g,null,l,n,p,KG,v),null,J);if($APP.k($APP.k(A)?A:O)){var R=O;return $APP.k(R)?(t=R,new $APP.H(null,3,5,$APP.I,[t.ej,t.th,t.ca],null)):null}R=$APP.Fb(c);$APP.k(R)||(J=$APP.Jd(function(W,
Z,fa,ia,ja){return function(ta,ua,ca){var V=$APP.rg.B;var da=$APP.C.A(fa,ua);if($APP.k(da)){var Y=da.oh;ca=ja>=Y+ca.Vg?new aUa(1,ja):new aUa(da.n+1,Y)}else ca=new aUa(1,ja);return V.call($APP.rg,ta,ua,ca)}}(R,G,J,O,B,t,c,d,g,null,l,n,p,KG,v),J,g),$APP.Ne(d,$APP.rg.B(G,t,J)));return null}}if($APP.hd(a))return new $APP.H(null,2,5,$APP.I,[null,$APP.Le(null)],null);var c=$APP.kh.j(null),d=$APP.kh.j(null),g=cUa(a),l=$APP.qe(null),n=$APP.C.B(l,dUa,$APP.Kd),p=$APP.C.B(l,eUa,16E3),v=1/$APP.Nd(p);return new $APP.H(null,
2,5,$APP.I,[d,function(){function t(J,O){if($APP.k($APP.$d.A?$APP.$d.A(J,fUa):$APP.$d.call(null,J,fUa)))return $APP.k($APP.$d.A?$APP.$d.A(O,gUa):$APP.$d.call(null,O,gUa))?$APP.Ne(d,null):$APP.lh.B(d,$APP.Oi,n.j?n.j(O):n.call(null,O)),null;if($APP.k($APP.$d.A?$APP.$d.A(J,hUa):$APP.$d.call(null,J,hUa)))return b(O,!0);throw $APP.Zi.A("[encore/limiter*] Unexpected limiter command",new $APP.f(null,2,[iUa,new $APP.f(null,2,[$APP.iw,J,$APP.Ui,$APP.hb(J)],null),jUa,O],null));}function A(J){return b(J,!1)}
function B(){return b(null,!1)}var G=null;G=function(J,O){switch(arguments.length){case 0:return B.call(this);case 1:return A.call(this,J);case 2:return t.call(this,J,O)}throw Error("Invalid arity: "+arguments.length);};G.J=B;G.j=A;G.A=t;return G}()],null)};lUa=function(a){return void 0===a||null==a?"nil":a};LG=function(){return!0};MG=function(){return!1};NG=function(a){return $APP.qg.A(-1,a.indexOf("*"))?$APP.Pg($APP.ki($APP.ki(["^",$APP.m.j(a),"$"].join(""),".","\\."),"*","(.*)")):null};
OG=function(a,b){for(;;){if($APP.k(function(){var t=new $APP.ug(null,new $APP.f(null,2,["*",null,mUa,null],null),null);return t.j?t.j(a):t.call(null,a)}()))return LG;if($APP.k(function(){var t=$APP.wg([$APP.sf,$APP.vg,$APP.Ifa]);return t.j?t.j(a):t.call(null,a)}()))return MG;if(a instanceof RegExp)return function(t){return function(A){return $APP.Mg(t,A)}}(a,b,LG,MG,NG);if("string"===typeof a){var c=NG(a);if($APP.k(c)){var d=b;a=c;b=d}else return function(t){return function(A){return $APP.Uc.A(A,
t)}}(a,b,c,LG,MG,NG)}else if($APP.od(a)||$APP.jd(a)){if($APP.k(function(){var t=$APP.yg(a);return t.j?t.j("*"):t.call(null,"*")}()))return LG;if($APP.Uc.A($APP.Tc(a),1))c=$APP.u(a),d=b,a=c,b=d;else{var g=$APP.Id.B(function(t,A,B,G,J){return function(O,R){var W=$APP.x.B(O,0,null);O=$APP.x.B(O,1,null);var Z=R instanceof RegExp?R:J(R);return $APP.k(Z)?new $APP.H(null,2,5,$APP.I,[W,$APP.Vd.A(O,Z)],null):new $APP.H(null,2,5,$APP.I,[$APP.Vd.A(W,R),O],null)}}(a,b,LG,MG,NG),new $APP.H(null,2,5,$APP.I,[$APP.vg,
$APP.sf],null),a),l=$APP.x.B(g,0,null),n=$APP.x.B(g,1,null),p=$APP.re(l),v=function(){var t=$APP.re(n);return $APP.k(t)?(t=function(A,B,G,J,O,R,W,Z,fa,ia,ja){return function(ta){return VTa(function(){return function(ua){return $APP.Mg(ua,ta)}}(A,B,G,J,O,R,W,Z,fa,ia,ja),G)}}(a,b,t,t,g,l,n,p,LG,MG,NG),$APP.k(b)?$APP.mh(t):t):null}();if($APP.k(function(){var t=p;return $APP.k(t)?v:t}()))return function(t,A,B,G,J,O,R){return function(W){var Z=O.j?O.j(W):O.call(null,W);return $APP.k(Z)?Z:R.j?R.j(W):R.call(null,
W)}}(a,b,g,l,n,p,v,LG,MG,NG);if($APP.k(p))return p;if($APP.k(v))return v;throw $APP.Zi.A("[encore/cond!] No matching clause",$APP.F);}}else throw $APP.Zi.A("[enc/compile-str-filter] Unexpected spec type",new $APP.f(null,1,[nUa,new $APP.f(null,2,[$APP.iw,a,$APP.Ui,$APP.hb(a)],null)],null));}};
tUa=function(a){for(;;){if($APP.md(a)){var b=$APP.C.A(a,oUa),c=function(){var n=$APP.C.A(a,$APP.Xm);return $APP.k(n)?n:$APP.C.A(a,pUa)}(),d=function(){var n=$APP.C.A(a,$APP.zn);return $APP.k(n)?n:$APP.C.A(a,qUa)}(),g=function(){var n=c;return $APP.k(n)?OG(n,b):null}(),l=function(){var n=d;return $APP.k(n)?OG(n,b):null}();if($APP.Uc.A(l,LG)||$APP.Uc.A(g,MG))return MG;if($APP.k(function(){var n=g;return $APP.k(n)?l:n}()))return function(n,p,v,t,A,B){return function(G){G=$APP.m.j(G);return $APP.k(A.j?
A.j(G):A.call(null,G))?$APP.k(B.j?B.j(G):B.call(null,G))?!1:!0:!1}}(a,b,c,d,g,l,LG,MG,NG,OG);if($APP.k(g))return $APP.Uc.A(g,LG)?LG:function(n,p,v,t,A){return function(B){B=$APP.m.j(B);B=A.j?A.j(B):A.call(null,B);return $APP.k(B)?!0:!1}}(a,b,c,d,g,l,LG,MG,NG,OG);if($APP.k(l))return $APP.Uc.A(l,MG)?LG:function(n,p,v,t,A,B){return function(G){G=$APP.m.j(G);G=B.j?B.j(G):B.call(null,G);return $APP.k(G)?!1:!0}}(a,b,c,d,g,l,LG,MG,NG,OG);throw $APP.Zi.A("[encore/compile-str-filter] `allow-spec` and `deny-spec` cannot both be nil",
new $APP.f(null,2,[rUa,c,sUa,d],null));}a=new $APP.f(null,2,[$APP.Xm,a,$APP.zn,null],null)}};vUa=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=0<b.length?new $APP.Bc(b.slice(0),0,null):null;return uUa(b)};uUa=function(a){$APP.x.B(a,0,null);return new $APP.f(null,2,[wUa,!0,$APP.Hk,function(b){b=$APP.qe(b);b=$APP.C.A(b,xUa);return $APP.Yt.C($APP.y([$APP.dh(b)]))}],null)};
zUa=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=0<b.length?new $APP.Bc(b.slice(0),0,null):null;return yUa(b)};
yUa=function(a){$APP.x.B(a,0,null);return new $APP.f(null,2,[wUa,!0,$APP.Hk,"undefined"===typeof console?function(){return null}:function(){function b(c){var d=function(){var g=c instanceof $APP.E?c.ga:null;switch(g){case "trace":return console.trace;case "debug":return console.debug;case "info":return console.info;case "warn":return console.warn;case "error":return console.error;case "fatal":return console.error;case "report":return console.info;default:throw Error(["No matching clause: ",$APP.m.j(g)].join(""));
}}();return $APP.k(d)?d:console.log}return function(c){var d=b($APP.av.j(c));if($APP.k(d)){if($APP.k(function(){var n=$APP.C.A(c,AUa);return $APP.k(n)?n:$APP.am.A(c,new $APP.H(null,2,5,$APP.I,[BUa,AUa],null))}())){var g=function(){var n=$APP.rg.C(c,CUa,"",$APP.y([PG,null])),p=QG.j(c);return p.j?p.j(n):p.call(null,n)}(),l=function(){var n=RG.j(c),p=PG.j(c);return $APP.k(p)?$APP.Yd(g,$APP.Yd(p,n)):$APP.Yd(g,n)}();return d.apply(console,$APP.En.j(l))}return d.call(console,$APP.dh(xUa.j(c)))}return null}}()],
null)};DUa=function(a,b,c,d,g){a=new Date(a,b,c);g=g||0;return a.valueOf()+864E5*(((void 0!==d?d:3)-g+7)%7-((a.getDay()+6)%7-g+7)%7)};EUa=function(){};
GUa=function(a){if("number"==typeof a){var b=new EUa;b.Tf=a;var c=a;if(0==c)c="Etc/GMT";else{var d=["Etc/GMT",0>c?"-":"+"];c=Math.abs(c);d.push(Math.floor(c/60)%100);c%=60;0!=c&&d.push(":",lD(c,2));c=d.join("")}b.kh=c;c=a;0==c?c="UTC":(d=["UTC",0>c?"+":"-"],c=Math.abs(c),d.push(Math.floor(c/60)%100),c%=60,0!=c&&d.push(":",c),c=d.join(""));a=FUa(a);b.nh=[c,c];b.be={hl:a,xh:a};b.Vf=[];return b}b=new EUa;b.kh=a.id;b.Tf=-a.std_offset;b.nh=a.names;b.be=a.names_ext;b.Vf=a.transitions;return b};
FUa=function(a){var b=["GMT"];b.push(0>=a?"+":"-");a=Math.abs(a);b.push(lD(Math.floor(a/60)%100,2),":",lD(a%60,2));return b.join("")};SG=function(a,b){b=Date.UTC(b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate(),b.getUTCHours(),b.getUTCMinutes())/36E5;for(var c=0;c<a.Vf.length&&b>=a.Vf[c];)c+=2;return 0==c?0:a.Vf[c-1]};KUa=function(a){this.Kf=[];this.Ib=HUa;"number"==typeof a?IUa(this,a):JUa(this,a)};TG=function(a){return a.getHours?a.getHours():0};
JUa=function(a,b){for(LUa&&(b=b.replace(/\u200f/g,""));b;){const c=b;for(let d=0;d<MUa.length;++d){const g=b.match(MUa[d]);if(g){let l=g[0];b=b.substring(l.length);0==d&&("''"==l?l="'":(l=l.substring(1,"'"==g[1]?l.length-1:l.length),l=l.replace(/''/g,"'")));a.Kf.push({text:l,type:d});break}}if(c===b)throw Error("Malformed pattern part: "+b);}};
IUa=function(a,b){let c;if(4>b)c=a.Ib.uh[b];else if(8>b)c=a.Ib.yh[b-4];else if(12>b)c=a.Ib.gj[b-8],c=c.replace("{1}",a.Ib.uh[b-8]),c=c.replace("{0}",a.Ib.yh[b-8]);else{IUa(a,10);return}JUa(a,c)};UG=function(a,b){{b=String(b);const c=a.Ib||HUa;if(void 0!==c.yj){a=[];for(let d=0;d<b.length;d++){const g=b.charCodeAt(d);a.push(48<=g&&57>=g?String.fromCharCode(c.yj+g-48):b.charAt(d))}b=a.join("")}}return b};
VG=function(a){if(!(a.getHours&&a.getSeconds&&a.getMinutes))throw Error("The date to format has no time (probably a goog.date.Date). Use Date or goog.date.DateTime, or use a pattern without time fields.");};
NUa=function(a,b,c,d,g,l){var n=b.length;switch(b.charAt(0)){case "G":return c=0<d.getFullYear()?1:0,4<=n?a.Ib.ij[c]:a.Ib.jj[c];case "y":return c=d.getFullYear(),0>c&&(c=-c),2==n&&(c%=100),UG(a,lD(c,n));case "Y":return c=(new Date(DUa(d.getFullYear(),d.getMonth(),d.getDate(),a.Ib.wh,a.Ib.vh))).getFullYear(),0>c&&(c=-c),2==n&&(c%=100),UG(a,lD(c,n));case "M":a:switch(c=d.getMonth(),n){case 5:n=a.Ib.lj[c];break a;case 4:n=a.Ib.kj[c];break a;case 3:n=a.Ib.oj[c];break a;default:n=UG(a,lD(c+1,n))}return n;
case "k":return VG(g),UG(a,lD(TG(g)||24,n));case "S":return UG(a,(g.getMilliseconds()/1E3).toFixed(Math.min(3,n)).substr(2)+(3<n?lD(0,n-3):""));case "E":return c=d.getDay(),4<=n?a.Ib.xj[c]:a.Ib.qj[c];case "a":return VG(g),n=TG(g),a.Ib.fj[12<=n&&24>n?1:0];case "h":return VG(g),UG(a,lD(TG(g)%12||12,n));case "K":return VG(g),UG(a,lD(TG(g)%12,n));case "H":return VG(g),UG(a,lD(TG(g),n));case "c":a:switch(c=d.getDay(),n){case 5:n=a.Ib.tj[c];break a;case 4:n=a.Ib.wj[c];break a;case 3:n=a.Ib.vj[c];break a;
default:n=UG(a,lD(c,1))}return n;case "L":a:switch(c=d.getMonth(),n){case 5:n=a.Ib.sj[c];break a;case 4:n=a.Ib.rj[c];break a;case 3:n=a.Ib.uj[c];break a;default:n=UG(a,lD(c+1,n))}return n;case "Q":return c=Math.floor(d.getMonth()/3),4>n?a.Ib.pj[c]:a.Ib.mj[c];case "d":return UG(a,lD(d.getDate(),n));case "m":return VG(g),UG(a,lD(g.getMinutes(),n));case "s":return VG(g),UG(a,lD(g.getSeconds(),n));case "v":return n=l||GUa(c.getTimezoneOffset()),n.kh;case "V":return a=l||GUa(c.getTimezoneOffset()),2>=
n?a.kh:0<SG(a,c)?void 0!==a.be.hj?a.be.hj:a.be.DST_GENERIC_LOCATION:void 0!==a.be.xh?a.be.xh:a.be.STD_GENERIC_LOCATION;case "w":return c=DUa(g.getFullYear(),g.getMonth(),g.getDate(),a.Ib.wh,a.Ib.vh),UG(a,lD(Math.floor(Math.round((c-(new Date((new Date(c)).getFullYear(),0,1)).valueOf())/864E5)/7)+1,n));case "z":return a=l||GUa(c.getTimezoneOffset()),4>n?a.nh[0<SG(a,c)?2:0]:a.nh[0<SG(a,c)?3:1];case "Z":return b=l||GUa(c.getTimezoneOffset()),4>n?(n=-(b.Tf-SG(b,c)),a=[0>n?"-":"+"],n=Math.abs(n),a.push(lD(Math.floor(n/
60)%100,2),lD(n%60,2)),n=a.join("")):n=UG(a,FUa(b.Tf-SG(b,c))),n;default:return""}};OUa=function(a){switch(a instanceof $APP.E?a.ga:null){case "trace":return 0;case "debug":return 1;case "info":return 2;case "warn":return 3;case "error":return 4;case "fatal":return 5;case "report":return 6;default:return null}};
QUa=function(a){if($APP.k(OUa(a)))return a;throw $APP.Zi.A("Invalid Timbre logging level: should be e/o #{:trace :debug :info :warn :error :fatal :report}",new $APP.f(null,2,[PUa,a,$APP.Ui,$APP.hb(a)],null));};WG=function(a){var b=OUa(a);if($APP.k(b))return b;throw $APP.Zi.A("Invalid Timbre logging level: should be e/o #{:trace :debug :info :warn :error :fatal :report}",new $APP.f(null,2,[PUa,a,$APP.Ui,$APP.hb(a)],null));};
RUa=function(a,b){return(WG.j?WG.j(a):WG.call(null,a))>=(WG.j?WG.j(b):WG.call(null,b))};TUa=function(a,b){a=$APP.k($APP.cd.j?$APP.cd.j(a):$APP.cd.call(null,a))?a.j?a.j(b):a.call(null,b):SUa(a,b);return $APP.k(a)?!0:!1};VUa=function(a,b,c){b=$APP.od(b)?UUa(b,c):b;a=$APP.k(b)?b:a;return QUa.j?QUa.j(a):QUa.call(null,a)};WUa=function(a){if($APP.k(a)){var b=$APP.wg([$APP.sf,$APP.vg]);b=b.j?b.j(a):b.call(null,a);a=$APP.k(b)?null:a}else a=null;return a};
XUa=function(a,b){a=WUa(a);b=WUa(b);return $APP.k($APP.k(a)?a:b)?new $APP.f(null,2,[$APP.Xm,a,$APP.zn,b],null):null};
cVa=function(a,b,c,d){var g=$APP.k(d)?d:YUa;d=function(){var l=$APP.C.A(g,ZUa);l=$APP.k(l)?l:$APP.C.A(g,$APP.av);return VUa.B?VUa.B(a,l,c):VUa.call(null,a,l,c)}();return $APP.k(RUa.A?RUa.A(b,d):RUa.call(null,b,d))?(b=function(){var l=$APP.C.A(g,$Ua);if($APP.k(l))return l;l=$APP.C.A(g,aVa);var n=$APP.C.A(g,bVa);return XUa.A?XUa.A(l,n):XUa.call(null,l,n)}(),$APP.k(b)?$APP.k(TUa.A?TUa.A(b,c):TUa.call(null,b,c))?!0:!1:!0):!1};dVa=function(a){return null==a?"nil":"string"===typeof a?a:$APP.jh.C($APP.y([a]))};
iVa=function(a){var b=$APP.qe(a),c=$APP.C.A(b,eVa),d=$APP.C.A(b,fVa);a=$APP.C.A(b,RG);b=$APP.C.A(b,XG);b=$APP.qe(b);b=$APP.C.B(b,gVa,dVa);if($APP.Uc.A(null,c))return"";if($APP.Uc.A(YG,c))return d=$APP.Vg.j(b),$APP.k($APP.k(" ")?$APP.qg.A(" ",""):" ")?(c=$APP.Ri.j(" "),b=$APP.Ws.A(hVa,$APP.m),a=$APP.k(d)?$APP.Xs.B($APP.Jl.A(d,c),b,a):$APP.Xs.B(c,b,a)):a=$APP.k(d)?$APP.Xs.B(d,$APP.Ws.A(hVa,$APP.m),a):$APP.m.j($APP.Id.A(hVa,a)),a;if($APP.Uc.A($APP.Dy,c)){if("string"===typeof d)return null==d?a="":(a=
$APP.k(lUa)?$APP.Hl.A(lUa,a):a,a=$APP.Je.B(JG,d,a)),a;throw $APP.Zi.A("Timbre format-style logging call without a format pattern string",new $APP.f(null,3,[fVa,d,$APP.Ui,$APP.hb(d),RG,a],null));}throw Error(["No matching clause: ",$APP.m.j(c)].join(""));};
jVa=function(a){var b=$APP.$d.A?$APP.$d.A(ZG,ZG):$APP.$d.call(null,ZG,ZG),c=$APP.$d.A?$APP.$d.A(YG,$APP.Dy):$APP.$d.call(null,YG,$APP.Dy),d=$APP.x.B(a,0,null);if($APP.k($APP.k(b)?d instanceof Error:b)){var g=d,l=null,n=ZTa(a);a=$APP.k(c)?$APP.x.B(n,0,null):null;c=$APP.k(c)?ZTa(n):n;return new $APP.H(null,4,5,$APP.I,[g,l,a,c],null)}l=$APP.k(function(){var v=$APP.md(d);return v?$APP.h.j($APP.ed(d)):v}())?d:null;g=function(){var v=$APP.Px.j(l);return $APP.k(v)?v:$APP.k(b)?null:ZG}();var p=$APP.Oi.A(l,
$APP.Px);n=$APP.k(p)?ZTa(a):a;a=$APP.k(c)?$APP.x.B(n,0,null):null;c=$APP.k(c)?ZTa(n):n;return new $APP.H(null,4,5,$APP.I,[g,p,a,c],null)};oVa=function(a,b){return function(c){try{return b.j?b.j(c):b.call(null,c)}catch(v){var d=v,g=$APP.qe(c),l=$APP.C.A(g,$APP.av),n=$APP.C.A(g,kVa),p=$APP.C.A(g,lVa);g=$APP.C.A(g,mVa);throw $APP.Zi.B(a,new $APP.f(null,4,[$APP.av,l,$APP.oy,c,nVa,[$APP.m.j($APP.k(n)?n:$APP.k(p)?p:"?"),":",$APP.m.j($APP.k(g)?g:"?")].join(""),QG,b],null),d);}}};
bH=function(a,b,c,d,g){var l=YUa;if(cVa(pVa,a,b,l)){var n=new Date;d=$APP.Fb(d);d=jVa(d);var p=$APP.x.B(d,0,null),v=$APP.x.B(d,1,null),t=$APP.x.B(d,2,null);d=$APP.x.B(d,3,null);c=$APP.Vd.A($APP.k(null)?null:$APP.F,$APP.fg([qVa,rVa,sVa,RG,lVa,tVa,kVa,$APP.av,eVa,PG,KE,mVa,uVa,BUa,fVa],[n,null,l,d,null,function(){var W=new $APP.ug(null,new $APP.f(null,2,[vVa,null,$APP.hw,null],null),null);return W.j?W.j(a):W.call(null,a)}(),b,a,YG,p,null,c,new $APP.bh(function(){return p},null),v,t]));c=$APP.Id.B(function(W,
Z){W=Z.j?Z.j(W):Z.call(null,W);return null==W?$APP.Mc(null):W},c,$APP.C.A(l,wVa));if($APP.k(c)){n=$APP.qe(c);var A=$APP.C.A(n,RG),B=$APP.rg.B(c,xVa,new $APP.bh(function(){return A},null)),G=$G.C(B,CUa,new $APP.bh(function(){return oVa("Timbre error when calling (msg-fn \x3cdata\x3e)",iVa)(B)},null),$APP.y([yVa,new $APP.bh(function(){return $APP.yc(function(){var W=$APP.C.A(v,$APP.Yl);if($APP.k(W))return new $APP.H(null,3,5,$APP.I,[W,g,a],null);W=$APP.C.A(v,zVa);if($APP.k(W))return W;W=$APP.C.A(v,
AVa);return $APP.k(W)?new $APP.H(null,4,5,$APP.I,[W,g,t,a],null):new $APP.H(null,4,5,$APP.I,[A,g,t,a],null)}())},null)])),J=function(){var W=$APP.mh(function(fa){return new $APP.bh(function(){var ia=$APP.C.A(G,qVa),ja=$APP.qe(fa);ja=$APP.C.A(ja,BVa);return $APP.k($APP.$d.A?$APP.$d.A(ja,CVa):$APP.$d.call(null,ja,CVa))?(new Date(ia)).toISOString():(new KUa(ja)).format(ia)},null)}),Z=new $APP.bh(function(){return $APP.Vd.A(DVa,$APP.C.A(l,EVa))},null);return function(fa){var ia=(ia=null==fa)?ia:$APP.$d.A?
$APP.$d.A(fa,FVa):$APP.$d.call(null,fa,FVa);return $APP.k(ia)?W($APP.Fb(Z)):W($APP.Vd.A($APP.Fb(Z),fa))}}(),O=function(){var W=$APP.mh($APP.C.B(l,QG,aH));return function(Z){var fa=(fa=null==Z)?fa:$APP.$d.A?$APP.$d.A(Z,FVa):$APP.$d.call(null,Z,FVa);return oVa("Timbre error when calling (output-fn \x3cdata\x3e)",$APP.k(fa)?W:Z)}}(),R=$APP.C.A(l,XG);$APP.Jd(function(W,Z,fa){if($APP.k(function(){var da=$APP.C.A(fa,wUa);return $APP.k(da)?cVa(GVa,a,b,fa):da}())){var ia=$APP.C.A(fa,HVa);if(function(){var da=
$APP.hd(ia);if(da)return da;da=IVa(Z,ia);var Y=$APP.dh($APP.C.A(G,yVa));da=da.j?da.j(Y):da.call(null,Y);return $APP.eb(da)}()){var ja=$APP.qe(fa);W=$APP.C.A(ja,$APP.Hk);$APP.C.A(ja,JVa);var ta=J($APP.C.A(fa,EVa)),ua=O($APP.C.A(fa,QG)),ca=function(){var da=$APP.C.A(fa,XG);return $APP.k(da)?da:R}(),V=$APP.Vd.A(G,new $APP.f(null,6,[KVa,Z,LVa,fa,XG,ca,QG,ua,xUa,new $APP.bh(function(){var da=$APP.rg.C(G,MVa,ta,$APP.y([XG,ca]));return ua.j?ua.j(da):ua.call(null,da)},null),MVa,ta],null));ja=function(){var da=
$APP.C.A(fa,NVa);return $APP.k(da)?da.j?da.j(V):da.call(null,V):V}();return $APP.k(ja)?W.j?W.j(ja):W.call(null,ja):null}}return null},null,$APP.C.A(l,OVa))}}return null};cH=function(a){return function(b){return $APP.td(b)&&$APP.Uc.A($APP.u.j?$APP.u.j(b):$APP.u.call(null,b),a)}};PVa=function(a){var b=$APP.td(a);return b?(b=dH($APP.u.j?$APP.u.j(a):$APP.u.call(null,a)),$APP.k(b)?$APP.Uc.A(eH,$APP.Xc($APP.u.j?$APP.u.j(a):$APP.u.call(null,a))):b):b};
fH=function(a,b){var c=b instanceof $APP.q?function(d){return new $APP.D(null,b,new $APP.D(null,d,null,1,null),2,null)}:b;return function(d){if(GF(d)){var g=a.j?a.j(d):a.call(null,d);return $APP.eb(VF.j(d))?g:$APP.k(VF.j(g))?g:c.j?c.j(d):c.call(null,d)}return c.j?c.j(d):c.call(null,d)}};QVa=function(a,b,c,d){return GF(a)&&GF(b)?c.A?c.A(a,b):c.call(null,a,b):$APP.Uc.A(a,b)?0:$APP.k(MF.j(a))?0:$APP.k(uG.j(b))?a:new $APP.D(null,d,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)};
iH=function(a,b){return GF(a)&&GF(b)?gH.A(a,b):GF(a)?$APP.k(MF.j(a))?b:$APP.k(hH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):GF(b)?$APP.k(MF.j(b))?a:$APP.k(hH(a))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,
a),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.k(hH(a))?$APP.k(hH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a),$APP.y([new $APP.D(null,
b,null,1,null)])))):$APP.k(hH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))};
RVa=function(a,b){return GF(a)&&GF(b)?AG.A(a,b):GF(a)?$APP.k(MF.j(a))?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Jv,null,1,null),new $APP.D(null,b,null,1,null)))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Jv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):GF(b)?$APP.k(MF.j(b))?a:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Jv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.Uc.A(a,b)?0:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.Jv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))};SVa=function(a){return RVa(0,a)};
kH=function(a,b){return GF(a)&&GF(b)?OF.A(a,b):GF(a)?$APP.k(MF.j(a))?a:$APP.k(uG.j(a))?b:$APP.k(jH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):GF(b)?$APP.k(MF.j(b))?b:$APP.k(uG.j(b))?a:$APP.k(jH(a))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,
null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.k(jH(a))?$APP.k(jH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),$APP.Fc.j?$APP.Fc.j(a):
$APP.Fc.call(null,a),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.k(jH(b))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))};
lH=function(a,b){return GF(a)&&GF(b)?BG.A(a,b):GF(a)?$APP.k(MF.j(a))?a:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sj,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):GF(b)?$APP.k(MF.j(b))?AD("division by zero"):$APP.k(uG.j(b))?a:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sj,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sj,null,1,null),new $APP.D(null,a,null,1,null),
$APP.y([new $APP.D(null,b,null,1,null)]))))};TVa=function(a){return lH(1,a)};
WVa=function(a){return GF(a)?$APP.k(VF.j(a))?$APP.k(MF.j(a))?0:new $APP.D(null,mH,new $APP.D(null,a,null,1,null),2,null):UF(a/nH)?0:UF(1/(a-UVa-VVa))?1:UF((a+UVa)/VVa)?-1:Math.sin(a):a instanceof $APP.q?$APP.k((new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).call(null,a))?0:$APP.k((new $APP.ug(null,
new $APP.f(null,1,[sH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[sH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,1,[sH,null],null),null)).call(null,a))?1:$APP.k((new $APP.ug(null,new $APP.f(null,1,[tH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[tH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,1,[tH,null],null),null)).call(null,a))?-1:new $APP.D(null,mH,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,mH,new $APP.D(null,a,null,1,null),2,null)};
XVa=function(a){return GF(a)?$APP.k(VF.j(a))?$APP.k(MF.j(a))?1:new $APP.D(null,uH,new $APP.D(null,a,null,1,null),2,null):UF((a-UVa)/nH)?0:UF(a/VVa)?1:UF((a-nH)/VVa)?-1:Math.cos(a):a instanceof $APP.q?$APP.k((new $APP.ug(null,new $APP.f(null,2,[sH,null,tH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[sH,null,tH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[sH,null,tH,null],null),null)).call(null,a))?0:$APP.k((new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).j?
(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).call(null,a))?1:$APP.k((new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).call(null,a))?-1:new $APP.D(null,uH,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,uH,new $APP.D(null,a,null,1,null),2,null)};
YVa=function(a){return GF(a)?$APP.eb(VF.j(a))?vH.j(a):$APP.k(MF.j(a))?1:new $APP.D(null,wH,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,wH,new $APP.D(null,a,null,1,null),2,null)};ZVa=function(a){return GF(a)?$APP.eb(VF.j(a))?xH.j(a):$APP.k(MF.j(a))?0:new $APP.D(null,yH,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,yH,new $APP.D(null,a,null,1,null),2,null)};BH=function(a){return GF(a)?zH.j(a):kH(BG.A(1,2),iH(a,AH(a)))};
$Va=function(a){return GF(a)?CH.j(a):kH(BG.A(1,2),kH(yG.A(0,-1),RVa(a,AH(a))))};aWa=function(a,b){return GF(a)&&GF(b)?DH.A(a,b):FF(a)?kH(a,BH(b)):FF(b)?kH(BH(a),b):iH(kH(BH(a),BH(b)),kH($Va(a),$Va(b)))};
cWa=function(a){if($APP.k(bWa(a)))return a=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a)),new $APP.D(null,EH(eH,2),new $APP.D(null,a,null,1,null),2,null);if($APP.k(PVa(a))){var b=$APP.x.A($APP.u.j?$APP.u.j(a):$APP.u.call(null,a),2);a=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a));return new $APP.D(null,EH(eH,b+1),new $APP.D(null,a,null,1,null),2,null)}return new $APP.D(null,eH,new $APP.D(null,a,null,1,null),2,null)};
dWa=function(a,b){return!0===a?b:!1===a?a:!0===b?a:!1===b?b:$APP.Uc.A(a,b)?b:new $APP.D(null,$APP.ko,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)};eWa=function(a,b){var c=GF(a),d=GF(b);return c&&d?hG.A(a,b):c||d?!1:$APP.Uc.A(a,b)?!0:new $APP.D(null,$APP.bw,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)};fWa=function(a){return GF(a)?uG.j(a):new $APP.D(null,$APP.bw,new $APP.D(null,1,new $APP.D(null,a,null,1,null),2,null),3,null)};
FH=function(a){return gWa.j?gWa.j(a):gWa.call(null,a)};hWa=function(a){return function(b,c){return $APP.k(a.j?a.j(b):a.call(null,b))?$APP.k(a.j?a.j(c):a.call(null,c))?$APP.Ed(b,c):-1:$APP.k(a.j?a.j(c):a.call(null,c))?1:$APP.Ed(b,c)}};iWa=function(a,b,c){if(null!=a&&null!=a.zf)a=a.zf(a,b,c);else{var d=iWa[$APP.la(null==a?null:a)];if(null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else if(d=iWa._,null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else throw $APP.ib("ICanonicalize.-\x3eexpression",a);}return a};
jWa=function(a,b){if(null!=a&&null!=a.Le)a=a.Le(a,b);else{var c=jWa[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=jWa._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICanonicalize.known-operation?",a);}return a};lWa=function(a){return kWa.j(a)};GH=function(a){return mWa.j(a)};nWa=function(){};
HH=function(a,b,c){if(null!=a&&null!=a.ac)a=a.ac(a,b,c);else{var d=HH[$APP.la(null==a?null:a)];if(null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else if(d=HH._,null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else throw $APP.ib("IPerturbed.replace-tag",a);}return a};
IH=function(a,b,c){if(null!=a&&null!=a.$b)a=a.$b(a,b,c);else{var d=IH[$APP.la(null==a?null:a)];if(null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else if(d=IH._,null!=d)a=d.B?d.B(a,b,c):d.call(null,a,b,c);else throw $APP.ib("IPerturbed.extract-tangent",a);}return a};JH=function(a,b){if(null!=a&&null!=a.ic)a=a.ic(a,b);else{var c=JH[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=JH._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("IPerturbed.extract-id",a);}return a};
KH=function(a,b,c,d){this.Pc=a;this.R=b;this.N=c;this.P=d;this.O=2230716170;this.U=139264};oWa=function(a){return new KH(a,null,null,null)};LH=function(){return $APP.lh.A(pWa,$APP.Lc)};MH=function(a,b,c){this.tag=a;this.xc=b;this.ze=c;this.O=2149580800;this.U=2048};qWa=function(a,b,c){return new MH(a,b,c)};NH=function(a){return a instanceof MH};OH=function(a){return NH(a)?a.tag:null};QH=function(a,b,c){var d=PH;PH=$APP.Yd(a,PH);try{return $APP.Je.A(b,c)}finally{PH=d}};
rWa=function(a){return $APP.vd($APP.He($APP.wg([a]),PH))};sWa=function(a,b){return JF(RH.j(a),RH.j(b))};tWa=function(a){return function(b){var c=LH();b=SH.B(b,1,c);return IH(QH(c,a,new $APP.H(null,1,5,$APP.I,[b],null)),c,TH)}};uWa=function(){};UH=function(a){if(null!=a&&null!=a.bc)a=a.bc(a);else{var b=UH[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=UH._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IArity.arity",a);}return a};
WH=function(a){return $APP.vh(DF(a),VH)};XH=function(a){switch(arguments.length){case 2:return XH.A(arguments[0],arguments[1]);case 3:return XH.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};YH=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=0<b.length?new $APP.Bc(b.slice(0),0,null):null;return YH.C(b)};
$H=function(a){var b=$APP.ed(a);b=$APP.k(ZH.j(b))?b:$APP.rg.B(b,ZH,UH(a));a=$APP.mh(a);return ESa(a,b)};aI=function(a){switch(arguments.length){case 2:return aI.A(arguments[0],arguments[1]);case 3:return aI.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
bI=function(a){switch(arguments.length){case 2:return bI.A(arguments[0],arguments[1]);case 3:return bI.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
wWa=function(a){return XH.B(function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(d){return vG.j($APP.Je.A(a,d))}b.G=0;b.M=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}(),UH(a),new $APP.f(null,1,[cI,vWa],null))};
yWa=function(a){return XH.B(function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(d){return PF.j($APP.Je.A(a,d))}b.G=0;b.M=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}(),UH(a),new $APP.f(null,1,[cI,xWa],null))};
dI=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=1<b.length?new $APP.Bc(b.slice(1),0,null):null;return dI.C(arguments[0],b)};eI=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=1<b.length?new $APP.Bc(b.slice(1),0,null):null;return eI.C(arguments[0],b)};
zWa=function(a){var b=$APP.Pg(/invoke\$arity\$\d+/),c=$APP.Lf.A($APP.vg,$APP.un.A($APP.bb,$APP.N.A(new $APP.H(null,1,5,$APP.I,[a.G],null),$APP.Vg.A(function(d){d=$APP.Mg(b,d);return $APP.k(d)?parseInt($APP.Og.A(d,13)):null},$APP.Ma(a)))));return $APP.hd(c)?new $APP.H(null,1,5,$APP.I,[a.length],null):$APP.gi.j(c)};
fI=function(a){switch(arguments.length){case 0:return fI.J();case 1:return fI.j(arguments[0]);case 2:return fI.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};AWa=function(a){return $APP.Id.A(fI,a)};BWa=function(a){return $APP.Xs.B($APP.Vg.j(UH),fI,a)};gI=function(a,b){return IF(a)?XH.A($APP.Le(a),b):a};
CWa=function(a){return XH.A(function(b,c){var d=IF(b)?UH(c):UH(b),g=IF(c)?d:UH(c),l=gI(b,d),n=gI(c,g);b=AWa(new $APP.H(null,2,5,$APP.I,[d,g],null));return XH.A(function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=new $APP.Bc(B,0,null)}return v.call(this,A)}function v(t){var A=$APP.Je.A(l,t);t=$APP.Je.A(n,t);return a.A?a.A(A,t):a.call(null,A,t)}p.G=0;p.M=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}(),b)},new $APP.H(null,
2,5,$APP.I,[hI,2],null))};iI=function(a){var b=XH.A($APP.Pi.A($APP.Jl,a),new $APP.H(null,2,5,$APP.I,[hI,1],null));a.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(c){return b.j?b.j(c):b.call(null,c)})};kI=function(a){jI(a,a)};
jI=function(a,b){b=CWa(b);for(var c=$APP.r(new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[VH,VH],null),new $APP.H(null,2,5,$APP.I,[VH,lI],null),new $APP.H(null,2,5,$APP.I,[lI,VH],null)],null)),d=null,g=0,l=0;;)if(l<g){var n=d.aa(null,l);a.F(null,n,function(t,A,B,G,J,O){return function(R,W){return O.A?O.A(R,W):O.call(null,R,W)}}(c,d,g,l,n,b));l+=1}else{var p=$APP.r(c);if(p){var v=p;$APP.pd(v)?(c=$APP.lc(v),g=$APP.mc(v),d=c,v=$APP.Tc(c),c=g,g=v):(n=$APP.u(v),a.F(null,n,function(t,A,B,G,J,O,
R,W){return function(Z,fa){return W.A?W.A(Z,fa):W.call(null,Z,fa)}}(c,d,g,l,n,v,p,b)),c=$APP.w(v),d=null,g=0);l=0}else break}};
DWa=function(a,b,c){return XH.A(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){if(rWa(b)){var n=LH();return HH(IH(QH(b,a,$APP.Vg.A(function(p){return HH(p,b,n)},l)),b,c),n,b)}return IH(QH(b,a,l),b,c)}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),UH(a))};
EWa=function(a,b,c){return XH.A(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){if(rWa(b)){var n=LH();l=$APP.Vg.A(function(p){return HH(p,b,n)},l);return HH(HH($APP.Je.A(a,l),b,c),n,b)}return HH($APP.Je.A(a,l),b,c)}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),UH(a))};
FWa=function(a,b,c){return $APP.Id.B(function(d,g){var l=$APP.Ab(g),n=$APP.Bb(g);g=$APP.rg.B;var p=$APP.C.B(d,l,0);n=a.A?a.A(p,n):a.call(null,p,n);return g.call($APP.rg,d,l,n)},b,$APP.r(c))};mI=function(a,b){this.i=a;this.ca=b;this.O=2149580800;this.U=0};GWa=function(a,b){return new mI(a,b)};HWa=function(a){return a instanceof mI};IWa=function(a){return a.ca};oI=function(a,b){if(HWa(b)){var c=$APP.Uc.A(a.ca,b.ca);return c?hG.A(a.i,b.i):c}return GF(b)?hG.A(a.i,nI.A(b,a.ca)):!1};
pI=function(a,b){return GWa(nI.A(a,b),b)};qI=function(a){return function(b,c){if($APP.Uc.A(b.ca,c.ca)){var d=b.i;c=c.i;d=a.A?a.A(d,c):a.call(null,d,c);b=pI(d,b.ca)}else b=AD("unequal moduli");return b}};rI=function(a){return JWa(a.i,a.ca)};
JWa=function(a,b){a:if($APP.k(MF.j(a)))var c=new $APP.H(null,3,5,$APP.I,[jG.j(b),0,1],null);else if($APP.k(MF.j(b)))c=new $APP.H(null,3,5,$APP.I,[jG.j(a),1,0],null);else{c=0;for(var d=1,g=1,l=0,n=jG.j(b),p=jG.j(a);;){if($APP.k(MF.j(n))){c=new $APP.H(null,3,5,$APP.I,[p,d,l],null);break a}var v=sI.A(p,n);d=TF.A(d,kG.A(v,c));var t=c;l=TF.A(l,kG.A(v,g));var A=g;p=TF.A(p,kG.A(v,n));v=n;c=d;d=t;g=l;l=A;n=p;p=v}}g=$APP.x.B(c,0,null);n=$APP.x.B(c,1,null);$APP.x.B(c,2,null);return 2>g?pI(n,b):AD([$APP.m.j(a),
" is not invertible mod ",$APP.m.j(b)].join(""))};KWa=function(a,b,c){return GWa(Number(nI.A(tI.A(BigInt(a),BigInt(b)),c)),c)};LWa=function(a){return $APP.Jd(function(b,c,d){return 0===d?b:$APP.rg.B(b,c,d)},uI,a)};MWa=function(a,b){return $APP.Jd(function(c,d,g){return d>b?$APP.rg.B(c,d-1,g):$APP.rg.B(c,d,g)},uI,$APP.Oi.A(a,b))};NWa=function(a,b,c){a=$APP.Jd(function(d,g,l){return g>=b?$APP.rg.B(d,g+1,l):$APP.rg.B(d,g,l)},uI,a);return 0===c?a:$APP.rg.B(a,b,c)};
vI=function(a){return $APP.Je.A($APP.yr,$APP.pg(a))};wI=function(a,b){return a.A?a.A(b,0):a.call(null,b,0)};
OWa=function(a){var b=$APP.Jj.j($APP.Tc(a)),c=$APP.Lf.A($APP.sf,$APP.Vs.A(a,$APP.ng(a)));return new $APP.H(null,2,5,$APP.I,[function(d){return $APP.Lf.B(uI,$APP.bf.j(function(g){var l=c.j?c.j(g):c.call(null,g);l=d.j?d.j(l):d.call(null,l);return $APP.k(l)?new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[g,l],null)],null):null}),b)},function(d){return $APP.Lf.B(uI,$APP.bf.j(function(g){var l=d.j?d.j(g):d.call(null,g);return $APP.k(l)?new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[c.j?
c.j(g):c.call(null,g),l],null)],null):null}),b)}],null)};QWa=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=2<b.length?new $APP.Bc(b.slice(2),0,null):null;return PWa(arguments[0],arguments[1],b)};
PWa=function(a,b,c){c=$APP.qe(c);c=$APP.C.A(c,RWa);a=$APP.tf($APP.k(c)?$APP.Qb(a):a);b=$APP.tf($APP.k(c)?$APP.Qb(b):b);for(var d=$APP.Nd(0);;){var g=$APP.x.B(a,d,null),l=$APP.x.B(b,d,null);if($APP.eb(g)&&$APP.eb(l))return 0;if($APP.eb(g))return-1;if($APP.eb(l))return 1;var n=$APP.Ed($APP.x.A(g,0),$APP.x.A(l,0));if(0===n)if(g=$APP.x.A(g,1),l=$APP.x.A(l,1),$APP.Uc.A(g,l))d+=1;else return $APP.k(c)?l-g:g-l;else return 0>n?1:-1}};
SWa=function(a,b){var c=vI(a),d=vI(b);return $APP.Uc.A(c,d)?QWa(a,b):c-d};xI=function(a){return $APP.x.B(a,0,uI)};yI=function(a){return $APP.x.B(a,1,0)};TWa=function(a){var b=xI(a);a=yI(a);return[$APP.jh.C($APP.y([a])),"*",$APP.jh.C($APP.y([b]))].join("")};UWa=function(a){return $APP.k(MF.j(a))?$APP.sf:new $APP.H(null,1,5,$APP.I,[zI.A(uI,a)],null)};
VWa=function(a){var b=$APP.Jl.A($APP.ip.j(function(c,d){if($APP.k(MF.j(d)))return null;c=0===c?uI:AI.A?AI.A(0,c):AI.call(null,0,c);return new $APP.H(null,1,5,$APP.I,[zI.A(c,d)],null)}),$APP.eh);return $APP.Lf.B($APP.sf,b,a)};
WWa=function(a){return $APP.hd(a)?$APP.sf:$APP.Lf.A($APP.sf,$APP.Vs.B(xI,SWa,function(){return function d(c){return new $APP.de(null,function(){for(var g=c;;)if(g=$APP.r(g)){if($APP.pd(g)){var l=$APP.lc(g),n=$APP.Tc(l),p=$APP.fe(n);a:for(var v=0;;)if(v<n){var t=$APP.bd(l,v),A=$APP.x.B(t,0,null);t=$APP.x.B(t,1,null);t=$APP.Xs.B($APP.Vg.j(yI),mG,t);$APP.eb(MF.j(t))&&(A=$APP.od(A)?LWa(A):$APP.ld(A)?A:$APP.md(A)?$APP.Lf.A(uI,A):yD("Invalid inputs to sparse-\x3eterms TODO"),$APP.je(p,zI.A(A,t)));v+=1}else{l=
!0;break a}return l?$APP.ie($APP.ke(p),d($APP.mc(g))):$APP.ie($APP.ke(p),null)}l=$APP.u(g);p=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);l=$APP.Xs.B($APP.Vg.j(yI),mG,l);if($APP.eb(MF.j(l)))return p=$APP.od(p)?LWa(p):$APP.ld(p)?p:$APP.md(p)?$APP.Lf.A(uI,p):yD("Invalid inputs to sparse-\x3eterms TODO"),$APP.Yd(zI.A(p,l),d($APP.Fc(g)));g=$APP.Fc(g)}else return null},null,null)}($APP.oh(xI,a))}()))};
XWa=function(a,b){return $APP.Lf.A($APP.sf,function(){return function g(d){return new $APP.de(null,function(){for(var l=d;;)if(l=$APP.r(l)){if($APP.pd(l)){var n=$APP.lc(l),p=$APP.Tc(n),v=$APP.fe(p);a:for(var t=0;;)if(t<p){var A=$APP.bd(n,t),B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);A=a.j?a.j(A):a.call(null,A);$APP.eb(MF.j(A))&&$APP.je(v,zI.A(B,A));t+=1}else{n=!0;break a}return n?$APP.ie($APP.ke(v),g($APP.mc(l))):$APP.ie($APP.ke(v),null)}n=$APP.u(l);v=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);n=a.j?
a.j(n):a.call(null,n);if($APP.eb(MF.j(n)))return $APP.Yd(zI.A(v,n),g($APP.Fc(l)));l=$APP.Fc(l)}else return null},null,null)}(b)}())};ZWa=function(a,b){return YWa(a,XWa(RF,b))};$Wa=function(a,b){var c=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);for(var d=$APP.bc($APP.sf),g=0;;){var l=$APP.x.B(b,g,null);if(null==l)return $APP.dc(d);var n=l;l=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);d=$APP.mf.A(d,zI.A($APP.Qo.C($APP.yr,$APP.y([c,l])),OF.A(a,n)));g+=1}};
aXa=function(a,b){return function g(d){var l=$APP.x.B(a,d,null);return null==l?$APP.sf:YWa($Wa(l,b),g(d+1))}(0)};
bXa=function(a,b){var c=$APP.fd(b),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);for(var g=$APP.sf;;){if($APP.hd(a))return new $APP.H(null,2,5,$APP.I,[g,a],null);var l=$APP.fd(a),n=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);n=LWa($APP.Qo.C($APP.yr,$APP.y([n,sD($APP.Ek,d)])));if($APP.Ge($APP.Lba,$APP.pg(n)))l=BG.A(l,c),n=zI.A(n,l),g=YWa(g,new $APP.H(null,1,5,$APP.I,[n],null)),a=ZWa(a,$Wa(n,b));else return new $APP.H(null,2,5,$APP.I,[g,a],null)}};
cXa=function(a,b){var c=$APP.tf(a),d=$APP.Tc(c);return $APP.Xs.B($APP.ip.j(function(g,l){var n=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);var p=function(){return function B(A){return new $APP.de(null,function(){for(var G=A;;)if(G=$APP.r(G)){if($APP.pd(G)){var J=$APP.lc(G),O=$APP.Tc(J),R=$APP.fe(O);a:for(var W=0;;)if(W<O){var Z=$APP.bd(J,W);$APP.qg.A(g,Z)&&$APP.je(R,$APP.am.A(c,new $APP.H(null,2,5,$APP.I,[Z,0],null)));W+=1}else{J=!0;break a}return J?$APP.ie($APP.ke(R),B($APP.mc(G))):$APP.ie($APP.ke(R),
null)}R=$APP.u(G);if($APP.qg.A(g,R))return $APP.Yd($APP.am.A(c,new $APP.H(null,2,5,$APP.I,[R,0],null)),B($APP.Fc(G)));G=$APP.Fc(G)}else return null},null,null)}($APP.Jj.j(d))}(),v=$APP.Je.A(kG,$APP.Vg.A(function(t){return TF.A(b,t)},p));p=$APP.Je.A(kG,$APP.Vg.A(function(t){return TF.A(n,t)},p));return kG.C(QF.j(p),l,$APP.y([v]))}),mG,c)};dXa=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,3,5,$APP.I,[b,b,a],null)};
eXa=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);var g=$APP.x.B(b,2,null);$APP.x.B(c,0,null);b=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);c=SF.A(mG.A(kG.A(TF.A(a,b),g),kG.A(TF.A(d,a),c)),TF.A(d,b));return new $APP.H(null,3,5,$APP.I,[d,b,c],null)}};fXa=function(a){return function(b){return $APP.Vg.B(eXa(a),b,$APP.Fc(b))}};BI=function(a){return $APP.Vg.A($APP.u,a)};
CI=function(a,b,c){return $APP.Hg.A($APP.r,$APP.af(function(d){return $APP.Vg.B(b,d,$APP.Fc(d))},$APP.Vg.A(a,c)))};gXa=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);$APP.x.B(c,0,null);var g=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);return new $APP.H(null,3,5,$APP.I,[d,g,((a-g)*b+(d-a)*c)/(d-g)],null)}};hXa=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,4,5,$APP.I,[b,b,a,a],null)};
iXa=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);$APP.x.B(b,2,null);var g=$APP.x.B(b,3,null);$APP.x.B(c,0,null);b=$APP.x.B(c,1,null);var l=$APP.x.B(c,2,null);$APP.x.B(c,3,null);c=(l-g)/(d-b);return new $APP.H(null,4,5,$APP.I,[d,b,c*(d-a),c*(b-a)],null)}};jXa=function(a){return DI.j($APP.Vg.A(function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);var c=$APP.x.B(b,2,null);$APP.x.B(b,3,null);return c},a))};
EI=function(a,b,c){return function(){function d(n,p){return $APP.Ut.B(b,a.j?a.j(p):a.call(null,p),n)}function g(n){return c.j?c.j(n):c.call(null,n)}var l=null;l=function(n,p){switch(arguments.length){case 0:return $APP.sf;case 1:return g.call(this,n);case 2:return d.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.J=function(){return $APP.sf};l.j=g;l.A=d;return l}()};kXa=function(a){return EI(dXa,gXa(a),function(b){return $APP.fd($APP.$c(b))})};
lXa=function(a){return $APP.Xs.B($APP.Vg.j(function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);var c=$APP.x.B(b,2,null);$APP.x.B(b,3,null);return c}),FI,a)};mXa=function(a){return EI(hXa,iXa(a),lXa)};nXa=function(a){return GI.j(mXa(a))};oXa=function(a){return $APP.Cba(a)?BigInt(a):a};HI=function(a){var b=$APP.Jj.A(1,a+1);return 19>a?$APP.Je.A($APP.Ys,b):$APP.Xs.B($APP.Vg.j(uD),kG,b)};pXa=function(a,b){a=$APP.Jj.B(a,0,-b);return $APP.Xs.B($APP.Vg.j(uD),kG,a)};
qXa=function(a,b){var c=$APP.kh.j(null);$APP.Ne(c,$APP.mh(function(g,l){if($APP.Uc.A(l,1)||$APP.Uc.A(g,l))return 1;var n=g-1;g=function(){var v=$APP.Fb(c);v=v.A?v.A(n,l):v.call(null,n,l);v=BigInt(v);return kG.A?kG.A(l,v):kG.call(null,l,v)}();var p=function(){var v=l-1,t=$APP.Fb(c);return t.A?t.A(n,v):t.call(null,n,v)}();return mG.A?mG.A(g,p):mG.call(null,g,p)}));if(0===b)return 0===a?1:0;if(b>a)return 0;var d=$APP.Fb(c);return d.A?d.A(a,b):d.call(null,a,b)};
rXa=function(a){var b=$APP.Vg.j(function(d){return qXa(a,d)}),c=$APP.Jj.j(a+1);return $APP.Xs.B(b,mG,c)};II=function(a){return $APP.N.A(new $APP.de(null,function(){return a},null,null),new $APP.de(null,function(){return $APP.Vj.j(vG.j($APP.u(a)))},null,null))};sXa=function(a,b){return $APP.Vg.B(mG,a,b)};tXa=function(a,b){return new $APP.de(null,function(){return $APP.Yd(mG.A(a,$APP.u(b)),$APP.Fc(b))},null,null)};
uXa=function(a,b){return new $APP.de(null,function(){return $APP.Yd(mG.A($APP.u(a),b),$APP.Fc(a))},null,null)};vXa=function(a,b){return $APP.Vg.B(TF,a,b)};wXa=function(a,b){return new $APP.de(null,function(){return $APP.Yd(TF.A($APP.u(a),b),$APP.Fc(a))},null,null)};JI=function(a,b){return new $APP.de(null,function(){return $APP.Yd(TF.A(a,$APP.u(b)),$APP.Vg.A(RF,$APP.Fc(b)))},null,null)};xXa=function(a,b){return $APP.Vg.A(function(c){return OF.A(c,b)},a)};
KI=function(a,b){return $APP.Vg.A(function(c){return OF.A(a,c)},b)};yXa=function(a,b){return $APP.Vg.A(function(c){return SF.A(c,b)},a)};MI=function(a,b){return function g(d){return new $APP.de(null,function(){var l=$APP.r(d),n=$APP.u(l);l=$APP.w(l);var p=$APP.Fc(b);l=LI(p,g(l));return $APP.Yd(n,l)},null,null)}(a)};zXa=function(a){return function d(c){return new $APP.de(null,function(){var g=$APP.Fc(c),l=d(c);return $APP.Yd(0,NI(MI(g,l)))},null,null)}(a)};
OI=function(a,b){return $APP.Yd(b,$APP.Vg.B(BG,a,$APP.af($APP.Lc,1)))};AXa=function(a,b){function c(d,g){for(var l=II(new $APP.H(null,1,5,$APP.I,[1],null));;){var n=$APP.Ie(g);g=$APP.Pd(g,2);if(n)d=LI(d,d);else{if(0===g)return LI(d,l);l=LI(d,l);d=LI(d,d)}}}return 0<b?c(a,b):0===b?II(new $APP.H(null,1,5,$APP.I,[1],null)):NI(c(a,RF.j(b)))};PI=function(a,b){this.xs=a;this.ca=b;this.O=2173042689;this.U=0};QI=function(a,b){return new PI(a,b)};
RI=function(a,b){this.xs=a;this.ca=b;this.O=2173042689;this.U=0};SI=function(a,b){return new RI(a,b)};BXa=function(a){return a instanceof PI||a instanceof RI};TI=function(a){return a instanceof RI};CXa=function(a){switch(a instanceof $APP.E?a.ga:null){case "emmy.series/series":return QI;case "emmy.series/power-series":return SI;default:return yD(["Unsupported kind: ",$APP.m.j(a)].join(""))}};UI=function(a){return QI(II(a),null)};VI=function(a){return SI(II(a),null)};
DXa=function(a){return TI(a)?a:BXa(a)?SI($APP.r(a),$APP.ed(a)):yD("non-series provided to -\x3efunction.")};EXa=function(a,b){var c=PF.j(b);return $APP.Vg.B(kG,a,$APP.af(function(d){return kG.A(b,d)},c))};WI=function(a,b){return function g(d){var l=$APP.Je.A($APP.u(d),b);return BXa(l)?new $APP.de(null,function(){var n=$APP.r(l),p=$APP.u(n);n=$APP.w(n);return $APP.Yd(p,sXa(n,g($APP.Fc(d))))},null,null):$APP.Yd(l,new $APP.de(null,function(){return g($APP.Fc(d))},null,null))}($APP.r(a))};
XI=function(a,b){a=$APP.Vg.A(a,b);var c=$APP.ed(b);b=TI(b)?SI:QI;return b.A?b.A(a,c):b.call(null,a,c)};FXa=function(a,b){if(1>=b)return a;var c=vG.j($APP.u(a));b=$APP.Vj.A(b-1,c);b=$APP.Je.A($APP.N,$APP.Vg.B($APP.Yd,a,$APP.Vj.j(b)));c=$APP.ed(a);a=TI(a)?SI:QI;return a.A?a.A(b,c):a.call(null,b,c)};GXa=function(a){var b=$APP.Ut.A(mG,a),c=$APP.ed(a);a=TI(a)?SI:QI;return a.A?a.A(b,c):a.call(null,b,c)};HXa=function(a,b){return $APP.Xs.B($APP.We.j(b+1),mG,a)};
IXa=function(a,b){return SI(MI($APP.r(a),$APP.r(b)),null)};JXa=function(a){a:{var b=$APP.bc(new $APP.H(null,1,5,$APP.I,[1],null));for(var c=1,d=1;;){if(0===a)break a;c=c*a/d;b=$APP.mf.A(b,c);--a;d+=1}}b=$APP.dc(b);return SI(II(b),null)};YI=function(a){return $APP.Uc.A(a,$APP.Kv)};KXa=function(a){var b=(b=$APP.be(a))?tD(/^\?[^\?].*/,$APP.Ag(a)):b;return $APP.k(b)?b:$APP.kd(a)&&$APP.Uc.A($APP.u(a),ZI)};
$I=function(a){var b=(b=$APP.be(a))?tD(/^\?\?[^\?].*/,$APP.Ag(a)):b;return $APP.k(b)?b:$APP.kd(a)&&$APP.Uc.A($APP.u(a),LXa)};aJ=function(a){var b=(b=$APP.be(a))?tD(/^\$\$[^\$].*/,$APP.Ag(a)):b;return $APP.k(b)?b:$APP.kd(a)&&$APP.Uc.A($APP.u(a),MXa)};bJ=function(a){return $APP.be(a)?a:$APP.Xc(a)};NXa=function(a){return $APP.be(a)?$APP.Zg.j(["??",$APP.Og.A($APP.Ag(a),2)].join("")):$APP.Xc(a)};cJ=function(a){function b(){return!0}return $APP.be(a)?b:(a=$APP.r($APP.Se.A(2,a)))?$APP.Je.A($APP.xt,a):b};
dJ=function(a){return $APP.kd(a)&&$APP.Uc.A($APP.u(a),$APP.Kj)};eJ=function(a){return $APP.kd(a)&&$APP.Uc.A($APP.u(a),$APP.Lj)};
OXa=function(a,b,c){var d=$APP.Id.B(function(g,l){var n=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return $APP.k(a.j?a.j(l):a.call(null,l))?$APP.hd(g)?new $APP.H(null,2,5,$APP.I,[$APP.Vd.A(n,b.j?b.j(l):b.call(null,l)),$APP.sf],null):new $APP.H(null,2,5,$APP.I,[$APP.Vd.C(n,g,$APP.y([b.j?b.j(l):b.call(null,l)])),$APP.sf],null):new $APP.H(null,2,5,$APP.I,[n,$APP.Vd.A(g,b.j?b.j(l):b.call(null,l))],null)},new $APP.H(null,2,5,$APP.I,[$APP.sf,$APP.sf],null),c);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return $APP.hd(d)?
c:$APP.Vd.A(c,d)};fJ=function(a){return new $APP.f(null,1,[PXa,a],null)};QXa=function(a){return $APP.md(a)?PXa.A(a,a):a};RXa=function(a,b){a=$APP.be(a)?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,a,null,1,null)))):dJ(a)?$APP.Xc(a):a;return new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null)};
UXa=function(a,b){function c(g){g=OXa($APP.yt.B($I,aJ,eJ),d,g);return $APP.hd(g)?$APP.Ec:$APP.Uc.A(1,$APP.Tc(g))?$APP.u(g):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.sy,null,1,null),g)))}var d=function n(l){var p=KXa(l);p=$APP.k(p)?p:$I(l);return $APP.k(p)?(l=bJ(l),RXa(l,a)):$APP.k(aJ(l))?(l=NXa(l),new $APP.D(null,SXa,new $APP.D(null,RXa(l,a),null,1,null),2,null)):l instanceof $APP.q?new $APP.D(null,$APP.K,new $APP.D(null,l,null,1,null),2,null):dJ(l)?$APP.Xc(l):eJ(l)?$APP.Lf.A($APP.sf,$APP.Xc(l)):
$APP.md(l)?sD(n,l):$APP.od(l)?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.rua,null,1,null),new $APP.D(null,c(l),null,1,null)))):$APP.kd(l)?$APP.hd(l)?l:$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Pu,null,1,null),new $APP.D(null,c(l),null,1,null)))):l};return $APP.k(b)?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,TXa,null,1,null),new $APP.D(null,d(b),null,1,null))))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.ey,null,1,null),new $APP.D(null,TXa,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,gJ,null,1,null),new $APP.D(null,TXa,null,1,null)))),null,1,null)])))),null,1,null)])))):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,gJ,null,1,null),new $APP.D(null,b,null,1,null))))};VXa=function(){return null};WXa=function(a,b,c){return c.j?c.j(a):c.call(null,a)};XXa=function(a){return function(b,c,d){c=a.j?a.j(c):a.call(null,c);return $APP.k(c)?d.j?d.j(b):d.call(null,b):c}};
YXa=function(a){return function(b,c,d){c=a.j?a.j(b):a.call(null,b);return $APP.k(c)?d.j?d.j(b):d.call(null,b):c}};ZXa=function(a,b){var c=hJ.j?hJ.j(b):hJ.call(null,b);return function(d,g,l){return $APP.k(a.j?a.j(g):a.call(null,g))?c.B?c.B(d,g,l):c.call(null,d,g,l):null}};$Xa=function(a){var b=hJ.j?hJ.j(a):hJ.call(null,a);return function(c,d,g){return $APP.k(b.B?b.B(c,d,g):b.call(null,c,d,g))?null:g.j?g.j(c):g.call(null,c)}};bYa=function(a){return $APP.Yj.K(a,$APP.rg,aYa,!0)};
cYa=function(a,b){return bYa(function(c,d,g){d=$APP.k(d)?d:$APP.sf;var l=(l=$APP.kd(d))?b.j?b.j(d):b.call(null,d):l;if($APP.k(l)){if(YI(a))return g.A?g.A(c,null):g.call(null,c,null);l=c.j?c.j(a):c.call(null,a);if($APP.k(l))return $APP.Uc.A(d,l)?g.A?g.A(c,null):g.call(null,c,null):null;c=$APP.rg.B(c,a,d);return g.A?g.A(c,null):g.call(null,c,null)}return null})};
dYa=function(a){return function(b,c,d){if($APP.kd(c)){var g=$APP.Vg.A(hJ,a);return function t(n,p,v){function A(O){function R(W,Z){return t(W,Z,$APP.w(v))}return O.B?O.B(n,p,R):O.call(null,n,p,R)}function B(O){function R(Z){return t(Z,$APP.w(p),$APP.w(v))}var W=$APP.u(p);return O.B?O.B(n,W,R):O.call(null,n,W,R)}if($APP.k(v)){var G=$APP.u(v);if($APP.k(aYa.A($APP.ed(G),!1)))return A(G);var J=$APP.r(p);return J?B(G):J}return $APP.r(p)?!1:d.j?d.j(n):d.call(null,n)}(b,c,g)}return null}};
iJ=function(a,b,c){this.R=a;this.N=b;this.P=c;this.O=2230716170;this.U=139264};jJ=function(a){return a instanceof iJ};
eYa=function(a,b){var c=hJ(a),d=function(){function g(p,v){b.A?b.A(p,v):b.call(null,p,v);return!1}function l(p){b.j?b.j(p):b.call(null,p);return!1}var n=null;n=function(p,v){switch(arguments.length){case 1:return l.call(this,p);case 2:return g.call(this,p,v)}throw Error("Invalid arity: "+arguments.length);};n.j=l;n.A=g;return n}();return function(g){return c.B?c.B($APP.F,g,d):c.call(null,$APP.F,g,d)}};
fYa=function(a){var b=hJ(a);return function(c){var d=$APP.kh.j($APP.sf),g=function(){function l(v,t){$APP.lh.B(d,$APP.Vd,new $APP.H(null,2,5,$APP.I,[v,t],null));return!1}function n(v){$APP.lh.B(d,$APP.Vd,v);return!1}var p=null;p=function(v,t){switch(arguments.length){case 1:return n.call(this,v);case 2:return l.call(this,v,t)}throw Error("Invalid arity: "+arguments.length);};p.j=n;p.A=l;return p}();b.B?b.B($APP.F,c,g):b.call(null,$APP.F,c,g);return $APP.Fb(d)}};
mJ=function(a,b){var c=$APP.cd(a)?a:kJ.j(a);return function(d){d=c.j?c.j(d):c.call(null,d);jJ(d)?d=lJ:(d=b.j?b.j(d):b.call(null,d),d=QXa($APP.k(d)?d:lJ));return d}};gYa=function(a){return a};hYa=function(){return lJ};iYa=function(a){return function(b){return $APP.k(a.j?a.j(b):a.call(null,b))?b:lJ}};jYa=function(a){return function(){return a}};
kYa=function(a){return function(b){for(var c=a;;){if($APP.hd(c))return lJ;var d=$APP.u(c);d=d.j?d.j(b):d.call(null,b);if($APP.k(jJ.j?jJ.j(d):jJ.call(null,d)))c=$APP.Fc(c);else return d}}};lYa=function(a){return function(b){return $APP.Id.B(function(c,d){c=d.j?d.j(c):d.call(null,c);return $APP.k(jJ.j?jJ.j(c):jJ.call(null,c))?$APP.Mc(lJ):c},b,a)}};nYa=function(a){return mYa.A($APP.ed(a),!1)};nJ=function(a){return $APP.Yj.K(a,$APP.rg,mYa,!0)};pJ=function(a){return $APP.k(nYa(a))?a:nJ(oJ.C(a,$APP.y([gYa])))};
rJ=function(a,b){return qJ.C(iYa(a),$APP.y([b]))};oYa=function(a,b){return nJ(function(c){for(;;){var d=pJ(b);d=d.j?d.j(c):d.call(null,c);if($APP.k(a.A?a.A(c,d):a.call(null,c,d)))return d;c=d}})};pYa=function(a,b){return $APP.kd(b)?(a=$APP.Ej.j($APP.Vg.A(a,b)),$APP.Uc.A(b,a)?b:$APP.od(b)?$APP.tf(a):a):$APP.md(b)?(a=sD(a,b),$APP.Uc.A(b,a)?b:a):b};
qYa=function(a){var b=pJ(a),c=$APP.kh.j(null);$APP.Ne(c,$APP.mh(function(d){var g=pYa($APP.Fb(c),d);d=b.j?b.j(g):b.call(null,g);if($APP.Uc.A(d,g))return d;g=$APP.Fb(c);return g.j?g.j(d):g.call(null,d)}));return nJ($APP.Fb(c))};sJ=function(a){var b=GF(a);return b?sG.j(a):b};tJ=function(a){var b=xG(a);return b?(b=$APP.eb(MF.j(a)))?MF.j(zH.j(a)):b:b};uJ=function(a){return xG(a)&&$APP.eb(MF.j(zH.j(a)))&&$APP.eb(MF.j(CH.j(a)))};rYa=function(a){var b=tJ(a);return $APP.k(b)?UF(CH.j(a)):b};sYa=function(a){return!EF(a)};
tYa=function(a){return MF.j(nI.A(a,2))};uYa=function(a){return uG.j(nI.A(a,2))};vYa=function(a){var b=EF(a);return b?tYa(a):b};wYa=function(a){var b=EF(a);return b?uYa(a):b};xYa=function(a){var b=wYa(a);return $APP.k(b)?2<a:b};yYa=function(a){return GF(a)&&2<a};vJ=function(a){return GF(a)&&2<=a};
zYa=function(a,b){return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,a,new $APP.D(null,yJ,null,1,null),2,null),zJ),function(c){var d=$APP.N.A,g=new $APP.H(null,1,5,$APP.I,[a],null);c=$APP.qe(c);c=$APP.C.A(c,yJ);c=$APP.un.A($APP.wg([b]),c);return(d=$APP.r(d.call($APP.N,g,c)))?d:fJ(d)})]))};
CYa=function(a){return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,EF,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(b):EJ.call(null,b),CJ.j?CJ.j(b):CJ.call(null,b)],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,
BJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),zJ),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)}),rJ(function(){return!0},mJ(xJ.j(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null)),function(b){b=$APP.qe(b);b=$APP.C.A(b,EJ);var c=a.j?a.j(b):a.call(null,b),d=GJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,
2,5,$APP.I,[BJ,c],null))],null)),c],null));d=d.call(GJ,c?c:fJ(c),AYa);return $APP.k(d)?b:d})),rJ(function(){return!0},mJ(xJ.j(new $APP.D(null,HJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null)),function(b){b=$APP.qe(b);b=$APP.C.A(b,EJ);var c=a.j?a.j(b):a.call(null,b),d=GJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,c],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.sj,c,2],null))],null))],null));d=d.call(GJ,c?c:fJ(c),BYa);return $APP.k(d)?(b=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,b,2],null))],null)))?b:fJ(b):d})),mJ(xJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,EJ.j?EJ.j(b):
EJ.call(null,b)],null))],null)))?b:fJ(b)})]))]))};
IYa=function(a){var b=FH($APP.Hv);return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,$APP.Kv,new $APP.D(null,0,null,1,null),2,null),3,null),zJ),function(){return $APP.k(1)?1:fJ(1)}),mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,1,null,1,null),2,null),3,null),zJ),function(c){c=EJ.j?EJ.j(c):EJ.call(null,c);return $APP.k(c)?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,pG,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,EF,null,1,null),
2,null),3,null),null,1,null),2,null),3,null),zJ),function(c){c=$APP.Od(c.j?c.j(CJ):c.call(null,CJ),4);var d=new $APP.H(null,4,5,$APP.I,[1,pG,-1,TF.j(pG)],null);c=d.j?d.j(c):d.call(null,c);return $APP.k(c)?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,IJ,null,1,null),2,null),3,null),new $APP.D(null,JJ,null,1,null),2,null),3,null),function(c){c=$APP.qe(c);var d=$APP.C.A(c,IJ),g=$APP.C.A(c,JJ),l=$APP.C.A(c,EJ),n=a.j?a.j(d):a.call(null,d),p=
a.j?a.j(g):a.call(null,g);return $APP.k(function(){var v=EF(n)&&EF(p);if(v)return v;v=function(){var t=vYa(p);$APP.k(t)&&(t=b.A?b.A(n,p):b.call(null,n,p),t=a.j?a.j(t):a.call(null,t),t=EF(t));return t}();return $APP.k(v)?v:$APP.k(!0)?GJ.A(function(){var t=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,l,n],null)),p],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,l,b.A?b.A(n,p):b.call(null,n,p)],null))],null));return t?t:fJ(t)}(),
DYa):!0}())?new $APP.f(null,1,[EYa,kG.A(d,g)],null):null}),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(c):EJ.call(null,c),EYa.j?EYa.j(c):EYa.call(null,c)],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,1,new $APP.D(null,2,null,1,null),2,null),3,null),null,1,null),2,null),3,null),function(){return!0}),function(c){return(c=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(c):EJ.call(null,c)],null)))?c:fJ(c)}),
mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,FYa,new $APP.D(null,EJ,new $APP.D(null,KJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,LJ,null,1,null),2,null),3,null),new $APP.D(null,MJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(c){return(c=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),NJ.j?NJ.j(c):NJ.call(null,c),$APP.y([KJ.j?KJ.j(c):KJ.call(null,c),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(c):EJ.call(null,
c),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,1,LJ.j?LJ.j(c):LJ.call(null,c)],null))],null))],null),MJ.j?MJ.j(c):MJ.call(null,c)]))))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,NJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,LJ,null,1,null),2,null),3,null),new $APP.D(null,KJ,new $APP.D(null,EJ,new $APP.D(null,MJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(c){return(c=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),NJ.j?NJ.j(c):
NJ.call(null,c),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(c):EJ.call(null,c),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,1,LJ.j?LJ.j(c):LJ.call(null,c)],null))],null))],null),KJ.j?KJ.j(c):KJ.call(null,c),MJ.j?MJ.j(c):MJ.call(null,c)]))))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,NJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,GYa,null,1,null),2,null),3,null),new $APP.D(null,KJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,
EJ,new $APP.D(null,HYa,null,1,null),2,null),3,null),new $APP.D(null,MJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(c){return(c=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),NJ.j?NJ.j(c):NJ.call(null,c),$APP.y([KJ.j?KJ.j(c):KJ.call(null,c),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(c):EJ.call(null,c),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,GYa.j?GYa.j(c):GYa.call(null,c),HYa.j?HYa.j(c):HYa.call(null,c)],null))],null))],null),MJ.j?
MJ.j(c):MJ.call(null,c)]))))?c:fJ(c)})]))]))};
LYa=function(a){return AJ.C($APP.y([mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,vYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(b){var c=$APP.I,d=EJ.j?EJ.j(b):EJ.call(null,b);b=SF.A(b.j?b.j(CJ):b.call(null,CJ),2);return(c=$APP.r(new $APP.H(null,3,5,c,[FJ,d,b],null)))?c:fJ(c)}),wJ.C($APP.y([rJ(function(){return!0},wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,
HJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,vYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),null,1,null),2,null),function(b){b=$APP.qe(b);var c=$APP.C.A(b,EJ);b=$APP.C.A(b,CJ);var d=a.j?a.j(c):a.call(null,c);c=SF.A(b,2);var g=GJ.A;b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,d,b],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,
[FJ,d,c],null))],null));return $APP.k(g.call(GJ,b?b:fJ(b),JYa))?new $APP.f(null,1,[OJ,c],null):null}),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(b):EJ.call(null,b),OJ.j?OJ.j(b):OJ.call(null,b)],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,HJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,xYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),null,1,null),2,null),function(b){b=$APP.qe(b);var c=
$APP.C.A(b,EJ);b=$APP.C.A(b,CJ);var d=a.j?a.j(c):a.call(null,c);c=SF.A(TF.A(b,1),2);var g=GJ.A;b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,d,b],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,d,c],null))],null));return $APP.k(g.call(GJ,b?b:fJ(b),KYa))?new $APP.f(null,1,[OJ,c],null):null}),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],
null)),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(b):EJ.call(null,b),OJ.j?OJ.j(b):OJ.call(null,b)],null))],null)))?b:fJ(b)})])))])),wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,wYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null)),g=$APP.I,l=
EJ.j?EJ.j(b):EJ.call(null,b);b=SF.A(TF.A(b.j?b.j(CJ):b.call(null,CJ),1),2);return(c=$APP.r(new $APP.H(null,3,5,c,[$APP.Hv,d,$APP.r(new $APP.H(null,3,5,g,[FJ,l,b],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,EJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,
new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,EJ,null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,EJ,new $APP.D(null,QJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),
2,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),PJ.j?PJ.j(b):PJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null),QJ.j?QJ.j(b):QJ.call(null,b)]))))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,QJ,null,
1,null),2,null),3,null),4,null),new $APP.D(null,EJ,null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),PJ.j?PJ.j(b):PJ.call(null,b),$APP.y([QJ.j?QJ.j(b):QJ.call(null,b)]))),$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,EJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,new $APP.D(null,
HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,QJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null)),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),PJ.j?PJ.j(b):PJ.call(null,b),$APP.y([QJ.j?QJ.j(b):QJ.call(null,b)])))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,
EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,EJ,new $APP.D(null,QJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),PJ.j?PJ.j(b):PJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null),QJ.j?QJ.j(b):QJ.call(null,b)])))],null)))?
b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,RJ,new $APP.D(null,EJ,new $APP.D(null,SJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,QJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,
[$APP.Hv],null),RJ.j?RJ.j(b):RJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null),SJ.j?SJ.j(b):SJ.call(null,b)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),PJ.j?PJ.j(b):PJ.call(null,b),$APP.y([QJ.j?QJ.j(b):QJ.call(null,b)])))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,RJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),
2,null),new $APP.D(null,SJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,EJ,new $APP.D(null,QJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),RJ.j?RJ.j(b):RJ.call(null,b),$APP.y([SJ.j?SJ.j(b):SJ.call(null,b)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),PJ.j?PJ.j(b):PJ.call(null,
b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null),QJ.j?QJ.j(b):QJ.call(null,b)])))],null)))?b:fJ(b)})]))]))};
QYa=function(a){function b(c){return function(d){var g=$APP.qe(d);d=$APP.C.A(g,EJ);g=$APP.C.A(g,LJ);d=a.j?a.j(d):a.call(null,d);g=a.j?a.j(g):a.call(null,g);return $APP.k(hG.A(d,g))?TJ.A(d,c):TJ.B(d,g,c)}}return pJ(rJ(function(){return!0},AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,HJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,EJ,new $APP.D(null,LJ,null,1,null),2,null),3,null),null,1,null),2,null),b(MYa)),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,
2,5,$APP.I,[HJ,EJ.j?EJ.j(c):EJ.call(null,c)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,LJ.j?LJ.j(c):LJ.call(null,c)],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,HJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,EJ,new $APP.D(null,LJ,new $APP.D(null,UJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),b(NYa)),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(c):EJ.call(null,c)],null)),$APP.r(new $APP.H(null,2,5,
$APP.I,[HJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,LJ.j?LJ.j(c):LJ.call(null,c)],null),UJ.j?UJ.j(c):UJ.call(null,c)))],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,HJ,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,EJ,new $APP.D(null,LJ,null,1,null),2,null),3,null),null,1,null),2,null),b(OYa)),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(c):EJ.call(null,c)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,LJ.j?
LJ.j(c):LJ.call(null,c)],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,HJ,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,EJ,new $APP.D(null,LJ,new $APP.D(null,UJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),b(PYa)),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(c):EJ.call(null,c)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,LJ.j?LJ.j(c):LJ.call(null,c)],null),
UJ.j?UJ.j(c):UJ.call(null,c)))],null))],null)))?c:fJ(c)})]))]))))};
WYa=function(a){return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.j(new $APP.D(null,$APP.Hv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,XJ,null,1,null),2,null),3,null),4,null),5,null),6,null)),function(b){b=$APP.qe(b);var c=$APP.C.A(b,EJ),d=$APP.C.A(b,LJ);c=a.j?a.j(c):a.call(null,c);d=a.j?a.j(d):a.call(null,d);if($APP.k(hG.A(c,d))){var g=TJ.A(c,RYa);
if(g)return(c=b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[c],null),WJ.j?WJ.j(b):WJ.call(null,b),XJ.j?XJ.j(b):XJ.call(null,b)]))))?c:fJ(b)}else if(g=TJ.B(c,d,RYa))return(c=b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,c,d],null))],null))],null),WJ.j?WJ.j(b):WJ.call(null,
b),XJ.j?XJ.j(b):XJ.call(null,b)]))))?c:fJ(b);return g}),mJ(xJ.j(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null)),function(b){var c=$APP.qe(b);b=$APP.C.A(c,EJ);c=$APP.C.A(c,LJ);b=a.j?a.j(b):a.call(null,b);c=a.j?a.j(c):a.call(null,c);if($APP.k(hG.A(b,c))){var d=TJ.A(b,SYa);return d?1:d}return(d=TJ.B(b,c,SYa))?(b=$APP.r(new $APP.H(null,2,5,$APP.I,
[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,b,c],null))],null)))?b:fJ(b):d}),mJ(xJ.j(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null)),function(b){b=$APP.qe(b);var c=$APP.C.A(b,EJ),d=$APP.C.A(b,LJ);c=a.j?a.j(c):a.call(null,c);d=a.j?
a.j(d):a.call(null,d);if($APP.k(hG.A(c,d))){var g=TJ.A(c,TYa);if(g)return(c=b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([WJ.j?WJ.j(b):WJ.call(null,b)]))))?c:fJ(b)}else if(g=TJ.B(c,d,TYa))return(c=b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,c,d],null))],null))],null),WJ.j?WJ.j(b):WJ.call(null,
b)]))))?c:fJ(b);return g}),mJ(xJ.j(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,WJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null)),function(b){b=$APP.qe(b);var c=$APP.C.A(b,EJ),d=$APP.C.A(b,LJ);c=a.j?a.j(c):a.call(null,c);d=a.j?a.j(d):a.call(null,d);if($APP.k(hG.A(c,d))){var g=
TJ.A(c,UYa);if(g)return(c=b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([WJ.j?WJ.j(b):WJ.call(null,b)])))],null)))?c:fJ(b)}else if(g=TJ.B(c,d,UYa))return(c=b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,c,d],null))],null)),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([WJ.j?WJ.j(b):
WJ.call(null,b)])))],null)))?c:fJ(b);return g}),mJ(xJ.j(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WJ,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,XJ,new $APP.D(null,new $APP.D(null,HJ,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,YJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null)),function(b){b=
$APP.qe(b);var c=$APP.C.A(b,EJ),d=$APP.C.A(b,LJ);c=a.j?a.j(c):a.call(null,c);d=a.j?a.j(d):a.call(null,d);if($APP.k(hG.A(c,d))){var g=TJ.A(c,VYa);if(g)return(c=b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([WJ.j?WJ.j(b):WJ.call(null,b)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),XJ.j?XJ.j(b):XJ.call(null,b),$APP.y([YJ.j?YJ.j(b):YJ.call(null,b)])))],null)))?c:fJ(b)}else if(g=TJ.B(c,d,VYa))return(c=
b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VJ.j?VJ.j(b):VJ.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,c,d],null))],null))],null),WJ.j?WJ.j(b):WJ.call(null,b)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),XJ.j?XJ.j(b):XJ.call(null,b),$APP.y([YJ.j?YJ.j(b):YJ.call(null,b)])))],null)))?c:fJ(b);return g})]))]))};
XYa=function(a){return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,ZJ,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,$J,null,1,null),2,null),new $APP.D(null,aK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,bK,null,1,null),2,null),new $APP.D(null,cK,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),ZJ.j?ZJ.j(b):ZJ.call(null,b),$APP.y([aK.j?aK.j(b):aK.call(null,b),cK.j?cK.j(b):
cK.call(null,b),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$J.j?$J.j(b):$J.call(null,b),bK.j?bK.j(b):bK.call(null,b)],null))],null))],null)]))))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.Jv,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.sj,EJ.j?EJ.j(b):EJ.call(null,b),LJ.j?LJ.j(b):LJ.call(null,b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,ZJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,dK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,eK,null,1,null),2,null),3,null),4,null),new $APP.D(null,fK,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,gK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,
hK,null,1,null),2,null),3,null),4,null),new $APP.D(null,aK,null,1,null),2,null),3,null),4,null),5,null),6,null),function(b){var c=function(){var g=(g=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),dK.j?dK.j(b):dK.call(null,b),$APP.y([eK.j?eK.j(b):eK.call(null,b)]))))?g:fJ(g);return a.j?a.j(g):a.call(null,g)}(),d=function(){var g=(g=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),gK.j?gK.j(b):gK.call(null,b),$APP.y([hK.j?hK.j(b):hK.call(null,b)]))))?g:fJ(g);return a.j?a.j(g):
a.call(null,g)}();return $APP.k(WF(function(){var g=new $APP.D(null,$APP.Jv,new $APP.D(null,c,new $APP.D(null,d,null,1,null),2,null),3,null);return a.j?a.j(g):a.call(null,g)}()))?new $APP.f(null,1,[iK,c],null):null}),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(b):EJ.call(null,b),LJ.j?LJ.j(b):LJ.call(null,b)],null))],null)),iK.j?iK.j(b):
iK.call(null,b)],null))],null),ZJ.j?ZJ.j(b):ZJ.call(null,b),$APP.y([fK.j?fK.j(b):fK.call(null,b),aK.j?aK.j(b):aK.call(null,b)]))))?b:fJ(b)})]))]))};
gZa=function(a){return AJ.C($APP.y([function(){var b=FH(jK);return rJ(function(){return!0},mJ(xJ.j(new $APP.D(null,jK,new $APP.D(null,LJ,new $APP.D(null,EJ,null,1,null),2,null),3,null)),function(c){var d=$APP.qe(c);c=$APP.C.A(d,EJ);d=$APP.C.A(d,LJ);var g=a.j?a.j(c):a.call(null,c),l=a.j?a.j(d):a.call(null,d);if($APP.k(hG.A(l,g))){if(GF(l))return $APP.k(sG.j(l))?$APP.M($APP.Jv,$APP.M($APP.sj,$APP.M($APP.Hv,3,pH),4)):$APP.M($APP.sj,pH,4);c=GJ.A(new $APP.D(null,YYa,new $APP.D(null,g,null,1,null),2,null),
ZYa);return $APP.k(c)?$APP.M($APP.sj,pH,4):c}if(GF(l)&&GF(g))return b.A?b.A(l,g):b.call(null,l,g);var n=function(){var p=new $APP.D(null,kK,new $APP.D(null,l,new $APP.D(null,g,null,1,null),2,null),3,null);return a.j?a.j(p):a.call(null,p)}();if($APP.k(uG.j(n)))return null;c=GJ.A(new $APP.D(null,YYa,new $APP.D(null,n,null,1,null),2,null),$Ya);return $APP.k(c)?(c=function(){var p=new $APP.D(null,$APP.sj,new $APP.D(null,l,new $APP.D(null,n,null,1,null),2,null),3,null);return a.j?a.j(p):a.call(null,p)}(),
d=function(){var p=new $APP.D(null,$APP.sj,new $APP.D(null,g,new $APP.D(null,n,null,1,null),2,null),3,null);return a.j?a.j(p):a.call(null,p)}(),(c=$APP.r(new $APP.H(null,3,5,$APP.I,[jK,c,d],null)))?c:fJ(c)):c}))}(),wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,lK,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),zJ),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,mK,new $APP.D(null,
EJ,null,1,null),2,null),null,1,null),2,null),zJ),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,nK,new $APP.D(null,new $APP.D(null,jK,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),zJ),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,mK,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(b):EJ.call(null,b),2],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,lK,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,LJ.j?LJ.j(b):LJ.call(null,b),2],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,
nK,new $APP.D(null,new $APP.D(null,lK,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,LJ.j?LJ.j(b):LJ.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,LJ.j?LJ.j(b):LJ.call(null,b),2],null))],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,nK,new $APP.D(null,new $APP.D(null,mK,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),
2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(b):EJ.call(null,b),2],null))],null))],null)),EJ.j?EJ.j(b):EJ.call(null,b)],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,jK,new $APP.D(null,IJ,new $APP.D(null,JJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,
$APP.I,[$APP.sj,IJ.j?IJ.j(b):IJ.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,IJ.j?IJ.j(b):IJ.call(null,b),2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,JJ.j?JJ.j(b):JJ.call(null,b),2],null))],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,jK,new $APP.D(null,IJ,new $APP.D(null,JJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.sj,JJ.j?JJ.j(b):JJ.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,IJ.j?IJ.j(b):IJ.call(null,b),2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,JJ.j?JJ.j(b):JJ.call(null,b),2],null))],null))],null))],null)))?b:fJ(b)})])),rJ(function(){return!0},wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,lK,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);
b=$APP.C.A(b,EJ);var c=a.j?a.j(b):a.call(null,b);b=GJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[lK,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,c],null))],null)),c],null));return b.call(GJ,c?c:fJ(c),aZa)}),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,mK,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,EJ);var c=a.j?a.j(b):a.call(null,
b);b=GJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[mK,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,c],null))],null)),c],null));return b.call(GJ,c?c:fJ(c),bZa)}),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,jK,new $APP.D(null,new $APP.D(null,nK,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,EJ);var c=a.j?a.j(b):a.call(null,b);b=GJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,
[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[jK,$APP.r(new $APP.H(null,2,5,$APP.I,[nK,c],null))],null)),c],null));return b.call(GJ,c?c:fJ(c),cZa)}),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,jK,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,EJ);var c=a.j?a.j(b):a.call(null,b);b=GJ.A;
c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,3,5,$APP.I,[jK,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,c],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,c],null))],null)),c],null));return b.call(GJ,c?c:fJ(c),dZa)}),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,lK,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,EJ);var c=a.j?a.j(b):a.call(null,b);b=GJ.A;
c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[lK,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,c],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),pH],null)),c],null))],null));return b.call(GJ,c?c:fJ(c),eZa)}),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),
pH],null)),EJ.j?EJ.j(b):EJ.call(null,b)],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,mK,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),function(b){b=$APP.qe(b);b=$APP.C.A(b,EJ);var c=a.j?a.j(b):a.call(null,b);b=GJ.A;c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.bw,$APP.r(new $APP.H(null,2,5,$APP.I,[mK,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,c],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.sj,1,2],null)),pH],null)),c],null))],null));return b.call(GJ,c?c:fJ(c),fZa)}),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),pH],null)),EJ.j?EJ.j(b):EJ.call(null,b)],null)))?b:fJ(b)})])))]))};
hZa=function(a){function b(n){var p=(new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).call(null,n);$APP.k(p)?n=p:(n=l.A?l.A(n,pH):l.call(null,n,pH),n=a.j?a.j(n):a.call(null,n),n=EF(n));return n}var c=FH($APP.Iv),d=FH($APP.Jv),g=FH($APP.Hv),l=FH($APP.sj);return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,
mH,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,b,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(0)?0:fJ(0)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,1,[sH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[sH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,1,[sH,null],null),null)).call(null,n);$APP.k(p)?n=
p:(p=l.A?l.A(pH,2):l.call(null,pH,2),n=d.A?d.A(n,p):d.call(null,n,p),p=g.A?g.A(2,pH):g.call(null,2,pH),n=l.A?l.A(n,p):l.call(null,n,p),n=a.j?a.j(n):a.call(null,n),n=EF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(1)?1:fJ(1)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,1,[tH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[tH,null],
null),null)).j(n):(new $APP.ug(null,new $APP.f(null,1,[tH,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=l.A?l.A(pH,2):l.call(null,pH,2),n=c.A?c.A(n,p):c.call(null,n,p),p=g.A?g.A(2,pH):g.call(null,2,pH),n=l.A?l.A(n,p):l.call(null,n,p),n=a.j?a.j(n):a.call(null,n),n=EF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(-1)?-1:fJ(-1)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,function(n){var p=(new $APP.ug(null,
new $APP.f(null,2,[sH,null,tH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[sH,null,tH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,2,[sH,null,tH,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=l.A?l.A(pH,2):l.call(null,pH,2),n=d.A?d.A(n,p):d.call(null,n,p),n=l.A?l.A(n,pH):l.call(null,n,pH),n=a.j?a.j(n):a.call(null,n),n=EF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(0)?0:fJ(0)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,
ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,2,[qH,null,rH,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=g.A?g.A(2,pH):g.call(null,2,pH),n=l.A?l.A(n,p):l.call(null,n,p),n=a.j?a.j(n):a.call(null,n),n=EF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(1)?1:fJ(1)}),
mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,2,[oH,null,pH,null],null),null)).call(null,n);$APP.k(p)?n=p:(n=d.A?d.A(n,pH):d.call(null,n,pH),p=g.A?g.A(2,pH):g.call(null,2,pH),n=l.A?l.A(n,p):l.call(null,n,p),n=a.j?a.j(n):a.call(null,n),n=EF(n));return n},
null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(-1)?-1:fJ(-1)}),mJ(xJ.A(new $APP.D(null,nK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,b,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(0)?0:fJ(0)}),mJ(xJ.A(new $APP.D(null,nK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,function(n){var p=(new $APP.ug(null,new $APP.f(null,2,[oK,null,pK,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,
2,[oK,null,pK,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,2,[oK,null,pK,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=l.A?l.A(pH,4):l.call(null,pH,4),n=d.A?d.A(n,p):d.call(null,n,p),n=l.A?l.A(n,pH):l.call(null,n,pH),n=a.j?a.j(n):a.call(null,n),n=EF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(1)?1:fJ(1)}),mJ(xJ.A(new $APP.D(null,nK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,function(n){var p=(new $APP.ug(null,
new $APP.f(null,1,[qK,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[qK,null],null),null)).j(n):(new $APP.ug(null,new $APP.f(null,1,[qK,null],null),null)).call(null,n);$APP.k(p)?n=p:(p=l.A?l.A(pH,4):l.call(null,pH,4),n=c.A?c.A(n,p):c.call(null,n,p),n=l.A?l.A(n,pH):l.call(null,n,pH),n=a.j?a.j(n):a.call(null,n),n=EF(n));return n},null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(){return $APP.k(-1)?-1:fJ(-1)})]))]))};
iZa=function(a){var b=rK.A(sK,new $APP.ug(null,new $APP.f(null,2,[mH,null,uH,null],null),null)),c=tK.C(uK.C(uH,$APP.y([YXa(function(d){return $APP.Uc.A(mH,d.j?d.j(sK):d.call(null,sK))})])),$APP.y([uK.C(mH,$APP.y([YXa(function(d){return $APP.Uc.A(uH,d.j?d.j(sK):d.call(null,sK))})]))]));return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,vK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,b,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,2,null,
1,null),2,null),3,null),new $APP.D(null,wK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,c,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,xK,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(d){return(d=$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Iv,1],null),vK.j?vK.j(d):vK.call(null,d),$APP.y([wK.j?wK.j(d):wK.call(null,d),xK.j?xK.j(d):xK.call(null,d)]))))?d:fJ(d)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,
vK,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,dK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,b,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,eK,null,1,null),2,null),3,null),4,null),new $APP.D(null,wK,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,gK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,c,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,2,null,1,null),2,null),3,
null),new $APP.D(null,hK,null,1,null),2,null),3,null),4,null),new $APP.D(null,xK,null,1,null),2,null),3,null),4,null),5,null),6,null),function(d){var g=function(){var n=(n=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),dK.j?dK.j(d):dK.call(null,d),$APP.y([eK.j?eK.j(d):eK.call(null,d)]))))?n:fJ(n);return a.j?a.j(n):a.call(null,n)}(),l=function(){var n=(n=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),gK.j?gK.j(d):gK.call(null,d),$APP.y([hK.j?hK.j(d):hK.call(null,d)]))))?n:fJ(n);
return a.j?a.j(n):a.call(null,n)}();return $APP.k(WF(function(){var n=new $APP.D(null,$APP.Jv,new $APP.D(null,g,new $APP.D(null,l,null,1,null),2,null),3,null);return a.j?a.j(n):a.call(null,n)}()))?new $APP.f(null,1,[iK,g],null):null}),function(d){return(d=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),vK.j?vK.j(d):vK.call(null,d),$APP.y([wK.j?wK.j(d):wK.call(null,d),xK.j?xK.j(d):xK.call(null,d),new $APP.H(null,1,5,$APP.I,[iK.j?iK.j(d):iK.call(null,d)],null)]))))?d:fJ(d)})]))]))};
kZa=function(a){return qJ.C(jZa,$APP.y([iZa(a)]))};
lZa=function(a){var b=$APP.Jl.A(NF,a),c=new $APP.ug(null,new $APP.f(null,2,[mH,null,uH,null],null),null),d=new $APP.f(null,2,[uH,mH,mH,uH],null);return AJ.C($APP.y([function(){function g(l){var n=$APP.qe(l),p=$APP.C.A(n,CJ);l=$APP.C.A(n,sK);n=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,IJ.j?IJ.j(n):IJ.call(null,n),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[sK.j?sK.j(n):sK.call(null,n),EJ.j?EJ.j(n):EJ.call(null,n)],null)),TF.A(p,2)],null))],null));return $APP.k(b(n?n:fJ(n)))?
new $APP.f(null,1,[yK,d.j?d.j(l):d.call(null,l)],null):null}return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,vK,new $APP.D(null,IJ,new $APP.D(null,wK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,c,null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,vJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,
xK,null,1,null),2,null),3,null),4,null),5,null),6,null),g),function(l){return(l=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),vK.j?vK.j(l):vK.call(null,l),$APP.y([wK.j?wK.j(l):wK.call(null,l),xK.j?xK.j(l):xK.call(null,l),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,IJ.j?IJ.j(l):IJ.call(null,l),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[yK.j?yK.j(l):yK.call(null,l),EJ.j?EJ.j(l):EJ.call(null,l)],null)),2],null))],null))],null)]))))?
l:fJ(l)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,vK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,c,null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,vJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,wK,new $APP.D(null,IJ,new $APP.D(null,xK,null,1,null),2,null),3,null),4,null),5,null),6,null),g),function(l){return(l=
$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),vK.j?vK.j(l):vK.call(null,l),$APP.y([wK.j?wK.j(l):wK.call(null,l),xK.j?xK.j(l):xK.call(null,l),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,IJ.j?IJ.j(l):IJ.call(null,l),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[yK.j?yK.j(l):yK.call(null,l),EJ.j?EJ.j(l):EJ.call(null,l)],null)),2],null))],null))],null)]))))?l:fJ(l)})]))}(),function(){function g(l){var n=$APP.qe(l),p=$APP.C.A(n,CJ);l=$APP.C.A(n,
sK);n=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,IJ.j?IJ.j(n):IJ.call(null,n),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),zK.j?zK.j(n):zK.call(null,n),$APP.y([AK.j?AK.j(n):AK.call(null,n),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[sK.j?sK.j(n):sK.call(null,n),EJ.j?EJ.j(n):EJ.call(null,n)],null)),TF.A(p,2)],null))],null)])))],null));return $APP.k(b(n?n:fJ(n)))?new $APP.f(null,1,[yK,d.j?d.j(l):d.call(null,l)],null):null}return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,
$APP.Iv,new $APP.D(null,vK,new $APP.D(null,IJ,new $APP.D(null,wK,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,zK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,c,null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,vJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,AK,null,1,null),2,null),3,null),4,null),
new $APP.D(null,xK,null,1,null),2,null),3,null),4,null),5,null),6,null),g),function(l){return(l=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),vK.j?vK.j(l):vK.call(null,l),$APP.y([wK.j?wK.j(l):wK.call(null,l),xK.j?xK.j(l):xK.call(null,l),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,IJ.j?IJ.j(l):IJ.call(null,l),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[yK.j?yK.j(l):yK.call(null,l),EJ.j?EJ.j(l):EJ.call(null,l)],null)),2],null))],null))],
null)]))))?l:fJ(l)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,vK,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,zK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,c,null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,vJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,AK,null,1,null),2,null),3,null),
4,null),new $APP.D(null,wK,new $APP.D(null,IJ,new $APP.D(null,xK,null,1,null),2,null),3,null),4,null),5,null),6,null),g),function(l){return(l=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),vK.j?vK.j(l):vK.call(null,l),$APP.y([wK.j?wK.j(l):wK.call(null,l),xK.j?xK.j(l):xK.call(null,l),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,IJ.j?IJ.j(l):IJ.call(null,l),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[yK.j?yK.j(l):yK.call(null,l),EJ.j?
EJ.j(l):EJ.call(null,l)],null)),2],null))],null))],null)]))))?l:fJ(l)})]))}()]))};BK=function(a,b){return $APP.vd($APP.r($APP.lz.A(a,b)))};
nZa=function(a){var b=IYa(a),c=CYa(a),d=hZa(a),g=gZa(a),l=LYa(a);return function(n){var p=aG(n),v=BK(new $APP.ug(null,new $APP.f(null,2,[mH,null,uH,null],null),null),p),t=BK(new $APP.ug(null,new $APP.f(null,3,[jK,null,mK,null,lK,null],null),null),p),A=BK(new $APP.ug(null,new $APP.f(null,2,[DJ,null,BJ,null],null),null),p),B=$APP.Bd(p,HJ);p=$APP.Bd(p,CK);n=b.j?b.j(n):b.call(null,n);A=A?c.j?c.j(n):c.call(null,n):n;A=p?mZa.j?mZa.j(A):mZa.call(null,A):A;A=t?g.j?g.j(A):g.call(null,A):A;A=$APP.k(v?!0:v)?
d.j?d.j(A):d.call(null,A):A;return v&&t?(v=g.j?g.j(A):g.call(null,A),l.j?l.j(v):l.call(null,v)):B?l.j?l.j(A):l.call(null,A):A}};DK=function(a,b,c,d,g){this.o=a;this.arity=b;this.name=c;this.context=d;this.ca=g;this.O=393473;this.U=0};EK=function(a,b,c,d,g){return new DK(a,b,c,d,g)};FK=function(a){return a instanceof DK};GK=function(a){return FK(a)?a.o:yD(["non-operator supplied: ",$APP.m.j(a)].join(""))};HK=function(a){return FK(a)?a.arity:yD(["non-operator supplied: ",$APP.m.j(a)].join(""))};
IK=function(a){return FK(a)?a.name:yD(["non-operator supplied: ",$APP.m.j(a)].join(""))};JK=function(a){return FK(a)?a.context:yD(["non-operator supplied: ",$APP.m.j(a)].join(""))};KK=function(a,b){return FK(a)?EK(a.o,a.arity,a.name,b,a.ca):yD(["non-operator supplied: ",$APP.m.j(a)].join(""))};
oZa=function(a,b){return LK.A(aI.A(GK(a),b),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.MK,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,NK,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,IK(a),null,1,null)])))))};
pZa=function(a,b){return $APP.Jd(function(c,d,g){var l=d.j?d.j(c):d.call(null,c);return $APP.k(l)?$APP.Uc.A(g,l)?c:$APP.Uc.A(d,OK)&&$APP.vh(l,g)?$APP.rg.B(c,d,g):$APP.Uc.A(d,OK)&&$APP.vh(g,l)?c:yD(["incompatible operator context: ",$APP.m.j(JK(a)),$APP.m.j(JK(b))," at key: ",$APP.m.j(d)].join("")):$APP.rg.B(c,d,g)},JK(a),JK(b))};
qZa=function(a,b,c,d){var g=gI(c,new $APP.H(null,2,5,$APP.I,[hI,1],null));return EK(function(l){var n=YH.C($APP.y([g,l]));l=d.j?d.j(l):d.call(null,l);return a.A?a.A(n,l):a.call(null,n,l)},HK(d),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,b,null,1,null),new $APP.D(null,cG.j(c),null,1,null),$APP.y([new $APP.D(null,IK(d),null,1,null)])))),JK(d),null)};
rZa=function(a,b,c,d){var g=gI(d,new $APP.H(null,2,5,$APP.I,[hI,1],null));return EK(function(l){var n=c.j?c.j(l):c.call(null,l);l=YH.C($APP.y([g,l]));return a.A?a.A(n,l):a.call(null,n,l)},HK(c),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,b,null,1,null),new $APP.D(null,IK(c),null,1,null),$APP.y([new $APP.D(null,cG.j(d),null,1,null)])))),JK(c),null)};
sZa=function(a){return EK(function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(d){return RF.j($APP.Je.A(a,d))}b.G=0;b.M=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}(),HK(a),new $APP.D(null,$APP.Jv,new $APP.D(null,IK(a),null,1,null),2,null),JK(a),$APP.ed(a))};
tZa=function(a,b){var c=pZa(a,b);return $APP.k(MF.j(b))?KK(a,c):EK(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return AG.A($APP.Je.A(a,l),$APP.Je.A(b,l))}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),AWa(new $APP.H(null,2,5,$APP.I,[HK(a),HK(b)],null)),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Jv,null,1,null),new $APP.D(null,IK(a),
null,1,null),$APP.y([new $APP.D(null,IK(b),null,1,null)])))),c,null)};
uZa=function(a,b){var c=pZa(a,b);return $APP.k(MF.j(a))?KK(b,c):$APP.k(MF.j(b))?KK(a,c):EK(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return gH.A($APP.Je.A(a,l),$APP.Je.A(b,l))}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),AWa(new $APP.H(null,2,5,$APP.I,[UH(a),UH(b)],null)),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,
null),new $APP.D(null,IK(a),null,1,null),$APP.y([new $APP.D(null,IK(b),null,1,null)])))),c,null)};
vZa=function(a,b){return EK(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return OF.A(a,$APP.Je.A(b,g))}c.G=0;c.M=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),HK(b),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,cG.j(a),null,1,null),$APP.y([new $APP.D(null,IK(b),null,1,null)])))),JK(b),$APP.ed(b))};
wZa=function(a,b){return EK(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return $APP.Je.A(a,$APP.Vg.A(function(l){return OF.A(b,l)},g))}c.G=0;c.M=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),HK(a),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,IK(a),null,1,null),$APP.y([new $APP.D(null,cG.j(b),null,1,null)])))),
JK(a),$APP.ed(a))};xZa=function(a,b){return EK(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return OF.A(QF.j(b),$APP.Je.A(a,g))}c.G=0;c.M=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),HK(a),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sj,null,1,null),new $APP.D(null,IK(a),null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))),JK(a),$APP.ed(a))};
PK=function(a,b){return TF.A(kG.A(a,b),kG.A(b,a))};yZa=function(a,b){return mG.A(kG.A(a,b),kG.A(b,a))};zZa=function(a){return EK(QK.j?QK.j(a):QK.call(null,a),new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.T.j($APP.r($APP.N.A(new $APP.D(null,BJ,null,1,null),new $APP.D(null,IK(a),null,1,null)))),JK(a),$APP.ed(a))};AZa=function(a,b){return a===b?1:0};RK=function(a,b,c){this.orientation=a;this.v=b;this.ca=c;this.O=2310931231;this.U=131072};SK=function(a,b,c){return new RK(a,b,c)};
TK=function(a){return $APP.od(a)?a:a instanceof RK?a.v:yD(["non-structure supplied: ",$APP.m.j(a)].join(""))};VK=function(a){return a instanceof RK?a.orientation:UK};WK=function(a){return $APP.kd(a)?$APP.Tc($APP.ef(a)):1};BZa=function(a,b){return $APP.kd(a)?$APP.x.A(a,b):$APP.Uc.A(b,0)?a:yD(["non-sequential s:nth not supported: ",$APP.m.j(a)," with index !\x3d 0: ",$APP.m.j(b)].join(""))};
CZa=function(a,b){if(b instanceof RK){var c=$APP.Uc.A(a.orientation,b.orientation);return c?hG.A(a.v,b.v):c}return $APP.Uc.A(a.orientation,UK)?$APP.od(b)?hG.A(a.v,b):$APP.ud(b)?hG.A($APP.r(a),$APP.r(b)):!1:!1};XK=function(a){return a instanceof RK||$APP.od(a)};YK=function(a){return $APP.od(a)||a instanceof RK&&$APP.Uc.A(UK,a.orientation)};DZa=function(a){return a instanceof RK&&$APP.Uc.A(ZK,a.orientation)};
EZa=function(a){return $APP.Bd(new $APP.ug(null,new $APP.f(null,2,[UK,null,ZK,null],null),null),a)};FZa=function(a,b){return $APP.Uc.A(VK(a),VK(b))};$K=function(a){var b=$APP.Tc(a),c=VK(a),d=$APP.Lf.B($APP.vg,$APP.Vg.j(function(l){return XK(l)?$APP.Tc(l):1}),a),g=$APP.Lf.B($APP.vg,$APP.Vg.j(VK),a);return $APP.Ge(XK,a)&&$APP.Uc.A(1,$APP.Tc(g))&&$APP.Uc.A(1,$APP.Tc(d))?new $APP.f(null,4,[GZa,c,HZa,$APP.u(g),IZa,b,JZa,$APP.u(d)],null):null};
KZa=function(a,b){return function(c){c=$K(c);c=$APP.k(c)?$APP.Uc.A(a,GZa.j(c))&&$APP.Uc.A(b,HZa.j(c)):null;return $APP.vd(c)}};LZa=function(a){return $APP.vd($K(a))};aL=function(a,b){b=$APP.od(b)?b:$APP.Lf.A($APP.sf,b);return SK(a,b,null)};bL=function(a){return aL(UK,a)};MZa=function(a){return SK(UK,a,null)};cL=function(a){return aL(ZK,a)};NZa=function(a){return SK(ZK,a,null)};dL=function(a,b){return aL(VK(a),b)};eL=function(a,b,c){return SK(b,$APP.Hl.A(c,$APP.Jj.j(a)),null)};
gL=function(a,b,c){var d=fL.j?fL.j(c):fL.call(null,c),g=[$APP.m.j(a),$APP.m.j(d)].join("");return eL(b,c,function(l){return $APP.Zg.j([g,$APP.m.j(l)].join(""))})};hL=function(a,b){return gL(a,b,UK)};iL=function(a,b){return gL(a,b,ZK)};OZa=function(a,b){function c(g){var l=$APP.Vg.A(function(n){return BZa(n,g)},b);return $APP.Je.A(a,l)}var d=$APP.x.B(b,0,null);d=$APP.Tc(d);return jL.B?jL.B(c,0,d):jL.call(null,c,0,d)};
PZa=function(a,b){var c=$APP.x.B(b,0,null);return XK(c)?eL($APP.Tc(c),VK(c),function(d){var g=$APP.Vg.A(function(l){return BZa(l,d)},b);return $APP.Je.A(a,g)}):$APP.Je.A(a,b)};kL=function(a,b){return function n(d,g,l){if(XK(d)){var p=VK(d);return eL($APP.Tc(d),VK(d),function(v){return n(BZa(d,v),$APP.Vd.A(g,v),$APP.Vd.A(l,p))})}return a.B?a.B(d,g,l):a.call(null,d,g,l)}(b,$APP.sf,$APP.sf)};lL=function(a){return XK(a)?kL(function(b,c,d){return $APP.z($APP.r(c),new $APP.f(null,1,[QZa,d],null))},a):null};
RZa=function(a,b){return mL.C(function(c){var d=$APP.Vg.A(fL,QZa.j($APP.ed(c)));c=$APP.Vg.B($APP.m,d,c);return $APP.Zg.j($APP.Je.B($APP.m,a,c))},$APP.y([lL(b)]))};SZa=function(a){var b=VK(a);return PZa(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return aL(b,g)}c.G=0;c.M=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),a)};
nL=function(a){return mL.C(function(){return $APP.Oj.j($APP.Yv)},$APP.y([a]))};pL=function(a){return vG.j(oL(a))};qL=function(a){return nL(oL(a))};TZa=function(a,b){return dL(a,$APP.Vg.A(function(c){return kG.A(c,b)},a))};UZa=function(a,b){return dL(b,$APP.Vg.A(function(c){return kG.A(a,c)},b))};rL=function(a,b){return $APP.Je.A(mG,$APP.Vg.B(kG,a,b))};VZa=function(a,b){return rL(sL.j(a),b)};
uL=function(a,b){return tL(a,b)?rL(a,b):$APP.k(function(){return $APP.k(!0)?!0:!FZa(a,b)&&$APP.Ge(function(c){return tL(a,c)},b)}())?UZa(a,b):yD(["Incompatible multiplication: ",$APP.m.j(a),$APP.m.j(b)].join(""))};vL=function(a,b){var c=oL(a);return tL(c,b)?rL(c,b):yD(["incompatible structures: dot-product ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))};WZa=function(a,b){return mL.C(function(c){return mL.C(function(d){return kG.A(c,d)},$APP.y([a]))},$APP.y([b]))};
XZa=function(a,b){($APP.qg.A($APP.Tc(a),3)||$APP.qg.A($APP.Tc(b),3))&&yD("cross product only works on two elements of ^3");var c=$APP.x.B(a,0,null),d=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);var g=$APP.x.B(b,0,null),l=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return wL.C($APP.y([TF.A(kG.A(d,b),kG.A(a,l)),TF.A(kG.A(a,g),kG.A(c,b)),TF.A(kG.A(c,l),kG.A(d,g))]))};YZa=function(a,b,c){return $APP.Uc.A($APP.Tc(b),$APP.Tc(c))?SK(VK(b),$APP.Hl.B(a,b,c),null):AD([$APP.m.j(a)," provided arguments of differing length"].join(""))};
xL=function(a,b,c){this.arity=a;this.Ra=b;this.ca=c;this.O=2158362625;this.U=0};yL=function(a,b,c){return new xL(a,b,c)};zL=function(a){return a instanceof xL};AL=function(a,b){if($APP.hd(b))return 0;if($APP.Uc.A($APP.Tc(b),1)&&$APP.hd(xI($APP.x.A(b,0)))){var c=yI($APP.x.A(b,0));return zL(c)?yL(a,b,null):c}return yL(a,b,null)};CL=function(a){return $APP.Vg.A(function(b){return BL.A(a,b)},$APP.Jj.A(0,a))};ZZa=function(a){return dG.j(cXa(a,BL.J()))};
$Za=function(a,b,c){if($APP.k(MF.j(b)))return b;if(0===c)return DL.A(a,b);b=zI.A(AI.A?AI.A(0,c):AI.call(null,0,c),b);return yL(a,new $APP.H(null,1,5,$APP.I,[b],null),null)};EL=function(a){return zL(a)?a.arity:0};a_a=function(a){return zL(a)?a.Ra:$APP.od(a)?a:$APP.k(MF.j(a))?$APP.sf:new $APP.H(null,1,5,$APP.I,[zI.j(a)],null)};
b_a=function(a,b){var c=zL(a),d=zL(b);return c&&d?(a=a.arity,b=b.arity,$APP.Uc.A(a,b)?a:AD(["mismatched polynomial arity: ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))):c?a.arity:d?b.arity:0};c_a=function(a,b){return 0<=b&&b<EL(a)};d_a=function(a,b){return c_a(a,b)?b:AD(["Supplied i ",$APP.m.j(b)," outside the bounds of arity ",$APP.m.j(EL(a))," for input ",$APP.m.j(a)].join(""))};
FL=function(a,b){if(b instanceof xL){var c=$APP.Uc.A(a.arity,b.arity);return c?hG.A(a.Ra,b.Ra):c}a=a.Ra;return(c=1>=$APP.Tc(a))?(c=$APP.fd(a),(a=$APP.hd(xI(c)))?hG.A(b,yI(c)):a):c};GL=function(a){return zL(a)?$APP.Vg.A(yI,a_a(a)):$APP.k(MF.j(a))?$APP.sf:new $APP.H(null,1,5,$APP.I,[a],null)};HL=function(a){a=$APP.fd(a_a(a));return $APP.k(a)?a:new $APP.H(null,2,5,$APP.I,[uI,0],null)};IL=function(a){return zL(a)?yI($APP.fd(a.Ra)):a};e_a=function(a){for(;;)if(zL(a))a=IL(a);else return a};
f_a=function(a){return!zL(a)||$APP.Uc.A(1,$APP.Tc(a.Ra))};g_a=function(a){return zL(a)&&$APP.Uc.A(a.arity,1)};h_a=function(a){return zL(a)&&1<a.arity};JL=function(a){return sG.j(e_a(a))};KL=function(a,b){return zL(b)?AL(b.arity,XWa(a,b.Ra)):a.j?a.j(b):a.call(null,b)};i_a=function(a,b){return $APP.k(MF.j(b))?b:KL(function(c){return kG.A(c,b)},a)};j_a=function(a,b){return $APP.k(MF.j(a))?a:KL(function(c){return kG.A(a,c)},b)};k_a=function(a){if(zL(a)){var b=a.arity;a=$APP.gd(a.Ra);return AL(b,a)}return 0};
m_a=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=4<b.length?new $APP.Bc(b.slice(4),0,null):null;return l_a(arguments[0],arguments[1],arguments[2],arguments[3],b)};
l_a=function(a,b,c,d,g){g=$APP.qe(g);g=$APP.C.B(g,n_a,AL);var l=zL(a),n=zL(b);return l&&n?(c=b_a(a,b),l=function(){var p=a.Ra,v=b.Ra;return d.A?d.A(p,v):d.call(null,p,v)}(),g.A?g.A(c,l):g.call(null,c,l)):l?(c=a.arity,l=function(){var p=a.Ra,v=UWa(b);return d.A?d.A(p,v):d.call(null,p,v)}(),g.A?g.A(c,l):g.call(null,c,l)):n?(c=b.arity,l=function(){var p=UWa(a),v=b.Ra;return d.A?d.A(p,v):d.call(null,p,v)}(),g.A?g.A(c,l):g.call(null,c,l)):c.A?c.A(a,b):c.call(null,a,b)};LL=function(a){return KL(RF,a)};
o_a=function(a){return $APP.k(JL(a))?LL(a):a};ML=function(a,b){return m_a(a,b,gH,YWa)};NL=function(a,b){return m_a(a,b,AG,ZWa)};OL=function(a,b){return m_a(a,b,OF,aXa)};PL=function(a){return OL(a,a)};QL=function(a){return OL(a,OL(a,a))};
RL=function(a,b){if(zL(a))if($APP.xd(b))if(0>b)a=yD(["No inverse -- FPF:EXPT:",$APP.m.j(a),$APP.m.j(b)].join(""));else{if(!$APP.k(uG.j(a)))if($APP.k(MF.j(a)))a=$APP.k(MF.j(b))?AD("poly 0^0"):a;else a:for(var c=1;;){if(0===b){a=c;break a}if($APP.Ie(b))a=OL(a,a),b=$APP.Pd(b,2);else{var d=a;--b;c=OL(a,c);a=d}}}else a=yD(["Can only raise an FPF to an exact integer power: ",$APP.m.j(a),$APP.m.j(b)].join(""));else a=tI.A(a,b);return a};
SL=function(a,b){return $APP.k(MF.j(b))?yD("internal polynomial division by zero"):$APP.k(function(){var c=MF.j(a);return $APP.k(c)?c:uG.j(b)}())?new $APP.H(null,2,5,$APP.I,[a,0],null):l_a(a,b,function(c,d){return new $APP.H(null,2,5,$APP.I,[sI.A(c,d),CG.A(c,d)],null)},bXa,$APP.y([n_a,function(c,d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return new $APP.H(null,2,5,$APP.I,[AL(c,g),AL(c,d)],null)}]))};
TL=function(a,b){if($APP.k(uG.j(b)))return a;var c=SL(a,b),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);$APP.k(MF.j(c))||zD(["expected even division left a remainder! ",$APP.m.j(a)," / ",$APP.m.j(b)," r ",$APP.m.j(c)].join(""));return d};p_a=function(a){return EF(a)?BigInt(a):a};
q_a=function(a,b){var c=HL(b),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);c=p_a(c);d=vI(d);for(var g=0;;){var l=UL.j(a),n=IL(a);n=p_a(n);if(l<d)return new $APP.H(null,2,5,$APP.I,[a,g],null);a=dG.j(NL(i_a(a,c),OL($Za(1,n,l-d),b)));g+=1}};r_a=function(a,b){return c_a(a,b)&&0===UL.A(a,b)};
s_a=function(a){function b(d){return VL.A(c-1,function(){return function n(l){return new $APP.de(null,function(){for(;;){var p=$APP.r(l);if(p){if($APP.pd(p)){var v=$APP.lc(p),t=$APP.Tc(v),A=$APP.fe(t);a:for(var B=0;;)if(B<t){var G=$APP.bd(v,B),J=$APP.x.B(G,0,null);G=$APP.x.B(G,1,null);$APP.je(A,new $APP.H(null,2,5,$APP.I,[MWa(J,0),G],null));B+=1}else{v=!0;break a}return v?$APP.ie($APP.ke(A),n($APP.mc(p))):$APP.ie($APP.ke(A),null)}v=$APP.u(p);A=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);return $APP.Yd(new $APP.H(null,
2,5,$APP.I,[MWa(A,0),v],null),n($APP.Fc(p)))}return null}},null,null)}(d)}())}var c=a.arity;return VL.A(1,$APP.Vg.A(function(d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);g=0===g?uI:AI.A?AI.A(0,g):AI.call(null,0,g);return zI.A(g,b(d))},$APP.oh(function(d){return wI(xI(d),0)},a.Ra)))};
t_a=function(a,b){if(zL(a)){var c=WWa(function(){return function l(g){return new $APP.de(null,function(){for(var n=g;;){var p=$APP.r(n);if(p){var v=p,t=$APP.u(v),A=$APP.x.B(t,0,null),B=$APP.x.B(t,1,null);if(p=$APP.r(function(G,J,O,R,W,Z){return function ja(ia){return new $APP.de(null,function(ta,ua,ca){return function(){for(;;){var V=$APP.r(ia);if(V){if($APP.pd(V)){var da=$APP.lc(V),Y=$APP.Tc(da),ea=$APP.fe(Y);a:for(var ya=0;;)if(ya<Y){var wa=$APP.bd(da,ya),Ba=$APP.x.B(wa,0,null);wa=$APP.x.B(wa,1,
null);Ba=NWa(Ba,0,wI(ca,0));$APP.je(ea,zI.A(Ba,wa));ya+=1}else{da=!0;break a}return da?$APP.ie($APP.ke(ea),ja($APP.mc(V))):$APP.ie($APP.ke(ea),null)}da=$APP.u(V);ea=$APP.x.B(da,0,null);da=$APP.x.B(da,1,null);ea=NWa(ea,0,wI(ca,0));return $APP.Yd(zI.A(ea,da),ja($APP.Fc(V)))}return null}}}(G,J,O,R,W,Z),null,null)}}(n,t,A,B,v,p)(a_a(B))))return $APP.N.A(p,l($APP.Fc(n)));n=$APP.Fc(n)}else return null}},null,null)}(a.Ra)}());return yL(b,c,$APP.ed(a))}return DL.A(b,a)};
u_a=function(a,b,c){var d=b_a(a,b);a=s_a(a);b=s_a(b);c=c.A?c.A(a,b):c.call(null,a,b);return zL(c)?t_a(c,d):c};v_a=function(a,b){if(zL(a)){a=a.Ra;for(var c=0,d=1,g=0;;){var l=$APP.x.A(a,0);if($APP.k(l)){var n=l;l=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);l=wI(l,0);d=kG.A(d,tI.A(b,l-g));a=$APP.w(a);c=mG.A(c,kG.A(n,d));g=l}else return c}}else return a};
WL=function(a,b){for(;;)if(zL(a)){var c=a.arity;if($APP.hd(b))return a;if($APP.k(MF.j(a)))return 0;var d=$APP.u(b);d=zL(d)&&1<c?DL.A(c-1,d):d;if($APP.Uc.A(c,1))return v_a(a,d);a=v_a(s_a(a),d);if(zL(a))b=$APP.w(b);else return a}else return a};w_a=function(a,b){return WL(a,$APP.Vg.B(OL,b,CL(EL(a))))};x_a=function(a,b){return WL(a,$APP.Vg.B(ML,b,CL(EL(a))))};
XL=function(a,b){return zL(a)?(d_a(a,b),VL.A(a.arity,function(){return function g(d){return new $APP.de(null,function(){for(var l=d;;)if(l=$APP.r(l)){if($APP.pd(l)){var n=$APP.lc(l),p=$APP.Tc(n),v=$APP.fe(p);return function(){for(var J=0;;)if(J<p){var O=$APP.bd(n,J),R=$APP.x.B(O,0,null),W=$APP.x.B(O,1,null),Z=R.A?R.A(b,0):R.call(null,b,0);$APP.qg.A(0,Z)&&(O=v,R=$APP.Uc.A(1,Z)?$APP.Oi.A(R,b):$APP.Gj.B(R,b,$APP.Ld),W=kG.A(Z,W),R=zI.A(R,W),O.add(R));J+=1}else return!0}()?$APP.ie($APP.ke(v),g($APP.mc(l))):
$APP.ie($APP.ke(v),null)}var t=$APP.u(l),A=$APP.x.B(t,0,null),B=$APP.x.B(t,1,null),G=A.A?A.A(b,0):A.call(null,b,0);if($APP.qg.A(0,G))return $APP.Yd(function(){var J=$APP.Uc.A(1,G)?$APP.Oi.A(A,b):$APP.Gj.B(A,b,$APP.Ld),O=kG.A(G,B);return zI.A(J,O)}(),g($APP.Fc(l)));l=$APP.Fc(l)}else return null},null,null)}(a.Ra)}())):0};
y_a=function(a){return zL(a)?function d(c){return new $APP.de(null,function(){for(;;){var g=$APP.r(c);if(g){if($APP.pd(g)){var l=$APP.lc(g),n=$APP.Tc(l),p=$APP.fe(n);a:for(var v=0;;)if(v<n){var t=$APP.bd(l,v);$APP.je(p,XL(a,t));v+=1}else{l=!0;break a}return l?$APP.ie($APP.ke(p),d($APP.mc(g))):$APP.ie($APP.ke(p),null)}p=$APP.u(g);return $APP.Yd(XL(a,p),d($APP.Fc(g)))}return null}},null,null)}($APP.Jj.j(a.arity)):$APP.sf};
YL=function(a,b){if(zL(a)){var c=$APP.Vg.j(function(d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return $APP.Xs.K($APP.ip.j(function(l,n){l=wI(g,l);return z_a.A?z_a.A(n,l):z_a.call(null,n,l)}),A_a,$F(d),b)});a=$APP.Qb(a.Ra);return $APP.Xs.B(c,B_a,a)}return $F(a)};
aM=function(a,b){for(var c=new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[ZL,ZL],null),new $APP.H(null,2,5,$APP.I,[$L,ZL],null),new $APP.H(null,2,5,$APP.I,[ZL,$L],null)],null),d=$APP.r(c),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n),v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[v,t],null),function(){return function(G,J){return b.A?b.A(G,J):b.call(null,G,J)}}(d,g,l,n,p,v,t,c));n+=1}else{var A=$APP.r(d);if(A){p=A;if($APP.pd(p))d=$APP.lc(p),n=$APP.mc(p),g=d,l=
$APP.Tc(d),d=n;else{var B=$APP.u(p);v=$APP.x.B(B,0,null);t=$APP.x.B(B,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[v,t],null),function(){return function(G,J){return b.A?b.A(G,J):b.call(null,G,J)}}(d,g,l,n,B,v,t,p,A,c));d=$APP.w(p);g=null;l=0}n=0}else break}};C_a=function(){var a=(new Date).getTime();return function(){return 1E6*((new Date).getTime()-a)}};
D_a=function(a){if(null!=a&&null!=a.Cf)a=a.Cf(a);else{var b=D_a[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=D_a._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IStopwatch.start",a);}return a};bM=function(a,b){if(null!=a&&null!=a.Mg)a=a.Mg(a,b);else{var c=bM[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=bM._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("IStopwatch.-elapsed",a);}return a};
cM=function(a){if(null!=a&&null!=a.Bf)a=a.Bf(a);else{var b=cM[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=cM._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IStopwatch.repr",a);}return a};
E_a=function(a,b){return a/function(){switch(b instanceof $APP.E?b.ga:null){case "nanos":return 1;case "micros":return 1E3;case "millis":return 1E6;case "seconds":return 1E9;case "minutes":return 6E10;case "hours":return 36E11;case "days":return 864E11;default:return yD(["Unknown unit: ",$APP.m.j(b)].join(""))}}()};
H_a=function(a){var b=$APP.u($APP.df.A($APP.Jl.A(function(c){return 1<c},$APP.u),$APP.Vg.A($APP.wi.A(function(c){return E_a(a,c)},$APP.Kd),$APP.Wd(F_a))));return $APP.k(b)?b:new $APP.H(null,2,5,$APP.I,[0,G_a],null)};dM=function(a,b,c){this.Ig=a;this.offset=b;this.gi=c};
K_a=function(a){var b=$APP.kh.j(a);if("undefined"===typeof eM||"undefined"===typeof I_a||"undefined"===typeof J_a||"undefined"===typeof fM)fM=function(c,d,g){this.Xk=c;this.gf=d;this.nk=g;this.O=393216;this.U=0},fM.prototype.da=function(c,d){return new fM(this.Xk,this.gf,d)},fM.prototype.ba=function(){return this.nk},fM.prototype.Cf=function(){$APP.lh.A(this.gf,D_a);return this},fM.prototype.Mg=function(c,d){return bM($APP.Fb(this.gf),d)},fM.prototype.Bf=function(){return cM($APP.Fb(this.gf))},fM.prototype.toString=
function(){return cM($APP.Fb(this.gf))},fM.cb=!0,fM.Ya="emmy.util.stopwatch/t_emmy$util$stopwatch47017",fM.gb=function(c){return $APP.Vb(c,"emmy.util.stopwatch/t_emmy$util$stopwatch47017")};return new fM(a,b,$APP.F)};M_a=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=0<b.length?new $APP.Bc(b.slice(0),0,null):null;b=$APP.qe(b);b=$APP.C.B(b,L_a,!0);c=new dM(null,0,!1);return K_a($APP.k(b)?c.Cf(null):c)};
N_a=function(a,b,c){if($APP.k(!1)){c=$APP.Vg.A($APP.m,c);b=$APP.Lf.A(new $APP.H(null,2,5,$APP.I,[b,a],null),c);var d=$APP.Kl.A(" ",b),g=$APP.Je.A($APP.m,$APP.Vj.A(a,"  "));bH($APP.zu,"emmy.polynomial.gcd",90,new $APP.bh(function(){return new $APP.H(null,2,5,$APP.I,[g,d],null)},null),117156733)}};O_a=function(){var a=gM;if($APP.k(a)){var b=hM;a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return bM(gM,b)>a}return a};
P_a=function(a){if($APP.k(O_a())){var b=JG("Timed out: %s after %s",a,cM(gM));bH($APP.kw,"emmy.polynomial.gcd",108,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,[b],null)},null),663336066);VNa(b)}};Q_a=function(a,b){var c=hM,d=gM,g=M_a();hM=a;gM=g;try{return b.J?b.J():b.call(null)}finally{gM=d,hM=c}};
U_a=function(a,b,c){if($APP.k(!0)){var d=new $APP.H(null,2,5,$APP.I,[b,c],null);var g=$APP.Fb(R_a);d=g.j?g.j(d):g.call(null,d)}else d=!0;if($APP.k(d))return $APP.lh.A(S_a,$APP.Lc),d;a=a.A?a.A(b,c):a.call(null,b,c);$APP.k(!0)&&($APP.lh.A(T_a,$APP.Lc),$APP.lh.K(R_a,$APP.rg,new $APP.H(null,2,5,$APP.I,[b,c],null),a));return a};
V_a=function(a,b,c){if(h_a(a)||h_a(b)){var d=$APP.Lf.A(zL(a)?a.Ra:$APP.sf,zL(b)?b.Ra:$APP.sf);d=1>=$APP.Tc(d)?new $APP.H(null,2,5,$APP.I,[$APP.Kd,$APP.Kd],null):OWa($APP.Xs.B($APP.Vg.j(xI),iM,d));var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var l=jM.A;a=jM.A(g,a);b=jM.A(g,b);c=c.A?c.A(a,b):c.call(null,a,b);return l.call(jM,d,c)}return c.A?c.A(a,b):c.call(null,a,b)};
W_a=function(a,b){var c=GL(a);if($APP.Uc.A(1,$APP.Tc(c))){var d=$APP.u(c);a=KL(function(){return 1},a)}else d=$APP.Je.A(b,c),a=$APP.k(uG.j(d))?a:KL(function(g){return kM.A(g,d)},a);return new $APP.H(null,2,5,$APP.I,[d,a],null)};X_a=function(a){return function(b,c,d){var g=W_a(b,a);b=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var l=W_a(c,a);c=$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);b=a.A?a.A(b,c):a.call(null,b,c);d=d.A?d.A(g,l):d.call(null,g,l);d=zL(d)?d:DL.A(1,d);return j_a(b,d)}};
Z_a=function(){var a=lM;return function(b,c,d){var g=$APP.Id.A($APP.Lf,$APP.Vg.A($APP.Jl.A(rD,xI),b.Ra)),l=$APP.Id.A($APP.Lf,$APP.Vg.A($APP.Jl.A(rD,xI),c.Ra));return $APP.hd($APP.lz.A(g,l))?($APP.lh.A(Y_a,$APP.Lc),$APP.Je.A(a,$APP.N.A(GL(b),GL(c)))):d.A?d.A(b,c):d.call(null,b,c)}};mM=function(a,b){return $APP.Je.B(lM,b,GL(a))};$_a=function(a,b){return $APP.k(MF.j(a))?jG.j(b):$APP.k(MF.j(b))?jG.j(a):zL(a)?zL(b)?$APP.Uc.A(a,b)?o_a(a):null:mM(a,b):zL(b)?mM(b,a):lM(a,b)};
b0a=function(a,b){var c=$APP.x.A(a.Ra,0),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);d=$APP.Xs.K($APP.Vg.j(xI),nM,d,b.Ra);b=mM(b,c);$APP.lh.A(a0a,$APP.Lc);return AL(a.arity,new $APP.H(null,1,5,$APP.I,[zI.A(d,b)],null))};c0a=function(a){return function(b,c){for(;;){P_a("euclid inner loop");var d=$_a(b,c);if($APP.k(d))return d;b=q_a(b,c);d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);if($APP.k(MF.j(d)))return jG.j(c);b=W_a(d,a);$APP.x.B(b,0,null);d=$APP.x.B(b,1,null);b=c;c=d}}};
d0a=function(a,b){return oM.B(new $APP.H(null,2,5,$APP.I,[a,b],null),X_a(lM),c0a(lM))};e0a=function(a,b){return oM.C(new $APP.H(null,2,5,$APP.I,[a,b],null),Z_a(),V_a,$APP.y([pM]))};f0a=function(a,b){var c=$_a(a,b);return $APP.k(c)?c:Q_a(hM,function(){return e0a(a,b)})};g0a=function(a,b){if(zL(a)||zL(b)){var c=f0a(a,b);return o_a(OL(TL(a,c),b))}return qM.A(a,b)};h0a=function(a){return zL(a)?$APP.Xs.B($APP.bu.j(uG),rM,y_a(a)):1};
i0a=function(a){for(var b=0,c=a,d=$APP.sf,g=a,l=1;;){if($APP.k(uG.j(b)))return b=$APP.fd(d),GF(b)?$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[b],null),$APP.pi.A($APP.Vd.A($APP.gd(d),1),1)):$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[c],null),$APP.pi.A(d,1));a=h0a(c);b=TL(c,rM.A?rM.A(c,a):rM.call(null,c,a));a=rM.A?rM.A(a,b):rM.call(null,a,b);g=TL(g,b);l=rM.A?rM.A(g,l):rM.call(null,g,l);var n=TL(b,a);g=a;c=TL(c,OL(a,b));d=$APP.Vd.C(d,l,$APP.y([n]));l=b;b=g;g=l;l=a}};
j0a=function(a){var b=FH(FJ);return $APP.Yd($APP.Hv,$APP.ip.A(function(c,d){return 0===c?d:b.A?b.A(d,c):b.call(null,d,c)},a))};
l0a=function(a){for(var b=function(){var B=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a));return sM.j?sM.j(B):sM.call(null,B)}(),c=FH(FJ),d=FH($APP.Hv),g=FH(HJ),l=$APP.k(jH(b))?$APP.Fc.j?$APP.Fc.j(b):$APP.Fc.call(null,b):new $APP.H(null,1,5,$APP.I,[b],null),n=b=1;;){if($APP.hd(l))return $APP.Uc.A(n,1)||GJ.A($APP.T.j($APP.r($APP.N.A(new $APP.D(null,tM,null,1,null),new $APP.D(null,n,null,1,null)))),k0a),g=g.j?g.j(b):g.call(null,b),b=n,d.A?d.A(g,b):d.call(null,g,b);var p=$APP.r(l);l=$APP.u(p);p=
$APP.w(p);if($APP.k(dH(l))){var v=$APP.Fc.j?$APP.Fc.j(l):$APP.Fc.call(null,l),t=$APP.x.B(v,0,null),A=$APP.x.B(v,1,null);$APP.xd(A)&&$APP.Ie(A)?(l=p,n=p=function(){var B=$APP.Pd(A,2);if(1<B){var G=n;B=c.A?c.A(t,B):c.call(null,t,B);return d.A?d.A(G,B):d.call(null,G,B)}return $APP.Uc.A(B,1)?d.A?d.A(n,t):d.call(null,n,t):n}()):(b=d.A?d.A(l,b):d.call(null,l,b),v=n,l=p,n=v)}else b=d.A?d.A(l,b):d.call(null,l,b),v=n,l=p,n=v}};n0a=function(a){return $APP.oz(function(b){return $APP.k(m0a(b))?l0a(b):b},a)};
o0a=function(a,b){return function l(d,g){if($APP.hd(d))return 0;if($APP.Uc.A(1,$APP.Tc(d)))return g=$APP.x.B(d,0,null),$APP.x.B(g,0,null),$APP.x.B(g,1,null);var n=$APP.gd(d),p=$APP.pi.A(d,1),v=$APP.gd(p),t=$APP.u(d);t=$APP.x.B(t,0,null);d=$APP.fd(d);d=$APP.x.B(d,0,null);n=l(n,g);p=l(p,g);v=l(v,g);n=TF.A(p,n);g=TF.A(kG.A(SF.A(TF.A(g,t),TF.A(g,d)),TF.A(1,SF.A(n,TF.A(p,v)))),1);return mG.A(p,SF.A(n,g))}($APP.tf(a),b)};
p0a=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,4,5,$APP.I,[b,b,0,a],null)};q0a=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);$APP.x.B(b,2,null);b=$APP.x.B(b,3,null);$APP.x.B(c,0,null);var g=$APP.x.B(c,1,null),l=$APP.x.B(c,2,null);c=$APP.x.B(c,3,null);var n=c-b;return new $APP.H(null,4,5,$APP.I,[d,g,b,c+n/((a-d)/(a-g)*(1-n/(c-l))-1)],null)}};
r0a=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,4,5,$APP.I,[b,b,a,a],null)};
s0a=function(a){return function(b,c){var d=$APP.x.B(b,0,null);$APP.x.B(b,1,null);$APP.x.B(b,2,null);b=$APP.x.B(b,3,null);$APP.x.B(c,0,null);var g=$APP.x.B(c,1,null),l=$APP.x.B(c,2,null);$APP.x.B(c,3,null);c=l-b;var n=(a-d)/(a-g)*b,p=n-l;return 0===p?(bH($APP.Yu,"emmy.rational-function.interpolate",190,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["zero denominator!"],null)},null),-993265357),new $APP.H(null,4,5,$APP.I,[d,g,l,b],null)):new $APP.H(null,4,5,$APP.I,[d,g,n*c/p,l*c/p],null)}};
t0a=function(a){return EI(p0a,q0a(a),function(b){return $APP.fd($APP.$c(b))})};u0a=function(a){return EI(r0a,s0a(a),lXa)};v0a=function(a){return GI.j(u0a(a))};uM=function(a,b,c,d){this.arity=a;this.Jb=b;this.v=c;this.ca=d;this.O=2158362625;this.U=0};vM=function(a,b,c,d){return new uM(a,b,c,d)};wM=function(a){return a instanceof uM};w0a=function(a){return!wM(a)&&!zL(a)};x0a=function(a){return wM(a)?a.arity:EL(a)};
y0a=function(a,b){var c=x0a(a),d=x0a(b);return 0===c?d:0===d?c:$APP.Uc.A(c,d)?c:yD(["Unequal arities: ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))};z0a=function(a){return wM(a)?JL(a.Jb):JL(a)};xM=function(a,b){if(b instanceof uM){var c=$APP.Uc.A(a.arity,b.arity);return c?(c=hG.A(a.Jb,b.Jb),$APP.k(c)?hG.A(a.v,b.v):c):c}c=hG.A(a.v,EG(b));return $APP.k(c)?hG.A(a.Jb,DG(b)):c};A0a=function(a,b,c){return $APP.k(MF.j(b))?0:$APP.k(uG.j(c))?b:zL(b)||zL(c)?vM(a,b,c,null):BG.A(b,c)};
zM=function(a,b){if(w0a(a)&&w0a(b))var c=BG.A(a,b);else{$APP.k(MF.j(b))&&AD(["Can't form rational function with zero denominator: ",$APP.m.j(b)].join(""));c=y0a(a,b);var d=$APP.Jl.A($APP.Ot.J(),$APP.Vg.j(EG)),g=$APP.N.A(GL(a),GL(b));d=$APP.Xs.K(d,$APP.Ws.j(qM),1,g);g=$APP.Uc;var l=g.A;var n=IL(b);n=FF(n)?$APP.k(sG.j(n))?-1:1:xG(n)?$APP.k(sG.j(zH.j(n)))?-1:1:1;d=l.call(g,1,n)?d:RF.j(d);b=$APP.k(uG.j(d))?new $APP.H(null,2,5,$APP.I,[a,b],null):new $APP.H(null,2,5,$APP.I,[OF.A(d,a),OF.A(d,b)],null);a=
$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);d=yM.A(a,b);b=$APP.k(uG.j(d))?new $APP.H(null,2,5,$APP.I,[a,b],null):new $APP.H(null,2,5,$APP.I,[TL(a,d),TL(b,d)],null);a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);c=A0a(c,a,b)}return c};
B0a=function(a,b,c,d){var g=y0a(a,b),l=DG(a);a=EG(a);var n=DG(b);b=EG(b);var p=uG.j(a);p=$APP.k(p)?uG.j(b):p;d=$APP.k(p)?new $APP.H(null,2,5,$APP.I,[c.A?c.A(l,n):c.call(null,l,n),1],null):d.K?d.K(l,a,n,b):d.call(null,l,a,n,b);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return A0a(g,c,d)};
C0a=function(a,b,c,d){function g(n,p){if($APP.k(MF.j(n)))return new $APP.H(null,2,5,$APP.I,[0,1],null);var v=yM.A(p,n);return $APP.k(uG.j(v))?new $APP.H(null,2,5,$APP.I,[n,p],null):new $APP.H(null,2,5,$APP.I,[TL(n,v),TL(p,v)],null)}if($APP.k(hG.A(b,d)))return a=ML(a,c),g(a,b);var l=yM.A(b,d);if($APP.k(uG.j(l)))return g(ML(OL(a,d),OL(b,c)),OL(b,d));b=TL(b,l);l=TL(d,l);return g(ML(OL(a,l),OL(b,c)),OL(b,d))};D0a=function(a,b,c,d){return C0a(a,b,LL(c),d)};
E0a=function(a,b,c,d){var g=MF.j(a);g=$APP.k(g)?g:MF.j(c);if($APP.k(g))return new $APP.H(null,2,5,$APP.I,[0,1],null);g=yM.A(a,d);var l=yM.A(b,c);a=OL(TL(a,g),TL(c,l));b=OL(TL(b,l),TL(d,g));return new $APP.H(null,2,5,$APP.I,[a,b],null)};F0a=function(a,b,c,d){a=yM.A(a,c);b=qM.A(b,d);b=zM(a,b);return new $APP.H(null,2,5,$APP.I,[DG(b),EG(b)],null)};G0a=function(a){return wM(a)?vM(a.arity,LL(a.Jb),a.v,$APP.ed(a)):LL(a)};H0a=function(a){return $APP.k(z0a(a))?G0a(a):a};
I0a=function(a,b){return $APP.k(MF.j(a))?b:$APP.k(MF.j(b))?a:B0a(a,b,ML,C0a)};J0a=function(a,b){return $APP.k(MF.j(a))?G0a(b):$APP.k(MF.j(b))?a:B0a(a,b,NL,D0a)};K0a=function(a,b){return $APP.k(MF.j(a))?a:$APP.k(MF.j(b))?b:$APP.k(uG.j(a))?b:$APP.k(uG.j(b))?a:B0a(a,b,OL,E0a)};L0a=function(a){return wM(a)?vM(a.arity,PL(a.Jb),PL(a.v),$APP.ed(a)):PL(a)};M0a=function(a){return wM(a)?vM(a.arity,QL(a.Jb),QL(a.v),$APP.ed(a)):QL(a)};
N0a=function(a,b){if(wM(a)){var c=a.Jb,d=a.v;d=0>b?new $APP.H(null,3,5,$APP.I,[d,c,-b],null):new $APP.H(null,3,5,$APP.I,[c,d,b],null);b=$APP.x.B(d,0,null);c=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return vM(a.arity,RL(b,d),RL(c,d),$APP.ed(a))}return RL(a,b)};O0a=function(a){if(wM(a)){var b=a.Jb,c=a.v;return $APP.k(MF.j(b))?AD("Can't form rational function with zero denominator."):$APP.k(sG.j(b))?vM(a.arity,RF.j(c),RF.j(b),$APP.ed(a)):vM(a.arity,c,b,$APP.ed(a))}return QF.j(a)};
AM=function(a,b){return K0a(a,O0a(b))};P0a=function(a,b){return B0a(a,b,yM,F0a)};BM=function(a,b){return wM(a)?BG.A(WL(a.Jb,b),WL(a.v,b)):WL(a,b)};CM=function(a,b){if(wM(a)){var c=a.Jb;a=a.v;return AM(NL(OL(XL(c,b),a),OL(c,XL(a,b))),PL(a))}return XL(a,b)};
Q0a=function(a){return wM(a)?function d(c){return new $APP.de(null,function(){for(;;){var g=$APP.r(c);if(g){if($APP.pd(g)){var l=$APP.lc(g),n=$APP.Tc(l),p=$APP.fe(n);a:for(var v=0;;)if(v<n){var t=$APP.bd(l,v);$APP.je(p,CM(a,t));v+=1}else{l=!0;break a}return l?$APP.ie($APP.ke(p),d($APP.mc(g))):$APP.ie($APP.ke(p),null)}p=$APP.u(g);return $APP.Yd(CM(a,p),d($APP.Fc(g)))}return null}},null,null)}($APP.Jj.j(a.arity)):y_a(a)};
R0a=function(a,b){if(wM(a)){var c=YL(a.Jb,b);a=YL(a.v,b);b=FH($APP.sj);return b.A?b.A(c,a):b.call(null,c,a)}return YL(a,b)};
EM=function(a,b){for(var c=new $APP.H(null,5,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[DM,DM],null),new $APP.H(null,2,5,$APP.I,[ZL,DM],null),new $APP.H(null,2,5,$APP.I,[$L,DM],null),new $APP.H(null,2,5,$APP.I,[DM,ZL],null),new $APP.H(null,2,5,$APP.I,[DM,$L],null)],null),d=$APP.r(c),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n),v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[v,t],null),function(){return function(G,J){return b.A?b.A(G,J):b.call(null,G,J)}}(d,g,l,n,p,v,t,c));
n+=1}else{var A=$APP.r(d);if(A){p=A;if($APP.pd(p))d=$APP.lc(p),n=$APP.mc(p),g=d,l=$APP.Tc(d),d=n;else{var B=$APP.u(p);v=$APP.x.B(B,0,null);t=$APP.x.B(B,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[v,t],null),function(){return function(G,J){return b.A?b.A(G,J):b.call(null,G,J)}}(d,g,l,n,B,v,t,p,A,c));d=$APP.w(p);g=null;l=0}n=0}else break}};
S0a=function(a){return function(b){try{return a.j?a.j(b):a.call(null,b)}catch(c){if(c instanceof Error)return bH($APP.kw,"emmy.simplify",22,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["simplifier timed out: must have been a complicated expression"],null)},null),-2037906775),b;throw c;}}};U0a=function(){var a=FM.A(16,"-s-");return GM.A(T0a,a)};W0a=function(){var a=FM.A(16,"-r-");return GM.A(V0a,a)};JM=function(a){return HM.call(null,IM.call(null,a))};
KM=function(a){return function(b){for(;;){var c=a.j?a.j(b):a.call(null,b);if($APP.Uc.A(b,c))return b;c=JM.j?JM.j(c):JM.call(null,c);if($APP.Uc.A(c,b))return b;if($APP.k(NF(HM.call(null,new $APP.D(null,$APP.Jv,new $APP.D(null,b,new $APP.D(null,c,null,1,null),2,null),3,null)))))return c;b=c}}};LM=function(a){return function(b){var c=a.j?a.j(b):a.call(null,b);return $APP.Uc.A(b,c)?b:JM.j?JM.j(c):JM.call(null,c)}};MM=function(a,b){return $APP.k(a)?b:$APP.Kd};
n1a=function(a){var b=aG(a),c=BK(new $APP.ug(null,new $APP.f(null,1,[HJ,null],null),null),b),d=$APP.k(!0)?BK(new $APP.ug(null,new $APP.f(null,1,[HJ,null],null),null),b):!0,g=BK(new $APP.ug(null,new $APP.f(null,2,[DJ,null,BJ,null],null),null),b),l=BK(new $APP.ug(null,new $APP.f(null,6,[mH,null,nK,null,uH,null,NM,null,OM,null,PM,null],null),null),b);b=BK(new $APP.ug(null,new $APP.f(null,1,[$APP.Vw,null],null),null),b);return $APP.Jl.C(MM(!0,X0a),MM(c,Y0a),MM(d,$APP.Jl.B(KM($APP.Jl.A(QM,Z0a)),Y0a,KM($0a))),
$APP.y([MM(l,$APP.Jl.C(LM($APP.Jl.A(QM,a1a)),LM(b1a),LM(c1a),$APP.y([KM(d1a),LM(e1a),LM(f1a),MM(!1,LM(g1a)),LM(QM),KM(d1a),LM(e1a),LM(f1a)]))),MM(g,$APP.Jl.B(LM(QM),KM($APP.Jl.A(h1a,i1a)),KM($APP.Jl.A(j1a,k1a)))),KM($APP.Jl.B(QM,MM(g,$APP.Jl.A(h1a,i1a)),MM(c,Z0a))),MM(l,LM(c1a)),LM(l1a),MM(b,LM(m1a)),JM]))(a)};SM=function(a){return NSa(RM,a)};o1a=function(a){return ZF(a)&&$APP.Uc.A(PSa(a),RM)};
UM=function(a,b){var c=FH(b);$APP.k(c)?a.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(d){var g=function(){var l=$F(d);return c.j?c.j(l):c.call(null,l)}();return SM(function(){var l=TM;return $APP.k(l)?l.j?l.j(g):l.call(null,g):g}())}):a.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(d){return OSa(RM,b,new $APP.H(null,1,5,$APP.I,[d],null))})};
WM=function(a,b){var c=new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[RM,RM],null),new $APP.H(null,2,5,$APP.I,[VM,RM],null),new $APP.H(null,2,5,$APP.I,[RM,VM],null)],null),d=FH(b);if($APP.k(d))for(var g=$APP.r(c),l=null,n=0,p=0;;)if(p<n){var v=l.aa(null,p),t=$APP.x.B(v,0,null),A=$APP.x.B(v,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[t,A],null),function(J,O,R,W,Z,fa,ia,ja){return function(ta,ua){var ca=function(){var V=$F(ta),da=$F(ua);return ja.A?ja.A(V,da):ja.call(null,V,da)}();return SM(function(){var V=
TM;return $APP.k(V)?V.j?V.j(ca):V.call(null,ca):ca}())}}(g,l,n,p,v,t,A,d,d,c));p+=1}else if(v=$APP.r(g)){var B=v;if($APP.pd(B))t=$APP.lc(B),v=$APP.mc(B),A=t,t=$APP.Tc(t),g=v,l=A,n=t;else{var G=$APP.u(B);t=$APP.x.B(G,0,null);A=$APP.x.B(G,1,null);a.F(null,new $APP.H(null,2,5,$APP.I,[t,A],null),function(J,O,R,W,Z,fa,ia,ja,ta,ua){return function(ca,V){var da=function(){var Y=$F(ca),ea=$F(V);return ua.A?ua.A(Y,ea):ua.call(null,Y,ea)}();return SM(function(){var Y=TM;return $APP.k(Y)?Y.j?Y.j(da):Y.call(null,
da):da}())}}(g,l,n,p,G,t,A,B,v,d,d,c));g=$APP.w(B);l=null;n=0}p=0}else break;else for(g=$APP.r(c),l=null,p=n=0;;)if(p<n)v=l.aa(null,p),t=$APP.x.B(v,0,null),A=$APP.x.B(v,1,null),a.F(null,new $APP.H(null,2,5,$APP.I,[t,A],null),function(){return function(J,O){return OSa(RM,b,new $APP.H(null,2,5,$APP.I,[J,O],null))}}(g,l,n,p,v,t,A,d,c)),p+=1;else if(v=$APP.r(g))B=v,$APP.pd(B)?(t=$APP.lc(B),v=$APP.mc(B),A=t,t=$APP.Tc(t),g=v,l=A,n=t):(G=$APP.u(B),t=$APP.x.B(G,0,null),A=$APP.x.B(G,1,null),a.F(null,new $APP.H(null,
2,5,$APP.I,[t,A],null),function(){return function(J,O){return OSa(RM,b,new $APP.H(null,2,5,$APP.I,[J,O],null))}}(g,l,n,p,G,t,A,B,v,d,c)),g=$APP.w(B),l=null,n=0),p=0;else break};q1a=function(a){return o1a(a)?p1a(a):a};XM=function(a,b,c,d){this.tag=a;this.id=b;this.xc=c;this.Td=d;this.U=2048;this.O=2147483648};r1a=function(a,b,c,d){return new XM(a,b,c,d)};YM=function(a){return a instanceof XM};s1a=function(a,b){return r1a(a,$APP.Oj.J(),b,$APP.sf)};t1a=function(a,b,c){return r1a(a,$APP.Oj.J(),b,c)};
ZM=function(a){return YM(a)?a.xc:a};u1a=function(a,b){return YM(a)&&$APP.Uc.A(b,a.tag)?a.xc:a};v1a=function(a,b){return JF(ZM(a),ZM(b))};
w1a=function(a){function b(c,d){var g=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);if($APP.Bd(g,d.id))return new $APP.H(null,2,5,$APP.I,[g,c],null);g=$APP.Vd.A(g,d.id);var l=d.Td;g=$APP.Xs.K($APP.Vg.j($APP.u),$APP.Ws.j(b),new $APP.H(null,2,5,$APP.I,[g,c],null),l);c=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return new $APP.H(null,2,5,$APP.I,[c,$APP.Yd(d,g)],null)}return $APP.Xc(b(new $APP.H(null,2,5,$APP.I,[$APP.vg,$APP.sf],null),a))};
x1a=function(a,b){var c=$APP.C.A(a,b.id);return $APP.Id.B(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);l=l.id;g=kG.A(c,g);var n=$APP.C.A(d,l);g=$APP.k(n)?mG.A(n,g):g;return $APP.rg.B(d,l,g)},a,b.Td)};y1a=function(a){var b=w1a(a);a=$APP.pe([a.id,1]);return oWa($APP.Id.B(x1a,a,b))};
z1a=function(a,b){return function(){function c(g){$APP.r(b)&&!XK(g)&&yD(["Selectors ",$APP.m.j(b)," not allowed for non-structural input ",$APP.m.j(g)].join(""));var l=LH(),n=$APP.am.A(g,b);g=$APP.k(n)?$APP.hd(b)?$M(n,l):$APP.cm(g,b,$M(n,l)):yD(["Bad selectors ",$APP.m.j(b)," for structure ",$APP.m.j(g)].join(""));n=QH(l,a,new $APP.H(null,1,5,$APP.I,[g],null));n=IH(n,l,aN);return bN($APP.am.A(g,b),n,l)}var d=null;d=function(g){switch(arguments.length){case 0:return 0;case 1:return c.call(this,g)}throw Error("Invalid arity: "+
arguments.length);};d.J=function(){return 0};d.j=c;return d}()};cN=function(a){for(;;)if(YM(a))a=ZM(a);else if(NH(a))a=RH.j(a);else return a};A1a=function(a,b){return function g(d){if(YM(d)){var l=ZM(d);return t1a(d.tag,g(l),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[d,b.j?b.j(l):b.call(null,l)],null)],null))}if(NH(d)){l=dN.j(d);var n=$APP.x.B(l,0,null),p=$APP.x.B(l,1,null);l=g(n);n=kG.A(b.j?b.j(n):b.call(null,n),p);return SH.B(l,n,OH(d))}return a.j?a.j(d):a.call(null,d)}};
C1a=function(a){var b=a.j?a.j(eN):a.call(null,eN),c=a.j?a.j(fN):a.call(null,fN);return $APP.k($APP.k(b)?c:b)?B1a(a,b,c):yD("No df:dx, df:dy supplied for `f` or registered generically.")};
B1a=function(a,b,c){return function n(g,l){function p(B){var G=u1a(g,B),J=u1a(l,B),O=YM(g)&&$APP.Uc.A(B,g.tag)?new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[g,b.A?b.A(G,J):b.call(null,G,J)],null)],null):$APP.sf,R=YM(l)&&$APP.Uc.A(B,l.tag)?new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[l,c.A?c.A(G,J):c.call(null,G,J)],null)],null):$APP.sf;return t1a(B,n(G,J),$APP.Lf.A(O,R))}function v(B){var G=dN.A(g,B),J=$APP.x.B(G,0,null);G=$APP.x.B(G,1,null);var O=dN.A(l,B),R=$APP.x.B(O,0,null),
W=$APP.x.B(O,1,null);O=n(J,R);J=mG.A($APP.k(NF(G))?G:kG.A(b.A?b.A(J,R):b.call(null,J,R),G),$APP.k(NF(W))?W:kG.A(c.A?c.A(J,R):c.call(null,J,R),W));return SH.B(O,J,B)}var t=gN.C($APP.y([g,l]));if($APP.k(t)){var A=$APP.x.B(t,0,null);t=$APP.x.B(t,1,null);return YM(t)?p(A):NH(t)?v(A):yD("Non-tape or dual perturbation!")}return a.A?a.A(g,l):a.call(null,g,l)}};iN=function(a){var b=hN;var c=a.j?a.j(eN):a.call(null,eN);c=$APP.k(c)?A1a(a,c):yD("No df:dx supplied for `f` or registered generically.");b(a,c)};
hN=function(a,b){a.F(null,new $APP.H(null,1,5,$APP.I,[jN],null),function(c){return b.j?b.j(c):b.call(null,c)});return a.F(null,new $APP.H(null,1,5,$APP.I,[kN],null),function(c){return b.j?b.j(c):b.call(null,c)})};mN=function(a){lN(a,C1a(a))};
lN=function(a,b){for(var c=$APP.r(new $APP.H(null,8,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[kN,kN],null),new $APP.H(null,2,5,$APP.I,[jN,jN],null),new $APP.H(null,2,5,$APP.I,[kN,jN],null),new $APP.H(null,2,5,$APP.I,[jN,kN],null),new $APP.H(null,2,5,$APP.I,[HF,kN],null),new $APP.H(null,2,5,$APP.I,[HF,jN],null),new $APP.H(null,2,5,$APP.I,[kN,HF],null),new $APP.H(null,2,5,$APP.I,[jN,HF],null)],null)),d=null,g=0,l=0;;)if(l<g){var n=d.aa(null,l);a.F(null,n,function(){return function(t,A){return b.A?b.A(t,
A):b.call(null,t,A)}}(c,d,g,l,n));l+=1}else{var p=$APP.r(c);if(p){var v=p;$APP.pd(v)?(c=$APP.lc(v),g=$APP.mc(v),d=c,v=$APP.Tc(c),c=g,g=v):(n=$APP.u(v),a.F(null,n,function(){return function(t,A){return b.A?b.A(t,A):b.call(null,t,A)}}(c,d,g,l,n,v,p)),c=$APP.w(v),d=null,g=0);l=0}else break}};
nN=function(a){return function(){function b(g,l){g=cN(g);l=cN(l);return a.A?a.A(g,l):a.call(null,g,l)}function c(g){g=cN(g);return a.j?a.j(g):a.call(null,g)}var d=null;d=function(g,l){switch(arguments.length){case 1:return c.call(this,g);case 2:return b.call(this,g,l)}throw Error("Invalid arity: "+arguments.length);};d.j=c;d.A=b;return d}()};
D1a=function(a,b){var c=A1a(a,function(){return b}),d=cG.j(c);return function(g){return EF(cN(g))?yD(["Derivative of g/",$APP.m.j(d)," undefined at integral points."].join("")):c(g)}};oN=function(a,b,c){this.r=a;this.c=b;this.v=c;this.O=2174747415;this.U=0};pN=function(a,b,c){return new oN(a,b,c)};qN=function(a){return a instanceof oN};rN=function(a){return qN(a)?a.r:yD(["non-matrix supplied: ",$APP.m.j(a)].join(""))};sN=function(a){return qN(a)?a.c:yD(["non-matrix supplied: ",$APP.m.j(a)].join(""))};
E1a=function(a){return $APP.od(a)?a:qN(a)?a.v:yD(["non-matrix supplied: ",$APP.m.j(a)].join(""))};tN=function(a){return qN(a)&&$APP.Uc.A(rN(a),sN(a))};F1a=function(a){return qN(a)&&$APP.Uc.A(sN(a),1)};G1a=function(a){return qN(a)&&$APP.Uc.A(rN(a),1)};uN=function(a,b){var c=b instanceof oN;return c?(c=$APP.Uc.A(a.r,b.r))?(c=$APP.Uc.A(a.c,b.c))?hG.A(a.v,b.v):c:c:c};H1a=function(a,b){var c=$APP.am.A(a,b);return F1a(a)&&$APP.Uc.A(1,$APP.Tc(b))?c.j?c.j(0):c.call(null,0):c};
vN=function(a,b){return pN(rN(b),sN(b),$APP.Hl.A(function(c){return $APP.Hl.A(a,c)},b))};I1a=function(a,b){var c=$APP.Lf.A($APP.sf,$APP.ip.A(function(d,g){return $APP.Lf.A($APP.sf,$APP.ip.A(function(l,n){return a.B?a.B(n,d,l):a.call(null,n,d,l)},g))},b));return pN(rN(b),sN(b),c)};J1a=function(a){var b=$APP.Vg.A($APP.Tc,a);return $APP.Ge(function(c){return $APP.Uc.A(c,$APP.u(b))},$APP.w(b))};K1a=function(a){return J1a(a)?pN($APP.Tc(a),$APP.Tc($APP.u(a)),$APP.Hl.A($APP.tf,a)):yD("malformed matrix")};
L1a=function(a){return J1a(a)?pN($APP.Tc($APP.u(a)),$APP.Tc(a),$APP.Je.B($APP.Hl,$APP.ps,a)):yD("malformed matrix")};M1a=function(a){return pN(1,$APP.Tc(a),new $APP.H(null,1,5,$APP.I,[$APP.tf(a)],null))};wN=function(a){return pN($APP.Tc(a),1,$APP.Hl.A($APP.ps,a))};yN=function(a){return xN.B(sN(a),rN(a),function(b,c){return $APP.am.A(a,new $APP.H(null,2,5,$APP.I,[c,b],null))})};N1a=function(a){return bL($APP.Vg.A(function(b){return qN(b)?zN.j(b):b},a))};
O1a=function(a,b){var c=rN(a),d=rN(b),g=sN(a),l=sN(b);$APP.Uc.A(g,d)||yD("matrices incompatible for multiplication");return xN.B(c,l,function(n,p){return $APP.Id.A(mG,function(){return function A(t){return new $APP.de(null,function(){for(;;){var B=$APP.r(t);if(B){if($APP.pd(B)){var G=$APP.lc(B),J=$APP.Tc(G),O=$APP.fe(J);a:for(var R=0;;)if(R<J){var W=$APP.bd(G,R);$APP.je(O,kG.A($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[n,W],null)),$APP.am.A(b,new $APP.H(null,2,5,$APP.I,[W,p],null))));R+=1}else{G=!0;
break a}return G?$APP.ie($APP.ke(O),A($APP.mc(B))):$APP.ie($APP.ke(O),null)}O=$APP.u(B);return $APP.Yd(kG.A($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[n,O],null)),$APP.am.A(b,new $APP.H(null,2,5,$APP.I,[O,p],null))),A($APP.Fc(B)))}return null}},null,null)}($APP.Jj.j(g))}())})};P1a=function(a,b){return vN(function(c){return kG.A(a,c)},b)};Q1a=function(a,b){return vN(function(c){return kG.A(c,b)},a)};
AN=function(a,b,c){var d=rN(b),g=rN(c),l=sN(b),n=sN(c);($APP.qg.A(d,g)||$APP.qg.A(l,n))&&yD("matrices incompatible for operation");return xN.B(d,l,function(p,v){var t=$APP.am.A(b,new $APP.H(null,2,5,$APP.I,[p,v],null));p=$APP.am.A(c,new $APP.H(null,2,5,$APP.I,[p,v],null));return a.A?a.A(t,p):a.call(null,t,p)})};
BN=function(a,b){var c=$K(a);if($APP.k(c)){c=$APP.qe(c);var d=$APP.C.A(c,JZa),g=$APP.C.A(c,IZa),l=$APP.C.A(c,HZa),n=$APP.C.A(c,GZa),p=$APP.Uc.A(l,UK);d=p?new $APP.H(null,2,5,$APP.I,[d,g],null):new $APP.H(null,2,5,$APP.I,[g,d],null);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);c=xN.B(c,d,function(v,t){return $APP.am.A(a,p?new $APP.H(null,2,5,$APP.I,[t,v],null):new $APP.H(null,2,5,$APP.I,[v,t],null))});d=function(v){return zN.K(v,n,l,p)};return b.A?b.A(c,d):b.call(null,c,d)}return yD(["structure ",$APP.m.j(a),
" is not a 2-tensor"].join(""))};R1a=function(a,b){return BN(a,function(c,d){c=b.j?b.j(c):b.call(null,c);return d.j?d.j(c):d.call(null,c)})};S1a=function(a,b){$APP.qg.A(sN(a),$APP.Tc(b))&&yD("matrix and tuple incompatible for multiplication");return bL($APP.Vg.A(function(c){function d(l){return kG.A($APP.x.A(g,l),$APP.x.A(b,l))}var g=$APP.x.A(a,c);c=sN(a);return jL.B?jL.B(d,0,c):jL.call(null,d,0,c)},$APP.Jj.j(rN(a))))};
T1a=function(a,b){$APP.qg.A($APP.Tc(a),rN(b))&&yD("matrix and tuple incompatible for multiplication");return cL($APP.Vg.A(function(c){function d(l){return kG.A($APP.C.A(a,l),$APP.am.A(b,new $APP.H(null,2,5,$APP.I,[l,c],null)))}var g=rN(b);return jL.B?jL.B(d,0,g):jL.call(null,d,0,g)},$APP.Jj.j(sN(b))))};U1a=function(a,b){return cL($APP.C.A(a,b))};CN=function(a,b){return bL($APP.Vg.A(function(c){return c.j?c.j(b):c.call(null,b)},a))};
V1a=function(a){var b=rN(a);return bL($APP.Vg.A(function(c){return $APP.am.A(a,new $APP.H(null,2,5,$APP.I,[c,c],null))},$APP.Jj.A(0,b)))};W1a=function(a){return wN(a)};DN=function(a){return CN(a,0)};X1a=function(a){return $APP.Hl.A($APP.u,a)};Y1a=function(a){return EN.C($APP.y([TK(a)]))};FN=function(a){return U1a(a,0)};GN=function(a){return $APP.x.A(a,0)};
IN=function(a,b,c){var d=sN(b),g=qL(a);return HN.A(function(){return function p(n){return new $APP.de(null,function(){for(;;){var v=$APP.r(n);if(v){if($APP.pd(v)){var t=$APP.lc(v),A=$APP.Tc(t),B=$APP.fe(A);a:for(var G=0;;)if(G<A){var J=$APP.bd(t,G);$APP.je(B,HN.A(CN(b,J),g));G+=1}else{t=!0;break a}return t?$APP.ie($APP.ke(B),p($APP.mc(v))):$APP.ie($APP.ke(B),null)}B=$APP.u(v);return $APP.Yd(HN.A(CN(b,B),g),p($APP.Fc(v)))}return null}},null,null)}($APP.Jj.j(d))}(),qL(c))};
Z1a=function(a){a=R1a(a,JN);return $APP.Uc.A(VK(a),VK($APP.u(a)))?oL(a):a};KN=function(a,b){if($APP.od(a))return $APP.Lf.A($APP.pi.B(a,0,b),$APP.pi.A(a,b+1));a=$APP.Lf.A($APP.sf,a);return KN.A?KN.A(a,b):KN.call(null,a,b)};$1a=function(a,b,c){return $APP.rg.B(a,b,c)};a2a=function(a,b,c,d,g){var l=XK(a)?BN(a,function(n){return n}):a;return xN.B(c-b+1,g-d+1,function(n,p){return $APP.am.A(l,new $APP.H(null,2,5,$APP.I,[n+b,p+d],null))})};
b2a=function(a,b,c){return pN(rN(a)-1,sN(a)-1,$APP.Hl.A(function(d){return KN(d,c)},KN(E1a(a),b)))};c2a=function(a){var b=rN(a);return $APP.Xs.B($APP.Vg.j(function(c){return $APP.am.A(a,new $APP.H(null,2,5,$APP.I,[c,c],null))}),mG,$APP.Jj.A(0,b))};
d2a=function(a,b,c,d){var g=a.J?a.J():a.call(null);return function(l){var n=$APP.kh.j(null);$APP.Ne(n,$APP.mh(function(t,A){var B=$APP.r(A),G=$APP.u(B);B=$APP.w(B);if($APP.eb(B))return $APP.am.A(l,new $APP.H(null,2,5,$APP.I,[t,G],null));G=0;B=A;for(var J=g;;){if($APP.eb($APP.r(B)))return J;var O=$APP.am.A(l,new $APP.H(null,2,5,$APP.I,[t,$APP.u(B)],null));if($APP.k(d.j?d.j(O):d.call(null,O)))G+=1,B=$APP.Fc(B);else{var R=KN(A,G);var W=t+1;var Z=$APP.Fb(n);W=Z.A?Z.A(W,R):Z.call(null,W,R);W=c.A?c.A(O,
W):c.call(null,O,W);O=G+1;B=$APP.Fc(B);J=$APP.Ie(G)?a.A?a.A(J,W):a.call(null,J,W):b.A?b.A(J,W):b.call(null,J,W);G=O}}}));var p=$APP.Jj.j(rN(l)),v=$APP.Fb(n);return v.A?v.A(0,p):v.call(null,0,p)}};
e2a=function(a,b,c,d,g){var l=d2a(a,b,c,g);return function(n){var p=rN(n);if($APP.Uc.A(p,1))return pN(1,1,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[function(){var A=$APP.am.A(n,new $APP.H(null,2,5,$APP.I,[0,0],null));return d.j?d.j(A):d.call(null,A)}()],null)],null));var v=l(n),t=b.j?b.j(v):b.call(null,v);return xN.B(p,p,function(A,B){var G=$APP.Ie(A+B)?v:t;A=l(b2a(n,B,A));return d.A?d.A(A,G):d.call(null,A,G)})}};f2a=function(a,b){var c=qL(b),d=qL(uL(c,a));return uL(LN.B(c,a,d),b)};
g2a=function(a,b){var c=qL(a),d=qL(uL(b,c));return uL(a,LN.B(d,b,c))};MN=function(a){return xN.B(a,a,AZa)};h2a=function(a){return tN(a)?I1a(function(b,c,d){return $APP.Uc.A(c,d)?PF.j(b):vG.j(b)},a):yD("identity-like on non-square")};
i2a=function(a){var b=tN(a);if(b){var c=rN(a);return $APP.Ge($APP.rd,function(){return function l(g){return new $APP.de(null,function(){for(var n=g;;){var p=$APP.r(n);if(p){var v=p,t=$APP.u(v);if(p=$APP.r(function(A,B,G,J,O,R){return function fa(Z){return new $APP.de(null,function(ia,ja){return function(){for(;;){var ta=$APP.r(Z);if(ta){if($APP.pd(ta)){var ua=$APP.lc(ta),ca=$APP.Tc(ua),V=$APP.fe(ca);a:for(var da=0;;)if(da<ca){var Y=$APP.bd(ua,da),ea=$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[ja,Y],null));
$APP.je(V,$APP.Uc.A(ja,Y)?uG.j(ea):MF.j(ea));da+=1}else{ua=!0;break a}return ua?$APP.ie($APP.ke(V),fa($APP.mc(ta))):$APP.ie($APP.ke(V),null)}V=$APP.u(ta);ua=$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[ja,V],null));return $APP.Yd($APP.Uc.A(ja,V)?uG.j(ua):MF.j(ua),fa($APP.Fc(ta)))}return null}}}(A,B,G,J,O,R),null,null)}}(n,t,v,p,c,b)($APP.Jj.j(c))))return $APP.N.A(p,l($APP.Fc(n)));n=$APP.Fc(n)}else return null}},null,null)}($APP.Jj.j(c))}())}return b};
j2a=function(a,b,c,d,g){var l=d2a(a,b,c,g);return function(n,p){var v=CN(p,0);p=rN(p);var t=l(n),A=yN(n);return wN($APP.Hl.A(function(B){B=l($1a(A,B,v));return d.A?d.A(B,t):d.call(null,B,t)},$APP.Jj.j(p)))}};ON=function(a,b){return YK(a)?DN(NN(b,wN(a))):F1a(a)?NN(b,a):DZa(a)?FN(yN(NN(yN(b),yN(Y1a(a))))):G1a(a)?yN(NN(yN(b),yN(a))):yD(["I don't know how to solve:",$APP.m.j(a),$APP.m.j(b)].join(""))};
RN=function(a){if($APP.Uc.A(a,PN))return 0;if($APP.kd(a)){a=$APP.r(a);var b=$APP.u(a),c=$APP.w(a);if($APP.Uc.A(QN,b))return $APP.Hl.A(RN,c);if($APP.Uc.A(k2a,b))return $APP.Je.A(wL,$APP.Vg.A(RN,c));if($APP.Uc.A(l2a,b))return $APP.Je.A(SN,$APP.Vg.A(RN,c));if($APP.Uc.A(TN,b))return $APP.Je.A(wL,$APP.Vj.A($APP.Xc(c),function(){var d=$APP.u(c);return RN.j?RN.j(d):RN.call(null,d)}()));if($APP.Uc.A(m2a,b))return $APP.Je.A(SN,$APP.Vj.A($APP.Xc(c),function(){var d=$APP.u(c);return RN.j?RN.j(d):RN.call(null,
d)}()));if($APP.Uc.A(n2a,b))return $APP.Lf.A($APP.sf,$APP.Vj.A($APP.Xc(c),function(){var d=$APP.u(c);return RN.j?RN.j(d):RN.call(null,d)}()));throw Error(["No matching clause: ",$APP.m.j(b)].join(""));}return null};
o2a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null);$APP.k(function(){var g=$APP.Uc.A($APP.gv,b);return g?$APP.k(c)?d:c:g}())||yD(["A SICM signature is of the form '(-\x3e domain range), got: ",$APP.m.j(b),$APP.m.j(c),$APP.m.j(d)].join(""));return new $APP.H(null,2,5,$APP.I,[function(){var g=RN(c);return $APP.od(g)?g:new $APP.H(null,1,5,$APP.I,[g],null)}(),RN(d)],null)};
p2a=function(a,b,c,d){this.qd=a;this.arity=b;this.domain=c;this.range=d;this.O=2149580801;this.U=0};UN=function(a,b,c,d){return new p2a(a,b,c,d)};q2a=function(a){return a instanceof p2a};r2a=function(a,b){return q2a(b)&&$APP.Uc.A(a.qd,b.qd)&&$APP.Uc.A(a.domain,b.domain)&&$APP.Uc.A(a.range,b.range)};
VN=function(a){switch(arguments.length){case 1:return VN.j(arguments[0]);case 2:return VN.A(arguments[0],arguments[1]);case 3:return VN.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
s2a=function(a){return $APP.Hl.A(function(b){var c=$APP.I,d=b instanceof $APP.q?b:$APP.u(b);if(b instanceof $APP.q)var g=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,WN,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null))));else if($APP.kd(b)&&$APP.Uc.A($APP.Tc(b),3)){g=$APP.x.B(b,0,null);var l=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);g=$APP.T.j($APP.r($APP.N.C(new $APP.D(null,WN,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
$APP.K,null,1,null),new $APP.D(null,g,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,l,null,1,null),new $APP.D(null,b,null,1,null)]))))}else g=yD(["unknown literal function type",$APP.m.j(b)].join(""));return new $APP.H(null,2,5,c,[d,g],null)},a)};XN=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=3<b.length?new $APP.Bc(b.slice(3),0,null):null;return XN.C(arguments[0],arguments[1],arguments[2],b)};
t2a=function(a,b){b=$APP.Uc.A(UH(a),new $APP.H(null,2,5,$APP.I,[hI,1],null))?$APP.Uc.A($APP.u(b),0)?$APP.Uc.A($APP.Tc(b),1)?cWa(a.qd):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Vw,null,1,null),$APP.w(b)))),null,1,null),new $APP.D(null,a.qd,null,1,null)))):yD("wrong indices"):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Vw,null,1,null),b))),null,1,null),new $APP.D(null,a.qd,null,1,null))));return UN(b,UH(a),a.domain,
a.range)};u2a=function(a,b,c){return function(){function d(n,p){var v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);$APP.x.B(p,2,null);p=YN.A(v,c);if($APP.k(NF(p)))return n;t=t2a(a,t);return mG.A(n,kG.A(ZN.A?ZN.A(t,b):ZN.call(null,t,b),p))}function g(n){return SH.B($APP.Je.A(a,b),n,c)}var l=null;l=function(n,p){switch(arguments.length){case 0:return 0;case 1:return g.call(this,n);case 2:return d.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.J=function(){return 0};l.j=g;l.A=d;return l}()};
v2a=function(a,b,c){return function(){function d(n,p){var v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);$APP.x.B(p,2,null);return YM(v)&&$APP.Uc.A(c,v.tag)?(p=t2a(a,t),$APP.Vd.A(n,new $APP.H(null,2,5,$APP.I,[v,ZN.A?ZN.A(p,b):ZN.call(null,p,b)],null))):n}function g(n){return t1a(c,$APP.Je.A(a,b),n)}var l=null;l=function(n,p){switch(arguments.length){case 0:return $APP.sf;case 1:return g.call(this,n);case 2:return d.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.J=function(){return $APP.sf};
l.j=g;l.A=d;return l}()};w2a=function(a,b,c,d){d=YM(d)?v2a:NH(d)?u2a:yD("No tape or differential inputs.");var g=mL.C(function(l){return YM(l)?u1a(l,c):NH(l)?RH.A(l,c):l},$APP.y([b]));return $N.A(d.B?d.B(a,g,c):d.call(null,a,g,c),b)};
aO=function(a,b,c,d){if("number"===typeof c)return IF(b)?null:yD(["expected numerical quantity in argument ",$APP.m.j(d)," of function call ",$APP.m.j(a)," but got ",$APP.m.j(b)].join(""));if(XK(c)){(XK(b)||$APP.kd(b))&&$APP.Uc.A(VK(b),VK(c))&&$APP.Uc.A($APP.Tc(b),$APP.Tc(c))||yD(["expected structure matching ",$APP.m.j(c)," but got ",$APP.m.j(b)].join(""));b=$APP.r($APP.Vg.K($APP.M,b,c,$APP.Jj.J()));for(var g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n),v=$APP.x.B(p,0,null);c=$APP.x.B(p,1,null);p=$APP.x.B(p,
2,null);var t=a;p=$APP.Vd.A(d,p);aO.K?aO.K(t,v,c,p):aO.call(null,t,v,c,p);n+=1}else if(b=$APP.r(b))$APP.pd(b)?(p=$APP.lc(b),b=$APP.mc(b),c=p,p=$APP.Tc(p),g=c,l=p):(p=$APP.u(b),v=$APP.x.B(p,0,null),c=$APP.x.B(p,1,null),p=$APP.x.B(p,2,null),g=a,l=v,p=$APP.Vd.A(d,p),aO.K?aO.K(g,l,c,p):aO.call(null,g,l,c,p),b=$APP.w(b),g=null,l=0),n=0;else return null}else return c instanceof $APP.E?$APP.Uc.A(DF(b),c)?null:yD(["expected argument of type ",$APP.m.j(c)," but got ",$APP.m.j(DF(b))," in call to function ",
$APP.m.j(a)].join("")):yD(["unexpected argument example. got ",$APP.m.j(b)," want ",$APP.m.j(c)].join(""))};
ZN=function(a,b){aO(a,b,a.domain,new $APP.H(null,1,5,$APP.I,[0],null));var c=N1a(b),d=$N.A(function(){function g(p,v){v=$APP.x.B(v,0,null);return $APP.Vd.A(p,v)}function l(p){return $APP.Je.A(gN,p)}var n=null;n=function(p,v){switch(arguments.length){case 0:return $APP.sf;case 1:return l.call(this,p);case 2:return g.call(this,p,v)}throw Error("Invalid arity: "+arguments.length);};n.J=function(){return $APP.sf};n.j=l;n.A=g;return n}(),c);return $APP.k(d)?(b=$APP.x.B(d,0,null),d=$APP.x.B(d,1,null),w2a(a,
c,b,d)):SM($APP.T.j($APP.r($APP.N.A(new $APP.D(null,a.qd,null,1,null),$APP.Vg.A(cG,b)))))};x2a=function(){};bO=function(a,b){if(null!=a&&null!=a.$h)a=a.$h(a,b);else{var c=bO[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=bO._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("IFrame.coords-\x3eevent",a);}return a};
cO=function(a,b){if(null!=a&&null!=a.ai)a=a.ai(a,b);else{var c=cO[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=cO._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("IFrame.event-\x3ecoords",a);}return a};y2a=function(a){if(null!=a&&null!=a.Xj)a=a.Id;else{var b=y2a[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=y2a._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IFrame.ancestor-frame",a);}return a};
dO=function(a){if(null!=a&&null!=a.Yj)a=a.name;else{var b=dO[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=dO._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IFrame.frame-name",a);}return a};eO=function(a){if(null!=a&&null!=a.Zj)a=a.params;else{var b=eO[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=eO._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("IFrame.params",a);}return a};
z2a=function(a){return null!=a?$APP.xc===a.Wj?!0:a.$c?!1:$APP.gb(x2a,a):$APP.gb(x2a,a)};B2a=function(a){return $APP.Yj.K(a,$APP.rg,A2a,!0)};C2a=function(a){return A2a.A($APP.ed(a),!1)};E2a=function(a){return D2a.j($APP.ed(a))};F2a=function(a,b){var c=E2a(a);return $APP.k(c)?$APP.Uc.A(c,b)?a:yD(["Someone else owns these coords: ",$APP.m.j(a),$APP.m.j(b)].join("")):$APP.Yj.K(a,$APP.rg,D2a,b)};
I2a=function(a,b){return function(){function c(n,p,v){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof G2a||"undefined"===typeof gO)gO=function(t,A,B,G,J,O,R){this.pf=t;this.yf=A;this.call=B;this.name=G;this.Id=J;this.params=O;this.sk=R;this.O=393216;this.U=0},gO.prototype.da=function(t,A){return new gO(this.pf,this.yf,this.call,this.name,this.Id,this.params,A)},gO.prototype.ba=function(){return this.sk},gO.prototype.Wj=$APP.xc,gO.prototype.Xj=function(){return this.Id},gO.prototype.Yj=
function(){return this.name},gO.prototype.Zj=function(){return this.params},gO.prototype.$h=function(t,A){t=this.pf.B?this.pf.B(this.Id,this,this.params):this.pf.call(null,this.Id,this,this.params);return t.j?t.j(A):t.call(null,A)},gO.prototype.ai=function(t,A){t=this.yf.B?this.yf.B(this.Id,this,this.params):this.yf.call(null,this.Id,this,this.params);return t.j?t.j(A):t.call(null,A)},gO.cb=!0,gO.Ya="emmy.calculus.frame/t_emmy$calculus$frame49168",gO.gb=function(t){return $APP.Vb(t,"emmy.calculus.frame/t_emmy$calculus$frame49168")},
H2a=function(t,A,B,G,J,O,R){return new gO(t,A,B,G,J,O,R)};return new gO(a,b,l,n,p,v,$APP.F)}function d(n,p){return l.B(n,p,$APP.F)}function g(n){return l.B(n,null,$APP.F)}var l=null;l=function(n,p,v){switch(arguments.length){case 1:return g.call(this,n);case 2:return d.call(this,n,p);case 3:return c.call(this,n,p,v)}throw Error("Invalid arity: "+arguments.length);};l.j=g;l.A=d;l.B=c;return l}()};
J2a=function(a,b){a=$APP.r($APP.We.A(a,b));b=null;for(var c=0,d=0;;)if(d<c){var g=b.aa(null,d);$APP.Zt.C($APP.y([dG.j(g)]));d+=1}else if(a=$APP.r(a))b=a,$APP.pd(b)?(a=$APP.lc(b),c=$APP.mc(b),b=a,g=$APP.Tc(a),a=c,c=g):(g=$APP.u(b),$APP.Zt.C($APP.y([dG.j(g)])),a=$APP.w(b),b=null,c=0),d=0;else return null};
K2a=function(a,b){a=$APP.r($APP.We.A(a,b));b=null;for(var c=0,d=0;;)if(d<c){var g=b.aa(null,d);$APP.$A.j(dG.j(g));d+=1}else if(a=$APP.r(a))b=a,$APP.pd(b)?(a=$APP.lc(b),c=$APP.mc(b),b=a,g=$APP.Tc(a),a=c,c=g):(g=$APP.u(b),$APP.$A.j(dG.j(g)),a=$APP.w(b),b=null,c=0),d=0;else return null};L2a=function(a,b){return $APP.Hl.A(b,$APP.Jj.j(a))};M2a=function(a){return function(b,c){return jG.j(b-c)<=.5*a*(2+jG.j(b)+jG.j(c))}};
N2a=function(a,b){return EN.C($APP.y([new $APP.H(null,3,5,$APP.I,[1,0,0],null),new $APP.H(null,3,5,$APP.I,[0,a,TF.j(b)],null),new $APP.H(null,3,5,$APP.I,[0,b,a],null)]))};jO=function(a){return N2a(hO.j(a),iO.j(a))};O2a=function(a,b){return EN.C($APP.y([new $APP.H(null,3,5,$APP.I,[a,0,b],null),new $APP.H(null,3,5,$APP.I,[0,1,0],null),new $APP.H(null,3,5,$APP.I,[TF.j(b),0,a],null)]))};kO=function(a){return O2a(hO.j(a),iO.j(a))};
P2a=function(a,b){return EN.C($APP.y([new $APP.H(null,3,5,$APP.I,[a,TF.j(b),0],null),new $APP.H(null,3,5,$APP.I,[b,a,0],null),new $APP.H(null,3,5,$APP.I,[0,0,1],null)]))};lO=function(a){return P2a(hO.j(a),iO.j(a))};Q2a=function(a,b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);b=mO.j(b);c=tG.A(d,c);return kG.C(lO(c),kO(b),$APP.y([lO(a),yN(kO(b)),yN(lO(c))]))};R2a=function(a){var b=hO.j(a);a=iO.j(a);return IN(iL(nO,3),N2a(b,a),hL($APP.oO,3))};
S2a=function(a){var b=hO.j(a);a=iO.j(a);return IN(iL(nO,3),O2a(b,a),hL($APP.oO,3))};T2a=function(a){var b=hO.j(a);a=iO.j(a);return IN(iL(nO,3),P2a(b,a),hL($APP.oO,3))};U2a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=hO.j(a),l=iO.j(a);return wL.C($APP.y([c,TF.A(kG.A(g,d),kG.A(l,b)),mG.A(kG.A(l,d),kG.A(g,b))]))}};
V2a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=hO.j(a),l=iO.j(a);return wL.C($APP.y([mG.A(kG.A(g,c),kG.A(l,b)),d,TF.A(kG.A(g,b),kG.A(l,c))]))}};W2a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=hO.j(a),l=iO.j(a);return wL.C($APP.y([TF.A(kG.A(g,c),kG.A(l,d)),mG.A(kG.A(l,c),kG.A(g,d)),b]))}};
X2a=function(a){return wL.C($APP.y([$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[1,2],null)),$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[2,0],null)),$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[0,1],null))]))};pO=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return kG.C(lO(c),jO(b),$APP.y([lO(a)]))};Z2a=function(a){return $APP.Uc.A(DF(a),Y2a)};$2a=function(a){return $APP.Uc.A(DF(a),qO)};c3a=function(a){return $APP.am.A(a,new $APP.H(null,2,5,$APP.I,[a3a,b3a],null))};
rO=function(a){return $2a(a)?a:qO.j($APP.ed(a))};tO=function(a,b){return $APP.cm(a,new $APP.H(null,2,5,$APP.I,[sO,b],null),new $APP.f(null,2,[$APP.Q,b,d3a,$APP.F],null))};e3a=function(a){return rD($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[a3a,sO],null)))};h3a=function(a,b){var c=$APP.am.A(a,new $APP.H(null,3,5,$APP.I,[a3a,sO,b],null));if($APP.k(c))return $APP.rg.B(c,f3a,a);throw $APP.Zi.A("Unknown patch.",new $APP.f(null,2,[g3a,b,f3a,a],null));};
uO=function(a,b,c,d){return $APP.cm(a,new $APP.H(null,4,5,$APP.I,[sO,c,d3a,b],null),d)};i3a=function(a){return rD(d3a.j(a))};vO=function(a,b,c){c=h3a(a,c);var d=$APP.am.A(c,new $APP.H(null,2,5,$APP.I,[d3a,b],null));if($APP.k(d))b=d;else throw $APP.Zi.A("Unknown coordinate system.",new $APP.f(null,2,[j3a,b,k3a,c],null));return b.j?b.j(a):b.call(null,a)};n3a=function(a,b){return new $APP.f(null,4,[$APP.Ui,l3a,nUa,a,f3a,b,m3a,$APP.kh.j($APP.F)],null)};
xO=function(a,b,c,d){a=n3a(a,b);b=m3a.j(a);$APP.lh.K(b,$APP.rg,wO.j?wO.j(c):wO.call(null,c),d);return a};yO=function(a){return nUa.j(a)};o3a=function(a){return f3a.j(a)};p3a=function(a){return $APP.Uc.A(DF(a),l3a)};zO=function(a,b){return p3a(a)&&$APP.Uc.A(o3a(a),b)};AO=function(a,b,c){a=m3a.j(a);b=wO.j?wO.j(b):wO.call(null,b);var d=$APP.Fb(a);d=d.j?d.j(b):d.call(null,b);if($APP.k(d))return d;c=mL.C(q1a,$APP.y([c.J?c.J():c.call(null)]));$APP.lh.K(a,$APP.rg,b,c);return c};q3a=function(){};
r3a=function(a,b){if(null!=a&&null!=a.Cc)a=a.Cc(a,b);else{var c=r3a[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=r3a._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICoordinateSystem.check-coordinates",a);}return a};
s3a=function(a,b){if(null!=a&&null!=a.Mc)a=a.Mc(a,b);else{var c=s3a[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=s3a._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICoordinateSystem.check-point",a);}return a};
BO=function(a,b){if(null!=a&&null!=a.Nc)a=a.Nc(a,b);else{var c=BO[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=BO._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICoordinateSystem.coords-\x3epoint",a);}return a};
CO=function(a,b){if(null!=a&&null!=a.Oc)a=a.Oc(a,b);else{var c=CO[$APP.la(null==a?null:a)];if(null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else if(c=CO._,null!=c)a=c.A?c.A(a,b):c.call(null,a,b);else throw $APP.ib("ICoordinateSystem.point-\x3ecoords",a);}return a};wO=function(a){if(null!=a&&null!=a.dd)a=a.id;else{var b=wO[$APP.la(null==a?null:a)];if(null!=b)a=b.j?b.j(a):b.call(null,a);else if(b=wO._,null!=b)a=b.j?b.j(a):b.call(null,a);else throw $APP.ib("ICoordinateSystem.uuid",a);}return a};
t3a=function(a){return null!=a?$APP.xc===a.cd?!0:a.$c?!1:$APP.gb(q3a,a):$APP.gb(q3a,a)};EO=function(a){return DO.j($APP.ed(a))};FO=function(a){return z2a(a)?function(b){return cO(a,b)}:function(b){return CO(a,b)}};GO=function(a){return z2a(a)?function(b){return bO(a,b)}:function(b){return BO(a,b)}};u3a=function(a){return mL.C($APP.Oj,$APP.y([EO(a)]))};v3a=function(a){var b=u3a(a);return BO(a,b)};w3a=function(a,b){rO(a);var c=rO(b);return function(d){return n3a(yO(d),c)}};
x3a=function(a){return mL.C(function(b){return $APP.Zg.j(["v:",$APP.m.j(b)].join(""))},$APP.y([a]))};JO=function(a,b){var c=HO.j(rO(b));c=bL($APP.Vj.A(c,0));return $APP.Yj.C(YH.C($APP.y([VN.B(a,c,0),FO(b)])),$APP.rg,$APP.Q,$APP.Ag,IO,b,$APP.y([$APP.Ui,y3a]))};z3a=function(){return 0};A3a=function(){return 1};B3a=function(a){return function(){return a}};C3a=function(a,b,c){return $APP.Uc.A(a,1)?c.j?c.j(0):c.call(null,0):eL(a,b,c)};
KO=function(a){a=HO.j(a);return C3a(a,UK,function(b){return $APP.Zg.j(["x",$APP.m.j(b)].join(""))})};
F3a=function(a){var b=QF.j(a);return function(){function c(l,n){var p=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof MO)MO=function(v,t,A,B,G,J,O){this.orientation=v;this.fi=t;this.ctor=A;this.Pa=B;this.Ub=G;this.id=J;this.yk=O;this.O=393216;this.U=0},MO.prototype.da=function(v,t){return new MO(this.orientation,this.fi,this.ctor,this.Pa,this.Ub,this.id,t)},MO.prototype.ba=function(){return this.yk},MO.prototype.cd=$APP.xc,
MO.prototype.Cc=function(v,t){return YK(t)&&$APP.Uc.A(NO.j(t),2)&&(!GF(t)||0<=$APP.x.A(t,0))},MO.prototype.Mc=function(v,t){return zO(t,this.Pa)},MO.prototype.Nc=function(v,t){v=$APP.x.B(t,0,null);var A=$APP.x.B(t,1,null);return xO(kG.A(this.orientation,wL.C($APP.y([kG.A(iO.j(v),hO.j(A)),kG.A(iO.j(v),iO.j(A)),hO.j(v)]))),this.Pa,this,t)},MO.prototype.Oc=function(v,t){var A=this;return AO(t,this,function(){var B=kG.A(A.fi,yO(t));if(YK(B)&&$APP.Uc.A(NO.j(B),D3a.j(A.Pa))){var G=$APP.x.B(B,0,null),J=
$APP.x.B(B,1,null);B=$APP.x.B(B,2,null);return wL.C($APP.y([mO.j(B),tG.A(J,G)]))}return yD("S2-coordinates bad point")})},MO.prototype.dd=function(){return this.id},MO.cb=!0,MO.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57430",MO.gb=function(v){return $APP.Vb(v,"emmy.calculus.manifold/t_emmy$calculus$manifold57430")},E3a=function(v,t,A,B,G,J,O){return new MO(v,t,A,B,G,J,O)};return new MO(a,b,g,l,n,p,$APP.F)}(),new $APP.f(null,2,[DO,n,qO,l],null))}function d(l){var n=KO(l);return g.A(l,n)}
var g=null;g=function(l,n){switch(arguments.length){case 1:return d.call(this,l);case 2:return c.call(this,l,n)}throw Error("Invalid arity: "+arguments.length);};g.j=d;g.A=c;return g}()};
H3a=function(a){function b(c){return $APP.N.A(new $APP.de(null,function(){return $APP.Fc(c)},null,null),new $APP.de(null,function(){return new $APP.H(null,1,5,$APP.I,[$APP.u(c)],null)},null,null))}return function(){function c(l,n){var p=HO.j(l),v=function(){var B=p+1;return a.j?a.j(B):a.call(null,B)}(),t=QF.j(v),A=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof OO)OO=function(B,G,J,O,R,W,Z,fa,ia,ja){this.Zd=B;this.ctor=
G;this.Ze=J;this.n=O;this.Pa=R;this.id=W;this.Ed=Z;this.Fd=fa;this.Ub=ia;this.zk=ja;this.O=393216;this.U=0},OO.prototype.da=function(B,G){return new OO(this.Zd,this.ctor,this.Ze,this.n,this.Pa,this.id,this.Ed,this.Fd,this.Ub,G)},OO.prototype.ba=function(){return this.zk},OO.prototype.cd=$APP.xc,OO.prototype.Cc=function(B,G){var J=this;B=NO.j(G);return $APP.Uc.A(J.n,1)&&$APP.Uc.A(B,1)||YK(G)&&$APP.Uc.A(B,J.n)&&$APP.Ge($APP.ip.j(function(O,R){return $APP.Uc.A(O+1,J.n)||!GF(R)||$APP.eb(sG.j(R))}),G)},
OO.prototype.Mc=function(B,G){return zO(G,this.Pa)},OO.prototype.Nc=function(B,G){var J=this;if($APP.Uc.A(J.n,1))B=wL.C($APP.y([hO.j(G),iO.j(G)]));else{var O=$APP.Vg.A(iO,G),R=$APP.Vg.A(hO,G);B=bL(function(){var W=$APP.Vg.A(function(Z){return $APP.Uc.A(Z,J.n)?$APP.Je.A(kG,O):$APP.Je.A(kG,$APP.Yd($APP.x.A(R,Z),$APP.We.A(Z,O)))},$APP.Jj.j(J.n+1));return J.Zd.j?J.Zd.j(W):J.Zd.call(null,W)}())}return xO(kG.A(J.Fd,B),J.Pa,this,G)},OO.prototype.Oc=function(B,G){var J=this;return AO(G,this,function(){function O(ja,
ta){$APP.k(function(){var ua="number"===typeof ja;return ua?(ua="number"===typeof ta)?(ua=MF.j(ja),$APP.k(ua)?MF.j(ta):ua):ua:ua}())&&bH($APP.kw,"emmy.calculus.manifold",866,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["Sn-coordinates singular!"],null)},null),-542701496);return tG.A(ja,ta)}var R=function(){var ja=$APP.Wd(kG.A(J.Ed,yO(G)));return J.Zd.j?J.Zd.j(ja):J.Zd.call(null,ja)}();if($APP.Uc.A(J.n,1))return O($APP.x.A(R,1),$APP.x.A(R,0));for(var W=$APP.u(R),Z=$APP.Fc(R),fa=new $APP.H(null,
1,5,$APP.I,[O($APP.u(R),$APP.Xc(R))],null);;){if($APP.eb($APP.w(Z)))return bL(fa);var ia=lG.j(mG.A(nG.j($APP.u(Z)),nG.j(W)));W=ia;R=$APP.Fc(Z);fa=$APP.Yd(O(ia,$APP.Xc(Z)),fa);Z=R}})},OO.prototype.dd=function(){return this.id},OO.cb=!0,OO.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57440",OO.gb=function(B){return $APP.Vb(B,"emmy.calculus.manifold/t_emmy$calculus$manifold57440")},G3a=function(B,G,J,O,R,W,Z,fa,ia,ja){return new OO(B,G,J,O,R,W,Z,fa,ia,ja)};return new OO(b,g,a,p,l,A,t,v,n,$APP.F)}(),
new $APP.f(null,2,[DO,n,qO,l],null))}function d(l){var n=KO(l);return g.A(l,n)}var g=null;g=function(l,n){switch(arguments.length){case 1:return d.call(this,l);case 2:return c.call(this,l,n)}throw Error("Invalid arity: "+arguments.length);};g.j=d;g.A=c;return g}()};
J3a=function(a){return function(){function b(g,l){var n=HO.j(g),p=function(){var A=n+1;return a.j?a.j(A):a.call(null,A)}(),v=QF.j(p),t=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof PO)PO=function(A,B,G,J,O,R,W,Z,fa){this.Ze=A;this.ctor=B;this.Pa=G;this.Ub=J;this.n=O;this.Fd=R;this.Ed=W;this.id=Z;this.Ak=fa;this.O=393216;this.U=0},PO.prototype.da=function(A,B){return new PO(this.Ze,this.ctor,this.Pa,this.Ub,this.n,this.Fd,
this.Ed,this.id,B)},PO.prototype.ba=function(){return this.Ak},PO.prototype.cd=$APP.xc,PO.prototype.Cc=function(A,B){return $APP.Uc.A(this.n,1)&&$APP.Uc.A(NO.j(B),1)||YK(B)&&$APP.Uc.A(NO.j(B),this.n)},PO.prototype.Mc=function(A,B){return zO(B,this.Pa)},PO.prototype.Nc=function(A,B){var G=this,J=$APP.Uc.A(G.n,1)?wL.C($APP.y([B])):B,O=DH.A(J,J),R=function(){var W=TF.A(O,1),Z=mG.A(1,O);return SF.A?SF.A(W,Z):SF.call(null,W,Z)}();A=eL(G.n+1,UK,function(W){if($APP.Uc.A(W,G.n))return R;W=kG.A(2,$APP.x.A(J,
W));var Z=mG.A(1,O);return SF.A?SF.A(W,Z):SF.call(null,W,Z)});return xO(kG.A(G.Fd,A),G.Pa,this,B)},PO.prototype.Oc=function(A,B){var G=this;return AO(B,this,function(){var J=kG.A(G.Ed,yO(B));GF($APP.x.A(J,G.n))&&$APP.Uc.A($APP.x.A(J,G.n),1)&&zD("S^n stereographic singular");var O=eL(G.n,UK,function(R){R=$APP.x.A(J,R);var W=TF.A(1,$APP.x.A(J,G.n));return SF.A?SF.A(R,W):SF.call(null,R,W)});return $APP.Uc.A(G.n,1)?$APP.u(O):O})},PO.prototype.dd=function(){return this.id},PO.cb=!0,PO.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57448",
PO.gb=function(A){return $APP.Vb(A,"emmy.calculus.manifold/t_emmy$calculus$manifold57448")},I3a=function(A,B,G,J,O,R,W,Z,fa){return new PO(A,B,G,J,O,R,W,Z,fa)};return new PO(a,d,g,l,n,p,v,t,$APP.F)}(),new $APP.f(null,2,[DO,l,qO,g],null))}function c(g){var l=KO(g);return d.A(g,l)}var d=null;d=function(g,l){switch(arguments.length){case 1:return c.call(this,g);case 2:return b.call(this,g,l)}throw Error("Invalid arity: "+arguments.length);};d.j=c;d.A=b;return d}()};
L3a=function(a){return function(){function b(g,l){var n=HO.j(g),p=function(){var A=n+1;return a.j?a.j(A):a.call(null,A)}(),v=QF.j(p),t=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof QO)QO=function(A,B,G,J,O,R,W,Z,fa){this.Ze=A;this.ctor=B;this.Pa=G;this.Ub=J;this.n=O;this.Fd=R;this.Ed=W;this.id=Z;this.Bk=fa;this.O=393216;this.U=0},QO.prototype.da=function(A,B){return new QO(this.Ze,this.ctor,this.Pa,this.Ub,this.n,this.Fd,
this.Ed,this.id,B)},QO.prototype.ba=function(){return this.Bk},QO.prototype.cd=$APP.xc,QO.prototype.Cc=function(A,B){return $APP.Uc.A(this.n,1)&&$APP.Uc.A(NO.j(B),1)||YK(B)&&$APP.Uc.A(NO.j(B),this.n)},QO.prototype.Mc=function(A,B){return zO(B,this.Pa)},QO.prototype.Nc=function(A,B){var G=this,J=$APP.Uc.A(G.n,1)?wL.C($APP.y([B])):B;A=DH.A(J,J);var O=lG.j(mG.A(1,A)),R=SF.A(1,O);A=eL(mG.A(G.n,1),UK,function(W){return $APP.Uc.A(W,G.n)?R:SF.A($APP.x.A(J,W),O)});return xO(kG.A(G.Fd,A),G.Pa,this,J)},QO.prototype.Oc=
function(A,B){var G=this,J=this;return AO(B,J,function(){var O=kG.A(G.Ed,yO(B)),R=$APP.x.A(O,G.n);if($APP.k(function(){var Z=GF(R);return Z?(Z=sG.j(R),$APP.k(Z)?Z:MF.j(R)):Z}()))throw $APP.Zi.A("Point not covered by S^n-gnomic coordinate patch.",new $APP.f(null,2,[$APP.RO,B,IO,J],null));var W=eL(G.n,UK,function(Z){return SF.A($APP.x.A(O,Z),R)});return $APP.Uc.A(G.n,1)?$APP.x.A(W,0):W})},QO.prototype.dd=function(){return this.id},QO.cb=!0,QO.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57458",
QO.gb=function(A){return $APP.Vb(A,"emmy.calculus.manifold/t_emmy$calculus$manifold57458")},K3a=function(A,B,G,J,O,R,W,Z,fa){return new QO(A,B,G,J,O,R,W,Z,fa)};return new QO(a,d,g,l,n,p,v,t,$APP.F)}(),new $APP.f(null,2,[DO,l,qO,g],null))}function c(g){var l=KO(g);return d.A(g,l)}var d=null;d=function(g,l){switch(arguments.length){case 1:return c.call(this,g);case 2:return b.call(this,g,l)}throw Error("Invalid arity: "+arguments.length);};d.j=c;d.A=b;return d}()};
M3a=function(a,b,c,d){return IF(d)?tWa(function(g){g=$APP.cm(b,c,g);return a.j?a.j(g):a.call(null,g)})(d):yD(["non-numerical entry ",$APP.m.j(d)," at path ",$APP.m.j(c)," in input structure ",$APP.m.j(b)].join(""))};N3a=function(a,b,c){var d=$APP.am.A(b,c);return $APP.k(d)?(d=oL(d),kL(function(g,l){l=$APP.hd(c)?l:$APP.Lf.A(c,l);return M3a(a,b,l,g)},d)):yD(["Bad selectors ",$APP.m.j(c)," for structure ",$APP.m.j(b)].join(""))};
O3a=function(a,b){var c=$APP.tf(b);return function(d){return XK(d)?N3a(a,d,c):$APP.hd(c)?tWa(a)(d):yD(["Selectors ",$APP.m.j(c)," not allowed for non-structural input ",$APP.m.j(d)].join(""))}};P3a=function(a,b){return SO(function(c){return O3a(c,b)},a)};Q3a=function(a){return function(b){var c=TO.B,d=qL(a.j?a.j(b):a.call(null,b));var g=UO.j?UO.j(a):UO.call(null,a);g=g.j?g.j(b):g.call(null,b);return c.call(TO,d,g,b)}};WO=function(a){return FK(a)&&$APP.Uc.A(OK.j(JK(a)),VO)};
YO=function(a,b){return LK.B(a,b,new $APP.f(null,4,[OK,VO,$APP.R3a,S3a,vWa,T3a,XO,new $APP.H(null,1,5,$APP.I,[VH],null)],null))};U3a=function(a,b){return function(c){var d=YH,g=d.C,l=kG.A;c=YH.C($APP.y([c,GO(b)]));c=UO.j?UO.j(c):UO.call(null,c);return g.call(d,$APP.y([l.call(kG,c,a),FO(b)]))}};V3a=function(a,b){var c=YH,d=c.C,g=FO(b);a=a.j?a.j(g):a.call(null,g);return d.call(c,$APP.y([a,GO(b)]))};W3a=function(){return z3a};T3a=function(a){return LK.B(W3a,X3a,JK(a))};
S3a=function(a){return WO(a)&&$APP.Uc.A(GK(a),W3a)};Y3a=function(a,b){var c=HO.j(rO(b)),d=$APP.Uc.A(c,1)?0:bL($APP.Vj.A(c,0));c=$APP.Uc.A(c,1)?new $APP.H(null,1,5,$APP.I,[0],null):d;return ZO.B(VN.B(a,d,c),b,a)};Z3a=function(a){return $APP.Zg.j(["d:d",$APP.m.j(a)].join(""))};aP=function(a){return oL(kL(function(b,c){b=Z3a(b);return $APP.Je.K($O,a,b,c)},EO(a)))};
$3a=function(a,b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Iv,null,1,null),$APP.Vg.B(function(d,g){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,cG.j(d),null,1,null),$APP.y([new $APP.D(null,cG.j(g),null,1,null)]))))},$APP.ef(a),$APP.ef(b)))));return YO(function(d){var g=b.j?b.j(d):b.call(null,d);return function(l){return kG.A(g.j?g.j(l):g.call(null,l),a.j?a.j(l):a.call(null,l))}},c)};
a4a=function(a,b){return mL.C(function(c){return c.j?c.j(a):c.call(null,a)},$APP.y([b]))};c4a=function(a,b){return LK.A(function(c){return function(d){var g=YH.C($APP.y([function(){var l=FO(b);return a.j?a.j(l):a.call(null,l)}(),GO(b)]));return kG.A(function(){var l=UO.j?UO.j(c):UO.call(null,c);return l.j?l.j(d):l.call(null,d)}(),g.j?g.j(d):g.call(null,d))}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,b4a,null,1,null),new $APP.D(null,IK(a),null,1,null)))))};
d4a=function(a){return function(b,c){return function(d){return function(g){var l=qG.j(kG.A(b,c));l=l.j?l.j(d):l.call(null,d);g=l.j?l.j(g):l.call(null,g);return HXa(g,a)}}}};e4a=function(a,b){function c(g,l){if($APP.hd(g))return l;var n=$APP.u(g),p=$APP.Fc($APP.Ig.A(function(v){return $APP.qg.A(v,n)},b));g=$APP.Fc(g);return d(l,p,g,g,0)}var d=function A(l,n,p,v,t){return $APP.hd(v)?c(p,l+t):A(l,n,p,$APP.Fc(v),$APP.eb($APP.He($APP.wg([$APP.u(v)]),n))?t+1:t)};return c(a,0)};
f4a=function(a){function b(d,g){if($APP.hd(d))return g;var l=$APP.r(d);d=$APP.u(l);l=$APP.w(l);return c(g,d,l,l,0)}var c=function t(g,l,n,p,v){return $APP.hd(p)?b(n,g+v):t(g,l,n,$APP.Fc(p),$APP.u(p)>=l?v:v+1)};return b(a,0)};g4a=function(a,b){var c=$APP.tf(b);return $APP.Vg.A(function(d){return $APP.C.A(c,d)},a)};
j4a=function(a,b){var c=new $APP.Ac(function(){return $APP.Us},h4a,$APP.fg([$APP.No,$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.ky,$APP.Aj,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[!0,$APP.An,i4a,"cljs/core.cljs",16,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.xx,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.xx,$APP.Yv,$APP.Ew],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.xx,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,
[$APP.xx,$APP.Yv,$APP.Ew],null)),$APP.Cx,$APP.M(null,null)],null),1,1544,1544,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.xx,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.xx,$APP.Yv,$APP.Ew],null)),null,$APP.k($APP.Us)?$APP.Us.Z:null]));return c.A?c.A(a,b):c.call(null,a,b)};
o4a=function(a){function b(B,G){for(;;){var J=l[B]+n[B]|0;if(0>J)n[B]=-n[B]|0,J=G,--B,G=J;else if($APP.Uc.A(J,B+1)){if(0===B)return!1;n[B]=-n[B]|0;J=G+1;--B;G=J}else{var O=G+(B-l[B]);G+=B-J;var R=g[O];g[O]=g[G];g[G]=R;l[B]=J;return!0}}}function c(B){return $APP.Lf.A($APP.sf,B)}var d=$APP.Tc(a),g=$APP.Fi.j(a),l=$APP.pt.A(d,$APP.Vj.j(0)),n=$APP.pt.A(d,$APP.Vj.j(1)),p=$APP.kh.j(c(g)),v=$APP.kh.j(!0),t=function(){if("undefined"===typeof eM||"undefined"===typeof I_a||"undefined"===typeof k4a||"undefined"===
typeof bP)bP=function(B,G,J,O,R,W,Z,fa,ia,ja){this.step=B;this.a=G;this.jh=J;this.o=O;this.Pf=R;this.n=W;this.as=Z;this.Pg=fa;this.c=ia;this.tk=ja;this.O=393216;this.U=131072},bP.prototype.da=function(B,G){return new bP(this.step,this.a,this.jh,this.o,this.Pf,this.n,this.as,this.Pg,this.c,G)},bP.prototype.ba=function(){return this.tk},bP.prototype.hasNext=function(){return $APP.Fb(this.Pg)},bP.prototype.next=function(){var B=$APP.Fb(this.jh),G=this.Pg;var J=this.n-1;J=this.step.A?this.step.A(J,0):
this.step.call(null,J,0);$APP.Ne(G,J);$APP.Ne(this.jh,this.Pf.j?this.Pf.j(this.a):this.Pf.call(null,this.a));return B},bP.prototype.Qa=function(){return this},bP.cb=!0,bP.Ya="emmy.util.permute/t_emmy$util$permute49436",bP.gb=function(B){return $APP.Vb(B,"emmy.util.permute/t_emmy$util$permute49436")},l4a=function(B,G,J,O,R,W,Z,fa,ia,ja){return new bP(B,G,J,O,R,W,Z,fa,ia,ja)};return new bP(b,g,p,n,c,d,a,v,l,$APP.F)}(),A=new $APP.Ac(function(){return $APP.vt},m4a,$APP.fg([$APP.No,$APP.yl,$APP.Q,$APP.Wi,
$APP.Nr,$APP.Aj,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[!0,$APP.An,n4a,"cljs/core.cljs",24,1,4176,4176,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.yya],null)),null,$APP.k($APP.vt)?$APP.vt.Z:null]));return A.j?A.j(t):A.call(null,t)};p4a=function(){return z3a};cP=function(a){if(FK(a)){var b=q4a.j(JK(a));return $APP.k(b)?b:yD(["operator, but not a differential form: ",$APP.m.j(a)].join(""))}return WH(a)?0:yD(["not a differential form: ",$APP.m.j(a)].join(""))};
eP=function(a){var b=FK(a);return b?(a=OK.j(JK(a)),$APP.vh(a,dP)):b};r4a=function(a,b){return eP(a)&&$APP.Uc.A(b,cP(a))};s4a=function(a){return r4a(a,1)};fP=function(a,b,c){if($APP.Uc.A(b,0))return a.J?a.J():a.call(null);var d=$APP.Lf.A($APP.sf,$APP.Vj.A(b,VO));return LK.B(a,c,$APP.Ni.C($APP.y([t4a,new $APP.f(null,4,[OK,dP,ZH,new $APP.H(null,2,5,$APP.I,[hI,b],null),q4a,b,XO,d],null)])))};
hP=function(a,b){return LK.B(a,b,$APP.Ni.C($APP.y([t4a,new $APP.f(null,4,[OK,gP,ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),q4a,1,XO,new $APP.H(null,1,5,$APP.I,[VO],null)],null)])))};u4a=function(a,b){return function(c){return mL.C(function(d){return YH.C($APP.y([kG.A(a,V3a(d,b)),FO(b)]))},$APP.y([c]))}};v4a=function(a,b){var c=aP(b);return YH.C($APP.y([a.j?a.j(c):a.call(null,c),GO(b)]))};
w4a=function(a,b){var c=HO.j(rO(b)),d=$APP.Uc.A(c,1)?0:bL($APP.Vj.A(c,0));c=cL($APP.Vj.A(c,0));return iP.B(VN.B(a,d,c),b,a)};x4a=function(a){return $APP.Zg.j(["d",$APP.m.j(a)].join(""))};kP=function(a){return kL(function(b,c){b=x4a(b);return $APP.Je.K(jP,a,b,c)},EO(a))};z4a=function(a,b){return hP(function(c){return kG.A(a,b.j?b.j(c):b.call(null,c))},y4a)};A4a=function(a,b){return mL.C(a,$APP.y([b]))};
mP=function(a){var b=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.lP,null,1,null),new $APP.D(null,cG.j(a),null,1,null))));return hP(function(c){return mL.C(function(d){return function(g){var l=d.j?d.j(a):d.call(null,a);return l.j?l.j(g):l.call(null,g)}},$APP.y([c]))},b)};
C4a=function(a,b){var c=cP(a),d=cP(b);if(0===c||0===d)return kG.A(a,b);var g=c+d,l=1/(HI(c)*HI(d));d=function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=new $APP.Bc(B,0,null)}return v.call(this,A)}function v(t){return kG.A(l,$APP.Je.A(mG,$APP.Vg.B(function(A,B){var G=$APP.Ye(c,A);A=$APP.x.B(G,0,null);G=$APP.x.B(G,1,null);return kG.C(B,$APP.Je.A(a,A),$APP.y([$APP.Je.A(b,G)]))},o4a(t),$APP.Ve(new $APP.H(null,2,5,$APP.I,
[1,-1],null)))))}p.G=0;p.M=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}();var n=$APP.T.j($APP.r($APP.N.C(new $APP.D(null,B4a,null,1,null),new $APP.D(null,cG.j(a),null,1,null),$APP.y([new $APP.D(null,cG.j(b),null,1,null)]))));return fP(d,g,n)};
E4a=function(a){var b=cP(a);return 0===b?a:fP(function(){function c(g){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new $APP.Bc(n,0,null)}return d.call(this,l)}function d(g){return kG.A(1/HI(b),function(){var l=$APP.Vg.B(function(n,p){return kG.A(p,$APP.Je.A(a,n))},o4a(g),$APP.Ve(new $APP.H(null,2,5,$APP.I,[1,-1],null)));return jL.j?jL.j(l):jL.call(null,l)}())}c.G=0;c.M=function(g){g=$APP.r(g);return d(g)};c.C=d;return c}(),b,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
D4a,null,1,null),new $APP.D(null,cG.j(a),null,1,null)))))};
G4a=function(a,b){var c=cP(a),d=cP(b);return 0===c||0===d?kG.A(a,b):fP(function(){function g(n){var p=null;if(0<arguments.length){p=0;for(var v=Array(arguments.length-0);p<v.length;)v[p]=arguments[p+0],++p;p=new $APP.Bc(v,0,null)}return l.call(this,p)}function l(n){var p=$APP.Ye(c,n);n=$APP.x.B(p,0,null);p=$APP.x.B(p,1,null);return kG.A($APP.Je.A(a,n),$APP.Je.A(b,p))}g.G=0;g.M=function(n){n=$APP.r(n);return l(n)};g.C=l;return g}(),c+d,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,F4a,null,1,null),new $APP.D(null,
cG.j(a),null,1,null),$APP.y([new $APP.D(null,cG.j(b),null,1,null)])))))};nP=function(a){var b=aP(a),c=kP(a);return new $APP.f(null,5,[$APP.Ui,H4a,HO,HO.j(rO(a)),I4a,b,J4a,c,IO,a],null)};K4a=function(a){return $APP.vh(DF(a),H4a)};L4a=function(a){return IO.j(a)};N4a=function(a,b){var c=$APP.Tc($APP.ef(a));return new $APP.f(null,4,[$APP.Ui,M4a,HO,c,I4a,a,J4a,b],null)};O4a=function(a){return $APP.vh(DF(a),M4a)};oP=function(a){return J4a.j(a)};pP=function(a){return I4a.j(a)};P4a=function(a){return HO.j(a)};
rP=function(a,b){var c=pP(b);b=oP(b);return qP.C(a,$APP.y([c,b]))};Q4a=function(a,b){function c(l){var n=qL(d);return sP.B(n,LN.B(n,mL.C(function(p){return p.j?p.j(l):p.call(null,l)},$APP.y([g])),d),d)}var d=EO(b),g=mL.C(function(l){return V3a(l,b)},$APP.y([a]));a=C3a(HO.j(rO(b)),UK,function(l){return $APP.Jl.A(tP.C($APP.y([l])),c)});return mL.C(function(l){return iP.A(l,b)},$APP.y([a]))};
R4a=function(a,b){return function(c){return function(d){var g=pP(a),l=oP(a);return kG.A(g.j?g.j(d):g.call(null,d),mL.C(function(n){return function(){var p=n.j?n.j(c):n.call(null,c);return p.j?p.j(b):p.call(null,b)}},$APP.y([l])))}}};S4a=function(a,b){return mL.C(oP(a),$APP.y([pP(b)]))};T4a=function(a,b){var c=$APP.sf;if(FK(a))return a=JK(a),b.A?b.A(a,c):b.call(null,a,c);a=$APP.ed(a);return b.A?b.A(a,c):b.call(null,a,c)};
U4a=function(a,b){return FK(a)?KK(a,$APP.Je.B($APP.rg,JK(a),b)):$APP.Je.K($APP.Yj,a,$APP.rg,b)};uP=function(a){return T4a(a,XO)};vP=function(a,b){b=$APP.Lf.A($APP.sf,b);return U4a(a,$APP.y([XO,b,ZH,new $APP.H(null,2,5,$APP.I,[hI,$APP.Tc(b)],null)]))};wP=function(a){return T4a(a,V4a)};xP=function(a,b){b=$APP.Lf.A($APP.sf,b);return U4a(a,$APP.y([V4a,b,ZH,new $APP.H(null,2,5,$APP.I,[hI,$APP.Tc(b)],null)]))};
W4a=function(a,b){var c=uP(a),d=pP(b),g=oP(b);b=$APP.Vg.A(function(l){return $APP.vh(l,VO)?yP:zP},c);return xP(function(l){l=$APP.Hl.B(function(n,p){return $APP.vh(n,VO)?$APP.C.A(d,p):$APP.C.A(g,p)},c,l);return $APP.Je.A(a,l)},b)};
X4a=function(a,b){var c=wP(a),d=pP(b),g=oP(b),l=P4a(b),n=$APP.Hl.A(new $APP.f(null,2,[zP,gP,yP,VO],null),c);return vP(function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=new $APP.Bc(B,0,null)}return v.call(this,A)}function v(t){var A=$APP.Wd($APP.Jj.j(l)),B=AP(function(){return function R(O){return new $APP.de(null,function(){for(;;){var W=$APP.r(O);if(W){var Z=W;if($APP.pd(Z)){var fa=$APP.lc(Z),ia=$APP.Tc(fa),ja=
$APP.fe(ia);return function(){for(var ua=0;;)if(ua<ia){var ca=$APP.bd(fa,ua);$APP.je(ja,$APP.Vg.B(function(V,da,Y,ea,ya,wa,Ba,Qa,Va,cb){return function(pb,rb){return new $APP.H(null,2,5,$APP.I,[pb,WO(rb)?function(){var yb=$APP.C.A(cb,pb);return yb.j?yb.j(rb):yb.call(null,rb)}():function(){var yb=$APP.C.A(Va,pb);return rb.j?rb.j(yb):rb.call(null,yb)}()],null)}}(ua,ca,fa,ia,ja,Z,W,A,d,g,l,n,c),A,$APP.Vj.j(ca)));ua+=1}else return!0}()?$APP.ie($APP.ke(ja),R($APP.mc(Z))):$APP.ie($APP.ke(ja),null)}var ta=
$APP.u(Z);return $APP.Yd($APP.Vg.B(function(ua,ca,V,da,Y,ea){return function(ya,wa){return new $APP.H(null,2,5,$APP.I,[ya,WO(wa)?function(){var Ba=$APP.C.A(ea,ya);return Ba.j?Ba.j(wa):Ba.call(null,wa)}():function(){var Ba=$APP.C.A(Y,ya);return wa.j?wa.j(Ba):wa.call(null,Ba)}()],null)}}(ta,Z,W,A,d,g,l,n,c),A,$APP.Vj.j(ta)),R($APP.Fc(Z)))}return null}},null,null)}(t)}()),G=function(){return function R(O){return new $APP.de(null,function(){for(;;){var W=$APP.r(O);if(W){if($APP.pd(W)){var Z=$APP.lc(W),
fa=$APP.Tc(Z),ia=$APP.fe(fa);a:for(var ja=0;;)if(ja<fa){var ta=$APP.bd(Z,ja),ua=$APP.Vg.A($APP.u,ta);ta=$APP.Vg.A($APP.fd,ta);$APP.je(ia,$APP.Je.B(kG,a.j?a.j(ua):a.call(null,ua),$APP.Wd(ta)));ja+=1}else{Z=!0;break a}return Z?$APP.ie($APP.ke(ia),R($APP.mc(W))):$APP.ie($APP.ke(ia),null)}Z=$APP.u(W);ia=$APP.Vg.A($APP.u,Z);Z=$APP.Vg.A($APP.fd,Z);return $APP.Yd($APP.Je.B(kG,a.j?a.j(ia):a.call(null,ia),$APP.Wd(Z)),R($APP.Fc(W)))}return null}},null,null)}(B)}();return jL.j?jL.j(G):jL.call(null,G)}p.G=0;
p.M=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}(),n)};
Y4a=function(a,b){var c=wP(a),d=wP(b);c=$APP.Kg(c);c=$APP.qe(c);var g=$APP.C.A(c,zP);c=$APP.C.A(c,yP);d=$APP.Kg(d);var l=$APP.qe(d);d=$APP.C.A(l,zP);l=$APP.C.A(l,yP);var n=mG.A($APP.k(g)?g:0,$APP.k(d)?d:0);d=mG.A($APP.k(c)?c:0,$APP.k(l)?l:0);var p=mG.A(n,d),v=mG.A(n,c);return xP(function(t){var A=$APP.Lf.A($APP.sf,t);return kG.A(function(){var B=$APP.Lf.A($APP.pi.B(A,0,g),$APP.pi.B(A,n,v));return a.j?a.j(B):a.call(null,B)}(),function(){var B=$APP.Lf.A($APP.pi.B(A,g,n),$APP.pi.B(A,v,p));return b.j?
b.j(B):b.call(null,B)}())},$APP.N.A($APP.Vj.A(n,zP),$APP.Vj.A(d,yP)))};Z4a=function(a,b,c){var d=$APP.pi.B(a,0,b);a=$APP.pi.A(a,b);return $APP.Je.K($APP.Vd,d,c,a)};
$4a=function(a,b,c,d){var g=wP(a);g=$APP.Kg(g);var l=$APP.qe(g);g=$APP.C.A(l,zP);l=$APP.C.A(l,yP);var n=g-1;g=l-1;return xP(function(p){function v(A){A=$APP.N.A(Z4a($APP.pi.B(t,0,n),b,A),Z4a($APP.pi.A(t,n),c,A));return a.j?a.j(A):a.call(null,A)}var t=$APP.Lf.A($APP.sf,p);return jL.B?jL.B(v,0,d):jL.call(null,v,0,d)},$APP.N.A($APP.Vj.A(n,zP),$APP.Vj.A(g,yP)))};
a5a=function(a,b){var c=pP(b),d=oP(b);return function p(l,n){if($APP.hd(l))return $APP.Je.A(a,n);l=$APP.r(l);var v=$APP.u(l),t=$APP.w(l);return mL.C(function(A){return p(t,$APP.Vd.A(n,A))},$APP.y([$APP.vh(v,VO)?c:$APP.vh(v,gP)?d:yD(["Invalid argument type: ",$APP.jh.C($APP.y([v])),". Every arg must be a vector field or oneform field."].join(""))]))}(uP(a),$APP.sf)};
b5a=function(a,b){var c=pP(b),d=oP(b),g=function(){for(var l=a,n=$APP.sf;;)if(XK(l)){var p=function(){var A=VK(l);return BP.j?BP.j(A):BP.call(null,A)}(),v=function(){var A=p;A=A instanceof $APP.E?A.ga:null;switch(A){case "emmy.structure/up":return VO;case "emmy.structure/down":return gP;default:throw Error(["No matching clause: ",$APP.m.j(A)].join(""));}}(),t=$APP.x.A(l,0);n=$APP.Vd.A(n,v);l=t}else return n}();return vP(function(){function l(p){var v=null;if(0<arguments.length){v=0;for(var t=Array(arguments.length-
0);v<t.length;)t[v]=arguments[v+0],++v;v=new $APP.Bc(t,0,null)}return n.call(this,v)}function n(p){return kG.A(function B(t,A){if($APP.hd(t))return A3a;var G=$APP.u(t),J=$APP.u(A);return $APP.vh(J,VO)?mL.C(function(O){return kG.A(O.j?O.j(G):O.call(null,G),B($APP.Fc(t),$APP.Fc(A)))},$APP.y([d])):$APP.vh(J,gP)?mL.C(function(O){return kG.A(G.j?G.j(O):G.call(null,O),B($APP.Fc(t),$APP.Fc(A)))},$APP.y([c])):null}(p,g),a)}l.G=0;l.M=function(p){p=$APP.r(p);return n(p)};l.C=n;return l}(),g)};
c5a=function(a){return function(b){return YH.C($APP.y([b,a]))}};d5a=function(a){return function(b){return YH.C($APP.y([b,a]))}};CP=function(a){return function(b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.lP,null,1,null),new $APP.D(null,cG.j(a),null,1,null)))),null,1,null),new $APP.D(null,cG.j(b),null,1,null))));return YO(function(d){d=YH.C($APP.y([d,a]));return b.j?b.j(d):b.call(null,d)},c)}};
f5a=function(a,b){return function(c){var d=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,e5a,null,1,null),new $APP.D(null,cG.j(a),null,1,null)))),null,1,null),new $APP.D(null,cG.j(c),null,1,null))));return YO(function(g){var l=YH,n=l.C;g=YH.C($APP.y([g,a]));g=c.j?c.j(g):c.call(null,g);return n.call(l,$APP.y([g,b]))},d)}};
g5a=function(a,b,c){var d=HO.j(rO(b)),g=HO.j(rO(c));d=$APP.Uc.A(d,1)?0:bL($APP.Vj.A(d,0));g=bL($APP.Vj.A(g,0));return YH.C($APP.y([GO(c),VN.B(a,d,g),FO(b)]))};i5a=function(a){return function(b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,h5a,null,1,null),new $APP.D(null,cG.j(a),null,1,null)))),null,1,null),new $APP.D(null,cG.j(b),null,1,null))));return YO(function(d){return YH.C($APP.y([b.j?b.j(d):b.call(null,d),a]))},c)}};
DP=function(a){return function(b){function c(n,p){return YO(function(v){return function(){var t=n.j?n.j(v):n.call(null,v);return t.j?t.j(p):t.call(null,p)}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,j5a,null,1,null),new $APP.D(null,cG.j(n),null,1,null)))))}var d=function(){function n(v){var t=null;if(0<arguments.length){t=0;for(var A=Array(arguments.length-0);t<A.length;)A[t]=arguments[t+0],++t;t=new $APP.Bc(A,0,null)}return p.call(this,t)}function p(v){return function(t){var A=a.j?a.j(t):a.call(null,
t),B=$APP.Je.A(b,$APP.Vg.A(function(G){return c(G,t)},v));return B.j?B.j(A):B.call(null,A)}}n.G=0;n.M=function(v){v=$APP.r(v);return p(v)};n.C=p;return n}(),g=cP(b),l=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,k5a,null,1,null),new $APP.D(null,cG.j(a),null,1,null)))),null,1,null),new $APP.D(null,cG.j(b),null,1,null))));return fP(d,g,l)}};l5a=function(a,b){var c=pP(b);b=oP(b);return N4a(mL.C(i5a(a),$APP.y([c])),mL.C(DP(a),$APP.y([b])))};
n5a=function(a){return function(b){var c=cP(b);if(0===c)return c5a(a)(b);var d=function(){function l(p){var v=null;if(0<arguments.length){v=0;for(var t=Array(arguments.length-0);v<t.length;)t[v]=arguments[v+0],++v;v=new $APP.Bc(t,0,null)}return n.call(this,v)}function n(p){return $APP.Je.A(DP(a)(b),$APP.Vg.A(CP.j?CP.j(a):CP.call(null,a),p))}l.G=0;l.M=function(p){p=$APP.r(p);return n(p)};l.C=n;return l}(),g=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,m5a,null,
1,null),new $APP.D(null,cG.j(a),null,1,null)))),null,1,null),new $APP.D(null,cG.j(b),null,1,null))));return fP(d,c,g)}};o5a=function(a,b){return f5a(b,a)};q5a=function(a){return LK.A(function(b){return kG.A(UO.j?UO.j(b):UO.call(null,b),a)},new $APP.D(null,p5a,new $APP.D(null,cG.j(a),null,1,null),2,null))};
s5a=function(a){return function(b){var c=cP(b);return fP(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return $APP.Je.B(b,a,l)}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),c-1,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,r5a,null,1,null),new $APP.D(null,cG.j(a),null,1,null)))),null,1,null),new $APP.D(null,
cG.j(b),null,1,null)))))}};GP=function(a,b){return new $APP.f(null,3,[$APP.Ui,t5a,EP,a,FP,b],null)};u5a=function(a){return $APP.Uc.A(DF(a),t5a)};HP=function(a){return EP.j(a)};IP=function(a){return FP.j(a)};JP=function(a,b){return new $APP.f(null,3,[$APP.Ui,v5a,w5a,a,FP,b],null)};x5a=function(a){return $APP.Uc.A(DF(a),v5a)};y5a=function(a){return w5a.j(a)};z5a=function(a){return FP.j(a)};A5a=function(a){var b=IP(a);a=HP(a);return JP(mL.C(a,$APP.y([pP(b)])),b)};
B5a=function(a){var b=z5a(a);a=y5a(a);return GP(kG.A(a,oP(b)),b)};C5a=function(a){var b=y5a(a);return JP(kG.A(SF.A(1,2),mG.A(b,SZa(b))),z5a(a))};D5a=function(a){return B5a(C5a(A5a(a)))};F5a=function(a,b){var c=IP(a),d=HP(a);a=oP(b);var g=pP(b),l=pP(c);c=oP(c);var n=mL.C(c,$APP.y([g])),p=mL.C(a,$APP.y([l]));c=hP(function(v){return mG.A(kG.A(p,v.j?v.j(n):v.call(null,n)),kG.A(p,kG.A(d.j?d.j(v):d.call(null,v),n)))},E5a);return GP(c,b)};
G5a=function(a,b){var c=l5a(b,IP(a));a=mL.C(DP(b),$APP.y([HP(a)]));return GP(a,c)};
H5a=function(a){var b=IP(a),c=HP(a),d=pP(b),g=oP(b);return function(l){var n=c.j?c.j(l):c.call(null,l);return function(p){var v=g.j?g.j(p):g.call(null,p),t=mG.A(l.j?l.j(v):l.call(null,v),kG.A(n,v));return YO(function(A){return kG.A(d.j?d.j(A):d.call(null,A),t)},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,KP,null,1,null),new $APP.D(null,cG.j(l),null,1,null)))),null,1,null),new $APP.D(null,cG.j(p),null,1,null)))))}}};
I5a=function(a){return function(b){return function(c){var d=cP(c),g=H5a(a)(b),l=function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=new $APP.Bc(B,0,null)}return v.call(this,A)}function v(t){var A=$APP.Lf.A($APP.sf,t);return TF.A(function(){var B=$APP.Je.A(c,A);return b.j?b.j(B):b.call(null,B)}(),function(){function B(G){G=$APP.Gj.B(A,G,g);return $APP.Je.A(c,G)}return jL.B?jL.B(B,0,d):jL.call(null,B,0,d)}())}p.G=0;
p.M=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}(),n=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,KP,null,1,null),new $APP.D(null,cG.j(b),null,1,null)))),null,1,null),new $APP.D(null,cG.j(c),null,1,null))));return fP(l,d,n)}}};
J5a=function(a){var b=IP(a),c=pP(b),d=oP(b),g=HP(a);return function(l){var n=g.j?g.j(l):g.call(null,l);return function(p){var v=uP(p),t=function R(B,G,J,O){return $APP.hd(B)?kG.A(function(){var W=$APP.Je.A(p,J);return l.j?l.j(W):l.call(null,W)}(),$APP.Je.A(kG,O)):rP(function(W,Z){return $APP.vh($APP.u(B),VO)?R($APP.Fc(B),$APP.Fc(G),$APP.Vd.A(J,W),$APP.Vd.A(O,function(){var fa=$APP.u(G);return Z.j?Z.j(fa):Z.call(null,fa)}())):$APP.vh($APP.u(B),gP)?R($APP.Fc(B),$APP.Fc(G),$APP.Vd.A(J,Z),$APP.Vd.A(O,
function(){var fa=$APP.u(G);return fa.j?fa.j(W):fa.call(null,W)}())):null},b)};return vP(function(){function B(J){var O=null;if(0<arguments.length){O=0;for(var R=Array(arguments.length-0);O<R.length;)R[O]=arguments[O+0],++O;O=new $APP.Bc(R,0,null)}return G.call(this,O)}function G(J){var O=$APP.Lf.A($APP.sf,J);J=t(v,O,$APP.sf,$APP.sf);var R=function(){var W=$APP.ip.A(function(Z,fa){return $APP.vh(fa,gP)?kG.A(kG.A(mL.C(function(ia){var ja=$APP.x.A(O,Z);return ja.j?ja.j(ia):ja.call(null,ia)},$APP.y([c])),
n),mL.C(function(ia){return $APP.Je.A(p,$APP.rg.B(O,Z,ia))},$APP.y([d]))):$APP.vh(fa,VO)?RF.j(kG.A(mL.C(function(ia){return $APP.Je.A(p,$APP.rg.B(O,Z,ia))},$APP.y([c])),kG.A(n,mL.C(function(ia){var ja=$APP.x.A(O,Z);return ia.j?ia.j(ja):ia.call(null,ja)},$APP.y([d]))))):null},v);return jL.j?jL.j(W):jL.call(null,W)}();return mG.A(J,R)}B.G=0;B.M=function(J){J=$APP.r(J);return G(J)};B.C=G;return B}(),v)}}};
K5a=function(a){return function(b){return function(c){return function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){var n=$APP.Je.A(LP,l);if($APP.Uc.A($APP.Tc(l),1)&&p3a($APP.u(l))){var p=vP(c,n);l=$APP.u(l);n=b.j?b.j(p):b.call(null,p);return n.j?n.j(l):n.call(null,l)}return $APP.Ge(function(v){return WO(v)||s4a(v)},l)?(p=vP(c,n),$APP.Je.A(function(){var v=J5a(a)(b);
return v.j?v.j(p):v.call(null,p)}(),l)):yD("Bad function or arguments to covariant derivative")}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}()}}};
L5a=function(a){return function(b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,KP,null,1,null),new $APP.D(null,cG.j(b),null,1,null))));return LK.A(function l(g){if(WO(g)){var n=H5a(a)(b);return n.j?n.j(g):n.call(null,g)}return eP(g)?(n=I5a(a)(b),n.j?n.j(g):n.call(null,g)):$APP.vd($APP.r(uP(g)))?(n=J5a(a)(b),n.j?n.j(g):n.call(null,g)):WH(g)?(n=K5a(a)(b),n.j?n.j(g):n.call(null,g)):XK(g)?mL.C(l,$APP.y([g])):wD(["Can't do this kind of covariant derivative yet ",$APP.m.j(cG.j(b))," @ ",$APP.m.j(cG.j(g))].join(""))},
c)}};M5a=function(a){return function(b){return function(c){c=MP.j(a)(c);return c.j?c.j(b):c.call(null,b)}}};N5a=function(a,b,c){return function(d){return function(g){var l=aP(a);var n=FO(b);var p=CP.j?CP.j(d):CP.call(null,d);p=p.j?p.j(l):p.call(null,l);l=MP.A(c,d)(l);l=l.j?l.j(p):l.call(null,p);n=l.j?l.j(n):l.call(null,n);return n.j?n.j(g):n.call(null,g)}}};
O5a=function(a,b,c){return function(d){return function(g){return function(l){var n=aP(a);var p=FO(b);n=MP.A(c,d)(n);n=n.j?n.j(g):n.call(null,g);p=n.j?n.j(p):n.call(null,p);return p.j?p.j(l):p.call(null,l)}}}};P5a=function(a){var b=EO(a);return kL(function(c,d){return $APP.z(function(g){return $APP.am.A(CO(a,g),d)},new $APP.f(null,1,[$APP.Q,c],null))},b)};
Q5a=function(a){return function d(c){var g;if(g=$APP.kd(c)){g=$APP.u(c);var l=new $APP.ug(null,new $APP.f(null,2,[yP,"null",zP,"null"],null),null);g=l.j?l.j(g):l.call(null,g)}return $APP.k(g)?(g=$APP.u(c),g=$APP.Uc.A(g,zP)?NP:OP,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,g,null,1,null),$APP.Vg.A(d,$APP.Fc(c)))))):$APP.od(c)?$APP.Hl.A(d,c):c instanceof $APP.q?new $APP.D(null,$APP.K,new $APP.D(null,c,null,1,null),2,null):yD("Invalid coordinate prototype")}(a)};
R5a=function(a,b){function c(g,l){return YH.C($APP.y([function(n){return $APP.C.A(n,l)},g]))}var d=UO.j?UO.j(b):UO.call(null,b);return $APP.Uc.A(a,1)?SN.C($APP.y([SN.C($APP.y([DH.A(d,d)]))])):eL(a,ZK,function(g){return eL(a,ZK,function(l){return DH.A(c(d,g),c(d,l))})})};PP=function(a){var b=HO.j(rO(a));a=YH.C($APP.y([yO,GO(a)]));return R5a(b,a)};
S5a=function(a){var b=nP(a),c=oP(b),d=PP(a),g=FO(a);return vP(function(l,n){return function(p){var v=function(){var t=g(p);return d.j?d.j(t):d.call(null,t)}();return kG.A(kG.A(v,function(){var t=c.j?c.j(l):c.call(null,l);return t.j?t.j(p):t.call(null,p)}()),function(){var t=c.j?c.j(n):c.call(null,n);return t.j?t.j(p):t.call(null,p)}())}},new $APP.H(null,2,5,$APP.I,[VO,VO],null))};
T5a=function(a){var b=nP(a),c=pP(b),d=SF.A(1,PP(a)),g=FO(a);return vP(function(l,n){return function(p){var v=function(){var t=g(p);return d.j?d.j(t):d.call(null,t)}();return kG.A(kG.A(v,mL.C(function(t){t=l.j?l.j(t):l.call(null,t);return t.j?t.j(p):t.call(null,p)},$APP.y([c]))),mL.C(function(t){t=n.j?n.j(t):n.call(null,t);return t.j?t.j(p):t.call(null,p)},$APP.y([c])))}},new $APP.H(null,2,5,$APP.I,[gP,gP],null))};
U5a=function(a,b){return function l(d,g){return d<=g?JO($APP.Zg.j([$APP.m.j(a),"_",$APP.m.j(d),$APP.m.j(g)].join("")),b):l(g,d)}};V5a=function(a,b){var c=nP(b),d=oP(c),g=U5a(a,b),l=NO.j(d),n=eL(l,ZK,function(p){return eL(l,ZK,function(v){return g(p,v)})});return vP(function(p,v){return kG.A(kG.A(n,d.j?d.j(p):d.call(null,p)),d.j?d.j(v):d.call(null,v))},new $APP.H(null,2,5,$APP.I,[VO,VO],null))};
W5a=function(a,b){var c=oP(b);return function(d,g){return kG.A(c.j?c.j(d):c.call(null,d),kG.A(a,c.j?c.j(g):c.call(null,g)))}};X5a=function(a,b){var c=pP(b);return mL.C(function(d){return mL.C(function(g){return a.A?a.A(d,g):a.call(null,d,g)},$APP.y([c]))},$APP.y([c]))};Y5a=function(a,b){return function(c){var d=X5a(a,b);c=d.j?d.j(c):d.call(null,c);d=oP(b);d=nL(d);return LN.B(d,c,d)}};
QP=function(a,b){return vP(function(c,d){var g=pP(b);return kG.A(kG.A(Y5a(a,b),mL.C(c,$APP.y([g]))),mL.C(d,$APP.y([g])))},new $APP.H(null,2,5,$APP.I,[gP,gP],null))};
Z5a=function(a,b){function c(d,g){return YO(function(l){return function(){var n=d.j?d.j(l):d.call(null,l);return n.j?n.j(g):n.call(null,g)}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,j5a,null,1,null),new $APP.D(null,cG.j(d),null,1,null)))))}return vP(function(d,g){return function(l){var n=a.j?a.j(l):a.call(null,l);var p=c(d,l);l=c(g,l);p=b.A?b.A(p,l):b.call(null,p,l);return p.j?p.j(n):p.call(null,n)}},new $APP.H(null,2,5,$APP.I,[VO,VO],null))};
RP=function(a){return function(b){return hP(function(c){return a.A?a.A(c,b):a.call(null,c,b)},$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$5a,null,1,null),new $APP.D(null,cG.j(b),null,1,null),$APP.y([new $APP.D(null,cG.j(a),null,1,null)])))))}};
SP=function(a,b){var c=QP(a,b);return function(d){var g=rP(function(l,n){return kG.A(c.A?c.A(d,n):c.call(null,d,n),l)},b);return YO(g,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,a6a,null,1,null),new $APP.D(null,cG.j(d),null,1,null),$APP.y([new $APP.D(null,cG.j(a),null,1,null)])))))}};
b6a=function(a,b){return function(c){return vP(function(d,g){return rP(function(l,n){return rP(function(p,v){return kG.C(a.A?a.A(d,l):a.call(null,d,l),c.A?c.A(n,v):c.call(null,n,v),$APP.y([a.A?a.A(p,g):a.call(null,p,g)]))},b)},b)},new $APP.H(null,2,5,$APP.I,[VO,VO],null))}};
c6a=function(a,b){var c=QP(a,b);return function(d){return vP(function(g,l){return rP(function(n,p){return rP(function(v,t){return kG.C(c.A?c.A(g,p):c.call(null,g,p),d.A?d.A(n,v):d.call(null,n,v),$APP.y([c.A?c.A(t,l):c.call(null,t,l)]))},b)},b)},new $APP.H(null,2,5,$APP.I,[gP,gP],null))}};
d6a=function(a,b){var c=QP(a,b);return function(d){var g=rP(function(l,n){return rP(function(p,v){return kG.A(c.A?c.A(n,v):c.call(null,n,v),d.A?d.A(l,p):d.call(null,l,p))},b)},b);return vP(g,new $APP.H(null,1,5,$APP.I,[VH],null))}};e6a=function(a,b){return function(c){var d=rP(function(g,l){return rP(function(n,p){return kG.A(a.A?a.A(g,n):a.call(null,g,n),c.A?c.A(l,p):c.call(null,l,p))},b)},b);return vP(d,new $APP.H(null,1,5,$APP.I,[VH],null))}};
f6a=function(a,b,c){var d=Y5a(a,b)(c),g=pP(b);return function(l){var n=mL.C(function(p){p=l.j?l.j(p):l.call(null,p);return p.j?p.j(c):p.call(null,c)},$APP.y([g]));n=kG.A(d,n);return qP.C(kG,$APP.y([n,g]))}};h6a=function(a,b){return new $APP.f(null,3,[$APP.Ui,g6a,w5a,a,FP,b],null)};
i6a=function(a,b){var c=pP(b),d=SF.A(1,2);return h6a(mL.C(function(g){return mL.C(function(l){return mL.C(function(n){return kG.A(d,TF.A(mG.A(function(){var p=a.A?a.A(n,l):a.call(null,n,l);return g.j?g.j(p):g.call(null,p)}(),function(){var p=a.A?a.A(n,g):a.call(null,n,g);return l.j?l.j(p):l.call(null,p)}()),function(){var p=a.A?a.A(l,g):a.call(null,l,g);return n.j?n.j(p):n.call(null,p)}()))},$APP.y([c]))},$APP.y([c]))},$APP.y([c])),b)};
j6a=function(a,b){var c=$H($APP.Jl.A($H,a)),d=QP(c,b),g=pP(b),l=oP(b),n=SF.A(1,2);return JP(mL.C(function(p){return mL.C(function(v){return mL.C(function(t){return rP(function(A,B){return kG.A(d.A?d.A(t,B):d.call(null,t,B),kG.A(n,TF.A(mG.A(function(){var G=c.A?c.A(A,v):c.call(null,A,v);return p.j?p.j(G):p.call(null,G)}(),function(){var G=c.A?c.A(A,p):c.call(null,A,p);return v.j?v.j(G):v.call(null,G)}()),function(){var G=c.A?c.A(v,p):c.call(null,v,p);return A.j?A.j(G):A.call(null,G)}())))},b)},$APP.y([l]))},
$APP.y([g]))},$APP.y([g])),b)};k6a=function(a,b,c){function d(p){p=fL.j?fL.j(p):fL.call(null,p);return $APP.k(p)?p:yD(["Bad scripts: ",$APP.m.j(b)].join(""))}var g=$APP.x.B(b,0,null),l=$APP.x.B(b,1,null),n=$APP.x.B(b,2,null);return eL(c,g,function(p){return eL(c,l,function(v){return eL(c,n,function(t){return $APP.Zg.j([$APP.m.j(a),$APP.m.j(d(g)),$APP.m.j(p),$APP.m.j(v),$APP.m.j(d(n)),$APP.m.j(t)].join(""))})})})};
l6a=function(a,b){var c=HO.j(rO(b));return h6a(mL.C(function(d){return JO(d,b)},$APP.y([k6a(a,new $APP.H(null,3,5,$APP.I,[ZK,ZK,ZK],null),c)])),nP(b))};m6a=function(a,b){var c=HO.j(rO(b));return JP(mL.C(function(d){return JO(d,b)},$APP.y([k6a(a,new $APP.H(null,3,5,$APP.I,[ZK,ZK,UK],null),c)])),nP(b))};n6a=function(a,b){return B5a(m6a(a,b))};TP=function(a,b,c,d,g){return rP(function(l,n){var p=kG.A;l=g.A?g.A(c,l):g.call(null,c,l);var v=PK(a,b);n=n.j?n.j(v):n.call(null,v);return p.call(kG,l,n)},d)};
o6a=function(a,b){var c=pP(b),d=SF.A(1,2);return JP(mL.C(function(g){return mL.C(function(l){return mL.C(function(n){return kG.A(d,mG.A(TF.A(mG.A(function(){var p=a.A?a.A(n,l):a.call(null,n,l);return g.j?g.j(p):g.call(null,p)}(),function(){var p=a.A?a.A(n,g):a.call(null,n,g);return l.j?l.j(p):l.call(null,p)}()),function(){var p=a.A?a.A(l,g):a.call(null,l,g);return n.j?n.j(p):n.call(null,p)}()),TF.A(mG.A(TP(n,l,g,b,a),TP(n,g,l,b,a)),TP(l,g,n,b,a))))},$APP.y([c]))},$APP.y([c]))},$APP.y([c])),b)};
p6a=function(a,b){var c=pP(b),d=oP(b),g=QP(a,b),l=SF.A(1,2);return JP(mL.C(function(n){return mL.C(function(p){return mL.C(function(v){return rP(function(t,A){return kG.A(g.A?g.A(v,A):g.call(null,v,A),kG.A(l,mG.A(TF.A(mG.A(function(){var B=a.A?a.A(t,p):a.call(null,t,p);return n.j?n.j(B):n.call(null,B)}(),function(){var B=a.A?a.A(t,n):a.call(null,t,n);return p.j?p.j(B):p.call(null,B)}()),function(){var B=a.A?a.A(p,n):a.call(null,p,n);return t.j?t.j(B):t.call(null,B)}()),TF.A(mG.A(TP(t,p,n,b,a),TP(t,
n,p,b,a)),TP(p,n,t,b,a)))))},b)},$APP.y([d]))},$APP.y([c]))},$APP.y([c])),b)};q6a=function(a){return function(b,c){var d=TF.A,g=PK(a.j?a.j(b):a.call(null,b),a.j?a.j(c):a.call(null,c));b=PK(b,c);b=a.j?a.j(b):a.call(null,b);return d.call(TF,g,b)}};r6a=function(a){return vP(function(b,c,d,g){d=q6a(a)(d,g);c=d.j?d.j(c):d.call(null,c);return b.j?b.j(c):b.call(null,c)},new $APP.H(null,4,5,$APP.I,[gP,VO,VO,VO],null))};
s6a=function(a,b){return vP(function(c,d){return rP(function(g,l){var n=r6a(a);return n.K?n.K(l,c,g,d):n.call(null,l,c,g,d)},b)},new $APP.H(null,2,5,$APP.I,[VO,VO],null))};t6a=function(a){return function(b,c){return mG.C(function(){var d=a.j?a.j(b):a.call(null,b);return d.j?d.j(c):d.call(null,c)}(),kG.A(-1,function(){var d=a.j?a.j(c):a.call(null,c);return d.j?d.j(b):d.call(null,b)}()),$APP.y([kG.A(-1,PK(b,c))]))}};
u6a=function(a){return vP(function(b,c,d){c=t6a(a)(c,d);return b.j?b.j(c):b.call(null,c)},new $APP.H(null,3,5,$APP.I,[gP,VO,VO],null))};v6a=function(a,b){var c=aP(b),d=kP(b);b=GO(b)(wL.C($APP.y([$APP.Yv,$APP.UP,$APP.VP])));d=mL.C(function(g){return mL.C(function(l){return mL.C(function(n){return mL.C(function(p){p=q6a(a)(n,p);p=p.j?p.j(l):p.call(null,l);return g.j?g.j(p):g.call(null,p)},$APP.y([c]))},$APP.y([c]))},$APP.y([c]))},$APP.y([d]));return d.j?d.j(b):d.call(null,b)};
w6a=function(a,b){function c(p){return kG.A(SF.A(1,lG.j(lG.j(nG.j(b.A?b.A(p,p):b.call(null,p,p))))),p)}a=$APP.ef(a);for(var d=c($APP.u(a)),g=$APP.Fc(a),l=new $APP.H(null,1,5,$APP.I,[d],null);;){if($APP.hd(g))return cL(l);var n=$APP.Fc(g);l=$APP.Vd.A(l,c(TF.A($APP.u(g),$APP.Je.A(mG,$APP.Vg.A(function(p){return function(v){var t=kG.A;var A=$APP.u(p);A=b.A?b.A(A,v):b.call(null,A,v);return t.call(kG,A,v)}}(g,l,a,d),l)))));g=n}};x6a=function(a,b,c){a=w6a(pP(a),b);return N4a(a,Q4a(a,c))};
y6a=function(a,b){return YH.C($APP.y([SP(a,b),WP]))};z6a=function(a,b){var c=XP(a,b);b=SP(a,b);return YH.C($APP.y([b,c,WP,RP(a)]))};A6a=function(a,b){return YH.C($APP.y([YP.A(a,b),y6a(a,b)]))};B6a=function(a){var b=PP(a);a=HO.j(rO(a));return eL(a,ZK,function(c){return lG.j($APP.am.A(b,new $APP.H(null,2,5,$APP.I,[c,c],null)))})};F6a=function(a,b){return $APP.z(new $APP.H(null,2,5,$APP.I,[b,null],null),new $APP.f(null,3,[C6a,$APP.td,D6a,$APP.Kd,E6a,a],null))};
G6a=function(a){return F6a(function(b,c){return $APP.z(c,$APP.ed(b))},a)};ZP=function(a){return a.j?a.j(0):a.call(null,0)};$P=function(a){var b=ZP(a);a=C6a.j($APP.ed(a));return a.j?a.j(b):a.call(null,b)};H6a=function(a){return $APP.aQ.j(a.j?a.j(1):a.call(null,1))};
cQ=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.qe(c),g=$APP.C.A(d,bQ);c=$APP.C.A(d,I6a);var l=$APP.C.A(d,J6a),n=$APP.C.A(d,$APP.aQ);d=$APP.C.A(d,K6a);return $APP.k(l)?(l=$APP.fd(l),$APP.k(d)?(d=$APP.I,b=$APP.N.A(g,$APP.Yd(b,n)),g=E6a.j($APP.ed(a)),b=g.A?g.A(l,b):g.call(null,l,b),c=new $APP.H(null,2,5,d,[b,$APP.k(c)?$APP.rg.B(c,K6a,!0):c],null)):c=new $APP.H(null,2,5,$APP.I,[l,c],null),$APP.z(c,$APP.ed(a))):null};
L6a=function(a){for(;;){if($APP.Uc.A($APP.sq,a.j?a.j(1):a.call(null,1)))return ZP(a);var b=cQ(a);if($APP.k(b))a=b;else return ZP(a)}};dQ=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);c=$APP.qe(c);var d=$APP.C.A(c,bQ),g=$APP.C.A(c,$APP.aQ),l=$APP.r(g),n=$APP.u(l);l=$APP.w(l);return $APP.k($APP.k(c)?g:c)?$APP.z(new $APP.H(null,2,5,$APP.I,[n,$APP.rg.C(c,bQ,$APP.Vd.A(d,b),$APP.y([$APP.aQ,l]))],null),$APP.ed(a)):null};
eQ=function(a,b){$APP.x.B(a,0,null);var c=$APP.x.B(a,1,null);return $APP.z(new $APP.H(null,2,5,$APP.I,[b,$APP.rg.B(c,K6a,!0)],null),$APP.ed(a))};M6a=function(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;b=2<b.length?new $APP.Bc(b.slice(2),0,null):null;c=arguments[0];return eQ(c,$APP.Je.B(arguments[1],ZP(c),b))};
fQ=function(a){if($APP.Uc.A($APP.sq,a.j?a.j(1):a.call(null,1)))return a;var b=$P(a);if($APP.k(b))if($APP.k($P(a))){b=$APP.x.B(a,0,null);var c=$APP.x.B(a,1,null);if($APP.k($P(a))){var d=ZP(a);var g=D6a.j($APP.ed(a));d=g.j?g.j(d):g.call(null,d)}else throw"called children on a leaf node";var l=$APP.r(d);g=$APP.u(l);l=$APP.w(l);b=$APP.k(d)?$APP.z(new $APP.H(null,2,5,$APP.I,[g,new $APP.f(null,4,[bQ,$APP.sf,J6a,$APP.k(c)?$APP.Vd.A(J6a.j(c),b):new $APP.H(null,1,5,$APP.I,[b],null),I6a,c,$APP.aQ,l],null)],
null),$APP.ed(a)):null}else b=null;if($APP.k(b))return b;b=dQ(a);if($APP.k(b))return b;for(;;)if($APP.k(cQ(a))){b=dQ(cQ(a));if($APP.k(b))return b;a=cQ(a)}else return new $APP.H(null,2,5,$APP.I,[ZP(a),$APP.sq],null)};N6a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.Tc(a);return $APP.Uc.A(a,1)&&EF(b)?["1/",$APP.m.j(b)].join(""):$APP.Uc.A(a,2)&&EF(b)&&EF(c)?[$APP.m.j(b),"/",$APP.m.j(c)].join(""):null};
a7a=function(a){function b(Z,fa){return l(Z)>l(fa)}function c(Z){var fa=$APP.k(R)?O6a(ZP(Z)):R;return $APP.k(fa)?eQ(Z,fa):Z}function d(Z,fa){return $APP.k(Z)?J.j?J.j(fa):J.call(null,fa):fa}function g(Z){var fa=G.j?G.j(Z):G.call(null,Z);return $APP.k(fa)?fa:Z}function l(Z){for(;;){var fa=O.j?O.j(Z):O.call(null,Z);if($APP.k(fa))return fa;if($APP.td(Z))if($APP.Uc.A(3,$APP.Tc(Z))&&$APP.Uc.A(FJ,$APP.u(Z)))Z=$APP.Xc(Z);else return $APP.Uc.A($APP.Vw,$APP.u(Z))?(Z=eH,O.j?O.j(Z):O.call(null,Z)):O.j?O.j(gQ):
O.call(null,gQ);else return Z instanceof $APP.q?O.j?O.j(gQ):O.call(null,gQ):0}}function n(Z,fa,ia){return $APP.Uc.A($APP.Iv,Z)?$APP.m.j(fa):$APP.Uc.A($APP.Hv,Z)?$APP.m.j(fa):$APP.Uc.A(hQ,Z)?$APP.Uc.A(ia,$APP.Iv)?new $APP.f(null,2,[P6a,Q6a,R6a,fa],null):["- ",$APP.m.j(fa)].join(""):$APP.Uc.A($APP.sj,Z)?EF(fa)?["1/",$APP.m.j(fa)].join(""):["1 / ",$APP.m.j(fa)].join(""):[$APP.m.j(Z)," ",$APP.m.j(fa)].join("")}function p(Z){var fa=ZP(Z);fa=S6a.j?S6a.j(fa):S6a.call(null,fa);return Z===fa?Z:eQ(Z,fa)}a=
$APP.qe(a);var v=$APP.C.B(a,T6a," * "),t=$APP.C.B(a,U6a,$APP.F),A=$APP.C.B(a,V6a,$APP.F),B=$APP.C.A(a,W6a),G=$APP.C.B(a,X6a,$APP.F),J=$APP.C.B(a,Y6a,function(Z){return["(",$APP.m.j(Z),")"].join("")}),O=$APP.C.A(a,Z6a),R=$APP.C.B(a,$6a,!1),W=function ia(fa){if($APP.k($P(fa))){var ja=fQ(c(p(fa))),ta=function(){for(var Y=dQ(ja);;){Y=eQ(Y,ia(Y));var ea=dQ(Y);if($APP.k(ea))Y=ea;else return cQ(Y)}}();fa=ZP(ta);fa=$APP.r(fa);var ua=$APP.u(fa),ca=$APP.w(fa),V=function(){var Y=cQ(ta);if($APP.k(Y)){Y=$APP.x.B(ta,
0,null);var ea=$APP.x.B(ta,1,null);ea=$APP.qe(ea);var ya=$APP.C.A(ea,bQ),wa=$APP.C.A(ea,$APP.aQ);Y=$APP.k($APP.k(ea)?$APP.r(ya):ea)?$APP.z(new $APP.H(null,2,5,$APP.I,[$APP.u(ya),$APP.rg.C(ea,bQ,$APP.sf,$APP.y([$APP.aQ,$APP.N.C($APP.Fc(ya),new $APP.H(null,1,5,$APP.I,[Y],null),$APP.y([wa]))]))],null),$APP.ed(ta)):ta;Y=ZP(Y)}return Y}();return $APP.k(A.j?A.j(ua):A.call(null,ua))?d(function(){var Y=A.j?A.j(V):A.call(null,V);if($APP.k(Y)){Y=$APP.eb(b(ua,V));if($APP.k(Y)){Y=$APP.Uc.A(ua,$APP.Hv)&&$APP.Uc.A(V,
hQ);if(!Y){Y=$APP.x.B(ca,0,null);var ea=$APP.x.B(ca,1,null);Y=$APP.Uc.A($APP.sj,ua)&&EF(Y)&&(null==ea||EF(ea))}Y=$APP.eb(Y)}return Y}return Y}(),function(){var Y=function(){var wa=t.j?t.j(ua):t.call(null,ua);return $APP.k(wa)?wa.j?wa.j(ca):wa.call(null,ca):null}();if($APP.k(Y))return Y;if($APP.Uc.A($APP.Tc(ca),1))return n(ua,$APP.u(ca),V);if($APP.Uc.A(ua,$APP.Iv)){Y=$APP.Vg.A(function(wa){var Ba=$APP.qe(wa),Qa=$APP.C.A(Ba,P6a);Ba=$APP.C.A(Ba,R6a);return $APP.k(Qa)?new $APP.H(null,2,5,$APP.I,[$APP.Uc.A(Qa,
Q6a)?"-":"+",Ba],null):new $APP.H(null,2,5,$APP.I,["+",wa],null)},ca);Y=$APP.r(Y);var ea=$APP.u(Y),ya=$APP.w(Y);Y=$APP.Yd($APP.Uc.A($APP.u(ea),"+")?$APP.pi.A(ea,1):$APP.Uc.A($APP.u(ea),"-")?$APP.rg.B(ea,0,"- "):ea,function(){return function Qa(Ba){return new $APP.de(null,function(){for(;;){var Va=$APP.r(Ba);if(Va){if($APP.pd(Va)){var cb=$APP.lc(Va),pb=$APP.Tc(cb),rb=$APP.fe(pb);a:for(var yb=0;;)if(yb<pb){var Ub=$APP.bd(cb,yb),Db=$APP.x.B(Ub,0,null);Ub=$APP.x.B(Ub,1,null);$APP.je(rb,new $APP.H(null,
2,5,$APP.I,[[" ",$APP.m.j(Db)," "].join(""),Ub],null));yb+=1}else{cb=!0;break a}return cb?$APP.ie($APP.ke(rb),Qa($APP.mc(Va))):$APP.ie($APP.ke(rb),null)}cb=$APP.u(Va);rb=$APP.x.B(cb,0,null);cb=$APP.x.B(cb,1,null);return $APP.Yd(new $APP.H(null,2,5,$APP.I,[[" ",$APP.m.j(rb)," "].join(""),cb],null),Qa($APP.Fc(Va)))}return null}},null,null)}(ya)}());return $APP.Xs.B($APP.eh,$APP.m,Y)}Y=$APP.Uc.A($APP.Hv,ua)?$APP.k(v)?v:" * ":$APP.Uc.A(FJ,ua)?"^":[" ",$APP.m.j(ua)," "].join("");return $APP.Xs.B($APP.Ri.j(Y),
$APP.m,ca)}()):d(function(){if($APP.k(V)){var Y=A.j?A.j(V):A.call(null,V);return $APP.k(Y)?$APP.eb(b(ua,V)):Y}return V}(),function(){var Y=function(){var ea=t.j?t.j(ua):t.call(null,ua);return $APP.k(ea)?(ea=t.j?t.j(ua):t.call(null,ua),ea.j?ea.j(ca):ea.call(null,ca)):ea}();return $APP.k(Y)?Y:[$APP.m.j(d(function(){var ea=$P(ja);return $APP.k(ea)?b(gQ,ZP(fQ(ja))):ea}(),g(ia(fQ(ta))))),$APP.m.j(d(function(){var ea=$APP.eb(b(ua,gQ));return $APP.k(ea)?ea:(ea=1<$APP.Tc(ca))?ea:$P(dQ(ja))}(),$APP.Kl.A(", ",
ca)))].join("")}())}fa=ZP(fa);var da=$APP.k(B)?B.j?B.j(fa):B.call(null,fa):B;return $APP.k(da)?da:fa};return function(fa){fa=W(G6a(cG.j(fa)));return"string"===typeof fa?fa:$APP.m.j(fa)}};b7a=function(a,b){return $APP.Je.A($APP.m,$APP.Vg.A(function(c){c=parseInt(c);return b.j?b.j(c):b.call(null,c)},$APP.m.j(a)))};iQ=function(a){return["{",$APP.m.j(a),"}"].join("")};jQ=function(a){return"string"===typeof a&&$APP.Uc.A($APP.Tc(a),1)?a:iQ(a)};c7a=function(a){return["\\displaystyle{",$APP.m.j(a),"}"].join("")};
d7a=function(a,b){return $APP.Hl.B($APP.yr,a,b)};kQ=function(a,b){return $APP.Hl.B($APP.Ek,a,b)};lQ=function(a,b){return $APP.Hl.A(function(c){return a*c},b)};g7a=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,e7a,.05),d=$APP.C.B(b,f7a,2.5E-4),g=$APP.tf(a),l=c+1;return $APP.Lf.A(new $APP.H(null,1,5,$APP.I,[g],null),$APP.ip.A(function(n,p){return $APP.rg.B(g,n,0===p?d:l*p)},g))};
h7a=function(a){var b=$APP.x.B(a,0,null);a=$APP.kd(b)?$APP.bf.C(function(c){return kQ(c,b)},$APP.y([a])):$APP.Vg.A(function(c){return c-b},a);return $APP.Id.A($APP.Hj,$APP.Vg.A(mQ,a))};i7a=function(a){var b=$APP.kh.j(0);return new $APP.H(null,2,5,$APP.I,[b,function(c){$APP.lh.A(b,$APP.Lc);return a.j?a.j(c):a.call(null,c)}],null)};j7a=function(a,b,c){c=$APP.Vs.A($APP.Pi.A($APP.x,b),$APP.Jj.A(0,c+1));a=$APP.Hl.A(a,c);b=$APP.Hl.A(b,c);return new $APP.H(null,2,5,$APP.I,[a,b],null)};
p7a=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,k7a,!0);return $APP.Ni.C($APP.y([$APP.k(c)?new $APP.f(null,4,[l7a,1,m7a,1+2/a,n7a,.75-1/(2*a),o7a,1-1/a],null):new $APP.f(null,4,[l7a,1,m7a,2,n7a,.5,o7a,.5],null),$APP.sg(b,new $APP.H(null,4,5,$APP.I,[l7a,m7a,n7a,o7a],null))]))};
q7a=function(a,b,c){function d(G){G=$APP.r(G);var J=$APP.u(G);G=$APP.w(G);G=$APP.Lf.A(new $APP.H(null,1,5,$APP.I,[J],null),$APP.Vg.A(function(O){return d7a(J,lQ(A,kQ(O,J)))},G));return j7a(G,$APP.Hl.A(a,G),b)}function g(G,J){return d7a(lQ(1-B,J),lQ(B,$APP.fd(G)))}function l(G,J){return kQ(lQ(B*v+1,J),lQ(B*v,$APP.fd(G)))}function n(G,J){return kQ(lQ(v*t+1,J),lQ(v*t,$APP.fd(G)))}function p(G,J){return kQ(lQ(v+1,J),lQ(v,$APP.fd(G)))}c=p7a(b,c);c=$APP.qe(c);var v=$APP.C.A(c,l7a),t=$APP.C.A(c,m7a),A=$APP.C.A(c,
o7a),B=$APP.C.A(c,n7a);return function(G,J){var O=$APP.x.B(J,0,null);return function(){function R(ta,ua){ta=$APP.Vd.A($APP.gd(G),ta);ua=$APP.Vd.A($APP.gd(J),ua);return j7a(ta,ua,b)}var W=$APP.fd(J),Z=$APP.fd($APP.gd(J)),fa=lQ(1/b,$APP.Id.A(d7a,$APP.gd(G))),ia=p(G,fa),ja=a.j?a.j(ia):a.call(null,ia);if(ja<O)return W=n(G,fa),Z=a.j?a.j(W):a.call(null,W),Z<ja?R(W,Z):R(ia,ja);if(ja<Z)return R(ia,ja);if(ja<W)return W=l(G,fa),ia=a.j?a.j(W):a.call(null,W),ia<=ja?R(W,ia):d(G);ja=g(G,fa);ia=a.j?a.j(ja):a.call(null,
ja);return ia<W?R(ja,ia):d(G)}()}};t7a=function(a){a=$APP.qe(a);var b=$APP.C.B(a,r7a,1E-4),c=$APP.C.B(a,s7a,1E-4);return function(d,g){return h7a(d)<=b&&h7a(g)<=c}};u7a=function(a,b,c){var d=$APP.qe(c);c=$APP.C.A(d,nQ);d=$APP.C.A(d,oQ);var g=$APP.k(c)?c:200*b,l=$APP.k(d)?d:200*b;return function(n){return n>g||$APP.Fb(a)>l}};
v7a=function(a,b,c){var d=$APP.qe(c);c=$APP.C.A(d,$APP.Xw);c=$APP.k(c)?c:$APP.Le(null);var g=$APP.Tc(b),l=i7a(a);a=$APP.x.B(l,0,null);var n=$APP.x.B(l,1,null);l=q7a(n,g,d);var p=t7a(d),v=u7a(a,g,d);b=g7a(b,d);d=$APP.Hl.A(n,b);b=j7a(b,d,g);g=$APP.x.B(b,0,null);$APP.x.B(g,0,null);g=$APP.x.B(b,1,null);$APP.x.B(g,0,null);for(n=0;;){d=b;g=$APP.x.B(d,0,null);b=$APP.x.B(g,0,null);var t=$APP.x.B(d,1,null);d=$APP.x.B(t,0,null);c.B?c.B(n,b,d):c.call(null,n,b,d);var A=p(g,t);var B=A;B=$APP.k(B)?B:v(n);if($APP.k(B))return new $APP.f(null,
5,[pQ,b,$APP.iw,d,qQ,A,rQ,n,sQ,$APP.Fb(a)],null);b=l.A?l.A(g,t):l.call(null,g,t);n=g=n+1}};tQ=function(a,b){return w7a*a+x7a*b};uQ=function(a,b){return a+y7a*(a-b)};
z7a=function(a,b,c,d,g){var l=$APP.x.B(b,0,null),n=$APP.x.B(c,0,null),p=$APP.x.B(c,1,null),v=$APP.x.B(d,0,null),t=$APP.x.B(d,1,null),A=$APP.x.B(g,0,null);return p<t?function(){var B=tQ(v,l);return B<n?new $APP.H(null,4,5,$APP.I,[b,new $APP.H(null,2,5,$APP.I,[B,a.j?a.j(B):a.call(null,B)],null),c,d],null):new $APP.H(null,4,5,$APP.I,[b,c,new $APP.H(null,2,5,$APP.I,[B,a.j?a.j(B):a.call(null,B)],null),d],null)}():function(){var B=tQ(n,A);return v<B?new $APP.H(null,4,5,$APP.I,[c,d,new $APP.H(null,2,5,$APP.I,
[B,a.j?a.j(B):a.call(null,B)],null),g],null):new $APP.H(null,4,5,$APP.I,[c,new $APP.H(null,2,5,$APP.I,[B,a.j?a.j(B):a.call(null,B)],null),d,g],null)}()};A7a=function(a){var b=KF(a);return function(c,d,g,l){$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);return b(c>l?c:l,d<g?d:g)}};
B7a=function(a){var b=KF(a);return function(c,d,g,l){d=$APP.x.B(c,0,null);$APP.x.B(c,1,null);c=$APP.x.B(l,0,null);$APP.x.B(l,1,null);return b(d,c)}};C7a=function(a){return function(b,c,d,g,l){return a<l}};
E7a=function(a){a=$APP.qe(a);var b=$APP.C.A(a,qQ),c=$APP.C.A(a,s7a),d=$APP.C.A(a,D7a);return function(){function g(n){var p=null;if(0<arguments.length){p=0;for(var v=Array(arguments.length-0);p<v.length;)v[p]=arguments[p+0],++p;p=new $APP.Bc(v,0,null)}return l.call(this,p)}function l(n){return $APP.He(function(p){return $APP.Je.A(p,n)},new $APP.H(null,3,5,$APP.I,[$APP.k(b)?b:$APP.Le(!1),B7a(d),A7a(c)],null))}g.G=0;g.M=function(n){n=$APP.r(n);return l(n)};g.C=l;return g}()};
G7a=function(a){a=$APP.qe(a);var b=$APP.C.A(a,nQ),c=$APP.C.A(a,oQ),d=$APP.C.A(a,F7a);return function(){function g(n){var p=null;if(0<arguments.length){p=0;for(var v=Array(arguments.length-0);p<v.length;)v[p]=arguments[p+0],++p;p=new $APP.Bc(v,0,null)}return l.call(this,p)}function l(n){return $APP.He(function(p){return $APP.Je.A(p,n)},new $APP.H(null,2,5,$APP.I,[function(){function p(t){var A=null;if(0<arguments.length){A=0;for(var B=Array(arguments.length-0);A<B.length;)B[A]=arguments[A+0],++A;A=
new $APP.Bc(B,0,null)}return v.call(this,A)}function v(){return $APP.Fb(d)>c}p.G=0;p.M=function(t){t=$APP.r(t);return v(t)};p.C=v;return p}(),C7a(b)],null))}g.G=0;g.M=function(n){n=$APP.r(n);return l(n)};g.C=l;return g}()};
H7a=function(a,b,c){var d=a.j?a.j(b):a.call(null,b);a=a.j?a.j(c):a.call(null,c);return d<a?new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[b,d],null),new $APP.H(null,2,5,$APP.I,[c,a],null)],null):new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[c,a],null),new $APP.H(null,2,5,$APP.I,[b,d],null)],null)};
I7a=function(a,b,c){var d=$APP.x.B(a,0,null),g=$APP.x.B(a,1,null);a=$APP.x.B(b,0,null);var l=$APP.x.B(b,1,null);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);c=(a-d)*(l-c);g=(a-b)*(l-g);d=(a-b)*g-(a-d)*c;a=2*(g-c);return 0<a?new $APP.H(null,2,5,$APP.I,[RF.j(d),a],null):new $APP.H(null,2,5,$APP.I,[d,jG.j(a)],null)};J7a=function(a,b,c){var d=$APP.x.B(b,0,null);b=I7a(a,b,c);a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return d+a/(2E-21>b?2E-21:b)};
L7a=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,K7a,110);return function(d,g,l){var n=$APP.x.B(g,0,null),p=$APP.x.B(g,1,null),v=$APP.x.B(l,0,null),t=$APP.x.B(l,1,null),A=n+c*(v-n),B=J7a(d,g,l);if(n<=B&&B<=v){A=a.j?a.j(B):a.call(null,B);if(A<t)return new $APP.H(null,3,5,$APP.I,[g,new $APP.H(null,2,5,$APP.I,[B,A],null),l],null);if(A>p)return new $APP.H(null,3,5,$APP.I,[d,g,new $APP.H(null,2,5,$APP.I,[B,A],null)],null);d=uQ(v,n);return new $APP.H(null,3,5,$APP.I,[g,l,new $APP.H(null,2,5,$APP.I,[d,a.j?
a.j(d):a.call(null,d)],null)],null)}if(v<=B&&B<=A)return A=a.j?a.j(B):a.call(null,B),A<t?(d=uQ(B,v),new $APP.H(null,3,5,$APP.I,[l,new $APP.H(null,2,5,$APP.I,[B,A],null),new $APP.H(null,2,5,$APP.I,[d,a.j?a.j(d):a.call(null,d)],null)],null)):new $APP.H(null,3,5,$APP.I,[g,l,new $APP.H(null,2,5,$APP.I,[B,A],null)],null);if(v<=A&&A<=B)return new $APP.H(null,3,5,$APP.I,[g,l,new $APP.H(null,2,5,$APP.I,[A,a.j?a.j(A):a.call(null,A)],null)],null);d=uQ(v,n);return new $APP.H(null,3,5,$APP.I,[g,l,new $APP.H(null,
2,5,$APP.I,[d,a.j?a.j(d):a.call(null,d)],null)],null)}};M7a=function(a,b,c){a=b>=.5*(a+c)?a-b:c-b;return new $APP.H(null,2,5,$APP.I,[a,w7a*a],null)};N7a=function(a,b,c,d){a=$APP.Jl.A(RF,a);return $APP.Gj.B(vQ.K(a,b,c,d),$APP.iw,RF)};
O7a=function(a){var b=new $APP.ug(null,new $APP.f(null,2,[$APP.Hv,"null",$APP.Iv,"null"],null),null);return function g(d){if($APP.td(d)){var l=$APP.u(d);l=b.j?b.j(l):b.call(null,l);if($APP.eb(l)||4>$APP.Tc(d))return $APP.Vg.A(g,d);l=$APP.r(d);d=$APP.u(l);l=$APP.w(l);return $APP.Id.A($APP.Pi.A($APP.M,d),$APP.Vg.A(g,l))}return d}(a)};
P7a=function(){function a(g){var l=$APP.Fb(c);l=l.j?l.j(g):l.call(null,g);if($APP.k(l))return l;l=$APP.lh.A(b,$APP.Lc);$APP.lh.K(c,$APP.rg,g,l);return l}var b=$APP.kh.j(-1),c=$APP.kh.j($APP.F),d=function n(l){return $APP.td(l)?a($APP.Lf.B(new $APP.H(null,1,5,$APP.I,[$APP.u(l)],null),$APP.Vg.j(n),$APP.w(l))):"number"===typeof l?a(l):l};return function(){function l(v){return d(O7a(v))}function n(){return $APP.Vg.A($APP.u,$APP.Vs.A($APP.Xc,$APP.Fb(c)))}var p=null;p=function(v){switch(arguments.length){case 0:return n.call(this);
case 1:return l.call(this,v)}throw Error("Invalid arity: "+arguments.length);};p.J=n;p.j=l;return p}()};
S7a=function(a,b,c){function d(){var v=$APP.r(a);$APP.u(v);v=$APP.w(v);var t=$APP.u(v),A=$APP.w(v),B=$APP.Ej.j(function(){return function O(J){return new $APP.de(null,function(){for(;;){var R=$APP.r(J);if(R){if($APP.pd(R)){var W=$APP.lc(R),Z=$APP.Tc(W),fa=$APP.fe(Z);a:for(var ia=0;;)if(ia<Z){var ja=$APP.bd(W,ia);$APP.x.B(ja,0,null);var ta=$APP.x.B(ja,1,null);ja=$APP.x.B(ja,2,null);$APP.je(fa,new $APP.H(null,2,5,$APP.I,[ta,p.j?p.j(ja):p.call(null,ja)],null));ia+=1}else{W=!0;break a}return W?$APP.ie($APP.ke(fa),
O($APP.mc(R))):$APP.ie($APP.ke(fa),null)}W=$APP.u(R);$APP.x.B(W,0,null);fa=$APP.x.B(W,1,null);W=$APP.x.B(W,2,null);return $APP.Yd(new $APP.H(null,2,5,$APP.I,[fa,p.j?p.j(W):p.call(null,W)],null),O($APP.Fc(R)))}return null}},null,null)}(A)}());return l(function(G,J){var O=$APP.T.j($APP.r($APP.N.C(new $APP.D(null,Q7a,null,1,null),new $APP.D(null,t,null,1,null),$APP.y([$APP.Vg.A(function(R){var W=$APP.x.B(R,0,null);R=$APP.x.B(R,1,null);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Gv,null,1,null),
new $APP.D(null,W,null,1,null),$APP.y([new $APP.D(null,$APP.xd(R)?G.j?G.j(R):G.call(null,R):R,null,1,null)]))))},B)]))));J=$APP.Vg.B($APP.ps,G,J);return b.A?b.A(O,J):b.call(null,O,J)})}function g(){p.j?p.j(a):p.call(null,a);return l(function(v,t){var A=$APP.$c(v);v=$APP.Vg.B($APP.ps,v,t);return b.A?b.A(A,v):b.call(null,A,v)})}function l(v){function t(J){return $APP.xd(J)?G.j?G.j(J):G.call(null,J):J}var A=p.J?p.J():p.call(null),B=$APP.Tc(A),G=$APP.Lf.A($APP.sf,$APP.Pn.A(B,n));B=function(){return function R(O){return new $APP.de(null,
function(){for(;;){var W=$APP.r(O);if(W){if($APP.pd(W)){var Z=$APP.lc(W),fa=$APP.Tc(Z),ia=$APP.fe(fa);a:for(var ja=0;;)if(ja<fa){var ta=$APP.bd(Z,ja);$APP.je(ia,$APP.od(ta)?$APP.Mn.A($APP.u(ta),$APP.Vg.A(t,$APP.w(ta))):ta);ja+=1}else{Z=!0;break a}return Z?$APP.ie($APP.ke(ia),R($APP.mc(W))):$APP.ie($APP.ke(ia),null)}ia=$APP.u(W);return $APP.Yd($APP.od(ia)?$APP.Mn.A($APP.u(ia),$APP.Vg.A(t,$APP.w(ia))):ia,R($APP.Fc(W)))}return null}},null,null)}(A)}();return v.A?v.A(G,B):v.call(null,G,B)}c=$APP.qe(c);
var n=$APP.C.B(c,R7a,FM.A(8,"_")),p=P7a();return $APP.kd(a)?$APP.Uc.A($APP.u(a),Q7a)?d():g():b.A?b.A(a,null):b.call(null,a,null)};U7a=function(a){return $APP.Ao(function(b){if(FF(b))return vD(b);if($APP.kd(b)){var c=$APP.r(b),d=$APP.u(c);c=$APP.w(c);var g=$APP.Ge($APP.Baa,c);d=g?T7a.j?T7a.j(d):T7a.call(null,d):g;return $APP.k(d)?vD($APP.Je.A($APP.Dy.j(d),c)):b}return b},a)};
W7a=function(a){var b=wQ.j?wQ.j(a):wQ.call(null,a);if($APP.k(b))return b;throw $APP.Zi.A(["Invalid compilation mode supplied: ",$APP.m.j(a),". Please supply (or bind to `*mode*`) one of ",$APP.m.j(wQ)].join(""),new $APP.f(null,2,[$APP.hq,a,V7a,wQ],null));};X7a=function(a){return $APP.Hl.A(function(b){return $APP.z(b,new $APP.f(null,1,[$APP.tj,$APP.aqa],null))},$APP.Pn.A(3,a))};
Z7a=function(a,b){a=$APP.qe(a);var c=$APP.C.A(a,$APP.xQ),d=$APP.C.A(a,$APP.fm),g=$APP.C.A(a,Y7a),l=function(){switch(c instanceof $APP.E?c.ga:null){case "primitive":return X7a(function(){return b.j?b.j("a"):b.call(null,"a")});case "structure":return new $APP.H(null,1,5,$APP.I,[$APP.Lf.A($APP.sf,g)],null);case "native":return g;default:throw $APP.Zi.A("Invalid calling convention supplied",new $APP.f(null,1,[$APP.xQ,c],null));}}();return $APP.rg.B(a,yQ,$APP.k($APP.k(d)?$APP.qg.A(c,$APP.zQ):d)?$APP.Vd.A(l,
$APP.Lf.A($APP.sf,d)):l)};$7a=function(a,b){return S7a($APP.gm.j(a),function(c,d){return $APP.rg.B(a,$APP.gm,$APP.r(d)?AQ(c,d):c)},new $APP.f(null,1,[R7a,b],null))};
b8a=function(a){function b(n,p){return $APP.ip.A(function(v,t){return new $APP.H(null,2,5,$APP.I,[t,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Gu,null,1,null),new $APP.D(null,n,null,1,null),$APP.y([new $APP.D(null,v,null,1,null)]))))],null)},p)}a=$APP.qe(a);var c=$APP.C.A(a,yQ),d=$APP.C.A(a,$APP.xQ),g=$APP.C.A(a,Y7a),l=$APP.C.A(a,$APP.fm);switch(d instanceof $APP.E?d.ga:null){case "primitive":return d=$APP.x.B(c,0,null),$APP.x.B(c,1,null),c=$APP.x.B(c,2,null),$APP.Gj.S(a,$APP.gm,AQ,$APP.N.A(b(d,
$APP.ef(g)),b(c,l)),a8a);default:return a}};
c8a=function(a){function b(l,n){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Gv,null,1,null),new $APP.D(null,l,null,1,null),$APP.y([new $APP.D(null,n,null,1,null)]))))}function c(l){var n=$APP.kd(l);return n?(l=$APP.u(l),n=new $APP.ug(null,new $APP.f(null,3,[yP,"null",$APP.uu,"null",zP,"null"],null),null),n.j?n.j(l):n.call(null,l)):n}a=$APP.qe(a);var d=$APP.C.A(a,$APP.xQ),g=$APP.C.A(a,yQ);return $APP.Uc.A(d,$APP.zQ)?$APP.Gj.B(a,$APP.gm,function(l){if($APP.k(c(l))){var n=$APP.x.A(g,1);l=$APP.un.A(c,
$APP.Fc($APP.cf(c,$APP.Fc,l)));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,Q7a,null,1,null),new $APP.D(null,n,null,1,null),$APP.y([$APP.ip.A(b,l)]))))}return l}):a};d8a=function(a){return $APP.Ao(function(b){return $APP.kd(b)?$APP.r(b)?["[",$APP.Kl.A(", ",b),"]"].join(""):"_":$APP.m.j(b)},a)};e8a=function(a){return $APP.eka(PNa(),a)};
g8a=function(a){var b=$APP.qe(a);a=$APP.C.A(b,yQ);b=$APP.C.A(b,$APP.gm);return $APP.Bo(f8a,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.ay,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(a)))),null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))))};
i8a=function(a){var b=$APP.qe(a);a=$APP.C.A(b,yQ);b=$APP.C.A(b,$APP.gm);a=$APP.Hl.A(d8a,a);var c=$APP.kh.j($APP.sf);(function(d){if($APP.k(function(){var J=$P(d);return $APP.k(J)?$APP.Uc.A(ZP(fQ(d)),Q7a):J}())){var g=fQ(fQ(d)),l=ZP(g);if(!(l instanceof $APP.q))throw $APP.Zi.A("Expecting a symbol (referring to a primitive array)",new $APP.f(null,1,[h8a,l],null));for(var n=$APP.r(H6a(g)),p=null,v=0,t=0;;)if(t<v){var A=p.aa(null,t),B=$APP.x.B(A,0,null),G=$APP.x.B(A,1,null);A=$APP.x.B(A,2,null);if(!$APP.Uc.A(B,
$APP.Gv))throw $APP.Zi.A("Expecting an aset statement",new $APP.f(null,1,[h8a,B],null));$APP.lh.B(c,$APP.Vd,["  ",$APP.m.j(l),"[",$APP.m.j(G),"] \x3d ",$APP.m.j(BQ.j?BQ.j(A):BQ.call(null,A)),";"].join(""));t+=1}else if(n=$APP.r(n)){if($APP.pd(n))v=$APP.lc(n),n=$APP.mc(n),p=v,v=$APP.Tc(v);else{t=$APP.u(n);p=$APP.x.B(t,0,null);v=$APP.x.B(t,1,null);t=$APP.x.B(t,2,null);if(!$APP.Uc.A(p,$APP.Gv))throw $APP.Zi.A("Expecting an aset statement",new $APP.f(null,1,[h8a,p],null));$APP.lh.B(c,$APP.Vd,["  ",$APP.m.j(l),
"[",$APP.m.j(v),"] \x3d ",$APP.m.j(BQ.j?BQ.j(t):BQ.call(null,t)),";"].join(""));n=$APP.w(n);p=null;v=0}t=0}else break;return fQ(g)}return $APP.lh.B(c,$APP.Vd,["  return ",$APP.m.j(function(){var J=ZP(d);return BQ.j?BQ.j(J):BQ.call(null,J)}()),";"].join(""))})(function(d){var g=$P(d);g=$APP.k(g)?$APP.Uc.A(ZP(fQ(d)),$APP.hm):g;if($APP.k(g)){d=fQ(fQ(d));g=$APP.r($APP.Ll.A(2,ZP(d)));for(var l=null,n=0,p=0;;)if(p<n){var v=l.aa(null,p),t=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);$APP.td(v)&&$APP.Uc.A($APP.u(v),
$APP.Gu)?$APP.lh.B(c,$APP.Vd,["  const ",$APP.m.j(t)," \x3d ",$APP.m.j($APP.x.A(v,1)),"[",$APP.m.j($APP.x.A(v,2)),"];"].join("")):$APP.lh.B(c,$APP.Vd,["  const ",$APP.m.j(t)," \x3d ",$APP.m.j(BQ.j?BQ.j(v):BQ.call(null,v)),";"].join(""));p+=1}else if(g=$APP.r(g))$APP.pd(g)?(n=$APP.lc(g),g=$APP.mc(g),l=n,n=$APP.Tc(n)):(n=$APP.u(g),l=$APP.x.B(n,0,null),n=$APP.x.B(n,1,null),$APP.td(n)&&$APP.Uc.A($APP.u(n),$APP.Gu)?$APP.lh.B(c,$APP.Vd,["  const ",$APP.m.j(l)," \x3d ",$APP.m.j($APP.x.A(n,1)),"[",$APP.m.j($APP.x.A(n,
2)),"];"].join("")):$APP.lh.B(c,$APP.Vd,["  const ",$APP.m.j(l)," \x3d ",$APP.m.j(BQ.j?BQ.j(n):BQ.call(null,n)),";"].join("")),g=$APP.w(g),l=null,n=0),p=0;else break;return fQ(d)}return d}(G6a(b)));return $APP.Vd.A(a,$APP.Kl.A("\n",$APP.Fb(c)))};j8a=function(a){var b=$APP.Je.A(Function,i8a(a));return $APP.Uc.A($APP.xQ.j(a),$APP.zQ)?b:$APP.Jl.A($APP.gu,b)};k8a=function(a){return e8a(g8a(a))};l8a=function(a,b){return function g(d){return XK(d)?$APP.Hl.A(g,d):b.j?b.j($APP.UP):b.call(null,$APP.UP)}(a)};
m8a=function(a){$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,2,5,$APP.I,[CQ,a],null)};n8a=function(a){var b=$APP.x.B(a,0,null);$APP.x.B(a,1,null);return new $APP.H(null,2,5,$APP.I,[b,CQ],null)};o8a=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,2,5,$APP.I,[a,b],null)};q8a=function(a){var b=$APP.rg.B;var c=$APP.C.B(a,$APP.DQ,p8a);c=o8a.j?o8a.j(c):o8a.call(null,c);return b.call($APP.rg,a,$APP.DQ,c)};
r8a=function(a,b,c){var d=Math.abs(a)+Math.abs(b);return d<=c||Math.abs(b-a)<=c*d};
GQ=function(a,b){return function(){function c(l,n,p,v){v=$APP.qe(v);var t=$APP.C.B(v,s8a,1E-14);return r8a(n,p,t)?(bH($APP.Yu,"emmy.numerical.quadrature.common",136,new $APP.bh(function(){return new $APP.H(null,3,5,$APP.I,["Integrating narrow slice: ",n,p],null)},null),2009675594),new $APP.f(null,3,[qQ,!0,EQ,1,pQ,a.B?a.B(l,n,p):a.call(null,l,n,p)],null)):FQ.A(b.K?b.K(l,n,p,v):b.call(null,l,n,p,v),v)}function d(l,n,p){return g.K(l,n,p,$APP.F)}var g=null;g=function(l,n,p,v){switch(arguments.length){case 3:return d.call(this,
l,n,p);case 4:return c.call(this,l,n,p,v)}throw Error("Invalid arity: "+arguments.length);};g.B=d;g.K=c;return g}()};t8a=function(a,b,c){var d=Math.pow(b,c),g=d-1;return $APP.Vg.B(function(l,n){return(d*n-l)/g},a,$APP.Fc(a))};u8a=function(a,b,c){return $APP.Hg.A($APP.r,$APP.Vg.A($APP.u,$APP.af(function(d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var l=$APP.r(d);d=$APP.u(l);l=$APP.w(l);return new $APP.H(null,2,5,$APP.I,[t8a(g,b,d),l],null)},new $APP.H(null,2,5,$APP.I,[a,c],null))))};
v8a=function(a,b,c){return function(d){d=$APP.N.A($APP.Jj.B(b,c,(c-b)/d),new $APP.H(null,1,5,$APP.I,[c],null));return HQ.j($APP.Vg.B(a,d,$APP.Fc(d)))}};w8a=function(a,b,c){var d=c-b;return function(g){var l=d/g;return l*HQ.B(function(n){n=b+n*l;return a.j?a.j(n):a.call(null,n)},0,g)}};x8a=function(a,b,c){var d=c-b;return function(g){var l=d/g,n=b+l;return l*HQ.B(function(p){p=n+p*l;return a.j?a.j(p):a.call(null,p)},0,g)}};
y8a=function(a,b,c){return v8a(function(d,g){var l=a.j?a.j(d):a.call(null,d),n=a.j?a.j(g):a.call(null,g);return(g-d)*(l>n?l:n)},b,c)};z8a=function(a,b,c){return v8a(function(d,g){var l=a.j?a.j(d):a.call(null,d),n=a.j?a.j(g):a.call(null,g);return(g-d)*(l<n?l:n)},b,c)};B8a=function(a,b){var c=$APP.qe(b);b=$APP.C.B(c,$APP.tr,1);c=$APP.C.A(c,A8a);return $APP.k($APP.k(c)?"number"===typeof b:c)?IQ.K(a,2,1,1):a};
C8a=function(a,b,c){var d=c-b;return function(g){var l=d/g,n=b+l/2;return l*HQ.B(function(p){p=n+p*l;return a.j?a.j(p):a.call(null,p)},0,g)}};D8a=function(a,b,c){var d=C8a(a,b,c);return function(g,l){return(g+d(l))/2}};E8a=function(a,b,c,d){a=a.j?a.j(d):a.call(null,d);c=JQ.A(c,d);return $APP.Ut.B(b,a,c)};
F8a=function(a,b,c,d){return $APP.Fc($APP.Vg.A($APP.Xc,$APP.Ut.B(function(g,l){var n=$APP.x.B(g,0,null);$APP.x.B(g,1,null);if(0===$APP.Qd(l,c)){g=$APP.Pd(l,c);var p=$APP.C.A(n,g);g=$APP.k(p)?b.A?b.A(p,g):b.call(null,p,g):a.j?a.j(l):a.call(null,l)}else g=a.j?a.j(l):a.call(null,l);return new $APP.H(null,2,5,$APP.I,[$APP.rg.B(n,l,g),g],null)},new $APP.H(null,2,5,$APP.I,[$APP.F,null],null),d)))};G8a=function(a,b,c,d){var g="number"===typeof d?E8a:F8a;return g.K?g.K(a,b,c,d):g.call(null,a,b,c,d)};
KQ=function(a,b,c){return SF.A(kG.A(TF.A(c,b),mG.A(a.j?a.j(b):a.call(null,b),a.j?a.j(c):a.call(null,c))),2)};H8a=function(a,b,c){var d=c-b;return function(g){var l=d/g;return l*(((a.j?a.j(b):a.call(null,b))+(a.j?a.j(c):a.call(null,c)))/2+HQ.B(function(n){n=b+n*l;return a.j?a.j(n):a.call(null,n)},1,g))}};I8a=function(a,b,c){c=TF.A(c,b);var d=SF.A(c,2);b=mG.A(b,d);return kG.A(c,a.j?a.j(b):a.call(null,b))};
J8a=function(a,b,c){var d=c-b;return function(g,l){var n=d/l,p=n/6,v=b+p,t=b+5*p;return(g+n*HQ.B(function(A){var B=A*n;return function(){var G=v+B;return a.j?a.j(G):a.call(null,G)}()+function(){var G=t+B;return a.j?a.j(G):a.call(null,G)}()},0,l))/3}};K8a=function(a,b){var c=b-a;return function(d){return c/d}};
O8a=function(a){return function(){function b(g,l,n,p){p=$APP.Ni.C($APP.y([new $APP.f(null,1,[$APP.tr,L8a],null),p]));var v=$APP.qe(p),t=$APP.C.A(v,$APP.tr);p=$APP.Uc.A(M8a,N8a.j(v))?nXa(0):v0a(0);t=$APP.Vg.A(function(A){return A*A},$APP.Vg.A(K8a(l,n),t));g=a.K?a.K(g,l,n,v):a.call(null,g,l,n,v);g=$APP.Vg.B($APP.ps,t,g);return p.j?p.j(g):p.call(null,g)}function c(g,l,n){return d.K(g,l,n,new $APP.f(null,1,[$APP.tr,L8a],null))}var d=null;d=function(g,l,n,p){switch(arguments.length){case 3:return c.call(this,
g,l,n);case 4:return b.call(this,g,l,n,p)}throw Error("Invalid arity: "+arguments.length);};d.B=c;d.K=b;return d}()};
P8a=function(a){return function(){function b(g,l,n,p){function v(t){var A=1/t;return(g.j?g.j(A):g.call(null,A))/(t*t)}n=$APP.k(oG.j(n))?0:1/n;l=$APP.k(oG.j(l))?0:1/l;p=q8a(p);return a.K?a.K(v,n,l,p):a.call(null,v,n,l,p)}function c(g,l,n){return d.K(g,l,n,$APP.F)}var d=null;d=function(g,l,n,p){switch(arguments.length){case 3:return c.call(this,g,l,n);case 4:return b.call(this,g,l,n,p)}throw Error("Invalid arity: "+arguments.length);};d.B=c;d.K=b;return d}()};
U8a=function(a){return function(){function b(g,l,n,p){function v(ea,ya,wa,Ba){Ba=$APP.rg.B(t,$APP.DQ,Ba);ea=ea.K?ea.K(g,ya,wa,Ba):ea.call(null,g,ya,wa,Ba);return pQ.j(ea)}p=$APP.Ni.C($APP.y([new $APP.f(null,1,[Q8a,1],null),p]));var t=$APP.qe(p),A=$APP.C.A(t,Q8a);p=$APP.C.B(t,$APP.DQ,p8a);var B=$APP.Pi.A(v,a),G=$APP.Pi.A(v,P8a(a));A=Math.abs(A);var J=-A,O=new $APP.H(null,2,5,$APP.I,[l,n],null);try{if($APP.od(O)&&2===$APP.Tc(O))try{var R=$APP.x.A(O,0);if(-Infinity===R)try{var W=$APP.x.A(O,1);if(-Infinity===
W)return new $APP.f(null,3,[qQ,!0,EQ,0,pQ,0],null);throw LQ;}catch(ea){if(ea instanceof Error){var Z=ea;if(Z===LQ)throw LQ;throw Z;}throw ea;}else throw LQ;}catch(ea){if(ea instanceof Error)if(Z=ea,Z===LQ)try{if(R=$APP.x.A(O,0),Infinity===R)try{W=$APP.x.A(O,1);if(Infinity===W)return new $APP.f(null,3,[qQ,!0,EQ,0,pQ,0],null);throw LQ;}catch(ya){if(ya instanceof Error){var fa=ya;if(fa===LQ)throw LQ;throw fa;}throw ya;}else throw LQ;}catch(ya){if(ya instanceof Error)if(fa=ya,fa===LQ)try{if(R=$APP.x.A(O,
0),-Infinity===R)try{W=$APP.x.A(O,1);if(-Infinity===W)return $APP.Gj.B(d.K(g,n,l,t),pQ,$APP.Ek);throw LQ;}catch(wa){if(wa instanceof Error){var ia=wa;if(ia===LQ)throw LQ;throw ia;}throw wa;}else throw LQ;}catch(wa){if(wa instanceof Error)if(ia=wa,ia===LQ)try{if(R=$APP.x.A(O,0),Infinity===R)try{W=$APP.x.A(O,1);if(Infinity===W)return $APP.Gj.B(d.K(g,n,l,t),pQ,$APP.Ek);throw LQ;}catch(Ba){if(Ba instanceof Error){var ja=Ba;if(ja===LQ)throw LQ;throw ja;}throw Ba;}else throw LQ;}catch(Ba){if(Ba instanceof
Error)if(ja=Ba,ja===LQ)try{if(R=$APP.x.A(O,0),-Infinity===R)try{W=$APP.x.A(O,1);if(Infinity===W){var ta=G(l,J,R8a),ua=B(J,A,S8a),ca=G(A,n,T8a);return new $APP.f(null,2,[qQ,!0,pQ,ta+ua+ca],null)}throw LQ;}catch(Qa){if(Qa instanceof Error){var V=Qa;if(V===LQ){if(n<=J)return G(l,n,p);ta=G(l,J,R8a);var da=B(J,n,m8a(p));return new $APP.f(null,2,[qQ,!0,pQ,ta+da],null)}throw V;}throw Qa;}else throw LQ;}catch(Qa){if(Qa instanceof Error)if(V=Qa,V===LQ)try{W=$APP.x.A(O,1);if(Infinity===W){if(l>=A)return G(l,
n,p);var Y=B(l,A,n8a(p));ca=G(A,n,T8a);return new $APP.f(null,2,[qQ,!0,pQ,Y+ca],null)}throw LQ;}catch(Va){if(Va instanceof Error){R=Va;if(R===LQ)throw LQ;throw R;}throw Va;}else throw V;else throw Qa;}else throw ja;else throw Ba;}else throw ia;else throw wa;}else throw fa;else throw ya;}else throw Z;else throw ea;}else throw LQ;}catch(ea){if(ea instanceof Error){Z=ea;if(Z===LQ)return a.K?a.K(g,l,n,t):a.call(null,g,l,n,t);throw Z;}throw ea;}}function c(g,l,n){return d.K(g,l,n,$APP.F)}var d=null;d=
function(g,l,n,p){switch(arguments.length){case 3:return c.call(this,g,l,n);case 4:return b.call(this,g,l,n,p)}throw Error("Invalid arity: "+arguments.length);};d.B=c;d.K=b;return d}()};MQ=function(a){return $APP.x.A(a,0)};$APP.NQ=function(a){return $APP.x.A(a,1)};OQ=function(a){return $APP.x.A(a,2)};PQ=function(a){return $APP.x.A(a,3)};V8a=function(a){a=$APP.x.A(a,1);return YK(a)?$APP.Tc(a):1};W8a=function(a){return wL.C($APP.y([$APP.Oj.j($APP.Uv),hL($APP.Oj.j($APP.Yv),a),hL($APP.Oj.j($APP.Wv),a)]))};
$APP.X8a=function(a){return function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return kG.C(SF.A(1,2),a,$APP.y([nG.j(b)]))}};Y8a=function(a){return function(b){$APP.x.B(b,0,null);var c=$APP.x.B(b,1,null);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return wL.C($APP.y([wL.C($APP.y([b,0])),wL.C($APP.y([mG.A(b,kG.A(a,iO.j(c))),kG.C(-1,a,$APP.y([hO.j(c)]))]))]))}};
Z8a=function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null),l=$APP.x.B(g,0,null);$APP.x.B(l,0,null);l=$APP.x.B(l,1,null);g=$APP.x.B(g,1,null);$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var n=$APP.x.B(d,2,null);d=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);return TF.A(kG.A(SF.A(1,2),mG.A(kG.A(a,nG.j(d)),kG.A(b,nG.j(n)))),kG.A(c,mG.A(kG.A(a,l),kG.A(b,g))))}};
$8a=function(a,b){return function(c){var d=a.j?a.j(c):a.call(null,c),g=b.j?b.j(c):b.call(null,c);return QQ.B?QQ.B(c,d,g):QQ.call(null,c,d,g)}};a9a=function(a){return function(b,c){b=$8a(b,c);return TF.A(UO.j?UO.j(b):UO.call(null,b),YH.C($APP.y([$APP.RQ.j(a),b])))}};b9a=function(a){var b=SQ.j?SQ.j(2):SQ.call(null,2);b=b.j?b.j(a):b.call(null,a);return TF.A(kG.A(b,OQ),a)};c9a=function(a){return function(b){b=YH.C($APP.y([b9a(a),TQ.j(b)]));return UO.j?UO.j(b):UO.call(null,b)}};
d9a=function(a){return function(b){$APP.x.B(b,0,null);var c=$APP.x.B(b,1,null),d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);var g=$APP.x.B(b,2,null);b=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);return kG.C(SF.A(1,2),a,$APP.y([mG.C(nG.j(b),nG.j(kG.A(d,l)),$APP.y([nG.j(kG.C(d,iO.j(c),$APP.y([g])))]))]))}};
e9a=function(a,b,c){c+=1;var d=SF.A(TF.A(b,a),c);return function n(l){return new $APP.de(null,function(){for(;;){var p=$APP.r(l);if(p){if($APP.pd(p)){var v=$APP.lc(p),t=$APP.Tc(v),A=$APP.fe(t);a:for(var B=0;;)if(B<t){var G=$APP.bd(v,B);$APP.je(A,mG.A(a,kG.A(G,d)));B+=1}else{v=!0;break a}return v?$APP.ie($APP.ke(A),n($APP.mc(p))):$APP.ie($APP.ke(A),null)}A=$APP.u(p);return $APP.Yd(mG.A(a,kG.A(A,d)),n($APP.Fc(p)))}return null}},null,null)}($APP.Jj.A(1,c))};
f9a=function(a,b){return ZZa($APP.Vg.B($APP.ps,b,a))};g9a=function(a,b,c,d,g){var l=$APP.Tc(g);l=e9a(a,c,l);return f9a($APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,b,null,1,null),g,$APP.y([new $APP.D(null,d,null,1,null)]))))),$APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,a,null,1,null),l,$APP.y([new $APP.D(null,c,null,1,null)]))))))};i9a=function(a,b,c,d,g){return function(l){l=g9a(b,c,d,g,l);return UQ.S(a,l,b,d,new $APP.f(null,1,[h9a,!1],null))}};
j9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.Tc(a);return function(g){g=TF.A(g,b);for(var l=2,n=c,p=g;;){if($APP.Uc.A(l,d))return n;var v=l+1;n=mG.A(n,kG.A($APP.x.A(a,l),p));p=SF.A(kG.A(p,g),l);l=v}}};VQ=function(a){return function(b){var c=$APP.u(b);b=j9a(b);b=a.j?a.j(b):a.call(null,b);return b.j?b.j(c):b.call(null,c)}};k9a=function(a){return function(b){var c=$APP.Tc(b);return VQ(function(d){d=YH.C($APP.y([a,TQ.A(d,c-1)]));return UO.j?UO.j(d):UO.call(null,d)})(b)}};l9a=function(a){return bL($APP.gd(TK(a)))};
m9a=function(a){return TF.A(function(){var b=SQ.j?SQ.j(2):SQ.call(null,2);b=b.j?b.j(a):b.call(null,a);return WQ.j?WQ.j(b):WQ.call(null,b)}(),YH.C($APP.y([function(){var b=SQ.j?SQ.j(1):SQ.call(null,1);return b.j?b.j(a):b.call(null,a)}(),l9a])))};
n9a=function(a){return function(b){var c=$APP.Tc(b);return function n(g,l){if(0===g)g=0;else{var p=TF.A;var v=SQ.j?SQ.j(g):SQ.call(null,g);v=v.j?v.j(a):v.call(null,a);var t=tI.A(WQ,g-1);v=t.j?t.j(v):t.call(null,v);v=v.j?v.j(l):v.call(null,l);g=p.call(TF,v,n(g-1,l9a(l)))}return g}($APP.Pd(c,2),b)}};$APP.XQ=function(a){return function(b){var c=$APP.Tc(b);return VQ(function(d){d=YH.C($APP.y([a,TQ.j(d)]));return TQ.A(d,c)})(b)}};
o9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=lG.j(mG.A(nG.j(b),nG.j(c)));b=tG.A(c,b);return wL.C($APP.y([a,b]))};p9a=function(a){return o9a($APP.NQ(a))};q9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=kG.A(b,hO.j(c));b=kG.A(b,iO.j(c));return wL.C($APP.y([a,b]))};r9a=function(a){return q9a($APP.NQ(a))};
s9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null);a=kG.C(b,iO.j(c),$APP.y([hO.j(d)]));d=kG.C(b,iO.j(c),$APP.y([iO.j(d)]));b=kG.A(b,hO.j(c));return wL.B?wL.B(a,d,b):wL.call(null,a,d,b)};t9a=function(a){return s9a($APP.NQ(a))};u9a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null);a=lG.j(mG.C(nG.j(b),nG.j(c),$APP.y([nG.j(d)])));d=mO.j(SF.A(d,a));b=tG.A(c,b);return wL.B?wL.B(a,d,b):wL.call(null,a,d,b)};v9a=function(a){return u9a($APP.NQ(a))};
w9a=function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.gv,$APP.r(new $APP.H(null,4,5,$APP.I,[k2a,PN,$APP.r(new $APP.H(null,3,5,$APP.I,[TN,PN,a],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[m2a,PN,a],null))],null)),PN],null)))?a:fJ(a)};YQ=function(a,b,c){return wL.C($APP.y([a,b,c]))};x9a=function(a){var b=YK(a);if(b){if(b=$APP.Uc.A($APP.Tc(a),3)){b=$APP.x.B(a,0,null);var c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return IF(b)&&(IF(c)&&IF(a)||YK(c)&&DZa(a)&&$APP.Uc.A(WK(c),WK(a)))}return b}return b};
ZQ=function(a){return $APP.x.A(a,2)};y9a=function(a,b){return function(c){return YQ(c,a.j?a.j(c):a.call(null,c),b.j?b.j(c):b.call(null,c))}};z9a=function(a,b){return mG.A(a,b)};$APP.$Q=function(a){return function(b){return YQ(1,function(){var c=SQ.j?SQ.j(2):SQ.call(null,2);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}(),TF.j(function(){var c=SQ.j?SQ.j(1):SQ.call(null,1);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}()))}};
A9a=function(a){return function(b,c){b=y9a(b,c);c=$APP.$Q(a);return TF.A(UO.j?UO.j(b):UO.call(null,b),YH.C($APP.y([c,b])))}};B9a=function(a){return function(b){return wL.C($APP.y([0,function(){var c=SQ.j?SQ.j(2):SQ.call(null,2);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}(),TF.j(function(){var c=SQ.j?SQ.j(1):SQ.call(null,1);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}())]))}};
D9a=function(a){function b(l){var n=pL(l),p=d.j?d.j(n):d.call(null,n);n=c.j?c.j(n):c.call(null,n);if($APP.k($APP.k(!1)?MF.j(dG.j(aR.j(p))):!1))throw $APP.Zi.A("Legendre Transform Failure: determinant \x3d 0",new $APP.f(null,2,[C9a,a,$APP.or,l],null));p=LSa(p,TF.A(l,n));return TF.A(kG.A(l,p),a.j?a.j(p):a.call(null,p))}var c=UO.j?UO.j(a):UO.call(null,a),d=UO.j?UO.j(c):UO.call(null,c),g=UO.j?UO.j(b):UO.call(null,b);return function(l){if($APP.k(!1)){var n=nL(l);var p=hG.A,v=dG.j;var t=g.j?g.j(n):g.call(null,
n);t=c.j?c.j(t):c.call(null,t);n=$APP.eb(p.call(hG,n,v.call(dG,t)))}else n=!1;if($APP.k(n))throw $APP.Zi.A("Legendre Transform Failure: not quadratic",new $APP.f(null,2,[C9a,a,$APP.or,l],null));return b(l)}};E9a=function(a){return LK.A(function(b){return bR(b,a)},new $APP.D(null,cR,new $APP.D(null,a,null,1,null),2,null))};
G9a=function(a){return LK.A(function(b){var c=mG.A;var d=SQ.j?SQ.j(0):SQ.call(null,0);d=d.j?d.j(b):d.call(null,b);return c.call(mG,d,bR(b,a))},new $APP.D(null,F9a,new $APP.D(null,a,null,1,null),2,null))};I9a=function(a,b){return LK.A(qG.j(kG.A(b,dR.j(a))),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,H9a,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))))};
J9a=function(a){var b=ISa(LF);return function(c,d,g){d=b(d+a*Math.sin(c));c=b(c+d);return g.A?g.A(c,d):g.call(null,c,d)}};K9a=function(a,b){var c=$APP.Le(null);return function(d,g,l,n){var p=g;for(g=b;;){if($APP.Uc.A(g,0))return l.A?l.A(d,p):l.call(null,d,p);d=a.K?a.K(d,p,$APP.ps,c):a.call(null,d,p,$APP.ps,c);if($APP.k(d))p=d,d=$APP.x.B(p,0,null),p=$APP.x.B(p,1,null),--g;else return n.J?n.J():n.call(null)}}};
L9a=function(a){return function(b){var c=$APP.x.B(b,0,null);$APP.x.B(b,1,null);var d=$APP.x.B(b,2,null),g=wL.C,l=a.j?a.j(b):a.call(null,b),n=eR.A;var p=SQ.j?SQ.j(1):SQ.call(null,1);p=p.j?p.j(a):p.call(null,a);b=p.j?p.j(b):p.call(null,b);return g.call(wL,$APP.y([c,l,n.call(eR,d,b)]))}};M9a=function(a,b,c){return TF.A(YH.C($APP.y([$APP.$Q(b),a])),kG.A(UO.j?UO.j(a):UO.call(null,a),$APP.$Q(c)))};N9a=function(a,b){return M9a(a,b,YH.C($APP.y([b,a])))};
fR=function(a){return wL.C($APP.y([0,$APP.x.A(a,2),TF.j($APP.x.A(a,1))]))};O9a=function(a){return wL.C($APP.y([1,vG.j($APP.NQ.j?$APP.NQ.j(a):$APP.NQ.call(null,a)),vG.j(ZQ.j?ZQ.j(a):ZQ.call(null,a))]))};P9a=function(a,b){a=UO.j?UO.j(a):UO.call(null,a);return a.j?a.j(b):a.call(null,b)};Q9a=function(a){return function(b){return kG.A(a,b)}};R9a=function(a){return function(b){return kG.A(b,a)}};
S9a=function(a){return function(b){var c=qL(b),d=TF.A(fR,YH.C($APP.y([Q9a(function(){var g=UO.j?UO.j(a):UO.call(null,a);return g.j?g.j(b):g.call(null,b)}()),fR,R9a(function(){var g=UO.j?UO.j(a):UO.call(null,a);return g.j?g.j(b):g.call(null,b)}())])));return d.j?d.j(c):d.call(null,c)}};T9a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null),g=$APP.x.B(b,2,null);b=kG.A(lG.j(SF.A(kG.A(2,g),a)),iO.j(d));d=kG.A(lG.j(kG.C(2,a,$APP.y([g]))),hO.j(d));return wL.C($APP.y([c,b,d]))}};
U9a=function(a){return function(b){return kG.A(b,a)}};V9a=function(a){var b=kG.A(2,a)+1;return xN.B(b,b,function(c,d){return 0===c?0:0===d?0:$APP.Uc.A(c+a,d)?1:$APP.Uc.A(d+a,c)?-1:0})};W9a=function(a){var b=kG.A(2,a);return xN.B(b,b,function(c,d){return $APP.Uc.A(mG.A(c,a),d)?1:$APP.Uc.A(mG.A(d,a),c)?-1:0})};Y9a=function(a){var b=rN(a);if(!$APP.Ie(b))throw $APP.Zi.A("Wrong type -- symplectic-matrix?",new $APP.f(null,1,[X9a,a],null));b=W9a($APP.Pd(b,2));return TF.A(b,kG.C(a,b,$APP.y([gR.j(a)])))};
Z9a=function(a){return b2a(a,0,0)};$9a=function(a){return function(b){return Y9a(Z9a(Q3a(a)(b)))}};hR=function(a,b,c,d,g){this.r=a;this.i=b;this.Ma=c;this.k=d;this.ca=g;this.O=2310931231;this.U=131072};iR=function(a,b,c,d,g){return new hR(a,b,c,d,g)};a$a=function(a){return a instanceof hR};b$a=function(a){return yG.A(a.r,a.i)};c$a=function(a){return yG.A(a.Ma,a.k)};d$a=function(a){return new $APP.H(null,4,5,$APP.I,[a.r,a.i,a.Ma,a.k],null)};
jR=function(a){return new $APP.H(null,3,5,$APP.I,[a.i,a.Ma,a.k],null)};kR=function(a){var b=MF.j(a.i);return $APP.k(b)?(b=MF.j(a.Ma),$APP.k(b)?MF.j(a.k):b):b};e$a=function(a){var b=kR(a);return $APP.k(b)?MF.j(a.r):b};f$a=function(a){var b=kR(a);return $APP.k(b)?uG.j(a.r):b};
lR=function(a,b){var c=a===b;if(c)return c;var d=a.r,g=a.i,l=a.Ma;c=a.k;if(a$a(b))return a=hG.A(d,b.r),$APP.k(a)?(a=hG.A(g,b.i),$APP.k(a)?(l=hG.A(l,b.Ma),$APP.k(l)?hG.A(c,b.k):l):a):a;if(xG(b))return a=hG.A(d,b.ha),$APP.k(a)?(a=hG.A(g,b.ia),$APP.k(a)?(l=MF.j(l),$APP.k(l)?MF.j(c):l):a):a;if($APP.kd(b))return $APP.Uc.A($APP.Tc(b),4)&&$APP.Uc.A(d,$APP.x.A(b,0))&&$APP.Uc.A(g,$APP.x.A(b,1))&&$APP.Uc.A(l,$APP.x.A(b,2))&&$APP.Uc.A(c,$APP.x.A(b,3));a=kR(a);return $APP.k(a)?hG.A(d,b):a};g$a=function(a){return BWa(d$a(a))};
nR=function(a,b){return mR.K($APP.Je.A(a.r,b),$APP.Je.A(a.i,b),$APP.Je.A(a.Ma,b),$APP.Je.A(a.k,b))};h$a=function(a,b){return mR.K(oR.A(a.r,b),oR.A(a.i,b),oR.A(a.Ma,b),oR.A(a.k,b))};pR=function(a){return mR.K(RF.j(a.r),RF.j(a.i),RF.j(a.Ma),RF.j(a.k))};i$a=function(a,b){return mR.K(kG.A(a,b.r),kG.A(a,b.i),kG.A(a,b.Ma),kG.A(a,b.k))};j$a=function(a,b){return mR.K(kG.A(a.r,b),kG.A(a.i,b),kG.A(a.Ma,b),kG.A(a.k,b))};k$a=function(a){return mR.K(a.r,RF.j(a.i),RF.j(a.Ma),RF.j(a.k))};
qR=function(a,b){return mR.K(SF.A(a.r,b),SF.A(a.i,b),SF.A(a.Ma,b),SF.A(a.k,b))};l$a=function(a,b){var c=$APP.x.B(a,0,null),d=$APP.x.B(a,1,null),g=$APP.x.B(a,2,null);a=$APP.x.B(a,3,null);var l=$APP.x.B(b,0,null),n=$APP.x.B(b,1,null),p=$APP.x.B(b,2,null);b=$APP.x.B(b,3,null);return mG.C(kG.A(c,l),kG.A(d,n),$APP.y([kG.A(g,p),kG.A(a,b)]))};m$a=function(a,b){return mR.A(0,XZa(jR(a),jR(b)))};n$a=function(a){return qR(k$a(a),rR.j?rR.j(a):rR.call(null,a))};
rR=function(a){return mG.C(nG.j(a.r),nG.j(a.i),$APP.y([nG.j(a.Ma),nG.j(a.k)]))};sR=function(a){return lG.j(rR(a))};o$a=function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null),g=$APP.x.B(a,3,null);d=MF.j(d);g=$APP.k(d)?MF.j(g):d;if($APP.k(g))return $APP.k(MF.j(c))?mR.j(rG.j(b)):mR.K(rG.j(jG.j(new $APP.H(null,2,5,$APP.I,[b,c],null))),tG.A(c,b),0,0);c=sR(a);a=jR(a);g=jG.j(a);return mR.A(rG.j(c),OF.A(mO.j(BG.A(b,c)),BG.A(a,g)))};
uR=function(a){var b=qG.j(a.r);a=jR(a);var c=jG.j(a);return $APP.k(MF.j(c))?mR.K(b,0,0,0):mR.A(kG.A(b,hO.j(c)),kG.C(b,tR.j(c),$APP.y([a])))};p$a=function(a){var b=a.r;a=jR(a);var c=jG.j(a);return mR.A(kG.A(hO.j(b),vH.j(c)),kG.A(kG.A(TF.j(iO.j(b)),vR.j(c)),a))};q$a=function(a){var b=a.r;a=jR(a);var c=jG.j(a);return mR.A(kG.A(iO.j(b),vH.j(c)),kG.A(kG.A(hO.j(b),vR.j(c)),a))};r$a=function(a){return wR.A(q$a(a),p$a(a))};s$a=function(a){return qR(xR.A(uR(a),uR(pR(a))),2)};
t$a=function(a){return qR(yR.A(uR(a),uR(pR(a))),2)};u$a=function(a){return wR.A(t$a(a),s$a(a))};v$a=function(a,b){return $APP.xd(b)?JSa(a,b):uR(a$a(b)?zR.A(o$a(a),b):j$a(o$a(a),b))};w$a=function(a){var b=a.r;if($APP.k(kR(a)))return $APP.k(sG.j(b))?mR.K(0,lG.j(jG.j(b)),0,0):mR.K(lG.j(b),0,0,0);b=lG.j(mG.A(b,sR(a)));var c=lG.j(2);return mR.A(SF.A(b,c),SF.A(jR(a),kG.A(b,c)))};
AR=function(a,b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);a=BG.A(a,2);var g=iO.j(a);return mR.K(hO.j(a),kG.A(g,c),kG.A(g,d),kG.A(g,b))};
y$a=function(a){var b=a.r,c=a.i,d=a.Ma;a=a.k;var g=nG.j(b),l=nG.j(c),n=nG.j(d),p=nG.j(a),v=dG.j(mG.C(g,l,$APP.y([n,p])));GJ.A(new $APP.D(null,$APP.bw,new $APP.D(null,v,new $APP.D(null,1,null,1,null),2,null),3,null),x$a);return EN.C($APP.y([new $APP.H(null,3,5,$APP.I,[SF.A(mG.C(g,l,$APP.y([RF.j(n),RF.j(p)])),v),SF.A(kG.A(2,TF.A(kG.A(c,d),kG.A(b,a))),v),SF.A(kG.A(2,mG.A(kG.A(c,a),kG.A(b,d))),v)],null),new $APP.H(null,3,5,$APP.I,[SF.A(kG.A(2,mG.A(kG.A(c,d),kG.A(b,a))),v),SF.A(mG.C(g,RF.j(l),$APP.y([n,
RF.j(p)])),v),SF.A(kG.A(2,TF.A(kG.A(d,a),kG.A(b,c))),v)],null),new $APP.H(null,3,5,$APP.I,[SF.A(kG.A(2,TF.A(kG.A(c,a),kG.A(b,d))),v),SF.A(kG.A(2,mG.A(kG.A(d,a),kG.A(b,c))),v),SF.A(mG.C(g,RF.j(l),$APP.y([RF.j(n),p])),v)],null)]))};z$a=function(a){return BR.C($APP.y([$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[2,1],null)),$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[0,2],null)),$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[1,0],null))]))};
A$a=function(a){return function(b){var c=YH.C($APP.y([a,b]));return function(d){var g=kG.A;var l=UO.j?UO.j(c):UO.call(null,c);l=l.j?l.j(d):l.call(null,d);return z$a(g.call(kG,l,yN(c.j?c.j(d):c.call(null,d))))}}};B$a=function(a){return function(b){return function(c){return kG.A(yN(function(){var d=b.j?b.j(c):b.call(null,c);return a.j?a.j(d):a.call(null,d)}()),function(){var d=A$a(a)(b);return d.j?d.j(c):d.call(null,c)}())}}};
C$a=function(a,b,c){return function(d){var g=$APP.x.B(d,0,null),l=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return kG.A(SF.A(1,2),mG.C(kG.A(a,nG.j(g)),kG.A(b,nG.j(l)),$APP.y([kG.A(c,nG.j(d))])))}};D$a=function(a,b,c){return function(d){var g=$APP.x.B(d,0,null),l=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return SN.C($APP.y([kG.A(a,g),kG.A(b,l),kG.A(c,d)]))}};
E$a=function(a){return function(b){function c(d){return pO(a.j?a.j(d):a.call(null,d))}return z$a(function(d){var g=kG.A;var l=UO.j?UO.j(c):UO.call(null,c);l=l.j?l.j(d):l.call(null,d);return g.call(kG,l,gR.j(c(d)))}(b))}};
F$a=function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null),c=$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var d=$APP.x.B(a,2,null),g=$APP.x.B(d,0,null);a=$APP.x.B(d,1,null);var l=$APP.x.B(d,2,null);d=mG.A(kG.C(iO.j(b),iO.j(c),$APP.y([a])),kG.A(hO.j(b),g));b=mG.A(kG.C(hO.j(b),iO.j(c),$APP.y([a])),kG.C(-1,iO.j(b),$APP.y([g])));c=mG.A(kG.A(hO.j(c),a),l);return wL.C($APP.y([d,b,c]))};CR=function(a,b,c){return function(d){return C$a(a,b,c)(F$a(d))}};
G$a=function(a,b,c){return function(d){return D$a(a,b,c)(F$a(d))}};H$a=function(a,b,c){return function(d){var g=$APP.NQ(d);return kG.A(G$a(a,b,c)(d),gR.j(pO(g)))}};I$a=function(a,b,c){return function(d){$APP.x.B(d,0,null);$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return D$a(a,b,c)(d)}};J$a=function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return YQ(mG.A(c,a),d,b)}};
K$a=function(a,b){return function(c){return(function(){var d=b+c;return a.j?a.j(d):a.call(null,d)}()-function(){var d=b-c;return a.j?a.j(d):a.call(null,d)}())/(2*c)}};
M$a=function(a,b,c,d){switch(a instanceof $APP.E?a.ga:null){case "forward":return new $APP.f(null,4,[YG,1,DR,1,ER,FR.B(b,c,d),GR,function(g){g=c+g;g=b.j?b.j(g):b.call(null,g);return d/(g-d)}],null);case "central":return new $APP.f(null,4,[YG,2,DR,2,ER,K$a(b,c),GR,function(g){return d/(function(){var l=c+g;return b.j?b.j(l):b.call(null,l)}()-function(){var l=c-g;return b.j?b.j(l):b.call(null,l)}())}],null);case "backward":return new $APP.f(null,4,[YG,1,DR,1,ER,HR.B(b,c,d),GR,function(g){g=c-g;g=b.j?
b.j(g):b.call(null,g);return d/(d-g)}],null);case "central-d2":return new $APP.f(null,4,[YG,2,DR,2,ER,IR.B(b,c,d),GR,function(g){return function(){var l=c+g;return b.j?b.j(l):b.call(null,l)}()+function(){var l=c-g;return b.j?b.j(l):b.call(null,l)}()-2*d}],null);default:return yD(["Invalid method: ",$APP.m.j(a),". Please try one of ",$APP.m.j(L$a)].join(""))}};P$a=function(a){a=$APP.Ni.C($APP.y([new $APP.f(null,2,[N$a,JR,$APP.ny,O$a],null),a]));a=$APP.qe(a);$APP.C.A(a,$APP.ny);return a};
S$a=function(a,b,c){if($APP.md(c))return $APP.Jb(c,a,b);if(null==c)return b;if($APP.db(c)){var d=new $APP.Ac(function(){return $APP.Ts},Q$a,$APP.fg([$APP.No,$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.ky,$APP.Aj,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[!0,$APP.An,R$a,"cljs/core.cljs",20,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.hy,$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.hy,$APP.Nv,$APP.xy],null),new $APP.H(null,4,5,$APP.I,
[$APP.hy,$APP.Nv,$APP.xy,$APP.nx],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hy,$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.hy,$APP.Nv,$APP.xy],null),new $APP.H(null,4,5,$APP.I,[$APP.hy,$APP.Nv,$APP.xy,$APP.nx],null)),$APP.Cx,$APP.M(null,null,null)],null),1,1503,1503,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hy,$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.hy,$APP.Nv,$APP.xy],null),new $APP.H(null,4,5,$APP.I,[$APP.hy,$APP.Nv,$APP.xy,$APP.nx],null)),null,$APP.k($APP.Ts)?$APP.Ts.Z:
null]));return d.B?d.B(c,a,b):d.call(null,c,a,b)}return $APP.Ps(c,a,b)};
W$a=function(a,b){if("undefined"===typeof T$a||"undefined"===typeof U$a||"undefined"===typeof V$a||"undefined"===typeof KR)KR=function(c,d,g){this.Bd=c;this.Xb=d;this.Ek=g;this.O=917504;this.U=0},KR.prototype.da=function(c,d){return new KR(this.Bd,this.Xb,d)},KR.prototype.ba=function(){return this.Ek},KR.prototype.fb=function(c,d){return $APP.Ps(this.Bd,this.Xb.j?this.Xb.j(d):this.Xb.call(null,d),d.J?d.J():d.call(null))},KR.prototype.bb=function(c,d,g){return $APP.Ps(this.Bd,this.Xb.j?this.Xb.j(d):
this.Xb.call(null,d),g)},KR.cb=!0,KR.Ya="clojure.core.reducers/t_clojure$core$reducers60622",KR.gb=function(c){return $APP.Vb(c,"clojure.core.reducers/t_clojure$core$reducers60622")};return new KR(a,b,$APP.F)};
X$a=function(a){return W$a(a,function(b){return function(){function c(l,n){return $APP.kd(n)?$APP.Ps(X$a(n),b,l):b.A?b.A(l,n):b.call(null,l,n)}function d(){return b.J?b.J():b.call(null)}var g=null;g=function(l,n){switch(arguments.length){case 0:return d.call(this);case 2:return c.call(this,l,n)}throw Error("Invalid arity: "+arguments.length);};g.J=d;g.A=c;return g}()})};Y$a=function(a,b){var c=$APP.kh.j(-1);return S$a(function(d,g){d[$APP.lh.A(c,$APP.Kba)]=g;return d},b,X$a(a))};
aab=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,$APP.LR,1E-8);g=$APP.C.B(g,Z$a,!1);var l=$APP.Tc(c);a=(new $APP.$$a.Solver(a,l,{absoluteTolerance:d,relativeTolerance:d,rawFunction:!0})).integrate(b,$APP.rt.j(c));return $APP.k(g)?a:$APP.Jl.A($APP.gu,a)};
bab=function(a,b,c,d){d=$APP.qe(d);var g=$APP.C.B(d,h9a,!0),l=$APP.ef(c),n=$APP.rt.j(b),p=$APP.k(g)?$APP.MR.K(a,b,c,new $APP.f(null,1,[$APP.xQ,$APP.zQ],null)):function(){bH($APP.kw,"emmy.numerical.ode",195,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["Not compiling function for ODE analysis"],null)},null),-2088371585);var v=$APP.Je.A(a,b);return function(t,A){t=HN.A(t,c);t=v.j?v.j(t):v.call(null,t);return Y$a(t,A)}}();return aab(function(v,t,A){return p.B?p.B(t,A,n):p.call(null,t,A,n)},
0,l,d)};
eab=function(a,b){return function(){function c(l,n,p,v){function t(W){var Z=HN.A(G.j?G.j(W):G.call(null,W),l);$APP.k(A)&&(A.A?A.A(W,Z):A.call(null,W,Z));return $APP.Ne(B,new $APP.H(null,2,5,$APP.I,[W,Z],null))}v=$APP.qe(v);var A=$APP.C.A(v,cab),B=$APP.kh.j(new $APP.H(null,2,5,$APP.I,[0,null],null)),G=bab(a,b,l,v);if($APP.k(A)){n=$APP.r($APP.Jj.B(0,p,n));v=null;for(var J=0,O=0;;)if(O<J){var R=v.aa(null,O);t(R);O+=1}else if(n=$APP.r(n))v=n,$APP.pd(v)?(n=$APP.lc(v),O=$APP.mc(v),v=n,J=$APP.Tc(n),n=O):
(n=$APP.u(v),t(n),n=$APP.w(v),v=null,J=0),O=0;else break}$APP.eb(dab(p,$APP.x.A($APP.Fb(B),0)))&&t(p);G.J?G.J():G.call(null);return $APP.x.A($APP.Fb(B),1)}function d(l,n,p){return g.K(l,n,p,$APP.F)}var g=null;g=function(l,n,p,v){switch(arguments.length){case 3:return d.call(this,l,n,p);case 4:return c.call(this,l,n,p,v)}throw Error("Invalid arity: "+arguments.length);};g.B=d;g.K=c;return g}()};
fab=function(a,b,c,d,g){a=bab(a,b,c,new $APP.f(null,2,[$APP.LR,1E-6,h9a,!0],null));try{return $APP.Hl.A(a,function(){return function p(n){return new $APP.de(null,function(){for(var v=n;;)if(v=$APP.r(v)){if($APP.pd(v)){var t=$APP.lc(v),A=$APP.Tc(t),B=$APP.fe(A);a:for(var G=0;;)if(G<A){var J=$APP.bd(t,G);J<d+g/2&&B.add(J);G+=1}else{t=!0;break a}return t?$APP.ie($APP.ke(B),p($APP.mc(v))):$APP.ie($APP.ke(B),null)}B=$APP.u(v);if(B<d+g/2)return $APP.Yd(B,p($APP.Fc(v)));v=$APP.Fc(v)}else return null},null,
null)}($APP.Jj.B(0,d+g,g))}())}finally{a.J?a.J():a.call(null)}};
NR=function(a,b,c){var d=1/3,g=1/24,l=3/44,n=1/14;(0>function(){var R=a<b?a:b;return R<c?R:c}()||1.5E-38>function(){var R=a+b;var W=a+c;R=R<W?R:W;W=b+c;return R<W?R:W}()||3E37<function(){var R=a>b?a:b;return R>c?R:c}())&&yD("Carlson R_F");for(var p=a,v=b,t=c;;){var A=Math.sqrt(v),B=Math.sqrt(t);A=Math.sqrt(p)*(A+B)+A*B;p=.25*(p+A);v=.25*(v+A);A=.25*(t+A);t=d*(p+v+A);var G=(t-p)/t,J=(t-v)/t,O=(t-A)/t;if(.0025<function(){var R=Math.abs(G);var W=Math.abs(J);R=R>W?R:W;W=Math.abs(O);return R>W?R:W}())t=
A;else return d=G*J-O*O,p=G*J*O,(1+(g*d-.1-l*p)*d+n*p)/Math.sqrt(t)}};
gab=function(a,b,c){var d=3/14,g=1/6,l=9/22,n=3/26,p=.25*l,v=1.5*n;(0>(a<b?a:b)||1E-25>function(){var ia=a+b;return ia<c?ia:c}()||4.5E21<function(){var ia=a>b?a:b;return ia>c?ia:c}())&&yD("Carlson R_D");for(var t=a,A=b,B=c,G=0,J=1;;){var O=Math.sqrt(A),R=Math.sqrt(B);O=Math.sqrt(t)*(O+R)+O*R;G+=J/(R*(B+O));J*=.25;t=.25*(t+O);R=.25*(A+O);B=.25*(B+O);A=.2*(t+R+3*B);var W=(A-t)/A,Z=(A-R)/A,fa=(A-B)/A;if(.0015<function(){var ia=Math.abs(W);var ja=Math.abs(Z);ia=ia>ja?ia:ja;ja=Math.abs(fa);return ia>ja?
ia:ja}())A=R;else return t=W*Z,O=fa*fa,B=t-O,O=t-6*O,R=O+B+B,3*G+J*(1+O*(p*O-v*fa*R-d)+fa*(g*R+fa*(l*B-fa*n*t)))/(A*Math.sqrt(A))}};
hab=function(a,b){var c=2.236/1.3E-19,d=.257049/25,g=1/3,l=1/7,n=9/22;(0>a||$APP.Uc.A(b,0)||1.69E-38>a+Math.abs(b)||3E37<a+Math.abs(b)||b<-c&&0<a&&a<d)&&yD("Carlson R_C");0<b?a=new $APP.H(null,3,5,$APP.I,[a,b,1],null):(c=a-b,a=new $APP.H(null,3,5,$APP.I,[c,-b,Math.sqrt(a)/Math.sqrt(c)],null));b=$APP.x.B(a,0,null);c=$APP.x.B(a,1,null);for(a=$APP.x.B(a,2,null);;){d=2*Math.sqrt(b)*Math.sqrt(c)+c;b=.25*(b+d);c=.25*(c+d);d=g*(b+c+c);var p=(c-d)/d;if(!(.0012<Math.abs(p)))return(1+p*p*(.3+p*(l+p*(.375+p*
n))))/Math.sqrt(d)*a}};
iab=function(a,b,c,d){var g=3/14,l=1/3,n=3/22,p=3/26,v=.75*n,t=1.5*p,A=.5*l,B=n+n;(0>function(){var wa=a<b?a:b;return wa<c?wa:c}()||2.5E-13>function(){var wa=a+b;var Ba=a+c;wa=wa<Ba?wa:Ba;Ba=b+c;wa=wa<Ba?wa:Ba;Ba=Math.abs(d);return wa<Ba?wa:Ba}()||9E11<function(){var wa=a>b?a:b;wa=wa>c?wa:c;var Ba=Math.abs(d);return wa>Ba?wa:Ba}())&&yD("Carlson R_J");var G=0<d?new $APP.H(null,4,5,$APP.I,[a,b,c,d],null):function(){var wa=function(){var yb=a<b?a:b;return yb<c?yb:c}(),Ba=function(){var yb=a>b?a:b;return yb>
c?yb:c}(),Qa=a+b+c-wa-Ba,Va=1/(Qa-d),cb=Va*(Ba-Qa)*(Qa-wa),pb=Qa+cb,rb=hab(wa*Ba/Qa,d*pb/Qa);return new $APP.H(null,7,5,$APP.I,[wa,Qa,Ba,pb,Va,cb,rb],null)}(),J=$APP.x.B(G,0,null),O=$APP.x.B(G,1,null),R=$APP.x.B(G,2,null),W=$APP.x.B(G,3,null),Z=$APP.x.B(G,4,null),fa=$APP.x.B(G,5,null);G=$APP.x.B(G,6,null);var ia=R,ja=W;W=0;for(R=1;;){var ta=Math.sqrt(J),ua=Math.sqrt(O),ca=Math.sqrt(ia),V=ta*(ua+ca)+ua*ca;W+=R*hab(Math.pow(ja*(ta+ua+ca)+ta*ua*ca,2),ja*Math.pow(ja+V,2));R*=.25;J=.25*(J+V);O=.25*(O+
V);ia=.25*(ia+V);V=.25*(ja+V);ja=.2*(J+O+ia+V+V);var da=(ja-J)/ja,Y=(ja-O)/ja,ea=(ja-ia)/ja,ya=(ja-V)/ja;if(.0015<function(){var wa=Math.abs(da);var Ba=Math.abs(Y);wa=wa>Ba?wa:Ba;Ba=Math.abs(ea);wa=wa>Ba?wa:Ba;Ba=Math.abs(ya);return wa>Ba?wa:Ba}())ja=V;else return V=da*(Y+ea)+Y*ea,ta=da*Y*ea,ua=ya*ya,ca=V-3*ua,g=3*W+R*(1+ca*(v*ca-t*(ta+2*ya*(V-ua))-g)+ta*(A+ya*(ya*p-B))+ya*V*(l-ya*n)+-(l*ya*ua))/(ja*Math.sqrt(ja)),0>=d?Z*(fa*g+3*(G-NR(J,O,ia))):g}};
jab=function(a,b){var c=Math.sin(a);b*=c;return c*NR(Math.pow(Math.cos(a),2),(1-b)*(1+b),1)};kab=function(a,b){if($APP.Uc.A(a,1))return b.A?b.A(Infinity,1):b.call(null,Infinity,1);var c=1,d=Math.sqrt(1-a*a),g=a;a=0;for(var l=1;;){if(Math.abs(g)<OR)return c=d=Math.PI/2/c,d*=1-a/2,b.A?b.A(c,d):b.call(null,c,d);var n=Math.sqrt(c*d),p=(c-d)/2;a+=g*g*l;l*=2;c=(c+d)/2;d=n;g=p}};
lab=function(a,b){var c=0>a;if(c){var d=1-a,g=Math.sqrt(d);return new $APP.H(null,4,5,$APP.I,[c,-(a/d),b*g,g],null)}return new $APP.H(null,4,5,$APP.I,[c,a,b,1],null)};PR=function(a,b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return wL.C($APP.y([a,c,d,b]))};QR=function(a){return $APP.x.B(a,0,null)};RR=function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null),c=$APP.x.B(a,2,null);a=$APP.x.B(a,3,null);return wL.C($APP.y([b,c,a]))};
mab=function(a){return lG.j(TF.A(nG.j(QR(a)),nG.j(RR(a))))};nab=function(a){return lG.j(TF.A(nG.j(RR(a)),nG.j(QR(a))))};oab=function(a){return function(b){var c=SF.A(1,lG.j(TF.A(1,nG.j(a)))),d=SF.A(mG.A(-1,c),nG.j(a)),g=QR(b);b=RR(b);var l=DH.A(a,b);return PR(kG.A(c,mG.A(g,l)),mG.C(kG.C(c,a,$APP.y([g])),b,$APP.y([kG.C(d,a,$APP.y([l]))])))}};
pab=function(a,b){return function(c){var d=QR(c);c=RR(c);var g=nG.j(b),l=DH.A(a,c),n=SF.A(1,lG.j(TF.A(1,g))),p=TF.A(n,1);g=kG.A(n,mG.A(d,kG.A(l,b)));d=mG.C(kG.C(n,b,$APP.y([a,d])),c,$APP.y([kG.C(p,a,$APP.y([l]))]));return PR(g,d)}};qab=function(a){return function(b){var c=QR(b);b=RR(b);b=a.j?a.j(b):a.call(null,b);return PR(c,b)}};SR=function(a,b){return F2a($APP.Yj.K(b,$APP.rg,rab,!0),a)};sab=function(a){return rab.A($APP.ed(a),!1)};tab=function(a){return dO(E2a(a))};
xab=function(a,b,c,d,g){return uab(a,b,new $APP.f(null,3,[vab,c,wab,d,TR,g],null))};yab=function(){return function(a){return B2a(a)}};zab=function(a,b){return function(c){return SR(b,c)}};Aab=function(a){return vab.j(eO(a))};Bab=function(a){return wab.j(eO(a))};Cab=function(a){return TR.j(eO(a))};Dab=function(a,b){return SF.A(mG.A(a,b),mG.A(1,kG.A(a,b)))};Eab=function(a,b){return SF.A(mG.A(a,b),mG.A(1,kG.A(SF.A(a,UR),SF.A(b,UR))))};$APP.qa.prototype.Xe=$APP.ba(3,function(a){return this.Wc(this.div(a).multiply(a))});
$APP.za.prototype.Xe=$APP.ba(2,function(a){return $APP.Ga(this,a).remainder});$APP.qa.prototype.Ve=$APP.ba(1,function(){return 1==(this.jb&1)});$APP.za.prototype.Ve=$APP.ba(0,function(){return 0==this.pb.length&&-1==this.lc||0<this.pb.length&&0!=(this.pb[0]&1)});var pD=null,T$a={};mD.prototype.getName=function(){return this.name};mD.prototype.toString=function(){return $APP.m.j(this.name)};mD.prototype.Y=function(a,b){return b instanceof mD?$APP.Uc.A(this.name,b.name):!1};mD.prototype.ka=function(){return $APP.yc(this.name)};
Fab=new $APP.q("emmy.mechanics.lagrange","generalized-LE","emmy.mechanics.lagrange/generalized-LE",1641199781,null);Gab=new $APP.q(null,"matcher","matcher",1187762532,null);Hab=new $APP.q(null,"two-tensor-info","two-tensor-info",-594608408,null);Iab=new $APP.q("emmy.pattern.match","match","emmy.pattern.match/match",-1752583918,null);Jab=new $APP.q("emmy.env","vector-field?","emmy.env/vector-field?",1750013183,null);Kab=new $APP.q("emmy.env","ancestor-frame","emmy.env/ancestor-frame",-750459580,null);
VR=new $APP.q(null,"delta-t","delta-t",1769095452,null);Lab=new $APP.q("emmy.calculus.manifold","R2-polar","emmy.calculus.manifold/R2-polar",1688944980,null);Mab=new $APP.q("emmy.function","arg-shift","emmy.function/arg-shift",606567391,null);Nab=new $APP.q(null,"from","from",-839142725,null);Oab=new $APP.q(null,"find-path","find-path",-63940675,null);Pab=new $APP.q("emmy.env","raise1","emmy.env/raise1",-1052717631,null);Qab=new $APP.q("emmy.env","raise2","emmy.env/raise2",-205139274,null);
Rab=new $APP.q("emmy.rational-function","abs","emmy.rational-function/abs",-1087782177,null);Sab=new $APP.q(null,"golden-cut","golden-cut",1058787306,null);Tab=new $APP.q("cljs.core","checked-aset'","cljs.core/checked-aset'",163859714,null);ZK=new $APP.E("emmy.structure","down","emmy.structure/down",-1744668711);Uab=new $APP.q("emmy.mechanics.hamilton","flow-transform","emmy.mechanics.hamilton/flow-transform",-1174545373,null);jK=new $APP.q(null,"atan","atan",-1026550135,null);
o7a=new $APP.E(null,"sigma","sigma",-63715703);Vab=new $APP.q("emmy.expression","fmap","emmy.expression/fmap",957815726,null);Wab=new $APP.q(null,"combine-arities","combine-arities",-1180435548,null);Xab=new $APP.q(null,"trace2up","trace2up",522966671,null);Yab=new $APP.q("emmy.env","frame-params","emmy.env/frame-params",2045928944,null);Zab=new $APP.q("emmy.rational-function","add","emmy.rational-function/add",2076598657,null);eRa=new $APP.E(null,"protocol-prop","protocol-prop",-58388138);
$ab=new $APP.q("emmy.polynomial","reciprocal","emmy.polynomial/reciprocal",142220435,null);abb=new $APP.q("emmy.generic","asec","emmy.generic/asec",-941957938,null);bbb=new $APP.q(null,"definite-integral","definite-integral",760619981,null);cbb=new $APP.q(null,"oneform-field?","oneform-field?",-1326324759,null);jSa=new $APP.E(null,"with-meta","with-meta",-1566856820);dbb=new $APP.q("emmy.env","D-numeric","emmy.env/D-numeric",-590583872,null);
ebb=new $APP.q("emmy.matrix","s:transpose","emmy.matrix/s:transpose",351992212,null);fbb=new $APP.q("emmy.special.factorial","rising-factorial","emmy.special.factorial/rising-factorial",611783975,null);gbb=new $APP.q("emmy.env","Cartan-\x3eforms","emmy.env/Cartan-\x3eforms",307556946,null);hbb=new $APP.q(null,"within","within",1563704062,null);ibb=new $APP.q(null,"ruleset","ruleset",-504741885,null);
jbb=new $APP.q("emmy.special.factorial","stirling-second-kind","emmy.special.factorial/stirling-second-kind",303684776,null);kbb=new $APP.q("emmy.matrix","invert","emmy.matrix/invert",2070206201,null);lbb=new $APP.q("emmy.value","kind","emmy.value/kind",402745879,null);DPa=new $APP.q("cljs.core","PersistentHashMap","cljs.core/PersistentHashMap",-454120575,null);mbb=new $APP.q(null,"extract-tangent","extract-tangent",-1785612646,null);
nbb=new $APP.q("emmy.calculus.derivative","symbolic-taylor-series","emmy.calculus.derivative/symbolic-taylor-series",900301948,null);obb=new $APP.q(null,"emmy.calculus.frame","emmy.calculus.frame",-1927354137,null);pbb=new $APP.q("emmy.modint","chinese-remainder","emmy.modint/chinese-remainder",989096339,null);qbb=new $APP.q("emmy.generic","integer-part","emmy.generic/integer-part",-1536207222,null);rbb=new $APP.q("emmy.env","F-\x3eCT","emmy.env/F-\x3eCT",485081,null);
sbb=new $APP.q("emmy.calculus.connection","make-Christoffel-1","emmy.calculus.connection/make-Christoffel-1",-1898172660,null);tbb=new $APP.q("emmy.matrix","row-matrix-\x3evector","emmy.matrix/row-matrix-\x3evector",1051960094,null);ubb=new $APP.q(null,"H-state-\x3ematrix","H-state-\x3ematrix",859345923,null);vbb=new $APP.q("emmy.rational-function","negative?","emmy.rational-function/negative?",711662223,null);t5a=new $APP.E("emmy.calculus.covariant","Cartan","emmy.calculus.covariant/Cartan",-529045012);
wbb=new $APP.q(null,"exponent-contract","exponent-contract",1372913958,null);xbb=new $APP.q(null,"literal-function?","literal-function?",-391290455,null);ybb=new $APP.q(null,"map-vals","map-vals",-818445670,null);zbb=new $APP.q(null,"coefficients","coefficients",1939272705,null);Abb=new $APP.q(null,"fold-\x3escan-fn","fold-\x3escan-fn",1897258390,null);Bbb=new $APP.q(null,"the-next","the-next",-1182032600,null);Cbb=new $APP.q(null,"L-free-particle","L-free-particle",51383692,null);
Dbb=new $APP.q("emmy.pattern.syntax","compile-pattern","emmy.pattern.syntax/compile-pattern",-1933550162,null);WR=new $APP.E(null,"tilted","tilted",-1077184052);Ebb=new $APP.q("emmy.env","alternate-angles","emmy.env/alternate-angles",-1503638556,null);Fbb=new $APP.q("emmy.env","velocity","emmy.env/velocity",-92745197,null);Gbb=new $APP.q("emmy.dual","tangent","emmy.dual/tangent",-1107810866,null);h9a=new $APP.E(null,"compile?","compile?",-826687650);
Hbb=new $APP.q("emmy.special.factorial","subfactorial","emmy.special.factorial/subfactorial",1441604625,null);Ibb=new $APP.q(null,"define-coordinates","define-coordinates",785984378,null);Jbb=new $APP.q(null,"symplectic?","symplectic?",-1923699789,null);YR=new $APP.E(null,"skip-protocol-flag","skip-protocol-flag",-1426798630);Kbb=new $APP.q("emmy.structure","component","emmy.structure/component",-513246212,null);Lbb=new $APP.E(null,"micros","micros",420024622);
Mbb=new $APP.q("emmy.series","power-series*","emmy.series/power-series*",-1275455499,null);Nbb=new $APP.q("emmy.calculus.hodge-star","Hodge-star","emmy.calculus.hodge-star/Hodge-star",-972449625,null);Obb=new $APP.q("emmy.series","power-series?","emmy.series/power-series?",1083572761,null);Pbb=new $APP.q(null,"diagonal","diagonal",-329457619,null);Qbb=new $APP.q("emmy.pattern.rule","top-down","emmy.pattern.rule/top-down",-421921957,null);
Rbb=new $APP.q("emmy.series","identity","emmy.series/identity",-1687183655,null);Sbb=new $APP.q("emmy.quaternion","real-part","emmy.quaternion/real-part",1487460155,null);Tbb=new $APP.q("emmy.pattern.syntax","restriction","emmy.pattern.syntax/restriction",-1325345598,null);Ubb=new $APP.q("emmy.env","S3-stereographic","emmy.env/S3-stereographic",-419602625,null);Vbb=new $APP.q("emmy.calculus.manifold","attach-patch","emmy.calculus.manifold/attach-patch",-1143415289,null);
Wbb=new $APP.q("emmy.expression","-\x3eLiteral","emmy.expression/-\x3eLiteral",-768118032,null);Xbb=new $APP.E(null,"millis","millis",-1338288387);ZR=new $APP.q(null,"phi","phi",113733223,null);Ybb=new $APP.q("emmy.env","indexed-\x3etyped","emmy.env/indexed-\x3etyped",798465885,null);Zbb=new $APP.q(null,"lowest-degree","lowest-degree",1042665898,null);$bb=new $APP.q("emmy.mechanics.rotation","rotate-x-tuple","emmy.mechanics.rotation/rotate-x-tuple",1209966635,null);
acb=new $APP.q("emmy.quaternion","J-tensor","emmy.quaternion/J-tensor",2007933375,null);bcb=new $APP.q("emmy.env","interior-product","emmy.env/interior-product",1038623856,null);ccb=new $APP.q("emmy.env","vector-field-\x3ebasis-components","emmy.env/vector-field-\x3ebasis-components",-1281813315,null);dcb=new $APP.q(null,"flush-obvious-ones","flush-obvious-ones",1647447327,null);ecb=new $APP.q("emmy.util.logic","*log-assumptions?*","emmy.util.logic/*log-assumptions?*",-1434219461,null);
$APP.xQ=new $APP.E(null,"calling-convention","calling-convention",-1148806156);fcb=new $APP.q("emmy.env","make-four-tuple","emmy.env/make-four-tuple",1211887888,null);gcb=new $APP.q("emmy.env","zero?","emmy.env/zero?",1552443374,null);hcb=new $APP.q("emmy.mechanics.hamilton","H-state?","emmy.mechanics.hamilton/H-state?",1455823230,null);icb=new $APP.q("Math","asinh","Math/asinh",-1387635973,null);
jcb=new $APP.q("emmy.numerical.ode","state-advancer","emmy.numerical.ode/state-advancer",-1066425555,null);$R=new $APP.E("emmy.value","seq","emmy.value/seq",2124022964);kcb=new $APP.q("emmy.function","*strict-arity-checks*","emmy.function/*strict-arity-checks*",64089365,null);lcb=new $APP.q("emmy.env","denominator","emmy.env/denominator",-227464344,null);mcb=new $APP.q(null,"emmy.expression.cse","emmy.expression.cse",-423533766,null);ncb=new $APP.q(null,"powers","powers",311385535,null);
ocb=new $APP.q("emmy.env","S2p-Riemann","emmy.env/S2p-Riemann",-1296230970,null);pcb=new $APP.q(null,"carlson-rd","carlson-rd",-1185982603,null);qcb=new $APP.q(null,"carlson-rc","carlson-rc",-572153565,null);rcb=new $APP.q("emmy.env","patch-names","emmy.env/patch-names",1713205312,null);aS=new $APP.q(null,"manifold","manifold",-299796682,null);scb=new $APP.q(null,"log1-x-series","log1-x-series",-1278924827,null);tcb=new $APP.q("emmy.env","tex$$","emmy.env/tex$$",1405245746,null);
ucb=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer-recursive","emmy.rational-function.interpolate/bulirsch-stoer-recursive",1004634018,null);vcb=new $APP.q("emmy.special.factorial","-\x3ebigint","emmy.special.factorial/-\x3ebigint",-2032215075,null);wcb=new $APP.E(null,"primal","primal",-1668271542);xcb=new $APP.q("emmy.pattern.match","fail","emmy.pattern.match/fail",175383078,null);
ycb=new $APP.q("emmy.polynomial.interpolate","neville-incremental","emmy.polynomial.interpolate/neville-incremental",-1468130221,null);zcb=new $APP.q(null,"patch-names","patch-names",-1547977741,null);Acb=new $APP.q("emmy.mechanics.lagrange","spherical-\x3erectangular","emmy.mechanics.lagrange/spherical-\x3erectangular",718057911,null);bS=new $APP.q(null,"simplify","simplify",1041318062,null);gJ=new $APP.q("emmy.pattern.consequence","succeed","emmy.pattern.consequence/succeed",-2134737526,null);
Bcb=new $APP.q(null,"emmy.structure","emmy.structure",-1841347423,null);Ccb=new $APP.q("emmy.calculus.covariant","Cartan-\x3eCartan-over-map","emmy.calculus.covariant/Cartan-\x3eCartan-over-map",705943493,null);Dcb=new $APP.q("emmy.calculus.form-field","exterior-derivative","emmy.calculus.form-field/exterior-derivative",-377546215,null);Ecb=new $APP.q("emmy.matrix","column","emmy.matrix/column",-1629830083,null);Fcb=new $APP.q("emmy.env","one-like","emmy.env/one-like",-707832446,null);
Gcb=new $APP.q("emmy.env","D-reverse","emmy.env/D-reverse",-1572294824,null);Hcb=new $APP.q("emmy.util","re-matches?","emmy.util/re-matches?",48524176,null);xUa=new $APP.E(null,"output_","output_",-36797880);Icb=new $APP.q("emmy.calculus.connection","literal-Cartan","emmy.calculus.connection/literal-Cartan",-747501442,null);Jcb=new $APP.q(null,"emmy.dual","emmy.dual",-1682107932,null);Kcb=new $APP.q("emmy.generic","asin","emmy.generic/asin",-27711941,null);
Lcb=new $APP.q("emmy.numerical.unimin.bracket","parabolic-pieces","emmy.numerical.unimin.bracket/parabolic-pieces",-467891697,null);Mcb=new $APP.q(null,"sincos-\x3etrig","sincos-\x3etrig",23955403,null);Ncb=new $APP.q(null,"carlson-rf","carlson-rf",1245654373,null);Ocb=new $APP.q(null,"carlson-rj","carlson-rj",-1303485699,null);cS=new $APP.E("emmy.structure","structure","emmy.structure/structure",1597503132);Pcb=new $APP.q(null,"reverse-segment?","reverse-segment?",-1059328125,null);
Qcb=new $APP.E(null,"backward","backward",554036364);Rcb=new $APP.q("emmy.numsymb","sqrt?","emmy.numsymb/sqrt?",1819733409,null);Scb=new $APP.q("emmy.numsymb","quotient?","emmy.numsymb/quotient?",-293049979,null);Tcb=new $APP.q("emmy.numerical.unimin.bracket","bracket-max-scmutils","emmy.numerical.unimin.bracket/bracket-max-scmutils",-624944250,null);Ucb=new $APP.q("emmy.pattern.rule","choice*","emmy.pattern.rule/choice*",-1389094849,null);
Vcb=new $APP.q("emmy.matrix","down-\x3erow-matrix","emmy.matrix/down-\x3erow-matrix",-1472370279,null);Wcb=new $APP.q("emmy.generic","abs","emmy.generic/abs",2145223455,null);Xcb=new $APP.q("emmy.generic","dimension","emmy.generic/dimension",1450492416,null);Ycb=new $APP.q(null,"subfactorial","subfactorial",-515124997,null);H4a=new $APP.E("emmy.calculus.basis","coordinate-basis","emmy.calculus.basis/coordinate-basis",1695407987);Zcb=new $APP.q(null,"theta2","theta2",381749589,null);
$cb=new $APP.q(null,"one","one",-1719427865,null);adb=new $APP.q(null,"theta1","theta1",7117474,null);BRa=new $APP.E(null,"fexpr","fexpr",-122857150);bdb=new $APP.q("emmy.polynomial","touchard","emmy.polynomial/touchard",-1968715026,null);cdb=new $APP.q(null,"monomial?","monomial?",-1156841196,null);ddb=new $APP.q("emmy.simplify.rules","log-expand","emmy.simplify.rules/log-expand",-318543072,null);edb=new $APP.q(null,"S2p-Riemann","S2p-Riemann",1897909555,null);
fdb=new $APP.q("emmy.generic","log10","emmy.generic/log10",157064456,null);gdb=new $APP.q(null,"seq-\x3e","seq-\x3e",-877593267,null);hdb=new $APP.q(null,"coeff-functions","coeff-functions",825348842,null);dS=new $APP.q(null,"method","method",1696235119,null);idb=new $APP.q(null,"update-some","update-some",-1531449476,null);jdb=new $APP.q("emmy.modint","residue","emmy.modint/residue",234165167,null);kdb=new $APP.q(null,"s:solve-linear-left","s:solve-linear-left",682916545,null);
ldb=new $APP.q(null,"state-\x3eqddot","state-\x3eqddot",-108844324,null);mdb=new $APP.q(null,"R4-cyl","R4-cyl",-1631843753,null);ndb=new $APP.q(null,"coordinate-system-\x3eLame-coefficients","coordinate-system-\x3eLame-coefficients",-1264922352,null);DD=new $APP.E(null,"as-aliases","as-aliases",1485064798);odb=new $APP.q("emmy.env","arity","emmy.env/arity",-1218544587,null);pdb=new $APP.q(null,"iterated-bottom-up","iterated-bottom-up",86068982,null);
qdb=new $APP.q("emmy.mechanics.lagrange","coordinates","emmy.mechanics.lagrange/coordinates",-965732825,null);rdb=new $APP.q(null,"-\x3eangle-axis","-\x3eangle-axis",-837358946,null);eS=new $APP.q(null,"ops","ops",-1417105706,null);sdb=new $APP.q(null,"product?","product?",242454523,null);tdb=new $APP.q(null,"valid-methods","valid-methods",2063472095,null);udb=new $APP.q("cljs.core","qualified-ident?","cljs.core/qualified-ident?",-1863492566,null);
vdb=new $APP.q(null,"emmy.util.def","emmy.util.def",-349640323,null);wdb=new $APP.q("emmy.env","basis-\x3edimension","emmy.env/basis-\x3edimension",-87447731,null);fS=new $APP.E(null,"protocol-info","protocol-info",1471745843);xdb=new $APP.q("emmy.generic","solve-linear-right","emmy.generic/solve-linear-right",1371907076,null);ydb=new $APP.q(null,"make-four-tuple","make-four-tuple",-2053785145,null);
zdb=new $APP.q("emmy.calculus.basis","basis-\x3evector-basis","emmy.calculus.basis/basis-\x3evector-basis",860063458,null);Adb=new $APP.q(null,"Rz-matrix","Rz-matrix",-1387146081,null);qRa=new $APP.E(null,"types","types",590030639);Bdb=new $APP.q(null,"basis-prime","basis-prime",1652370905,null);Cdb=new $APP.q(null,"-\x3einfix","-\x3einfix",347316576,null);xOa=new $APP.E(null,"undeclared-var","undeclared-var",-1624364944);Ddb=new $APP.q(null,"ONE-matrix","ONE-matrix",-294443349,null);
Edb=new $APP.q("emmy.expression.render","-\x3eTeX","emmy.expression.render/-\x3eTeX",-865227985,null);Fdb=new $APP.q(null,"initial-count","initial-count",530024616,null);gS=new $APP.q(null,"remainder","remainder",-1608248897,null);Gdb=new $APP.q(null,"trivial-gcd","trivial-gcd",-1471361134,null);Hdb=new $APP.q("emmy.simplify.rules","trig-\x3esincos","emmy.simplify.rules/trig-\x3esincos",2105950818,null);Idb=new $APP.q(null,"c:generate","c:generate",1080088399,null);
Jdb=new $APP.q(null,"divisible?","divisible?",721956434,null);RRa=new $APP.q("cljs.core","ns-special-form","cljs.core/ns-special-form",1585185745,null);Kdb=new $APP.q("emmy.mechanics.hamilton","canonical?","emmy.mechanics.hamilton/canonical?",-1898264293,null);Ldb=new $APP.q("emmy.mechanics.hamilton","state-\x3ep","emmy.mechanics.hamilton/state-\x3ep",-521522917,null);Mdb=new $APP.q(null,"unquote?","unquote?",1120794638,null);
Ndb=new $APP.q("emmy.env","with-literal-functions","emmy.env/with-literal-functions",1083267414,null);TQa=new $APP.E(null,"pmasks","pmasks",-871416698);Odb=new $APP.q(null,"modified-bulirsch-stoer-sum","modified-bulirsch-stoer-sum",-651883568,null);Pdb=new $APP.q(null,"old","old",-184691163,null);Qdb=new $APP.q("cljs.core","true?","cljs.core/true?",-77973136,null);Rdb=new $APP.q(null,"Rayleigh-dissipation","Rayleigh-dissipation",387785803,null);
Sdb=new $APP.q("emmy.complex","complex?","emmy.complex/complex?",730887307,null);Tdb=new $APP.q("emmy.env","divide","emmy.env/divide",450475901,null);Udb=new $APP.q("emmy.env","column-matrix-\x3eup","emmy.env/column-matrix-\x3eup",945546204,null);Vdb=new $APP.q("emmy.env","brent-min","emmy.env/brent-min",-544244635,null);Wdb=new $APP.q(null,"beta","beta",2096137419,null);Xdb=new $APP.q(null,"permutation","permutation",-1081825529,null);Ydb=new $APP.q(null,"fresh-tag","fresh-tag",622887910,null);
Zdb=new $APP.q(null,"acceleration-tuple","acceleration-tuple",1955295370,null);hS=new $APP.q(null,"?factor","?factor",598737740,null);iS=new $APP.q(null,"four-tuple","four-tuple",1220782365,null);$db=new $APP.q(null,"careful-def","careful-def",1574540304,null);aeb=new $APP.q("emmy.env","manifold-point?","emmy.env/manifold-point?",1446354379,null);beb=new $APP.q("emmy.mechanics.rotation","angle-axis-\x3erotation-matrix","emmy.mechanics.rotation/angle-axis-\x3erotation-matrix",33550409,null);
ceb=new $APP.q(null,"expression","expression",1842843403,null);deb=new $APP.q("emmy.util","biginteger","emmy.util/biginteger",1646410917,null);eeb=new $APP.E(null,"polar-cylindrical","polar-cylindrical",-803036371);feb=new $APP.q(null,"replace-tag","replace-tag",1531237472,null);geb=new $APP.E("emmy.expression","abstract-down","emmy.expression/abstract-down",22046591);heb=new $APP.q(null,"sqrt?","sqrt?",-1493021640,null);ieb=new $APP.E(null,"check-point","check-point",-951160144);
jeb=new $APP.q("emmy.env","coordinate-system-\x3ebasis","emmy.env/coordinate-system-\x3ebasis",713194691,null);jS=new $APP.q("emmy.calculus.coordinate","coordinate-functions","emmy.calculus.coordinate/coordinate-functions",388209362,null);keb=new $APP.q("emmy.polynomial","eq","emmy.polynomial/eq",1834358746,null);leb=new $APP.q(null,"series*","series*",-172585970,null);$APP.meb=new $APP.q(null,"vector-field","vector-field",1291054264,null);
neb=new $APP.q("emmy.numerical.unimin.golden","extend-pt","emmy.numerical.unimin.golden/extend-pt",-1264405405,null);oeb=new $APP.q(null,"expression-simplifier","expression-simplifier",-1365588802,null);peb=new $APP.q("emmy.calculus.manifold","one-manifold-function","emmy.calculus.manifold/one-manifold-function",2042659286,null);kS=new $APP.q(null,"partial-derivative","partial-derivative",-1901056819,null);
qeb=new $APP.q("emmy.polynomial","-\x3epower-series","emmy.polynomial/-\x3epower-series",654679288,null);reb=new $APP.q("emmy.calculus.basis","basis-\x3eoneform-basis","emmy.calculus.basis/basis-\x3eoneform-basis",1230504834,null);seb=new $APP.q("emmy.simplify.rules","divide-numbers-through","emmy.simplify.rules/divide-numbers-through",569667771,null);teb=new $APP.q("emmy.env","elliptic-f","emmy.env/elliptic-f",-1150997741,null);
ueb=new $APP.q(null,"basis-\x3eoneform-basis","basis-\x3eoneform-basis",150278774,null);lS=new $APP.q(null,"identity?","identity?",-1064576891,null);veb=new $APP.q(null,"series?","series?",733908051,null);mS=new $APP.q(null,"cache?","cache?",38577578,null);web=new $APP.q("emmy.polynomial","monomial?","emmy.polynomial/monomial?",1804095046,null);qPa=new $APP.E(null,"goog-module","goog-module",-767061656);xeb=new $APP.q("emmy.env","evolution","emmy.env/evolution",-658829369,null);
yeb=new $APP.q("emmy.env","complex","emmy.env/complex",1972060261,null);nS=new $APP.q("cljs.core","IMeta","cljs.core/IMeta",-1459057517,null);zeb=new $APP.q("emmy.mechanics.hamilton","two-particle-center-of-mass","emmy.mechanics.hamilton/two-particle-center-of-mass",1019311275,null);Aeb=new $APP.q("emmy.matrix","get-in","emmy.matrix/get-in",1305824368,null);Beb=new $APP.q("emmy.mechanics.lagrange","Lagrangian-\x3eacceleration","emmy.mechanics.lagrange/Lagrangian-\x3eacceleration",-1247094327,null);
Ceb=new $APP.q("emmy.operator","context","emmy.operator/context",1970178364,null);Deb=new $APP.q("emmy.env","integer-part","emmy.env/integer-part",-852364132,null);Eeb=new $APP.q(null,"Qdot","Qdot",48449280,null);Feb=new $APP.E(null,"identity?","identity?",1589858878);Geb=new $APP.q("emmy.pattern.rule","fail","emmy.pattern.rule/fail",-1207554483,null);Heb=new $APP.q(null,"map-coefficients","map-coefficients",1799565654,null);
Ieb=new $APP.q("emmy.pattern.rule","rule","emmy.pattern.rule/rule",1557507652,null);Jeb=new $APP.q(null,"stream-integrator","stream-integrator",662343416,null);YSa=new $APP.E(null,"input","input",556931961);Keb=new $APP.q(null,"maxterms","maxterms",-1702656166,null);Leb=new $APP.E(null,"extend-type","extend-type",-517175606);Meb=new $APP.q("cljs.core","checked-aget","cljs.core/checked-aget",24024561,null);Neb=new $APP.q("emmy.env","square","emmy.env/square",-677973359,null);
Oeb=new $APP.q("emmy.env","compatible-shape","emmy.env/compatible-shape",999757184,null);Peb=new $APP.E(null,"fname","fname",1500291491);Qeb=new $APP.q(null,"fail","fail",-948220839,null);Reb=new $APP.q("emmy.mechanics.hamilton","polar-canonical-inverse","emmy.mechanics.hamilton/polar-canonical-inverse",177955478,null);tVa=new $APP.E(null,"error-level?","error-level?",778415885);Seb=new $APP.q(null,"nth-col","nth-col",510012518,null);oS=new $APP.q(null,"?theta","?theta",-893896091,null);
Teb=new $APP.q("emmy.calculus.metric","metric-\x3einverse-components","emmy.calculus.metric/metric-\x3einverse-components",-619552361,null);zVa=new $APP.E(null,"id!","id!",218090956);pS=new $APP.q(null,"quaternion?","quaternion?",1626848711,null);Ueb=new $APP.q("emmy.calculus.form-field","function-\x3eoneform-field","emmy.calculus.form-field/function-\x3eoneform-field",-1387840999,null);Veb=new $APP.q(null,"rsolve","rsolve",108587268,null);
Web=new $APP.q("emmy.calculus.manifold","corresponding-velocities","emmy.calculus.manifold/corresponding-velocities",944974871,null);Xeb=new $APP.q("emmy.util.def","defgeneric","emmy.util.def/defgeneric",-1292804047,null);qS=new $APP.q(null,"indices","indices",422393184,null);Yeb=new $APP.q("emmy.env","numerator","emmy.env/numerator",-1634321984,null);Zeb=new $APP.q(null,"emmy.function","emmy.function",1327532696,null);$eb=new $APP.q("Math","tanh","Math/tanh",479074141,null);
HF=new $APP.E("emmy.value","scalar","emmy.value/scalar",1964041514);WN=new $APP.q("emmy.abstract.function","literal-function","emmy.abstract.function/literal-function",869741704,null);afb=new $APP.q(null,"rule","rule",-1924462512,null);bfb=new $APP.q("emmy.mechanics.lagrange","Lagrange-interpolation-function","emmy.mechanics.lagrange/Lagrange-interpolation-function",983357370,null);zPa=new $APP.E(null,"js-fn-var","js-fn-var",-565665358);
cfb=new $APP.q("emmy.generic","tanhc","emmy.generic/tanhc",-271568193,null);dfb=new $APP.q("emmy.quaternion","pure?","emmy.quaternion/pure?",112156834,null);HOa=new $APP.E(null,"global-goog-object\x26array","global-goog-object\x26array",907046210);rS=new $APP.q("b","coordinate-basis?","b/coordinate-basis?",-1009472899,null);efb=new $APP.q("emmy.simplify.rules","logexp","emmy.simplify.rules/logexp",-1658944749,null);
ffb=new $APP.q("emmy.mechanics.lagrange","L-central-rectangular","emmy.mechanics.lagrange/L-central-rectangular",-2050374616,null);gfb=new $APP.q(null,"matrix-\x3evector","matrix-\x3evector",1354067238,null);vK=new $APP.q(null,"??a1","??a1",2070706636,null);hfb=new $APP.q(null,"richardson-scan","richardson-scan",768006724,null);ifb=new $APP.q(null,"touchard","touchard",1495467264,null);wK=new $APP.q(null,"??a2","??a2",-73012434,null);xK=new $APP.q(null,"??a3","??a3",-1861674627,null);
sS=new $APP.q(null,"ancestor-frame","ancestor-frame",-1796645653,null);tS=new $APP.q("cljs.core","ISeqable","cljs.core/ISeqable",137437203,null);jfb=new $APP.q("emmy.env","make-Christoffel-1","emmy.env/make-Christoffel-1",1238138931,null);bZa=new $APP.q(null,"acos-cos","acos-cos",-652558231,null);kfb=new $APP.q(null,"metric-\x3econnection-1","metric-\x3econnection-1",1270458170,null);lfb=new $APP.q(null,"metric-\x3econnection-2","metric-\x3econnection-2",413672956,null);
mfb=new $APP.q("emmy.env","pullback-function","emmy.env/pullback-function",1996156673,null);nfb=new $APP.q("emmy.abstract.number","abstract-number?","emmy.abstract.number/abstract-number?",694084185,null);$APP.uS=new $APP.q(null,"points","points",153934644,null);ofb=new $APP.q("emmy.polynomial","-\x3eterms","emmy.polynomial/-\x3eterms",-1215301159,null);pfb=new $APP.q("emmy.structure","unflatten","emmy.structure/unflatten",-1050431230,null);
qfb=new $APP.q(null,"two-tensor-operation","two-tensor-operation",-1277856915,null);rfb=new $APP.q("emmy.series","tanh-series","emmy.series/tanh-series",1397818974,null);oPa=new $APP.q(null,"checked-aset'","checked-aset'",-510930777,null);tE=new $APP.E(null,"uses","uses",232664692);sfb=new $APP.q("emmy.util","machine-epsilon","emmy.util/machine-epsilon",896368496,null);tfb=new $APP.q(null,"known-operation?","known-operation?",-1185030050,null);
ufb=new $APP.q("emmy.polynomial","with-lower-arity","emmy.polynomial/with-lower-arity",-1979164496,null);vfb=new $APP.E(null,"protocol-with-overwriting-method","protocol-with-overwriting-method",319993011);wfb=new $APP.q("emmy.polynomial","map-coefficients","emmy.polynomial/map-coefficients",448776324,null);$APP.R3a=new $APP.E(null,"zero?","zero?",-1314772630);EPa=new $APP.q("cljs.core","List","cljs.core/List",1708954352,null);
xfb=new $APP.q("emmy.mechanics.lagrange","parametric-path-action","emmy.mechanics.lagrange/parametric-path-action",1421787236,null);yfb=new $APP.q("emmy.rational-function","coeff?","emmy.rational-function/coeff?",-736056791,null);zfb=new $APP.q("emmy.calculus.manifold","spacetime-rect","emmy.calculus.manifold/spacetime-rect",146933710,null);Afb=new $APP.q(null,"point-\x3ecoords","point-\x3ecoords",-1341974162,null);Bfb=new $APP.q(null,"constant-elimination","constant-elimination",444082136,null);
Cfb=new $APP.q("emmy.env","-\x3eL-state","emmy.env/-\x3eL-state",-2084350364,null);vS=new $APP.E(null,"stereographic","stereographic",-1557537208);Dfb=new $APP.q("emmy.env","manifold-type","emmy.env/manifold-type",-994601464,null);Efb=new $APP.q("emmy.mechanics.lagrange","linear-interpolants","emmy.mechanics.lagrange/linear-interpolants",438848742,null);Ffb=new $APP.q("emmy.calculus.frame","claim","emmy.calculus.frame/claim",2042144609,null);wS=new $APP.q(null,"??d1","??d1",1286203826,null);
xS=new $APP.q(null,"??d2","??d2",525254907,null);Gfb=new $APP.q(null,"patch","patch",2021306636,null);Hfb=new $APP.q("emmy.env","generalized-LE","emmy.env/generalized-LE",233003866,null);jOa=new $APP.E("cljs.analyzer","constant-table","cljs.analyzer/constant-table",-114131889);Ifb=new $APP.q(null,"nform-field?","nform-field?",-822258039,null);Jfb=new $APP.q("emmy.env","oneform-field?","emmy.env/oneform-field?",1913890886,null);Kfb=new $APP.q(null,"SR-coordinates?","SR-coordinates?",-159254540,null);
Lfb=new $APP.E(null,"extract-tangent","extract-tangent",868823123);Mfb=new $APP.q("emmy.generic","atan","emmy.generic/atan",-149083958,null);QS=new $APP.q(null,"coordinate-basis?","coordinate-basis?",-1009472993,null);Nfb=new $APP.q("emmy.env","binomial-series","emmy.env/binomial-series",-408596039,null);Ofb=new $APP.q(null,"meta49437","meta49437",-500220952,null);Pfb=new $APP.q("emmy.pattern.rule","bottom-up","emmy.pattern.rule/bottom-up",764915180,null);
Qfb=new $APP.q("emmy.algebra.fold","kahan","emmy.algebra.fold/kahan",-304103572,null);pUa=new $APP.E(null,"whitelist","whitelist",-979294437);RS=new $APP.q(null,"pattern","pattern",1882666950,null);SS=new $APP.q(null,"primal","primal",-27740015,null);zK=new $APP.q(null,"??b1","??b1",-1771260238,null);HTa=new $APP.q("cljs.core","reduce","cljs.core/reduce",2025430439,null);AK=new $APP.q(null,"??b2","??b2",1805392567,null);Rfb=new $APP.q("emmy.env","up","emmy.env/up",-1663352095,null);
Sfb=new $APP.q("cljs.core","float?","cljs.core/float?",-941017745,null);Tfb=new $APP.q(null,"metric-\x3einverse-components","metric-\x3einverse-components",-804339491,null);Ufb=new $APP.q("emmy.special.factorial","stirling-first-kind","emmy.special.factorial/stirling-first-kind",-1622973223,null);Vfb=new $APP.q("emmy.sr.frames","make-SR-frame","emmy.sr.frames/make-SR-frame",809775584,null);Wfb=new $APP.q(null,"compatible-H-state?","compatible-H-state?",-1949500168,null);
Xfb=new $APP.q("emmy.env","sech","emmy.env/sech",1861563112,null);Yfb=new $APP.q("emmy.polynomial","trailing-coefficient","emmy.polynomial/trailing-coefficient",-43718303,null);Zfb=new $APP.q("emmy.env","integrate-state-derivative","emmy.env/integrate-state-derivative",107604274,null);$fb=new $APP.q(null,"bundle-element","bundle-element",-1923897958,null);
agb=new $APP.q("emmy.mechanics.lagrange","Lagrangian-\x3estate-derivative","emmy.mechanics.lagrange/Lagrangian-\x3estate-derivative",765260420,null);bgb=new $APP.q(null,"velocities","velocities",1008302579,null);cgb=new $APP.q(null,"exact-zero?","exact-zero?",357843816,null);CD=new $APP.E(null,"libspec","libspec",1228503756);TS=new $APP.q(null,"??fs","??fs",-1640556976,null);dgb=new $APP.q("emmy.env","Cartan-transform","emmy.env/Cartan-transform",1356321911,null);
egb=new $APP.q("emmy.mechanics.rotation","rotate-y-tuple","emmy.mechanics.rotation/rotate-y-tuple",-327120368,null);fgb=new $APP.q("emmy.structure","opposite-orientation","emmy.structure/opposite-orientation",-898302298,null);ggb=new $APP.E(null,"compile-syntax-check","compile-syntax-check",-1865080468);hgb=new $APP.q(null,"emmy.expression","emmy.expression",-1323234745,null);igb=new $APP.q(null,"Euler-\x3eomega","Euler-\x3eomega",1655711102,null);
jgb=new $APP.q(null,"coordinate-system-\x3ebasis","coordinate-system-\x3ebasis",-316169058,null);PG=new $APP.E(null,"?err","?err",549653299);kgb=new $APP.q(null,"basis-components-\x3evector-field","basis-components-\x3evector-field",-2054657112,null);l2a=new $APP.q(null,"DOWN","DOWN",-1166138822,null);lgb=new $APP.q("emmy.calculus.form-field","get-rank","emmy.calculus.form-field/get-rank",-993270681,null);dK=new $APP.q(null,"??f1","??f1",-1548442439,null);
eK=new $APP.q(null,"??f2","??f2",745277317,null);US=new $APP.q("cljs.core","ICounted","cljs.core/ICounted",-1299011378,null);gK=new $APP.q(null,"??f3","??f3",-1809203400,null);hK=new $APP.q(null,"??f4","??f4",1817370441,null);mgb=new $APP.q(null,"standard-map","standard-map",1530905855,null);ngb=new $APP.q("emmy.structure","dimension","emmy.structure/dimension",1128670244,null);
ogb=new $APP.q("emmy.calculus.basis","coordinate-system-\x3ebasis","emmy.calculus.basis/coordinate-system-\x3ebasis",731026722,null);pgb=new $APP.q("emmy.env","wedge","emmy.env/wedge",1904030125,null);yOa=new $APP.E(null,"macro-present?","macro-present?",-1397713205);qgb=new $APP.q("emmy.env","coordinate-basis-oneform-field","emmy.env/coordinate-basis-oneform-field",873833783,null);rgb=new $APP.q("emmy.env","bigint?","emmy.env/bigint?",-697598861,null);sVa=new $APP.E(null,"config","config",994861415);
sgb=new $APP.q(null,"polar-\x3erectangular","polar-\x3erectangular",723200704,null);tgb=new $APP.q("emmy.env","brent-max","emmy.env/brent-max",-2073178861,null);ugb=new $APP.q(null,"R3-rect","R3-rect",-421879293,null);vgb=new $APP.q(null,"emmy.mechanics.time-evolution","emmy.mechanics.time-evolution",500695545,null);wgb=new $APP.q("emmy.env","pe","emmy.env/pe",207379544,null);xgb=new $APP.q("emmy.env","pi","emmy.env/pi",-919890821,null);
ygb=new $APP.q("emmy.matrix","by-cols*","emmy.matrix/by-cols*",842080009,null);VS=new $APP.q(null,"??n1","??n1",-1325838299,null);WS=new $APP.q(null,"??n2","??n2",-1403574689,null);zgb=new $APP.q("emmy.mechanics.rotation","Rz-matrix","emmy.mechanics.rotation/Rz-matrix",1697461158,null);Agb=new $APP.q(null,"with-frame","with-frame",1995405727,null);xVa=new $APP.E(null,"vargs_","vargs_",552132148);FOa=new $APP.E(null,"global-exports","global-exports",-1644865592);
Bgb=new $APP.q("emmy.simplify.rules","exp-\x3esincos","emmy.simplify.rules/exp-\x3esincos",188967388,null);Cgb=new $APP.q(null,"asin-series","asin-series",-191286736,null);Dgb=new $APP.q("emmy.calculus.vector-calculus","gradient","emmy.calculus.vector-calculus/gradient",51457926,null);Egb=new $APP.q(null,"emmy.autodiff","emmy.autodiff",1051420705,null);Fgb=new $APP.q("emmy.dual","compare","emmy.dual/compare",-1123148781,null);Ggb=new $APP.q("emmy.matrix","I","emmy.matrix/I",196338887,null);
XS=new $APP.E(null,"at-least","at-least",267196846);Hgb=new $APP.q("emmy.env","add-v:cs","emmy.env/add-v:cs",1969141461,null);Igb=new $APP.q("emmy.env","pullback-vector-field","emmy.env/pullback-vector-field",-1320189142,null);Jgb=new $APP.q("emmy.util.aggregate","monoid","emmy.util.aggregate/monoid",-1637277535,null);M8a=new $APP.E(null,"polynomial","polynomial",-832765162);Kgb=new $APP.q(null,"*TeX-sans-serif-symbols*","*TeX-sans-serif-symbols*",-854063910,null);
Q7a=new $APP.q("cljs.core","doto","cljs.core/doto",-1284816239,null);Lgb=new $APP.q(null,"Cartan-\x3eCartan-over-map","Cartan-\x3eCartan-over-map",-1216564554,null);$APP.RO=new $APP.E(null,"point","point",1813198264);Mgb=new $APP.q("emmy.polynomial","lower-arity","emmy.polynomial/lower-arity",-1280777346,null);Ngb=new $APP.q(null,"kronecker","kronecker",-759603946,null);Ogb=new $APP.q("emmy.generic","sec","emmy.generic/sec",936938387,null);
Pgb=new $APP.q("emmy.env","frame?","emmy.env/frame?",833425375,null);Qgb=new $APP.q(null,"indexed","indexed",2031290151,null);Z$a=new $APP.E(null,"js?","js?",731848670);rPa=new $APP.E(null,"node","node",581201198);Rgb=new $APP.q(null,"differential-of-map","differential-of-map",1243517525,null);Sgb=new $APP.q(null,"Boolean","Boolean",1661141587,null);Tgb=new $APP.q("emmy.pattern.rule","choice","emmy.pattern.rule/choice",-548605100,null);YS=new $APP.q(null,"analyzer","analyzer",-578676386,null);
Ugb=new $APP.q("emmy.function","get","emmy.function/get",-1793923368,null);Vgb=new $APP.q(null,"IKind","IKind",-1122621827,null);Wgb=new $APP.q("emmy.pattern.match","foreach-matcher","emmy.pattern.match/foreach-matcher",-1357230120,null);Xgb=new $APP.q("emmy.simplify.rules","even?","emmy.simplify.rules/even?",1406673330,null);Ygb=new $APP.q("series","power-series?","series/power-series?",-1037667389,null);cQa=new $APP.E(null,"binding-form?","binding-form?",1728940169);
Zgb=new $APP.q("emmy.pattern.rule","consequence","emmy.pattern.rule/consequence",-1340910887,null);$gb=new $APP.q("emmy.util.aggregate","sum","emmy.util.aggregate/sum",-1909275822,null);ahb=new $APP.q("emmy.quaternion","I-tensor","emmy.quaternion/I-tensor",1368886547,null);ZS=new $APP.q(null,"acot","acot",1103016569,null);$APP.MD=new $APP.E(null,"options","options",99638489);bhb=new $APP.q("emmy.calculus.form-field","wedge","emmy.calculus.form-field/wedge",1109134517,null);
chb=new $APP.q("emmy.env","vector:generate","emmy.env/vector:generate",-1936462599,null);dhb=new $APP.q(null,"assume!","assume!",1219209121,null);ehb=new $APP.q("emmy.calculus.manifold","S2p-stereographic","emmy.calculus.manifold/S2p-stereographic",233343695,null);fhb=new $APP.q("emmy.env","boost-direction","emmy.env/boost-direction",782295390,null);ghb=new $APP.q("emmy.polynomial","from-power-series","emmy.polynomial/from-power-series",-552872100,null);
uOa=new $APP.E("clojure.error","symbol","clojure.error/symbol",1544821994);hhb=new $APP.q(null,"components-\x3emetric","components-\x3emetric",-1449192205,null);ZH=new $APP.E(null,"arity","arity",-1808556135);mK=new $APP.q(null,"acos","acos",353741763,null);ihb=new $APP.q("emmy.polynomial","leading-exponents","emmy.polynomial/leading-exponents",134917691,null);jhb=new $APP.q(null,"sincos-\x3eexp1","sincos-\x3eexp1",-1351286233,null);
khb=new $APP.q(null,"sincos-\x3eexp2","sincos-\x3eexp2",935948490,null);$S=new $APP.q(null,"constant","constant",1260922224,null);lhb=new $APP.q("emmy.calculus.manifold","S3-gnomonic","emmy.calculus.manifold/S3-gnomonic",-987625972,null);mhb=new $APP.q("emmy.env","Lagrangian-\x3eenergy","emmy.env/Lagrangian-\x3eenergy",-1192894669,null);nhb=new $APP.q("emmy.util","compute-expt","emmy.util/compute-expt",107701436,null);aT=new $APP.q(null,"e-\x3ec","e-\x3ec",-1459982439,null);
ohb=new $APP.q("emmy.series","binomial-series","emmy.series/binomial-series",-57585989,null);phb=new $APP.q("emmy.polynomial.interpolate","modified-neville-fold","emmy.polynomial.interpolate/modified-neville-fold",-1720995209,null);qhb=new $APP.q(null,"canonical?","canonical?",-942586428,null);rhb=new $APP.q("emmy.mechanics.lagrange","acceleration-tuple","emmy.mechanics.lagrange/acceleration-tuple",-708335570,null);shb=new $APP.E(null,"lower-riemann","lower-riemann",-418483901);
thb=new $APP.q("emmy.mechanics.hamilton","polar-canonical","emmy.mechanics.hamilton/polar-canonical",1768890995,null);uhb=new $APP.q("emmy.calculus.covariant","make-Cartan","emmy.calculus.covariant/make-Cartan",1902493329,null);vhb=new $APP.q(null,"acsch","acsch",-1449651634,null);whb=new $APP.q(null,"emmy.rational-function.interpolate","emmy.rational-function.interpolate",231242309,null);bE=new $APP.E("clojure.error","phase","clojure.error/phase",275140358);
xhb=new $APP.E(null,"known-operation?","known-operation?",1469405719);yhb=new $APP.q(null,"rotate-left","rotate-left",-1088090459,null);g6a=new $APP.E("emmy.calculus.connection","Christoffel-1","emmy.calculus.connection/Christoffel-1",-714777450);zhb=new $APP.q("emmy.matrix","nth-row","emmy.matrix/nth-row",-1981439469,null);Ahb=new $APP.q("emmy.generic","floor","emmy.generic/floor",607506297,null);Bhb=new $APP.q("emmy.calculus.metric","trace2up","emmy.calculus.metric/trace2up",607614917,null);
Chb=new $APP.q("emmy.calculus.manifold","R2-rect","emmy.calculus.manifold/R2-rect",-1423078140,null);ROa=new $APP.E(null,"js-provide","js-provide",1052912493);Dhb=new $APP.q(null,"leading-coefficient","leading-coefficient",-1229509395,null);Ehb=new $APP.q("emmy.env","Riemann","emmy.env/Riemann",-219712800,null);Fhb=new $APP.q(null,"derivative?","derivative?",1454715490,null);Ghb=new $APP.q("emmy.structure","literal-down","emmy.structure/literal-down",-211692452,null);
Hhb=new $APP.q("emmy.env","symplectic-unit","emmy.env/symplectic-unit",2091030165,null);Ihb=new $APP.E(null,"warning-type","warning-type",1711103595);Jhb=new $APP.q("emmy.complex","parse-complex","emmy.complex/parse-complex",-1556002796,null);iRa=new $APP.E(null,"host-call","host-call",1059629755);Khb=new $APP.q("emmy.env","Lagrange-interpolation-function","emmy.env/Lagrange-interpolation-function",1187854249,null);Lhb=new $APP.q("emmy.pattern.match","not","emmy.pattern.match/not",-45534106,null);
Mhb=new $APP.q("emmy.calculus.manifold","uuid","emmy.calculus.manifold/uuid",-1498777606,null);Nhb=new $APP.E(null,"nodes","nodes",-2099585805);Ohb=new $APP.q(null,"acsc","acsc",-1149851176,null);Phb=new $APP.q("emmy.env","coordinate-functions","emmy.env/coordinate-functions",-1770294271,null);Qhb=new $APP.q("emmy.mechanics.hamilton","D-phase-space","emmy.mechanics.hamilton/D-phase-space",1553636618,null);Rhb=new $APP.q("emmy.value","set-js-meta!","emmy.value/set-js-meta!",-322342388,null);
Shb=new $APP.q(null,"fn-counter","fn-counter",245142765,null);Thb=new $APP.q(null,"*poly-simplify*","*poly-simplify*",710366657,null);bT=new $APP.q("cljs.core","IIndexed","cljs.core/IIndexed",-436490749,null);Uhb=new $APP.q(null,"compositional-canonical?","compositional-canonical?",-235019959,null);Vhb=new $APP.q("emmy.expression","sorted?","emmy.expression/sorted?",-283398484,null);Whb=new $APP.q("emmy.calculus.curvature","Riemann","emmy.calculus.curvature/Riemann",-439852890,null);
cT=new $APP.q(null,"square","square",-1842001092,null);Xhb=new $APP.q(null,"differential","differential",1372034786,null);Yhb=new $APP.q("emmy.generic","acsch","emmy.generic/acsch",-27957245,null);Zhb=new $APP.q(null,"two-down?","two-down?",640100597,null);$hb=new $APP.q("emmy.env","column-matrix-\x3evector","emmy.env/column-matrix-\x3evector",1058526148,null);aib=new $APP.q("emmy.mechanics.hamilton","Phi*","emmy.mechanics.hamilton/Phi*",-653609790,null);
bib=new $APP.q("emmy.mechanics.lagrange","Euler-Lagrange-operator","emmy.mechanics.lagrange/Euler-Lagrange-operator",656873984,null);cib=new $APP.q("emmy.util.permute","number-of-permutations","emmy.util.permute/number-of-permutations",280089544,null);dib=new $APP.q("emmy.generic","one-like","emmy.generic/one-like",-90952804,null);eib=new $APP.q(null,"Lagrangian-\x3eRouthian","Lagrangian-\x3eRouthian",222397111,null);fib=new $APP.q(null,"all-results","all-results",-1415580986,null);
dT=new $APP.q(null,"floor","floor",-772394748,null);gib=new $APP.q(null,"emmy.calculus.manifold","emmy.calculus.manifold",-1044647599,null);hib=new $APP.q("emmy.env","coordinatize","emmy.env/coordinatize",-952232144,null);rUa=new $APP.E(null,"allow-spec","allow-spec",448749872);iib=new $APP.q(null,"T-body-Euler","T-body-Euler",92639401,null);jib=new $APP.q("emmy.expression","expression-of","emmy.expression/expression-of",8468966,null);
kib=new $APP.E(null,"invalid-protocol-symbol","invalid-protocol-symbol",86246948);lib=new $APP.q(null,"seq:print","seq:print",-1136490111,null);dZa=new $APP.q(null,"atan-sin-cos","atan-sin-cos",-761958387,null);mib=new $APP.q(null,"-\x3etex-equation","-\x3etex-equation",-121272119,null);nib=new $APP.q(null,"p-\x3er","p-\x3er",1864824186,null);oib=new $APP.q("emmy.operator","make-operator","emmy.operator/make-operator",1283966800,null);
pib=new $APP.q("emmy.generic","sin","emmy.generic/sin",1382432478,null);qib=new $APP.E(null,"minterms","minterms",-1267652170);rib=new $APP.q("emmy.calculus.metric","oneform-field-\x3evector-field","emmy.calculus.metric/oneform-field-\x3evector-field",-1279709088,null);sib=new $APP.q(null,"Ry-matrix","Ry-matrix",-110991524,null);tib=new $APP.q("emmy.calculus.manifold","literal-scalar-field","emmy.calculus.manifold/literal-scalar-field",903642531,null);uib=new $APP.E(null,"letfn","letfn",-2121022354);
vib=new $APP.q("emmy.quaternion","quaternion?","emmy.quaternion/quaternion?",1358205183,null);wib=new $APP.E("cljs.analyzer","protocol-impl","cljs.analyzer/protocol-impl",-1523935409);kWa=new $APP.E(null,"simplify","simplify",-599213465);xib=new $APP.E(null,"in-\x3epartial","in-\x3epartial",1608898855);yib=new $APP.q("emmy.simplify.rules","trig:special","emmy.simplify.rules/trig:special",-38160197,null);zib=new $APP.q("emmy.env","sumr","emmy.env/sumr",-777336054,null);
Aib=new $APP.q("emmy.pattern.rule","\x3d\x3e","emmy.pattern.rule/\x3d\x3e",2133377795,null);Bib=new $APP.q("emmy.env","make-event","emmy.env/make-event",194949656,null);Cib=new $APP.q(null,"emmy.calculus.hodge-star","emmy.calculus.hodge-star",-847911522,null);Dib=new $APP.q("emmy.calculus.covariant","geodesic-equation","emmy.calculus.covariant/geodesic-equation",-1084034565,null);VM=new $APP.E("emmy.value","number","emmy.value/number",547788979);
Eib=new $APP.q(null,"M-\x3eEuler","M-\x3eEuler",-1777835457,null);Fib=new $APP.q(null,"parse-ratio","parse-ratio",1768923063,null);Gib=new $APP.q(null,"literal","literal",-989660164,null);Hib=new $APP.q("emmy.env","bigint","emmy.env/bigint",-1121715661,null);Iib=new $APP.q(null,"coordinate-system-\x3evector-basis","coordinate-system-\x3evector-basis",-1896061788,null);Jib=new $APP.q(null,"S3-tilted","S3-tilted",-1815929529,null);
Kib=new $APP.q("emmy.polynomial","drop-leading-term","emmy.polynomial/drop-leading-term",-1571502755,null);FP=new $APP.E(null,"basis","basis",1865819339);Lib=new $APP.q("emmy.polynomial.gcd","*clock*","emmy.polynomial.gcd/*clock*",-549484565,null);Mib=new $APP.q("emmy.matrix","*careful-conversion*","emmy.matrix/*careful-conversion*",1533133483,null);Nib=new $APP.q("emmy.sr.boost","four-tuple-\x3espace","emmy.sr.boost/four-tuple-\x3espace",285734132,null);
Oib=new $APP.q("emmy.simplify.rules","sincos-\x3eexp2","emmy.simplify.rules/sincos-\x3eexp2",2006247798,null);Pib=new $APP.q("emmy.simplify.rules","sincos-\x3eexp1","emmy.simplify.rules/sincos-\x3eexp1",-284517749,null);Qib=new $APP.q("emmy.mechanics.rigid","M-\x3eomega","emmy.mechanics.rigid/M-\x3eomega",964883892,null);Rib=new $APP.q("emmy.polynomial.interpolate","modified-neville-sum","emmy.polynomial.interpolate/modified-neville-sum",-843531547,null);
Sib=new $APP.q("emmy.env","S2p-tilted","emmy.env/S2p-tilted",-1327641631,null);Tib=new $APP.q(null,"Lagrange-interpolation-function","Lagrange-interpolation-function",-1682964898,null);Uib=new $APP.q(null,"indexed-\x3etyped","indexed-\x3etyped",-495593490,null);Vib=new $APP.q("emmy.simplify.rules","odd?","emmy.simplify.rules/odd?",1769749773,null);Wib=new $APP.q(null,"elliptic-integrals","elliptic-integrals",892634708,null);sOa=new $APP.E("clojure.error","line","clojure.error/line",-1816287471);
Xib=new $APP.q(null,"ICoordinateSystem","ICoordinateSystem",131120782,null);Yib=new $APP.q(null,"euler-gamma","euler-gamma",1811527439,null);JVa=new $APP.E(null,"async?","async?",1523057758);$APP.eT=new $APP.E(null,"size","size",1098693007);Zib=new $APP.q("emmy.env","S2-type","emmy.env/S2-type",-26303570,null);$ib=new $APP.q(null,"tag-active?","tag-active?",-1542800383,null);aN=new $APP.E("emmy.dual","reverse","emmy.dual/reverse",-1140830856);
QNa=new $APP.q(null,"cljs.spec.alpha","cljs.spec.alpha",505122844,null);ajb=new $APP.q("emmy.calculus.metric","raise2","emmy.calculus.metric/raise2",-1222669361,null);bjb=new $APP.q("emmy.calculus.metric","raise1","emmy.calculus.metric/raise1",-2060807002,null);cjb=new $APP.q("emmy.series","cos-series","emmy.series/cos-series",-1482945835,null);djb=new $APP.q("emmy.calculus.form-field","oneform-field-\x3ecomponents","emmy.calculus.form-field/oneform-field-\x3ecomponents",-1686561511,null);
ejb=new $APP.q("emmy.pattern.rule","iterated-bottom-up","emmy.pattern.rule/iterated-bottom-up",-729308934,null);fT=new $APP.q(null,"convergence-fn","convergence-fn",1483169014,null);fjb=new $APP.q("emmy.pattern.match","-\x3eFailure","emmy.pattern.match/-\x3eFailure",730202035,null);gjb=new $APP.E(null,"valid?","valid?",-212412379);hjb=new $APP.q("emmy.env","frame-name","emmy.env/frame-name",1776401029,null);
ijb=new $APP.q("emmy.env","oneform-field-\x3evector-field","emmy.env/oneform-field-\x3evector-field",-135296695,null);gT=new $APP.q(null,"acc","acc",-1815869457,null);jjb=new $APP.E(null,"coords-\x3eevent","coords-\x3eevent",-1002790988);hT=new $APP.E("emmy.complex","complex","emmy.complex/complex",-886041869);kjb=new $APP.q("emmy.numerical.unimin.bracket","ascending-by","emmy.numerical.unimin.bracket/ascending-by",-1264323100,null);ljb=new $APP.q(null,"ref","ref",-1364538802,null);
EYa=new $APP.q(null,"?ab","?ab",-380882607,null);mjb=new $APP.q(null,"column-matrix","column-matrix",977710190,null);njb=new $APP.q("emmy.simplify.rules","expand-multiangle","emmy.simplify.rules/expand-multiangle",555994743,null);ojb=new $APP.q(null,"-\x3eQuaternion","-\x3eQuaternion",2119310605,null);pjb=new $APP.q(null,"seq-arity","seq-arity",-1795913505,null);qjb=new $APP.q("emmy.calculus.manifold","typical-point","emmy.calculus.manifold/typical-point",-974567133,null);
rjb=new $APP.q(null,"SO3-type","SO3-type",-259399070,null);sjb=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer-scan","emmy.rational-function.interpolate/bulirsch-stoer-scan",-262640161,null);tjb=new $APP.q(null,"monoid","monoid",1982407932,null);$APP.iT=new $APP.q(null,"add","add",1875819266,null);ujb=new $APP.q("emmy.algebra.fold","constant","emmy.algebra.fold/constant",2003621841,null);jT=new $APP.q(null,"?c1","?c1",-268581185,null);uPa=new $APP.E(null,"externs","externs",221720677);
BUa=new $APP.E(null,"?meta","?meta",-793560773);vjb=new $APP.q(null,"Jacobian","Jacobian",-1342622555,null);wjb=new $APP.q(null,"leading-exponents","leading-exponents",-1198630583,null);xjb=new $APP.q("emmy.quaternion","spherical","emmy.quaternion/spherical",-1292829121,null);yjb=new $APP.q("emmy.env","lcm","emmy.env/lcm",1481971313,null);zjb=new $APP.q("emmy.matrix","column?","emmy.matrix/column?",-579607826,null);
Ajb=new $APP.q("emmy.quaternion","-\x3ecomplex-pair","emmy.quaternion/-\x3ecomplex-pair",-2112365939,null);kT=new $APP.q(null,"compare-fn","compare-fn",233034889,null);YQa=new $APP.E("cljs.analyzer","property","cljs.analyzer/property",1113330886);Bjb=new $APP.q(null,"sharpen","sharpen",1323878487,null);Cjb=new $APP.q("emmy.matrix","column*","emmy.matrix/column*",-2008125406,null);Djb=new $APP.q("emmy.env","coordinate-system-\x3emetric","emmy.env/coordinate-system-\x3emetric",-1184237821,null);
lT=new $APP.E("emmy.modint","modint","emmy.modint/modint",128115973);Ejb=new $APP.q(null,"T-rigid-body","T-rigid-body",1643981749,null);Fjb=new $APP.q("emmy.calculus.covariant","Lie-D","emmy.calculus.covariant/Lie-D",-455776798,null);Gjb=new $APP.q(null,"contractible?","contractible?",-624316069,null);Hjb=new $APP.q(null,"odd-integer?","odd-integer?",-1780439963,null);Ijb=new $APP.q("emmy.calculus.indexed","outer-product","emmy.calculus.indexed/outer-product",685783821,null);
Jjb=new $APP.q(null,"from-angle-normal-axis","from-angle-normal-axis",2091071901,null);Kjb=new $APP.q("emmy.function","seq-arity","emmy.function/seq-arity",-1006791443,null);mT=new $APP.q(null,"coordsys","coordsys",1968681528,null);Ljb=new $APP.q("Math","cosh","Math/cosh",-1954958918,null);WE=new $APP.E(null,"field","field",-1302436500);Mjb=new $APP.q(null,"quaternion-state-\x3eomega-space","quaternion-state-\x3eomega-space",97984525,null);
Njb=new $APP.q(null,"*warn-on-infer*","*warn-on-infer*",1890277318,null);Ojb=new $APP.q("emmy.env","factor","emmy.env/factor",650837576,null);Pjb=new $APP.q("emmy.mechanics.lagrange","L-pendulum","emmy.mechanics.lagrange/L-pendulum",2048699930,null);k5a=new $APP.q(null,"form-field-\x3eform-field-over-map","form-field-\x3eform-field-over-map",1700913758,null);Qjb=new $APP.q("emmy.env","covariant-differential","emmy.env/covariant-differential",1265332708,null);
fZa=new $APP.q(null,"acos-sin","acos-sin",1513257305,null);Rjb=new $APP.q("emmy.mechanics.rotation","Ry-matrix","emmy.mechanics.rotation/Ry-matrix",24184875,null);Sjb=new $APP.q("emmy.env","freeze","emmy.env/freeze",519536865,null);Tjb=new $APP.q("emmy.numerical.unimin.brent","brent-min","emmy.numerical.unimin.brent/brent-min",412015145,null);Ujb=new $APP.q(null,"let-coordinates","let-coordinates",1678927597,null);ZL=new $APP.E("emmy.polynomial","polynomial","emmy.polynomial/polynomial",-18826324);
yVa=new $APP.E(null,"hash_","hash_",-827203612);Vjb=new $APP.q("emmy.env","coordinate-system-\x3eoneform-basis","emmy.env/coordinate-system-\x3eoneform-basis",397293752,null);Wjb=new $APP.q(null,"inflate","inflate",577869908,null);PQa=new $APP.q(null,"__meta","__meta",-946752628,null);Xjb=new $APP.q("emmy.numerical.quadrature","available-methods","emmy.numerical.quadrature/available-methods",-667133907,null);Yjb=new $APP.q("emmy.polynomial","scale-l","emmy.polynomial/scale-l",-780812859,null);
Zjb=new $APP.E(null,"impls","impls",-1314014853);$jb=new $APP.q("emmy.env","-\x3etex-equation","emmy.env/-\x3etex-equation",-1172062182,null);akb=new $APP.q("emmy.series","fib-series","emmy.series/fib-series",1239574556,null);bkb=new $APP.q(null,"Phi","Phi",679137412,null);nT=new $APP.E("emmy.series","coseries","emmy.series/coseries",1116504415);ckb=new $APP.q(null,"modified-neville-sum","modified-neville-sum",-1873943260,null);
dkb=new $APP.q(null,"symplectic-two-form","symplectic-two-form",-501487260,null);ekb=new $APP.q("emmy.util","int","emmy.util/int",-925020463,null);fkb=new $APP.q("emmy.env","S2-spherical","emmy.env/S2-spherical",1341414941,null);gkb=new $APP.q("emmy.env","manifold?","emmy.env/manifold?",975413107,null);hkb=new $APP.E(null,"macros-ns","macros-ns",1626844933);D6a=new $APP.E("zip","children","zip/children",-940194589);
ikb=new $APP.q("emmy.calculus.manifold","R3-spherical","emmy.calculus.manifold/R3-spherical",-51209951,null);jkb=new $APP.q(null,"emmy.util","emmy.util",777632628,null);kkb=new $APP.q(null,"matrix-by-cols","matrix-by-cols",-1933276979,null);lkb=new $APP.E(null,"missing","missing",362507769);mkb=new $APP.q("emmy.env","coordinate-system-at","emmy.env/coordinate-system-at",-1903743214,null);
nkb=new $APP.q("emmy.calculus.map","pullback-vector-field","emmy.calculus.map/pullback-vector-field",-1827175707,null);okb=new $APP.q("emmy.util","parse-double","emmy.util/parse-double",1389014485,null);pkb=new $APP.q(null,"twopi","twopi",1500974612,null);ZYa=new $APP.q(null,"aggressive-atan-1","aggressive-atan-1",-730258103,null);$Ya=new $APP.q(null,"aggressive-atan-2","aggressive-atan-2",-628426094,null);oT=new $APP.q(null,"?im","?im",120320525,null);
k7a=new $APP.E(null,"adaptive?","adaptive?",-259268570);qkb=new $APP.q("emmy.env","up-\x3ecolumn-matrix","emmy.env/up-\x3ecolumn-matrix",-1349682481,null);R7a=new $APP.E(null,"gensym-fn","gensym-fn",-883485832);rkb=new $APP.q(null,"emmy.numerical.unimin.golden","emmy.numerical.unimin.golden",1703295274,null);skb=new $APP.q("emmy.structure","dual-zero","emmy.structure/dual-zero",2070935638,null);tkb=new $APP.E(null,"module-type","module-type",1392760304);
ukb=new $APP.q("emmy.calculus.derivative","*mode*","emmy.calculus.derivative/*mode*",1903158697,null);vkb=new $APP.q("emmy.simplify.rules","non-negative-factors!","emmy.simplify.rules/non-negative-factors!",1177918175,null);TXa=new $APP.q(null,"r__45896__auto__","r__45896__auto__",1544830075,null);wkb=new $APP.q("emmy.env","negative?","emmy.env/negative?",1404352869,null);xkb=new $APP.q("emmy.env","Hamiltonian-\x3estate-derivative","emmy.env/Hamiltonian-\x3estate-derivative",-814043599,null);
ykb=new $APP.q("emmy.dual","bundle-element","emmy.dual/bundle-element",-1169646684,null);zkb=new $APP.E(null,"central-d2","central-d2",1063418821);pT=new $APP.q("cljs.core","IWithMeta","cljs.core/IWithMeta",-1981666051,null);Akb=new $APP.q(null,"make-constant-vector-field","make-constant-vector-field",-71514147,null);Bkb=new $APP.q("emmy.expression","pe","emmy.expression/pe",831779257,null);Ckb=new $APP.q(null,"semipolar","semipolar",-145327529,null);
Dkb=new $APP.E(null,"undeclared-ns-form","undeclared-ns-form",-248024137);Ekb=new $APP.q("emmy.env","general-boost","emmy.env/general-boost",-1813259114,null);Fkb=new $APP.q(null,"orthonormalize","orthonormalize",-931386057,null);Gkb=new $APP.q("emmy.mechanics.lagrange","make-path","emmy.mechanics.lagrange/make-path",-2065309011,null);Hkb=new $APP.q("emmy.env","SR-coordinates?","emmy.env/SR-coordinates?",946028419,null);Ikb=new $APP.q(null,"converged?","converged?",-875375793,null);
x$a=new $APP.q(null,"-\x3erotation-matrix","-\x3erotation-matrix",1030542807,null);Jkb=new $APP.q("emmy.numerical.derivative","backward-difference","emmy.numerical.derivative/backward-difference",2113152218,null);Kkb=new $APP.q("emmy.generic","real-part","emmy.generic/real-part",1558748796,null);Lkb=new $APP.q(null,"quotient?","quotient?",895716076,null);XOa=new $APP.q(null,"Function","Function",-749895448,null);Mkb=new $APP.q("emmy.modint","modulus","emmy.modint/modulus",-2094361453,null);
Nkb=new $APP.q("emmy.expression.analyze","auxiliary-variable-fetcher","emmy.expression.analyze/auxiliary-variable-fetcher",-1848744273,null);Okb=new $APP.q("emmy.simplify.rules","*sqrt-factor-simplify?*","emmy.simplify.rules/*sqrt-factor-simplify?*",2073057927,null);Pkb=new $APP.q("emmy.mechanics.hamilton","H-central","emmy.mechanics.hamilton/H-central",275169501,null);Qkb=new $APP.q("emmy.util","parse-bigint","emmy.util/parse-bigint",1326751331,null);
qT=new $APP.q(null,"boost-direction","boost-direction",-335370591,null);Rkb=new $APP.q("cljs.core","uuid?","cljs.core/uuid?",-15131116,null);Skb=new $APP.q("emmy.util.permute","subpermute","emmy.util.permute/subpermute",246773707,null);rT=new $APP.q(null,"frame","frame",-70551061,null);Tkb=new $APP.q("emmy.quaternion","add","emmy.quaternion/add",1070196234,null);Ukb=new $APP.q("emmy.expression","literal?","emmy.expression/literal?",750576800,null);
Vkb=new $APP.q("emmy.special.elliptic","jacobi-elliptic-functions","emmy.special.elliptic/jacobi-elliptic-functions",-81540406,null);Wkb=new $APP.q(null,"index-types","index-types",-1276115991,null);Xkb=new $APP.q(null,"phidot","phidot",-1040914891,null);b4a=new $APP.q(null,"coordinatized","coordinatized",1447215710,null);Ykb=new $APP.q("emmy.generic","negate","emmy.generic/negate",-1058220643,null);Zkb=new $APP.q("emmy.value","principal-value","emmy.value/principal-value",-2039467858,null);
$kb=new $APP.q("emmy.env","inner-product","emmy.env/inner-product",-912328867,null);sT=new $APP.E("emmy.series","series","emmy.series/series",1817174773);alb=new $APP.q("emmy.function","function?","emmy.function/function?",673009327,null);blb=new $APP.q(null,"*monomial-order*","*monomial-order*",-1705265536,null);clb=new $APP.q(null,"that","that",828965210,null);dlb=new $APP.E(null,"alternate","alternate",-931038644);elb=new $APP.q(null,"Symbol","Symbol",716452869,null);
PN=new $APP.q(null,"Real","Real",374292741,null);mWa=new $APP.E(null,"simplify-expression","simplify-expression",-473287731);flb=new $APP.E(null,"seconds","seconds",-445266194);glb=new $APP.q(null,"make-Lagrangian","make-Lagrangian",1190262545,null);hlb=new $APP.q(null,"rotate-z-matrix","rotate-z-matrix",1997537548,null);tT=new $APP.q(null,"plus","plus",1852072188,null);ilb=new $APP.q("emmy.polynomial","leading-term","emmy.polynomial/leading-term",1083872270,null);
jlb=new $APP.q(null,"complex?","complex?",-1119689323,null);klb=new $APP.q(null,"basis-\x3edimension","basis-\x3edimension",1009774354,null);llb=new $APP.q("cljs.core","sorted-map","cljs.core/sorted-map",-1196662760,null);mlb=new $APP.q("emmy.util","compute-sqrt","emmy.util/compute-sqrt",1940358593,null);nlb=new $APP.q(null,"-\x3estructure","-\x3estructure",1110609707,null);olb=new $APP.q(null,"parabolic-pieces","parabolic-pieces",1967742243,null);
plb=new $APP.q("emmy.generic","exact?","emmy.generic/exact?",-623886372,null);qlb=new $APP.q("emmy.quaternion","J-matrix","emmy.quaternion/J-matrix",-655831157,null);rlb=new $APP.q("emmy.simplify.rules","unary-elimination","emmy.simplify.rules/unary-elimination",1775341255,null);slb=new $APP.E(null,"munged-namespace","munged-namespace",-101986199);tlb=new $APP.E(null,"trapezoid","trapezoid",114840675);ulb=new $APP.q(null,"H-central","H-central",1534229930,null);
vlb=new $APP.q(null,"T-body","T-body",1409086972,null);wlb=new $APP.q("emmy.calculus.manifold","coordinate-prototype","emmy.calculus.manifold/coordinate-prototype",-2134738891,null);xlb=new $APP.q("emmy.generic","modulo","emmy.generic/modulo",125436899,null);ylb=new $APP.q("emmy.value","seqtype","emmy.value/seqtype",-1345949868,null);T6a=new $APP.E(null,"juxtapose-multiply","juxtapose-multiply",-1262547042);k3a=new $APP.E(null,"patch","patch",380775109);
zlb=new $APP.q("emmy.calculus.coordinate","let-coordinates","emmy.calculus.coordinate/let-coordinates",1490647267,null);yPa=new $APP.E(null,"js-shadowed-by-local","js-shadowed-by-local",198048291);Alb=new $APP.E(null,"romberg-open","romberg-open",-200805328);Blb=new $APP.q("emmy.function","memoize","emmy.function/memoize",-2056935645,null);Clb=new $APP.q(null,"fail-r","fail-r",-488260749,null);Dlb=new $APP.q(null,"literal-Hamiltonian-state","literal-Hamiltonian-state",94824489,null);
Elb=new $APP.q(null,"rising-factorial","rising-factorial",-1445656103,null);Flb=new $APP.q(null,"trig:sum-\x3eproduct","trig:sum-\x3eproduct",1941161330,null);Glb=new $APP.q(null,"sym-\x3evar","sym-\x3evar",-1699261063,null);uT=new $APP.q(null,"sech","sech",-1403979131,null);Hlb=new $APP.q(null,"*commute-partials?*","*commute-partials?*",549147281,null);Ilb=new $APP.q("emmy.env","mapr","emmy.env/mapr",-1584594995,null);
Jlb=new $APP.q("emmy.generic","almost-integral?","emmy.generic/almost-integral?",-566969131,null);mPa=new $APP.q(null,"checked-aset","checked-aset",1556136760,null);Klb=new $APP.q(null,"polynomial","polynomial",807766365,null);Llb=new $APP.q("emmy.pattern.syntax","reverse-segment-name","emmy.pattern.syntax/reverse-segment-name",-2008361478,null);Mlb=new $APP.q("emmy.quaternion","semipolar","emmy.quaternion/semipolar",123019087,null);
Nlb=new $APP.q("emmy.structure","same-orientation?","emmy.structure/same-orientation?",-590443222,null);Olb=new $APP.q("emmy.expression.analyze","monotonic-symbol-generator","emmy.expression.analyze/monotonic-symbol-generator",-926866228,null);Plb=new $APP.q("emmy.special.factorial","bell","emmy.special.factorial/bell",-160776725,null);Qlb=new $APP.q(null,"coordinate-basis-vector-field","coordinate-basis-vector-field",928502764,null);
Rlb=new $APP.q(null,"standard-map-inverse","standard-map-inverse",1527044725,null);Slb=new $APP.q(null,"S2-tilted","S2-tilted",875853010,null);Tlb=new $APP.q("emmy.generic","trace","emmy.generic/trace",1962665587,null);Ulb=new $APP.q("emmy.matrix","with-substituted-row","emmy.matrix/with-substituted-row",-63338969,null);Vlb=new $APP.q(null,"transpose-outer","transpose-outer",248243056,null);Wlb=new $APP.q(null,"*expt-half-\x3esqrt?*","*expt-half-\x3esqrt?*",-1454481314,null);
Xlb=new $APP.q("emmy.matrix","by-cols","emmy.matrix/by-cols",-1087232333,null);Ylb=new $APP.q("emmy.env","orthonormalize","emmy.env/orthonormalize",-1914772032,null);lQa=new $APP.E(null,"js-globals","js-globals",1670394727);Zlb=new $APP.q("emmy.mechanics.hamilton","*validate-Legendre-transform?*","emmy.mechanics.hamilton/*validate-Legendre-transform?*",1367316148,null);$lb=new $APP.q("emmy.pattern.consequence","unwrap","emmy.pattern.consequence/unwrap",-1920991018,null);
amb=new $APP.q("emmy.env","R1-rect","emmy.env/R1-rect",-1224779121,null);bmb=new $APP.q(null,"-\x3eSeries","-\x3eSeries",2145681101,null);cmb=new $APP.q(null,"literal-manifold-map","literal-manifold-map",915017254,null);KP=new $APP.q(null,"nabla","nabla",1447510358,null);dmb=new $APP.q(null,"jacobi-elliptic-functions","jacobi-elliptic-functions",-617861797,null);emb=new $APP.q("emmy.calculus.frame","ancestor-frame","emmy.calculus.frame/ancestor-frame",-755747916,null);
fmb=new $APP.q("emmy.env","coordinate-system-\x3emetric-components","emmy.env/coordinate-system-\x3emetric-components",429161738,null);gmb=new $APP.q("matrix","num-rows","matrix/num-rows",-1162348928,null);hmb=new $APP.q("emmy.calculus.manifold","S2-tilted","emmy.calculus.manifold/S2-tilted",-84281672,null);imb=new $APP.q(null,"abstract-number?","abstract-number?",740601180,null);jmb=new $APP.E(null,"weeks","weeks",1844596125);
kmb=new $APP.q("emmy.env","euler-gamma","emmy.env/euler-gamma",895975420,null);Y6a=new $APP.E(null,"parenthesize","parenthesize",-1945667578);lmb=new $APP.q("emmy.structure","compatible-shape","emmy.structure/compatible-shape",643765646,null);mmb=new $APP.q("emmy.env","acceleration","emmy.env/acceleration",1422673655,null);nmb=new $APP.q("emmy.env","let-coordinates","emmy.env/let-coordinates",670150288,null);
omb=new $APP.q("emmy.calculus.manifold","S1-gnomonic","emmy.calculus.manifold/S1-gnomonic",897465245,null);pmb=new $APP.q(null,"nth-row","nth-row",1256930440,null);qmb=new $APP.q("emmy.calculus.form-field","alt-wedge","emmy.calculus.form-field/alt-wedge",2085730765,null);qQa=new $APP.E(null,"statement","statement",-32780863);rmb=new $APP.q(null,"emmy.mechanics.hamilton","emmy.mechanics.hamilton",-1632324516,null);r5a=new $APP.q(null,"interior-product","interior-product",1619499933,null);
sPa=new $APP.E(null,"global","global",93595047);smb=new $APP.q(null,"opposite","opposite",-720147765,null);tmb=new $APP.q(null,"equiv","equiv",992570171,null);umb=new $APP.q(null,"claim","claim",665172358,null);vmb=new $APP.q(null,"fold-chain","fold-chain",-753757507,null);wmb=new $APP.q(null,"Hprime","Hprime",-2140990051,null);QOa=new $APP.E(null,"ns-sym","ns-sym",-1696101605);xmb=new $APP.q("emmy.value","add-object-symbols!","emmy.value/add-object-symbols!",1431521820,null);
ymb=new $APP.E(null,"done","done",-889844188);zmb=new $APP.q("emmy.env","S1-gnomonic","emmy.env/S1-gnomonic",243490852,null);vT=new $APP.q(null,"derivs","derivs",1777840707,null);Amb=new $APP.q(null,"central-difference","central-difference",1344231377,null);Bmb=new $APP.q(null,"literal-down","literal-down",-1340662285,null);Cmb=new $APP.E(null,"cljc","cljc",-1728400583);Dmb=new $APP.q("emmy.mechanics.lagrange","L3-central","emmy.mechanics.lagrange/L3-central",-1028329062,null);
oH=new $APP.q(null,"-pi","-pi",-613600448,null);Emb=new $APP.q(null,"ulist","ulist",-427264443,null);Fmb=new $APP.q("emmy.mechanics.rotation","M-\x3eEuler","emmy.mechanics.rotation/M-\x3eEuler",-1375269112,null);Gmb=new $APP.q(null,"triginv","triginv",-535102478,null);Hmb=new $APP.q("emmy.util.aggregate","merge-fn","emmy.util.aggregate/merge-fn",-1131039703,null);Imb=new $APP.q(null,"classical-gcd","classical-gcd",-1805676176,null);Jmb=new $APP.E(null,"milne","milne",110782965);
Kmb=new $APP.q("emmy.env","state-\x3et","emmy.env/state-\x3et",-573214061,null);wT=new $APP.E("emmy.matrix","square-matrix","emmy.matrix/square-matrix",-857272006);Lmb=new $APP.q("emmy.pattern.match","foreach","emmy.pattern.match/foreach",197469065,null);Mmb=new $APP.q(null,"half-angle","half-angle",584327215,null);Nmb=new $APP.q("emmy.expression.cse","extract-common-subexpressions","emmy.expression.cse/extract-common-subexpressions",-18214444,null);
Omb=new $APP.q(null,"-\x3et_emmy$util$permute49436","-\x3et_emmy$util$permute49436",1626292862,null);Pmb=new $APP.q(null,"unflatten","unflatten",527019,null);Qmb=new $APP.q(null,"timeout-ex","timeout-ex",1608520355,null);xT=new $APP.q("emmy.calculus.form-field","coordinate-system-\x3eoneform-basis","emmy.calculus.form-field/coordinate-system-\x3eoneform-basis",659366848,null);Rmb=new $APP.q("cljs.core","simple-ident?","cljs.core/simple-ident?",1674885558,null);
Smb=new $APP.q(null,"differential-of-function","differential-of-function",997752521,null);Tmb=new $APP.q("emmy.numsymb","sqrt","emmy.numsymb/sqrt",1370402951,null);Umb=new $APP.q(null,"logexp-\x3especfun","logexp-\x3especfun",2100487617,null);Vmb=new $APP.q("emmy.matrix","seq-\x3e","emmy.matrix/seq-\x3e",-1903344984,null);Wmb=new $APP.q("emmy.polynomial","analyzer","emmy.polynomial/analyzer",-1945120724,null);
Xmb=new $APP.q("emmy.structure","vector-\x3eup","emmy.structure/vector-\x3eup",782926436,null);Ymb=new $APP.q("emmy.env","state-advancer","emmy.env/state-advancer",163396960,null);Zmb=new $APP.q(null,"???","???",1210272185,null);$mb=new $APP.q("emmy.value","compare","emmy.value/compare",-1087601004,null);anb=new $APP.q("emmy.util.def","var-meta","emmy.util.def/var-meta",438546164,null);
bnb=new $APP.q("emmy.mechanics.hamilton","compositional-canonical?","emmy.mechanics.hamilton/compositional-canonical?",-926323202,null);cnb=new $APP.q("emmy.simplify.rules","idempotent","emmy.simplify.rules/idempotent",844979137,null);dnb=new $APP.q(null,"components-\x3evector-field","components-\x3evector-field",-1160967663,null);enb=new $APP.q("emmy.mechanics.hamilton","Hamilton-equations","emmy.mechanics.hamilton/Hamilton-equations",-303713702,null);
fnb=new $APP.q(null,"associative","associative",1021237616,null);gnb=new $APP.E(null,"undeclared-protocol-symbol","undeclared-protocol-symbol",462882867);hnb=new $APP.q("emmy.pattern.rule","return","emmy.pattern.rule/return",-1581836238,null);inb=new $APP.q("cljs.core","integer?","cljs.core/integer?",1710697810,null);jnb=new $APP.q("emmy.env","R2-rect","emmy.env/R2-rect",-1568258147,null);knb=new $APP.q("emmy.env","R4-cyl","emmy.env/R4-cyl",1344160736,null);
lnb=new $APP.q(null,"arg-tolerance","arg-tolerance",-973251989,null);yT=new $APP.q(null,"??f","??f",-94026515,null);YJ=new $APP.q(null,"??d","??d",-581862453,null);mnb=new $APP.q(null,"psidot","psidot",-265477541,null);XJ=new $APP.q(null,"??c","??c",1219586074,null);nnb=new $APP.q(null,"interrupted","interrupted",-1654482530,null);onb=new $APP.q(null,"vector-basis-\x3edual","vector-basis-\x3edual",-54882730,null);WJ=new $APP.q(null,"??b","??b",254504576,null);
VJ=new $APP.q(null,"??a","??a",-294068510,null);RJ=new $APP.q(null,"??p","??p",1112654910,null);pnb=new $APP.q(null,"solve","solve",636252852,null);qnb=new $APP.q(null,"complex-rules","complex-rules",1594824372,null);zT=new $APP.q(null,"??j","??j",1098328567,null);rnb=new $APP.q(null,"S2-gnomonic","S2-gnomonic",876138980,null);AT=new $APP.q(null,"??i","??i",-474049037,null);BT=new $APP.q(null,"??x","??x",-1924511736,null);snb=new $APP.q("emmy.env","tex$","emmy.env/tex$",2073166013,null);
CT=new $APP.q(null,"??w","??w",1245275022,null);QJ=new $APP.q(null,"??v","??v",2028946795,null);PJ=new $APP.q(null,"??u","??u",788654559,null);tnb=new $APP.q(null,"specfun-\x3elogexp","specfun-\x3elogexp",-540007439,null);SJ=new $APP.q(null,"??q","??q",253374785,null);unb=new $APP.q("emmy.env","spacetime-rect","emmy.env/spacetime-rect",392527447,null);vnb=new $APP.q(null,"qp-\x3eH-state-path","qp-\x3eH-state-path",1616022316,null);
wnb=new $APP.q("emmy.calculus.manifold","R4-rect","emmy.calculus.manifold/R4-rect",-1765223590,null);DT=new $APP.q(null,"??y","??y",-1087769442,null);xnb=new $APP.q("emmy.polynomial","contractible?","emmy.polynomial/contractible?",1782998533,null);ynb=new $APP.q(null,"drop1","drop1",648703478,null);znb=new $APP.q(null,"drop2","drop2",1353441554,null);Anb=new $APP.E(null,"unsupported-js-module-type","unsupported-js-module-type",1806206180);
Bnb=new $APP.q(null,"Christoffel-\x3ebasis","Christoffel-\x3ebasis",817417876,null);Cnb=new $APP.q("emmy.expression.analyze","initializer","emmy.expression.analyze/initializer",685932787,null);Dnb=new $APP.q(null,"exp-contract","exp-contract",1533009748,null);Enb=new $APP.q("emmy.env","spacetime","emmy.env/spacetime",528609609,null);pVa=new $APP.E(null,"report","report",1394055010);ET=new $APP.E("emmy.value","floating-point","emmy.value/floating-point",919866091);
Fnb=new $APP.q(null,"tanhc","tanhc",991235322,null);Gnb=new $APP.q("emmy.numerical.quadrature","get-integrator","emmy.numerical.quadrature/get-integrator",158462799,null);Hnb=new $APP.q("emmy.simplify.rules","sincos-\x3etrig","emmy.simplify.rules/sincos-\x3etrig",1098989247,null);Inb=new $APP.q(null,"torsion-vector","torsion-vector",-479497882,null);Jnb=new $APP.q("emmy.polynomial","abs","emmy.polynomial/abs",43142284,null);
Knb=new $APP.q("emmy.polynomial","scale","emmy.polynomial/scale",-457727360,null);Lnb=new $APP.q(null,"illegal","illegal",1626781480,null);Mnb=new $APP.q(null,"coordinate-tuple","coordinate-tuple",-1161946955,null);Nnb=new $APP.q(null,"asec","asec",-81933685,null);Onb=new $APP.q(null,"literal-Cartan","literal-Cartan",757080022,null);ZQa=new $APP.E("cljs.analyzer","symbol","cljs.analyzer/symbol",933248902);Pnb=new $APP.q(null,"Literal","Literal",998711045,null);
Qnb=new $APP.q("emmy.value","argument-kind","emmy.value/argument-kind",940335956,null);JRa=new $APP.q(null,"cljs.repl","cljs.repl",1767065658,null);Rnb=new $APP.E(null,"tangent","tangent",720915821);Snb=new $APP.E(null,"mins","mins",467369676);Tnb=new $APP.q(null,"emmy.tape","emmy.tape",1939677624,null);Unb=new $APP.q("emmy.series","-\x3ePowerSeries","emmy.series/-\x3ePowerSeries",1728975685,null);FT=new $APP.q(null,"make-polar","make-polar",2147326621,null);
Vnb=new $APP.q("emmy.env","make-Christoffel","emmy.env/make-Christoffel",445740966,null);gP=new $APP.E("emmy.calculus.form-field","oneform-field","emmy.calculus.form-field/oneform-field",790058519);GT=new $APP.q(null,"minus","minus",-43029965,null);Wnb=new $APP.q("emmy.util","timeout-ex","emmy.util/timeout-ex",-1367120633,null);Xnb=new $APP.q("cljs.core","seqable?","cljs.core/seqable?",-745394886,null);Ynb=new $APP.q(null,"log10","log10",891257803,null);
Znb=new $APP.q(null,"literal-function","literal-function",-1466238050,null);$nb=new $APP.q(null,"frame?","frame?",-229419232,null);aob=new $APP.q(null,"state-\x3et","state-\x3et",460567876,null);bob=new $APP.q(null,"state-\x3eq","state-\x3eq",68587681,null);cob=new $APP.q(null,"state-\x3ep","state-\x3ep",-1751204370,null);dob=new $APP.q("emmy.quaternion","cosh","emmy.quaternion/cosh",-1157111862,null);a6a=new $APP.q(null,"raise","raise",1824672588,null);
eob=new $APP.q("emmy.polynomial.factor","-\x3et_emmy$polynomial$factor49028","emmy.polynomial.factor/-\x3et_emmy$polynomial$factor49028",-1047650525,null);fob=new $APP.q(null,"L3-central","L3-central",-1545087426,null);gob=new $APP.q("emmy.mechanics.hamilton","symplectic-unit","emmy.mechanics.hamilton/symplectic-unit",-95628681,null);hob=new $APP.q("emmy.env","pullback-form","emmy.env/pullback-form",34856191,null);
iob=new $APP.q("emmy.mechanics.hamilton","H-harmonic","emmy.mechanics.hamilton/H-harmonic",-8379886,null);lK=new $APP.q(null,"asin","asin",-904130570,null);job=new $APP.q("emmy.structure","typical-object","emmy.structure/typical-object",-1719684405,null);JD=new $APP.E(null,"init","init",-1875481434);kob=new $APP.q(null,"segment?","segment?",1234224398,null);HT=new $APP.q(null,"continue","continue",1433184974,null);lob=new $APP.q(null,"-\x3eModInt","-\x3eModInt",-1177394650,null);
mob=new $APP.q(null,"cos-half-angle-formula","cos-half-angle-formula",-1744663300,null);nob=new $APP.q("emmy.env","curl","emmy.env/curl",1104521556,null);oob=new $APP.q("emmy.pattern.rule","guard","emmy.pattern.rule/guard",2098710200,null);pob=new $APP.q(null,"H-state?","H-state?",-1647143223,null);qob=new $APP.q(null,"state-\x3en-dof","state-\x3en-dof",766036380,null);rob=new $APP.q(null,"principal-value","principal-value",-344542783,null);
IT=new $APP.q(null,"Christoffel?","Christoffel?",977826934,null);cSa=new $APP.q("cljs.core","IVector","cljs.core/IVector",1711112835,null);rH=new $APP.q(null,"-two-pi","-two-pi",-50550974,null);sob=new $APP.q("emmy.calculus.manifold","R2","emmy.calculus.manifold/R2",1557152115,null);tob=new $APP.q("emmy.calculus.manifold","R3","emmy.calculus.manifold/R3",619595120,null);uob=new $APP.q("emmy.calculus.manifold","R4","emmy.calculus.manifold/R4",878101290,null);
vob=new $APP.q("emmy.calculus.manifold","Euler-angles","emmy.calculus.manifold/Euler-angles",1727658450,null);wob=new $APP.q("emmy.polynomial.richardson","richardson-sum","emmy.polynomial.richardson/richardson-sum",970645537,null);xob=new $APP.q("emmy.calculus.manifold","R1","emmy.calculus.manifold/R1",-2040681754,null);yob=new $APP.q("emmy.pattern.rule","as-attempt","emmy.pattern.rule/as-attempt",72612861,null);D2a=new $APP.E("emmy.calculus.frame","owner","emmy.calculus.frame/owner",-1563689470);
zob=new $APP.q("emmy.env","Jacobian","emmy.env/Jacobian",1834978546,null);Aob=new $APP.q("emmy.mechanics.rigid","L-space","emmy.mechanics.rigid/L-space",2064820792,null);Bob=new $APP.q(null,"p-sequence","p-sequence",1101946304,null);Cob=new $APP.q(null,"covariant-differential","covariant-differential",-1899447919,null);$APP.JT=new $APP.q(null,"present","present",415886062,null);Dob=new $APP.q(null,"three-vector-components-\x3eantisymmetric","three-vector-components-\x3eantisymmetric",690977266,null);
Eob=new $APP.q("emmy.mechanics.lagrange","momentum-tuple","emmy.mechanics.lagrange/momentum-tuple",564528094,null);Fob=new $APP.q("emmy.calculus.manifold","patch-names","emmy.calculus.manifold/patch-names",2101754329,null);Gob=new $APP.q(null,"consequence","consequence",1638527189,null);KT=new $APP.q(null,"maxiter","maxiter",-226692227,null);Hob=new $APP.q("emmy.env","S2-gnomonic","emmy.env/S2-gnomonic",1989839257,null);Iob=new $APP.q(null,"operator","operator",-220343811,null);
Job=new $APP.E(null,"protocol-deprecated","protocol-deprecated",103233497);Kob=new $APP.q("emmy.env","infinite?","emmy.env/infinite?",-1352545046,null);Lob=new $APP.q("emmy.quaternion","three-vector","emmy.quaternion/three-vector",829450905,null);Mob=new $APP.q("emmy.calculus.manifold","Rn","emmy.calculus.manifold/Rn",-1207694986,null);Nob=new $APP.q(null,"colat","colat",-1900781322,null);Oob=new $APP.q(null,"L-pendulum","L-pendulum",501843390,null);
Pob=new $APP.q(null,"L-rectangular","L-rectangular",32091286,null);Qob=new $APP.q("emmy.polynomial.interpolate","modified-neville","emmy.polynomial.interpolate/modified-neville",-541175015,null);Rob=new $APP.q(null,"raise2","raise2",-1138595067,null);Sob=new $APP.q(null,"raise1","raise1",-2109852308,null);Tob=new $APP.q("emmy.env","Hodge-star","emmy.env/Hodge-star",1320905112,null);Uob=new $APP.q("emmy.calculus.manifold","S3","emmy.calculus.manifold/S3",892737402,null);
Vob=new $APP.q("emmy.calculus.manifold","S1","emmy.calculus.manifold/S1",94678692,null);Wob=new $APP.q("emmy.calculus.manifold","S2","emmy.calculus.manifold/S2",-1354477707,null);Xob=new $APP.q("emmy.polynomial.gcd","*poly-gcd-time-limit*","emmy.polynomial.gcd/*poly-gcd-time-limit*",-1624888697,null);Yob=new $APP.q("emmy.numerical.ode","evolve","emmy.numerical.ode/evolve",-220785197,null);Zob=new $APP.q(null,"richardson-column","richardson-column",1067781891,null);
mYa=new $APP.E("emmy.pattern.rule","attempt?","emmy.pattern.rule/attempt?",1709760667);$ob=new $APP.q("emmy.quaternion","ONE","emmy.quaternion/ONE",-302160831,null);apb=new $APP.q(null,"make-Christoffel","make-Christoffel",1480535635,null);LT=new $APP.q(null,"*rf-simplify*","*rf-simplify*",-1292516740,null);bpb=new $APP.q("emmy.polynomial.richardson","richardson-sequence","emmy.polynomial.richardson/richardson-sequence",254452593,null);cpb=new $APP.q("emmy.env","log2","emmy.env/log2",1380937864,null);
dpb=new $APP.q("emmy.env","coordinate-tuple","emmy.env/coordinate-tuple",-128064702,null);$Ra=new $APP.q("cljs.core","IMap","cljs.core/IMap",1407777598,null);MT=new $APP.q(null,"mu:N-\x3eM","mu:N-\x3eM",-1564575384,null);epb=new $APP.q(null,"*divide-numbers-through-simplify?*","*divide-numbers-through-simplify?*",276306313,null);fpb=new $APP.q("emmy.series","sinh-series","emmy.series/sinh-series",1317522346,null);gpb=new $APP.E(null,"preprocess","preprocess",1208285012);
hpb=new $APP.q("emmy.pattern.rule","iterated","emmy.pattern.rule/iterated",-253441051,null);ipb=new $APP.q("emmy.calculus.manifold","Sn","emmy.calculus.manifold/Sn",-1449239589,null);NT=new $APP.q("cljs.core","IReversible","cljs.core/IReversible",-1422278012,null);jpb=new $APP.q(null,"bell","bell",2060210813,null);kpb=new $APP.q("emmy.series","sin-series","emmy.series/sin-series",-425555923,null);lpb=new $APP.q(null,"s-map","s-map",732813964,null);
mpb=new $APP.q("emmy.env","r-\x3es","emmy.env/r-\x3es",-753530099,null);npb=new $APP.q("emmy.env","r-\x3ep","emmy.env/r-\x3ep",-1093607092,null);opb=new $APP.q(null,"ONE","ONE",-1107326119,null);ppb=new $APP.q(null,"permute","permute",-199300448,null);DRa=new $APP.E(null,"invoke","invoke",1145927159);qpb=new $APP.q("emmy.env","asinh","emmy.env/asinh",-742095466,null);d3a=new $APP.E(null,"coordinate-systems","coordinate-systems",-642340545);
OT=new $APP.q(null,"orthonormalize?","orthonormalize?",1628658775,null);PT=new $APP.q(null,"relative-threshold","relative-threshold",-225607443,null);rpb=new $APP.q(null,"old-tag","old-tag",-1527675795,null);spb=new $APP.q(null,"metric:invert","metric:invert",-709738857,null);tpb=new $APP.q(null,"...","...",-1926939749,null);upb=new $APP.q(null,"Euler-Lagrange-operator","Euler-Lagrange-operator",-2048146756,null);
vpb=new $APP.q("emmy.special.elliptic","elliptic-pi","emmy.special.elliptic/elliptic-pi",-615608420,null);wpb=new $APP.q(null,"proper-time-interval","proper-time-interval",-304271527,null);xpb=new $APP.q(null,"up-\x3ecolumn-matrix","up-\x3ecolumn-matrix",1793835676,null);J6a=new $APP.E(null,"pnodes","pnodes",1739080565);ypb=new $APP.q("emmy.calculus.manifold","constant-manifold-function","emmy.calculus.manifold/constant-manifold-function",1049674971,null);
zpb=new $APP.q("emmy.calculus.manifold","S2-gnomonic","emmy.calculus.manifold/S2-gnomonic",268263198,null);Apb=new $APP.q(null,"keyvals","keyvals",-2067234787,null);Bpb=new $APP.q("emmy.generic","sech","emmy.generic/sech",-1751135034,null);QT=new $APP.q(null,"orientation-matrix","orientation-matrix",-591482625,null);Cpb=new $APP.q(null,"with-literal-functions","with-literal-functions",-1921576455,null);Dpb=new $APP.q(null,"multivariate?","multivariate?",-1200676278,null);
Epb=new $APP.q("cljs.core","ident?","cljs.core/ident?",1567441535,null);Fpb=new $APP.q(null,"-\x3eLiteral","-\x3eLiteral",-67051922,null);Gpb=new $APP.q("emmy.sr.boost","four-tuple-\x3ect","emmy.sr.boost/four-tuple-\x3ect",251091581,null);Hpb=new $APP.E(null,"suggested-symbol","suggested-symbol",-1329631875);Ipb=new $APP.q("emmy.mechanics.hamilton","linear-function-\x3emultiplier","emmy.mechanics.hamilton/linear-function-\x3emultiplier",-1110494963,null);
Jpb=new $APP.q(null,"qw-state-\x3eL-body","qw-state-\x3eL-body",31958610,null);Kpb=new $APP.q(null,"richardson-fold","richardson-fold",-768238887,null);Lpb=new $APP.q(null,"one-like","one-like",-1767302049,null);Mpb=new $APP.q(null,"L-space","L-space",-174468754,null);CE=new $APP.E(null,"macros","macros",811339431);X3a=new $APP.q(null,"vf:zero","vf:zero",-742903868,null);Npb=new $APP.q("emmy.env","F-\x3eC","emmy.env/F-\x3eC",39292458,null);Opb=new $APP.q(null,"dual-zero","dual-zero",973357295,null);
Ppb=new $APP.q("emmy.env","Hamilton-equations","emmy.env/Hamilton-equations",1685848060,null);Qpb=new $APP.q("emmy.expression.analyze","default-simplifier","emmy.expression.analyze/default-simplifier",-1029400406,null);Rpb=new $APP.q("emmy.expression.compile","compiler-mode","emmy.expression.compile/compiler-mode",2050922658,null);Spb=new $APP.E(null,"bulirsch-stoer-closed","bulirsch-stoer-closed",-1579787828);
Tpb=new $APP.q("emmy.calculus.manifold","check-point","emmy.calculus.manifold/check-point",1850769069,null);RT=new $APP.q(null,"absolute-threshold","absolute-threshold",-1812236055,null);Upb=new $APP.q(null,"M-\x3eomega-body","M-\x3eomega-body",983228556,null);Vpb=new $APP.q("emmy.mechanics.rigid","M-of-q-\x3eomega-of-t","emmy.mechanics.rigid/M-of-q-\x3eomega-of-t",2073112316,null);Wpb=new $APP.q("emmy.expression","compare","emmy.expression/compare",-1460444273,null);
ST=new $APP.q(null,"selectors","selectors",959789759,null);Xpb=new $APP.q("emmy.generic","-","emmy.generic/-",-1086485521,null);Ypb=new $APP.q("emmy.generic","/","emmy.generic//",-2106270570,null);Zpb=new $APP.q("emmy.generic","*","emmy.generic/*",1624468586,null);$pb=new $APP.q("emmy.generic","+","emmy.generic/+",-2019921249,null);TT=new $APP.E(null,"open","open",-1763596448);aqb=new $APP.q(null,"local-state-derivative","local-state-derivative",-161819186,null);
bqb=new $APP.q("emmy.rational-function","arg-shift","emmy.rational-function/arg-shift",-1657281136,null);cqb=new $APP.q(null,"*unchecked-arrays*","*unchecked-arrays*",-381849911,null);UT=new $APP.E(null,"positional","positional",-203580463);dqb=new $APP.q("emmy.series","integral","emmy.series/integral",1400052131,null);eqb=new $APP.q("emmy.structure","basis-unit","emmy.structure/basis-unit",-186104379,null);fqb=new $APP.q(null,"update-frame","update-frame",-509780921,null);
jF=new $APP.E(null,"fn-arity","fn-arity",-403576501);gqb=new $APP.q(null,"catalan-series","catalan-series",695607563,null);hqb=new $APP.q(null,"almost-integral?","almost-integral?",66142864,null);iqb=new $APP.q("emmy.mechanics.lagrange","L-central-polar","emmy.mechanics.lagrange/L-central-polar",64463743,null);jqb=new $APP.q(null,"univariate-gcd","univariate-gcd",-754810104,null);kqb=new $APP.q("emmy.env","Gamma-bar","emmy.env/Gamma-bar",2059096836,null);
rab=new $APP.E("emmy.sr.frames","SR-coordinates?","emmy.sr.frames/SR-coordinates?",-568664156);lqb=new $APP.q(null,"v-over-c","v-over-c",275370392,null);mqb=new $APP.q("emmy.env","cube","emmy.env/cube",-673085262,null);VT=new $APP.E("emmy.collection","map","emmy.collection/map",-120400283);nqb=new $APP.q("emmy.simplify.rules","odd-integer?","emmy.simplify.rules/odd-integer?",-709501751,null);oqb=new $APP.q("emmy.env","R3-spherical","emmy.env/R3-spherical",-233418582,null);
pqb=new $APP.q("emmy.env","magnitude","emmy.env/magnitude",400507352,null);qqb=new $APP.q(null,"emmy.expression.analyze","emmy.expression.analyze",-1976783154,null);rqb=new $APP.q(null,"bracket-min-scmutils","bracket-min-scmutils",1756130332,null);WT=new $APP.q(null,"initial-brent-guess","initial-brent-guess",-1867938358,null);sqb=new $APP.q("emmy.calculus.manifold","coords-\x3epoint","emmy.calculus.manifold/coords-\x3epoint",-505581765,null);
tqb=new $APP.E(null,"no-stacktrace?","no-stacktrace?",1701072694);G_a=new $APP.E(null,"nanos","nanos",-1777059258);XT=new $APP.q(null,"compile?","compile?",813843877,null);uqb=new $APP.q("emmy.mechanics.rigid","L-body-Euler","emmy.mechanics.rigid/L-body-Euler",82000386,null);vqb=new $APP.q("emmy.util","longtype","emmy.util/longtype",1569625982,null);CRa=new $APP.E(null,"invoke-ctor","invoke-ctor",-756052704);qF=new $APP.E(null,"compilation","compilation",-1328774561);
wqb=new $APP.q("emmy.value","number?","emmy.value/number?",-2103383755,null);RQa=new $APP.E(null,"num-fields","num-fields",1529154024);xqb=new $APP.q(null,"symplectic-unit","symplectic-unit",54553914,null);YT=new $APP.q(null,"psi","psi",80412671,null);yqb=new $APP.q("emmy.env","define-coordinates","emmy.env/define-coordinates",-327183607,null);zqb=new $APP.q("emmy.polynomial.gcd","time-expired?","emmy.polynomial.gcd/time-expired?",98763553,null);
Aqb=new $APP.q("v","scalar?","v/scalar?",1570437899,null);Bqb=new $APP.q("emmy.pattern.match","match-when","emmy.pattern.match/match-when",-607337179,null);VH=new $APP.E("emmy.value","function","emmy.value/function",-1238426744);Cqb=new $APP.q("emmy.mechanics.hamilton","Lie-transform","emmy.mechanics.hamilton/Lie-transform",-1422742182,null);Dqb=new $APP.q("emmy.env","corresponding-velocities","emmy.env/corresponding-velocities",799939472,null);
Eqb=new $APP.q("emmy.env","literal-Cartan","emmy.env/literal-Cartan",1749215073,null);Fqb=new $APP.q("emmy.value","numerical?","emmy.value/numerical?",68608154,null);Gqb=new $APP.q("emmy.env","submatrix","emmy.env/submatrix",-80134854,null);Hqb=new $APP.q(null,"emmy.expression.render","emmy.expression.render",205266842,null);eF=new $APP.E(null,"numeric","numeric",-1495594714);$5a=new $APP.q(null,"lower","lower",-1534114948,null);
Iqb=new $APP.q(null,"double-factorial","double-factorial",267781799,null);Jqb=new $APP.q(null,"this-frame","this-frame",797029280,null);Kqb=new $APP.q(null,"general-determinant","general-determinant",-464196132,null);Lqb=new $APP.q("emmy.calculus.map","pullback","emmy.calculus.map/pullback",1601776300,null);Mqb=new $APP.q(null,"L-harmonic","L-harmonic",-1439317414,null);
Nqb=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer-fold","emmy.rational-function.interpolate/bulirsch-stoer-fold",969177736,null);ZT=new $APP.q(null,"Christoffel","Christoffel",-408898581,null);Oqb=new $APP.E(null,"initial-guess","initial-guess",-1883142405);$E=new $APP.E(null,"target","target",253001721);Pqb=new $APP.q("emmy.env","matrix-by-cols","emmy.env/matrix-by-cols",-232636262,null);
Qqb=new $APP.q(null,"Hamiltonian-\x3estate-derivative","Hamiltonian-\x3estate-derivative",853341788,null);KYa=new $APP.q(null,"simsqrt2","simsqrt2",-1794028771,null);JYa=new $APP.q(null,"simsqrt1","simsqrt1",-1069513157,null);Rqb=new $APP.q("emmy.matrix","rsolve","emmy.matrix/rsolve",1132098145,null);Sqb=new $APP.q("emmy.special.factorial","factorial","emmy.special.factorial/factorial",2087946329,null);Tqb=new $APP.q(null,"state-advancer","state-advancer",1461667085,null);
Uqb=new $APP.q(null,"argument-kind","argument-kind",1292297133,null);BVa=new $APP.E(null,"pattern","pattern",242135423);rVa=new $APP.E(null,"spying?","spying?",1753444487);HO=new $APP.E(null,"dimension","dimension",543254198);Vqb=new $APP.q(null,"ruleset*","ruleset*",2076462881,null);Wqb=new $APP.q("emmy.polynomial","evenly-divide","emmy.polynomial/evenly-divide",-789717990,null);H9a=new $APP.q(null,"Lie-transform","Lie-transform",1913072017,null);
Xqb=new $APP.q("emmy.generic","determinant","emmy.generic/determinant",-491865139,null);Yqb=new $APP.q("emmy.mechanics.lagrange","coordinate-tuple","emmy.mechanics.lagrange/coordinate-tuple",342016849,null);Zqb=new $APP.q("cljs.core","regexp?","cljs.core/regexp?",-348418979,null);$qb=new $APP.q(null,"S2p-spherical","S2p-spherical",-596118512,null);arb=new $APP.q(null,"literal-up","literal-up",2121652004,null);
brb=new $APP.q("emmy.pattern.rule","!\x3d\x3e","emmy.pattern.rule/!\x3d\x3e",1335650556,null);crb=new $APP.q("cljs.core","IChunkedSeq","cljs.core/IChunkedSeq",-892943716,null);drb=new $APP.q("emmy.mechanics.lagrange","state-\x3eqdot","emmy.mechanics.lagrange/state-\x3eqdot",756716733,null);erb=new $APP.q("emmy.simplify.rules","trig:sum-\x3eproduct","emmy.simplify.rules/trig:sum-\x3eproduct",845041118,null);frb=new $APP.q(null,"template","template",938125843,null);
grb=new $APP.q("emmy.numsymb","operands","emmy.numsymb/operands",-200381602,null);hrb=new $APP.q("emmy.calculus.manifold","S2p-Riemann","emmy.calculus.manifold/S2p-Riemann",-1411756215,null);irb=new $APP.q(null,"grow-limit","grow-limit",-524226826,null);jrb=new $APP.q(null,"S1-circular","S1-circular",-435145260,null);krb=new $APP.q(null,"emmy.value","emmy.value",-940670323,null);lrb=new $APP.q("emmy.structure","same","emmy.structure/same",-444962107,null);cI=new $APP.E(null,"from","from",1815293044);
mrb=new $APP.q("emmy.mechanics.hamilton","iterated-map","emmy.mechanics.hamilton/iterated-map",-520393614,null);nrb=new $APP.q(null,"state0","state0",1595451039,null);orb=new $APP.q("emmy.mechanics.hamilton","phase-space-derivative","emmy.mechanics.hamilton/phase-space-derivative",-2135919912,null);prb=new $APP.q(null,"unsigned?","unsigned?",1137767373,null);qrb=new $APP.q("emmy.env","Lap","emmy.env/Lap",1550109480,null);rrb=new $APP.q("emmy.env","conjugate","emmy.env/conjugate",-1908388678,null);
srb=new $APP.q(null,"REVERSE-EMPTY","REVERSE-EMPTY",-66425398,null);trb=new $APP.q(null,"qp-canonical?","qp-canonical?",-1589954108,null);urb=new $APP.q("emmy.series","function-\x3e","emmy.series/function-\x3e",-214623649,null);vrb=new $APP.q("emmy.env","Lagrangian-\x3eHamiltonian","emmy.env/Lagrangian-\x3eHamiltonian",-329281508,null);wrb=new $APP.q("emmy.dual","primal-tangent-pair","emmy.dual/primal-tangent-pair",-265703521,null);
xrb=new $APP.q("emmy.series","generate","emmy.series/generate",-1600609312,null);yrb=new $APP.q("emmy.env","velocity-tuple","emmy.env/velocity-tuple",353575488,null);zrb=new $APP.q("emmy.env","base-frame-maker","emmy.env/base-frame-maker",2024760385,null);Arb=new $APP.q("emmy.generic","conjugate","emmy.generic/conjugate",-1786958144,null);Brb=new $APP.q(null,"S2p-gnomonic","S2p-gnomonic",-68458035,null);Crb=new $APP.q("emmy.rational-function","mul","emmy.rational-function/mul",-1330903620,null);
Drb=new $APP.q("emmy.mechanics.lagrange","Lagrangian-\x3eenergy","emmy.mechanics.lagrange/Lagrangian-\x3eenergy",-1663647966,null);Erb=new $APP.q("emmy.mechanics.lagrange","L-harmonic","emmy.mechanics.lagrange/L-harmonic",151173670,null);Frb=new $APP.q("emmy.env","Euler-\x3eM","emmy.env/Euler-\x3eM",-602689074,null);Grb=new $APP.q("emmy.env","torsion-vector","emmy.env/torsion-vector",-1580647989,null);Hrb=new $APP.E(null,"new","new",-2085437848);Irb=new $APP.q(null,"-I","-I",-749163958,null);
Jrb=new $APP.q(null,"argument-types","argument-types",-1135318142,null);Krb=new $APP.q("emmy.env","quotient","emmy.env/quotient",8215747,null);Lrb=new $APP.q("emmy.quaternion","cylindrical","emmy.quaternion/cylindrical",-586938286,null);Mrb=new $APP.q(null,"-\x3eFunction","-\x3eFunction",-1491692950,null);Nrb=new $APP.q("emmy.numerical.unimin.bracket","bracket-min-scmutils","emmy.numerical.unimin.bracket/bracket-min-scmutils",-129617600,null);Orb=new $APP.E(null,"Euler-patch","Euler-patch",-700594077);
Prb=new $APP.q(null,"*inhibit-expt-simplify*","*inhibit-expt-simplify*",-2053640743,null);Qrb=new $APP.q(null,"s:generate","s:generate",1698463663,null);Rrb=new $APP.q(null,"stop-fn","stop-fn",1292059281,null);Srb=new $APP.q(null,"num-cols","num-cols",729489141,null);Urb=new $APP.q(null,"emmy.mechanics.rotation","emmy.mechanics.rotation",1705037628,null);Vrb=new $APP.q("emmy.mechanics.lagrange","literal-Lagrangian-state","emmy.mechanics.lagrange/literal-Lagrangian-state",1384430246,null);
Wrb=new $APP.q("emmy.mechanics.lagrange","Gamma","emmy.mechanics.lagrange/Gamma",-1904787378,null);Xrb=new $APP.E(null,"forward","forward",-557345303);Yrb=new $APP.q("emmy.env","rotate-z-tuple","emmy.env/rotate-z-tuple",1935923167,null);Zrb=new $APP.q("emmy.value","INumericTower","emmy.value/INumericTower",-780252741,null);$T=new $APP.q(null,"assumption","assumption",-169353111,null);$rb=new $APP.q(null,"seq-limit","seq-limit",474615035,null);
asb=new $APP.q("emmy.sr.frames","coordinate-origin","emmy.sr.frames/coordinate-origin",2034721019,null);bsb=new $APP.q("emmy.simplify.rules","log-contract","emmy.simplify.rules/log-contract",587382585,null);csb=new $APP.q("emmy.simplify.rules","exp-contract","emmy.simplify.rules/exp-contract",455824928,null);dsb=new $APP.q(null,"as-matrix","as-matrix",157934886,null);esb=new $APP.q("emmy.calculus.frame","make-event","emmy.calculus.frame/make-event",216916168,null);
fsb=new $APP.q(null,"new-frame","new-frame",-1748465223,null);aU=new $APP.q(null,"arity","arity",-168024608,null);gsb=new $APP.q("emmy.expression","make-literal","emmy.expression/make-literal",444883170,null);$6a=new $APP.E(null,"rewrite-trig-squares","rewrite-trig-squares",747917607);hsb=new $APP.q(null,"L-sliding-pend","L-sliding-pend",-21140854,null);isb=new $APP.q("emmy.mechanics.rotation","rotate-y-matrix","emmy.mechanics.rotation/rotate-y-matrix",-1606320298,null);
jsb=new $APP.q("emmy.env","partial-sums","emmy.env/partial-sums",-781020439,null);ksb=new $APP.E(null,"println","println",1920840330);CQ=new $APP.E("emmy.numerical.quadrature.common","closed","emmy.numerical.quadrature.common/closed",-1976285246);lsb=new $APP.q(null,"basis-\x3evector-basis","basis-\x3evector-basis",-168519818,null);msb=new $APP.q("emmy.mechanics.hamilton","J-func","emmy.mechanics.hamilton/J-func",552799566,null);
nsb=new $APP.q("emmy.matrix","generate","emmy.matrix/generate",-1659566826,null);osb=new $APP.q("emmy.pattern.syntax","unquoted-form","emmy.pattern.syntax/unquoted-form",1530248092,null);psb=new $APP.q("emmy.complex","I","emmy.complex/I",1737484988,null);qsb=new $APP.q(null,"S3-gnomonic","S3-gnomonic",-1897888682,null);rsb=new $APP.q(null,"one-manifold-function","one-manifold-function",117769992,null);ssb=new $APP.q(null,"log-expand","log-expand",763293820,null);
tsb=new $APP.q("emmy.env","kind-predicate","emmy.env/kind-predicate",1454672761,null);usb=new $APP.q("emmy.env","S2-Riemann","emmy.env/S2-Riemann",-5562070,null);vsb=new $APP.q("emmy.mechanics.routhian","Lagrangian-state-\x3eRouthian-state","emmy.mechanics.routhian/Lagrangian-state-\x3eRouthian-state",765802201,null);bU=new $APP.q(null,"real-part","real-part",-2001752061,null);wsb=new $APP.q(null,"to-basis","to-basis",1787878908,null);cU=new $APP.q(null,"??more","??more",-1836200365,null);
dU=new $APP.q(null,"stream","stream",-1119494121,null);xsb=new $APP.q("emmy.mechanics.lagrange","T3-spherical","emmy.mechanics.lagrange/T3-spherical",1318160988,null);ysb=new $APP.q(null,"factorial","factorial",127776047,null);zsb=new $APP.q(null,"make-SR-coordinates","make-SR-coordinates",-22454532,null);Asb=new $APP.q("emmy.structure","orientation","emmy.structure/orientation",1167918505,null);
Bsb=new $APP.q("emmy.calculus.metric","coordinate-system-\x3einverse-metric","emmy.calculus.metric/coordinate-system-\x3einverse-metric",1724882308,null);Csb=new $APP.q("emmy.env","coordinate-basis-vector-field","emmy.env/coordinate-basis-vector-field",-197518447,null);Dsb=new $APP.q("emmy.calculus.form-field","d","emmy.calculus.form-field/d",1695963856,null);oK=new $APP.q(null,"+pi-over-4","+pi-over-4",-1289502545,null);
Esb=new $APP.q("emmy.mechanics.hamilton","transpose-function","emmy.mechanics.hamilton/transpose-function",1213459101,null);Fsb=new $APP.q("emmy.env","the-real-line","emmy.env/the-real-line",-777414225,null);Gsb=new $APP.q("emmy.env","Christoffel-\x3eCartan","emmy.env/Christoffel-\x3eCartan",-1133165322,null);Hsb=new $APP.q(null,"power-series","power-series",-572905126,null);Isb=new $APP.q("emmy.calculus.derivative","partial-reverse","emmy.calculus.derivative/partial-reverse",-617370816,null);
Jsb=new $APP.q(null,"rotate-y","rotate-y",1176649417,null);Ksb=new $APP.q(null,"rotate-z","rotate-z",933472,null);Lsb=new $APP.q("emmy.polynomial.gcd","univariate-gcd","emmy.polynomial.gcd/univariate-gcd",2080687552,null);KVa=new $APP.E(null,"appender-id","appender-id",-1917983538);E6a=new $APP.E("zip","make-node","zip/make-node",1103800591);v5a=new $APP.E("emmy.calculus.covariant","Christoffel","emmy.calculus.covariant/Christoffel",428267637);
Msb=new $APP.q(null,"rotate-x","rotate-x",-1991735296,null);Nsb=new $APP.q(null,"cylindrospherical","cylindrospherical",893169674,null);Osb=new $APP.q("emmy.rational-function","partial-derivative","emmy.rational-function/partial-derivative",-1700046016,null);UQa=new $APP.E(null,"fields","fields",-1932066230);Psb=new $APP.q("emmy.env","vector-field-\x3eoneform-field","emmy.env/vector-field-\x3eoneform-field",-818137644,null);
Qsb=new $APP.q("emmy.special.factorial","falling-factorial","emmy.special.factorial/falling-factorial",-651306167,null);Rsb=new $APP.q("emmy.quaternion","sub","emmy.quaternion/sub",889140518,null);eU=new $APP.q(null,"domain","domain",-807220832,null);Ssb=new $APP.q(null,"rotate-y-matrix","rotate-y-matrix",1752319055,null);Tsb=new $APP.q("emmy.matrix","diagonal","emmy.matrix/diagonal",794363528,null);Usb=new $APP.q("emmy.algebra.fold","count","emmy.algebra.fold/count",630331933,null);
Vsb=new $APP.q("emmy.quaternion","evaluate","emmy.quaternion/evaluate",1823777220,null);Wsb=new $APP.q("emmy.rational-function","analyzer","emmy.rational-function/analyzer",562799325,null);Xsb=new $APP.q("emmy.mechanics.rotation","rotate-x","emmy.mechanics.rotation/rotate-x",1094708537,null);Ysb=new $APP.q("emmy.mechanics.rotation","rotate-z","emmy.mechanics.rotation/rotate-z",1209918745,null);Zsb=new $APP.q("emmy.mechanics.rotation","rotate-y","emmy.mechanics.rotation/rotate-y",506582518,null);
$sb=new $APP.q(null,"add-velocities","add-velocities",1395500614,null);atb=new $APP.E(null,"unsupported-preprocess-value","unsupported-preprocess-value",1635147105);btb=new $APP.q(null,"fn-tolerance","fn-tolerance",194925363,null);ctb=new $APP.q("emmy.env","dot-product","emmy.env/dot-product",-1392257953,null);QG=new $APP.E(null,"output-fn","output-fn",1600951539);dtb=new $APP.q("emmy.polynomial.gcd","gcd-stats","emmy.polynomial.gcd/gcd-stats",1396556642,null);
etb=new $APP.q("emmy.util.aggregate","pairwise-sum","emmy.util.aggregate/pairwise-sum",-678185942,null);ftb=new $APP.q(null,"*incremental-simplifier*","*incremental-simplifier*",231067924,null);gtb=new $APP.q("emmy.expression","abstract-types","emmy.expression/abstract-types",-1816084977,null);htb=new $APP.q("emmy.mechanics.lagrange","Lagrange-equations-operator","emmy.mechanics.lagrange/Lagrange-equations-operator",29259867,null);
itb=new $APP.q(null,"basis-components-\x3eoneform-field","basis-components-\x3eoneform-field",785978786,null);jtb=new $APP.q("emmy.pattern.rule","template","emmy.pattern.rule/template",1191187487,null);ktb=new $APP.q(null,"quaternion-state-\x3eomega-body","quaternion-state-\x3eomega-body",1179732597,null);OK=new $APP.E(null,"subtype","subtype",-2092672993);ltb=new $APP.q("emmy.dual","-\x3eCompleted","emmy.dual/-\x3eCompleted",-43704959,null);
mtb=new $APP.q("emmy.mechanics.hamilton","-\x3eH-state","emmy.mechanics.hamilton/-\x3eH-state",1385304134,null);ntb=new $APP.q(null,"emmy.polynomial.interpolate","emmy.polynomial.interpolate",-1804382523,null);otb=new $APP.q(null,"velocity","velocity",1059007172,null);fU=new $APP.q(null,"arg-scale","arg-scale",-828801718,null);ptb=new $APP.q("emmy.env","partial-forward","emmy.env/partial-forward",-526740990,null);
qtb=new $APP.q("emmy.generic","outer-product","emmy.generic/outer-product",-1055965769,null);rtb=new $APP.q("emmy.special.elliptic","k-and-deriv","emmy.special.elliptic/k-and-deriv",411204883,null);stb=new $APP.q("emmy.simplify.rules","*inverse-simplify?*","emmy.simplify.rules/*inverse-simplify?*",1030704636,null);ttb=new $APP.q("emmy.matrix","solve","emmy.matrix/solve",-521544751,null);utb=new $APP.q("emmy.rational-function","square","emmy.rational-function/square",-1370743621,null);
vtb=new $APP.q("emmy.env","solve-linear","emmy.env/solve-linear",-653183971,null);wtb=new $APP.q(null,"expression-analyzer","expression-analyzer",1165025557,null);xtb=new $APP.q(null,"H-central-polar","H-central-polar",37104917,null);ytb=new $APP.q("emmy.env","four-tuple-\x3ect","emmy.env/four-tuple-\x3ect",-610797870,null);ztb=new $APP.q(null,"F-\x3eCT","F-\x3eCT",-1012552178,null);Atb=new $APP.q(null,"F-\x3eCH","F-\x3eCH",404198748,null);gU=new $APP.E(null,"jsdoc","jsdoc",1745183516);
Btb=new $APP.q("emmy.polynomial.gcd","gcd","emmy.polynomial.gcd/gcd",-909213703,null);Ctb=new $APP.q("emmy.calculus.basis","vector-basis-\x3edual","emmy.calculus.basis/vector-basis-\x3edual",-1119249214,null);Dtb=new $APP.q("emmy.env","partial-derivative","emmy.env/partial-derivative",-841620326,null);Etb=new $APP.q(null,"log2","log2",-1850656939,null);Ftb=new $APP.q("emmy.series","series","emmy.series/series",-837260996,null);
Gtb=new $APP.q(null,"oneform-field-\x3evector-field","oneform-field-\x3evector-field",-1253191494,null);$APP.hU=new $APP.q(null,"point","point",-841237505,null);Htb=new $APP.q("emmy.generic","Lie-derivative","emmy.generic/Lie-derivative",-1383110342,null);Itb=new $APP.q(null,"k__36626__auto__","k__36626__auto__",113536313,null);R$a=new $APP.q(null,"array-reduce","array-reduce",154113968,null);
Jtb=new $APP.q("emmy.simplify.rules","odd-positive-integer?","emmy.simplify.rules/odd-positive-integer?",-47331359,null);Ktb=new $APP.q("emmy.env","make-SR-coordinates","emmy.env/make-SR-coordinates",860815649,null);Ltb=new $APP.E(null,"midpoint","midpoint",-36269525);Mtb=new $APP.q("emmy.structure","kronecker","emmy.structure/kronecker",-1820129971,null);sUa=new $APP.E(null,"deny-spec","deny-spec",-1074984268);
Ntb=new $APP.q("emmy.pattern.syntax","restricted?","emmy.pattern.syntax/restricted?",-1782073038,null);Otb=new $APP.q(null,"arithmetic-ex","arithmetic-ex",2003781159,null);Ptb=new $APP.q("emmy.mechanics.hamilton","Hamiltonian-\x3estate-derivative","emmy.mechanics.hamilton/Hamiltonian-\x3estate-derivative",1170764435,null);Qtb=new $APP.q(null,"*poly-gcd-cache-enable*","*poly-gcd-cache-enable*",-1934378538,null);nQ=new $APP.E(null,"maxiter","maxiter",-1867223754);
Rtb=new $APP.q(null,"curl","curl",213545217,null);Stb=new $APP.q("emmy.expression.compile","validate-mode!","emmy.expression.compile/validate-mode!",2085105166,null);Ttb=new $APP.q(null,"kbn","kbn",-176972830,null);Utb=new $APP.q(null,"coordinate-system-\x3einverse-metric","coordinate-system-\x3einverse-metric",1607613774,null);BE=new $APP.E(null,"use-macros","use-macros",-905638393);Vtb=new $APP.q("emmy.env","Cartan?","emmy.env/Cartan?",-603061185,null);Wtb=new $APP.E(null,"hours","hours",58380855);
Xtb=new $APP.q("emmy.env","extended-rotation","emmy.env/extended-rotation",1609247994,null);Ytb=new $APP.q("emmy.series","tan-series","emmy.series/tan-series",837840721,null);Ztb=new $APP.q("emmy.numsymb","symbolic-operator","emmy.numsymb/symbolic-operator",1626790775,null);$tb=new $APP.q(null,"object-name-map","object-name-map",-812683425,null);aub=new $APP.q(null,"illegal-state","illegal-state",120680345,null);bub=new $APP.q(null,"emmy.mechanics.lagrange","emmy.mechanics.lagrange",288531855,null);
cub=new $APP.q("emmy.env","golden-section-min","emmy.env/golden-section-min",-305772320,null);dub=new $APP.q("emmy.mechanics.hamilton","standard-map-inverse","emmy.mechanics.hamilton/standard-map-inverse",34690720,null);eub=new $APP.q("emmy.env","Grad","emmy.env/Grad",-411848947,null);fub=new $APP.q("emmy.pattern.rule","rule*","emmy.pattern.rule/rule*",192682942,null);gub=new $APP.q("emmy.env","Ricci","emmy.env/Ricci",-126627823,null);KE=new $APP.E(null,"context","context",-830191113);
hub=new $APP.q("emmy.env","simplify","emmy.env/simplify",2104690809,null);iub=new $APP.q(null,"derivative","derivative",-1233120304,null);jub=new $APP.q("emmy.sr.boost","extended-rotation","emmy.sr.boost/extended-rotation",176702373,null);kub=new $APP.q("emmy.pattern.rule","ruleset*","emmy.pattern.rule/ruleset*",-886313707,null);eVa=new $APP.E(null,"msg-type","msg-type",-2132567822);lub=new $APP.q("emmy.env","tanhc","emmy.env/tanhc",-961031083,null);
mub=new $APP.q("emmy.env","vf:zero","emmy.env/vf:zero",-1860540553,null);nub=new $APP.q("emmy.expression.analyze","expression-\x3e","emmy.expression.analyze/expression-\x3e",-2017023069,null);iU=new $APP.q(null,"make","make",356488202,null);oub=new $APP.q("emmy.numerical.derivative","forward-difference","emmy.numerical.derivative/forward-difference",-764307413,null);pub=new $APP.q("emmy.quaternion","q-div-scalar","emmy.quaternion/q-div-scalar",-1093761009,null);
qub=new $APP.q(null,"emmy.ratio","emmy.ratio",1125351397,null);rub=new $APP.q(null,"literal-apply","literal-apply",-411755029,null);sub=new $APP.q(null,"*poly-gcd-time-limit*","*poly-gcd-time-limit*",-131795633,null);tub=new $APP.q("emmy.quaternion","tan","emmy.quaternion/tan",-574658076,null);uub=new $APP.q("emmy.calculus.connection","metric-\x3econnection-2","emmy.calculus.connection/metric-\x3econnection-2",1719273556,null);
vub=new $APP.q("emmy.calculus.connection","metric-\x3econnection-1","emmy.calculus.connection/metric-\x3econnection-1",-720939870,null);jU=new $APP.q("emmy.dual","IPerturbed","emmy.dual/IPerturbed",-340126679,null);wub=new $APP.q(null,"Euler-state-\x3eomega-body","Euler-state-\x3eomega-body",949502059,null);h8a=new $APP.E(null,"unexpected","unexpected",-1137752424);xub=new $APP.q("cljs.core","volatile?","cljs.core/volatile?",-1122186415,null);
yub=new $APP.q(null,"typed-\x3estructure","typed-\x3estructure",1731883948,null);zub=new $APP.q("emmy.mechanics.hamilton","qp-submatrix","emmy.mechanics.hamilton/qp-submatrix",1013050217,null);Aub=new $APP.q("emmy.rational-function","expression-\x3e","emmy.rational-function/expression-\x3e",628800854,null);K6a=new $APP.E(null,"changed?","changed?",-437828330);Bub=new $APP.q("emmy.pattern.match","bind","emmy.pattern.match/bind",507325627,null);
kU=new $APP.q(null,"v-compare","v-compare",-1787498040,null);Cub=new $APP.q("emmy.generic","angle","emmy.generic/angle",-1766806104,null);Dub=new $APP.q("emmy.util.stream","powers","emmy.util.stream/powers",1499305441,null);Eub=new $APP.q("emmy.mechanics.lagrange","velocities","emmy.mechanics.lagrange/velocities",-1648090729,null);Fub=new $APP.q(null,"mapr","mapr",-483178594,null);Gub=new $APP.q("emmy.polynomial.interpolate","neville-sum","emmy.polynomial.interpolate/neville-sum",1443576906,null);
MXa=new $APP.q(null,"$$","$$",-1388085599,null);Hub=new $APP.q("emmy.pattern.match","predicate","emmy.pattern.match/predicate",1055232176,null);Iub=new $APP.q("emmy.polynomial","add","emmy.polynomial/add",-549260368,null);Jub=new $APP.q("emmy.structure","*allow-incompatible-multiplication*","emmy.structure/*allow-incompatible-multiplication*",872974539,null);Kub=new $APP.q("emmy.calculus.basis","basis-\x3edimension","emmy.calculus.basis/basis-\x3edimension",-34013778,null);
Lub=new $APP.q("emmy.calculus.map","pushforward-vector","emmy.calculus.map/pushforward-vector",-1537800027,null);Mub=new $APP.q(null,"scan","scan",1311631423,null);Nub=new $APP.q(null,"unit?","unit?",-1881833431,null);Oub=new $APP.q(null,"structure-\x3eaccess-chains","structure-\x3eaccess-chains",-204414988,null);Pub=new $APP.E(null,"point-\x3ecoords","point-\x3ecoords",1312461607);Qub=new $APP.q(null,"from-complex","from-complex",-1001613936,null);
BYa=new $APP.q(null,"logexp2","logexp2",-1768907713,null);Rub=new $APP.q(null,"pullback-vector-field","pullback-vector-field",2082593527,null);Sub=new $APP.q("emmy.calculus.manifold","S2p-gnomonic","emmy.calculus.manifold/S2p-gnomonic",-1302991049,null);Tub=new $APP.q(null,"macroexpand-check","macroexpand-check",699092091,null);Uub=new $APP.q(null,"Christoffel-\x3esymbols","Christoffel-\x3esymbols",-397563291,null);
Vub=new $APP.q("emmy.calculus.vector-field","vector-field-\x3ebasis-components","emmy.calculus.vector-field/vector-field-\x3ebasis-components",-1306923308,null);OJ=new $APP.q(null,"?new-n","?new-n",-1095502685,null);Wub=new $APP.q(null,"oneform-field","oneform-field",119367957,null);Xub=new $APP.q(null,"structure-\x3ematrix","structure-\x3ematrix",1147394120,null);$APP.UD=new $APP.E(null,"order","order",-1254677256);
Yub=new $APP.q("emmy.mechanics.rigid","rigid-sysder","emmy.mechanics.rigid/rigid-sysder",-844995161,null);Zub=new $APP.q(null,"meta49063","meta49063",-516481606,null);$ub=new $APP.q(null,"basis-\x3ebasis-over-map","basis-\x3ebasis-over-map",-689512767,null);avb=new $APP.q(null,"exact?","exact?",-2028776167,null);bvb=new $APP.q(null,"patterns-and-consequences","patterns-and-consequences",-675483795,null);cvb=new $APP.q("emmy.ratio","parse-ratio","emmy.ratio/parse-ratio",1512919462,null);
dvb=new $APP.q(null,"Christoffel-\x3eCartan","Christoffel-\x3eCartan",-24052573,null);evb=new $APP.q("emmy.env","Gamma","emmy.env/Gamma",-368697251,null);fvb=new $APP.q("cljs.core","Inst","cljs.core/Inst",959205835,null);gvb=new $APP.q("emmy.value","Numerical","emmy.value/Numerical",-531724654,null);EVa=new $APP.E(null,"timestamp-opts","timestamp-opts",-1359534807);hvb=new $APP.q(null,"literal-column-matrix","literal-column-matrix",-1078794984,null);ivb=new $APP.q(null,"tex$$","tex$$",275226341,null);
jvb=new $APP.q("emmy.series","series?","emmy.series/series?",1613808352,null);kvb=new $APP.q("emmy.env","golden-section-max","emmy.env/golden-section-max",-945786394,null);lvb=new $APP.q(null,"acot-series","acot-series",2130004200,null);mvb=new $APP.q(null,"coord-sys","coord-sys",-674266314,null);cZa=new $APP.q(null,"atan-tan","atan-tan",-478846145,null);nvb=new $APP.q(null,"raise-arity","raise-arity",1424406691,null);
ovb=new $APP.q("emmy.structure","two-tensor-info","emmy.structure/two-tensor-info",-1647106255,null);pvb=new $APP.q("emmy.env","identity-like","emmy.env/identity-like",425106033,null);qvb=new $APP.E(null,"mid","mid",-2123385246);rvb=new $APP.q(null,"mass","mass",-498418519,null);svb=new $APP.q("emmy.series","series*","emmy.series/series*",1027930493,null);AYa=new $APP.q(null,"logexp1","logexp1",-1360132001,null);
tvb=new $APP.q("emmy.numerical.derivative","D-numeric","emmy.numerical.derivative/D-numeric",-1153804284,null);lU=new $APP.E(null,"imported-from","imported-from",1590463704);uvb=new $APP.q(null,"IPerturbed","IPerturbed",-1705959821,null);vvb=new $APP.E(null,"exprs","exprs",1795829094);wvb=new $APP.q(null,"dual?","dual?",-1114580629,null);xvb=new $APP.q("emmy.mechanics.hamilton","T-func","emmy.mechanics.hamilton/T-func",1164287767,null);
yvb=new $APP.q("emmy.mechanics.hamilton","symplectic-two-form","emmy.mechanics.hamilton/symplectic-two-form",753890769,null);zvb=new $APP.q("emmy.quaternion","from-angle-axis","emmy.quaternion/from-angle-axis",-35417977,null);Avb=new $APP.q("emmy.generic","transpose","emmy.generic/transpose",-1456344334,null);Bvb=new $APP.q("emmy.env","sqrt","emmy.env/sqrt",-654878317,null);Cvb=new $APP.q(null,"skeleton","skeleton",-126504426,null);
Dvb=new $APP.q("emmy.mechanics.lagrange","-\x3eL-state","emmy.mechanics.lagrange/-\x3eL-state",-1643104361,null);Evb=new $APP.q(null,"S2p-stereographic","S2p-stereographic",1252985877,null);Fvb=new $APP.q(null,"euler","euler",1830471499,null);XO=new $APP.E(null,"arguments","arguments",-1182834456);N$a=new $APP.E(null,"tolerance","tolerance",406811818);Gvb=new $APP.q(null,"meta49029","meta49029",-1893810837,null);Hvb=new $APP.q("emmy.env","exact?","emmy.env/exact?",-1040802314,null);
Ivb=new $APP.q(null,"basis-\x3ecoordinate-system","basis-\x3ecoordinate-system",-1847737797,null);Jvb=new $APP.E(null,"no-op","no-op",-93046065);Kvb=new $APP.q(null,"symplectic-transform?","symplectic-transform?",-597154357,null);Lvb=new $APP.q(null,"LE","LE",1319258661,null);Mvb=new $APP.q(null,"sumr","sumr",302547133,null);Nvb=new $APP.q("emmy.polynomial.richardson","richardson-column","emmy.polynomial.richardson/richardson-column",1739669134,null);Ovb=new $APP.E(null,"simpson38","simpson38",-754529919);
Pvb=new $APP.q("emmy.mechanics.lagrange","Dt","emmy.mechanics.lagrange/Dt",-1268615967,null);Qvb=new $APP.q(null,"L-central-rectangular","L-central-rectangular",613723220,null);Rvb=new $APP.q(null,"foreach","foreach",1221441146,null);Svb=new $APP.q("emmy.env","csch","emmy.env/csch",-914429636,null);Tvb=new $APP.q(null,"reverse-segment","reverse-segment",-571699043,null);Uvb=new $APP.q("emmy.mechanics.lagrange","L-two-particle","emmy.mechanics.lagrange/L-two-particle",971498539,null);
Vvb=new $APP.q(null,"polar-canonical","polar-canonical",-1550139768,null);Wvb=new $APP.q("emmy.mechanics.lagrange","qv-\x3elocal-path","emmy.mechanics.lagrange/qv-\x3elocal-path",-1275417780,null);Xvb=new $APP.q(null,"rotate-z-tuple","rotate-z-tuple",-1312708500,null);Yvb=new $APP.q("emmy.polynomial","map-exponents","emmy.polynomial/map-exponents",230746221,null);Zvb=new $APP.q(null,"S2-metric","S2-metric",1081044753,null);$vb=new $APP.q(null,"event-\x3ecoords","event-\x3ecoords",-81360503,null);
awb=new $APP.q("emmy.env","-\x3elocal","emmy.env/-\x3elocal",10264939,null);bwb=new $APP.q("emmy.series","constant","emmy.series/constant",-2136577855,null);cwb=new $APP.q("emmy.pattern.match","pass","emmy.pattern.match/pass",2021981941,null);dwb=new $APP.q("emmy.calculus.derivative","partial","emmy.calculus.derivative/partial",-920700913,null);ewb=new $APP.q("emmy.generic","asech","emmy.generic/asech",-1327326229,null);
fwb=new $APP.q("emmy.mechanics.lagrange","LE","emmy.mechanics.lagrange/LE",-1352752575,null);gwb=new $APP.q("matrix","antisymmetric?","matrix/antisymmetric?",-1425081311,null);mU=new $APP.q("cljs.core","IEquiv","cljs.core/IEquiv",-1245752602,null);hwb=new $APP.q("emmy.polynomial.interpolate","neville","emmy.polynomial.interpolate/neville",1611538742,null);iwb=new $APP.q("emmy.calculus.manifold","alternate-angles","emmy.calculus.manifold/alternate-angles",-1388506517,null);
NK=new $APP.q(null,"component","component",-1098498987,null);jwb=new $APP.q(null,"Cartan-transform","Cartan-transform",397778116,null);kwb=new $APP.q("emmy.mechanics.lagrange","velocity-tuple","emmy.mechanics.lagrange/velocity-tuple",-236731791,null);lwb=new $APP.q("emmy.mechanics.lagrange","Lagrange-equations-first-order","emmy.mechanics.lagrange/Lagrange-equations-first-order",-647102082,null);j5a=new $APP.q(null,"make-fake-vector-field","make-fake-vector-field",-1146565625,null);
GZa=new $APP.E(null,"outer-orientation","outer-orientation",-985566313);mwb=new $APP.q("emmy.numerical.unimin.golden","inv-phi","emmy.numerical.unimin.golden/inv-phi",1708835685,null);nwb=new $APP.q("emmy.mechanics.lagrange","s-\x3er","emmy.mechanics.lagrange/s-\x3er",937839797,null);owb=new $APP.q(null,"with-lower-arity","with-lower-arity",2056753154,null);pwb=new $APP.q(null,"js?","js?",-1922587099,null);qwb=new $APP.q(null,"var-meta","var-meta",785035777,null);
rwb=new $APP.E(null,"literal?","literal?",352485871);nU=new $APP.q(null,"fold","fold",753070195,null);swb=new $APP.q("emmy.env","acceleration-tuple","emmy.env/acceleration-tuple",-1309226785,null);$APP.DQ=new $APP.E(null,"interval","interval",1708495417);twb=new $APP.q("emmy.expression","expression-\x3estream","emmy.expression/expression-\x3estream",-1331609557,null);uwb=new $APP.q("emmy.calculus.derivative","D","emmy.calculus.derivative/D",-645610427,null);
vwb=new $APP.q("emmy.calculus.curvature","torsion","emmy.calculus.curvature/torsion",1761460222,null);wwb=new $APP.q(null,"kind-predicate","kind-predicate",336774062,null);xwb=new $APP.q(null,"R1","R1",1595616472,null);ywb=new $APP.q("emmy.generic","exp","emmy.generic/exp",99355250,null);zwb=new $APP.q(null,"R2","R2",51758745,null);Awb=new $APP.q(null,"R3","R3",-72629094,null);Bwb=new $APP.q(null,"R4","R4",-879475264,null);JOa=new $APP.E(null,"module","module",1424618191);
Cwb=new $APP.q("emmy.matrix","s:solve-linear-right","emmy.matrix/s:solve-linear-right",2083145779,null);Dwb=new $APP.q(null,"emmy.polynomial.richardson","emmy.polynomial.richardson",-1983697181,null);Ewb=new $APP.q(null,"S1","S1",1013002370,null);oU=new $APP.q(null,"orientation","orientation",-2030878190,null);Fwb=new $APP.q(null,"Euler-state-\x3eL-body","Euler-state-\x3eL-body",-1827575539,null);
Gwb=new $APP.q("emmy.mechanics.lagrange","rectangular-\x3espherical","emmy.mechanics.lagrange/rectangular-\x3espherical",1575230615,null);pU=new $APP.q(null,"coordinate-prototype","coordinate-prototype",-1149174049,null);Hwb=new $APP.q(null,"coordinate","coordinate",1527720318,null);Iwb=new $APP.q("emmy.mechanics.lagrange","-\x3estate","emmy.mechanics.lagrange/-\x3estate",-74084632,null);Jwb=new $APP.q(null,"S2","S2",1434700047,null);Kwb=new $APP.q(null,"S3","S3",1919527328,null);
Lwb=new $APP.q("emmy.expression","variables-in","emmy.expression/variables-in",-1256051564,null);Mwb=new $APP.q("emmy.calculus.manifold","S1-slope","emmy.calculus.manifold/S1-slope",-27432147,null);Nwb=new $APP.q("emmy.simplify.rules","sin-sq-\x3ecos-sq","emmy.simplify.rules/sin-sq-\x3ecos-sq",542981601,null);Owb=new $APP.q(null,"fork","fork",-1591461534,null);Pwb=new $APP.q(null,"bracket-max","bracket-max",-1833956158,null);Qwb=new $APP.q(null,"Rn","Rn",1925679884,null);
Rwb=new $APP.q(null,"T1","T1",-1863234891,null);Swb=new $APP.q(null,"T2","T2",-986451912,null);Twb=new $APP.q(null,"next-p-fn","next-p-fn",1114419574,null);Uwb=new $APP.q(null,"Rx","Rx",410881441,null);qU=new $APP.q("cljs.core","ICollection","cljs.core/ICollection",802638471,null);Vwb=new $APP.q("emmy.generic","exact-zero?","emmy.generic/exact-zero?",-116345427,null);Wwb=new $APP.q("emmy.calculus.manifold","spacetime-sphere","emmy.calculus.manifold/spacetime-sphere",175578561,null);
Xwb=new $APP.q(null,"RationalFunction","RationalFunction",1491561426,null);Ywb=new $APP.q(null,"Ry","Ry",249628162,null);Zwb=new $APP.q(null,"Rz","Rz",-1950648434,null);$wb=new $APP.q(null,"Sn","Sn",-153298683,null);axb=new $APP.E(null,"open-closed","open-closed",-1293256622);bxb=new $APP.q(null,"attach-coordinate-system","attach-coordinate-system",-1382768242,null);cxb=new $APP.q(null,"-\x3elocal","-\x3elocal",1172465974,null);dxb=new $APP.q(null,"make-SR-frame","make-SR-frame",-949574673,null);
exb=new $APP.q(null,"abstract?","abstract?",1420943811,null);k2a=new $APP.q(null,"UP","UP",-1898089532,null);fxb=new $APP.q(null,"Numerical","Numerical",390792779,null);gxb=new $APP.q("emmy.calculus.frame","frame?","emmy.calculus.frame/frame?",813579663,null);hxb=new $APP.q("emmy.calculus.manifold","manifold-family?","emmy.calculus.manifold/manifold-family?",-1403588078,null);ixb=new $APP.q("emmy.env","contract","emmy.env/contract",754783939,null);
jxb=new $APP.q("emmy.simplify.rules","*expt-half-\x3esqrt?*","emmy.simplify.rules/*expt-half-\x3esqrt?*",-390949078,null);kxb=new $APP.E(null,"undeclared-macros-ns","undeclared-macros-ns",-438029430);lxb=new $APP.q("emmy.env","qp-submatrix","emmy.env/qp-submatrix",-1544308977,null);mxb=new $APP.q("emmy.env","wcross-\x3ew","emmy.env/wcross-\x3ew",945092694,null);nxb=new $APP.q(null,"make-Christoffel-1","make-Christoffel-1",77741028,null);
oxb=new $APP.q(null,"momentum-tuple","momentum-tuple",-27972686,null);pxb=new $APP.E(null,"romberg","romberg",609723434);PXa=new $APP.E("emmy.pattern.consequence","succeed","emmy.pattern.consequence/succeed",519698243);rU=new $APP.q(null,"α","α",-210042210,null);qxb=new $APP.q("emmy.env","S1-slope","emmy.env/S1-slope",-408543850,null);rxb=new $APP.q(null,"G__42888","G__42888",1190732901,null);sxb=new $APP.q(null,"ε","ε",-1396568965,null);ZRa=new $APP.E(null,"vals","vals",768058733);
txb=new $APP.q(null,"symbolic-taylor-series","symbolic-taylor-series",-622675349,null);uxb=new $APP.q(null,"meta57472","meta57472",1903688089,null);vxb=new $APP.q(null,"*strict-arity-checks*","*strict-arity-checks*",816380251,null);wxb=new $APP.E(null,"current-symbol","current-symbol",-932381075);n2a=new $APP.q(null,"X*","X*",1047022815,null);xxb=new $APP.q(null,"Vr","Vr",1917258557,null);yxb=new $APP.q("emmy.rational-function","make","emmy.rational-function/make",1765232261,null);
zxb=new $APP.q("emmy.mechanics.hamilton","H-rectangular","emmy.mechanics.hamilton/H-rectangular",-413726828,null);Axb=new $APP.q(null,"Euler-\x3eomega-body","Euler-\x3eomega-body",84295533,null);Bxb=new $APP.q(null,"sin-sq-\x3ecos-sq","sin-sq-\x3ecos-sq",1625924925,null);Cxb=new $APP.q("emmy.polynomial.interpolate","neville-recursive","emmy.polynomial.interpolate/neville-recursive",-468921529,null);Dxb=new $APP.q(null,"meta57464","meta57464",539451490,null);
Exb=new $APP.q("emmy.complex","ONE","emmy.complex/ONE",581834791,null);Fxb=new $APP.q(null,"bracket-min","bracket-min",-1880863081,null);SPa=new $APP.q("cljs.core","implements?","cljs.core/implements?",-251485149,null);Gxb=new $APP.q(null,"qw-state-\x3eL-space","qw-state-\x3eL-space",347488469,null);$Qa=new $APP.E("cljs.analyzer","list","cljs.analyzer/list",-539585923);Hxb=new $APP.q("emmy.env","m-\x3es","emmy.env/m-\x3es",220788748,null);
Ixb=new $APP.q(null,"-\x3eStructure","-\x3eStructure",-1170287724,null);Jxb=new $APP.q("emmy.mechanics.rotation","rotate-z-tuple","emmy.mechanics.rotation/rotate-z-tuple",-909229189,null);Kxb=new $APP.q(null,"meta57459","meta57459",-2073742992,null);TR=new $APP.E(null,"origin","origin",1037372088);Lxb=new $APP.q(null,"available-methods","available-methods",96037987,null);Mxb=new $APP.q("emmy.calculus.vector-field","vf:zero","emmy.calculus.vector-field/vf:zero",-1835394610,null);
Nxb=new $APP.q(null,"argument","argument",-1471433928,null);Oxb=new $APP.q("emmy.env","log","emmy.env/log",-1068738128,null);Pxb=new $APP.q("emmy.env","basis-\x3evector-basis","emmy.env/basis-\x3evector-basis",844291841,null);Qxb=new $APP.q(null,"meta57449","meta57449",1897026304,null);Rxb=new $APP.q("emmy.mechanics.hamilton","time-independent-canonical?","emmy.mechanics.hamilton/time-independent-canonical?",49357688,null);Sxb=new $APP.q(null,"Qdotdot","Qdotdot",1384643287,null);
Txb=new $APP.q("cljs.core","symbol?","cljs.core/symbol?",1422196122,null);Uxb=new $APP.q(null,"meta57441","meta57441",335433717,null);Vxb=new $APP.q("emmy.quaternion","ONE-matrix","emmy.quaternion/ONE-matrix",-1099906141,null);Wxb=new $APP.q("emmy.calculus.derivative","D-forward","emmy.calculus.derivative/D-forward",427958367,null);Xxb=new $APP.q("emmy.matrix","literal-matrix","emmy.matrix/literal-matrix",113887090,null);$Ua=new $APP.E(null,"ns-filter","ns-filter",108598448);
Yxb=new $APP.q(null,"emmy.util.logic","emmy.util.logic",-1309409419,null);Zxb=new $APP.q("emmy.mechanics.rigid","Euler-\x3eomega-body","emmy.mechanics.rigid/Euler-\x3eomega-body",-2038335469,null);$xb=new $APP.q("emmy.quaternion","ZERO","emmy.quaternion/ZERO",-1083776647,null);ayb=new $APP.q("emmy.env","literal-oneform-field","emmy.env/literal-oneform-field",560911970,null);byb=new $APP.q(null,"-\x3eDual","-\x3eDual",-478966744,null);cyb=new $APP.q(null,"trig:special","trig:special",-1108594585,null);
dyb=new $APP.q("emmy.structure","mapr","emmy.structure/mapr",-1572536377,null);eyb=new $APP.q("emmy.calculus.manifold","coordinate-system-at","emmy.calculus.manifold/coordinate-system-at",-2128414549,null);fyb=new $APP.q(null,"literal-number","literal-number",1180750380,null);gyb=new $APP.E(null,"hostname_","hostname_",-2091647379);hyb=new $APP.q("emmy.quaternion","negate","emmy.quaternion/negate",-1003742118,null);iyb=new $APP.q(null,"subpermute","subpermute",99919407,null);
jyb=new $APP.q(null,"meta57431","meta57431",653532405,null);kyb=new $APP.E(null,"no-such-method","no-such-method",1087422840);lyb=new $APP.q("emmy.matrix","structure-\x3ematrix","emmy.matrix/structure-\x3ematrix",191185365,null);$APP.sU=new $APP.q(null,"b","b",-1172211299,null);$APP.lP=new $APP.q(null,"d","d",-682293345,null);myb=new $APP.q(null,"emmy.calculus.curvature","emmy.calculus.curvature",-869522506,null);tU=new $APP.q(null,"g","g",-916345864,null);uU=new $APP.q(null,"j","j",242556762,null);
nO=new $APP.q(null,"l","l",-1258542346,null);$APP.vU=new $APP.q(null,"k","k",-505765866,null);$APP.wU=new $APP.q(null,"n","n",-2092305744,null);$APP.oO=new $APP.q(null,"r","r",1169147337,null);nyb=new $APP.q(null,"\x3c?","\x3c?",-1929864530,null);xU=new $APP.q(null,"q","q",-1965434072,null);oyb=new $APP.q(null,"numerical?","numerical?",286810593,null);yU=new $APP.q(null,"u","u",483896742,null);pyb=new $APP.q(null,"meta57422","meta57422",694898237,null);qyb=new $APP.q(null,"w","w",1994700528,null);
zU=new $APP.q(null,"vector-basis","vector-basis",770571439,null);ryb=new $APP.q("emmy.matrix","s:transpose-orientation","emmy.matrix/s:transpose-orientation",-1509811631,null);syb=new $APP.q("emmy.quaternion","multipolar","emmy.quaternion/multipolar",211546978,null);ZI=new $APP.q(null,"?","?",-62633706,null);ZG=new $APP.E(null,"auto","auto",-566279492);AU=new $APP.q(null,"B","B",218028147,null);BU=new $APP.q(null,"A","A",-48410867,null);eH=new $APP.q(null,"D","D",1632515634,null);
ER=new $APP.E(null,"function","function",-2127255473);UR=new $APP.q(null,"C","C",1466901940,null);CU=new $APP.q(null,"F","F",524988269,null);$APP.DU=new $APP.q(null,"H","H",702383200,null);tyb=new $APP.q(null,"G","G",901987130,null);uyb=new $APP.q("cljs.core","number?","cljs.core/number?",-811857295,null);vyb=new $APP.q(null,"J","J",-1259700941,null);EU=new $APP.q(null,"I","I",-827294806,null);$APP.FU=new $APP.q(null,"L","L",602224008,null);GU=new $APP.q(null,"K","K",1641243268,null);
HU=new $APP.q(null,"M","M",-115210679,null);wyb=new $APP.q(null,"P","P",-985522478,null);$APP.IU=new $APP.q(null,"R","R",703869004,null);xyb=new $APP.q(null,"Q","Q",-1991115249,null);JU=new $APP.q(null,"T","T",1815772404,null);KU=new $APP.q(null,"V","V",471247521,null);yyb=new $APP.q(null,"U","U",-1292433725,null);QN=new $APP.q(null,"X","X",-948439456,null);zyb=new $APP.q(null,"\x3d\x3e","\x3d\x3e",-813269641,null);Ayb=new $APP.E(null,"convergence-fn","convergence-fn",-157362513);
Byb=new $APP.q(null,"meta57411","meta57411",1452211331,null);gQ=new $APP.E(null,"apply","apply",1320385493);Cyb=new $APP.q("emmy.matrix","-\x3estructure","emmy.matrix/-\x3estructure",-2126763600,null);Dyb=new $APP.q(null,"quotify-coordinate-prototype","quotify-coordinate-prototype",-1299623498,null);Eyb=new $APP.q("emmy.dual","derivative","emmy.dual/derivative",-946247194,null);MRa=new $APP.E(null,"spec-skip-macros","spec-skip-macros",-645015958);
Fyb=new $APP.q("emmy.series","partial-sums","emmy.series/partial-sums",-903419413,null);P6a=new $APP.E(null,"hint","hint",439639918);Gyb=new $APP.q(null,"forward-difference","forward-difference",2142904194,null);Hyb=new $APP.q("emmy.pattern.rule","pass","emmy.pattern.rule/pass",242412252,null);Iyb=new $APP.q(null,"id-\x3epartial","id-\x3epartial",-1276946428,null);Jyb=new $APP.q(null,"k-and-deriv","k-and-deriv",948345568,null);
LU=new $APP.E("emmy.quaternion","quaternion","emmy.quaternion/quaternion",1038626106);Kyb=new $APP.q(null,"meta57400","meta57400",1948548895,null);$APP.VP=new $APP.q(null,"z","z",851004344,null);$APP.UP=new $APP.q(null,"y","y",-117328249,null);$APP.MU=new $APP.E(null,"state","state",-1988618099);Lyb=new $APP.q(null,"iterated-top-down","iterated-top-down",-601519396,null);Myb=new $APP.q(null,"Lagrange-equations","Lagrange-equations",-2039149866,null);
Nyb=new $APP.q("emmy.env","rotate-y-tuple","emmy.env/rotate-y-tuple",1666916204,null);Oyb=new $APP.E(null,"protocol-inline","protocol-inline",1550487556);Pyb=new $APP.q("emmy.quaternion","I-matrix","emmy.quaternion/I-matrix",110675528,null);Qyb=new $APP.q("emmy.env","momentum-tuple","emmy.env/momentum-tuple",1039623149,null);LXa=new $APP.q(null,"??","??",-1097896773,null);Ryb=new $APP.q(null,"emmy.mechanics.noether","emmy.mechanics.noether",1242600456,null);
Syb=new $APP.q("emmy.quaternion","sin","emmy.quaternion/sin",1453782949,null);NU=new $APP.q(null,"univariate?","univariate?",1606506402,null);Tyb=new $APP.q("emmy.mechanics.hamilton","L-state-\x3eH-state","emmy.mechanics.hamilton/L-state-\x3eH-state",-1541198669,null);Uyb=new $APP.q("emmy.util","failure-to-converge","emmy.util/failure-to-converge",1451892638,null);Vyb=new $APP.q("emmy.util.permute","permutation-sequence","emmy.util.permute/permutation-sequence",-95125419,null);
Wyb=new $APP.q("emmy.structure","make","emmy.structure/make",-731255583,null);JJ=new $APP.q(null,"?b","?b",1575118075,null);OU=new $APP.q(null,"?c","?c",870679775,null);Xyb=new $APP.q("emmy.calculus.map","pushforward-function","emmy.calculus.map/pushforward-function",-1570367866,null);PU=new $APP.q(null,"?d","?d",-1851543854,null);Yyb=new $APP.q(null,"?e","?e",-1194391683,null);IJ=new $APP.q(null,"?a","?a",1314302913,null);QU=new $APP.q(null,"?m","?m",896026745,null);
RU=new $APP.q(null,"?f","?f",-1121766265,null);SU=new $APP.q(null,"?u","?u",749886731,null);CJ=new $APP.q(null,"?n","?n",-2053238410,null);Zyb=new $APP.q("emmy.env","Curl","emmy.env/Curl",1780544087,null);$yb=new $APP.q("emmy.numerical.unimin.golden","phi","emmy.numerical.unimin.golden/phi",-2045044638,null);azb=new $APP.q(null,"?p","?p",-10896580,null);
bzb=new $APP.q("emmy.calculus.vector-calculus","coordinate-system-\x3eLame-coefficients","emmy.calculus.vector-calculus/coordinate-system-\x3eLame-coefficients",-1661630614,null);czb=new $APP.q("emmy.polynomial","negate","emmy.polynomial/negate",-1482358772,null);TU=new $APP.q(null,"?z","?z",711595547,null);dzb=new $APP.q(null,"seqtype","seqtype",-1127485523,null);ezb=new $APP.q("emmy.series","-\x3efunction","emmy.series/-\x3efunction",-161120223,null);
fzb=new $APP.q("emmy.env","the-ether","emmy.env/the-ether",891750124,null);EJ=new $APP.q(null,"?x","?x",-555096650,null);LJ=new $APP.q(null,"?y","?y",-1454470631,null);gzb=new $APP.q(null,"vector-\x3edown","vector-\x3edown",595456260,null);hzb=new $APP.q("emmy.polynomial","sub","emmy.polynomial/sub",1465909596,null);izb=new $APP.q(null,"Gamma-bar","Gamma-bar",941167787,null);jzb=new $APP.q(null,"predicate","predicate",-101970333,null);
kzb=new $APP.q("emmy.series","arg-scale","emmy.series/arg-scale",-2014368231,null);lzb=new $APP.q("emmy.env","iterated-map","emmy.env/iterated-map",1720527068,null);mzb=new $APP.q(null,"residue","residue",-810505434,null);nzb=new $APP.q("emmy.polynomial","identity","emmy.polynomial/identity",-1838836812,null);$APP.UU=new $APP.q(null,"initial-state","initial-state",-381085279,null);ozb=new $APP.q("emmy.matrix","fmap-indexed","emmy.matrix/fmap-indexed",1272453632,null);
pzb=new $APP.q(null,"add-object-symbols!","add-object-symbols!",1079364533,null);qzb=new $APP.q("emmy.matrix","row-matrix-\x3edown","emmy.matrix/row-matrix-\x3edown",1464939399,null);rzb=new $APP.q(null,"SR-name","SR-name",1611225963,null);sH=new $APP.q(null,"pi-over-2","pi-over-2",515246065,null);pK=new $APP.q(null,"pi-over-4","pi-over-4",1610173659,null);XQa=new $APP.E("cljs.analyzer","error","cljs.analyzer/error",-65289642);szb=new $APP.E(null,"ns*","ns*",200417856);
tzb=new $APP.q(null,"emmy.matrix","emmy.matrix",-1759018144,null);uzb=new $APP.q("emmy.env","index-types","emmy.env/index-types",1880279110,null);vzb=new $APP.q("cljs.core","reduced?","cljs.core/reduced?",-1192491371,null);wzb=new $APP.q(null,"-\x3evector","-\x3evector",-1800052761,null);xzb=new $APP.q(null,"bulirsch-stoer-sum","bulirsch-stoer-sum",-265874685,null);wVa=new $APP.E(null,"middleware","middleware",1462115504);
yzb=new $APP.q("emmy.matrix","identity-like","emmy.matrix/identity-like",519402553,null);zzb=new $APP.q("emmy.generic","sinhc","emmy.generic/sinhc",-980285987,null);Azb=new $APP.q(null,"rotate-y-tuple","rotate-y-tuple",620058393,null);Bzb=new $APP.q("emmy.calculus.form-field","differential-of-function","emmy.calculus.form-field/differential-of-function",-1262843004,null);VU=new $APP.q(null,"basis","basis",-788616430,null);zQa=new $APP.E(null,"in-loop","in-loop",-187298246);
SQa=new $APP.E(null,"record","record",-779106859);Czb=new $APP.q(null,"failure-to-converge","failure-to-converge",1638576378,null);Dzb=new $APP.q(null,"new-tag","new-tag",-624938805,null);Ezb=new $APP.q("emmy.rational-function","-\x3et_emmy$rational_function49062","emmy.rational-function/-\x3et_emmy$rational_function49062",-810295408,null);Fzb=new $APP.q("emmy.calculus.vector-calculus","Lap","emmy.calculus.vector-calculus/Lap",-99502815,null);Gzb=new $APP.E(null,"one?","one?",146571376);
Hzb=new $APP.q("emmy.util.aggregate","*cutoff*","emmy.util.aggregate/*cutoff*",-1972074086,null);Izb=new $APP.q(null,"Dt","Dt",389881669,null);Jzb=new $APP.q(null,"sum?","sum?",1995120931,null);Kzb=new $APP.q("emmy.series","one","emmy.series/one",1613843016,null);Lzb=new $APP.q("emmy.env","Legendre-transform","emmy.env/Legendre-transform",1127756050,null);Mzb=new $APP.q("emmy.env","kind","emmy.env/kind",1218716427,null);Nzb=new $APP.q(null,"signature","signature",-1190680975,null);
Ozb=new $APP.q(null,"emmy.calculus.basis","emmy.calculus.basis",-706999681,null);Pzb=new $APP.q("emmy.util.stream","seq-limit","emmy.util.stream/seq-limit",1461539925,null);Qzb=new $APP.q(null,"GM","GM",1363569210,null);Rzb=new $APP.q(null,"compute-expt","compute-expt",927241808,null);Szb=new $APP.q(null,"velocity-tuple","velocity-tuple",1387588589,null);Tzb=new $APP.q(null,"monic?","monic?",-269964245,null);Uzb=new $APP.q(null,"D-phase-space","D-phase-space",1736774239,null);
Vzb=new $APP.q("emmy.generic","square","emmy.generic/square",-294101765,null);WU=new $APP.q(null,"n-dof","n-dof",148884184,null);Wzb=new $APP.q("emmy.env","exact-divide","emmy.env/exact-divide",-1933094893,null);Xzb=new $APP.q("emmy.quaternion","tanh","emmy.quaternion/tanh",1285599501,null);Yzb=new $APP.q("emmy.calculus.vector-field","literal-vector-field","emmy.calculus.vector-field/literal-vector-field",656282349,null);n4a=new $APP.q(null,"chunkIteratorSeq","chunkIteratorSeq",1822959135,null);
Zzb=new $APP.q(null,"separatev","separatev",-1127561069,null);$zb=new $APP.E(null,"choose","choose",1680203305);aAb=new $APP.q(null,"Euler-angles","Euler-angles",-1077969924,null);bAb=new $APP.q("emmy.calculus.manifold","make-manifold","emmy.calculus.manifold/make-manifold",-1747513101,null);cAb=new $APP.q("emmy.rational-function","cube","emmy.rational-function/cube",1011771736,null);dAb=new $APP.q(null,"generalized-LE","generalized-LE",-1073642743,null);
eAb=new $APP.q(null,"*clock*","*clock*",876103715,null);fAb=new $APP.q("emmy.sr.frames","base-frame-chart","emmy.sr.frames/base-frame-chart",-2079801159,null);gAb=new $APP.q("emmy.structure","up*","emmy.structure/up*",-1398422306,null);hAb=new $APP.q("emmy.mechanics.lagrange","polar-\x3erectangular","emmy.mechanics.lagrange/polar-\x3erectangular",-1966599516,null);iAb=new $APP.q(null,"rigid-sysder","rigid-sysder",1244192073,null);
jAb=new $APP.q("emmy.special.factorial","pochhammer","emmy.special.factorial/pochhammer",-215994613,null);kAb=new $APP.q(null,"odd-positive-integer?","odd-positive-integer?",-1115599027,null);lAb=new $APP.q(null,"wildcard?","wildcard?",954487426,null);mAb=new $APP.E(null,"set!","set!",-1389817006);nAb=new $APP.q(null,"zeta1","zeta1",-475321608,null);oAb=new $APP.q(null,"zeta2","zeta2",-1365055378,null);pAb=new $APP.q(null,"new-variables","new-variables",-1065568929,null);
XU=new $APP.q(null,"orientation-function","orientation-function",-1851559379,null);UK=new $APP.E("emmy.structure","up","emmy.structure/up",790281384);qAb=new $APP.q(null,"antisymmetric?","antisymmetric?",-335784736,null);rAb=new $APP.q(null,"typical-point","typical-point",-1087714491,null);sAb=new $APP.q("emmy.calculus.manifold","the-real-line","emmy.calculus.manifold/the-real-line",-655174890,null);tAb=new $APP.E(null,"alternate-patch","alternate-patch",1191317178);
uAb=new $APP.q("emmy.structure","up?","emmy.structure/up?",612771628,null);gVa=new $APP.E(null,"arg-\x3estr-fn","arg-\x3estr-fn",2064845310);vAb=new $APP.q("emmy.series","-\x3eSeries","emmy.series/-\x3eSeries",647407986,null);wAb=new $APP.q(null,"*log-assumptions?*","*log-assumptions?*",-1003046769,null);xAb=new $APP.q(null,"*half-angle-simplify?*","*half-angle-simplify?*",-451115374,null);yAb=new $APP.q(null,"integral","integral",182791804,null);
zAb=new $APP.q("emmy.dual","fresh-tag","emmy.dual/fresh-tag",1242274252,null);YU=new $APP.q(null,"H-state","H-state",766610049,null);AAb=new $APP.q("emmy.calculus.covariant","Cartan?","emmy.calculus.covariant/Cartan?",-230051397,null);$APP.ZU=new $APP.q(null,"epsilon","epsilon",910372957,null);BAb=new $APP.q("emmy.expression","print-expression","emmy.expression/print-expression",-1227922809,null);CAb=new $APP.q(null,"Lagrangian-\x3epower-loss","Lagrangian-\x3epower-loss",557159409,null);
LVa=new $APP.E(null,"appender","appender",1267426510);DAb=new $APP.q("emmy.env","phi","emmy.env/phi",-932588012,null);tOa=new $APP.E("clojure.error","column","clojure.error/column",304721553);EAb=new $APP.q(null,"richardson-sum","richardson-sum",296554660,null);FAb=new $APP.q(null,"same","same",-1566530708,null);GAb=new $APP.q(null,"two-tensor-\x3e","two-tensor-\x3e",-2025001390,null);$U=new $APP.q(null,"mul","mul",1285905465,null);
HAb=new $APP.q(null,"vector-inner-product","vector-inner-product",-1766536674,null);IAb=new $APP.q(null,"*careful-conversion*","*careful-conversion*",375806734,null);JAb=new $APP.q(null,"i:contract","i:contract",-1495221968,null);KAb=new $APP.q("emmy.calculus.hodge-star","orthonormalize","emmy.calculus.hodge-star/orthonormalize",357550725,null);TOa=new $APP.q(null,"cljs.core$macros","cljs.core$macros",-2057787548,null);
LAb=new $APP.q("emmy.calculus.map","differential-of-map","emmy.calculus.map/differential-of-map",355752483,null);MAb=new $APP.q(null,"inv-phi2","inv-phi2",-1861820731,null);aV=new $APP.E("emmy.matrix","column-matrix","emmy.matrix/column-matrix",91926350);bPa=new $APP.q(null,"Number","Number",-508146185,null);NAb=new $APP.q("emmy.env","S1-tilted","emmy.env/S1-tilted",-1115919706,null);OAb=new $APP.q(null,"vector-field-\x3eoneform-field","vector-field-\x3eoneform-field",207224065,null);
PAb=new $APP.E(null,"recur-frames","recur-frames",-307205196);QAb=new $APP.q("emmy.sr.boost","proper-space-interval","emmy.sr.boost/proper-space-interval",938798978,null);RAb=new $APP.q("emmy.dual","-\x3eDual","emmy.dual/-\x3eDual",-228949002,null);SAb=new $APP.q("emmy.mechanics.routhian","Lagrangian-\x3eRouthian","emmy.mechanics.routhian/Lagrangian-\x3eRouthian",1200637098,null);TAb=new $APP.q("emmy.polynomial","partial-derivative","emmy.polynomial/partial-derivative",1043846527,null);
UAb=new $APP.q("emmy.pattern.syntax","binding?","emmy.pattern.syntax/binding?",1417270726,null);VAb=new $APP.q("emmy.quaternion","unit?","emmy.quaternion/unit?",1607527633,null);WAb=new $APP.q(null,"*sqrt-factor-simplify?*","*sqrt-factor-simplify?*",-1142636069,null);JZa=new $APP.E(null,"inner-size","inner-size",755766819);XAb=new $APP.q("emmy.env","exp10","emmy.env/exp10",126313462,null);YAb=new $APP.q(null,"symmetrize-Cartan","symmetrize-Cartan",1090588998,null);
ZAb=new $APP.q("emmy.mechanics.lagrange","coordinate","emmy.mechanics.lagrange/coordinate",-95160614,null);cab=new $APP.E(null,"observe","observe",-86651450);$Ab=new $APP.q("emmy.polynomial","arg-scale","emmy.polynomial/arg-scale",-1629149708,null);aBb=new $APP.q(null,"product","product",-1290961512,null);bBb=new $APP.q(null,"typed-\x3eindexed","typed-\x3eindexed",-1302095155,null);bV=new $APP.E("emmy.series","power-series","emmy.series/power-series",58712418);
cBb=new $APP.q("emmy.env","matrix-by-rows","emmy.env/matrix-by-rows",291838052,null);dBb=new $APP.q("emmy.polynomial","-\x3et_emmy$polynomial48683","emmy.polynomial/-\x3et_emmy$polynomial48683",-226892997,null);$APP.cV=new $APP.E(null,"simplify?","simplify?",78948489);eBb=new $APP.q(null,"-\x3ecomplex-matrix","-\x3ecomplex-matrix",37544878,null);fBb=new $APP.q(null,"emmy.pattern.syntax","emmy.pattern.syntax",-1313247869,null);gBb=new $APP.q("emmy.env","Rx","emmy.env/Rx",1536411124,null);
hBb=new $APP.q("emmy.env","Ry","emmy.env/Ry",1208139709,null);iBb=new $APP.q("emmy.env","Rz","emmy.env/Rz",-937607197,null);dV=new $APP.q(null,"name-format","name-format",-680058666,null);jBb=new $APP.q("emmy.function","arity","emmy.function/arity",-956876334,null);kBb=new $APP.q(null,"xi-\x3erectangular","xi-\x3erectangular",-1801725668,null);lBb=new $APP.q(null,"modified-bulirsch-stoer-fold","modified-bulirsch-stoer-fold",258037031,null);
mBb=new $APP.q("emmy.env","Sn","emmy.env/Sn",-1339874990,null);nBb=new $APP.q(null,"literal-matrix","literal-matrix",-1009819945,null);oBb=new $APP.q("emmy.matrix","trace","emmy.matrix/trace",1707194077,null);eV=new $APP.q(null,"vector-field?","vector-field?",921525260,null);gRa=new $APP.E(null,"object","object",1474613949);pBb=new $APP.q("emmy.env","S1","emmy.env/S1",-83658691,null);qBb=new $APP.q(null,"goog","goog",-70603925,null);rBb=new $APP.q("emmy.env","S2","emmy.env/S2",-1763638788,null);
sBb=new $APP.q("emmy.env","S3","emmy.env/S3",801890805,null);fV=new $APP.q(null,"equation","equation",1141003782,null);tBb=new $APP.q(null,"prepare","prepare",190876862,null);uBb=new $APP.q("emmy.env","Rn","emmy.env/Rn",-1218329601,null);yQ=new $APP.E(null,"argv","argv",-1462790895);vBb=new $APP.q(null,"with-limited-time","with-limited-time",-417273310,null);wBb=new $APP.q("emmy.numerical.derivative","valid-methods","emmy.numerical.derivative/valid-methods",-551119034,null);
xBb=new $APP.q(null,"initializer","initializer",-427835229,null);yBb=new $APP.q(null,"modified-neville","modified-neville",-477401254,null);zBb=new $APP.q(null,"Lap","Lap",25592799,null);ABb=new $APP.q(null,"symgen","symgen",-880919559,null);BBb=new $APP.q("emmy.env","R1","emmy.env/R1",-1648827283,null);CBb=new $APP.q("emmy.env","R2","emmy.env/R2",1168883436,null);DBb=new $APP.q("emmy.env","expt","emmy.env/expt",-1338987834,null);EBb=new $APP.q("emmy.env","R3","emmy.env/R3",1026886895,null);
FBb=new $APP.q("emmy.env","R4","emmy.env/R4",251272595,null);kF=new $APP.E(null,"argc","argc",-1452839519);GBb=new $APP.q("emmy.operator","arity","emmy.operator/arity",915557534,null);HBb=new $APP.q(null,"trace2down","trace2down",1832753626,null);IBb=new $APP.E(null,"defined","defined",-1805032318);JBb=new $APP.q("cljs.core","false?","cljs.core/false?",-1660815306,null);KBb=new $APP.q("emmy.series","atanh-series","emmy.series/atanh-series",77583755,null);oUa=new $APP.E(null,"cache?","cache?",-1601953949);
LBb=new $APP.q("emmy.algebra.fold","generic-sum-fold","emmy.algebra.fold/generic-sum-fold",1281400173,null);MBb=new $APP.q("emmy.special.factorial","double-factorial","emmy.special.factorial/double-factorial",-2108419303,null);NBb=new $APP.q(null,"roll","roll",1651798526,null);OBb=new $APP.q("emmy.generic","tan","emmy.generic/tan",-645967061,null);PBb=new $APP.q("emmy.abstract.number","literal-number?","emmy.abstract.number/literal-number?",-1703736780,null);
QBb=new $APP.q("emmy.sr.frames","v:c","emmy.sr.frames/v:c",312665889,null);RBb=new $APP.q("emmy.algebra.fold","join","emmy.algebra.fold/join",1937122726,null);SBb=new $APP.q(null,"from-power-series","from-power-series",1871650538,null);W6a=new $APP.E(null,"render-primitive","render-primitive",-529994613);TBb=new $APP.q(null,"goog.array","goog.array",-671977860,null);UBb=new $APP.q("cljs.core","seq?","cljs.core/seq?",-1302056292,null);VBb=new $APP.q("emmy.env","exp2","emmy.env/exp2",1817881551,null);
ARa=new $APP.E(null,"fn-deprecated","fn-deprecated",626877647);WBb=new $APP.q("Math","sinh","Math/sinh",-996945022,null);XBb=new $APP.q("emmy.mechanics.lagrange","L-free-particle","emmy.mechanics.lagrange/L-free-particle",-1574475160,null);kVa=new $APP.E(null,"?ns-str","?ns-str",2012733966);YBb=new $APP.q("emmy.util.permute","permute","emmy.util.permute/permute",-18883492,null);gV=new $APP.E(null,"rectangular","rectangular",193204560);
ZBb=new $APP.q(null,"make-manifold-family","make-manifold-family",391146328,null);$Bb=new $APP.q("emmy.expression","literal-apply","emmy.expression/literal-apply",-1112935907,null);aCb=new $APP.q("emmy.util","biginttype","emmy.util/biginttype",962719325,null);bCb=new $APP.E("emmy.numerical.quadrature.common","open","emmy.numerical.quadrature.common/open",-708131519);cCb=new $APP.q(null,"-\x3eTeX","-\x3eTeX",-682969935,null);yE=new $APP.E(null,"ret-tag","ret-tag",1705919990);
dCb=new $APP.q(null,"unsupported","unsupported",594924511,null);eCb=new $APP.q("emmy.quaternion","cylindrospherical","emmy.quaternion/cylindrospherical",87659266,null);fCb=new $APP.q("emmy.calculus.metric","components-\x3emetric","emmy.calculus.metric/components-\x3emetric",-1601440343,null);gCb=new $APP.q(null,"eq-fn","eq-fn",923311547,null);hCb=new $APP.q(null,"map-\x3eCompleted","map-\x3eCompleted",1367547234,null);
iCb=new $APP.q("emmy.calculus.manifold","get-patch","emmy.calculus.manifold/get-patch",817155090,null);jCb=new $APP.q("cljs.core","simple-symbol?","cljs.core/simple-symbol?",-1951205629,null);kCb=new $APP.q("emmy.mechanics.hamilton","Phi","emmy.mechanics.hamilton/Phi",1634621403,null);lCb=new $APP.q("emmy.env","momentum","emmy.env/momentum",1413332238,null);mCb=new $APP.q(null,"kahan-babushka-klein","kahan-babushka-klein",-1129341992,null);
nCb=new $APP.q(null,"pushforward-vector","pushforward-vector",-2017628021,null);oCb=new $APP.q("emmy.mechanics.hamilton","qp-\x3eH-state-path","emmy.mechanics.hamilton/qp-\x3eH-state-path",-1353119773,null);pCb=new $APP.q(null,"using-coordinates","using-coordinates",672518652,null);qCb=new $APP.q(null,"alternate-angles","alternate-angles",-469789615,null);rCb=new $APP.q("emmy.matrix","characteristic-polynomial","emmy.matrix/characteristic-polynomial",1037731882,null);
sCb=new $APP.E("emmy.matrix","down","emmy.matrix/down",-1773528537);tCb=new $APP.q("emmy.util.def","careful-def","emmy.util.def/careful-def",698573189,null);uCb=new $APP.q(null,"evaluate","evaluate",-1129217332,null);vCb=new $APP.q(null,"binomial-coefficient","binomial-coefficient",-1900165027,null);wCb=new $APP.q("emmy.generic","acsc","emmy.generic/acsc",-675575907,null);RWa=new $APP.E(null,"reverse?","reverse?",-1672868474);xCb=new $APP.q(null,"initial-p","initial-p",159948069,null);
yCb=new $APP.q(null,"compatible-shape","compatible-shape",2037767671,null);hV=new $APP.q(null,"emmy.simplify","emmy.simplify",-490367714,null);iV=new $APP.q("cljs.core","IPrintWithWriter","cljs.core/IPrintWithWriter",1349251417,null);zCb=new $APP.q(null,"symplectic-matrix?","symplectic-matrix?",-2132491360,null);ACb=new $APP.q(null,"vector:generate","vector:generate",1316333380,null);jV=new $APP.q(null,"imag-part","imag-part",2028041294,null);
BCb=new $APP.q("emmy.calculus.indexed","index-types","emmy.calculus.indexed/index-types",-1606152014,null);CCb=new $APP.q(null,"Legendre-transform","Legendre-transform",77490623,null);DCb=new $APP.q("emmy.env","typed-\x3estructure","emmy.env/typed-\x3estructure",-1599751679,null);ECb=new $APP.q(null,"pushforward-function","pushforward-function",-2125705580,null);FCb=new $APP.q(null,"restricted?","restricted?",645416471,null);kV=new $APP.E(null,"structure","structure",1563832083);
GCb=new $APP.q("emmy.mechanics.lagrange","L-axisymmetric-top","emmy.mechanics.lagrange/L-axisymmetric-top",-1196620965,null);HCb=new $APP.E(null,"denominator","denominator",-804365096);ICb=new $APP.q(null,"ONE-tensor","ONE-tensor",-1496343602,null);JCb=new $APP.q(null,"compute-sqrt","compute-sqrt",-2067318931,null);KCb=new $APP.q(null,"emmy.env","emmy.env",-2036137056,null);LCb=new $APP.q(null,"sin-series","sin-series",-1391412354,null);
MCb=new $APP.q("emmy.quaternion","from-rotation-matrix","emmy.quaternion/from-rotation-matrix",-916087243,null);NCb=new $APP.q("emmy.rational-function.interpolate","modified-bulirsch-stoer-sum","emmy.rational-function.interpolate/modified-bulirsch-stoer-sum",-1017577760,null);OCb=new $APP.q(null,"up-of-downs?","up-of-downs?",43706581,null);PCb=new $APP.q(null,"row-matrix","row-matrix",-2005619498,null);lV=new $APP.q(null,"M-of-q","M-of-q",868515731,null);
QCb=new $APP.q(null,"taylor-series","taylor-series",1018004082,null);h4a=new $APP.q("cljs.core","-indexOf","cljs.core/-indexOf",-1914846785,null);RCb=new $APP.q(null,"polar-canonical-inverse","polar-canonical-inverse",-746066399,null);SCb=new $APP.q(null,"biginttype","biginttype",671497401,null);TCb=new $APP.q("emmy.series","catalan-series","emmy.series/catalan-series",1625824348,null);UCb=new $APP.q("emmy.pattern.match","as-segment-matcher","emmy.pattern.match/as-segment-matcher",452996137,null);
VCb=new $APP.q(null,"make-basis","make-basis",-507384846,null);WCb=new $APP.q(null,"coordinate-system-\x3eoneform-basis","coordinate-system-\x3eoneform-basis",1426882309,null);XCb=new $APP.q("emmy.generic","acos","emmy.generic/acos",568902022,null);YCb=new $APP.q("emmy.env","oneform-field-\x3ebasis-components","emmy.env/oneform-field-\x3ebasis-components",-571671434,null);ZCb=new $APP.q("Math","log","Math/log",46490779,null);
$Cb=new $APP.q("emmy.numerical.derivative","central-difference","emmy.numerical.derivative/central-difference",-178793090,null);aDb=new $APP.q(null,"emmy.calculus.metric","emmy.calculus.metric",-636969725,null);bDb=new $APP.q("emmy.generic","acot","emmy.generic/acot",-1652695882,null);cDb=new $APP.q("emmy.quaternion","expt","emmy.quaternion/expt",-1365932191,null);dDb=new $APP.q(null,"momentum","momentum",-1755355427,null);
eDb=new $APP.q("emmy.calculus.manifold","S2-spherical","emmy.calculus.manifold/S2-spherical",882058390,null);fDb=new $APP.q(null,"brent-min","brent-min",477201418,null);gDb=new $APP.q("emmy.polynomial","coeff?","emmy.polynomial/coeff?",950343704,null);hDb=new $APP.q(null,"-\x3eOperator","-\x3eOperator",2055658388,null);iDb=new $APP.q(null,"solve-linear-right","solve-linear-right",-1518292405,null);jDb=new $APP.q(null,"zeno","zeno",141272922,null);
kDb=new $APP.q(null,"joint-arity","joint-arity",632178222,null);lDb=new $APP.E(null,"out","out",-910545517);mDb=new $APP.q("emmy.polynomial.richardson","richardson-scan","emmy.polynomial.richardson/richardson-scan",95595215,null);V7a=new $APP.E(null,"valid-mode","valid-mode",1171609710);nDb=new $APP.q("emmy.env","series:sum","emmy.env/series:sum",-546636796,null);oDb=new $APP.q("emmy.env","expression-of","emmy.env/expression-of",769545669,null);
pDb=new $APP.q(null,"spacetime-sphere","spacetime-sphere",-189162513,null);qDb=new $APP.q("emmy.env","m:generate","emmy.env/m:generate",-1863391968,null);rDb=new $APP.q("emmy.quaternion","get-r","emmy.quaternion/get-r",-1374344294,null);sDb=new $APP.q("emmy.quaternion","get-i","emmy.quaternion/get-i",-1036525517,null);tDb=new $APP.q("emmy.quaternion","get-j","emmy.quaternion/get-j",930199151,null);uDb=new $APP.q("emmy.quaternion","get-k","emmy.quaternion/get-k",-440295452,null);
vDb=new $APP.q("emmy.generic","identity?","emmy.generic/identity?",-1656175880,null);mV=new $APP.E("emmy.matrix","matrix","emmy.matrix/matrix",-253656831);wDb=new $APP.q(null,"coerce-to-fn","coerce-to-fn",2129768019,null);nV=new $APP.q(null,"original-list","original-list",1772023851,null);xDb=new $APP.q("emmy.env","d","emmy.env/d",-1808310296,null);yDb=new $APP.q(null,"xpow","xpow",-133471806,null);zDb=new $APP.q("emmy.polynomial","univariate?","emmy.polynomial/univariate?",259891412,null);
ADb=new $APP.q(null,"emmy.calculus.coordinate","emmy.calculus.coordinate",-1739399929,null);BDb=new $APP.q("emmy.mechanics.lagrange","osculating-path","emmy.mechanics.lagrange/osculating-path",-883100340,null);ZE=new $APP.E("cljs.analyzer","expr","cljs.analyzer/expr",1708655889);oV=new $APP.q(null,"factors","factors",-1546618389,null);CDb=new $APP.q("emmy.mechanics.lagrange","state-\x3eq","emmy.mechanics.lagrange/state-\x3eq",-1487288291,null);
DDb=new $APP.q("emmy.env","arg-shift","emmy.env/arg-shift",885884926,null);EDb=new $APP.q("emmy.mechanics.lagrange","state-\x3et","emmy.mechanics.lagrange/state-\x3et",-1182493984,null);FDb=new $APP.q("emmy.polynomial","coefficients","emmy.polynomial/coefficients",470957039,null);GDb=new $APP.q(null,"-\x3ecomplex-pair","-\x3ecomplex-pair",-769128571,null);HDb=new $APP.q(null,"cartesian-product","cartesian-product",1232721737,null);IDb=new $APP.E(null,"equation","equation",-499527745);
JDb=new $APP.q("emmy.env","literal-matrix","emmy.env/literal-matrix",2692794,null);KDb=new $APP.q("emmy.structure","transpose","emmy.structure/transpose",-2044556138,null);LDb=new $APP.q(null,"zero","zero",781566951,null);MDb=new $APP.q("emmy.structure","sumr","emmy.structure/sumr",-706557164,null);NDb=new $APP.q(null,"angles-path","angles-path",1169157124,null);ODb=new $APP.q("emmy.generic","partial-derivative","emmy.generic/partial-derivative",-620815744,null);
PDb=new $APP.q("emmy.structure","structure-\x3eprototype","emmy.structure/structure-\x3eprototype",-157823404,null);QDb=new $APP.q("emmy.calculus.covariant","symmetrize-Christoffel","emmy.calculus.covariant/symmetrize-Christoffel",514310538,null);RDb=new $APP.q("emmy.generic","cos","emmy.generic/cos",-47395634,null);SDb=new $APP.q("emmy.generic","cot","emmy.generic/cot",1929307087,null);TDb=new $APP.q(null,"*cutoff*","*cutoff*",-768308169,null);
UDb=new $APP.q(null,"opposite-orientation","opposite-orientation",-1960888039,null);LTa=new $APP.q("java.lang.Math","abs","java.lang.Math/abs",1272698622,null);VDb=new $APP.q(null,"Grad","Grad",-1533675656,null);WDb=new $APP.q("emmy.simplify.rules","angular-parity","emmy.simplify.rules/angular-parity",726527978,null);XDb=new $APP.q("emmy.matrix","column-matrix-\x3evector","emmy.matrix/column-matrix-\x3evector",951550476,null);YDb=new $APP.q(null,"make-path","make-path",-72172791,null);
ZDb=new $APP.q(null,"literal-Lagrangian-state","literal-Lagrangian-state",206160578,null);$Db=new $APP.E(null,"msecs","msecs",1711980553);pV=new $APP.q(null,"outer-orientation","outer-orientation",654965214,null);aEb=new $APP.q("emmy.env","covariant-derivative","emmy.env/covariant-derivative",1221265867,null);bEb=new $APP.q("emmy.function","combine-arities","emmy.function/combine-arities",1994059382,null);cEb=new $APP.q("emmy.env","minimize","emmy.env/minimize",-613445648,null);
dEb=new $APP.q(null,"multiplicative-transpose","multiplicative-transpose",1690205494,null);eEb=new $APP.q("emmy.numsymb","dot-product","emmy.numsymb/dot-product",985201995,null);fEb=new $APP.q("cljs.core","ns-unmap","cljs.core/ns-unmap",-1559056406,null);gEb=new $APP.q(null,"idempotent","idempotent",-220060811,null);hEb=new $APP.q("emmy.polynomial","square","emmy.polynomial/square",-1045396918,null);iEb=new $APP.q("emmy.mechanics.hamilton","momenta","emmy.mechanics.hamilton/momenta",-2115048610,null);
jEb=new $APP.q(null,"Rx-matrix","Rx-matrix",547573038,null);kEb=new $APP.E(null,"declared-arglists-mismatch","declared-arglists-mismatch",-496878383);cRa=new $APP.E("cljs.analyzer","call","cljs.analyzer/call",964149800);lEb=new $APP.q("emmy.env","s-\x3er","emmy.env/s-\x3er",1538747556,null);mEb=new $APP.q(null,"get-r","get-r",-31995758,null);VO=new $APP.E("emmy.calculus.vector-field","vector-field","emmy.calculus.vector-field/vector-field",739612763);
nEb=new $APP.q(null,"rule-simplifier","rule-simplifier",-1334565675,null);oEb=new $APP.q(null,"-\x3e4x4-matrix","-\x3e4x4-matrix",-1753309744,null);pEb=new $APP.q("emmy.pattern.syntax","wildcard?","emmy.pattern.syntax/wildcard?",1314957807,null);qEb=new $APP.q(null,"brent-max","brent-max",-942668348,null);rEb=new $APP.q("emmy.rational-function","from-points","emmy.rational-function/from-points",-1082803325,null);qV=new $APP.q(null,"acosh","acosh",-2005748303,null);
sEb=new $APP.q("emmy.env","s-\x3em","emmy.env/s-\x3em",-947460291,null);tEb=new $APP.q(null,"gradient","gradient",-343377444,null);uEb=new $APP.q("cljs.core","IMapEntry","cljs.core/IMapEntry",535941300,null);vEb=new $APP.q("emmy.simplify.rules","logexp-\x3especfun","emmy.simplify.rules/logexp-\x3especfun",1039035517,null);rV=new $APP.q(null,"local","local",142764803,null);wEb=new $APP.q("emmy.env","*","emmy.env/*",1476276860,null);xEb=new $APP.q(null,"longtype","longtype",1290789410,null);
yEb=new $APP.q("emmy.matrix","two-tensor-\x3e","emmy.matrix/two-tensor-\x3e",1078531381,null);zEb=new $APP.q("emmy.env","-","emmy.env/-",-1605964347,null);AEb=new $APP.q("emmy.calculus.covariant","parallel-transport-equation","emmy.calculus.covariant/parallel-transport-equation",2112489694,null);BEb=new $APP.q("emmy.env","+","emmy.env/+",-1636773707,null);CEb=new $APP.q("emmy.env","/","emmy.env//",1834991288,null);DEb=new $APP.q(null,"get-i","get-i",841532219,null);
EEb=new $APP.q(null,"get-j","get-j",1199347047,null);FEb=new $APP.q(null,"get-k","get-k",-1782268692,null);GEb=new $APP.q("emmy.structure","fold-chain","emmy.structure/fold-chain",-1830499052,null);HEb=new $APP.q(null,"chart","chart",-1481210344,null);IEb=new $APP.E(null,"your-version","your-version",-351781765);JEb=new $APP.q("emmy.env","\x3d","emmy.env/\x3d",1680024316,null);KEb=new $APP.q("emmy.simplify.rules","*sin-cos-simplify?*","emmy.simplify.rules/*sin-cos-simplify?*",880690826,null);
LEb=new $APP.q("emmy.env","zero-like","emmy.env/zero-like",256583262,null);MEb=new $APP.q(null,"acoth","acoth",1639672811,null);NEb=new $APP.q("emmy.env","D-forward","emmy.env/D-forward",1009314329,null);OEb=new $APP.q("emmy.env","D","emmy.env/D",-1574044025,null);PEb=new $APP.q("emmy.env","I","emmy.env/I",1291135,null);QEb=new $APP.q("emmy.env","rotate-z-matrix","emmy.env/rotate-z-matrix",-1166870351,null);
REb=new $APP.q("emmy.calculus.curvature","torsion-vector","emmy.calculus.curvature/torsion-vector",-655479923,null);SEb=new $APP.q(null,"*unchecked-if*","*unchecked-if*",1542408350,null);TEb=new $APP.q("emmy.env","structure-\x3evector","emmy.env/structure-\x3evector",1597191082,null);UEb=new $APP.q("emmy.env","pushforward-vector","emmy.env/pushforward-vector",-1038153500,null);VEb=new $APP.q(null,"four-tuple-\x3ect","four-tuple-\x3ect",-1670005201,null);
WEb=new $APP.q(null,"frame-predicate","frame-predicate",-1552233927,null);XEb=new $APP.q("emmy.env","trace","emmy.env/trace",1671513221,null);YEb=new $APP.q("emmy.env","chinese-remainder","emmy.env/chinese-remainder",1070733639,null);ZEb=new $APP.q("emmy.simplify.rules","triginv","emmy.simplify.rules/triginv",565660742,null);$Eb=new $APP.q(null,"commutator","commutator",1038087209,null);
aFb=new $APP.q("emmy.polynomial.interpolate","modified-neville-scan","emmy.polynomial.interpolate/modified-neville-scan",1079675519,null);bFb=new $APP.q("emmy.generic","zero-like","emmy.generic/zero-like",643941476,null);RD=new $APP.E("cljs.analyzer","namespaces","cljs.analyzer/namespaces",-260788927);cFb=new $APP.q(null,"operator?","operator?",1708561462,null);dFb=new $APP.q("emmy.quaternion","roll","emmy.quaternion/roll",845893318,null);eFb=new $APP.q(null,"minimize","minimize",-1647687907,null);
fFb=new $APP.q(null,"coordinates","coordinates",415198859,null);gFb=new $APP.q("emmy.env","metric-\x3ecomponents","emmy.env/metric-\x3ecomponents",673896653,null);hFb=new $APP.q(null,"direction","direction",1007172132,null);wUa=new $APP.E(null,"enabled?","enabled?",-1376075057);iFb=new $APP.q("emmy.quaternion","real?","emmy.quaternion/real?",685934414,null);jFb=new $APP.q(null,"-\x3eRationalFunction","-\x3eRationalFunction",-1916100697,null);
kFb=new $APP.q("emmy.env","Hamiltonian","emmy.env/Hamiltonian",395510226,null);lFb=new $APP.E(null,"tests","tests",-1041085625);mFb=new $APP.q("emmy.env","fractional-part","emmy.env/fractional-part",-1484941681,null);nFb=new $APP.q("cljs.core","array?","cljs.core/array?",-1655912448,null);oFb=new $APP.q(null,"alt-wedge","alt-wedge",-1039108858,null);pFb=new $APP.q("emmy.env","basis-components-\x3evector-field","emmy.env/basis-components-\x3evector-field",-932310019,null);
qFb=new $APP.q("emmy.env","tanh","emmy.env/tanh",1392859752,null);rFb=new $APP.q(null,"gcd-stats","gcd-stats",-1203765846,null);sFb=new $APP.q(null,"-\x3eL-state","-\x3eL-state",1029512715,null);tFb=new $APP.q("emmy.env","tanc","emmy.env/tanc",-1921649246,null);uFb=new $APP.q("emmy.calculus.manifold","R3-cyl","emmy.calculus.manifold/R3-cyl",2008142283,null);vFb=new $APP.q(null,"p1__59122#","p1__59122#",-983782886,null);wFb=new $APP.q(null,"matrix-by-rows","matrix-by-rows",-1400856559,null);
xFb=new $APP.q(null,"factorial-power","factorial-power",-1318084454,null);yFb=new $APP.q("emmy.util","keyset","emmy.util/keyset",270836023,null);sV=new $APP.q(null,"backend","backend",793042403,null);zFb=new $APP.q("emmy.polynomial","univariate-\x3edense","emmy.polynomial/univariate-\x3edense",-2020028363,null);AFb=new $APP.q("emmy.quaternion","-\x3evector","emmy.quaternion/-\x3evector",-1532462337,null);BFb=new $APP.q("emmy.env","definite-integral","emmy.env/definite-integral",-336307266,null);
CFb=new $APP.q("emmy.env","angle","emmy.env/angle",2144718722,null);tV=new $APP.E("emmy.abstract.function","function","emmy.abstract.function/function",878668117);DFb=new $APP.q("emmy.matrix","num-cols","emmy.matrix/num-cols",1953785168,null);EFb=new $APP.q("emmy.env","gradient","emmy.env/gradient",-1389710927,null);FFb=new $APP.q(null,"print-expression","print-expression",1826868853,null);
GFb=new $APP.q("emmy.env","metric-\x3einverse-components","emmy.env/metric-\x3einverse-components",-1632880464,null);HFb=new $APP.q("emmy.calculus.covariant","covariant-derivative","emmy.calculus.covariant/covariant-derivative",-1836804793,null);IFb=new $APP.q("emmy.env","vector-field-\x3ecomponents","emmy.env/vector-field-\x3ecomponents",-678476911,null);JFb=new $APP.q(null,"S3-spherical","S3-spherical",-73265585,null);
KFb=new $APP.q("s","compatible-for-contraction?","s/compatible-for-contraction?",-50704509,null);LFb=new $APP.q("emmy.series","bell-series","emmy.series/bell-series",-715401971,null);MFb=new $APP.q("emmy.generic","csc","emmy.generic/csc",440165121,null);HD=new $APP.E(null,"children","children",-940561982);NFb=new $APP.q(null,"native-integral?","native-integral?",1972110620,null);OFb=new $APP.q("emmy.simplify.rules","not-integral?","emmy.simplify.rules/not-integral?",-1471229124,null);
PFb=new $APP.q(null,"monotonic-symbol-generator","monotonic-symbol-generator",1030677660,null);QFb=new $APP.q(null,"emmy.operator","emmy.operator",-1111337305,null);RFb=new $APP.q(null,"cuthigh","cuthigh",-1046878586,null);SFb=new $APP.E(null,"months","months",-45571637);uV=new $APP.q(null,"-\x3eexpression","-\x3eexpression",-1295460418,null);vV=new $APP.q(null,"cube","cube",138920159,null);
TFb=new $APP.q(null,"*allow-incompatible-multiplication*","*allow-incompatible-multiplication*",1994211376,null);UFb=new $APP.q("emmy.quaternion","K-tensor","emmy.quaternion/K-tensor",1466584396,null);VFb=new $APP.q(null,"guard","guard",767383716,null);WFb=new $APP.q("emmy.env","-tau","emmy.env/-tau",-1418132068,null);XFb=new $APP.q(null,"row-matrix-\x3evector","row-matrix-\x3evector",1672763573,null);YFb=new $APP.q("clojure.core","mod","clojure.core/mod",215755142,null);
ZFb=new $APP.q(null,"elliptic-k","elliptic-k",625190114,null);$Fb=new $APP.q("emmy.env","row-matrix-\x3evector","emmy.env/row-matrix-\x3evector",605163750,null);aGb=new $APP.q("emmy.polynomial.interpolate","tableau-fn","emmy.polynomial.interpolate/tableau-fn",1916732414,null);bGb=new $APP.q(null,"elliptic-e","elliptic-e",1469512221,null);cGb=new $APP.q(null,"elliptic-f","elliptic-f",2039182144,null);dGb=new $APP.q(null,"-\x3ebigint","-\x3ebigint",863817399,null);
eGb=new $APP.q("emmy.env","cross-product","emmy.env/cross-product",59748312,null);RM=new $APP.E("emmy.expression","numeric","emmy.expression/numeric",-181475924);fGb=new $APP.E(null,"overload-arity","overload-arity",823206044);gGb=new $APP.q("emmy.mechanics.rigid","qw-state-\x3eL-body","emmy.mechanics.rigid/qw-state-\x3eL-body",-2090012960,null);hGb=new $APP.q(null,"emmy.simplify.rules","emmy.simplify.rules",1791645636,null);iGb=new $APP.q("emmy.env","rotate-x","emmy.env/rotate-x",-806731691,null);
jGb=new $APP.q("emmy.env","rotate-y","emmy.env/rotate-y",-1735629286,null);kGb=new $APP.q("emmy.env","rotate-z","emmy.env/rotate-z",-948930891,null);lGb=new $APP.q(null,"make-Hamiltonian","make-Hamiltonian",1457755270,null);wV=new $APP.q(null,"family","family",327385835,null);mGb=new $APP.q(null,"emmy.special.elliptic","emmy.special.elliptic",1100074875,null);
nGb=new $APP.q("emmy.calculus.metric","coordinate-system-\x3emetric-components","emmy.calculus.metric/coordinate-system-\x3emetric-components",1577030701,null);oGb=new $APP.q("Math","trunc","Math/trunc",1386774702,null);kN=new $APP.E("emmy.tape","tape","emmy.tape/tape",-747075426);pGb=new $APP.q(null,"tex$","tex$",-1271871282,null);qGb=new $APP.q(null,"from-complex-matrix","from-complex-matrix",-334210528,null);rGb=new $APP.q(null,"multi-factorial","multi-factorial",828671797,null);
sGb=new $APP.q("emmy.sr.frames","base-frame-point","emmy.sr.frames/base-frame-point",1338863497,null);tGb=new $APP.q("emmy.env","solve-linear-right","emmy.env/solve-linear-right",2028141086,null);$APP.uGb=new $APP.q(null,"mag","mag",1689150701,null);vGb=new $APP.q(null,"point-\x3emanifold","point-\x3emanifold",937995152,null);wGb=new $APP.q(null,"fixed-point","fixed-point",266974883,null);xGb=new $APP.q(null,"*TeX-vertical-down-tuples*","*TeX-vertical-down-tuples*",-1032771622,null);
yGb=new $APP.q("emmy.env","identity?","emmy.env/identity?",-2043797294,null);zGb=new $APP.q(null,"-\x3eJavaScript","-\x3eJavaScript",-417418602,null);AGb=new $APP.q(null,"canonical-transform?","canonical-transform?",1108728387,null);BGb=new $APP.q(null,"fmap-indexed","fmap-indexed",-1932165905,null);WTa=new $APP.E(null,"version","version",425292698);CGb=new $APP.q("emmy.env","phase-space-derivative","emmy.env/phase-space-derivative",1054715770,null);
DGb=new $APP.q("emmy.util","inttype","emmy.util/inttype",-1591430550,null);EGb=new $APP.q("emmy.generic","invert","emmy.generic/invert",1772168795,null);FGb=new $APP.q(null,"failure","failure",-1934019890,null);nE=new $APP.E(null,"anonymous","anonymous",447897231);GGb=new $APP.q(null,"metric-\x3ecomponents","metric-\x3ecomponents",-280457160,null);HGb=new $APP.q("emmy.calculus.manifold","S1-circular","emmy.calculus.manifold/S1-circular",794004458,null);
IGb=new $APP.q("emmy.generic","ceiling","emmy.generic/ceiling",-1790548622,null);JGb=new $APP.q("emmy.function","get-in","emmy.function/get-in",1473231369,null);KGb=new $APP.q("emmy.expression","substitute","emmy.expression/substitute",-758415210,null);LGb=new $APP.q("emmy.env","Lie-D","emmy.env/Lie-D",-1995509146,null);MGb=new $APP.q("emmy.simplify.rules","specfun-\x3elogexp","emmy.simplify.rules/specfun-\x3elogexp",-1618126267,null);
NGb=new $APP.q("emmy.numsymb","derivative?","emmy.numsymb/derivative?",-1743154467,null);OGb=new $APP.q("emmy.mechanics.lagrange","Gamma-bar","emmy.mechanics.lagrange/Gamma-bar",1498034999,null);PGb=new $APP.q("emmy.quaternion","-\x3erotation-matrix","emmy.quaternion/-\x3erotation-matrix",1298788575,null);QGb=new $APP.q(null,"re-matches?","re-matches?",-217725652,null);RGb=new $APP.q("emmy.env","curvature-components","emmy.env/curvature-components",1901709916,null);
SGb=new $APP.q("emmy.pattern.syntax","unquote-splice?","emmy.pattern.syntax/unquote-splice?",-306783946,null);GR=new $APP.E(null,"ratio-fn","ratio-fn",1226148920);AE=new $APP.E(null,"renames","renames",343278368);TGb=new $APP.q("emmy.mechanics.lagrange","Lagrange-equations","emmy.mechanics.lagrange/Lagrange-equations",1694519930,null);UGb=new $APP.q("emmy.quaternion","cos","emmy.quaternion/cos",-110326909,null);VGb=new $APP.q(null,"sin-half-angle-formula","sin-half-angle-formula",1943828750,null);
WGb=new $APP.q("emmy.env","row-matrix-\x3edown","emmy.env/row-matrix-\x3edown",1571898431,null);XGb=new $APP.q(null,"emmy.pattern.consequence","emmy.pattern.consequence",1651562694,null);YGb=new $APP.q(null,"leading-term","leading-term",-1876467876,null);ZGb=new $APP.q("emmy.calculus.manifold","S3-spherical","emmy.calculus.manifold/S3-spherical",1021348969,null);$Gb=new $APP.q("emmy.env","make-manifold","emmy.env/make-manifold",-1724752278,null);xV=new $APP.q(null,"types","types",-2064405130,null);
yV=new $APP.E(null,"id-\x3epartial","id-\x3epartial",1377489341);aHb=new $APP.q("emmy.env","Lagrangian-\x3estate-derivative","emmy.env/Lagrangian-\x3estate-derivative",30380731,null);bHb=new $APP.q("emmy.quaternion","from-angle-normal-axis","emmy.quaternion/from-angle-normal-axis",1285560933,null);zV=new $APP.q(null,"minterms","minterms",372879357,null);D3a=new $APP.E(null,"embedding-dimension","embedding-dimension",1369585967);
cHb=new $APP.q("emmy.util.permute","number-of-combinations","emmy.util.permute/number-of-combinations",-1577246383,null);dHb=new $APP.q("emmy.env","print-expression","emmy.env/print-expression",-1459251546,null);eHb=new $APP.q("emmy.simplify.rules","*log-exp-simplify?*","emmy.simplify.rules/*log-exp-simplify?*",1665754330,null);NP=new $APP.q("emmy.structure","up","emmy.structure/up",-1864154385,null);AV=new $APP.q(null,"default-relative-threshold","default-relative-threshold",1623766986,null);
fHb=new $APP.q(null,"coords-\x3eevent","coords-\x3eevent",637740539,null);gHb=new $APP.q(null,"split-high-degree-sincos","split-high-degree-sincos",-1143884333,null);hHb=new $APP.q("emmy.env","form-field-\x3eform-field-over-map","emmy.env/form-field-\x3eform-field-over-map",-1463567997,null);iHb=new $APP.q("emmy.expression.compile","compile-fn","emmy.expression.compile/compile-fn",-685968567,null);jHb=new $APP.q(null,"keyset","keyset",2135291099,null);
kHb=new $APP.q("emmy.calculus.map","differential","emmy.calculus.map/differential",1880219356,null);lHb=new $APP.q("emmy.env","R4-rect","emmy.env/R4-rect",-1352405565,null);mHb=new $APP.q(null,"harmonic-series","harmonic-series",-909996844,null);nHb=new $APP.q("emmy.expression.render","-\x3einfix","emmy.expression.render/-\x3einfix",-7429898,null);oHb=new $APP.q(null,"list-interchanges","list-interchanges",899634747,null);sO=new $APP.E(null,"patch-templates","patch-templates",836059143);
pHb=new $APP.q("emmy.quaternion","div","emmy.quaternion/div",-255534561,null);qHb=new $APP.q(null,"denominator","denominator",836166431,null);BV=new $APP.q(null,"rows","rows",-1804386089,null);rHb=new $APP.q("cljs.core","Var","cljs.core/Var",2071014443,null);sHb=new $APP.q("emmy.mechanics.time-evolution","shift-t","emmy.mechanics.time-evolution/shift-t",-1958879854,null);tHb=new $APP.q("emmy.series","sec-series","emmy.series/sec-series",-1117861223,null);
VE=new $APP.E(null,"ns-var-clash","ns-var-clash",-280494668);m7a=new $APP.E(null,"beta","beta",455605892);uHb=new $APP.q(null,"as-segment-matcher","as-segment-matcher",1157084158,null);vHb=new $APP.q("emmy.env","seq:pprint","emmy.env/seq:pprint",1222098633,null);wHb=new $APP.q(null,"oneform-basis","oneform-basis",387946054,null);TH=new $APP.E("emmy.dual","forward","emmy.dual/forward",1374847395);X6a=new $APP.E(null,"rename-functions","rename-functions",-358633973);
xHb=new $APP.q(null,"pipe","pipe",1977107376,null);F4a=new $APP.q(null,"tensor-product","tensor-product",553408668,null);yHb=new $APP.q(null,"away-from","away-from",243379524,null);zHb=new $APP.q("emmy.generic","div","emmy.generic/div",-192474278,null);AHb=new $APP.E(null,"maxterms","maxterms",951779603);CV=new $APP.q(null,"structures","structures",1081902171,null);DV=new $APP.q(null,"row?","row?",2035501942,null);
BHb=new $APP.q("emmy.pattern.rule","succeed","emmy.pattern.rule/succeed",1594724563,null);CHb=new $APP.q("f","function?","f/function?",1729250043,null);DHb=new $APP.q(null,"row*","row*",1238605271,null);EHb=new $APP.q(null,"by-cols","by-cols",2016712726,null);FHb=new $APP.q(null,"down-\x3erow-matrix","down-\x3erow-matrix",1694498822,null);f7a=new $APP.E(null,"zero-delta","zero-delta",-2009573292);GHb=new $APP.q(null,"from-angle-axis","from-angle-axis",770100623,null);
HHb=new $APP.E(null,"reloads","reloads",610698522);IHb=new $APP.q("emmy.pattern.match","with-frame","emmy.pattern.match/with-frame",905241676,null);JHb=new $APP.q(null,"real?","real?",-118641994,null);KHb=new $APP.q("emmy.matrix","nth-col","emmy.matrix/nth-col",-748337469,null);LHb=new $APP.q(null,"match","match",-1434376219,null);MHb=new $APP.q("emmy.env","sinhc","emmy.env/sinhc",-330734025,null);NHb=new $APP.q(null,"R1-rect","R1-rect",-127853232,null);
OHb=new $APP.q(null,"structure?","structure?",-1962489375,null);PHb=new $APP.E("cljs.analyzer","protocol-inline","cljs.analyzer/protocol-inline",-1611519026);aVa=new $APP.E(null,"ns-whitelist","ns-whitelist",-1717299774);QHb=new $APP.E(null,"initializer","initializer",-2068366756);RHb=new $APP.q(null,"linear","linear",-1782167072,null);SHb=new $APP.q("emmy.env","down-\x3erow-matrix","emmy.env/down-\x3erow-matrix",-1549879215,null);
EV=new $APP.q(null,"orthonormal-basis","orthonormal-basis",735254493,null);THb=new $APP.q("emmy.expression","sort","emmy.expression/sort",-188144105,null);FV=new $APP.q(null,"lcm","lcm",-1699262564,null);UHb=new $APP.q(null,"arities","arities",-140591390,null);VHb=new $APP.q(null,"simplify-expression","simplify-expression",1167243796,null);WHb=new $APP.E(null,"preamble-missing","preamble-missing",220974801);XHb=new $APP.q(null,"map-chain","map-chain",299004316,null);
YHb=new $APP.q("emmy.env","add-velocities","emmy.env/add-velocities",273637877,null);ZHb=new $APP.q("emmy.matrix","column-matrix-\x3eup","emmy.matrix/column-matrix-\x3eup",905687444,null);$Hb=new $APP.q("emmy.structure","opposite","emmy.structure/opposite",-1762053614,null);aIb=new $APP.q("s","structure?","s/structure?",-1962489518,null);bIb=new $APP.q("emmy.sr.boost","make-four-tuple","emmy.sr.boost/make-four-tuple",1930993077,null);cIb=new $APP.q(null,"diagonal?","diagonal?",2008193921,null);
dIb=new $APP.q(null,"row-matrix-\x3edown","row-matrix-\x3edown",273914986,null);eIb=new $APP.E(null,"case-node","case-node",1016946320);fIb=new $APP.q("emmy.expression.render","*TeX-sans-serif-symbols*","emmy.expression.render/*TeX-sans-serif-symbols*",540739176,null);GV=new $APP.E(null,"spherical","spherical",556747504);HV=new $APP.q(null,"atanh","atanh",-1915750692,null);gIb=new $APP.q("emmy.util","arithmetic-ex","emmy.util/arithmetic-ex",1745810371,null);
hIb=new $APP.q("emmy.env","Dt","emmy.env/Dt",1351832822,null);IV=new $APP.q(null,"ctor","ctor",-903570967,null);iIb=new $APP.q(null,"manifold-point","manifold-point",1980743222,null);jIb=new $APP.q("emmy.calculus.manifold","S3-tilted","emmy.calculus.manifold/S3-tilted",1493212961,null);kIb=new $APP.q(null,"kinetic-energy","kinetic-energy",1014555443,null);lIb=new $APP.q(null,"asinh-series","asinh-series",1808136764,null);
mIb=new $APP.q("emmy.calculus.form-field","basis-components-\x3eoneform-field","emmy.calculus.form-field/basis-components-\x3eoneform-field",-1625831825,null);JV=new $APP.q(null,"??pre","??pre",-1767241378,null);s8a=new $APP.E(null,"roundoff-cutoff","roundoff-cutoff",1739938187);nIb=new $APP.q(null,"get-rank","get-rank",1510807712,null);oIb=new $APP.q("emmy.calculus.form-field","coordinate-basis-oneform-field","emmy.calculus.form-field/coordinate-basis-oneform-field",1698080815,null);
pIb=new $APP.q(null,"litfns","litfns",1494839179,null);qIb=new $APP.q("emmy.util.logic","assume!","emmy.util.logic/assume!",-1355379731,null);rIb=new $APP.q("emmy.polynomial.gcd","*poly-gcd-cache-enable*","emmy.polynomial.gcd/*poly-gcd-cache-enable*",-441417970,null);EP=new $APP.E(null,"forms","forms",2045992350);sIb=new $APP.q(null,"I-matrix","I-matrix",1453302592,null);DJ=new $APP.q(null,"log","log",45015523,null);tIb=new $APP.q(null,"lon","lon",-2132367332,null);
uIb=new $APP.q(null,"geodesic-equation","geodesic-equation",-872309078,null);KV=new $APP.q(null,"low","low",39169118,null);vIb=new $APP.q(null,"combinations","combinations",2103807122,null);wIb=new $APP.q(null,"abstract-types","abstract-types",-373599555,null);xIb=new $APP.q(null,"F-\x3eC","F-\x3eC",-977930553,null);yIb=new $APP.q("emmy.structure","two-up?","emmy.structure/two-up?",-391574187,null);zIb=new $APP.q("emmy.series","exp-series","emmy.series/exp-series",1727476580,null);
AIb=new $APP.q("emmy.expression.analyze","expression-simplifier","emmy.expression.analyze/expression-simplifier",1677657454,null);BIb=new $APP.q(null,"F-\x3eK","F-\x3eK",-401605312,null);CIb=new $APP.q(null,"G__46133","G__46133",-2013643511,null);DIb=new $APP.q(null,"-\x3et_emmy$polynomial48683","-\x3et_emmy$polynomial48683",603863625,null);qUa=new $APP.E(null,"blacklist","blacklist",1248093170);EIb=new $APP.q(null,"modulus","modulus",-856269542,null);
FIb=new $APP.q(null,"compatible-zero","compatible-zero",-453704180,null);GIb=new $APP.q("emmy.calculus.metric","literal-metric","emmy.calculus.metric/literal-metric",-1683421293,null);HIb=new $APP.q(null,"T-quaternion-state","T-quaternion-state",-2080111039,null);IIb=new $APP.q(null,"foreach-matcher","foreach-matcher",-233710187,null);JIb=new $APP.q("emmy.polynomial.richardson","richardson-fold","emmy.polynomial.richardson/richardson-fold",167889732,null);
KIb=new $APP.q("emmy.numerical.ode","integrate-state-derivative","emmy.numerical.ode/integrate-state-derivative",-600109311,null);LIb=new $APP.q(null,"log1+x-series","log1+x-series",-1437348439,null);MIb=new $APP.q("emmy.calculus.indexed","contract","emmy.calculus.indexed/contract",-13144785,null);NIb=new $APP.q("emmy.expression.analyze","expression-analyzer","emmy.expression.analyze/expression-analyzer",-1864556219,null);OIb=new $APP.q(null,"choice","choice",265360800,null);
PIb=new $APP.q("emmy.simplify.rules","exponent-contract","emmy.simplify.rules/exponent-contract",296323466,null);QIb=new $APP.q("emmy.structure","vector-dot-product","emmy.structure/vector-dot-product",1487712319,null);RIb=new $APP.q("emmy.rational-function","partial-derivatives","emmy.rational-function/partial-derivatives",1971985122,null);SIb=new $APP.q(null,"divergence","divergence",175362438,null);SXa=new $APP.q("cljs.core","rseq","cljs.core/rseq",-238610347,null);
TIb=new $APP.q(null,"failed?","failed?",-2114702621,null);UIb=new $APP.q("emmy.function","arg-scale","emmy.function/arg-scale",-1148030600,null);VIb=new $APP.q("emmy.env","ff:zero","emmy.env/ff:zero",1612465500,null);WIb=new $APP.q("emmy.polynomial","degree","emmy.polynomial/degree",527316293,null);XIb=new $APP.q(null,"split-polynomial","split-polynomial",-1324656555,null);YIb=new $APP.q("emmy.operator","anticommutator","emmy.operator/anticommutator",-718500646,null);
ZIb=new $APP.q("p","univariate?","p/univariate?",1606506258,null);$Ib=new $APP.q("emmy.env","proper-time-interval","emmy.env/proper-time-interval",548627690,null);aJb=new $APP.q(null,"*fold*","*fold*",95822926,null);$APP.bJb=new $APP.q(null,"stopwatch","stopwatch",-1262782731,null);cJb=new $APP.q("emmy.pattern.rule","while","emmy.pattern.rule/while",883830589,null);jPa=new $APP.E(null,"advanced","advanced",-451287892);dJb=new $APP.q("emmy.quaternion","sqrt","emmy.quaternion/sqrt",-971476234,null);
eJb=new $APP.q("emmy.algebra.fold","fold-\x3esum-fn","emmy.algebra.fold/fold-\x3esum-fn",-276179943,null);n_a=new $APP.E(null,"-\x3epoly","-\x3epoly",360305471);LV=new $APP.q(null,"nrows","nrows",-1642567020,null);fJb=new $APP.q("emmy.generic","sinh","emmy.generic/sinh",-382554945,null);gJb=new $APP.q("emmy.env","asech","emmy.env/asech",-1344784383,null);hJb=new $APP.q("emmy.mechanics.rotation","Rx-matrix","emmy.mechanics.rotation/Rx-matrix",408850487,null);
iJb=new $APP.q("emmy.generic","sinc","emmy.generic/sinc",1985312038,null);jJb=new $APP.q(null,"r-\x3ep","r-\x3ep",-80303841,null);kJb=new $APP.q("emmy.value","IReal","emmy.value/IReal",-2003912387,null);lJb=new $APP.q(null,"-\x3eH-state","-\x3eH-state",-1515806723,null);mJb=new $APP.q("emmy.calculus.manifold","spacetime","emmy.calculus.manifold/spacetime",1764407504,null);nJb=new $APP.q("emmy.generic","one?","emmy.generic/one?",1178660714,null);oJb=new $APP.q(null,"fmap","fmap",55293788,null);
pJb=new $APP.q(null,"r-\x3es","r-\x3es",779371230,null);qO=new $APP.E("emmy.calculus.manifold","manifold","emmy.calculus.manifold/manifold",-1013288811);qJb=new $APP.q("emmy.simplify.rules","half-angle","emmy.simplify.rules/half-angle",-501174445,null);rJb=new $APP.E(null,"protocol-with-variadic-method","protocol-with-variadic-method",-693368178);sJb=new $APP.q("emmy.generic","exp10","emmy.generic/exp10",811434464,null);
tJb=new $APP.q("emmy.env","Poisson-bracket","emmy.env/Poisson-bracket",-1197327411,null);uJb=new $APP.q(null,"close-enuf?","close-enuf?",-677240843,null);vJb=new $APP.q("emmy.util","compute-abs","emmy.util/compute-abs",1040305163,null);wJb=new $APP.q(null,"angular-parity","angular-parity",-340761058,null);xJb=new $APP.q("emmy.calculus.covariant","Christoffel-\x3eCartan","emmy.calculus.covariant/Christoffel-\x3eCartan",1806949234,null);
yJb=new $APP.q("emmy.pattern.rule","ruleset","emmy.pattern.rule/ruleset",-1341856137,null);zJb=new $APP.q("emmy.numerical.unimin.golden","best-of","emmy.numerical.unimin.golden/best-of",-76851582,null);AJb=new $APP.q(null,"base-frame-maker","base-frame-maker",-1120850446,null);BJb=new $APP.q("emmy.function","with-arity","emmy.function/with-arity",-1491928077,null);CJb=new $APP.q(null,"literal-oneform-field","literal-oneform-field",-502718763,null);
MV=new $APP.E("emmy.operator","co-operator","emmy.operator/co-operator",-99060495);DJb=new $APP.q("emmy.mechanics.rigid","antisymmetric-\x3ecolumn-matrix","emmy.mechanics.rigid/antisymmetric-\x3ecolumn-matrix",1177730192,null);EJb=new $APP.q("emmy.matrix","diagonal?","emmy.matrix/diagonal?",-1296565018,null);FJb=new $APP.q(null,"meta49169","meta49169",1837721213,null);B4a=new $APP.q(null,"wedge","wedge",868448626,null);UE=new $APP.E(null,"import","import",-1399500709);
s7a=new $APP.E(null,"fn-tolerance","fn-tolerance",-1445606164);GJb=new $APP.E(null,"bulirsch-stoer-open","bulirsch-stoer-open",-2130050405);HJb=new $APP.q("emmy.mechanics.lagrange","F-\x3eC","emmy.mechanics.lagrange/F-\x3eC",645967451,null);IJb=new $APP.q("emmy.matrix","s-\x3em","emmy.matrix/s-\x3em",-853133691,null);JJb=new $APP.q(null,"power-series*","power-series*",-882059100,null);KJb=new $APP.q(null,"Ricci","Ricci",1070475462,null);
LJb=new $APP.q("emmy.env","event?","emmy.env/event?",1130559928,null);NV=new $APP.q(null,"power-series?","power-series?",405041482,null);OV=new $APP.q(null,"state-derivative-args","state-derivative-args",-1910752878,null);MJb=new $APP.q(null,"Polynomial","Polynomial",2054562416,null);NJb=new $APP.q(null,"from-4x4-matrix","from-4x4-matrix",-733777051,null);OJb=new $APP.q(null,"IReal","IReal",-443860270,null);PJb=new $APP.q(null,"literal-type","literal-type",-1586719306,null);
QJb=new $APP.q("emmy.env","literal-manifold-function","emmy.env/literal-manifold-function",-2016692046,null);PV=new $APP.q(null,"Cartan","Cartan",-1256546560,null);RJb=new $APP.q(null,"S2-type","S2-type",-1290736783,null);SJb=new $APP.q("emmy.env","sharpen","emmy.env/sharpen",-1819606646,null);TJb=new $APP.q("emmy.mechanics.lagrange","L-coupled-harmonic","emmy.mechanics.lagrange/L-coupled-harmonic",445832,null);UJb=new $APP.q(null,"s-\x3er","s-\x3er",-1726668015,null);
VJb=new $APP.q("emmy.env","solve-linear-left","emmy.env/solve-linear-left",-1761402631,null);WJb=new $APP.q(null,"s-\x3em","s-\x3em",137060200,null);mUa=new $APP.E(null,"any","any",1705907423);QV=new $APP.q(null,"form-field?","form-field?",1252796196,null);XJb=new $APP.q(null,"parametric-path-action","parametric-path-action",863239064,null);YJb=new $APP.q(null,"set-compiler-mode!","set-compiler-mode!",-768746968,null);
ZJb=new $APP.q("emmy.quaternion","*angle-axis-tolerance*","emmy.quaternion/*angle-axis-tolerance*",-1483012063,null);$Jb=new $APP.q(null,"bulirsch-stoer-scan","bulirsch-stoer-scan",-1711062801,null);aKb=new $APP.q("emmy.ratio","IRational","emmy.ratio/IRational",770773424,null);bF=new $APP.q(null,"constructor","constructor",-313397284,null);bKb=new $APP.q("emmy.env","standard-map","emmy.env/standard-map",-2065875678,null);
cKb=new $APP.q("emmy.mechanics.lagrange","find-path","emmy.mechanics.lagrange/find-path",1560510233,null);dKb=new $APP.q(null,"S1-slope","S1-slope",-1191127613,null);eKb=new $APP.q(null,"s:transpose-orientation","s:transpose-orientation",1694629066,null);fKb=new $APP.q("emmy.rational-function","rational-function?","emmy.rational-function/rational-function?",864024213,null);gKb=new $APP.q(null,"partial-reverse","partial-reverse",1108129073,null);
m3a=new $APP.E(null,"coordinate-representations","coordinate-representations",-676047034);hKb=new $APP.q("emmy.mechanics.lagrange","accelerations","emmy.mechanics.lagrange/accelerations",-88277009,null);rRa=new $APP.E(null,"invalid-arithmetic","invalid-arithmetic",1917075065);dUa=new $APP.E(null,"req-id-fn","req-id-fn",-1580886496);iKb=new $APP.q(null,"pochhammer","pochhammer",-1887028579,null);jKb=new $APP.q("emmy.algebra.fold","kbn","emmy.algebra.fold/kbn",-2000775869,null);
kKb=new $APP.q("Math","atan","Math/atan",-1027632159,null);MVa=new $APP.E(null,"timestamp_","timestamp_",-954533417);lKb=new $APP.q("emmy.mechanics.lagrange","r-\x3es","emmy.mechanics.lagrange/r-\x3es",-819500230,null);mKb=new $APP.q("emmy.calculus.manifold","literal-manifold-function","emmy.calculus.manifold/literal-manifold-function",-261697989,null);nKb=new $APP.q("emmy.mechanics.lagrange","r-\x3ep","emmy.mechanics.lagrange/r-\x3ep",1510064507,null);
oKb=new $APP.q(null,"*active-tags*","*active-tags*",-1386974245,null);pKb=new $APP.q(null,"typical-object","typical-object",-699041232,null);qKb=new $APP.q("emmy.env","constant-series","emmy.env/constant-series",918263055,null);rKb=new $APP.q("emmy.util","illegal-state","emmy.util/illegal-state",1880242933,null);sKb=new $APP.q(null,"backward-difference","backward-difference",-700667341,null);tKb=new $APP.q(null,"embedded","embedded",1525045279,null);
RV=new $APP.q(null,"make-rectangular","make-rectangular",-1494662174,null);SV=new $APP.q(null,"success-pattern","success-pattern",-1825317762,null);uKb=new $APP.q("Math","sin","Math/sin",1723896309,null);vKb=new $APP.q("emmy.polynomial","raise-arity","emmy.polynomial/raise-arity",91943693,null);EQ=new $APP.E(null,"terms-checked","terms-checked",1046419519);wKb=new $APP.q("emmy.quaternion","cross-product","emmy.quaternion/cross-product",-48968835,null);
xKb=new $APP.q("emmy.mechanics.rigid","L-space-Euler","emmy.mechanics.rigid/L-space-Euler",962470983,null);fF=new $APP.E(null,"js-op","js-op",-1046277897);yKb=new $APP.q(null,"Routhian-state-\x3eLagrangian-state","Routhian-state-\x3eLagrangian-state",1553598135,null);zKb=new $APP.q(null,"??terms","??terms",1737460425,null);AKb=new $APP.q(null,"ff:zero","ff:zero",628755951,null);m5a=new $APP.q(null,"pullback","pullback",-1132207426,null);BKb=new $APP.q(null,"K-matrix","K-matrix",-1333593383,null);
CKb=new $APP.q("emmy.matrix","literal-column-matrix","emmy.matrix/literal-column-matrix",-255899035,null);DKb=new $APP.q("emmy.env","basis-\x3ebasis-over-map","emmy.env/basis-\x3ebasis-over-map",268469906,null);EKb=new $APP.q(null,"i:outer-product","i:outer-product",-1864743308,null);FKb=new $APP.q("emmy.generic","tanh","emmy.generic/tanh",1214314566,null);GKb=new $APP.q("emmy.calculus.derivative","D-as-matrix","emmy.calculus.derivative/D-as-matrix",-1135641055,null);
HKb=new $APP.q(null,"ascending-by","ascending-by",670443144,null);IKb=new $APP.q("emmy.env","compatible-zero","emmy.env/compatible-zero",689688283,null);CUa=new $APP.E(null,"msg_","msg_",-1925147E3);JKb=new $APP.q(null,"defgeneric","defgeneric",-1097306948,null);KKb=new $APP.q("emmy.generic","numeric-zero?","emmy.generic/numeric-zero?",-2117490555,null);N8a=new $APP.E(null,"bs-extrapolator","bs-extrapolator",2042406575);LKb=new $APP.q(null,"D-as-matrix","D-as-matrix",1433947152,null);
qH=new $APP.q(null,"two-pi","two-pi",1398792117,null);TV=new $APP.q("emmy.function","IArity","emmy.function/IArity",-1048419713,null);MKb=new $APP.q(null,"*trig-product-to-sum-simplify?*","*trig-product-to-sum-simplify?*",1248606547,null);NKb=new $APP.q("emmy.calculus.manifold","S2-stereographic","emmy.calculus.manifold/S2-stereographic",-1069834302,null);UV=new $APP.q("cljs.core","IKVReduce","cljs.core/IKVReduce",878013381,null);OKb=new $APP.q("emmy.env","ref","emmy.env/ref",-318209511,null);
PKb=new $APP.q(null,"auxiliary-variable-fetcher","auxiliary-variable-fetcher",1143678719,null);QKb=new $APP.q("emmy.calculus.map","form-field-\x3eform-field-over-map","emmy.calculus.map/form-field-\x3eform-field-over-map",1243331136,null);RKb=new $APP.q("emmy.util","counted","emmy.util/counted",1494060608,null);SKb=new $APP.q("emmy.abstract.function","literal-function?","emmy.abstract.function/literal-function?",-1672306465,null);
TKb=new $APP.q("emmy.calculus.form-field","oneform-field?","emmy.calculus.form-field/oneform-field?",20076334,null);UKb=new $APP.q(null,"H-\x3eHp","H-\x3eHp",1522090576,null);VKb=new $APP.q(null,"I-tensor","I-tensor",-2120684949,null);WKb=new $APP.q("emmy.env","abs","emmy.env/abs",284179689,null);jQa=new $APP.E(null,"recurs","recurs",-1959309309);XKb=new $APP.q(null,"expand-multiangle","expand-multiangle",-521128157,null);YKb=new $APP.q("emmy.env","dimension","emmy.env/dimension",1083057198,null);
ZKb=new $APP.q(null,"Lagrangian-action","Lagrangian-action",1827700271,null);KD=new $APP.E(null,"ret","ret",-468222814);$Kb=new $APP.q("emmy.env","spacetime-sphere","emmy.env/spacetime-sphere",823907256,null);aLb=new $APP.q("emmy.series","log1-x-series","emmy.series/log1-x-series",175576372,null);bLb=new $APP.q("clojure.core","quot","clojure.core/quot",-292848233,null);cLb=new $APP.q("emmy.function","joint-arity","emmy.function/joint-arity",1758939772,null);
dLb=new $APP.q("emmy.numerical.unimin.golden","convergence-fn","emmy.numerical.unimin.golden/convergence-fn",-609005837,null);eLb=new $APP.q("emmy.dual","FORWARD-MODE","emmy.dual/FORWARD-MODE",-857400135,null);fLb=new $APP.q("emmy.env","make-constant-vector-field","emmy.env/make-constant-vector-field",945721088,null);gLb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57399","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57399",-1392949211,null);
hLb=new $APP.q("emmy.mechanics.rigid","M-of-q-\x3eomega-body-of-t","emmy.mechanics.rigid/M-of-q-\x3eomega-body-of-t",-355693121,null);iLb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57394","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57394",337282324,null);jLb=new $APP.q("emmy.env","form-field?","emmy.env/form-field?",-137465975,null);kLb=new $APP.q(null,"inverse-orientation","inverse-orientation",338347381,null);
lLb=new $APP.E(null,"event-\x3ecoords","event-\x3ecoords",-1721892030);mLb=new $APP.q("emmy.pattern.match","pattern-\x3ecombinators","emmy.pattern.match/pattern-\x3ecombinators",647621013,null);nLb=new $APP.q(null,"zero-manifold-function","zero-manifold-function",-429657829,null);oLb=new $APP.q(null,"binding?","binding?",568605883,null);pLb=new $APP.q("cljs.core","IRecord","cljs.core/IRecord",635852E3,null);
qLb=new $APP.q("emmy.mechanics.lagrange","velocity","emmy.mechanics.lagrange/velocity",-567545248,null);rLb=new $APP.q("emmy.env","nelder-mead","emmy.env/nelder-mead",397886904,null);sLb=new $APP.q("emmy.polynomial.factor","root-out-squares","emmy.polynomial.factor/root-out-squares",-189763287,null);tLb=new $APP.q("emmy.simplify.rules","sqrt-expand","emmy.simplify.rules/sqrt-expand",2018789844,null);uLb=new $APP.q("emmy.generic","tanc","emmy.generic/tanc",-200779884,null);
vLb=new $APP.q("emmy.quaternion","-\x3ecomplex-matrix","emmy.quaternion/-\x3ecomplex-matrix",842120886,null);wLb=new $APP.q(null,"sqrt-expand","sqrt-expand",-1216298848,null);xLb=new $APP.q("emmy.dual","primal","emmy.dual/primal",-312375937,null);yLb=new $APP.q("emmy.mechanics.hamilton","J-matrix","emmy.mechanics.hamilton/J-matrix",870346702,null);zLb=new $APP.q(null,"fail-pattern","fail-pattern",-762279763,null);
ALb=new $APP.q("emmy.matrix","general-determinant","emmy.matrix/general-determinant",-648645511,null);BLb=new $APP.q(null,"magnitude-sq","magnitude-sq",1337215013,null);CLb=new $APP.q(null,"hermetic-simplify-fixture","hermetic-simplify-fixture",-1682214452,null);DLb=new $APP.q(null,"sequence*","sequence*",-438978911,null);ELb=new $APP.q("emmy.calculus.frame","frame-owner","emmy.calculus.frame/frame-owner",563654146,null);FLb=new $APP.q(null,"nelder-mead","nelder-mead",-737112619,null);
GLb=new $APP.q("emmy.env","ceiling","emmy.env/ceiling",-295499900,null);HLb=new $APP.q("emmy.simplify.rules","constant-elimination","emmy.simplify.rules/constant-elimination",1568976652,null);ILb=new $APP.q(null,"hirow","hirow",-388964312,null);JLb=new $APP.q("emmy.matrix","classical-adjoint-formula","emmy.matrix/classical-adjoint-formula",-1528230048,null);KLb=new $APP.q("emmy.generic","solve-linear-left","emmy.generic/solve-linear-left",-1100374289,null);
LLb=new $APP.q("emmy.util.stream","vector:generate","emmy.util.stream/vector:generate",-2015822602,null);rQ=new $APP.E(null,"iterations","iterations",-1402710890);VV=new $APP.q(null,"annihilate?","annihilate?",-1123484107,null);MLb=new $APP.q(null,"permutation-parity","permutation-parity",915608661,null);NLb=new $APP.q(null,"all-results-matcher","all-results-matcher",-86570498,null);OLb=new $APP.q("cljs.core","IFind","cljs.core/IFind",-1727519574,null);
PLb=new $APP.q("emmy.series","cosh-series","emmy.series/cosh-series",-1375263612,null);QLb=new $APP.q(null,"momenta","momenta",-1206749655,null);RLb=new $APP.q("emmy.pattern.rule","predicate","emmy.pattern.rule/predicate",-1468552105,null);aZa=new $APP.q(null,"asin-sin","asin-sin",1881703610,null);SLb=new $APP.E(null,"absolute-threshold","absolute-threshold",842199714);PUa=new $APP.E(null,"given","given",716253602);TRa=new $APP.E("cljs.analyzer","numeric","cljs.analyzer/numeric",1415704188);
TLb=new $APP.q(null,"symmetric?","symmetric?",-57665610,null);mVa=new $APP.E(null,"?line","?line",-631853385);ULb=new $APP.E(null,"unchecked","unchecked",924418378);sQ=new $APP.E(null,"fncalls","fncalls",-71376182);VLb=new $APP.q(null,"integral?","integral?",-2027571295,null);WLb=new $APP.E(null,"console","console",1228072057);DO=new $APP.E("emmy.calculus.manifold","coord-prototype","emmy.calculus.manifold/coord-prototype",1491234441);
XLb=new $APP.q("emmy.env","D-as-matrix","emmy.env/D-as-matrix",-1863961501,null);V4a=new $APP.E(null,"index-types","index-types",1378319778);YLb=new $APP.q(null,"Euler-\x3eM","Euler-\x3eM",464914845,null);ZLb=new $APP.q(null,"-\x3epower-series","-\x3epower-series",1468094218,null);$Lb=new $APP.q("emmy.value","native-integral?","emmy.value/native-integral?",1753848439,null);aMb=new $APP.q("emmy.matrix","symmetric?","emmy.matrix/symmetric?",1066577107,null);
bMb=new $APP.q("emmy.operator","operator?","emmy.operator/operator?",1492593972,null);cMb=new $APP.q(null,"state-\x3eqdot","state-\x3eqdot",-1840399599,null);dMb=new $APP.q("emmy.value","object-name-map","emmy.value/object-name-map",-594874490,null);eMb=new $APP.q("emmy.polynomial","divisible?","emmy.polynomial/divisible?",2056050620,null);fMb=new $APP.E(null,"foreign","foreign",990521149);gMb=new $APP.q("emmy.calculus.vector-calculus","Curl","emmy.calculus.vector-calculus/Curl",-1071808338,null);
hMb=new $APP.q("emmy.matrix","some","emmy.matrix/some",544981599,null);iMb=new $APP.q("emmy.special.elliptic","elliptic-integrals","emmy.special.elliptic/elliptic-integrals",1429465819,null);jMb=new $APP.q("emmy.simplify","simplify-expression","emmy.simplify/simplify-expression",1181016553,null);kMb=new $APP.q(null,"multipolar","multipolar",-56699270,null);lMb=new $APP.q("cljs.core","sequential?","cljs.core/sequential?",1777854658,null);
mMb=new $APP.q(null,"v:make-basis-unit","v:make-basis-unit",381319342,null);nMb=new $APP.q("emmy.polynomial.factor","factor-expression","emmy.polynomial.factor/factor-expression",-1612667005,null);IZa=new $APP.E(null,"outer-size","outer-size",705588E3);oMb=new $APP.q("emmy.simplify.rules","log-extra","emmy.simplify.rules/log-extra",-642709194,null);pMb=new $APP.q("emmy.numerical.minimize","multidimensional-minimize","emmy.numerical.minimize/multidimensional-minimize",-1097077005,null);
qMb=new $APP.q("emmy.env","nform-field?","emmy.env/nform-field?",-1944080678,null);rMb=new $APP.q("emmy.calculus.manifold","R3-rect","emmy.calculus.manifold/R3-rect",404693097,null);sMb=new $APP.q(null,"sort-and-permute","sort-and-permute",-501389748,null);tMb=new $APP.q(null,"succeed-r","succeed-r",2090866930,null);uMb=new $APP.q(null,"permutation-sequence","permutation-sequence",-182988279,null);
vMb=new $APP.q("emmy.rational-function.interpolate","bs-merge","emmy.rational-function.interpolate/bs-merge",-1114663297,null);wMb=new $APP.q("emmy.mechanics.lagrange","L-uniform-acceleration","emmy.mechanics.lagrange/L-uniform-acceleration",1261170057,null);xMb=new $APP.q(null,"chinese-remainder","chinese-remainder",-54537496,null);yMb=new $APP.q("emmy.sr.frames","the-ether","emmy.sr.frames/the-ether",1000657076,null);zMb=new $APP.q(null,"throwable?","throwable?",2142132606,null);
AMb=new $APP.q(null,"Lagrangian-\x3eHamiltonian","Lagrangian-\x3eHamiltonian",570239049,null);BMb=new $APP.q(null,"logexp","logexp",1571978223,null);CMb=new $APP.E(null,"get-var-\x3eexpr","get-var-\x3eexpr",201158735);DMb=new $APP.q(null,"from-basis","from-basis",-1326422435,null);EMb=new $APP.q("emmy.rational-function.interpolate","bs-prepare","emmy.rational-function.interpolate/bs-prepare",-2112100550,null);nVa=new $APP.E(null,"location","location",1815599388);
FMb=new $APP.q(null,"literal-scalar-field","literal-scalar-field",1822360517,null);$APP.GMb=new $APP.q(null,"Array","Array",-423496279,null);HMb=new $APP.q("emmy.mechanics.rigid","L-body","emmy.mechanics.rigid/L-body",-1977479615,null);WV=new $APP.q(null,"Hamiltonian","Hamiltonian",-802031359,null);IMb=new $APP.q("emmy.env","basis-\x3eoneform-basis","emmy.env/basis-\x3eoneform-basis",1247242917,null);XV=new $APP.q(null,"components","components",567342585,null);
JMb=new $APP.q(null,"ZERO","ZERO",-1889270687,null);KMb=new $APP.q("emmy.calculus.indexed","argument-types","emmy.calculus.indexed/argument-types",-903324821,null);LMb=new $APP.q(null,"tableau-fn","tableau-fn",-1503017027,null);MMb=new $APP.q("emmy.generic","make-rectangular","emmy.generic/make-rectangular",-1708893731,null);YV=new $APP.q(null,"integer-part","integer-part",-1884537015,null);NMb=new $APP.q("emmy.mechanics.lagrange","Lagrangian","emmy.mechanics.lagrange/Lagrangian",450869303,null);
OMb=new $APP.q(null,"Cartan-\x3ebasis","Cartan-\x3ebasis",-113570833,null);PMb=new $APP.q("emmy.series","zero","emmy.series/zero",1964707476,null);QMb=new $APP.q("emmy.generic","inner-product","emmy.generic/inner-product",-23047757,null);lI=new $APP.E("emmy.function","cofunction","emmy.function/cofunction",-944520219);RMb=new $APP.q("cljs.core","vector","cljs.core/vector",720641726,null);SMb=new $APP.q(null,"sincos-random","sincos-random",1576329430,null);
TMb=new $APP.q("emmy.calculus.manifold","typical-coords","emmy.calculus.manifold/typical-coords",-1249724224,null);UMb=new $APP.q("emmy.algebra.fold","fold-\x3escan-fn","emmy.algebra.fold/fold-\x3escan-fn",225103671,null);VMb=new $APP.q("emmy.env","coth","emmy.env/coth",-2052877033,null);WMb=new $APP.q("emmy.sr.boost","proper-time-interval","emmy.sr.boost/proper-time-interval",2052197263,null);XMb=new $APP.q(null,"frame-maker","frame-maker",1417055762,null);
YMb=new $APP.q(null,"FORWARD-MODE","FORWARD-MODE",-587068717,null);ZMb=new $APP.q("emmy.calculus.manifold","attach-coordinate-system","emmy.calculus.manifold/attach-coordinate-system",1691756532,null);$APP.$Mb=new $APP.q(null,"evolve","evolve",2074557427,null);aNb=new $APP.E(null,"get-expr-\x3evar","get-expr-\x3evar",-224197397);bNb=new $APP.q("emmy.env","cosh","emmy.env/cosh",-908004761,null);ZV=new $APP.q(null,"integration-opts","integration-opts",185824687,null);
cNb=new $APP.q("emmy.series","xpow","emmy.series/xpow",1067226227,null);dNb=new $APP.q(null,"series","series",-2053725075,null);eNb=new $APP.q(null,"L-two-particle","L-two-particle",-625685417,null);fNb=new $APP.q("emmy.rational-function","arg-scale","emmy.rational-function/arg-scale",-480127035,null);gNb=new $APP.q(null,"order","order",385854271,null);hNb=new $APP.q("emmy.simplify.rules","*half-angle-simplify?*","emmy.simplify.rules/*half-angle-simplify?*",-1515708850,null);
iNb=new $APP.q("emmy.numerical.minimize","minimize","emmy.numerical.minimize/minimize",807990955,null);jNb=new $APP.q(null,"modified-bulirsch-stoer-scan","modified-bulirsch-stoer-scan",1926311504,null);kNb=new $APP.q("emmy.mechanics.hamilton","two-particle-center-of-mass-canonical","emmy.mechanics.hamilton/two-particle-center-of-mass-canonical",-1024015249,null);lNb=new $APP.q("emmy.expression","abstract?","emmy.expression/abstract?",988104029,null);
mNb=new $APP.q(null,"exterior-derivative","exterior-derivative",465479974,null);nNb=new $APP.q(null,"neville-incremental","neville-incremental",-1672797294,null);oNb=new $APP.q(null,"compute-abs","compute-abs",224551279,null);pNb=new $APP.q("emmy.env","time-independent-canonical?","emmy.env/time-independent-canonical?",-2059145314,null);qNb=new $APP.q("emmy.env","angle-axis-\x3erotation-matrix","emmy.env/angle-axis-\x3erotation-matrix",-1974985499,null);
rNb=new $APP.q("emmy.quaternion","-\x3eQuaternion","emmy.quaternion/-\x3eQuaternion",1314177045,null);sNb=new $APP.q("emmy.mechanics.lagrange","path-\x3estate-path","emmy.mechanics.lagrange/path-\x3estate-path",-1022435313,null);tNb=new $APP.q("emmy.complex","round","emmy.complex/round",1115486733,null);kK=new $APP.q(null,"gcd","gcd",1659909537,null);uNb=new $APP.E(null,"protocol-impl-recur-with-target","protocol-impl-recur-with-target",-1648321574);
vNb=new $APP.q("emmy.calculus.form-field","ff:zero","emmy.calculus.form-field/ff:zero",-1824687948,null);wNb=new $APP.E(null,"upper-riemann","upper-riemann",1525159164);xNb=new $APP.q(null,"*poly-gcd-debug*","*poly-gcd-debug*",-407696875,null);yNb=new $APP.E(null,"name-format","name-format",1974377103);zNb=new $APP.q(null,"literal-manifold-function","literal-manifold-function",-894930843,null);ANb=new $APP.q("Math","asin","Math/asin",-889681202,null);
BNb=new $APP.q("emmy.polynomial.gcd","classical-gcd","emmy.polynomial.gcd/classical-gcd",2136820552,null);CNb=new $APP.q("emmy.calculus.map","vector-field-\x3evector-field-over-map","emmy.calculus.map/vector-field-\x3evector-field-over-map",421796679,null);DNb=new $APP.q("emmy.structure","two-tensor?","emmy.structure/two-tensor?",-758378215,null);ENb=new $APP.q(null,"tableau-fold-fn","tableau-fold-fn",521156139,null);FNb=new $APP.q("emmy.env","-pi","emmy.env/-pi",-1729037675,null);
GNb=new $APP.q("emmy.quaternion","eq","emmy.quaternion/eq",216611588,null);HNb=new $APP.q("emmy.matrix","antisymmetric?","emmy.matrix/antisymmetric?",788081991,null);XG=new $APP.E(null,"output-opts","output-opts",-793411325);INb=new $APP.q(null,"angle-axis-\x3erotation-matrix","angle-axis-\x3erotation-matrix",1240127312,null);JNb=new $APP.q("emmy.pattern.match","map-\x3eFailure","emmy.pattern.match/map-\x3eFailure",-1100208696,null);KNb=new $APP.q(null,"J-matrix","J-matrix",-388525949,null);
LNb=new $APP.q(null,"attempt","attempt",-1042674461,null);MNb=new $APP.q("cljs.core","map-entry?","cljs.core/map-entry?",465406728,null);NNb=new $APP.q(null,"coordinate-functions","coordinate-functions",736537820,null);ONb=new $APP.q("cljs.core","IUUID","cljs.core/IUUID",-1606521379,null);PNb=new $APP.q(null,"gMR","gMR",1369866139,null);QNb=new $APP.q("emmy.polynomial.gcd","full-gcd","emmy.polynomial.gcd/full-gcd",1390497954,null);$APP.LR=new $APP.E(null,"epsilon","epsilon",-730158570);
RNb=new $APP.q("emmy.calculus.indexed","typed-\x3estructure","emmy.calculus.indexed/typed-\x3estructure",-1855045003,null);SNb=new $APP.q("emmy.quaternion","-\x3eangle-axis","emmy.quaternion/-\x3eangle-axis",504744342,null);TNb=new $APP.q(null,"term-rewriting","term-rewriting",-1893529052,null);UNb=new $APP.q("emmy.env","zero-manifold-function","emmy.env/zero-manifold-function",-1459603288,null);VNb=new $APP.q("Math","floor","Math/floor",-774722964,null);
WNb=new $APP.q(null,"characteristic-polynomial","characteristic-polynomial",-86494513,null);XNb=new $APP.q(null,"Div","Div",2085306215,null);YNb=new $APP.q("emmy.mechanics.time-evolution","H-\x3eHp","emmy.mechanics.time-evolution/H-\x3eHp",794464900,null);ZNb=new $APP.q(null,"emmy.calculus.form-field","emmy.calculus.form-field",1897032132,null);$Nb=new $APP.q("emmy.calculus.manifold","SO3-type","emmy.calculus.manifold/SO3-type",-1219795580,null);OE=new $APP.E(null,"return","return",-1891502105);
aOb=new $APP.q("emmy.matrix","identity?","emmy.matrix/identity?",-2087816678,null);fUa=new $APP.E("rl","reset","rl/reset",-800926172);eUa=new $APP.E(null,"gc-every","gc-every",-1661544691);bOb=new $APP.q("emmy.numerical.unimin.golden","inv-phi2","emmy.numerical.unimin.golden/inv-phi2",511323338,null);cOb=new $APP.q("emmy.quaternion","normalize","emmy.quaternion/normalize",542684508,null);
dOb=new $APP.q("emmy.calculus.basis","basis-\x3ecoordinate-system","emmy.calculus.basis/basis-\x3ecoordinate-system",1403958191,null);iUa=new $APP.E(null,"command","command",-894540724);$V=new $APP.q(null,"kind","kind",923265724,null);eOb=new $APP.q("emmy.calculus.vector-calculus","divergence","emmy.calculus.vector-calculus/divergence",853081072,null);aW=new $APP.q(null,"??factors","??factors",1906330792,null);fOb=new $APP.q("Math","abs","Math/abs",1400569394,null);
bW=new $APP.q(null,"fns","fns",-1469296983,null);gOb=new $APP.q(null,"Lagrange-equations-operator","Lagrange-equations-operator",-1568036865,null);hOb=new $APP.q(null,"atan-series","atan-series",755642859,null);iOb=new $APP.q("emmy.env","make-SR-frame","emmy.env/make-SR-frame",985930680,null);FD=new $APP.E(null,"refer-clojure","refer-clojure",813784440);jOb=new $APP.q("emmy.env","one-manifold-function","emmy.env/one-manifold-function",1080774493,null);
cW=new $APP.q(null,"state-derivative","state-derivative",-1453255724,null);dW=new $APP.q(null,"observe","observe",1553880077,null);kOb=new $APP.q("emmy.calculus.covariant","Cartan-\x3eforms","emmy.calculus.covariant/Cartan-\x3eforms",-7442898,null);lOb=new $APP.q("emmy.env","coordinate-system-\x3einverse-metric","emmy.env/coordinate-system-\x3einverse-metric",-1657682781,null);hRa=new $APP.E(null,"host-field","host-field",-72662140);
mOb=new $APP.q("emmy.quaternion","partial-derivative","emmy.quaternion/partial-derivative",-557923899,null);nOb=new $APP.q(null,"metric-over-map","metric-over-map",-1970394890,null);oOb=new $APP.q(null,"spacetime","spacetime",1382825726,null);pOb=new $APP.q(null,"branch","branch",1565897602,null);qOb=new $APP.E(null,"existing","existing",-340796094);rOb=new $APP.q("emmy.simplify","hermetic-simplify-fixture","emmy.simplify/hermetic-simplify-fixture",-1739515729,null);
sOb=new $APP.q(null,"qv-\x3elocal-path","qv-\x3elocal-path",313422824,null);tOb=new $APP.q("emmy.env","vector-field-\x3evector-field-over-map","emmy.env/vector-field-\x3evector-field-over-map",2070682500,null);uOb=new $APP.q(null,"make-Cartan","make-Cartan",-461348288,null);vOb=new $APP.q("emmy.calculus.vector-calculus","Laplacian","emmy.calculus.vector-calculus/Laplacian",-1453304654,null);wOb=new $APP.q(null,"reciprocal","reciprocal",-654944955,null);
xOb=new $APP.q("emmy.env","structure?","emmy.env/structure?",1235517874,null);$APP.zQ=new $APP.E(null,"primitive","primitive",1884541424);Q$a=new $APP.q("cljs.core","array-reduce","cljs.core/array-reduce",569260567,null);a8a=new $APP.E(null,"prepend","prepend",342616040);yOb=new $APP.q("emmy.series","fmap","emmy.series/fmap",1525964941,null);zOb=new $APP.q("emmy.env","with-index-types","emmy.env/with-index-types",1164135777,null);
AOb=new $APP.q("emmy.mechanics.hamilton","momentum","emmy.mechanics.hamilton/momentum",-827596440,null);BOb=new $APP.q(null,"golden-section-min","golden-section-min",-1566310259,null);vVa=new $APP.E(null,"fatal","fatal",1874419888);COb=new $APP.q(null,"oneform-field-\x3ecomponents","oneform-field-\x3ecomponents",154814502,null);eW=new $APP.q(null,"*mode*","*mode*",-1741124710,null);q4a=new $APP.E(null,"rank","rank",-1706728502);
DOb=new $APP.q("emmy.generic","asinh","emmy.generic/asinh",-118937728,null);EOb=new $APP.q("emmy.util.permute","permutation-parity","emmy.util.permute/permutation-parity",861029993,null);FOb=new $APP.q(null,"-\x3econtent+primitive","-\x3econtent+primitive",-2054346989,null);iQa=new $APP.E(null,"fn-method","fn-method",236100839);GOb=new $APP.q("emmy.mechanics.hamilton","H-central-polar","emmy.mechanics.hamilton/H-central-polar",992127210,null);
HOb=new $APP.q(null,"Laplacian","Laplacian",-1308705980,null);IOb=new $APP.q(null,"neville","neville",1283153265,null);JOb=new $APP.q(null,"default-simplifier","default-simplifier",2144884890,null);KOb=new $APP.q("emmy.util","illegal","emmy.util/illegal",1939333508,null);fW=new $APP.q(null,"over","over",1833084578,null);LOb=new $APP.q(null,"two-tensor?","two-tensor?",269900542,null);
MOb=new $APP.q("emmy.mechanics.lagrange","Lagrangian-\x3epower-loss","emmy.mechanics.lagrange/Lagrangian-\x3epower-loss",1321794453,null);gW=new $APP.q(null,"csch","csch",-1950330545,null);NOb=new $APP.q("emmy.calculus.frame","frame-name","emmy.calculus.frame/frame-name",1846629717,null);OOb=new $APP.q(null,"operands","operands",1252182965,null);POb=new $APP.q("emmy.env","Riemann-curvature","emmy.env/Riemann-curvature",-635246067,null);
QOb=new $APP.q("emmy.env","Lagrange-equations","emmy.env/Lagrange-equations",2043900427,null);A2a=new $APP.E("emmy.calculus.frame","event?","emmy.calculus.frame/event?",-489879263);ROb=new $APP.q("emmy.polynomial","from-points","emmy.polynomial/from-points",351153616,null);SOb=new $APP.q("s","down?","s/down?",-953416421,null);TOb=new $APP.q(null,"golden-section-max","golden-section-max",-2130564727,null);UOb=new $APP.q("emmy.quaternion","complex-2","emmy.quaternion/complex-2",758302746,null);
VOb=new $APP.q("emmy.quaternion","complex-1","emmy.quaternion/complex-1",-1850455712,null);WOb=new $APP.q("emmy.util.permute","-\x3et_emmy$util$permute49436","emmy.util.permute/-\x3et_emmy$util$permute49436",1806577666,null);XOb=new $APP.E(null,"case-test","case-test",-213512472);YOb=new $APP.q("emmy.calculus.map","pullback-form","emmy.calculus.map/pullback-form",1613487422,null);ZOb=new $APP.q("emmy.env","dual-zero","emmy.env/dual-zero",2091382876,null);
$Ob=new $APP.q(null,"check-point","check-point",689371383,null);aPb=new $APP.q("emmy.mechanics.hamilton","symplectic?","emmy.mechanics.hamilton/symplectic?",-1235079964,null);bPb=new $APP.q(null,"sci-eval","sci-eval",-372056164,null);Z6a=new $APP.E(null,"precedence-map","precedence-map",1892598799);cPb=new $APP.q("emmy.structure","structure-\x3eaccess-chains","emmy.structure/structure-\x3eaccess-chains",757760029,null);
dPb=new $APP.q("emmy.polynomial.factor","poly-\x3efactored-expression","emmy.polynomial.factor/poly-\x3efactored-expression",-1937864867,null);ePb=new $APP.q(null,"get-coordinates","get-coordinates",1704799803,null);l3a=new $APP.E("emmy.calculus.manifold","manifold-point","emmy.calculus.manifold/manifold-point",1526969857);fPb=new $APP.q("emmy.dual","equiv","emmy.dual/equiv",1278240065,null);gPb=new $APP.q("emmy.env","coordinate-system-names","emmy.env/coordinate-system-names",1781460769,null);
hPb=new $APP.q("emmy.util.aggregate","*fold*","emmy.util.aggregate/*fold*",-311027229,null);iPb=new $APP.q("emmy.expression","expression-\x3estring","emmy.expression/expression-\x3estring",559255347,null);jPb=new $APP.q("emmy.dual","tag-active?","emmy.dual/tag-active?",-1256082837,null);kPb=new $APP.q(null,"emmy.numerical.unimin.bracket","emmy.numerical.unimin.bracket",913531879,null);hW=new $APP.q(null,"asinh","asinh",-1398350397,null);
lPb=new $APP.q("emmy.polynomial","c*xn","emmy.polynomial/c*xn",-412553423,null);mPb=new $APP.q("emmy.util","sqrt-machine-epsilon","emmy.util/sqrt-machine-epsilon",-534779844,null);nPb=new $APP.q("emmy.quaternion","dot-product","emmy.quaternion/dot-product",-1008288780,null);oPb=new $APP.E(null,"identity-like","identity-like",-98546347);iW=new $APP.q(null,"patch-name","patch-name",433729698,null);jW=new $APP.q(null,"metric","metric",2049329604,null);
pPb=new $APP.q("emmy.env","literal-manifold-map","emmy.env/literal-manifold-map",-215370101,null);qPb=new $APP.q(null,"-\x3et_emmy$calculus$manifold57394","-\x3et_emmy$calculus$manifold57394",1390347070,null);rPb=new $APP.q("emmy.quaternion","exp","emmy.quaternion/exp",36458809,null);sPb=new $APP.q(null,"H-rectangular","H-rectangular",745243481,null);tPb=new $APP.q("emmy.env","ratio?","emmy.env/ratio?",564201594,null);j3a=new $APP.E(null,"coordinate-system-name","coordinate-system-name",-2088953179);
uPb=new $APP.q("emmy.special.elliptic","carlson-rd","emmy.special.elliptic/carlson-rd",-1723075846,null);vPb=new $APP.E(null,"extract-id","extract-id",-1627068623);wPb=new $APP.q("emmy.series","harmonic-series","emmy.series/harmonic-series",45400839,null);xPb=new $APP.q(null,"m-\x3es","m-\x3es",1355461087,null);yPb=new $APP.q("emmy.special.elliptic","carlson-rf","emmy.special.elliptic/carlson-rf",1780713972,null);
zPb=new $APP.q("emmy.special.elliptic","carlson-rc","emmy.special.elliptic/carlson-rc",-40319854,null);APb=new $APP.q(null,"permutations","permutations",-1558265014,null);BPb=new $APP.q(null,"constant-series","constant-series",-1961271942,null);CPb=new $APP.q("emmy.special.elliptic","carlson-rj","emmy.special.elliptic/carlson-rj",1380517454,null);DPb=new $APP.q("emmy.env","make-basis","emmy.env/make-basis",1052746631,null);
EPb=new $APP.q("emmy.calculus.form-field","literal-oneform-field","emmy.calculus.form-field/literal-oneform-field",273665418,null);FPb=new $APP.q("emmy.env","typed-\x3eindexed","emmy.env/typed-\x3eindexed",2013024880,null);GPb=new $APP.q(null,"manifold-type","manifold-type",-2024681051,null);HPb=new $APP.q("emmy.quaternion","arity","emmy.quaternion/arity",-973930344,null);IPb=new $APP.q("emmy.value","integral?","emmy.value/integral?",-366463480,null);
JPb=new $APP.q(null,"J-tensor","J-tensor",129006775,null);YYa=new $APP.q(null,"positive?","positive?",1455224686,null);KPb=new $APP.q("emmy.pattern.rule","iterated-top-down","emmy.pattern.rule/iterated-top-down",213838048,null);HJ=new $APP.q(null,"sqrt","sqrt",370479598,null);LPb=new $APP.q("emmy.numsymb","expt?","emmy.numsymb/expt?",-792689429,null);kW=new $APP.q(null,"best-of","best-of",2077533321,null);MPb=new $APP.q(null,"path-\x3estate-path","path-\x3estate-path",769505451,null);
NPb=new $APP.q("emmy.env","frame-owner","emmy.env/frame-owner",777518162,null);OPb=new $APP.q(null,"bs-merge","bs-merge",1465164655,null);PPb=new $APP.q(null,"L-coupled-harmonic","L-coupled-harmonic",-1590553116,null);QPb=new $APP.q(null,"frame-owner","frame-owner",1672840447,null);RPb=new $APP.q(null,"T3-spherical","T3-spherical",692408880,null);SPb=new $APP.E(null,"protocol-invalid-method","protocol-invalid-method",522647516);
TPb=new $APP.q(null,"-\x3et_emmy$calculus$manifold57399","-\x3et_emmy$calculus$manifold57399",-440415665,null);UPb=new $APP.q(null,"c-systems__58559__auto__","c-systems__58559__auto__",1361566204,null);VPb=new $APP.q("emmy.pattern.rule","pipe*","emmy.pattern.rule/pipe*",1424593420,null);WPb=new $APP.E(null,"sci","sci",-1317785218);lW=new $APP.q("cljs.core","ILookup","cljs.core/ILookup",-150575073,null);
XPb=new $APP.q("emmy.simplify.rules","*trig-product-to-sum-simplify?*","emmy.simplify.rules/*trig-product-to-sum-simplify?*",-1967083481,null);YPb=new $APP.q(null,"generate","generate",1477078705,null);ZPb=new $APP.q(null,"partial-derivatives","partial-derivatives",1773356385,null);$Pb=new $APP.q("emmy.mechanics.hamilton","H-state-\x3eL-state","emmy.mechanics.hamilton/H-state-\x3eL-state",-1276312507,null);aQb=new $APP.E("emmy.collection","set","emmy.collection/set",957963842);
bQb=new $APP.q("emmy.polynomial.gcd","*poly-gcd-debug*","emmy.polynomial.gcd/*poly-gcd-debug*",246756429,null);cQb=new $APP.q("emmy.mechanics.rigid","Euler-state-\x3eL-body","emmy.mechanics.rigid/Euler-state-\x3eL-body",278635227,null);dQb=new $APP.q("emmy.calculus.basis","Jacobian","emmy.calculus.basis/Jacobian",1840129489,null);eQb=new $APP.q(null,"Gamma","Gamma",681602978,null);fQb=new $APP.q("matrix","num-cols","matrix/num-cols",-354109770,null);
gQb=new $APP.q("emmy.calculus.manifold","c:generate","emmy.calculus.manifold/c:generate",-2027726687,null);hQb=new $APP.q(null,"coordinate-system-\x3emetric-components","coordinate-system-\x3emetric-components",1424635351,null);iQb=new $APP.q("emmy.simplify.rules","sqrt-contract","emmy.simplify.rules/sqrt-contract",-104035596,null);jQb=new $APP.q("emmy.mechanics.rigid","quaternion-state-\x3eomega-body","emmy.mechanics.rigid/quaternion-state-\x3eomega-body",-992738393,null);
kQb=new $APP.q(null,"exp2","exp2",603509626,null);lQb=new $APP.q("emmy.calculus.vector-field","components-\x3evector-field","emmy.calculus.vector-field/components-\x3evector-field",-80800745,null);mW=new $APP.q(null,"mode","mode",-2000032078,null);mQb=new $APP.q("emmy.generic","magnitude","emmy.generic/magnitude",682992694,null);nQb=new $APP.q(null,"sqrt-contract","sqrt-contract",958414240,null);oQb=new $APP.q(null,"rationalize","rationalize",290767001,null);
pQb=new $APP.q(null,"*log-exp-simplify?*","*log-exp-simplify?*",587076366,null);qQb=new $APP.q(null,"parse-int","parse-int",-742710469,null);rQb=new $APP.q("emmy.calculus.map","basis-\x3ebasis-over-map","emmy.calculus.map/basis-\x3ebasis-over-map",-137853229,null);sQb=new $APP.q("emmy.calculus.manifold","check-coordinates","emmy.calculus.manifold/check-coordinates",-1371793201,null);tQb=new $APP.q("emmy.polynomial.factor","split-polynomial","emmy.polynomial.factor/split-polynomial",-1396317750,null);
uQb=new $APP.q(null,"return","return",-250970578,null);aPa=new $APP.q(null,"Window","Window",-138860255,null);nW=new $APP.q(null,"permuted-list","permuted-list",-1279209469,null);n7a=new $APP.E(null,"gamma","gamma",1883969687);oW=new $APP.q("emmy.calculus.manifold","ICoordinateSystem","emmy.calculus.manifold/ICoordinateSystem",1561476964,null);vQb=new $APP.q(null,"expt?","expt?",370959426,null);wQb=new $APP.E(null,"inferred-ret-tag","inferred-ret-tag",798934347);
ID=new $APP.E(null,"statements","statements",600349855);xQb=new $APP.q(null,"*aggressive-atan-simplify?*","*aggressive-atan-simplify?*",1507641140,null);yQb=new $APP.q("emmy.env","drop1","emmy.env/drop1",-83315327,null);zQb=new $APP.q(null,"call","call",1120531661,null);AQb=new $APP.q(null,"Curl","Curl",797096696,null);jN=new $APP.E("emmy.dual","dual","emmy.dual/dual",-433931216);BQb=new $APP.q(null,"-\x3et_emmy$calculus$frame49168","-\x3et_emmy$calculus$frame49168",-569390957,null);
lOa=new $APP.E(null,"seen","seen",-518999789);CQb=new $APP.q("emmy.env","using-coordinates","emmy.env/using-coordinates",1801984337,null);$APP.pW=new $APP.q(null,"coords","coords",1041102415,null);DQb=new $APP.q("Math","acos","Math/acos",357181099,null);EQb=new $APP.q(null,"metric-\x3eChristoffel-2","metric-\x3eChristoffel-2",-1477146051,null);FQb=new $APP.E(null,"protocol-multiple-impls","protocol-multiple-impls",794179260);
GQb=new $APP.q(null,"emmy.expression.compile","emmy.expression.compile",553210407,null);HQb=new $APP.q(null,"metric-\x3eChristoffel-1","metric-\x3eChristoffel-1",1888246415,null);IQb=new $APP.q("emmy.rational-function","negate","emmy.rational-function/negate",3708381,null);JQb=new $APP.q("emmy.polynomial","multivariate?","emmy.polynomial/multivariate?",267086580,null);KQb=new $APP.q(null,"emmy.calculus.vector-calculus","emmy.calculus.vector-calculus",-96871050,null);
LQb=new $APP.q(null,"outer-product","outer-product",491531252,null);MQb=new $APP.q("emmy.mechanics.routhian","Routhian-state-\x3eLagrangian-state","emmy.mechanics.routhian/Routhian-state-\x3eLagrangian-state",-1983362902,null);NQb=new $APP.q(null,"from-rotation-matrix","from-rotation-matrix",-1184842963,null);Y7a=new $APP.E(null,"state-model","state-model",371967018);CK=new $APP.q(null,"magnitude","magnitude",-730161547,null);
OQb=new $APP.q("emmy.util","without-symbol-namespaces","emmy.util/without-symbol-namespaces",603109555,null);JTa=new $APP.q("emmy.util.def","fork","emmy.util.def/fork",1565339133,null);PQb=new $APP.E(null,"secs","secs",1532330091);QQb=new $APP.q("emmy.algebra.fold","kahan-babushka-neumaier","emmy.algebra.fold/kahan-babushka-neumaier",1973146121,null);RQb=new $APP.q("emmy.quaternion","make","emmy.quaternion/make",624604930,null);$APP.MK=new $APP.q(null,"compose","compose",1144740903,null);
qVa=new $APP.E(null,"instant","instant",655498374);FJ=new $APP.q(null,"expt","expt",2123850345,null);BJ=new $APP.q(null,"exp","exp",1378825265,null);SQb=new $APP.q("emmy.generic","fractional-part","emmy.generic/fractional-part",-1114623815,null);TQb=new $APP.q("emmy.calculus.indexed","with-argument-types","emmy.calculus.indexed/with-argument-types",2022391465,null);UQb=new $APP.q("emmy.util","nan?","emmy.util/nan?",-368462937,null);
VQb=new $APP.q(null,"bulirsch-stoer-fold","bulirsch-stoer-fold",59460024,null);GE=new $APP.E(null,"then","then",460598070);WQb=new $APP.q("emmy.pattern.match","segment","emmy.pattern.match/segment",-313761778,null);XQb=new $APP.q(null,"expn","expn",381067956,null);YQb=new $APP.q("emmy.env","drop2","emmy.env/drop2",307571047,null);ZQb=new $APP.q(null,"match-when","match-when",516405072,null);$Qb=new $APP.q("emmy.env","rotate-x-tuple","emmy.env/rotate-x-tuple",-713804553,null);
aRb=new $APP.q(null,"D-reverse","D-reverse",2091570853,null);bRb=new $APP.q(null,"rotate-x-tuple","rotate-x-tuple",-1878274782,null);eZa=new $APP.q(null,"asin-cos","asin-cos",-28391344,null);cRb=new $APP.q("emmy.calculus.manifold","coordinate-system-names","emmy.calculus.manifold/coordinate-system-names",1643324840,null);dRb=new $APP.q("v","integral?","v/integral?",-2027571413,null);eRb=new $APP.q("emmy.env","with-argument-types","emmy.env/with-argument-types",-1461885187,null);
fRb=new $APP.q("emmy.env","differential","emmy.env/differential",-1839604067,null);gRb=new $APP.q("emmy.env","R3-rect","emmy.env/R3-rect",595094224,null);hRb=new $APP.q("emmy.value","make-es6-callable","emmy.value/make-es6-callable",-509054717,null);iRb=new $APP.q("emmy.series","revert","emmy.series/revert",1823595145,null);jRb=new $APP.q(null,"attach-patch","attach-patch",1619352669,null);nQa=new $APP.E(null,"fn-self-name","fn-self-name",1461143531);
kRb=new $APP.q("emmy.expression.compile","valid-modes","emmy.expression.compile/valid-modes",112938506,null);pE=new $APP.q(null,"clj-nil","clj-nil",1321798654,null);sRa=new $APP.E(null,"segs","segs",-1940299576);lRb=new $APP.q(null,"variables","variables",-1090754955,null);mRb=new $APP.q(null,"has-next","has-next",-1971250537,null);$APP.nRb=new $APP.q("cljs.core","mapv","cljs.core/mapv",433728488,null);oRb=new $APP.q(null,"nan?","nan?",-76931893,null);
pRb=new $APP.q(null,"bracket-max-scmutils","bracket-max-scmutils",1979643050,null);qRb=new $APP.q(null,"goog.string","goog.string",-2055533048,null);rRb=new $APP.q("emmy.env","evolve","emmy.env/evolve",-1140657274,null);sRb=new $APP.q(null,"emmy.calculus.indexed","emmy.calculus.indexed",-759277111,null);tRb=new $APP.q(null,"structure-constant","structure-constant",-1401802547,null);qW=new $APP.q(null,"coordinate-system","coordinate-system",342184256,null);
uRb=new $APP.q(null,"IRational","IRational",1043551137,null);vRb=new $APP.q(null,"Riemann","Riemann",809872061,null);wRb=new $APP.q(null,"factor-expression","factor-expression",-2061580046,null);xRb=new $APP.E(null,"the-var","the-var",1428415613);yRb=new $APP.q(null,"event?","event?",-2038386683,null);zRb=new $APP.q(null,"with-index-types","with-index-types",-2000554538,null);ARb=new $APP.q(null,"time-expired?","time-expired?",1826704121,null);
BRb=new $APP.q(null,"M-\x3eomega","M-\x3eomega",-1205879070,null);i4a=new $APP.q(null,"-indexOf","-indexOf",-442719214,null);rW=new $APP.q("v","native-integral?","v/native-integral?",1972110486,null);CRb=new $APP.q("emmy.env","series","emmy.env/series",-1019970502,null);DRb=new $APP.q("emmy.dual","REVERSE-MODE","emmy.dual/REVERSE-MODE",1927323520,null);ERb=new $APP.q("emmy.value","scalar?","emmy.value/scalar?",1318943466,null);
FRb=new $APP.q("emmy.calculus.map","literal-manifold-map","emmy.calculus.map/literal-manifold-map",-773736888,null);GRb=new $APP.q("emmy.matrix","s:divide-by-structure","emmy.matrix/s:divide-by-structure",595723922,null);HRb=new $APP.q("emmy.series","sum","emmy.series/sum",-1370679882,null);sW=new $APP.q(null,"valid-orientation?","valid-orientation?",1508041189,null);IRb=new $APP.q("emmy.calculus.derivative","partial-forward","emmy.calculus.derivative/partial-forward",-973257536,null);
JRb=new $APP.q(null,"pitch","pitch",-1159309069,null);KRb=new $APP.q(null,"map-\x3eFailure","map-\x3eFailure",-77899845,null);LRb=new $APP.E(null,"nodejs","nodejs",321212524);tW=new $APP.q(null,"dual-basis","dual-basis",-73332233,null);MRb=new $APP.q("emmy.mechanics.rotation","Euler-\x3eM","emmy.mechanics.rotation/Euler-\x3eM",1665737322,null);NRb=new $APP.q(null,"g-on-M","g-on-M",168796354,null);F9a=new $APP.q(null,"flow-derivative","flow-derivative",-2031576450,null);
fQa=new $APP.E(null,"arg","arg",-1747261837);uW=new $APP.q(null,"Cartan-on-target","Cartan-on-target",1638424227,null);ORb=new $APP.q("emmy.rational-function","invert","emmy.rational-function/invert",-1434786149,null);PRb=new $APP.q("emmy.mechanics.hamilton","Poisson-bracket","emmy.mechanics.hamilton/Poisson-bracket",842528623,null);QRb=new $APP.q("emmy.pattern.rule","rule-simplifier","emmy.pattern.rule/rule-simplifier",261720809,null);RRb=new $APP.q(null,"x-degree","x-degree",1170692253,null);
SRb=new $APP.q(null,"same-orientation?","same-orientation?",-1650887357,null);TRb=new $APP.q(null,"emmy.mechanics.rigid","emmy.mechanics.rigid",-48431844,null);URb=new $APP.q("emmy.calculus.form-field","oneform-field-\x3ebasis-components","emmy.calculus.form-field/oneform-field-\x3ebasis-components",-326137970,null);VRb=new $APP.q("emmy.env","SO3","emmy.env/SO3",-494454810,null);WRb=new $APP.q(null,"is","is",2009660525,null);vW=new $APP.q(null,"coth","coth",1130257730,null);
XRb=new $APP.q(null,"without-symbol-namespaces","without-symbol-namespaces",814869975,null);YRb=new $APP.q(null,"covariant-derivative","covariant-derivative",95007126,null);ZRb=new $APP.q("emmy.series","acos-series","emmy.series/acos-series",-58407659,null);$Rb=new $APP.q(null,"D-numeric","D-numeric",509796205,null);aSb=new $APP.q(null,"determinant","determinant",-580156910,null);bSb=new $APP.q("emmy.env","literal-down","emmy.env/literal-down",-138816442,null);
cSb=new $APP.q("emmy.env","transfer-point","emmy.env/transfer-point",-489683007,null);dSb=new $APP.q("emmy.env","proper-space-interval","emmy.env/proper-space-interval",-891878801,null);eSb=new $APP.q("emmy.env","components-\x3eoneform-field","emmy.env/components-\x3eoneform-field",-65060581,null);wH=new $APP.q(null,"cosh","cosh",-1962788142,null);fSb=new $APP.q(null,"simplify-square-roots","simplify-square-roots",320711438,null);
gSb=new $APP.q(null,"emmy.special.factorial","emmy.special.factorial",-488164136,null);wW=new $APP.q(null,"m0","m0",142676688,null);xW=new $APP.q(null,"m1","m1",1532436901,null);hSb=new $APP.q(null,"m2","m2",1053528221,null);iSb=new $APP.q("emmy.generic","negative?","emmy.generic/negative?",1788861263,null);jSb=new $APP.q(null,"number-of-permutations","number-of-permutations",401663020,null);yW=new $APP.q(null,"ks","ks",-754231827,null);
zW=new $APP.q(null,"fractional-part","fractional-part",-505422086,null);kSb=new $APP.q("emmy.algebra.fold","max","emmy.algebra.fold/max",-1590307144,null);lSb=new $APP.q("emmy.env","cot","emmy.env/cot",1529068977,null);mSb=new $APP.q("emmy.env","cos","emmy.env/cos",-422859036,null);nSb=new $APP.q("emmy.env","Alt","emmy.env/Alt",2089654732,null);oSb=new $APP.q("emmy.calculus.frame","frame-maker","emmy.calculus.frame/frame-maker",373551543,null);
pSb=new $APP.q("emmy.calculus.manifold","S2p","emmy.calculus.manifold/S2p",-898919664,null);AW=new $APP.q(null,"ls","ls",-1458647179,null);qSb=new $APP.q("emmy.env","negate","emmy.env/negate",-1446561801,null);rSb=new $APP.q(null,"pairwise-sum","pairwise-sum",1070838009,null);sSb=new $APP.q("emmy.calculus.indexed","typed-\x3eindexed","emmy.calculus.indexed/typed-\x3eindexed",1203218980,null);
tSb=new $APP.q("emmy.mechanics.lagrange","L-sliding-pend","emmy.mechanics.lagrange/L-sliding-pend",1500414486,null);BW=new $APP.q(null,"ms","ms",487821794,null);uSb=new $APP.q("cljs.core","boolean?","cljs.core/boolean?",1400713761,null);vSb=new $APP.q("emmy.matrix","without","emmy.matrix/without",1858472872,null);wSb=new $APP.q("emmy.simplify.rules","cos-sq-\x3esin-sq","emmy.simplify.rules/cos-sq-\x3esin-sq",-71509844,null);
xSb=new $APP.q(null,"emmy.numerical.minimize","emmy.numerical.minimize",-1131862948,null);ySb=new $APP.q("emmy.polynomial","expt","emmy.polynomial/expt",-837641413,null);zSb=new $APP.q(null,"Hodge-star","Hodge-star",219488309,null);ASb=new $APP.q("emmy.simplify.rules","*exponent-product-simplify?*","emmy.simplify.rules/*exponent-product-simplify?*",-180144893,null);BSb=new $APP.q("emmy.matrix","square?","emmy.matrix/square?",-146341292,null);
CSb=new $APP.q(null,"M-of-q-\x3eomega-body-of-t","M-of-q-\x3eomega-body-of-t",1800029441,null);DSb=new $APP.q(null,"not-integral?","not-integral?",1746552960,null);ESb=new $APP.q("emmy.dual","*active-tags*","emmy.dual/*active-tags*",-2102560287,null);FSb=new $APP.q(null,"get-integrator","get-integrator",-285958527,null);CW=new $APP.q(null,"q0","q0",1970367567,null);DW=new $APP.q(null,"q1","q1",1804441001,null);EW=new $APP.q(null,"q2","q2",282479025,null);FW=new $APP.q(null,"op","op",-242456428,null);
GSb=new $APP.q("emmy.env","constant-manifold-function","emmy.env/constant-manifold-function",624278880,null);HSb=new $APP.q("emmy.mechanics.hamilton","Hamiltonian-\x3eLagrangian","emmy.mechanics.hamilton/Hamiltonian-\x3eLagrangian",-500988453,null);Y2a=new $APP.E("emmy.calculus.manifold","manifold-family","emmy.calculus.manifold/manifold-family",-1074374215);ISb=new $APP.q(null,"pe","pe",-876735477,null);uE=new $APP.E(null,"js-var","js-var",-1177899142);
JSb=new $APP.q(null,"splice-reduce","splice-reduce",-2065693385,null);KSb=new $APP.q("emmy.calculus.metric","embedding-map-\x3emetric-components","emmy.calculus.metric/embedding-map-\x3emetric-components",-828910261,null);LSb=new $APP.q("emmy.pattern.rule","fixed-point","emmy.pattern.rule/fixed-point",-1602956137,null);MSb=new $APP.q(null,"acos-series","acos-series",-1542810012,null);NSb=new $APP.E(null,"variadic-max-arity","variadic-max-arity",-14288402);pH=new $APP.q(null,"pi","pi",176774184,null);
OSb=new $APP.q(null,"r1","r1",-1963460869,null);PSb=new $APP.q(null,"r2","r2",1893375701,null);QSb=new $APP.q("emmy.env","csc","emmy.env/csc",550666523,null);RSb=new $APP.q("emmy.calculus.frame","coords-\x3eevent","emmy.calculus.frame/coords-\x3eevent",-399635368,null);SSb=new $APP.q("emmy.operator","procedure","emmy.operator/procedure",556856273,null);vOa=new $APP.E("cljs","analysis-error","cljs/analysis-error",-420526349);
TSb=new $APP.q("emmy.env","vector-\x3edown","emmy.env/vector-\x3edown",1847298409,null);USb=new $APP.q(null,"get-patch","get-patch",-636344,null);GW=new $APP.E("emmy.operator","operator","emmy.operator/operator",1412891316);VSb=new $APP.E(null,"unprovided","unprovided",-652330764);WSb=new $APP.q("emmy.env","factorial","emmy.env/factorial",1249115292,null);XSb=new $APP.q(null,"contract","contract",-1856283024,null);
YSb=new $APP.q("emmy.pattern.match","all-results-matcher","emmy.pattern.match/all-results-matcher",-1110526029,null);mE=new $APP.E(null,"excludes","excludes",-1791725945);HW=new $APP.q(null,"tangent","tangent",-1933519948,null);ZSb=new $APP.q(null,"qs","qs",-260156164,null);AVa=new $APP.E(null,"hash","hash",-13781596);$Sb=new $APP.q("emmy.sr.boost","general-boost","emmy.sr.boost/general-boost",2127263857,null);aTb=new $APP.q(null,"state-\x3eqp","state-\x3eqp",185160363,null);
bTb=new $APP.q(null,"make-operator","make-operator",329621074,null);IW=new $APP.q(null,"re","re",1869207729,null);FYa=new $APP.q(null,"??fs1*","??fs1*",1798735663,null);cTb=new $APP.q(null,"*validate-Legendre-transform?*","*validate-Legendre-transform?*",-2006767239,null);dTb=new $APP.q("emmy.calculus.metric","vector-field-\x3eoneform-field","emmy.calculus.metric/vector-field-\x3eoneform-field",191536335,null);eTb=new $APP.q(null,"divide-numbers-through","divide-numbers-through",1612965991,null);
fTb=new $APP.q("emmy.env","seq:print","emmy.env/seq:print",2045210942,null);IG=new $APP.E(null,"clj","clj",-660495428);JW=new $APP.q(null,"t0","t0",-534273234,null);KW=new $APP.q(null,"t1","t1",1665503971,null);LW=new $APP.q(null,"t2","t2",891676305,null);gTb=new $APP.q(null,"rv","rv",-860258924,null);hTb=new $APP.q(null,"q-div-scalar","q-div-scalar",-1899125481,null);iTb=new $APP.q(null,"curvature-components","curvature-components",-1275395345,null);
jTb=new $APP.q("emmy.polynomial","extend","emmy.polynomial/extend",-1095019845,null);MW=new $APP.q(null,"rs","rs",-1740853800,null);kTb=new $APP.q(null,"t?","t?",-2042555639,null);lTb=new $APP.q(null,"meta57395","meta57395",483204548,null);V6a=new $APP.E(null,"infix?","infix?",41062120);mTb=new $APP.q(null,"potential-energy","potential-energy",-990216810,null);nTb=new $APP.q(null,"Lagrange-equations-first-order","Lagrange-equations-first-order",975370522,null);
oTb=new $APP.q("emmy.mechanics.hamilton","state-\x3eqp","emmy.mechanics.hamilton/state-\x3eqp",-1006186532,null);pTb=new $APP.q("emmy.polynomial","divide","emmy.polynomial/divide",687310746,null);ORa=new $APP.E(null,"macro-syntax-check","macro-syntax-check",2072602373);hQ=new $APP.q(null,"u-","u-",1997472866,null);qTb=new $APP.E(null,"simpson","simpson",-1546685398);rTb=new $APP.q(null,"compiler-mode","compiler-mode",-1594269719,null);
sTb=new $APP.q(null,"coordinate-origin","coordinate-origin",-1339747644,null);tTb=new $APP.q("emmy.env","vector-\x3eup","emmy.env/vector-\x3eup",719487598,null);uTb=new $APP.q(null,"stirling-first-kind","stirling-first-kind",329338979,null);vTb=new $APP.q("emmy.env","multidimensional-minimize","emmy.env/multidimensional-minimize",-1541103218,null);wTb=new $APP.q("emmy.mechanics.hamilton","make-Hamiltonian","emmy.mechanics.hamilton/make-Hamiltonian",268374131,null);
xTb=new $APP.q(null,"the-ether","the-ether",-259961165,null);yTb=new $APP.q(null,"literal?","literal?",1993017398,null);zTb=new $APP.q(null,"-\x3eCompleted","-\x3eCompleted",-1940126805,null);$APP.NW=new $APP.q(null,"v1","v1",-2141311508,null);ATb=new $APP.q(null,"to","to",1832630534,null);$APP.OW=new $APP.q(null,"v2","v2",1875554983,null);BTb=new $APP.q("emmy.calculus.vector-field","coordinatize","emmy.calculus.vector-field/coordinatize",-927084903,null);IOa=new $APP.E(null,"goog","goog",-1711135452);
CTb=new $APP.q(null,"coeff?","coeff?",-398863446,null);hI=new $APP.E(null,"exactly","exactly",1304099233);DTb=new $APP.q("emmy.operator","exp","emmy.operator/exp",-1395745485,null);ETb=new $APP.q("emmy.env","S2p-stereographic","emmy.env/S2p-stereographic",67978312,null);zP=new $APP.q(null,"up","up",1370819414,null);eN=new $APP.E(null,"dfdx","dfdx",-1523879512);fN=new $APP.E(null,"dfdy","dfdy",-434788201);K7a=new $APP.E(null,"grow-limit","grow-limit",2130208943);
FTb=new $APP.q("emmy.simplify.rules","negative-number?","emmy.simplify.rules/negative-number?",-1495251167,null);GTb=new $APP.q("emmy.env","make-polar","emmy.env/make-polar",-1184935190,null);HTb=new $APP.q("emmy.env","exterior-derivative","emmy.env/exterior-derivative",-568827535,null);ITb=new $APP.q("emmy.matrix","make-zero","emmy.matrix/make-zero",115811654,null);$APP.PW=new $APP.q(null,"x0","x0",2051374914,null);$APP.QW=new $APP.q(null,"x1","x1",-223390720,null);
JTb=new $APP.q(null,"commutative","commutative",-77507576,null);KTb=new $APP.q(null,"polynomial?","polynomial?",-1721156532,null);LTb=new $APP.q(null,"numerator","numerator",1479770423,null);MTb=new $APP.q("emmy.rational-function","expt","emmy.rational-function/expt",1788741868,null);NTb=new $APP.q(null,"seq-print","seq-print",-2118969658,null);OTb=new $APP.q(null,"y0","y0",1751986334,null);DYa=new $APP.q(null,"exponent-product","exponent-product",134982023,null);
PTb=new $APP.q("emmy.util.stream","zeno","emmy.util.stream/zeno",-1055068504,null);QTb=new $APP.q(null,"xc","xc",-1246828562,null);RTb=new $APP.q("emmy.calculus.form-field","components-\x3eoneform-field","emmy.calculus.form-field/components-\x3eoneform-field",-1388426189,null);STb=new $APP.q("emmy.rational-function","gcd","emmy.rational-function/gcd",251347748,null);TTb=new $APP.q("emmy.calculus.manifold","coordinate-system?","emmy.calculus.manifold/coordinate-system?",-1926114138,null);
UTb=new $APP.q("emmy.dual","replace-tag","emmy.dual/replace-tag",1781391258,null);RW=new $APP.q(null,"xa","xa",1388612750,null);VTb=new $APP.q("emmy.env","metric-over-map","emmy.env/metric-over-map",1210605861,null);SW=new $APP.q(null,"xb","xb",-765832,null);WTb=new $APP.q("emmy.env","Christoffel?","emmy.env/Christoffel?",2099919873,null);XTb=new $APP.q(null,"z1","z1",-635827689,null);YTb=new $APP.q(null,"z2","z2",-752480244,null);
ZTb=new $APP.q("emmy.generic","gcd","emmy.generic/gcd",1292829540,null);$Tb=new $APP.q(null,"emmy.calculus.map","emmy.calculus.map",1333546993,null);aUb=new $APP.q("emmy.env","basis-\x3ecoordinate-system","emmy.env/basis-\x3ecoordinate-system",1421810382,null);TW=new $APP.q("cljs.core","IAssociative","cljs.core/IAssociative",-1700920611,null);bUb=new $APP.E(null,"adaptive-neighborhood-width","adaptive-neighborhood-width",791007094);cUb=new $APP.q(null,"frame-sym","frame-sym",1690428135,null);
dUb=new $APP.q(null,"modint","modint",-1355832379,null);eUb=new $APP.q("emmy.polynomial","expression-\x3e","emmy.polynomial/expression-\x3e",-1176034683,null);fUb=new $APP.q(null,"ys","ys",1606115702,null);gUb=new $APP.q(null,"Phi*","Phi*",-2105657447,null);hUb=new $APP.q("emmy.calculus.coordinate","define-coordinates","emmy.calculus.coordinate/define-coordinates",1830166904,null);iUb=new $APP.q(null,"L-axisymmetric-top","L-axisymmetric-top",-966661177,null);
jUb=new $APP.q("emmy.env","Christoffel-\x3esymbols","emmy.env/Christoffel-\x3esymbols",-1246502376,null);UW=new $APP.q("cljs.core","IFn","cljs.core/IFn",-920223129,null);kUb=new $APP.q(null,"Routh-equations","Routh-equations",-1119256779,null);lUb=new $APP.q("cljs.core","list?","cljs.core/list?",-684796618,null);mUb=new $APP.q("emmy.polynomial.factor","factor","emmy.polynomial.factor/factor",-295805940,null);
nUb=new $APP.q("emmy.quaternion","from-complex-matrix","emmy.quaternion/from-complex-matrix",1008303928,null);oUb=new $APP.q("emmy.env","-\x3einfix","emmy.env/-\x3einfix",1376852277,null);pUb=new $APP.q(null,"coordinate-basis-oneform-field","coordinate-basis-oneform-field",-68149918,null);vWa=new $APP.E(null,"zero-like","zero-like",1759410522);qUb=new $APP.q("emmy.structure","generate","emmy.structure/generate",-1690511640,null);
rUb=new $APP.q("emmy.util.permute","sort-and-permute","emmy.util.permute/sort-and-permute",-405653616,null);sUb=new $APP.q("cljs.core","list*","cljs.core/list*",357627358,null);tUb=new $APP.q(null,"antisymmetric-\x3ecolumn-matrix","antisymmetric-\x3ecolumn-matrix",-1061685310,null);uUb=new $APP.q(null,"ratio?","ratio?",-498643049,null);IQa=new $APP.E(null,"include-macros","include-macros",1228110289);
vUb=new $APP.q("emmy.mechanics.hamilton","symplectic-transform?","emmy.mechanics.hamilton/symplectic-transform?",312254588,null);wUb=new $APP.q("emmy.expression.analyze","*inhibit-expt-simplify*","emmy.expression.analyze/*inhibit-expt-simplify*",1358114281,null);xUb=new $APP.q("emmy.env","expression-\x3estring","emmy.env/expression-\x3estring",94331728,null);yUb=new $APP.E(null,"analyze-expression","analyze-expression",870894091);zUb=new $APP.q("emmy.env","lower","emmy.env/lower",-416117813,null);
AUb=new $APP.q(null,"Riemann-curvature","Riemann-curvature",-1648319560,null);BUb=new $APP.q("emmy.env","basis-components-\x3eoneform-field","emmy.env/basis-components-\x3eoneform-field",-332083849,null);CUb=new $APP.q(null,"parabolic-step","parabolic-step",720135352,null);DUb=new $APP.q("emmy.env","tan","emmy.env/tan",-531624639,null);EUb=new $APP.q("Math","pow","Math/pow",193807960,null);
FUb=new $APP.q("emmy.numerical.unimin.bracket","parabolic-step","emmy.numerical.unimin.bracket/parabolic-step",-610651676,null);eQa=new $APP.E(null,"binding","binding",539932593);GUb=new $APP.q("emmy.calculus.manifold","point-\x3emanifold","emmy.calculus.manifold/point-\x3emanifold",2099914878,null);HUb=new $APP.q("emmy.mechanics.hamilton","compatible-H-state?","emmy.mechanics.hamilton/compatible-H-state?",-587695837,null);
IUb=new $APP.q(null,"M-of-q-\x3eomega-of-t","M-of-q-\x3eomega-of-t",-467896766,null);JUb=new $APP.q("emmy.env","literal-number","emmy.env/literal-number",184945361,null);KUb=new $APP.q("emmy.numerical.multimin.nelder-mead","nelder-mead","emmy.numerical.multimin.nelder-mead/nelder-mead",-1878246548,null);$L=new $APP.E("emmy.polynomial","coeff","emmy.polynomial/coeff",972797864);LUb=new $APP.q("emmy.generic","freeze","emmy.generic/freeze",131755723,null);
MUb=new $APP.q(null,"literal-row-matrix","literal-row-matrix",-1031962807,null);$APP.VW=new $APP.E(null,"label","label",1718410804);NUb=new $APP.q("emmy.calculus.derivative","taylor-series","emmy.calculus.derivative/taylor-series",-1000016831,null);OUb=new $APP.q(null,"s:inverse","s:inverse",-1336873639,null);PUb=new $APP.q("cljs.core","inst?","cljs.core/inst?",1216133710,null);QUb=new $APP.q(null,"hicol","hicol",413945288,null);
RUb=new $APP.q(null,"proper-space-interval","proper-space-interval",-2056140240,null);SUb=new $APP.q(null,"Noether-integral","Noether-integral",-1527698590,null);TUb=new $APP.q(null,"emmy.calculus.derivative","emmy.calculus.derivative",-955806891,null);UUb=new $APP.q(null,"S2-spherical","S2-spherical",173450952,null);VUb=new $APP.E(null,"years","years",-1298579689);WUb=new $APP.q(null,"IFrame","IFrame",1542387647,null);XUb=new $APP.q("emmy.env","tau","emmy.env/tau",-1598211860,null);
YUb=new $APP.q(null,"-\x3eFailure","-\x3eFailure",1824260484,null);ZUb=new $APP.q("emmy.polynomial","valid-arity?","emmy.polynomial/valid-arity?",-596836818,null);$Ub=new $APP.E(null,"coords-\x3epoint","coords-\x3epoint",1186490070);aVb=new $APP.q("emmy.polynomial","-\x3ePolynomial","emmy.polynomial/-\x3ePolynomial",1862159190,null);bVb=new $APP.q("emmy.structure","expt","emmy.structure/expt",-1074222400,null);WW=new $APP.q(null,"calling-convention","calling-convention",491725371,null);
cVb=new $APP.q("emmy.pattern.match","frame-predicate","emmy.pattern.match/frame-predicate",1617798150,null);dVb=new $APP.q("emmy.util.aggregate","generic-sum","emmy.util.aggregate/generic-sum",-160417773,null);eVb=new $APP.q("emmy.quaternion","scale","emmy.quaternion/scale",-2079416714,null);fVb=new $APP.q(null,"with-argument-types","with-argument-types",1782525454,null);gVb=new $APP.q("emmy.numerical.unimin.golden","stop-fn","emmy.numerical.unimin.golden/stop-fn",-889753428,null);
hVb=new $APP.q("emmy.sr.frames","SR-coordinates?","emmy.sr.frames/SR-coordinates?",1071867371,null);YOa=new $APP.E(null,"ctor","ctor",1750864802);iVb=new $APP.q(null,"K-tensor","K-tensor",-2023182764,null);OVa=new $APP.E(null,"appenders","appenders",1245583998);jVb=new $APP.q("emmy.mechanics.hamilton","standard-map","emmy.mechanics.hamilton/standard-map",36927812,null);RYa=new $APP.q(null,"c1","c1",-1521904966,null);
kVb=new $APP.q("emmy.polynomial","-\x3estr","emmy.polynomial/-\x3estr",-1253774430,null);lVb=new $APP.q("emmy.matrix","matrix?","emmy.matrix/matrix?",-1906544740,null);SYa=new $APP.q(null,"c2","c2",78651156,null);TYa=new $APP.q(null,"c3","c3",468715789,null);UYa=new $APP.q(null,"c4","c4",-1626390159,null);VYa=new $APP.q(null,"c5","c5",1025457982,null);mVb=new $APP.q(null,"as","as",-1505746128,null);nVb=new $APP.q(null,"extend-pt","extend-pt",936827516,null);
XW=new $APP.q(null,"Cartan?","Cartan?",1638685802,null);oVb=new $APP.q("emmy.env","sum","emmy.env/sum",-1424949064,null);pVb=new $APP.q(null,"R3-cyl","R3-cyl",-1317838879,null);YW=new $APP.E(null,"south-pole","south-pole",-663994324);qVb=new $APP.q("emmy.env","compare","emmy.env/compare",-1886789744,null);ZW=new $APP.E("emmy.matrix","row-matrix","emmy.matrix/row-matrix",1672054134);rVb=new $APP.q(null,"degree","degree",1877638555,null);
sVb=new $APP.q("emmy.env","complex?","emmy.env/complex?",35925448,null);tVb=new $APP.q("emmy.rational-function.interpolate","modified-bulirsch-stoer","emmy.rational-function.interpolate/modified-bulirsch-stoer",1530047077,null);uVb=new $APP.q("emmy.pattern.rule","until","emmy.pattern.rule/until",1268378413,null);MYa=new $APP.q(null,"e1","e1",-732861271,null);NYa=new $APP.q(null,"e2","e2",1288255343,null);OYa=new $APP.q(null,"e3","e3",980159791,null);
vVb=new $APP.q("emmy.env","transpose","emmy.env/transpose",-2112189284,null);wVb=new $APP.q(null,"Cartan-\x3eforms","Cartan-\x3eforms",1353403135,null);PYa=new $APP.q(null,"e4","e4",-714258248,null);kOa=new $APP.E("cljs.analyzer","constants","cljs.analyzer/constants",1697083770);xVb=new $APP.q(null,"cs","cs",-117024463,null);$W=new $APP.q(null,"ct","ct",-517996828,null);yVb=new $APP.q("emmy.polynomial","evaluate","emmy.polynomial/evaluate",255708542,null);
zVb=new $APP.q("emmy.polynomial.interpolate","lagrange","emmy.polynomial.interpolate/lagrange",1122070272,null);AVb=new $APP.E(null,"right-riemann","right-riemann",1357460560);BVb=new $APP.q("emmy.polynomial.interpolate","tableau-fold-fn","emmy.polynomial.interpolate/tableau-fold-fn",1663563242,null);$APP.aX=new $APP.q(null,"f'","f'",1671336495,null);CVb=new $APP.q("emmy.calculus.vector-field","vector-field-\x3ecomponents","emmy.calculus.vector-field/vector-field-\x3ecomponents",-703620554,null);
DVb=new $APP.q("emmy.quaternion","magnitude","emmy.quaternion/magnitude",611614077,null);EVb=new $APP.q(null,"manifold-point-representation","manifold-point-representation",-630647746,null);FVb=new $APP.q(null,"the-real-line","the-real-line",319574384,null);bX=new $APP.q(null,"dx","dx",1258734795,null);GVb=new $APP.q(null,"String","String",-2070057435,null);$APP.cX=new $APP.q(null,"dt","dt",1272086768,null);HVb=new $APP.q("emmy.value","kind-predicate","emmy.value/kind-predicate",118964741,null);
IVb=new $APP.q(null,"emmy.pattern.match","emmy.pattern.match",-1379218803,null);JVb=new $APP.q("emmy.env","literal-vector-field","emmy.env/literal-vector-field",647911606,null);dX=new $APP.q(null,"eq","eq",1021992460,null);KVb=new $APP.q(null,"acceleration","acceleration",426643106,null);LVb=new $APP.q("emmy.structure","literal","emmy.structure/literal",132658007,null);MVb=new $APP.q(null,"-\x3eterms","-\x3eterms",104047239,null);fOa=new $APP.E(null,"loop-lets","loop-lets",2036794185);
NVb=new $APP.q(null,"fa","fa",2125512710,null);OVb=new $APP.q(null,"fb","fb",308862205,null);PVb=new $APP.q(null,"fc","fc",1492155206,null);QVb=new $APP.q("emmy.abstract.function","with-literal-functions","emmy.abstract.function/with-literal-functions",379735791,null);RVb=new $APP.q("emmy.pattern.rule","attempt?","emmy.pattern.rule/attempt?",-944675102,null);SVb=new $APP.q(null,"ff","ff",-1993208340,null);
TVb=new $APP.q("emmy.mechanics.lagrange","make-Lagrangian","emmy.mechanics.lagrange/make-Lagrangian",-408756363,null);gUa=new $APP.E("rl","all","rl/all",892118056);UVb=new $APP.q("emmy.matrix","num-rows","emmy.matrix/num-rows",956302826,null);VVb=new $APP.q(null,"miscsimp","miscsimp",2008821660,null);eX=new $APP.q(null,"fx","fx",402701955,null);WVb=new $APP.q("emmy.env","metric-\x3econnection-1","emmy.env/metric-\x3econnection-1",202899343,null);
XVb=new $APP.q("emmy.util","interrupted","emmy.util/interrupted",-369019014,null);YVb=new $APP.q("emmy.env","metric-\x3econnection-2","emmy.env/metric-\x3econnection-2",-582324945,null);ZVb=new $APP.q(null,"S2p-tilted","S2p-tilted",-205552708,null);fX=new $APP.q(null,"cont","cont",1063431313,null);$Vb=new $APP.q(null,"two-up?","two-up?",-1449212662,null);aWb=new $APP.q(null,"s:transpose","s:transpose",-671608823,null);bWb=new $APP.q(null,"??args","??args",-2100991912,null);
cWb=new $APP.q("emmy.matrix","as-matrix","emmy.matrix/as-matrix",-865116285,null);dWb=new $APP.q(null,"n-times","n-times",-1654271223,null);RE=new $APP.E(null,"fn-var","fn-var",1086204730);eWb=new $APP.q("emmy.structure","down-of-ups?","emmy.structure/down-of-ups?",1044675597,null);fWb=new $APP.q(null,"function-\x3e","function-\x3e",-1430532114,null);gWb=new $APP.q("emmy.simplify.rules","sincos-random","emmy.simplify.rules/sincos-random",505442210,null);
hWb=new $APP.q(null,"restriction","restriction",260296615,null);iWb=new $APP.q(null,"extended-rotation","extended-rotation",-1676844009,null);jWb=new $APP.q("emmy.calculus.manifold","with-coordinate-prototype","emmy.calculus.manifold/with-coordinate-prototype",-636709634,null);gX=new $APP.q(null,"im","im",506870084,null);kWb=new $APP.q(null,"make-es6-callable","make-es6-callable",-860688214,null);hX=new $APP.q(null,"cols","cols",-274269768,null);
lWb=new $APP.q(null,"falling-factorial","falling-factorial",1649395235,null);mWb=new $APP.q(null,"modint?","modint?",-46333612,null);nWb=new $APP.q("emmy.simplify.rules","trig:product-\x3esum","emmy.simplify.rules/trig:product-\x3esum",-1786356564,null);oWb=new $APP.q(null,"with-coordinate-prototype","with-coordinate-prototype",-1647439344,null);pWb=new $APP.q("emmy.calculus.map","pullback-function","emmy.calculus.map/pullback-function",1353904066,null);
qWb=new $APP.q("emmy.series","inflate","emmy.series/inflate",1711269509,null);rWb=new $APP.q("emmy.env","partial-reverse","emmy.env/partial-reverse",-5571198,null);sWb=new $APP.q(null,"thetadot","thetadot",1584260463,null);lF=new $APP.q("cljs.core","Symbol","cljs.core/Symbol",292989338,null);tWb=new $APP.q(null,"structure-\x3etyped","structure-\x3etyped",-1854577176,null);uWb=new $APP.q("emmy.calculus.manifold","point-\x3ecoords","emmy.calculus.manifold/point-\x3ecoords",2036243080,null);
vWb=new $APP.q("emmy.calculus.manifold","get-coordinates","emmy.calculus.manifold/get-coordinates",-1554273251,null);g3a=new $APP.E(null,"patch-name","patch-name",-1206801829);wWb=new $APP.q("emmy.env","pullback","emmy.env/pullback",1897998867,null);xWb=new $APP.E(null,"-\x3eexpression","-\x3eexpression",1358975351);yWb=new $APP.q(null,"substitute","substitute",-1998578400,null);zWb=new $APP.q("emmy.env","coordinate-origin","emmy.env/coordinate-origin",2009553427,null);
AWb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57471","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57471",-1248306625,null);BWb=new $APP.q(null,"flow-transform","flow-transform",1928355832,null);CWb=new $APP.q("emmy.numsymb","*incremental-simplifier*","emmy.numsymb/*incremental-simplifier*",-888049217,null);qE=new $APP.q(null,"prototype","prototype",519166522,null);DWb=new $APP.q("emmy.mechanics.rigid","T-rigid-body","emmy.mechanics.rigid/T-rigid-body",-477732325,null);
EWb=new $APP.q("emmy.quaternion","yaw","emmy.quaternion/yaw",-960135622,null);FWb=new $APP.q("emmy.numerical.unimin.bracket","bracket-min","emmy.numerical.unimin.bracket/bracket-min",547264931,null);GWb=new $APP.q("emmy.calculus.basis","basis?","emmy.calculus.basis/basis?",142229276,null);HWb=new $APP.q("emmy.env","argument-types","emmy.env/argument-types",-67750953,null);IWb=new $APP.q(null,"Dt-procedure","Dt-procedure",-1264845613,null);
JWb=new $APP.q(null,"INumericTower","INumericTower",-60503966,null);KWb=new $APP.q(null,"evenly-divide","evenly-divide",-2140597052,null);XTa=new $APP.E(null,"qualifier","qualifier",125841738);LWb=new $APP.q("emmy.pattern.match","matcher","emmy.pattern.match/matcher",197340969,null);MWb=new $APP.q(null,"log-contract","log-contract",-590272403,null);NWb=new $APP.q(null,"emmy.calculus.connection","emmy.calculus.connection",-560921033,null);
dP=new $APP.E("emmy.calculus.form-field","form-field","emmy.calculus.form-field/form-field",1983687851);OWb=new $APP.q(null,"validate-mode!","validate-mode!",-1971203371,null);PWb=new $APP.q("emmy.env","down","emmy.env/down",-34406874,null);QWb=new $APP.q("emmy.structure","-\x3eStructure","emmy.structure/-\x3eStructure",-43709489,null);RWb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57440","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57440",-1780311504,null);
SWb=new $APP.q(null,"C-\x3eCp","C-\x3eCp",-896239631,null);TWb=new $APP.q(null,"manifold-family?","manifold-family?",-175083464,null);UWb=new $APP.q(null,"canonical-K?","canonical-K?",1986971077,null);iX=new $APP.q(null,"ncols","ncols",1256712774,null);R6a=new $APP.E(null,"term","term",-1817390416);bRa=new $APP.E(null,"dot-action","dot-action",-1460119601);VWb=new $APP.q("cljs.core","checked-aset","cljs.core/checked-aset",-2080232353,null);
WWb=new $APP.q("emmy.util","bigint?","emmy.util/bigint?",-2014820488,null);XWb=new $APP.q("emmy.env","log10","emmy.env/log10",1987722014,null);YWb=new $APP.q(null,"-tau","-tau",-286798365,null);ZWb=new $APP.q(null,"-\x3ePowerSeries","-\x3ePowerSeries",-1598045772,null);$Wb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57430","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57430",1796164666,null);
aXb=new $APP.q("emmy.numerical.unimin.golden","golden-cut","emmy.numerical.unimin.golden/golden-cut",-1076889107,null);bXb=new $APP.q("emmy.calculus.frame","-\x3et_emmy$calculus$frame49168","emmy.calculus.frame/-\x3et_emmy$calculus$frame49168",-1676487044,null);cXb=new $APP.q(null,"*angle-axis-tolerance*","*angle-axis-tolerance*",2006721849,null);dXb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57458","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57458",1217214005,null);
eXb=new $APP.q("emmy.mechanics.lagrange","Q","emmy.mechanics.lagrange/Q",1745129875,null);fXb=new $APP.q(null,"L-body-Euler","L-body-Euler",-2040106128,null);gXb=new $APP.q(null,"canonical-H?","canonical-H?",-405611558,null);hXb=new $APP.q("emmy.env","Lagrangian-action","emmy.env/Lagrangian-action",695056082,null);iXb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57463","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57463",1460171786,null);
jXb=new $APP.q(null,"attempt?","attempt?",-1773174546,null);kXb=new $APP.q(null,"s:solve-linear-right","s:solve-linear-right",1060089768,null);lXb=new $APP.q("emmy.env","S2p","emmy.env/S2p",-259630439,null);mXb=new $APP.q("emmy.generic","cosh","emmy.generic/cosh",-1228467059,null);nXb=new $APP.q("emmy.calculus.curvature","curvature-components","emmy.calculus.curvature/curvature-components",-1904819046,null);
oXb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57448","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57448",-1508806582,null);pXb=new $APP.q(null,"Routhian-\x3eacceleration","Routhian-\x3eacceleration",1211175498,null);qXb=new $APP.q(null,"transfer-point","transfer-point",-1401040996,null);rXb=new $APP.q("emmy.calculus.covariant","Cartan-\x3ebasis","emmy.calculus.covariant/Cartan-\x3ebasis",1780360992,null);
sXb=new $APP.q(null,"machine-epsilon","machine-epsilon",437133340,null);tXb=new $APP.q(null,"cylindrical","cylindrical",218572202,null);uXb=new $APP.q(null,"biginteger","biginteger",1355108809,null);vXb=new $APP.q(null,"gcd-Dp","gcd-Dp",-1099248144,null);wXb=new $APP.q("emmy.value","within","emmy.value/within",1077000489,null);xXb=new $APP.q("emmy.generic","coth","emmy.generic/coth",-1398977791,null);
yXb=new $APP.q(null,"two-particle-center-of-mass-canonical","two-particle-center-of-mass-canonical",-102541166,null);zXb=new $APP.q(null,"tanc","tanc",-1009303983,null);AXb=new $APP.q(null,"leading-base-coefficient","leading-base-coefficient",1172071111,null);BXb=new $APP.q("emmy.env","manifold-family?","emmy.env/manifold-family?",-1225639795,null);CXb=new $APP.q("emmy.env","four-tuple-\x3espace","emmy.env/four-tuple-\x3espace",1009030027,null);
DXb=new $APP.q("emmy.env","Gram-Schmidt","emmy.env/Gram-Schmidt",-317937621,null);EXb=new $APP.q(null,"tan-series","tan-series",-96331392,null);FXb=new $APP.q("emmy.env","sec","emmy.env/sec",-554488407,null);tH=new $APP.q(null,"-pi-over-2","-pi-over-2",-1344612268,null);GXb=new $APP.q("emmy.polynomial","contract","emmy.polynomial/contract",1054811430,null);qK=new $APP.q(null,"-pi-over-4","-pi-over-4",-640936368,null);
HXb=new $APP.q("emmy.series","atan-series","emmy.series/atan-series",1786308410,null);jX=new $APP.q(null,"invert","invert",-1100858266,null);IXb=new $APP.q(null,"REVERSE-MODE","REVERSE-MODE",1173981818,null);$APP.kX=new $APP.q(null,"scale","scale",1410104174,null);JXb=new $APP.q("emmy.mechanics.rigid","Euler-state-\x3eL-space","emmy.mechanics.rigid/Euler-state-\x3eL-space",1878812671,null);
KXb=new $APP.q("emmy.calculus.covariant","Christoffel-\x3ebasis","emmy.calculus.covariant/Christoffel-\x3ebasis",-979638843,null);LXb=new $APP.E("cljs.analyzer","access","cljs.analyzer/access",-1639036494);MXb=new $APP.q("emmy.sr.frames","boost-direction","emmy.sr.frames/boost-direction",622867622,null);lX=new $APP.E(null,"adaptive-bulirsch-stoer","adaptive-bulirsch-stoer",1102962876);NXb=new $APP.E(null,"protocol-duped-method","protocol-duped-method",15128166);
OXb=new $APP.q(null,"stirling-second-kind","stirling-second-kind",-1632116686,null);PXb=new $APP.q("emmy.pattern.rule","term-rewriting","emmy.pattern.rule/term-rewriting",542746664,null);QXb=new $APP.q("emmy.mechanics.routhian","Routh-equations","emmy.mechanics.routhian/Routh-equations",1721729330,null);RXb=new $APP.q("emmy.value","twopi","emmy.value/twopi",1284081997,null);SXb=new $APP.q(null,"fold-\x3esum-fn","fold-\x3esum-fn",323282874,null);
TXb=new $APP.q(null,"trig:product-\x3esum","trig:product-\x3esum",-715536960,null);mX=new $APP.q(null,"Quaternion","Quaternion",-1494551228,null);UXb=new $APP.q("emmy.env","raise","emmy.env/raise",-1855157007,null);VXb=new $APP.q("emmy.env","Christoffel-\x3ebasis","emmy.env/Christoffel-\x3ebasis",-270700167,null);WXb=new $APP.q("emmy.env","sin","emmy.env/sin",-1422271296,null);XXb=new $APP.E(null,"spherical-cylindrical","spherical-cylindrical",-1256191895);
YXb=new $APP.q("emmy.mechanics.lagrange","local-state-derivative","emmy.mechanics.lagrange/local-state-derivative",1351499178,null);ZXb=new $APP.q(null,"sinh-series","sinh-series",-143264485,null);$Xb=new $APP.q(null,"general-boost2","general-boost2",317456793,null);aYb=new $APP.q("emmy.util","throwable?","emmy.util/throwable?",1821279386,null);bYb=new $APP.q("emmy.modint","make","emmy.modint/make",-680305517,null);cYb=new $APP.q(null,"with-active-tag","with-active-tag",-1658062207,null);
dYb=new $APP.q("emmy.env","S3-tilted","emmy.env/S3-tilted",1353557674,null);eYb=new $APP.q(null,"sec-series","sec-series",1948327208,null);nX=new $APP.q(null,"quotient","quotient",-1029733218,null);fYb=new $APP.q(null,"rule*","rule*",-1143211614,null);gYb=new $APP.q(null,"corresponding-velocities","corresponding-velocities",-250568131,null);hYb=new $APP.q(null,"tanh-series","tanh-series",-1681700087,null);$APP.iYb=new $APP.E(null,"generic-params?","generic-params?",918310827);
jYb=new $APP.q("emmy.function","I","emmy.function/I",834238296,null);kYb=new $APP.q(null,"symbolic-operator","symbolic-operator",-644006930,null);oX=new $APP.q(null,"modints","modints",-142681111,null);lYb=new $APP.q(null,"make-analyzer","make-analyzer",1003266453,null);mYb=new $APP.q(null,"components-\x3eoneform-field","components-\x3eoneform-field",997325256,null);nYb=new $APP.q(null,"function?","function?",1729250129,null);fVa=new $APP.E(null,"?msg-fmt","?msg-fmt",-852453891);
oYb=new $APP.q("emmy.structure","valid-orientation?","emmy.structure/valid-orientation?",-1697867716,null);pYb=new $APP.q(null,"numeric-zero?","numeric-zero?",-636661046,null);qYb=new $APP.q("emmy.env","claim","emmy.env/claim",2051797457,null);rYb=new $APP.q("emmy.env","symmetrize-Christoffel","emmy.env/symmetrize-Christoffel",-253603322,null);pX=new $APP.q(null,"rules","rules",-1455523403,null);qX=new $APP.q(null,"tanh","tanh",480481797,null);
sYb=new $APP.q("emmy.quaternion","-\x3e4x4-matrix","emmy.quaternion/-\x3e4x4-matrix",-948191528,null);tYb=new $APP.q("emmy.env","literal-function","emmy.env/literal-function",-303807549,null);uYb=new $APP.q("emmy.polynomial","linear","emmy.polynomial/linear",-96337642,null);vYb=new $APP.q(null,"emmy.numerical.unimin.brent","emmy.numerical.unimin.brent",1839875438,null);J4a=new $APP.E(null,"oneform-basis","oneform-basis",-1252585473);
wYb=new $APP.q(null,"bracket-step-fn","bracket-step-fn",2063745685,null);rX=new $APP.q(null,"target-coordsys","target-coordsys",-1758011714,null);xYb=new $APP.q(null,"n-terms","n-terms",670229723,null);yYb=new $APP.q("emmy.calculus.vector-field","basis-components-\x3evector-field","emmy.calculus.vector-field/basis-components-\x3evector-field",-957459114,null);zYb=new $APP.q("emmy.mechanics.rotation","rotate-z-matrix","emmy.mechanics.rotation/rotate-z-matrix",1057448981,null);
AYb=new $APP.q("emmy.quaternion","from-4x4-matrix","emmy.quaternion/from-4x4-matrix",610184733,null);BYb=new $APP.q("emmy.numsymb","arctan?","emmy.numsymb/arctan?",1979965424,null);CYb=new $APP.E(null,"extending-base-js-type","extending-base-js-type",432787264);DYb=new $APP.q(null,"constant-promotion","constant-promotion",-1000242423,null);EYb=new $APP.q("emmy.calculus.frame","params","emmy.calculus.frame/params",-1036035145,null);
FYb=new $APP.q("emmy.numsymb","iterated-derivative?","emmy.numsymb/iterated-derivative?",1569175162,null);kPa=new $APP.E(null,"optimizations","optimizations",-2047476854);GYb=new $APP.q(null,"tolerance-in-ulps","tolerance-in-ulps",-736814321,null);HYb=new $APP.q(null,"yaw","yaw",-151366862,null);IYb=new $APP.q("cljs.core","record?","cljs.core/record?",1307655860,null);JYb=new $APP.q("emmy.numerical.unimin.bracket","bracket-step-fn","emmy.numerical.unimin.bracket/bracket-step-fn",-328691295,null);
KYb=new $APP.E(null,"deftype","deftype",340294561);DM=new $APP.E("emmy.rational-function","rational-function","emmy.rational-function/rational-function",282911607);LYb=new $APP.q("emmy.simplify.rules","magnitude","emmy.simplify.rules/magnitude",346952065,null);MYb=new $APP.q(null,"column-matrix-\x3evector","column-matrix-\x3evector",2109025131,null);sX=new $APP.q(null,"c-\x3ee","c-\x3ee",366611773,null);NYb=new $APP.q("emmy.quaternion","scale-l","emmy.quaternion/scale-l",838633755,null);
PE=new $APP.E(null,"body?","body?",-1333761917);OYb=new $APP.q(null,"R4-rect","R4-rect",1343116656,null);PYb=new $APP.q("emmy.algebra.fold","kahan-babushka-klein","emmy.algebra.fold/kahan-babushka-klein",1088587135,null);FVa=new $APP.E(null,"inherit","inherit",-1840815422);QYb=new $APP.q(null,"univariate-\x3edense","univariate-\x3edense",1461492071,null);RYb=new $APP.q("emmy.env","symplectic-transform?","emmy.env/symplectic-transform?",-1727337058,null);
SYb=new $APP.q(null,"*inverse-simplify?*","*inverse-simplify?*",2101097792,null);TYb=new $APP.q(null,"emmy.calculus.vector-field","emmy.calculus.vector-field",-119658085,null);UYb=new $APP.q("emmy.util.permute","permutations","emmy.util.permute/permutations",-1504080722,null);VYb=new $APP.q(null,"neville-recursive","neville-recursive",-641526016,null);WYb=new $APP.q("emmy.polynomial.gcd","with-limited-time","emmy.polynomial.gcd/with-limited-time",237969530,null);
FG=new $APP.E("emmy.value","real","emmy.value/real",-1508349404);XYb=new $APP.q(null,"emmy.generic","emmy.generic",-958738397,null);YYb=new $APP.q("emmy.mechanics.lagrange","Rayleigh-dissipation","emmy.mechanics.lagrange/Rayleigh-dissipation",1981989847,null);ZYb=new $APP.q("clojure.core","rem","clojure.core/rem",-160175829,null);$Yb=new $APP.q(null,"terms","terms",83553549,null);aZb=new $APP.q(null,"unquoted-form","unquoted-form",-910654799,null);
tX=new $APP.q(null,"inner-product","inner-product",-1963110418,null);bZb=new $APP.q(null,"target","target",1893533248,null);y4a=new $APP.q(null,"unnamed-1form-field","unnamed-1form-field",-518922876,null);uX=new $APP.q(null,"maxfun","maxfun",1590229713,null);cZb=new $APP.q("emmy.matrix","s:solve-linear-left","emmy.matrix/s:solve-linear-left",397138982,null);dZb=new $APP.q(null,"four-tuple-\x3espace","four-tuple-\x3espace",-4527322,null);
vX=new $APP.q(null,"embedding-dimension","embedding-dimension",-1284849802,null);eZb=new $APP.q(null,"emmy.rational-function","emmy.rational-function",1375834807,null);fZb=new $APP.q(null,"-\x3estate","-\x3estate",-1734302196,null);gZb=new $APP.q("emmy.dual","with-active-tag","emmy.dual/with-active-tag",-1374483221,null);hZb=new $APP.q("emmy.env","function-\x3eoneform-field","emmy.env/function-\x3eoneform-field",2116304673,null);
wX=new $APP.q("cljs.core","IIterable","cljs.core/IIterable",178674073,null);xX=new $APP.q("emmy.calculus.frame","IFrame","emmy.calculus.frame/IFrame",-1712074664,null);iZb=new $APP.q("emmy.calculus.manifold","SO3","emmy.calculus.manifold/SO3",-601633155,null);jZb=new $APP.q("emmy.env","Lie-transform","emmy.env/Lie-transform",883253732,null);kZb=new $APP.q("emmy.simplify.rules","*commute-partials?*","emmy.simplify.rules/*commute-partials?*",1616304717,null);
lZb=new $APP.q("emmy.pattern.rule","n-times","emmy.pattern.rule/n-times",747549053,null);oQ=new $APP.E(null,"maxfun","maxfun",-50301814);mZb=new $APP.q(null,"procedure","procedure",1817254099,null);yX=new $APP.E(null,"ns-name","ns-name",-2077346323);nZb=new $APP.q("emmy.env","determinant","emmy.env/determinant",-1685568089,null);oZb=new $APP.q(null,"merge-fn","merge-fn",-2066368428,null);TPa=new $APP.q("cljs.core","instance?","cljs.core/instance?",2044751870,null);
pZb=new $APP.q("emmy.env","metric:invert","emmy.env/metric:invert",392005322,null);qZb=new $APP.q("emmy.calculus.metric","S2-metric","emmy.calculus.metric/S2-metric",1230212191,null);rZb=new $APP.q(null,"numsymb-atan","numsymb-atan",-1523379191,null);sZb=new $APP.q("emmy.env","oneform-field-\x3ecomponents","emmy.env/oneform-field-\x3ecomponents",1251479665,null);tZb=new $APP.q("emmy.calculus.connection","structure-constant","emmy.calculus.connection/structure-constant",901785429,null);
uZb=new $APP.E(null,"step","step",1288888124);vZb=new $APP.q(null,"frame-name","frame-name",738489072,null);wZb=new $APP.q("emmy.env","vector-basis-\x3edual","emmy.env/vector-basis-\x3edual",-1302841887,null);xZb=new $APP.q("emmy.env","column-matrix","emmy.env/column-matrix",2099472349,null);yZb=new $APP.q(null,"time-independent-canonical?","time-independent-canonical?",-605708243,null);zZb=new $APP.q("emmy.env","SO3-type","emmy.env/SO3-type",-1376896483,null);
AZb=new $APP.q("emmy.algebra.fold","min","emmy.algebra.fold/min",-1610507122,null);BZb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57421","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57421",-1814747554,null);zX=new $APP.q("cljs.core","IEmptyableCollection","cljs.core/IEmptyableCollection",5045035,null);CZb=new $APP.q("emmy.util","map-vals","emmy.util/map-vals",-28018698,null);DZb=new $APP.q(null,"down-of-ups?","down-of-ups?",2140316834,null);
yQa=new $APP.E(null,"loop","loop",-395552849);EZb=new $APP.q("emmy.polynomial","negative?","emmy.polynomial/negative?",1104586968,null);FZb=new $APP.q("emmy.numerical.unimin.bracket","bracket-max","emmy.numerical.unimin.bracket/bracket-max",1650860334,null);GZb=new $APP.q("emmy.env","make-Cartan","emmy.env/make-Cartan",-1490146795,null);HZb=new $APP.q("emmy.pattern.match","match-if","emmy.pattern.match/match-if",1603702515,null);
IZb=new $APP.q("emmy.mechanics.noether","Noether-integral","emmy.mechanics.noether/Noether-integral",147652014,null);JZb=new $APP.q("emmy.env","general-boost2","emmy.env/general-boost2",1569638698,null);KZb=new $APP.q(null,"make-diagonal","make-diagonal",-970636127,null);KTa=new $APP.q("cljs.core","\x3e\x3d","cljs.core/\x3e\x3d",350096541,null);LZb=new $APP.q("emmy.calculus.manifold","-\x3et_emmy$calculus$manifold57410","emmy.calculus.manifold/-\x3et_emmy$calculus$manifold57410",1006160627,null);
MZb=new $APP.q("emmy.calculus.metric","metric-over-map","emmy.calculus.metric/metric-over-map",1937934396,null);NZb=new $APP.q(null,"Hamilton-equations","Hamilton-equations",655898383,null);OZb=new $APP.q(null,"expression-\x3estring","expression-\x3estring",-956224851,null);PZb=new $APP.q(null,"f-name","f-name",-825059691,null);QZb=new $APP.q("emmy.ratio","ratio?","emmy.ratio/ratio?",-242905704,null);FRa=new $APP.E(null,"quoted?","quoted?",1464649621);
aYa=new $APP.E("emmy.pattern.match","segment?","emmy.pattern.match/segment?",-1563429454);RZb=new $APP.q(null,"num-rows","num-rows",2047176513,null);SZb=new $APP.q(null,"Euler-state-\x3eL-space","Euler-state-\x3eL-space",-378458455,null);TZb=new $APP.q("emmy.util","uuid","emmy.util/uuid",-24411268,null);UZb=new $APP.q("emmy.env","structure-\x3etyped","emmy.env/structure-\x3etyped",-757645765,null);
VZb=new $APP.q("emmy.pattern.consequence","compile-skeleton","emmy.pattern.consequence/compile-skeleton",1472561534,null);WZb=new $APP.q(null,"cos-sq-\x3esin-sq","cos-sq-\x3esin-sq",990466072,null);AX=new $APP.q(null,"negative?","negative?",374534410,null);XZb=new $APP.q(null,"-\x3estr","-\x3estr",-457137396,null);BX=new $APP.E(null,"sci?","sci?",2029704845);YZb=new $APP.q(null,"R3-spherical","R3-spherical",934549319,null);ZZb=new $APP.q(null,"generic-sum","generic-sum",800077806,null);
lVa=new $APP.E(null,"?file","?file",1533429675);$Zb=new $APP.q(null,"pullback-form","pullback-form",1098147136,null);a_b=new $APP.q(null,"neville-sum","neville-sum",-1107691511,null);EOa=new $APP.E(null,"js-dependency-index","js-dependency-index",-1887042131);b_b=new $APP.q(null,"choice*","choice*",-40649013,null);POa=new $APP.E(null,"undeclared-ns","undeclared-ns",-1589012812);c_b=new $APP.q(null,"transpose-function","transpose-function",45049194,null);
d_b=new $APP.q("emmy.calculus.covariant","Christoffel-\x3esymbols","emmy.calculus.covariant/Christoffel-\x3esymbols",1533974164,null);MPa=new $APP.q(null,".-cljs$lang$test",".-cljs$lang$test",718963148,null);CX=new $APP.q("emmy.simplify","*rf-simplify*","emmy.simplify/*rf-simplify*",-1340102255,null);e_b=new $APP.q("emmy.mechanics.lagrange","time","emmy.mechanics.lagrange/time",1463162485,null);f_b=new $APP.q("Math","acosh","Math/acosh",-2007025431,null);
g_b=new $APP.q("emmy.env","coordinate","emmy.env/coordinate",497866413,null);h_b=new $APP.q(null,"pseudo-remainder","pseudo-remainder",-1008273201,null);i_b=new $APP.E(null,"Euler","Euler",-773634476);j_b=new $APP.q("s","valid-orientation?","s/valid-orientation?",1508040722,null);k_b=new $APP.q("cljs.core","ITaggedLiteral","cljs.core/ITaggedLiteral",-1236965094,null);l_b=new $APP.E(null,"frame","frame",-1711082588);
m_b=new $APP.q("emmy.rational-function","-\x3eRationalFunction","emmy.rational-function/-\x3eRationalFunction",-1177410016,null);n_b=new $APP.q(null,"literal-number?","literal-number?",-1668954321,null);o_b=new $APP.q("emmy.simplify.rules","*aggressive-atan-simplify?*","emmy.simplify.rules/*aggressive-atan-simplify?*",443502472,null);p_b=new $APP.q("emmy.calculus.vector-field","coordinate-basis-vector-field","emmy.calculus.vector-field/coordinate-basis-vector-field",-155853334,null);
$APP.DX=new $APP.q(null,"axis","axis",425140705,null);q_b=new $APP.q("emmy.generic","cube","emmy.generic/cube",-54907240,null);gSa=new $APP.E(null,"js-object","js-object",1830199158);r_b=new $APP.q("emmy.generic","divide","emmy.generic/divide",62869867,null);nUa=new $APP.E(null,"spec","spec",347520401);s_b=new $APP.q("emmy.env","acsch","emmy.env/acsch",-415577575,null);t_b=new $APP.q(null,"-\x3efunction","-\x3efunction",267614160,null);
u_b=new $APP.q("emmy.env","typical-coords","emmy.env/typical-coords",-1155038391,null);v_b=new $APP.q("emmy.env","rotate-x-matrix","emmy.env/rotate-x-matrix",-2058569071,null);w_b=new $APP.q("emmy.simplify.rules","*sqrt-expt-simplify?*","emmy.simplify.rules/*sqrt-expt-simplify?*",713867908,null);x_b=new $APP.q("emmy.calculus.manifold","S1-tilted","emmy.calculus.manifold/S1-tilted",-1260834007,null);$APP.EX=new $APP.q("cljs.core","map","cljs.core/map",-338988913,null);
y_b=new $APP.q("emmy.calculus.manifold","S2p-spherical","emmy.calculus.manifold/S2p-spherical",355633914,null);z_b=new $APP.q(null,"add-v:cs","add-v:cs",939327354,null);A_b=new $APP.q(null,"s:divide-by-structure","s:divide-by-structure",-459494025,null);B_b=new $APP.q(null,"solve-linear","solve-linear",481545288,null);C_b=new $APP.q("emmy.structure","two-down?","emmy.structure/two-down?",-452398802,null);D_b=new $APP.q("emmy.calculus.metric","invert","emmy.calculus.metric/invert",-1249976488,null);
E_b=new $APP.q("emmy.env","SR-name","emmy.env/SR-name",594445252,null);F_b=new $APP.q(null,"pipe*","pipe*",-1519243240,null);G_b=new $APP.q("emmy.pattern.syntax","reverse-segment?","emmy.pattern.syntax/reverse-segment?",1834546852,null);H_b=new $APP.q(null,"general-boost","general-boost",-313944893,null);I_b=new $APP.q("emmy.util.stream","separatev","emmy.util.stream/separatev",-147050291,null);J_b=new $APP.q("emmy.env","Cartan-\x3eChristoffel","emmy.env/Cartan-\x3eChristoffel",585019648,null);
K_b=new $APP.q("emmy.polynomial","monic?","emmy.polynomial/monic?",1080857753,null);L_b=new $APP.q(null,"bulirsch-stoer","bulirsch-stoer",-1970651209,null);M_b=new $APP.q("emmy.series","arg-shift","emmy.series/arg-shift",833721084,null);N_b=new $APP.q(null,"sinhc","sinhc",-1445515294,null);O_b=new $APP.q("emmy.env","exp","emmy.env/exp",747203716,null);P_b=new $APP.q("emmy.calculus.manifold","S2-Riemann","emmy.calculus.manifold/S2-Riemann",-154789983,null);
Q_b=new $APP.q("emmy.pattern.rule","branch","emmy.pattern.rule/branch",-1395715698,null);R_b=new $APP.q("emmy.env","S3-gnomonic","emmy.env/S3-gnomonic",-867872885,null);S_b=new $APP.q("emmy.mechanics.lagrange","L-Kepler-polar","emmy.mechanics.lagrange/L-Kepler-polar",-824230560,null);T_b=new $APP.q(null,"ccs","ccs",2099570085,null);U_b=new $APP.q("emmy.env","numerical?","emmy.env/numerical?",-675960418,null);
V_b=new $APP.q("emmy.simplify.rules","split-high-degree-sincos","emmy.simplify.rules/split-high-degree-sincos",-92455769,null);Q6a=new $APP.E(null,"unary-minus","unary-minus",737624832);W_b=new $APP.q("emmy.util.aggregate","scan","emmy.util.aggregate/scan",644736072,null);X_b=new $APP.q("emmy.env","torsion","emmy.env/torsion",1073906108,null);Y_b=new $APP.q("emmy.calculus.manifold","manifold?","emmy.calculus.manifold/manifold?",592406266,null);
Z_b=new $APP.q("emmy.pattern.match","failure","emmy.pattern.match/failure",1236312317,null);$_b=new $APP.q("emmy.expression.compile","sci-eval","emmy.expression.compile/sci-eval",270375637,null);a0b=new $APP.q("emmy.pattern.rule","pattern*","emmy.pattern.rule/pattern*",1606954511,null);b0b=new $APP.q(null,"emmy.mechanics.routhian","emmy.mechanics.routhian",-18871499,null);c0b=new $APP.q("emmy.mechanics.hamilton","canonical-transform?","emmy.mechanics.hamilton/canonical-transform?",184573576,null);
d0b=new $APP.q("emmy.env","components-\x3emetric","emmy.env/components-\x3emetric",-462332794,null);e0b=new $APP.q("emmy.simplify.rules","flush-obvious-ones","emmy.simplify.rules/flush-obvious-ones",-1550927165,null);f0b=new $APP.q(null,"meta48684","meta48684",1261883463,null);g0b=new $APP.q("js","RegExp","js/RegExp",1778210562,null);h0b=new $APP.q("emmy.env","typical-point","emmy.env/typical-point",-57933656,null);i0b=new $APP.q(null,"SO3","SO3",-1478144109,null);
j0b=new $APP.q(null,"pullback-function","pullback-function",811870172,null);k0b=new $APP.q(null,"structure-\x3eprototype","structure-\x3eprototype",927102475,null);l0b=new $APP.q("emmy.complex","-I","emmy.complex/-I",1778981724,null);m0b=new $APP.q("emmy.operator","name","emmy.operator/name",-1936818318,null);n0b=new $APP.q(null,"objects","objects",-554722035,null);o0b=new $APP.q(null,"D-forward","D-forward",-20106674,null);
p0b=new $APP.q(null,"Hamiltonian-\x3eLagrangian","Hamiltonian-\x3eLagrangian",-1691416956,null);q0b=new $APP.q("emmy.calculus.indexed","structure-\x3etyped","emmy.calculus.indexed/structure-\x3etyped",-2094967225,null);OM=new $APP.q(null,"cot","cot",-1635649012,null);uH=new $APP.q(null,"cos","cos",-1452677493,null);r0b=new $APP.q(null,"S1-tilted","S1-tilted",1914352915,null);s0b=new $APP.q(null,"as-attempt","as-attempt",-1258923575,null);
t0b=new $APP.q("emmy.env","derivative","emmy.env/derivative",-236606619,null);u0b=new $APP.q(null,"qp-submatrix","qp-submatrix",1695903452,null);FX=new $APP.q(null,"symbols","symbols",1641743270,null);v0b=new $APP.q("emmy.sr.frames","SR-name","emmy.sr.frames/SR-name",971953516,null);w0b=new $APP.q(null,"emmy.polynomial.gcd","emmy.polynomial.gcd",-949784554,null);D4a=new $APP.q(null,"Alt","Alt",-1183702663,null);
x0b=new $APP.q(null,"emmy.numerical.multimin.nelder-mead","emmy.numerical.multimin.nelder-mead",-97174390,null);ITa=new $APP.q(null,"sum__38623__auto__","sum__38623__auto__",-1715001268,null);DE=new $APP.E(null,"rename-macros","rename-macros",1076432512);y0b=new $APP.q("emmy.env","S2-stereographic","emmy.env/S2-stereographic",-1165975109,null);z0b=new $APP.q("emmy.env","linear-interpolants","emmy.env/linear-interpolants",1045998745,null);
A0b=new $APP.q("emmy.rational-function","arity","emmy.rational-function/arity",165977631,null);B0b=new $APP.q("emmy.calculus.manifold","R1-rect","emmy.calculus.manifold/R1-rect",-2128452746,null);C0b=new $APP.q(null,"compare-full","compare-full",-1384935832,null);GX=new $APP.q(null,"tqv","tqv",-1233922921,null);D0b=new $APP.q(null,"quaternion","quaternion",-808610151,null);HX=new $APP.q(null,"arg-shift","arg-shift",-382841075,null);rOa=new $APP.E("clojure.error","source","clojure.error/source",-2011936397);
xWa=new $APP.E(null,"one-like","one-like",887133720);E0b=new $APP.q("emmy.env","S1-circular","emmy.env/S1-circular",968818019,null);F0b=new $APP.q(null,"H-harmonic","H-harmonic",881633245,null);fRa=new $APP.E(null,"warn-type","warn-type",-790105219);G0b=new $APP.q(null,"log-extra","log-extra",-1713077798,null);H0b=new $APP.q(null,"elliptic-pi","elliptic-pi",-78943475,null);I0b=new $APP.q(null,"bs-prepare","bs-prepare",-1806775766,null);GRa=new $APP.E(null,"def-var","def-var",-698214377);
J0b=new $APP.q("emmy.util","exception","emmy.util/exception",-1125365357,null);K0b=new $APP.q("emmy.env","literal-Christoffel-1","emmy.env/literal-Christoffel-1",-1177081599,null);L0b=new $APP.q("emmy.env","-\x3eJavaScript","emmy.env/-\x3eJavaScript",-1569654075,null);M0b=new $APP.q("emmy.env","literal-Christoffel-2","emmy.env/literal-Christoffel-2",1611336401,null);IX=new $APP.q(null,"dot-product","dot-product",-203055892,null);
N0b=new $APP.q(null,"emmy.pattern.rule","emmy.pattern.rule",1311400615,null);O0b=new $APP.q("emmy.calculus.indexed","with-index-types","emmy.calculus.indexed/with-index-types",-1256331971,null);P0b=new $APP.q(null,"by-cols*","by-cols*",1865655980,null);Q0b=new $APP.q(null,"vector-dot-product","vector-dot-product",433547396,null);R0b=new $APP.q(null,"revert","revert",656545594,null);S0b=new $APP.q("emmy.pattern.rule","attempt","emmy.pattern.rule/attempt",-1854835985,null);
T0b=new $APP.q("emmy.operator","expn","emmy.operator/expn",1368721850,null);U0b=new $APP.E(null,"numerator","numerator",-160761104);V0b=new $APP.q(null,"emmy.series","emmy.series",1477801845,null);W0b=new $APP.q(null,"Gram-Schmidt","Gram-Schmidt",-1549606410,null);X0b=new $APP.q("emmy.matrix","dimension","emmy.matrix/dimension",1160671846,null);Y0b=new $APP.q(null,"derivative-args","derivative-args",1022399972,null);
Z0b=new $APP.q("emmy.expression.analyze","-\x3eexpression","emmy.expression.analyze/-\x3eexpression",128259950,null);$0b=new $APP.E(null,"dep-path","dep-path",723826558);a1b=new $APP.q(null,"phase-space-derivative","phase-space-derivative",-105121875,null);KPa=new $APP.q(null,"clj","clj",980036099,null);b1b=new $APP.E(null,"single-segment-namespace","single-segment-namespace",-491924469);a3a=new $APP.E(null,"family","family",-1313145692);
c1b=new $APP.q("emmy.env","floor","emmy.env/floor",324561235,null);JX=new $APP.q(null,"??post","??post",1092296697,null);d1b=new $APP.q("emmy.env","components-\x3evector-field","emmy.env/components-\x3evector-field",-105983410,null);e1b=new $APP.q(null,"non-negative-factors!","non-negative-factors!",106433803,null);f1b=new $APP.q(null,"cofactors","cofactors",-589984987,null);KX=new $APP.q(null,"expression-\x3e","expression-\x3e",-916231213,null);g1b=new $APP.E(null,"var-ast","var-ast",1200379319);
$APP.LX=new $APP.q(null,"sub","sub",-453228498,null);h1b=new $APP.q(null,"modified-neville-scan","modified-neville-scan",1947157950,null);i1b=new $APP.q(null,"atanh-series","atanh-series",-1138222374,null);j1b=new $APP.q(null,"rectangular-\x3epolar","rectangular-\x3epolar",937043161,null);k1b=new $APP.q(null,"sum","sum",1777518341,null);l1b=new $APP.q("emmy.generic","acosh","emmy.generic/acosh",-1531863054,null);
m1b=new $APP.q("emmy.calculus.manifold","zero-manifold-function","emmy.calculus.manifold/zero-manifold-function",-1079676127,null);n1b=new $APP.q(null,"parse-bigint","parse-bigint",2129948991,null);MX=new $APP.q("emmy.ratio","rationalize","emmy.ratio/rationalize",2140571274,null);NX=new $APP.q("emmy.calculus.vector-field","coordinate-system-\x3evector-basis","emmy.calculus.vector-field/coordinate-system-\x3evector-basis",-807504210,null);
OX=new $APP.q(null,"metric-tensor","metric-tensor",201092848,null);o1b=new $APP.q(null,"trig-\x3esincos","trig-\x3esincos",1047780302,null);p1b=new $APP.q("emmy.generic","acoth","emmy.generic/acoth",905314862,null);q1b=new $APP.q("emmy.env","v:make-basis-unit","emmy.env/v:make-basis-unit",1498955603,null);r1b=new $APP.E(null,"frame-name","frame-name",-902042455);s1b=new $APP.q(null,"oneform-field-\x3ebasis-components","oneform-field-\x3ebasis-components",524891333,null);
t1b=new $APP.q("emmy.dual","map-\x3eCompleted","emmy.dual/map-\x3eCompleted",1086089032,null);PX=new $APP.E(null,"between","between",1131099276);u1b=new $APP.q("emmy.value","real?","emmy.value/real?",233515503,null);v1b=new $APP.q("emmy.calculus.curvature","Ricci","emmy.calculus.curvature/Ricci",-1017978157,null);w1b=new $APP.q("emmy.calculus.coordinate","using-coordinates","emmy.calculus.coordinate/using-coordinates",340839422,null);
x1b=new $APP.q("emmy.calculus.covariant","Cartan-transform","emmy.calculus.covariant/Cartan-transform",2058003451,null);QX=new $APP.q(null,"alpha","alpha",65549086,null);y1b=new $APP.q("emmy.mechanics.lagrange","Lagrangian-action","emmy.mechanics.lagrange/Lagrangian-action",222123715,null);RX=new $APP.q(null,"negate","negate",337772450,null);z1b=new $APP.q("emmy.structure","compatible-zero","emmy.structure/compatible-zero",633589477,null);A1b=new $APP.q(null,"exp-series","exp-series",965017655,null);
B1b=new $APP.q("emmy.env","Lagrange-equations-first-order","emmy.env/Lagrange-equations-first-order",-46063249,null);C1b=new $APP.q("emmy.mechanics.rigid","qw-state-\x3eL-space","emmy.mechanics.rigid/qw-state-\x3eL-space",-1775007301,null);D1b=new $APP.q(null,"constant-manifold-function","constant-manifold-function",-128826051,null);HPa=new $APP.q(null,"ignore","ignore",8989494,null);E1b=new $APP.q(null,"make-manifold","make-manifold",1553241629,null);
F1b=new $APP.q("emmy.mechanics.lagrange","rectangular-\x3epolar","emmy.mechanics.lagrange/rectangular-\x3epolar",-702186331,null);G1b=new $APP.q("emmy.generic","imag-part","emmy.generic/imag-part",-1809478125,null);H1b=new $APP.q("emmy.env","one?","emmy.env/one?",-1356116672,null);I1b=new $APP.q("emmy.env","sinh","emmy.env/sinh",-2046226859,null);SX=new $APP.q(null,"tolerance","tolerance",2047343345,null);J1b=new $APP.q("emmy.env","sinc","emmy.env/sinc",1560810312,null);
K1b=new $APP.q(null,"freeze","freeze",-610969460,null);L1b=new $APP.q("emmy.ratio","numerator","emmy.ratio/numerator",1333610278,null);M1b=new $APP.q(null,"L-body","L-body",346543391,null);N1b=new $APP.q(null,"parallel-transport-equation","parallel-transport-equation",-355914355,null);O1b=new $APP.q(null,"partial-sums","partial-sums",-1831543974,null);P1b=new $APP.q(null,"S2p","S2p",220470602,null);
Q1b=new $APP.q("emmy.expression.compile","set-compiler-mode!","emmy.expression.compile/set-compiler-mode!",223681889,null);AUa=new $APP.E(null,"raw-console?","raw-console?",-2061489061);dQa=new $APP.E(null,"arg-id","arg-id",-767177868);R1b=new $APP.q("emmy.util","long","emmy.util/long",1152494126,null);S1b=new $APP.q(null,"negative-number?","negative-number?",1763499605,null);T1b=new $APP.q("emmy.pattern.match","failed?","emmy.pattern.match/failed?",1191158064,null);
U1b=new $APP.q(null,"generic-sum-fold","generic-sum-fold",136678028,null);V1b=new $APP.q("emmy.calculus.basis","coordinate-basis?","emmy.calculus.basis/coordinate-basis?",16882539,null);W1b=new $APP.q("emmy.simplify","*poly-simplify*","emmy.simplify/*poly-simplify*",741964388,null);TX=new $APP.q(null,"mu-inverse:M-\x3eN","mu-inverse:M-\x3eN",1931872757,null);X1b=new $APP.q("emmy.env","literal-up","emmy.env/literal-up",869470067,null);Y1b=new $APP.E(null,"redef-in-file","redef-in-file",-476530788);
Z1b=new $APP.q(null,"v2:c","v2:c",1724311857,null);$1b=new $APP.q(null,"neville-fold","neville-fold",-291266752,null);a2b=new $APP.q("emmy.env","event-\x3ecoords","emmy.env/event-\x3ecoords",965005798,null);b2b=new $APP.q("emmy.util.stream","pprint","emmy.util.stream/pprint",1702116860,null);c2b=new $APP.q("emmy.calculus.metric","drop2","emmy.calculus.metric/drop2",1505706076,null);d2b=new $APP.q("emmy.calculus.metric","drop1","emmy.calculus.metric/drop1",1068830376,null);
e2b=new $APP.E("emmy.calculus.derivative","multi","emmy.calculus.derivative/multi",-1645123100);f2b=new $APP.q(null,"kbk-n","kbk-n",-118508308,null);g2b=new $APP.q("u","sqrt-machine-epsilon","u/sqrt-machine-epsilon",-243376683,null);h2b=new $APP.q("emmy.polynomial","lowest-degree","emmy.polynomial/lowest-degree",1856604792,null);i2b=new $APP.q("cljs.core","tagged-literal?","cljs.core/tagged-literal?",-1159666987,null);
j2b=new $APP.q("emmy.pattern.match","update-frame","emmy.pattern.match/update-frame",613740042,null);nK=new $APP.q(null,"tan","tan",-1380825876,null);k2b=new $APP.q("emmy.mechanics.hamilton","canonical-H?","emmy.mechanics.hamilton/canonical-H?",-588882291,null);l2b=new $APP.q("emmy.generic","exact-divide","emmy.generic/exact-divide",-1779568007,null);m2b=new $APP.q(null,"tau","tau",1730314431,null);n2b=new $APP.E(null,"throw","throw",-1044625833);
o2b=new $APP.q(null,"match-if","match-if",-2104618812,null);p2b=new $APP.q(null,"by-rows","by-rows",1662495500,null);q2b=new $APP.q("emmy.env","taylor-series","emmy.env/taylor-series",-473286137,null);UX=new $APP.q(null,"theta","theta",1213021269,null);r2b=new $APP.q(null,"contract-expt-trig","contract-expt-trig",-294579507,null);s2b=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer-sum","emmy.rational-function.interpolate/bulirsch-stoer-sum",-957607949,null);
t2b=new $APP.q(null,"down*","down*",813038101,null);u2b=new $APP.q("Math","exp","Math/exp",1383313257,null);hSa=new $APP.E(null,"js-array","js-array",-1210185421);v2b=new $APP.q("emmy.calculus.derivative","gradient","emmy.calculus.derivative/gradient",-2143065137,null);w2b=new $APP.q(null,"spacetime-rect","spacetime-rect",-779647580,null);$APP.sF=new $APP.E(null,"items","items",1031954938);x2b=new $APP.q(null,"down?","down?",-953416276,null);
FE=new $APP.E(null,"protocol-symbol","protocol-symbol",1279552198);y2b=new $APP.q(null,"fib-series","fib-series",41134027,null);z2b=new $APP.q("emmy.series","power-series","emmy.series/power-series",1699243945,null);A2b=new $APP.q("emmy.polynomial.gcd","-\x3econtent+primitive","emmy.polynomial.gcd/-\x3econtent+primitive",1552903515,null);B2b=new $APP.q(null,"from-points","from-points",-882765250,null);
C2b=new $APP.q("emmy.simplify.rules","sincos-flush-ones","emmy.simplify.rules/sincos-flush-ones",1279089513,null);jUa=new $APP.E(null,"req-id","req-id",-471642231);D2b=new $APP.q("emmy.mechanics.hamilton","canonical-K?","emmy.mechanics.hamilton/canonical-K?",962806032,null);E2b=new $APP.q("emmy.env","principal-value","emmy.env/principal-value",-1240139374,null);F2b=new $APP.q(null,"osculating-path","osculating-path",677457360,null);
G2b=new $APP.q("emmy.env","Laplacian","emmy.env/Laplacian",-149101911,null);H2b=new $APP.q("emmy.numsymb","product?","emmy.numsymb/product?",1361897618,null);I2b=new $APP.E(null,"case","case",1143702196);J2b=new $APP.q(null,"emmy.numerical.derivative","emmy.numerical.derivative",297292057,null);K2b=new $APP.q("emmy.calculus.metric","metric-\x3ecomponents","emmy.calculus.metric/metric-\x3ecomponents",-463638042,null);
L2b=new $APP.q("emmy.pattern.rule","pattern","emmy.pattern.rule/pattern",592549338,null);VX=new $APP.q(null,"coordinate-system-name","coordinate-system-name",-448421652,null);cR=new $APP.q(null,"Lie-derivative","Lie-derivative",-641072185,null);M2b=new $APP.q("emmy.series","asin-series","emmy.series/asin-series",1277951367,null);NM=new $APP.q(null,"sec","sec",60154974,null);oOa=new $APP.E(null,"root-source-info","root-source-info",-1436144912);N2b=new $APP.q(null,"lowrow","lowrow",829607435,null);
O2b=new $APP.q("emmy.mechanics.rotation","rotate-x-matrix","emmy.mechanics.rotation/rotate-x-matrix",403786189,null);P2b=new $APP.q(null,"emmy.complex","emmy.complex",-827099193,null);Q2b=new $APP.q(null,"coordinate-system-names","coordinate-system-names",793552790,null);R2b=new $APP.q("emmy.calculus.manifold","manifold","emmy.calculus.manifold/manifold",627242716,null);S2b=new $APP.q(null,"typical-coords","typical-coords",-29279558,null);
OP=new $APP.q("emmy.structure","down","emmy.structure/down",-104137184,null);T2b=new $APP.E(null,"hi","hi",-1821422114);U2b=new $APP.q("emmy.mechanics.lagrange","L-rectangular","emmy.mechanics.lagrange/L-rectangular",-281349062,null);V2b=new $APP.q("emmy.dual","eq","emmy.dual/eq",770908386,null);W2b=new $APP.q("emmy.env","orientation","emmy.env/orientation",1213531559,null);X2b=new $APP.q("emmy.generic","infinite?","emmy.generic/infinite?",-1270410512,null);
Y2b=new $APP.q("emmy.simplify.rules","constant-promotion","emmy.simplify.rules/constant-promotion",-2078995235,null);Z2b=new $APP.q("emmy.polynomial.impl","*monomial-order*","emmy.polynomial.impl/*monomial-order*",1553049184,null);$2b=new $APP.q("emmy.sr.frames","add-velocities","emmy.sr.frames/add-velocities",433017933,null);a3b=new $APP.q(null,"iterated-derivative?","iterated-derivative?",-1758259757,null);
b3b=new $APP.q("emmy.polynomial.factor","analyzer","emmy.polynomial.factor/analyzer",-766467377,null);c3b=new $APP.q("emmy.calculus.curvature","Riemann-curvature","emmy.calculus.curvature/Riemann-curvature",-1319246385,null);d3b=new $APP.q(null,"Lagrange-equations-1","Lagrange-equations-1",-1918067853,null);e3b=new $APP.q("emmy.rational-function","div","emmy.rational-function/div",-1259121510,null);f3b=new $APP.q("emmy.matrix","submatrix","emmy.matrix/submatrix",-1051104126,null);
g3b=new $APP.q(null,"emmy.modint","emmy.modint",216958365,null);h3b=new $APP.q(null,"const","const",-944505927,null);i3b=new $APP.q(null,"emmy.calculus.covariant","emmy.calculus.covariant",-709530597,null);j3b=new $APP.q("emmy.numerical.derivative","central-difference-d2","emmy.numerical.derivative/central-difference-d2",-45922657,null);k3b=new $APP.q("emmy.env","structure-constant","emmy.env/structure-constant",-287324128,null);WX=new $APP.q(null,"basis?","basis?",1311714792,null);
l3b=new $APP.q(null,"emmy.polynomial","emmy.polynomial",1304101377,null);m3b=new $APP.q(null,"S2-Riemann","S2-Riemann",940087751,null);n3b=new $APP.q("emmy.generic","zero?","emmy.generic/zero?",1202030068,null);o3b=new $APP.q("emmy.calculus.vector-calculus","Div","emmy.calculus.vector-calculus/Div",-2082339375,null);p3b=new $APP.E(null,"kind","kind",-717265803);q3b=new $APP.q("emmy.rational-function","-\x3eexpression","emmy.rational-function/-\x3eexpression",-1497272771,null);
HZa=new $APP.E(null,"inner-orientation","inner-orientation",-728775897);r3b=new $APP.E(null,"initial-h","initial-h",213105060);s3b=new $APP.q(null,"Lagrangian-\x3eenergy","Lagrangian-\x3eenergy",-73689250,null);t3b=new $APP.q("emmy.env","Cartan-\x3eCartan-over-map","emmy.env/Cartan-\x3eCartan-over-map",-187077823,null);u3b=new $APP.q("emmy.env","Lagrangian-\x3epower-loss","emmy.env/Lagrangian-\x3epower-loss",1654119300,null);$APP.XX=new $APP.q(null,"transpose","transpose",1165804847,null);
iF=new $APP.q("cljs.core","Keyword","cljs.core/Keyword",-451434488,null);v3b=new $APP.q(null,"pure?","pure?",1991394218,null);w3b=new $APP.q("emmy.mechanics.lagrange","Qdot","emmy.mechanics.lagrange/Qdot",-535548756,null);x3b=new $APP.q("emmy.polynomial","new-variables","emmy.polynomial/new-variables",-1814008275,null);y3b=new $APP.q(null,"R2-polar","R2-polar",-1569929362,null);$APP.z3b=new $APP.E(null,"dt","dt",-368444759);A3b=new $APP.E(null,"do","do",46310725);
RG=new $APP.E(null,"vargs","vargs",-966597273);p5a=new $APP.q(null,"Lie-D","Lie-D",1269840403,null);B3b=new $APP.q(null,"rotate-x-matrix","rotate-x-matrix",-1071484222,null);C3b=new $APP.q(null,"unary-elimination","unary-elimination",696583795,null);D3b=new $APP.q("cljs.core","checked-aget'","cljs.core/checked-aget'",1960922245,null);E3b=new $APP.q("emmy.matrix","fmap","emmy.matrix/fmap",1078467015,null);F3b=new $APP.E(null,"extend-type-invalid-method-shape","extend-type-invalid-method-shape",1424103549);
e5a=new $APP.q(null,"pushforward","pushforward",-683343030,null);G3b=new $APP.q(null,"inttype","inttype",-1877271282,null);$APP.H3b=new $APP.q(null,"group","group",-2071839637,null);I3b=new $APP.q("emmy.polynomial","-\x3eexpression","emmy.polynomial/-\x3eexpression",222600204,null);J3b=new $APP.q(null,"multidimensional-minimize","multidimensional-minimize",448428381,null);K3b=new $APP.E(null,"replace-tag","replace-tag",-109294055);
L3b=new $APP.q("emmy.quaternion","pitch","emmy.quaternion/pitch",-1964701701,null);YX=new $APP.q(null,"choose","choose",-974232464,null);M3b=new $APP.q("emmy.dual","extract-tangent","emmy.dual/extract-tangent",-2069345116,null);N3b=new $APP.q("emmy.util.permute","combinations","emmy.util.permute/combinations",1176682102,null);O3b=new $APP.q(null,"asech","asech",-316284500,null);lE=new $APP.E(null,"defs","defs",1398449717);
P3b=new $APP.q("emmy.env","compositional-canonical?","emmy.env/compositional-canonical?",844867868,null);Q3b=new $APP.q(null,"compile-fn","compile-fn",-1899745280,null);yK=new $APP.q(null,"?other-op","?other-op",-881473313,null);R3b=new $APP.q("emmy.matrix","cramers-rule","emmy.matrix/cramers-rule",-1466485203,null);S3b=new $APP.q("emmy.env","osculating-path","emmy.env/osculating-path",-158362333,null);T3b=new $APP.q(null,"with-substituted-row","with-substituted-row",-1155079974,null);
U3b=new $APP.q(null,"extract-common-subexpressions","extract-common-subexpressions",-1840588961,null);V3b=new $APP.E(null,"protocol-impl-with-variadic-method","protocol-impl-with-variadic-method",-319321217);ZX=new $APP.q("emmy.expression.analyze","ICanonicalize","emmy.expression.analyze/ICanonicalize",433117116,null);W3b=new $APP.q(null,"complex-2","complex-2",490677522,null);X3b=new $APP.q("emmy.rational-function","eq","emmy.rational-function/eq",-925728373,null);
Y3b=new $APP.q(null,"complex-1","complex-1",-1582732184,null);Z3b=new $APP.q("emmy.polynomial.interpolate","neville-scan","emmy.polynomial.interpolate/neville-scan",-406731484,null);$X=new $APP.q(null,"modulo","modulo",725580254,null);$3b=new $APP.q("emmy.polynomial","leading-base-coefficient","emmy.polynomial/leading-base-coefficient",-1789383243,null);aY=new $APP.E(null,"internal-ctor","internal-ctor",937392560);b3a=new $APP.E(null,"over","over",192553051);
a4b=new $APP.q("emmy.matrix","s:inverse","emmy.matrix/s:inverse",2136163490,null);bY=new $APP.q(null,"Lagrangian","Lagrangian",-1148415573,null);GTa=new $APP.q(null,"accs__38630__auto__","accs__38630__auto__",-2144987472,null);b4b=new $APP.q("emmy.env","S2p-gnomonic","emmy.env/S2p-gnomonic",-1190620738,null);qQ=new $APP.E(null,"converged?","converged?",1779059976);c4b=new $APP.q(null,"Dual","Dual",-234231465,null);d4b=new $APP.q(null,"solve-linear-left","solve-linear-left",1437395114,null);
e4b=new $APP.q(null,"iterated","iterated",1073898993,null);f4b=new $APP.q(null,"submatrix","submatrix",73135469,null);g4b=new $APP.q(null,"sqrt-machine-epsilon","sqrt-machine-epsilon",-243376808,null);h4b=new $APP.E(null,"redef","redef",1032704258);cY=new $APP.q(null,"trace","trace",557784112,null);i4b=new $APP.q("emmy.generic","identity-like","emmy.generic/identity-like",1873486939,null);j4b=new $APP.q("emmy.env","s:generate","emmy.env/s:generate",-1478588552,null);
k4b=new $APP.q(null,"bell-series","bell-series",-1645672484,null);l4b=new $APP.q("emmy.env","trace2up","emmy.env/trace2up",-510812446,null);m4b=new $APP.q(null,"emmy.util.permute","emmy.util.permute",2100059640,null);n4b=new $APP.q(null,"c*xn","c*xn",-1209260317,null);o4b=new $APP.E(null,"ancestor-frame","ancestor-frame",857790116);p4b=new $APP.q("emmy.calculus.covariant","symmetrize-Cartan","emmy.calculus.covariant/symmetrize-Cartan",-1243337097,null);
q4b=new $APP.q(null,"variables-in","variables-in",-1894872826,null);dY=new $APP.q("s","up?","s/up?",1718386486,null);r4b=new $APP.q(null,"column-matrix-\x3eup","column-matrix-\x3eup",-84333969,null);mH=new $APP.q(null,"sin","sin",1721439389,null);s4b=new $APP.q(null,"arctan?","arctan?",167558251,null);EQa=new $APP.E(null,"fns","fns",1185138786);IO=new $APP.E(null,"coordinate-system","coordinate-system",-1298347271);t4b=new $APP.q("cljs.core","Volatile","cljs.core/Volatile",-1098692185,null);
u4b=new $APP.q(null,"Lagrangian-\x3estate-derivative","Lagrangian-\x3estate-derivative",1286195816,null);v4b=new $APP.q(null,"expression-of","expression-of",1790811504,null);w4b=new $APP.q("emmy.mechanics.routhian","Routhian-\x3estate-derivative","emmy.mechanics.routhian/Routhian-\x3estate-derivative",-1454098679,null);x4b=new $APP.q("emmy.env","outer-product","emmy.env/outer-product",-668310695,null);y4b=new $APP.q("emmy.mechanics.hamilton","P","emmy.mechanics.hamilton/P",207000495,null);
z4b=new $APP.E(null,"lo","lo",-931799889);A4b=new $APP.q("emmy.structure","structure-\x3evector","emmy.structure/structure-\x3evector",-1553255508,null);B4b=new $APP.E(null,"catches","catches",-1478797617);C4b=new $APP.q(null,"symbol-generator","symbol-generator",-2079948609,null);D4b=new $APP.q("emmy.env","pushforward-function","emmy.env/pushforward-function",2083395271,null);E4b=new $APP.q(null,"L-central-polar","L-central-polar",-454329389,null);dOa=new $APP.E(null,"if","if",-458814265);
F4b=new $APP.q("emmy.env","up?","emmy.env/up?",684599062,null);eY=new $APP.q(null,"info?","info?",2002457080,null);NQa=new $APP.E(null,"unsynchronized-mutable","unsynchronized-mutable",-164143950);G4b=new $APP.E(null,"in","in",-1531184865);H4b=new $APP.q("emmy.simplify.rules","complex-trig","emmy.simplify.rules/complex-trig",-1420552587,null);I4b=new $APP.q("emmy.env","-\x3eH-state","emmy.env/-\x3eH-state",-402598880,null);
J4b=new $APP.q("emmy.util.permute","permutation-interchanges","emmy.util.permute/permutation-interchanges",1491483874,null);$APP.sE=new $APP.E(null,"js","js",1768080579);fY=new $APP.q(null,"complex","complex",-1238824944,null);K4b=new $APP.q("emmy.mechanics.hamilton","F-\x3eK","emmy.mechanics.hamilton/F-\x3eK",-1290116723,null);L4b=new $APP.q(null,"bottom-up","bottom-up",-2111255600,null);M4b=new $APP.q("emmy.pattern.syntax","variable-name","emmy.pattern.syntax/variable-name",533204310,null);
N4b=new $APP.q("emmy.simplify.rules","universal-reductions","emmy.simplify.rules/universal-reductions",418703513,null);O4b=new $APP.q("emmy.matrix","row*","emmy.matrix/row*",-2066319758,null);XE=new $APP.E(null,"protocols","protocols",-5615896);P4b=new $APP.q("emmy.simplify.rules","exp-expand","emmy.simplify.rules/exp-expand",-1011480890,null);Q4b=new $APP.q(null,"modified-bulirsch-stoer","modified-bulirsch-stoer",1854691701,null);
R4b=new $APP.q(null,"coordinate-system-\x3eorthonormal-vector-basis","coordinate-system-\x3eorthonormal-vector-basis",1168548313,null);S4b=new $APP.q(null,"drop-leading-term","drop-leading-term",-203911633,null);T4b=new $APP.E(null,"xa","xa",-251918777);U4b=new $APP.E(null,"xb","xb",-1641297359);sK=new $APP.q(null,"?op","?op",-135731883,null);V4b=new $APP.E(null,"relative-threshold","relative-threshold",-1866138970);gY=new $APP.q(null,"thunk","thunk",74255732,null);
W4b=new $APP.q("emmy.matrix","row?","emmy.matrix/row?",911532509,null);hY=new $APP.q(null,"simplify?","simplify?",1719480016,null);X4b=new $APP.E("cljs.analyzer","type","cljs.analyzer/type",478749742);iY=new $APP.q(null,"inner-orientation","inner-orientation",911755630,null);Y4b=new $APP.q("emmy.calculus.manifold","make-manifold-family","emmy.calculus.manifold/make-manifold-family",-778835266,null);LE=new $APP.E(null,"shadow","shadow",873231803);
Z4b=new $APP.q("emmy.calculus.metric","trace2down","emmy.calculus.metric/trace2down",1647409792,null);$4b=new $APP.E(null,"boole","boole",-148416687);a5b=new $APP.q("emmy.dual","dual?","emmy.dual/dual?",-894708927,null);b5b=new $APP.q(null,"horner-with-error","horner-with-error",-233784998,null);c5b=new $APP.q("emmy.generic","cross-product","emmy.generic/cross-product",-86703562,null);d5b=new $APP.q(null,"sicm-signature","sicm-signature",-432435845,null);
e5b=new $APP.q(null,"emmy.abstract.number","emmy.abstract.number",71713944,null);f5b=new $APP.q("emmy.abstract.function","-\x3eFunction","emmy.abstract.function/-\x3eFunction",405361520,null);g5b=new $APP.q(null,"J-func","J-func",1541898649,null);wab=new $APP.E(null,"vc","vc",194349650);iK=new $APP.q(null,"?s1","?s1",-1174751069,null);h5b=new $APP.q("emmy.env","S2-tilted","emmy.env/S2-tilted",-212419551,null);I4a=new $APP.E(null,"vector-basis","vector-basis",-869960088);
i5b=new $APP.q(null,"cos-series","cos-series",1863186724,null);j5b=new $APP.q(null,"emmy.numerical.quadrature","emmy.numerical.quadrature",1468850284,null);m4a=new $APP.q("cljs.core","chunkIteratorSeq","cljs.core/chunkIteratorSeq",74875524,null);k5b=new $APP.E(null,"cblocks","cblocks",-1769978138);jY=new $APP.q(null,"?re","?re",118270068,null);l5b=new $APP.q(null,"pattern-\x3ecombinators","pattern-\x3ecombinators",2073187402,null);
m5b=new $APP.q("emmy.generic","log2","emmy.generic/log2",1299455634,null);n5b=new $APP.q("emmy.rational-function","evaluate","emmy.rational-function/evaluate",-1598465215,null);kY=new $APP.q(null,"gensym-fn","gensym-fn",757045695,null);o5b=new $APP.q(null,"round","round",-645002441,null);COa=new $APP.E(null,"js-module-index","js-module-index",2072061931);p5b=new $APP.q("emmy.calculus.manifold","S3-stereographic","emmy.calculus.manifold/S3-stereographic",-249386586,null);
NVa=new $APP.E(null,"middleware-fn","middleware-fn",-61585752);q5b=new $APP.q(null,"Poisson-bracket","Poisson-bracket",-79662190,null);r5b=new $APP.q(null,"symmetrize-Christoffel","symmetrize-Christoffel",-1388254507,null);s5b=new $APP.q("emmy.util","unsupported","emmy.util/unsupported",311764091,null);t5b=new $APP.E(null,"minutes","minutes",1319166394);$Oa=new $APP.E("cljs.analyzer","externs","cljs.analyzer/externs",893359239);
u5b=new $APP.q(null,"linear-interpolants","linear-interpolants",-117737654,null);v5b=new $APP.q("emmy.mechanics.rigid","Euler-\x3eomega","emmy.mechanics.rigid/Euler-\x3eomega",-535954388,null);lY=new $APP.q(null,"ceiling","ceiling",-1593475279,null);w5b=new $APP.q("emmy.value","\x3d","emmy.value/\x3d",1401841144,null);x5b=new $APP.q("emmy.env","p-\x3er","emmy.env/p-\x3er",-1597723383,null);y5b=new $APP.E(null,"deps","deps",1883360319);z5b=new $APP.q(null,"folds","folds",1449129970,null);
A5b=new $APP.q(null,"vector-\x3eup","vector-\x3eup",1833229019,null);B5b=new $APP.q("emmy.numerical.ode","make-integrator","emmy.numerical.ode/make-integrator",-665599475,null);YE=new $APP.q("cljs.core","Object","cljs.core/Object",-345545431,null);C5b=new $APP.q("emmy.series","asinh-series","emmy.series/asinh-series",-749269107,null);D5b=new $APP.q(null,"iterated-map","iterated-map",-1443897207,null);E5b=new $APP.q(null,"lower-arity","lower-arity",37018640,null);
F5b=new $APP.q("emmy.calculus.vector-calculus","curl","emmy.calculus.vector-calculus/curl",-467591349,null);G5b=new $APP.q(null,"make-zero","make-zero",-1008366341,null);H5b=new $APP.q(null,"coordinate-system?","coordinate-system?",-697018728,null);I5b=new $APP.q(null,"bigint?","bigint?",-1865894876,null);J5b=new $APP.q(null,"manifold?","manifold?",-57809116,null);bK=new $APP.q(null,"?x4","?x4",94899597,null);$J=new $APP.q(null,"?x2","?x2",1502785613,null);
K5b=new $APP.q("emmy.calculus.manifold","manifold-point-representation","emmy.calculus.manifold/manifold-point-representation",10786532,null);L5b=new $APP.q("emmy.mechanics.lagrange","state-\x3eqddot","emmy.mechanics.lagrange/state-\x3eqddot",450232944,null);M5b=new $APP.q("emmy.env","v:c","emmy.env/v:c",153262841,null);N5b=new $APP.q("emmy.calculus.vector-field","evolution","emmy.calculus.vector-field/evolution",-616873570,null);
O5b=new $APP.q("emmy.dual","compare-full","emmy.dual/compare-full",1584170050,null);HYa=new $APP.q(null,"?y2","?y2",731715171,null);P5b=new $APP.q("Math","ceil","Math/ceil",-186204017,null);GYa=new $APP.q(null,"?y1","?y1",1237029156,null);Q5b=new $APP.q(null,"emmy.quaternion","emmy.quaternion",1427904557,null);R5b=new $APP.q(null,"coordinatize","coordinatize",-1986275097,null);mY=new $APP.q(null,"patterns","patterns",-1490353745,null);
S5b=new $APP.q("emmy.env","rotate-y-matrix","emmy.env/rotate-y-matrix",720342002,null);A8a=new $APP.E(null,"accelerate?","accelerate?",-29657518);T5b=new $APP.q("emmy.operator","-\x3eOperator","emmy.operator/-\x3eOperator",-1080554350,null);U5b=new $APP.q("emmy.env","S2p-spherical","emmy.env/S2p-spherical",534101091,null);V5b=new $APP.q(null,"exception","exception",1305254463,null);W5b=new $APP.E(null,"min-version","min-version",-1697197126);
X5b=new $APP.q("emmy.env","coordinate-system-\x3evector-basis","emmy.env/coordinate-system-\x3evector-basis",-849429161,null);Y5b=new $APP.q(null,"emmy.algebra.fold","emmy.algebra.fold",-459207822,null);Z5b=new $APP.q("emmy.quaternion","invert","emmy.quaternion/invert",1851875614,null);$5b=new $APP.q(null,"classical-adjoint-formula","classical-adjoint-formula",-471551995,null);nY=new $APP.q("a","monotonic-symbol-generator","a/monotonic-symbol-generator",1030677375,null);
a6b=new $APP.q("emmy.series","compose","emmy.series/compose",195899350,null);b6b=new $APP.q(null,"pattern*","pattern*",-294286221,null);c6b=new $APP.E(null,"recur","recur",-437573268);d6b=new $APP.q("emmy.util.aggregate","group","emmy.util.aggregate/group",1556218004,null);e6b=new $APP.q(null,"-\x3et_emmy$polynomial$factor49028","-\x3et_emmy$polynomial$factor49028",-872692048,null);f6b=new $APP.q("emmy.env","partial","emmy.env/partial",763774669,null);
g6b=new $APP.q("emmy.calculus.frame","event-\x3ecoords","emmy.calculus.frame/event-\x3ecoords",962323286,null);h6b=new $APP.q(null,"owner","owner",1247919588,null);QQa=new $APP.q(null,"__extmap","__extmap",-1435580931,null);i6b=new $APP.q("emmy.matrix","matrix-\x3evector","emmy.matrix/matrix-\x3evector",365660035,null);j6b=new $APP.q("emmy.generic","simplify","emmy.generic/simplify",1649699427,null);
h5a=new $APP.q(null,"vector-field-\x3evector-field-over-map","vector-field-\x3evector-field-over-map",969823025,null);k6b=new $APP.q("emmy.generic","quotient","emmy.generic/quotient",524483293,null);l6b=new $APP.q("emmy.env","Euler-angles","emmy.env/Euler-angles",2019373643,null);m6b=new $APP.q(null,"basis-unit","basis-unit",-1238004324,null);n6b=new $APP.q(null,"S1-gnomonic","S1-gnomonic",1277278711,null);o6b=new $APP.q(null,"modified-neville-fold","modified-neville-fold",1163820724,null);
p6b=new $APP.q("emmy.mechanics.rigid","quaternion-state-\x3eomega-space","emmy.mechanics.rigid/quaternion-state-\x3eomega-space",-2092144257,null);q6b=new $APP.q("emmy.numerical.unimin.brent","brent-max","emmy.numerical.unimin.brent/brent-max",997414695,null);r6b=new $APP.E(null,"expression-\x3e","expression-\x3e",1738204556);s6b=new $APP.q("emmy.rational-function.interpolate","modified-bulirsch-stoer-fold","emmy.rational-function.interpolate/modified-bulirsch-stoer-fold",824068631,null);
t6b=new $APP.q("emmy.quaternion","ONE-tensor","emmy.quaternion/ONE-tensor",-154616122,null);u6b=new $APP.q(null,"cosh-series","cosh-series",1737878103,null);v6b=new $APP.q("emmy.env","compose","emmy.env/compose",110695636,null);w6b=new $APP.q(null,"exact-divide","exact-divide",-836167490,null);x6b=new $APP.E("emmy.expression","abstract-matrix","emmy.expression/abstract-matrix",-842157179);y6b=new $APP.q("emmy.structure","literal-up","emmy.structure/literal-up",1068175229,null);
hQa=new $APP.E(null,"flag","flag",1088647881);z6b=new $APP.q("emmy.env","R3-cyl","emmy.env/R3-cyl",2115831730,null);A6b=new $APP.q("emmy.env","alt-wedge","emmy.env/alt-wedge",225882805,null);B6b=new $APP.q(null,"sym-\x3ef","sym-\x3ef",-671768860,null);C6b=new $APP.q("emmy.simplify.rules","canonicalize-partials","emmy.simplify.rules/canonicalize-partials",-442645,null);D6b=new $APP.q("emmy.mechanics.lagrange","Dt-procedure","emmy.mechanics.lagrange/Dt-procedure",357311615,null);
E6b=new $APP.q("emmy.mechanics.rigid","T-body-Euler","emmy.mechanics.rigid/T-body-Euler",-2078352517,null);F6b=new $APP.q("emmy.mechanics.hamilton","literal-Hamiltonian-state","emmy.mechanics.hamilton/literal-Hamiltonian-state",1319857380,null);k0a=new $APP.q(null,"root-out-squares","root-out-squares",-278750312,null);G6b=new $APP.q(null,"linear-function-\x3emultiplier","linear-function-\x3emultiplier",-185354560,null);
H6b=new $APP.q("emmy.matrix","-\x3eMatrix","emmy.matrix/-\x3eMatrix",2061981237,null);I6b=new $APP.q("emmy.env","make-rectangular","emmy.env/make-rectangular",-481625545,null);J6b=new $APP.q("emmy.mechanics.lagrange","acceleration","emmy.mechanics.lagrange/acceleration",-1206049082,null);K6b=new $APP.q(null,"emmy.numsymb","emmy.numsymb",-1063329930,null);L6b=new $APP.q(null,"emmy.util.aggregate","emmy.util.aggregate",-615679461,null);
M6b=new $APP.q("emmy.env","find-path","emmy.env/find-path",961683438,null);N6b=new $APP.q("emmy.env","parallel-transport-equation","emmy.env/parallel-transport-equation",665642074,null);U6a=new $APP.E(null,"special-handlers","special-handlers",-582917928);O6b=new $APP.q("emmy.calculus.manifold","R4-cyl","emmy.calculus.manifold/R4-cyl",1744537705,null);P6b=new $APP.q("emmy.simplify.rules","simplify-square-roots","emmy.simplify.rules/simplify-square-roots",-743431262,null);
Q6b=new $APP.q("emmy.structure","structure?","emmy.structure/structure?",1283227976,null);R6b=new $APP.q(null,"rectangular-\x3espherical","rectangular-\x3espherical",1020736763,null);S6b=new $APP.E(null,"private-var-access","private-var-access",967536101);oY=new $APP.q(null,"?x1","?x1",697080023,null);T6b=new $APP.q("emmy.rational-function.interpolate","bulirsch-stoer","emmy.rational-function.interpolate/bulirsch-stoer",1615277191,null);U6b=new $APP.q(null,"_if-false","_if-false",-353608572,null);
V6b=new $APP.q("emmy.pattern.match","and","emmy.pattern.match/and",1489121481,null);W6b=new $APP.q("emmy.env","Lie-derivative","emmy.env/Lie-derivative",-1767257328,null);pY=new $APP.q(null,"conjugate","conjugate",-1063123193,null);X6b=new $APP.q("emmy.polynomial","horner-with-error","emmy.polynomial/horner-with-error",-2120970616,null);qY=new $APP.q(null,"column?","column?",510745491,null);NJ=new $APP.q(null,"??fs1","??fs1",-1584583474,null);Y6b=new $APP.q(null,"shift-t","shift-t",-681669434,null);
MJ=new $APP.q(null,"??fs3","??fs3",1216174751,null);KJ=new $APP.q(null,"??fs2","??fs2",1129791247,null);Z6b=new $APP.E(null,"info?","info?",361925553);$6b=new $APP.q("emmy.env","geodesic-equation","emmy.env/geodesic-equation",-2102442369,null);rY=new $APP.E(null,"north-pole","north-pole",-1543616402);a7b=new $APP.q(null,"accelerations","accelerations",-1678530805,null);b7b=new $APP.q("emmy.polynomial.gcd","gcd-Dp","emmy.polynomial.gcd/gcd-Dp",-445086920,null);
c7b=new $APP.q("emmy.env","coordinate-basis?","emmy.env/coordinate-basis?",7762508,null);d7b=new $APP.q("emmy.sr.frames","base-frame-maker","emmy.sr.frames/base-frame-maker",1982767097,null);e7b=new $APP.q("emmy.quaternion","conjugate","emmy.quaternion/conjugate",-1866635233,null);f7b=new $APP.q(null,"column*","column*",1968036749,null);g7b=new $APP.q("emmy.env","Cartan-\x3ebasis","emmy.env/Cartan-\x3ebasis",1146663772,null);nPa=new $APP.q(null,"checked-aget'","checked-aget'",212330530,null);
sY=new $APP.E(null,"gnomonic","gnomonic",-1350375895);h7b=new $APP.q("emmy.matrix","row","emmy.matrix/row",-53588903,null);i7b=new $APP.q(null,"DHs","DHs",-78081496,null);j7b=new $APP.q(null,"unquote-splice?","unquote-splice?",1580318811,null);k7b=new $APP.q(null,"emmy.polynomial.impl","emmy.polynomial.impl",-1886265419,null);l7b=new $APP.q("emmy.polynomial","pseudo-remainder","emmy.polynomial/pseudo-remainder",308457853,null);Q8a=new $APP.E(null,"infinite-breakpoint","infinite-breakpoint",1403428770);
m7b=new $APP.q("emmy.env","modulo","emmy.env/modulo",1755424269,null);n7b=new $APP.q(null,"S3-stereographic","S3-stereographic",731850624,null);o7b=new $APP.q("cljs.core","IComparable","cljs.core/IComparable",1166626940,null);p7b=new $APP.q("emmy.mechanics.lagrange","state-\x3en-dof","emmy.mechanics.lagrange/state-\x3en-dof",-862592928,null);q7b=new $APP.q(null,"complex-trig","complex-trig",1797292313,null);r7b=new $APP.q(null,"primal-tangent-pair","primal-tangent-pair",-514796111,null);
s7b=new $APP.q("emmy.quaternion","magnitude-sq","emmy.quaternion/magnitude-sq",-1616288467,null);t7b=new $APP.q("emmy.numsymb","operator","emmy.numsymb/operator",-1418543548,null);tY=new $APP.q(null,"source-coordsys","source-coordsys",1671917495,null);u7b=new $APP.q(null,"binomial-series","binomial-series",-1526523436,null);v7b=new $APP.q(null,"*exponent-product-simplify?*","*exponent-product-simplify?*",893369951,null);w7b=new $APP.E(null,"spacetime-spherical","spacetime-spherical",-751929014);
x7b=new $APP.q("emmy.pattern.rule","pipe","emmy.pattern.rule/pipe",88270244,null);y7b=new $APP.q("emmy.env","atanh","emmy.env/atanh",-928399829,null);z7b=new $APP.q(null,"check-coordinates","check-coordinates",-511993179,null);E5a=new $APP.q(null,"omega-prime-forms","omega-prime-forms",1304696268,null);A7b=new $APP.q("emmy.env","invert","emmy.env/invert",1891927217,null);B7b=new $APP.q("emmy.special.factorial","binomial-coefficient","emmy.special.factorial/binomial-coefficient",1002691827,null);
C7b=new $APP.q(null,"variable-name","variable-name",-2125665669,null);l7a=new $APP.E(null,"alpha","alpha",-1574982441);uY=new $APP.q(null,"orientation-inverse-matrix","orientation-inverse-matrix",1827755966,null);D7b=new $APP.q(null,"make-literal","make-literal",886054236,null);E7b=new $APP.q(null,"structure-\x3evector","structure-\x3evector",-530711689,null);F7b=new $APP.q("emmy.dual","REVERSE-EMPTY","emmy.dual/REVERSE-EMPTY",-852657380,null);G7b=new $APP.q(null,"divide","divide",-545489112,null);
H7b=new $APP.q("emmy.special.elliptic","elliptic-k","emmy.special.elliptic/elliptic-k",89065331,null);I7b=new $APP.q("emmy.special.elliptic","elliptic-e","emmy.special.elliptic/elliptic-e",932398830,null);J7b=new $APP.q("emmy.special.elliptic","elliptic-f","emmy.special.elliptic/elliptic-f",1502517041,null);K7b=new $APP.q(null,"map-exponents","map-exponents",-1135861601,null);L7b=new $APP.q(null,"expts-\x3ecoef","expts-\x3ecoef",-214884486,null);mQa=new $APP.E(null,"fn-scope","fn-scope",-865664859);
M7b=new $APP.q("emmy.expression","evaluate","emmy.expression/evaluate",1514546874,null);N7b=new $APP.E(null,"days","days",-1394072564);O7b=new $APP.q(null,"reverse-segment-name","reverse-segment-name",1073216529,null);P7b=new $APP.q("emmy.mechanics.routhian","Routhian-\x3eacceleration","emmy.mechanics.routhian/Routhian-\x3eacceleration",2103893071,null);Q7b=new $APP.q("emmy.mechanics.rigid","Euler-state-\x3eomega-body","emmy.mechanics.rigid/Euler-state-\x3eomega-body",-1189770823,null);
R7b=new $APP.q("emmy.calculus.derivative","D-reverse","emmy.calculus.derivative/D-reverse",-2016156522,null);S7b=new $APP.q("emmy.env","polar-canonical","emmy.env/polar-canonical",-520263971,null);vY=new $APP.q("cljs.core","IReduce","cljs.core/IReduce",-577837345,null);T7b=new $APP.q("emmy.function","coerce-to-fn","emmy.function/coerce-to-fn",1308144045,null);$APP.U7b=new $APP.q(null,"spherical","spherical",-2097688265,null);
V7b=new $APP.q("emmy.simplify.rules","complex-rules","emmy.simplify.rules/complex-rules",-1616667200,null);W7b=new $APP.q("emmy.mechanics.hamilton","flow-derivative","emmy.mechanics.hamilton/flow-derivative",1608980401,null);wY=new $APP.q("cljs.core","ISequential","cljs.core/ISequential",-950981796,null);X7b=new $APP.q(null,"base-frame-chart","base-frame-chart",1026208390,null);Y7b=new $APP.q(null,"poly-\x3efactored-expression","poly-\x3efactored-expression",-158535444,null);
Z7b=new $APP.q("emmy.util.def","update-some","emmy.util.def/update-some",-1331757873,null);xY=new $APP.q(null,"dissipation-fn","dissipation-fn",1979250288,null);$7b=new $APP.q("emmy.env","coordinate-system?","emmy.env/coordinate-system?",-1815474643,null);D7a=new $APP.E(null,"arg-tolerance","arg-tolerance",1681183780);$APP.yY=new $APP.q(null,"size","size",-1555742762,null);a8b=new $APP.q(null,"origin","origin",-1617063681,null);
b8b=new $APP.q("emmy.calculus.form-field","Alt","emmy.calculus.form-field/Alt",1336710836,null);c8b=new $APP.q("emmy.calculus.basis","make-constant-vector-field","emmy.calculus.basis/make-constant-vector-field",961663073,null);d8b=new $APP.q("emmy.calculus.manifold","manifold-point?","emmy.calculus.manifold/manifold-point?",1306028620,null);e8b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57471","-\x3et_emmy$calculus$manifold57471",-1931618087,null);
f8b=new $APP.q("emmy.matrix","up-\x3ecolumn-matrix","emmy.matrix/up-\x3ecolumn-matrix",-1444074745,null);g8b=new $APP.q("emmy.operator","identity","emmy.operator/identity",2060804,null);h8b=new $APP.q("emmy.structure","down*","emmy.structure/down*",-275012676,null);i8b=new $APP.q("emmy.calculus.metric","raise","emmy.calculus.metric/raise",1429662218,null);j8b=new $APP.E(null,"msg-fn","msg-fn",-1873033940);
k8b=new $APP.q("emmy.env","metric-\x3eChristoffel-1","emmy.env/metric-\x3eChristoffel-1",-1305606788,null);l8b=new $APP.q("emmy.env","metric-\x3eChristoffel-2","emmy.env/metric-\x3eChristoffel-2",-447528048,null);m8b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57463","-\x3et_emmy$calculus$manifold57463",-1714752788,null);n8b=new $APP.q(null,"literal-vector-field","literal-vector-field",1681711331,null);o8b=new $APP.q(null,"cramers-rule","cramers-rule",-1785048704,null);
p8b=new $APP.q("cljs.core","double?","cljs.core/double?",1757455529,null);q8b=new $APP.q(null,"without","without",-1547399081,null);zY=new $APP.q(null,"square?","square?",-1270504145,null);r8b=new $APP.q("emmy.generic","sqrt","emmy.generic/sqrt",-1009239123,null);s8b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57458","-\x3et_emmy$calculus$manifold57458",265336015,null);t8b=new $APP.q(null,"coords-\x3epoint","coords-\x3epoint",-1467945699,null);u8b=new $APP.q(null,"torsion","torsion",492861929,null);
v8b=new $APP.q("emmy.env","R2-polar","emmy.env/R2-polar",1561231069,null);w8b=new $APP.q(null,"series:sum","series:sum",-1714640975,null);x8b=new $APP.q(null,"matrix-\x3eH-state","matrix-\x3eH-state",1619175641,null);y8b=new $APP.q(null,"vector-field-\x3ebasis-components","vector-field-\x3ebasis-components",-247472946,null);z8b=new $APP.q("emmy.pattern.rule","trace","emmy.pattern.rule/trace",-262557148,null);A8b=new $APP.q(null,"emmy.util.stream","emmy.util.stream",1561123960,null);
B8b=new $APP.q("emmy.env","acsc","emmy.env/acsc",-24092233,null);C8b=new $APP.q(null,"universal-reductions","universal-reductions",1476944709,null);D8b=new $APP.q(null,"number-of-combinations","number-of-combinations",-1363476619,null);AY=new $APP.q(null,"shifts","shifts",-704758268,null);E8b=new $APP.E(null,"unsigned?","unsigned?",-502764154);F8b=new $APP.q("emmy.structure","down?","emmy.structure/down?",67554565,null);G8b=new $APP.E(null,"fblock","fblock",-1236607426);
hF=new $APP.E("cljs.analyzer","analyzed","cljs.analyzer/analyzed",-735094162);H8b=new $APP.q("emmy.pattern.rule","failed?","emmy.pattern.rule/failed?",-795759401,null);I8b=new $APP.q(null,"neville-scan","neville-scan",-738395933,null);lPa=new $APP.q(null,"checked-aget","checked-aget",950823006,null);J8b=new $APP.q(null,"Lagrangian-\x3eacceleration","Lagrangian-\x3eacceleration",345497709,null);SRa=new $APP.E(null,"macroexpansion","macroexpansion",706274075);
K8b=new $APP.q("emmy.matrix","make-diagonal","emmy.matrix/make-diagonal",187096326,null);HVa=new $APP.E(null,"rate-limit","rate-limit",1748082022);L8b=new $APP.E(null,"export","export",214356590);OQa=new $APP.E(null,"defrecord","defrecord",-1367493418);ZUa=new $APP.E(null,"min-level","min-level",1634684919);M8b=new $APP.q("emmy.dual","tag","emmy.dual/tag",666261038,null);N8b=new $APP.q(null,"central-difference-d2","central-difference-d2",403360240,null);
O8b=new $APP.q("emmy.env","acot","emmy.env/acot",-2045740340,null);P8b=new $APP.q("emmy.env","acos","emmy.env/acos",1454596988,null);Q8b=new $APP.q(null,"o-\x3esyms","o-\x3esyms",-25830305,null);bVa=new $APP.E(null,"ns-blacklist","ns-blacklist",1957763142);TN=new $APP.q(null,"UP*","UP*",294235991,null);zRa=new $APP.E(null,"deprecation-nowarn","deprecation-nowarn",-1762828044);R8b=new $APP.q(null,"env","env",-175281708,null);
S8b=new $APP.q("emmy.mechanics.rigid","T-body","emmy.mechanics.rigid/T-body",-713675446,null);m2a=new $APP.q(null,"DOWN*","DOWN*",1300864675,null);T8b=new $APP.q(null,"L-space-Euler","L-space-Euler",-1490948843,null);wG=new $APP.q("emmy.complex","complex","emmy.complex/complex",754489658,null);U8b=new $APP.q("emmy.expression.render","*TeX-vertical-down-tuples*","emmy.expression.render/*TeX-vertical-down-tuples*",-1525401240,null);GVa=new $APP.E(null,"trace","trace",-1082747415);
V8b=new $APP.q(null,"new-arity","new-arity",-1624480576,null);W8b=new $APP.q("emmy.mechanics.hamilton","Hamiltonian","emmy.mechanics.hamilton/Hamiltonian",-1725596596,null);X8b=new $APP.E(null,"dblock","dblock",-1325623381);Y8b=new $APP.q("emmy.generic","dot-product","emmy.generic/dot-product",-1004113231,null);Z8b=new $APP.q(null,"compile-state-fn","compile-state-fn",-2216916,null);$8b=new $APP.q(null,"ICanonicalize","ICanonicalize",-1572005940,null);
a9b=new $APP.q("emmy.util.permute","list-interchanges","emmy.util.permute/list-interchanges",-824277049,null);b9b=new $APP.q("emmy.generic","csch","emmy.generic/csch",-410694894,null);c9b=new $APP.q("emmy.modint","-\x3eModInt","emmy.modint/-\x3eModInt",1202662049,null);d9b=new $APP.q("emmy.mechanics.lagrange","p-\x3er","emmy.mechanics.lagrange/p-\x3er",-871117546,null);e9b=new $APP.q(null,"F-tilde","F-tilde",996598782,null);
f9b=new $APP.q("emmy.numerical.unimin.golden","golden-section-min","emmy.numerical.unimin.golden/golden-section-min",601364146,null);g9b=new $APP.q("emmy.calculus.hodge-star","Gram-Schmidt","emmy.calculus.hodge-star/Gram-Schmidt",1956616544,null);h9b=new $APP.q("emmy.calculus.indexed","indexed-\x3etyped","emmy.calculus.indexed/indexed-\x3etyped",533604105,null);i9b=new $APP.q("emmy.polynomial","arity","emmy.polynomial/arity",-1518834610,null);
j9b=new $APP.q("emmy.rational-function","sub","emmy.rational-function/sub",-253444189,null);k9b=new $APP.q(null,"L-state-\x3eH-state","L-state-\x3eH-state",-46880312,null);l9b=new $APP.q("emmy.mechanics.rigid","T-quaternion-state","emmy.mechanics.rigid/T-quaternion-state",193580823,null);m9b=new $APP.q(null,"-\x3eMatrix","-\x3eMatrix",635711640,null);n9b=new $APP.q("emmy.function","compose","emmy.function/compose",389171445,null);
o9b=new $APP.q("emmy.series","log1+x-series","emmy.series/log1+x-series",-756965640,null);p9b=new $APP.q("emmy.generic","expt","emmy.generic/expt",-1429583700,null);q9b=new $APP.q(null,"basis-on-M","basis-on-M",1714569456,null);r9b=new $APP.q(null,"kahan","kahan",-1458265841,null);s9b=new $APP.q("emmy.env","divergence","emmy.env/divergence",1223453163,null);t9b=new $APP.q("emmy.simplify.rules","commutative","emmy.simplify.rules/commutative",991285212,null);
u9b=new $APP.q("emmy.calculus.connection","literal-Christoffel-1","emmy.calculus.connection/literal-Christoffel-1",-255341526,null);v9b=new $APP.q("emmy.calculus.connection","literal-Christoffel-2","emmy.calculus.connection/literal-Christoffel-2",-1619286076,null);w9b=new $APP.q("emmy.generic","remainder","emmy.generic/remainder",-1930884158,null);x9b=new $APP.q(null,"f-form","f-form",309693281,null);y9b=new $APP.q("emmy.polynomial.gcd","trivial-gcd","emmy.polynomial.gcd/trivial-gcd",256546410,null);
z9b=new $APP.q(null,"two-particle-center-of-mass","two-particle-center-of-mass",-171051168,null);A9b=new $APP.q(null,"counted","counted",1189969060,null);BY=new $APP.q(null,"high","high",-627137961,null);B9b=new $APP.E(null,"native","native",-613060878);C9b=new $APP.q("emmy.complex","ZERO","emmy.complex/ZERO",-432695973,null);D9b=new $APP.q("emmy.expression","literal-type","emmy.expression/literal-type",-1957201608,null);
E9b=new $APP.q("emmy.expression.render","-\x3eJavaScript","emmy.expression.render/-\x3eJavaScript",-1057115132,null);HRa=new $APP.E(null,"const-expr","const-expr",-1379382292);F9b=new $APP.E("emmy.expression","vector","emmy.expression/vector",-1823391456);G9b=new $APP.E(null,"catch","catch",1038065524);H9b=new $APP.q("emmy.structure","vector-\x3edown","emmy.structure/vector-\x3edown",1649641827,null);
I9b=new $APP.q("emmy.mechanics.rigid","three-vector-components-\x3eantisymmetric","emmy.mechanics.rigid/three-vector-components-\x3eantisymmetric",-1412059008,null);J9b=new $APP.q(null,"partial-forward","partial-forward",755260127,null);K9b=new $APP.q(null,"embedding","embedding",-2043869411,null);L9b=new $APP.q("emmy.calculus.metric","sharpen","emmy.calculus.metric/sharpen",1476241581,null);M9b=new $APP.q("emmy.simplify.rules","associative","emmy.simplify.rules/associative",2104123948,null);
N9b=new $APP.q("cljs.core","qualified-symbol?","cljs.core/qualified-symbol?",1570873476,null);O9b=new $APP.q("cljs.core","delay?","cljs.core/delay?",2099859324,null);P9b=new $APP.q(null,"permutation-interchanges","permutation-interchanges",1436643038,null);Q9b=new $APP.q("emmy.mechanics.hamilton","Lagrangian-\x3eHamiltonian","emmy.mechanics.hamilton/Lagrangian-\x3eHamiltonian",1995549950,null);
R9b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57421","-\x3et_emmy$calculus$manifold57421",1486529648,null);S9b=new $APP.q("emmy.dual","extract-id","emmy.dual/extract-id",841639758,null);$APP.CY=new $APP.q(null,"dimension","dimension",-2111181571,null);T9b=new $APP.q(null,"compile-skeleton","compile-skeleton",-668513117,null);U9b=new $APP.q(null,"coordinate-system-at","coordinate-system-at",-933140671,null);V9b=new $APP.q(null,"infix-sym-\x3eunicode","infix-sym-\x3eunicode",721754064,null);
DY=new $APP.q(null,"vars","vars",-406425690,null);W9b=new $APP.q("emmy.pattern.syntax","segment?","emmy.pattern.syntax/segment?",1005334251,null);X9b=new $APP.q("emmy.calculus.manifold","chart","emmy.calculus.manifold/chart",-588054402,null);Y9b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57410","-\x3et_emmy$calculus$manifold57410",-54835171,null);EY=new $APP.q(null,"angle","angle",-1032341515,null);Z9b=new $APP.q("emmy.env","S3-spherical","emmy.env/S3-spherical",625231346,null);
$9b=new $APP.q("emmy.generic","exp2","emmy.generic/exp2",389925301,null);a$b=new $APP.q("emmy.calculus.manifold","point","emmy.calculus.manifold/point",342112725,null);eSa=new $APP.q("cljs.core","ISet","cljs.core/ISet",2003412810,null);b$b=new $APP.q(null,"identity-like","identity-like",1541985180,null);c$b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57448","-\x3et_emmy$calculus$manifold57448",-389089740,null);FY=new $APP.q(null,"manifold-point?","manifold-point?",-1801722474,null);
d$b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57440","-\x3et_emmy$calculus$manifold57440",-547612566,null);dF=new $APP.E(null,"property","property",-1114278232);e$b=new $APP.q("emmy.ratio","denominator","emmy.ratio/denominator",571780366,null);f$b=new $APP.q("emmy.mechanics.time-evolution","C-\x3eCp","emmy.mechanics.time-evolution/C-\x3eCp",-21551299,null);g$b=new $APP.q("emmy.mechanics.hamilton","matrix-\x3eH-state","emmy.mechanics.hamilton/matrix-\x3eH-state",697183236,null);
h$b=new $APP.q("emmy.polynomial","normalize","emmy.polynomial/normalize",12681494,null);i$b=new $APP.q(null,"Complex","Complex",1443317787,null);j$b=new $APP.q("emmy.matrix","m-\x3es","emmy.matrix/m-\x3es",398995012,null);k$b=new $APP.q(null,"-\x3et_emmy$calculus$manifold57430","-\x3et_emmy$calculus$manifold57430",550158944,null);l$b=new $APP.q("emmy.expression.render","infix-sym-\x3eunicode","emmy.expression.render/infix-sym-\x3eunicode",-1067313886,null);
m$b=new $APP.q("emmy.mechanics.hamilton","symplectic-matrix?","emmy.mechanics.hamilton/symplectic-matrix?",-909030147,null);n$b=new $APP.q("emmy.env","real-part","emmy.env/real-part",1259206742,null);y3a=new $APP.E("emmy.calculus.manifold","manifold-function","emmy.calculus.manifold/manifold-function",-1023992517);o$b=new $APP.q("emmy.pattern.syntax","unquote?","emmy.pattern.syntax/unquote?",-246759071,null);
p$b=new $APP.q("emmy.simplify.rules","*divide-numbers-through-simplify?*","emmy.simplify.rules/*divide-numbers-through-simplify?*",1355588149,null);yJ=new $APP.q(null,"??xs","??xs",-2083850977,null);cF=new $APP.E(null,"infer-warning","infer-warning",-1600671410);q$b=new $APP.q("emmy.calculus.manifold","transfer-point","emmy.calculus.manifold/transfer-point",-348435014,null);r$b=new $APP.q(null,"multichoose","multichoose",337768353,null);
s$b=new $APP.q("emmy.modint","modint?","emmy.modint/modint?",863521491,null);GY=new $APP.q(null,"??y1","??y1",-1969315695,null);HY=new $APP.q(null,"??y2","??y2",-796250797,null);t$b=new $APP.q("cljs.core","flatten","cljs.core/flatten",-237795822,null);u$b=new $APP.q("Math","sqrt","Math/sqrt",377394374,null);v$b=new $APP.q("emmy.quaternion","mul","emmy.quaternion/mul",2091367217,null);w$b=new $APP.q("cljs.core","keyword?","cljs.core/keyword?",713156450,null);
x$b=new $APP.q(null,"one?","one?",1787102903,null);y$b=new $APP.q("emmy.mechanics.hamilton","F-\x3eCH","emmy.mechanics.hamilton/F-\x3eCH",1105336723,null);IY=new $APP.E("emmy.value","native-integral","emmy.value/native-integral",-1286161061);pQ=new $APP.E(null,"result","result",1415092211);z$b=new $APP.q(null,"emmy.numerical.ode","emmy.numerical.ode",-66413745,null);yH=new $APP.q(null,"sinh","sinh",-990423302,null);ZJ=new $APP.q(null,"??x1","??x1",-1923305193,null);
fK=new $APP.q(null,"??x2","??x2",169445330,null);aK=new $APP.q(null,"??x3","??x3",-411077265,null);A$b=new $APP.q("emmy.quaternion","I","emmy.quaternion/I",1052597922,null);B$b=new $APP.q("emmy.mechanics.hamilton","F-\x3eCT","emmy.mechanics.hamilton/F-\x3eCT",-1699667269,null);C$b=new $APP.q(null,"wcross-\x3ew","wcross-\x3ew",-80334599,null);cK=new $APP.q(null,"??x5","??x5",1822045235,null);D$b=new $APP.q("emmy.quaternion","K","emmy.quaternion/K",-1309915252,null);
$APP.JY=new $APP.q(null,"label","label",-936024965,null);E$b=new $APP.q("emmy.quaternion","J","emmy.quaternion/J",1692883003,null);F$b=new $APP.q(null,"until","until",451365137,null);G$b=new $APP.q(null,"S2-stereographic","S2-stereographic",-100853268,null);H$b=new $APP.q(null,"scalar?","scalar?",1570438077,null);I$b=new $APP.q(null,"sinc","sinc",60189925,null);J$b=new $APP.q("emmy.calculus.frame","event?","emmy.calculus.frame/event?",1150652264,null);
K$b=new $APP.q("emmy.env","remainder","emmy.env/remainder",-444421652,null);L$b=new $APP.q(null,"spherical-\x3erectangular","spherical-\x3erectangular",1409390107,null);M$b=new $APP.q("Math","cos","Math/cos",-1454544429,null);N$b=new $APP.q(null,"by-rows*","by-rows*",1156495609,null);O$b=new $APP.E(null,"closed","closed",-919675359);P$b=new $APP.E(null,"multiple-variadic-overloads","multiple-variadic-overloads",1110059837);Q$b=new $APP.q(null,"exp-expand","exp-expand",-2082275726,null);
R$b=new $APP.q("emmy.pattern.syntax","splice-reduce","emmy.pattern.syntax/splice-reduce",913308744,null);S$b=new $APP.q("emmy.util.permute","multichoose","emmy.util.permute/multichoose",317111693,null);T$b=new $APP.q("emmy.env","atan","emmy.env/atan",-1674162468,null);U$b=new $APP.q("emmy.calculus.metric","coordinate-system-\x3emetric","emmy.calculus.metric/coordinate-system-\x3emetric",2092059672,null);V$b=new $APP.q(null,"bigint","bigint",-70405490,null);
W$b=new $APP.q("emmy.calculus.basis","make-basis","emmy.calculus.basis/make-basis",1068287334,null);X$b=new $APP.q(null,"succeed","succeed",207632095,null);Y$b=new $APP.q("emmy.sr.boost","general-boost2","emmy.sr.boost/general-boost2",1615930831,null);Z$b=new $APP.q(null,"R2-rect","R2-rect",1642598370,null);$$b=new $APP.q(null,"s:invert","s:invert",-889536282,null);aac=new $APP.q(null,"Routhian-\x3estate-derivative","Routhian-\x3estate-derivative",1713797386,null);
bac=new $APP.q("cljs.core","qualified-keyword?","cljs.core/qualified-keyword?",-308091478,null);cac=new $APP.E(null,"numerical?","numerical?",-1353720934);dac=new $APP.q("emmy.env","rationalize","emmy.env/rationalize",-1345779476,null);eac=new $APP.q("emmy.util","double","emmy.util/double",-2015033650,null);KY=new $APP.q(null,"generic-params?","generic-params?",-1736124942,null);fac=new $APP.E(null,"closed-open","closed-open",-1821164567);
gac=new $APP.q("emmy.special.factorial","factorial-power","emmy.special.factorial/factorial-power",-976374300,null);hac=new $APP.q(null,"e_j","e_j",-204646387,null);iac=new $APP.q(null,"e_i","e_i",-907547744,null);jac=new $APP.q(null,"??zs","??zs",1863806627,null);kac=new $APP.q("emmy.env","gcd","emmy.env/gcd",-1538065038,null);lac=new $APP.q("cljs.core","Reduced","cljs.core/Reduced",971663396,null);mac=new $APP.q("emmy.pattern.match","sequence","emmy.pattern.match/sequence",-603330194,null);
nac=new $APP.q(null,"e_k","e_k",-1989044598,null);oac=new $APP.q("emmy.calculus.covariant","make-Christoffel","emmy.calculus.covariant/make-Christoffel",-992163038,null);tM=new $APP.q(null,"non-negative?","non-negative?",1248641804,null);pac=new $APP.q("emmy.matrix","transpose","emmy.matrix/transpose",-1736760748,null);qac=new $APP.q("emmy.mechanics.hamilton","Legendre-transform","emmy.mechanics.hamilton/Legendre-transform",-846467344,null);
rac=new $APP.q(null,"four-matrix","four-matrix",2083177250,null);sac=new $APP.q(null,"seq:pprint","seq:pprint",-160078278,null);UJ=new $APP.q(null,"??ys","??ys",1180811471,null);tac=new $APP.q(null,"make-event","make-event",-855573915,null);uac=new $APP.q(null,"full-gcd","full-gcd",-1142748438,null);vac=new $APP.q(null,"integrate-state-derivative","integrate-state-derivative",1154163041,null);wac=new $APP.E(null,"error-fn","error-fn",-171437615);
xac=new $APP.q("emmy.polynomial","arg-shift","emmy.polynomial/arg-shift",984324003,null);yac=new $APP.q(null,"expression-\x3estream","expression-\x3estream",1834298297,null);aQa=new $APP.q(null,"cljs.user","cljs.user",877795071,null);zac=new $APP.q("emmy.calculus.covariant","interior-product","emmy.calculus.covariant/interior-product",-677203764,null);Aac=new $APP.q("emmy.env","power-series","emmy.env/power-series",-1738248017,null);Bac=new $APP.q("g","zero?","g/zero?",325758938,null);
Cac=new $APP.q("emmy.mechanics.lagrange","Lagrange-equations-1","emmy.mechanics.lagrange/Lagrange-equations-1",-276843753,null);Dac=new $APP.q("emmy.numsymb","sum?","emmy.numsymb/sum?",160859848,null);Eac=new $APP.q("emmy.env","commutator","emmy.env/commutator",2017279100,null);$APP.Fac=new $APP.q(null,"normalize","normalize",-263858524,null);Gac=new $APP.q("emmy.util.permute","cartesian-product","emmy.util.permute/cartesian-product",1119553197,null);
F7a=new $APP.E(null,"fn-counter","fn-counter",-1395388762);Hac=new $APP.E(null,"non-dynamic-earmuffed-var","non-dynamic-earmuffed-var",-202005643);Iac=new $APP.q("emmy.pattern.match","reverse-segment","emmy.pattern.match/reverse-segment",-1629158578,null);Jac=new $APP.q(null,"Lagrangian-state-\x3eRouthian-state","Lagrangian-state-\x3eRouthian-state",1611386074,null);Kac=new $APP.q("emmy.env","trace2down","emmy.env/trace2down",-1369714327,null);
Lac=new $APP.q("emmy.calculus.coordinate","quotify-coordinate-prototype","emmy.calculus.coordinate/quotify-coordinate-prototype",-289125452,null);Mac=new $APP.q("emmy.simplify.rules","miscsimp","emmy.simplify.rules/miscsimp",1212725056,null);Nac=new $APP.E(null,"def-emits-var","def-emits-var",-1551927320);Oac=new $APP.q(null,"richardson-sequence","richardson-sequence",1960734964,null);Pac=new $APP.q(null,"lowcol","lowcol",-1417324880,null);
Qac=new $APP.q("emmy.matrix","s:invert","emmy.matrix/s:invert",234858361,null);Rac=new $APP.q(null,"TapeCell","TapeCell",-1115833436,null);Sac=new $APP.q(null,"sincos-flush-ones","sincos-flush-ones",227136733,null);Tac=new $APP.E(null,"uuid","uuid",-2145095719);Uac=new $APP.q(null,"-\x3et_emmy$rational_function49062","-\x3et_emmy$rational_function49062",-205216233,null);Vac=new $APP.q(null,"set-js-meta!","set-js-meta!",-540544347,null);
Wac=new $APP.q(null,"make-integrator","make-integrator",1359161389,null);LY=new $APP.q(null,"div","div",-1597244137,null);Xac=new $APP.q("emmy.mechanics.rotation","Rx","emmy.mechanics.rotation/Rx",541610072,null);Yac=new $APP.q(null,"emmy.abstract.function","emmy.abstract.function",-1169683343,null);Zac=new $APP.q("emmy.env","i:contract","emmy.env/i:contract",-464699005,null);$ac=new $APP.q(null,"function-\x3eoneform-field","function-\x3eoneform-field",596015058,null);
abc=new $APP.q(null,"IArity","IArity",-158622163,null);bbc=new $APP.q("emmy.env","asin","emmy.env/asin",-1754119131,null);cbc=new $APP.q("emmy.matrix","determinant","emmy.matrix/determinant",-1872172177,null);dbc=new $APP.q("emmy.mechanics.rotation","Ry","emmy.mechanics.rotation/Ry",-152294631,null);ebc=new $APP.q("emmy.mechanics.rotation","Rz","emmy.mechanics.rotation/Rz",1137068167,null);fbc=new $APP.q(null,"dense-coefficients","dense-coefficients",-384887247,null);
gbc=new $APP.q(null,"rational-function?","rational-function?",-545892330,null);hbc=new $APP.q("emmy.polynomial","mul","emmy.polynomial/mul",472422219,null);ibc=new $APP.q("emmy.pattern.match","or","emmy.pattern.match/or",-1428347965,null);jbc=new $APP.q(null,"cljs","cljs",-1162018140,null);kbc=new $APP.E(null,"invalid-array-access","invalid-array-access",-1747132236);lbc=new $APP.q("emmy.matrix","by-rows*","emmy.matrix/by-rows*",166732610,null);
mbc=new $APP.q(null,"emmy.polynomial.factor","emmy.polynomial.factor",-654922990,null);nbc=new $APP.q("emmy.generic","lcm","emmy.generic/lcm",1332899931,null);obc=new $APP.q("emmy.calculus.form-field","nform-field?","emmy.calculus.form-field/nform-field?",2101256690,null);pbc=new $APP.q("emmy.env","coords-\x3eevent","emmy.env/coords-\x3eevent",-392340088,null);qbc=new $APP.q("emmy.mechanics.lagrange","Qdotdot","emmy.mechanics.lagrange/Qdotdot",-203746645,null);
rbc=new $APP.q("emmy.matrix","two-tensor-operation","emmy.matrix/two-tensor-operation",-154084714,null);sbc=new $APP.q("emmy.polynomial","make","emmy.polynomial/make",-978068300,null);f3a=new $APP.E(null,"manifold","manifold",-1940328209);tbc=new $APP.q("emmy.special.factorial","multi-factorial","emmy.special.factorial/multi-factorial",-1161369505,null);ubc=new $APP.q(null,"coordinate-system-ctor","coordinate-system-ctor",301188674,null);
vbc=new $APP.q("emmy.quaternion","from-complex","emmy.quaternion/from-complex",340768920,null);wbc=new $APP.q("emmy.sr.frames","make-SR-coordinates","emmy.sr.frames/make-SR-coordinates",701443321,null);xbc=new $APP.q("emmy.env","S2-metric","emmy.env/S2-metric",-2062952604,null);ybc=new $APP.q("emmy.pattern.match","sequence*","emmy.pattern.match/sequence*",584918258,null);zbc=new $APP.q(null,"scale-l","scale-l",33154067,null);
Abc=new $APP.q("emmy.polynomial.gcd","lcm","emmy.polynomial.gcd/lcm",-1011771964,null);Bbc=new $APP.q("emmy.quaternion","log","emmy.quaternion/log",-761068821,null);MY=new $APP.q(null,"the-rule","the-rule",58807572,null);Cbc=new $APP.q("emmy.expression.analyze","known-operation?","emmy.expression.analyze/known-operation?",102835086,null);CVa=new $APP.E(null,"iso8601","iso8601",609352650);Dbc=new $APP.q(null,"pass","pass",-1080275776,null);
Ebc=new $APP.q(null,"compile-pattern","compile-pattern",424625475,null);Fbc=new $APP.q(null,"literal-Christoffel-1","literal-Christoffel-1",2054549682,null);Gbc=new $APP.q(null,"literal-Christoffel-2","literal-Christoffel-2",632148524,null);Hbc=new $APP.q(null,"Cartan-\x3eChristoffel","Cartan-\x3eChristoffel",-466028067,null);Ibc=new $APP.q("emmy.env","asec","emmy.env/asec",-1132449064,null);Jbc=new $APP.q("emmy.abstract.number","literal-number","emmy.abstract.number/literal-number",1151999273,null);
Kbc=new $APP.q("emmy.calculus.connection","metric-\x3eChristoffel-1","emmy.calculus.connection/metric-\x3eChristoffel-1",-346132889,null);Lbc=new $APP.q("emmy.calculus.vector-calculus","coordinate-system-\x3eorthonormal-vector-basis","emmy.calculus.vector-calculus/coordinate-system-\x3eorthonormal-vector-basis",-1404078301,null);Mbc=new $APP.q("emmy.calculus.connection","metric-\x3eChristoffel-2","emmy.calculus.connection/metric-\x3eChristoffel-2",1011000965,null);
Nbc=new $APP.q("emmy.structure","map-chain","emmy.structure/map-chain",1328036341,null);Obc=new $APP.q("emmy.matrix","literal-row-matrix","emmy.matrix/literal-row-matrix",123782868,null);Pbc=new $APP.q("emmy.env","component","emmy.env/component",-48202874,null);Qbc=new $APP.q(null,"extract-id","extract-id",13462904,null);Rbc=new $APP.q(null,"emmy.sr.frames","emmy.sr.frames",1823371956,null);Sbc=new $APP.q("Math","tan","Math/tan",-1378236364,null);Tbc=new $APP.q(null,"pairs","pairs",-2039825990,null);
Ubc=new $APP.q("cljs.core","string?","cljs.core/string?",-2072921719,null);O$a=new $APP.E(null,"central","central",467059073);Vbc=new $APP.q("emmy.generic","log","emmy.generic/log",-647758938,null);w5a=new $APP.E(null,"symbols","symbols",1211743);Wbc=new $APP.q(null,"parse-complex","parse-complex",941088514,null);Xbc=new $APP.q("emmy.generic","solve-linear","emmy.generic/solve-linear",-1065954809,null);bSa=new $APP.q("cljs.core","IList","cljs.core/IList",1015168964,null);
Ybc=new $APP.q("emmy.pattern.match","all-results","emmy.pattern.match/all-results",1753481397,null);Zbc=new $APP.q("emmy.pattern.match","eq","emmy.pattern.match/eq",2043848955,null);$bc=new $APP.q(null,"*sqrt-expt-simplify?*","*sqrt-expt-simplify?*",-352822736,null);acc=new $APP.q(null,"evolution","evolution",-1709615212,null);bcc=new $APP.q(null,"valid-modes","valid-modes",-813432109,null);
ccc=new $APP.q("emmy.rational-function.interpolate","modified-bulirsch-stoer-scan","emmy.rational-function.interpolate/modified-bulirsch-stoer-scan",1730821408,null);dcc=new $APP.E(null,"left-riemann","left-riemann",-330641680);ecc=new $APP.q("emmy.env","acosh","emmy.env/acosh",1339324932,null);fcc=new $APP.q("emmy.env","differential-of-map","emmy.env/differential-of-map",939285474,null);gcc=new $APP.q("emmy.generic","make-polar","emmy.generic/make-polar",1111002320,null);
hcc=new $APP.q(null,"base-frame-point","base-frame-point",908107138,null);yP=new $APP.q(null,"down","down",-1089190199,null);icc=new $APP.q("emmy.polynomial","partial-derivatives","emmy.polynomial/partial-derivatives",-650670957,null);jcc=new $APP.q("emmy.env","euler","emmy.env/euler",-1346592994,null);kcc=new $APP.q("emmy.quaternion","K-matrix","emmy.quaternion/K-matrix",-2139117615,null);lcc=new $APP.q("emmy.env","acoth","emmy.env/acoth",572107844,null);
GG=new $APP.E("emmy.value","integral","emmy.value/integral",-970970786);mcc=new $APP.q(null,"T-func","T-func",476643498,null);ncc=new $APP.q("emmy.env","literal-metric","emmy.env/literal-metric",1472684204,null);occ=new $APP.q("emmy.env","chart","emmy.env/chart",-447426825,null);pcc=new $APP.q(null,"trailing-coefficient","trailing-coefficient",217002391,null);qcc=new $APP.q(null,"-\x3ePolynomial","-\x3ePolynomial",511280004,null);rcc=new $APP.q(null,"frame-params","frame-params",-951014115,null);
scc=new $APP.q(null,"top-down","top-down",-1237101201,null);tcc=new $APP.q("emmy.env","Div","emmy.env/Div",959379402,null);ucc=new $APP.q("emmy.env","i:outer-product","emmy.env/i:outer-product",1436815015,null);vcc=new $APP.q("emmy.operator","commutator","emmy.operator/commutator",-119463125,null);wcc=new $APP.q(null,"zero-like","zero-like",-895025247,null);NY=new $APP.q("emmy.value","IKind","emmy.value/IKind",-1473468716,null);
xcc=new $APP.q("emmy.quaternion","commutator","emmy.quaternion/commutator",1304432849,null);ycc=new $APP.q(null,"cartan","cartan",1692318531,null);zcc=new $APP.q("emmy.env","literal-Lagrangian-state","emmy.env/literal-Lagrangian-state",1324063383,null);Acc=new $APP.q("emmy.polynomial","leading-coefficient","emmy.polynomial/leading-coefficient",-432834753,null);Bcc=new $APP.q("emmy.expression.analyze","make-analyzer","emmy.expression.analyze/make-analyzer",-295571899,null);
Ccc=new $APP.q(null,"bulirsch-stoer-recursive","bulirsch-stoer-recursive",1302097042,null);hUa=new $APP.E("rl","peek","rl/peek",-291391771);Dcc=new $APP.q("emmy.env","expression-\x3estream","emmy.env/expression-\x3estream",-1342794740,null);Ecc=new $APP.q("emmy.env","symmetrize-Cartan","emmy.env/symmetrize-Cartan",-2086446341,null);Fcc=new $APP.q("emmy.util","parse-int","emmy.util/parse-int",-1027318049,null);Gcc=new $APP.q(null,"up*","up*",1811123313,null);
OY=new $APP.q(null,"up?","up?",1718386499,null);Hcc=new $APP.q("cljs.core","simple-keyword?","cljs.core/simple-keyword?",39474330,null);Icc=new $APP.q(null,"cross-product","cross-product",-823528331,null);Jcc=new $APP.q(null,"skel","skel",-840013828,null);Kcc=new $APP.q(null,"emmy.sr.boost","emmy.sr.boost",1325352729,null);uVa=new $APP.E(null,"?err_","?err_",789480858);Lcc=new $APP.q("emmy.sr.frames","add-v:cs","emmy.sr.frames/add-v:cs",1860125053,null);
QZa=new $APP.E(null,"orientations","orientations",146962442);vab=new $APP.E(null,"boost-direction","boost-direction",-1975902118);Mcc=new $APP.q("emmy.calculus.manifold","S2-type","emmy.calculus.manifold/S2-type",-187537129,null);Ncc=new $APP.q("emmy.numerical.quadrature","definite-integral","emmy.numerical.quadrature/definite-integral",-1059883113,null);Occ=new $APP.q(null,"exp-\x3esincos","exp-\x3esincos",-887623320,null);Pcc=new $APP.q(null,"valid-arity?","valid-arity?",233342812,null);
Qcc=new $APP.q("emmy.quaternion","sinh","emmy.quaternion/sinh",-185436686,null);Rcc=new $APP.q("emmy.env","frame-maker","emmy.env/frame-maker",387237479,null);L_a=new $APP.E(null,"started?","started?",-1301062863);Scc=new $APP.q("emmy.polynomial","polynomial?","emmy.polynomial/polynomial?",1238725886,null);Tcc=new $APP.q("emmy.mechanics.rotation","wcross-\x3ew","emmy.mechanics.rotation/wcross-\x3ew",-2094852622,null);$APP.Ucc=new $APP.E(null,"v","v",21465059);$APP.aQ=new $APP.E(null,"r","r",-471384190);
$APP.VQa=new $APP.E(null,"t","t",-1397832519);ED=new $APP.E(null,"libspecs","libspecs",59807195);DR=new $APP.E(null,"q","q",689001697);PY=new $APP.q(null,"v:c","v:c",1270894894,null);YG=new $APP.E(null,"p","p",151049309);Vcc=new $APP.q("emmy.calculus.manifold","S2p-tilted","emmy.calculus.manifold/S2p-tilted",-1979695782,null);Wcc=new $APP.q(null,"kahan-babushka-neumaier","kahan-babushka-neumaier",-1310408534,null);Xcc=new $APP.q("emmy.env","imag-part","emmy.env/imag-part",-1123865539,null);
Ycc=new $APP.q(null,"canonicalize-partials","canonicalize-partials",1040991839,null);MTa=new $APP.q(null,".abs",".abs",1832478636,null);Zcc=new $APP.q("emmy.env","arg-scale","emmy.env/arg-scale",-1942276833,null);$cc=new $APP.q(null,"p-seq","p-seq",-1578923571,null);adc=new $APP.E(null,"check-coordinates","check-coordinates",2142442590);M4a=new $APP.E("emmy.calculus.basis","basis","emmy.calculus.basis/basis",-1395050689);bQ=new $APP.E(null,"l","l",1395893423);
e7a=new $APP.E(null,"nonzero-delta","nonzero-delta",-794646863);bdc=new $APP.q(null,"default-epsilon","default-epsilon",167984498,null);cdc=new $APP.q(null,"exp10","exp10",-1005012445,null);r7a=new $APP.E(null,"simplex-tolerance","simplex-tolerance",1524945145);ddc=new $APP.q("emmy.calculus.manifold","manifold-type","emmy.calculus.manifold/manifold-type",-32288893,null);edc=new $APP.q("emmy.polynomial","cube","emmy.polynomial/cube",-641467543,null);
fdc=new $APP.q(null,"with-arity","with-arity",1915481989,null);gdc=new $APP.q(null,"consequent-fn","consequent-fn",381611694,null);hdc=new $APP.q(null,"H-state-\x3eL-state","H-state-\x3eL-state",-455042562,null);idc=new $APP.q("emmy.mechanics.lagrange","-\x3elocal","emmy.mechanics.lagrange/-\x3elocal",615465306,null);X9a=new $APP.E(null,"M","M",-1755742206);C9a=new $APP.E(null,"F","F",-1115543258);$APP.jdc=new $APP.q(null,"segment","segment",675610331,null);
kdc=new $APP.q("emmy.structure","vector-inner-product","emmy.structure/vector-inner-product",1474392821,null);ldc=new $APP.q(null,"splice?","splice?",1977106547,null);mdc=new $APP.q("emmy.numerical.unimin.golden","golden-section-max","emmy.numerical.unimin.golden/golden-section-max",28195764,null);ndc=new $APP.q(null,"vector-field-\x3ecomponents","vector-field-\x3ecomponents",-1993765828,null);odc=new $APP.q("cljs.core","*","cljs.core/*",-857794892,null);
HG=new $APP.q("cljs.core","+","cljs.core/+",-342754435,null);pdc=new $APP.q(null,"m:generate","m:generate",-746017331,null);qdc=new $APP.q("emmy.calculus.metric","lower","emmy.calculus.metric/lower",-1550311246,null);rdc=new $APP.q(null,"anticommutator","anticommutator",369809372,null);PM=new $APP.q(null,"csc","csc",-427853492,null);sdc=new $APP.q("emmy.calculus.vector-calculus","Grad","emmy.calculus.vector-calculus/Grad",-1657004746,null);
tdc=new $APP.q("emmy.env","Euler-Lagrange-operator","emmy.env/Euler-Lagrange-operator",990394897,null);udc=new $APP.q("cljs.core","char?","cljs.core/char?",416405281,null);vdc=new $APP.q(null,"inv-phi","inv-phi",-425271954,null);wdc=new $APP.E(null,"case-then","case-then",2107591745);xdc=new $APP.q("emmy.util.stream","seq-print","emmy.util.stream/seq-print",-1184485848,null);ydc=new $APP.q("emmy.structure","up-of-downs?","emmy.structure/up-of-downs?",-38784916,null);
zdc=new $APP.q("emmy.matrix","cofactors","emmy.matrix/cofactors",533870010,null);Adc=new $APP.q("emmy.calculus.covariant","Christoffel?","emmy.calculus.covariant/Christoffel?",-2022725499,null);NTa=new $APP.q("js","Math","js/Math",2033291075,null);Bdc=new $APP.E(null,"orthonormalize?","orthonormalize?",-11872752);Cdc=new $APP.q(null,"factor","factor",-462641221,null);Ddc=new $APP.q("emmy.expression.compile","compile-state-fn","emmy.expression.compile/compile-state-fn",907497701,null);
Edc=new $APP.q("emmy.simplify.rules","contract-expt-trig","emmy.simplify.rules/contract-expt-trig",799206241,null);I6a=new $APP.E(null,"ppath","ppath",-1758182784);Fdc=new $APP.q(null,"literal-metric","literal-metric",-1799706791,null);QY=new $APP.q(null,"default-absolute-threshold","default-absolute-threshold",986519052,null);Gdc=new $APP.q("emmy.series","acot-series","emmy.series/acot-series",-1503167911,null);Hdc=new $APP.q(null,"Routhian","Routhian",-451266995,null);
Idc=new $APP.q(null,"lagrange","lagrange",1990996687,null);ME=new $APP.E(null,"protocol-impl","protocol-impl",2101328365);Jdc=new $APP.q("emmy.calculus.covariant","covariant-differential","emmy.calculus.covariant/covariant-differential",299230560,null);Kdc=new $APP.q("emmy.env","-\x3eTeX","emmy.env/-\x3eTeX",-1847038738,null);Ldc=new $APP.q("Math","atanh","Math/atanh",-1910277884,null);RY=new $APP.q(null,"initial-guess","initial-guess",-242610878,null);
Mdc=new $APP.q("emmy.polynomial.interpolate","neville-fold","emmy.polynomial.interpolate/neville-fold",-630269823,null);Ndc=new $APP.q("emmy.env","-\x3estate","emmy.env/-\x3estate",-674926849,null);Odc=new $APP.q("emmy.mechanics.hamilton","multiplicative-transpose","emmy.mechanics.hamilton/multiplicative-transpose",-1614087805,null);Pdc=new $APP.q("emmy.structure","transpose-outer","emmy.structure/transpose-outer",-812532823,null);
Qdc=new $APP.q("emmy.calculus.covariant","Cartan-\x3eChristoffel","emmy.calculus.covariant/Cartan-\x3eChristoffel",388236940,null);Rdc=new $APP.q(null,"!\x3d\x3e","!\x3d\x3e",527534792,null);Sdc=new $APP.q(null,"embedding-map-\x3emetric-components","embedding-map-\x3emetric-components",-1000114547,null);Tdc=new $APP.q("emmy.calculus.basis","contract","emmy.calculus.basis/contract",804023804,null);Udc=new $APP.q("emmy.generic","atanh","emmy.generic/atanh",-779953135,null);
Vdc=new $APP.q("emmy.numerical.ode","stream-integrator","emmy.numerical.ode/stream-integrator",-1398101800,null);Wdc=new $APP.q(null,"*sin-cos-simplify?*","*sin-cos-simplify?*",-187838922,null);Xdc=new $APP.q(null,"matrix?","matrix?",1297778417,null);Ydc=new $APP.q("cljs.core","/","cljs.core//",-696756880,null);SY=new $APP.q("emmy.util","bigint","emmy.util/bigint",-894648022,null);Zdc=new $APP.q("emmy.env","basis?","emmy.env/basis?",189457469,null);C6a=new $APP.E("zip","branch?","zip/branch?",-998880862);
$dc=new $APP.q("emmy.pattern.rule","failure","emmy.pattern.rule/failure",1057133778,null);aec=new $APP.q("emmy.env","row-matrix","emmy.env/row-matrix",-892177403,null);bec=new $APP.E(null,"goog-define","goog-define",-1048305441);cec=new $APP.E(null,"nodejs-rt","nodejs-rt",-512437071);dec=new $APP.q("emmy.algebra.fold","kbk-n","emmy.algebra.fold/kbk-n",-1261394355,null);TY=new $APP.q(null,"qdot","qdot",-754984603,null);eec=new $APP.q(null,"L-Kepler-polar","L-Kepler-polar",-1377249844,null);
fec=new $APP.q("emmy.polynomial","constant","emmy.polynomial/constant",-1683198938,null);gec=new $APP.q("emmy.matrix","by-rows","emmy.matrix/by-rows",537461417,null);hec=new $APP.q(null,"v1:c","v1:c",-1611587706,null);iec=new $APP.q(null,"coordinate-system-\x3emetric","coordinate-system-\x3emetric",2009542622,null);jec=new $APP.q(null,"L-uniform-acceleration","L-uniform-acceleration",-369576403,null);kec=new $APP.q("emmy.env","point","emmy.env/point",45740882,null);
lec=new $APP.q("emmy.mechanics.rigid","M-\x3eomega-body","emmy.mechanics.rigid/M-\x3eomega-body",-1138673574,null);mec=new $APP.q("emmy.env","anticommutator","emmy.env/anticommutator",1424531377,null);nec=new $APP.q("emmy.mechanics.hamilton","H-state-\x3ematrix","emmy.mechanics.hamilton/H-state-\x3ematrix",-131131554,null);oec=new $APP.E(null,"invalid-arity","invalid-arity",1335461949);pec=new $APP.q(null,"three-vector","three-vector",-512585855,null);
qec=new $APP.q("emmy.calculus.form-field","form-field?","emmy.calculus.form-field/form-field?",-990940063,null);rec=new $APP.q("emmy.mechanics.hamilton","qp-canonical?","emmy.mechanics.hamilton/qp-canonical?",1748483215,null);UY=new $APP.q(null,"values","values",2013177083,null);sec=new $APP.q("emmy.calculus.vector-field","vector-field?","emmy.calculus.vector-field/vector-field?",2010073622,null);tec=new $APP.q("emmy.series","value","emmy.series/value",-1131696377,null);
LD=new $APP.E(null,"locals","locals",535295783);var eM={},I_a={},VY=function VY(a){switch(arguments.length){case 1:return VY.j(arguments[0]);case 2:return VY.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};VY.j=function(a){return VY.A(a,0)};VY.A=function(a,b){var c=$APP.kh.j(b);return new $APP.H(null,2,5,$APP.I,[c,function(d){$APP.lh.A(c,$APP.Lc);return a.j?a.j(d):a.call(null,d)}],null)};VY.G=2;var uec=Math.sqrt,WY=Math.pow,mQ=Math.abs,vec=BigInt,OR;
a:for(var wec=1;;){if($APP.Uc.A(1,wec+1)){OR=2*wec;break a}wec/=2}var JR=Math.sqrt(OR);var XY,JPa,IPa;$APP.EEa={};JPa=new $APP.ug(null,new $APP.f(null,2,[$APP.$x,"null",$APP.zv,"null"],null),null);IPa=new $APP.ug(null,new $APP.f(null,2,[KPa,"null",$APP.KAa,"null"],null),null);var bOa=new $APP.ug(null,new $APP.f(null,9,[$APP.sE,null,hRa,null,$APP.Nw,null,$APP.Gk,null,$APP.Ok,null,DRa,null,uE,null,iRa,null,$APP.Bl,null],null),null);$APP.z($APP.vg,new $APP.f(null,1,[$0b,$APP.sf],null));var tF=null,EE=!1;$APP.kh.j(!1);
var aE=$APP.fg([CRa,CYb,atb,h4b,yPa,Anb,kib,S6b,NXb,slb,b1b,jF,cF,NSb,rJb,ARa,xOa,kEb,WHb,gnb,vfb,$APP.im,kbc,VSb,VE,POa,Hac,Dkb,rRa,Job,RE,uNb,fGb,FQb,Y1b,SPb,F3b,P$b,V3b],[!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!1,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0]),xec=new $APP.ug(null,new $APP.f(null,63,["typeof",null,"float",null,"implements",null,"else",null,"boolean",null,"abstract",null,"int",null,"static",null,"package",null,"this",null,"await",null,"yield",null,"interface",
null,"void",null,"delete",null,"class",null,"export",null,"var",null,"try",null,"long",null,"null",null,"return",null,"methods",null,"native",null,"private",null,"new",null,"for",null,"catch",null,"extends",null,"short",null,"protected",null,"throws",null,"synchronized",null,"transient",null,"super",null,"if",null,"let",null,"import",null,"char",null,"switch",null,"const",null,"case",null,"break",null,"volatile",null,"function",null,"continue",null,"final",null,"do",null,"double",null,"while",null,
"public",null,"arguments",null,"debugger",null,"with",null,"instanceof",null,"default",null,"throw",null,"goto",null,"finally",null,"byte",null,"constructor",null,"in",null,"enum",null],null),null),OD={},oF=function(){var a=$APP.kh.j($APP.F),b=$APP.kh.j($APP.F),c=$APP.kh.j($APP.F),d=$APP.kh.j($APP.F),g=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));return new $APP.Ch($APP.Zg.A("cljs.analyzer","error-message"),function(){function l(n,p){if(1<arguments.length)for(var v=0,t=Array(arguments.length-
1);v<t.length;)t[v]=arguments[v+1],++v;return n}l.G=1;l.M=function(n){var p=$APP.u(n);$APP.Fc(n);return p};l.C=function(n){return n};return l}(),$APP.yj,g,a,b,c,d)}();oF.F(null,WHb,function(a,b){return["Preamble resource file not found: ",$APP.Kl.A(" ",lkb.j(b))].join("")});oF.F(null,VSb,function(a,b){return["Required namespace not provided for ",$APP.Kl.A(" ",VSb.j(b))].join("")});
oF.F(null,xOa,function(a,b){return[$APP.k(yOa.j(b))?"Can't take value of macro ":"Use of undeclared Var ",$APP.m.j($APP.Dv.j(b)),"/",$APP.m.j($APP.rq.j(b))].join("")});oF.F(null,S6b,function(a,b){return["var: ",$APP.m.j($APP.mx.j(b))," is not public"].join("")});
oF.F(null,POa,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,QOa);b=$APP.C.A(b,ROa);return["No such namespace: ",$APP.m.j(a),", could not locate ",TD(a,$APP.Uu),", ",TD(a,Cmb),', or JavaScript source providing "',$APP.m.j(b),'"',$APP.Tda(TD(a,$APP.Uu),"_")?" (Please check that namespaces with dashes use underscores in the ClojureScript file name)":null].join("")});
oF.F(null,kxb,function(a,b){a=$APP.qe(b);b=$APP.C.A(a,QOa);$APP.C.A(a,ROa);return["No such macros namespace: ",$APP.m.j(b),", could not locate ",TD(b,IG)," or ",TD(b,Cmb)].join("")});oF.F(null,$APP.im,function(a,b){return[$APP.m.j($APP.Q.j(b))," not declared ^:dynamic"].join("")});oF.F(null,h4b,function(a,b){return[$APP.m.j($APP.mx.j(b))," already refers to: ",$APP.m.j($APP.Zg.A($APP.m.j($APP.yl.j(b)),$APP.m.j($APP.mx.j(b))))," being replaced by: ",$APP.m.j($APP.Zg.A($APP.m.j(yX.j(b)),$APP.m.j($APP.mx.j(b))))].join("")});
oF.F(null,Y1b,function(a,b){return[$APP.m.j($APP.mx.j(b))," at line ",$APP.m.j($APP.Xi.j(b))," is being replaced"].join("")});oF.F(null,RE,function(a,b){return[$APP.m.j($APP.Zg.A($APP.m.j(yX.j(b)),$APP.m.j($APP.mx.j(b))))," no longer fn, references are stale"].join("")});oF.F(null,jF,function(a,b){a=$APP.m.j(kF.j(b));var c=$APP.m,d=c.j,g=YOa.j(b);b=$APP.k(g)?g:$APP.Q.j(b);return["Wrong number of args (",a,") passed to ",d.call(c,b)].join("")});
oF.F(null,ARa,function(a,b){return[$APP.m.j($APP.Q.j($APP.Yu.j(BRa.j(b))))," is deprecated"].join("")});oF.F(null,kEb,function(a,b){return[$APP.m.j($APP.Zg.A($APP.m.j(yX.j(b)),$APP.m.j($APP.mx.j(b))))," declared arglists ",$APP.m.j($APP.Ru.j(b))," mismatch defined arglists ",$APP.m.j(IBb.j(b))].join("")});oF.F(null,Dkb,function(a,b){return["Invalid :refer, ",$APP.m.j($APP.Ui.j(b))," ",$APP.m.j($APP.yfa.j(b)),"/",$APP.m.j($APP.mx.j(b))," does not exist"].join("")});
oF.F(null,Job,function(a,b){return["Protocol ",$APP.m.j($APP.Pm.j(b))," is deprecated"].join("")});oF.F(null,gnb,function(a,b){return["Can't resolve protocol symbol ",$APP.m.j($APP.Pm.j(b))].join("")});oF.F(null,kib,function(a,b){return["Symbol ",$APP.m.j($APP.Pm.j(b))," is not a protocol"].join("")});
oF.F(null,SPb,function(a,b){return $APP.k(kyb.j(b))?["Bad method signature in protocol implementation, ",$APP.m.j($APP.Pm.j(b))," does not declare method called ",$APP.m.j(Peb.j(b))].join(""):["Bad method signature in protocol implementation, ",$APP.m.j($APP.Pm.j(b))," ",$APP.m.j(Peb.j(b))," does not declare arity ",$APP.m.j(oec.j(b))].join("")});oF.F(null,NXb,function(a,b){return["Duplicated methods in protocol implementation ",$APP.m.j($APP.Pm.j(b))," ",$APP.m.j(Peb.j(b))].join("")});
oF.F(null,FQb,function(a,b){return["Protocol ",$APP.m.j($APP.Pm.j(b))," implemented multiple times"].join("")});oF.F(null,rJb,function(a,b){return["Protocol ",$APP.m.j($APP.Pm.j(b))," declares method ",$APP.m.j($APP.Q.j(b))," with variadic signature (\x26)"].join("")});oF.F(null,vfb,function(a,b){a=$APP.Pm.j(qOb.j(b));return["Protocol ",$APP.m.j($APP.Pm.j(b))," is overwriting ",$APP.k(a)?"method":"function"," ",$APP.m.j($APP.Q.j(b)),$APP.k(a)?[" of protocol ",$APP.Ag(a)].join(""):null].join("")});
oF.F(null,V3b,function(a,b){return["Protocol ",$APP.m.j($APP.Pm.j(b))," implements method ",$APP.m.j($APP.Q.j(b))," with variadic signature (\x26)"].join("")});oF.F(null,uNb,function(a,b){return['Ignoring target object "',$APP.jh.C($APP.y([$APP.Qw.j(b)])),'" passed in recur to protocol method head'].join("")});oF.F(null,P$b,function(a,b){return[$APP.m.j($APP.Q.j(b)),": Can't have more than 1 variadic overload"].join("")});oF.F(null,NSb,function(a,b){return[$APP.m.j($APP.Q.j(b)),": Can't have fixed arity function with more params than variadic function"].join("")});
oF.F(null,fGb,function(a,b){return[$APP.m.j($APP.Q.j(b)),": Can't have 2 overloads with same arity"].join("")});oF.F(null,CYb,function(a,b){return["Extending an existing JavaScript type - use a different symbol name instead of ",$APP.m.j(wxb.j(b))," e.g ",$APP.m.j(Hpb.j(b))].join("")});oF.F(null,rRa,function(a,b){return[$APP.m.j(fF.j(b)),", all arguments must be numbers, got ",$APP.m.j(qRa.j(b))," instead"].join("")});
oF.F(null,kbc,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,$APP.Q);b=$APP.C.A(b,qRa);if($APP.Uc.A(Meb,a)||$APP.Uc.A(D3b,a))return["cljs.core/aget, arguments must be an array followed by numeric indices, got ",$APP.m.j(b)," instead",$APP.Uc.A($APP.dy,$APP.u(b))||$APP.Ge(new $APP.ug(null,new $APP.f(null,1,[$APP.Gy,null],null),null),$APP.Fc(b))?[" (consider ",2===$APP.Tc(b)?"goog.object/get":"goog.object/getValueByKeys"," for object access)"].join(""):null].join("");if($APP.Uc.A(VWb,a)||$APP.Uc.A(Tab,a))return["cljs.core/aset, arguments must be an array, followed by numeric indices, followed by a value, got ",
$APP.m.j(b)," instead",$APP.Uc.A($APP.dy,$APP.u(b))||$APP.Ge(new $APP.ug(null,new $APP.f(null,1,[$APP.Gy,null],null),null),$APP.zg($APP.Fc(b)))?" (consider goog.object/set for object access)":null].join("");throw Error(["No matching clause: ",$APP.m.j(a)].join(""));});oF.F(null,CRa,function(a,b){return["Cannot invoke type constructor ",$APP.m.j($APP.Q.j($APP.Yu.j(BRa.j(b))))," as function "].join("")});oF.F(null,b1b,function(a,b){return[$APP.m.j($APP.Q.j(b))," is a single segment namespace"].join("")});
oF.F(null,slb,function(a,b){a=$APP.qe(b);a=$APP.C.A(a,$APP.Q);b=$APP.hi($APP.Kl.A(".",$APP.Vg.A(function(c){return $APP.k(xec.j?xec.j(c):xec.call(null,c))?[$APP.m.j(c),"$"].join(""):c},$APP.qi.A($APP.Ag(a),/\./))));return["Namespace ",$APP.m.j(a)," contains a reserved JavaScript keyword, the corresponding Google Closure namespace will be munged to ",$APP.m.j(b)].join("")});
oF.F(null,VE,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,$APP.yl);b=$APP.C.A(b,$APP.Gk);return["Namespace ",$APP.m.j(a)," clashes with var ",$APP.m.j(b)].join("")});oF.F(null,Hac,function(a,b){a=$APP.qe(b);a=$APP.C.A(a,$APP.Gk);return[$APP.m.j(a)," not declared dynamic and thus is not dynamically rebindable, but its name suggests otherwise. Please either indicate ^:dynamic ",$APP.m.j(a)," or change the name"].join("")});
oF.F(null,F3b,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,$APP.Pm);b=$APP.C.A(b,$APP.ny);return["Bad extend-type method shape for protocol ",$APP.m.j(a)," method ",$APP.m.j(b),", method arities must be grouped together"].join("")});oF.F(null,Anb,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,tkb);b=$APP.C.A(b,$APP.Wi);return["Unsupported JavaScript module type ",$APP.m.j(a)," for foreign library ",$APP.m.j(b),"."].join("")});
oF.F(null,atb,function(a,b){b=$APP.qe(b);a=$APP.C.A(b,gpb);b=$APP.C.A(b,$APP.Wi);return["Unsupported preprocess value ",$APP.m.j(a)," for foreign library ",$APP.m.j(b),"."].join("")});oF.F(null,yPa,function(a,b){a=$APP.qe(b);a=$APP.C.A(a,$APP.Q);return[$APP.m.j(a)," is shadowed by a local"].join("")});
oF.F(null,cF,function(a,b){var c=$APP.qe(b),d=$APP.C.A(c,fRa);a=$APP.C.A(c,$APP.Qw);b=$APP.C.A(c,$APP.Ui);c=$APP.C.A(c,dF);d=d instanceof $APP.E?d.ga:null;switch(d){case "target":return["Cannot infer target type in expression ",$APP.m.j(a),""].join("");case "property":return["Cannot resolve property ",$APP.m.j(c)," for inferred type ",$APP.m.j(b)," in expression ",$APP.m.j(a)].join("");case "object":return["Adding extern to Object for property ",$APP.m.j(c)," due to ambiguous expression ",$APP.m.j(a)].join("");
default:throw Error(["No matching clause: ",$APP.m.j(d)].join(""));}});
var ZD=new $APP.H(null,1,5,$APP.I,[function(a,b,c){if($APP.k(a.j?a.j(aE):a.call(null,aE)))if(a=oF.A(a,c),$APP.k(a)){c=$APP.ab;$APP.ab=$APP.yaa;try{var d=$APP.Yt.C,g=["WARNING: ",$APP.m.j(a)].join("");var l=YD.A?YD.A(b,g):YD.call(null,b,g);return d.call($APP.Yt,$APP.y([l]))}finally{$APP.ab=c}}else return null;else return null}],null),yec=new $APP.f(null,2,[$APP.An,new $APP.f(null,1,[$APP.Q,$APP.An],null),aQa,new $APP.f(null,1,[$APP.Q,aQa],null)],null);
if("undefined"===typeof $APP.se||"undefined"===typeof $APP.EEa||"undefined"===typeof XY)XY=function(a){this.mk=a;this.O=425984;this.U=0},XY.prototype.da=function(a,b){return new XY(b)},XY.prototype.ba=function(){return this.mk},XY.prototype.Wa=function(){return yec},XY.cb=!0,XY.Ya="cljs.analyzer/t_cljs$analyzer35035",XY.gb=function(a){return $APP.Vb(a,"cljs.analyzer/t_cljs$analyzer35035")};new XY($APP.F);
var OOa=new $APP.ug(null,new $APP.f(null,6,[GVb,"null",qRb,"null",qBb,"null",$APP.Hza,"null",$APP.$w,"null",TBb,"null"],null),null),BOa=$APP.mh(function(a,b){return $APP.Bd($APP.Lf.B($APP.vg,$APP.bf.j(function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return new $APP.H(null,2,5,$APP.I,[d,$APP.Q.j(c)],null)}),a),$APP.m.j(b))}),jE=function jE(a){switch(arguments.length){case 3:return jE.B(arguments[0],arguments[1],arguments[2]);case 4:return jE.K(arguments[0],arguments[1],arguments[2],arguments[3]);
default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};jE.B=function(a,b,c){return jE.K(a,b,c,zOa())};
jE.K=function(a,b,c,d){var g=$APP.m.j(c);c=".."!==g&&/\./.test(g)?$APP.u($APP.qi.A(g,/\./)):c;c=$APP.Zg.j(c);(g=$APP.Bd(OOa,b))||($APP.k(PD($APP.Fb(null),RD,b))?g=null:(g=$APP.yl.j(a),g=null!=$APP.C.A($APP.bk.j(g),b)||null!=$APP.C.A($APP.um.j(g),b)),g=g||$APP.Uc.A($APP.An,b)&&$APP.Uc.A($APP.vxa,c)||null!=SD($APP.Fb(null),b,lE,c)||!$APP.eb(iE(b)));return g?null:d.B?d.B(a,b,c):d.call(null,a,b,c)};jE.G=4;
var YY=function YY(a){switch(arguments.length){case 0:return YY.J();case 1:return YY.j(arguments[0]);case 2:return YY.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return YY.C(arguments[0],arguments[1],c)}};YY.J=function(){return $APP.jy};YY.j=function(a){return a};YY.A=function(a,b){return null==a||null==b?$APP.jy:WOa($APP.kz.A(BD(a)?a:$APP.wg([a]),BD(b)?b:$APP.wg([b])))};
YY.C=function(a,b,c){return $APP.Je.B(YY,YY.A(a,b),c)};YY.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};YY.G=2;
var ePa=new $APP.f(null,7,[$APP.dy,$APP.Jx,$APP.Gy,GVb,$APP.$u,bPa,$APP.Sx,$APP.GMb,$APP.jx,XOa,$APP.zv,Sgb,$APP.oza,elb],null),zE=function(){var a=$APP.kh.j($APP.F),b=$APP.kh.j($APP.F),c=$APP.kh.j($APP.F),d=$APP.kh.j($APP.F),g=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));return new $APP.Ch($APP.Zg.A("cljs.analyzer","resolve*"),function(l,n,p){return tPa(p)},$APP.yj,g,a,b,c,d)}();
zE.F(null,$APP.sE,function(a,b,c){return new $APP.f(null,3,[$APP.Q,$APP.Zg.A($APP.m.j(c),$APP.Ag(b)),$APP.cy,uE,$APP.yl,c],null)});
zE.F(null,rPa,function(a,b,c,d){a=ND();a=$APP.Uc.A(LRb,$E.j(a))&&!1===cec.j(a);return $APP.k(a)?(a=vPa(b,d),new $APP.f(null,5,[$APP.yl,d,$APP.Q,$APP.Zg.A($APP.m.j(d),[gPa(c),".",$APP.Ag(b)].join("")),$APP.cy,uE,$APP.tj,$APP.z($APP.bx,new $APP.f(null,1,[$APP.Dv,a],null)),fMb,!0],null)):new $APP.f(null,4,[$APP.yl,d,$APP.Q,$APP.Zg.A($APP.m.j(d),[gPa(c),".",$APP.Ag(b)].join("")),$APP.cy,uE,fMb,!0],null)});
zE.F(null,qPa,function(a,b,c,d){return new $APP.f(null,3,[$APP.Q,$APP.Zg.A($APP.m.j(d),[hPa(c),".",$APP.Ag(b)].join("")),$APP.yl,d,$APP.cy,$APP.Gk],null)});zE.F(null,sPa,function(a,b,c,d){a=vPa(b,d);return new $APP.f(null,5,[$APP.yl,d,$APP.Q,$APP.Zg.A($APP.m.j(d),[iPa(c),".",$APP.Ag(b)].join("")),$APP.cy,uE,$APP.tj,$APP.z($APP.bx,new $APP.f(null,1,[$APP.Dv,a],null)),fMb,!0],null)});var zec=new $APP.ug(null,new $APP.f(null,4,[Tab,"null",D3b,"null",Meb,"null",VWb,"null"],null),null);
zE.F(null,$APP.yj,function(a,b,c,d){var g=SD($APP.Fb(null),c,lE,$APP.Zg.j($APP.Ag(b)));b=$APP.Zg.A($APP.m.j(c),$APP.Ag(b));if(d=$APP.qg.A(d,c))d=$APP.No.j(g),d=$APP.k(d)?$APP.eb(EE)&&!$APP.Bd(zec,b):d;$APP.k(d)&&$D(S6b,a,new $APP.f(null,1,[$APP.mx,b],null));return $APP.Ni.C($APP.y([g,new $APP.f(null,3,[$APP.Q,b,$APP.cy,$APP.Gk,$APP.yl,c],null)]))});
var RPa=new $APP.ug(null,new $APP.f(null,22,[$APP.Lh,"null",$APP.Mh,"null",$APP.sda,"null",$APP.Nh,"null",$APP.tda,"null",$APP.Ph,"null",$APP.Qh,"null",$APP.uda,"null",$APP.Rh,"null",$APP.Sh,"null",$APP.Th,"null",$APP.vda,"null",$APP.Vh,"null",$APP.Wh,"null",$APP.Xh,"null",$APP.Yh,"null",$APP.Zh,"null",$APP.$h,"null",$APP.ai,"null",$APP.K,"null",$APP.ci,"null",$APP.di,"null"],null),null),NE=null,QE=$APP.Ec,ZY=!1,$Y=!0,HE=function HE(a,b){var d=$APP.tj.j($APP.ed($APP.Qw.j(b)));null==d&&(d=$APP.tj.j(b),
d=null==d?$APP.tj.j($APP.Yu.j(b)):d);if(null==d)switch(d=$APP.cy.j(b),d instanceof $APP.E?d.ga:null){case "recur":return HPa;case "throw":return HPa;case "let":return b=$APP.gm.j(b),HE.A?HE.A(a,b):HE.call(null,a,b);case "loop":return b=$APP.gm.j(b),HE.A?HE.A(a,b):HE.call(null,a,b);case "do":return b=KD.j(b),HE.A?HE.A(a,b):HE.call(null,a,b);case "fn-method":return b=$APP.gm.j(b),HE.A?HE.A(a,b):HE.call(null,a,b);case "def":return b=JD.j(b),HE.A?HE.A(a,b):HE.call(null,a,b);case "invoke":return d=$APP.qe(b),
b=$APP.C.A(d,$APP.Hk),d=$APP.C.A(d,$APP.Xj),d=$APP.rg.B(CPa(b,d),$APP.cy,iQa),a=HE.A?HE.A(a,d):HE.call(null,a,d),null==a&&(a=$APP.qe(b),b=$APP.C.A(a,$APP.Yu),a=$APP.k(RE.j(b))?yE.j(b):$APP.k(zPa.j(b))?yE.j(b):$APP.Uc.A(uE,$APP.cy.j($APP.Yu.j(a)))?$APP.bx:$APP.Uc.A($APP.bx,$APP.yl.j(b))?$APP.bx:null,a=null==a?$APP.jy:a),a;case "if":return LPa(a,b);case "const":return a=$APP.Qw.j(b),$APP.Uc.A(!0,a)?$APP.zv:$APP.Uc.A(!1,a)?$APP.zv:$APP.jy;case "quote":return b=$APP.Ck.j(b),HE.A?HE.A(a,b):HE.call(null,
a,b);case "var":case "local":case "js-var":case "binding":return d=JD.j(b),null==d?(b=$APP.Yu.j(b),HE.A?HE.A(a,b):HE.call(null,a,b)):HE.A?HE.A(a,d):HE.call(null,a,d);case "host-field":case "host-call":return $APP.jy;case "js":return $APP.jy;default:return null}else return d},rF=function(){var a=$APP.kh.j($APP.F),b=$APP.kh.j($APP.F),c=$APP.kh.j($APP.F),d=$APP.kh.j($APP.F),g=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));return new $APP.Ch($APP.Zg.A("cljs.analyzer","parse"),function(){function l(n,
p){if(1<arguments.length)for(var v=0,t=Array(arguments.length-1);v<t.length;)t[v]=arguments[v+1],++v;return n}l.G=1;l.M=function(n){var p=$APP.u(n);$APP.Fc(n);return p};l.C=function(n){return n};return l}(),$APP.yj,g,a,b,c,d)}();
rF.F(null,$APP.ai,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);if($APP.qg.A(2,$APP.Tc(c)))throw gE(b,"Wrong number of args to var");if(!(a instanceof $APP.q))throw gE(b,"Argument to var must be symbol");return $APP.Ni.C($APP.y([new $APP.f(null,4,[$APP.Xl,b,$APP.cy,xRb,HD,new $APP.H(null,3,5,$APP.I,[$APP.Gk,$APP.mx,$APP.h],null),$APP.Qw,c],null),OPa(b,a)]))});
var PPa=$APP.fg([nFb,uSb,udc,lMb,w$b,jCb,N9b,$APP.ysa,MNb,p8b,Ubc,udb,bac,PUb,Sfb,Qdb,uyb,xub,inb,$APP.Bua,$APP.mva,Rkb,IYb,vzb,i2b,$APP.lv,$APP.vCa,JBb,lUb,Rmb,Hcc,Xnb,Txb,UBb,O9b,Zqb,Epb,$APP.fya],[$APP.Sx,$APP.zv,$APP.Gy,wY,iF,lF,lF,rHb,uEb,$APP.$u,$APP.Gy,new $APP.ug(null,new $APP.f(null,2,[iF,"null",lF,"null"],null),null),iF,fvb,$APP.$u,$APP.zv,$APP.$u,t4b,$APP.$u,$APP.$u,pE,ONb,pLb,lac,k_b,pE,$APP.$u,$APP.zv,bSa,new $APP.ug(null,new $APP.f(null,2,[iF,"null",lF,"null"],null),null),iF,new $APP.ug(null,
new $APP.f(null,3,[tS,"null",$APP.Sx,"null",$APP.Gy,"null"],null),null),lF,$APP.$x,$APP.dsa,g0b,new $APP.ug(null,new $APP.f(null,2,[iF,"null",lF,"null"],null),null),crb]);
rF.F(null,$APP.Rh,function(a,b,c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(c,2,null),l=$APP.x.B(c,3,null);if(3>$APP.Tc(c))throw $APP.Zi.B(null,cE(b,ggb,$APP.Rh),Error("Too few arguments to if"));if(4<$APP.Tc(c))throw $APP.Zi.B(null,cE(b,ggb,$APP.Rh),Error("Too many arguments to if"));a=function(){var v=NE;NE=$APP.Yd(null,NE);try{var t=$APP.rg.B(b,KE,$APP.Ck);return IE?IE(t,d):JE.call(null,t,d)}finally{NE=v}}();var n=function(){var v=ZY;ZY=!0;try{var t=WPa(b,d);return IE?IE(t,g):JE.call(null,
t,g)}finally{ZY=v}}(),p=function(){var v=ZY;ZY=!0;try{return IE?IE(b,l):JE.call(null,b,l)}finally{ZY=v}}();return new $APP.f(null,8,[$APP.Xl,b,$APP.cy,dOa,$APP.Qw,c,$APP.Pr,a,GE,n,$APP.vr,p,ULb,!1,HD,new $APP.H(null,3,5,$APP.I,[$APP.Pr,GE,$APP.vr],null)],null)});
rF.F(null,$APP.Mh,function(a,b,c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(c,2,null),l=$APP.x.B(c,3,null),n=$APP.x.B(c,4,null),p=$APP.rg.B(b,KE,$APP.Ck);a=function(){var v=NE;NE=$APP.Yd(null,NE);try{return IE?IE(p,d):JE.call(null,p,d)}finally{NE=v}}();g=$APP.Hl.A(function(v){return $APP.Hl.A(function(t){return IE?IE(p,t):JE.call(null,p,t)},v)},g);l=$APP.Hl.A(function(v){return IE?IE(b,v):JE.call(null,b,v)},l);l=$APP.Hl.B(function(v,t){return new $APP.f(null,5,[$APP.cy,eIb,$APP.Xl,b,
lFb,$APP.Hl.A(function(A){return new $APP.f(null,5,[$APP.cy,XOb,$APP.Qw,$APP.Qw.j(A),$APP.Xl,p,$APP.Pr,A,HD,new $APP.H(null,1,5,$APP.I,[$APP.Pr],null)],null)},v),GE,new $APP.f(null,5,[$APP.cy,wdc,$APP.Qw,$APP.Qw.j(t),$APP.Xl,b,GE,t,HD,new $APP.H(null,1,5,$APP.I,[GE],null)],null),HD,new $APP.H(null,2,5,$APP.I,[lFb,GE],null)],null)},g,l);n=IE?IE(b,n):JE.call(null,b,n);return new $APP.f(null,7,[$APP.Xl,b,$APP.cy,I2b,$APP.Qw,c,$APP.Pr,a,Nhb,l,$APP.yj,n,HD,new $APP.H(null,3,5,$APP.I,[$APP.Pr,Nhb,$APP.yj],
null)],null)});
rF.F(null,$APP.ci,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);if($APP.Uc.A(1,$APP.Tc(c)))throw gE(b,"Too few arguments to throw, throw expects a single Error instance");if(2<$APP.Tc(c))throw gE(b,"Too many arguments to throw, throw expects a single Error instance");a:{var d=NE;NE=$APP.Yd(null,NE);try{var g=$APP.rg.B(b,KE,$APP.Ck);var l=IE?IE(g,a):JE.call(null,g,a);break a}finally{NE=d}l=void 0}return new $APP.f(null,5,[$APP.Xl,b,$APP.cy,n2b,$APP.Qw,c,$APP.Ix,l,HD,new $APP.H(null,1,5,$APP.I,
[$APP.Ix],null)],null)});
rF.F(null,$APP.Nh,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a),g=$APP.Li.B(b,new $APP.H(null,1,5,$APP.I,[KE],null),function(Z){return $APP.Uc.A($APP.Ck,Z)?OE:Z}),l=$APP.xt.A($APP.td,function(Z){return $APP.Uc.A($APP.u(Z),$APP.bi)}),n=$APP.xt.A(l,function(Z){return $APP.Uc.A($APP.Xc(Z),$APP.yj)}),p=$APP.xt.A($APP.td,function(Z){return $APP.Uc.A($APP.u(Z),$APP.Oh)});a=function(){for(var Z=new $APP.f(null,6,[$APP.MU,$APP.pq,EP,d,$APP.gm,$APP.sf,k5b,$APP.sf,X8b,null,G8b,null],null);;)if($APP.td(EP.j(Z))){var fa=
EP.j(Z),ia=$APP.r(fa);fa=$APP.u(ia);ia=$APP.w(ia);ia=$APP.rg.B(Z,EP,ia);var ja=$APP.MU.j(Z);ja=ja instanceof $APP.E?ja.ga:null;switch(ja){case "start":Z=$APP.k(l(fa))?$APP.rg.B(Z,$APP.MU,B4b):$APP.k(p(fa))?$APP.rg.B(Z,$APP.MU,$APP.Wx):$APP.Li.K(ia,new $APP.H(null,1,5,$APP.I,[$APP.gm],null),$APP.Vd,fa);continue;case "catches":if($APP.k(n(fa))){Z=$APP.rg.C(ia,X8b,fa,$APP.y([$APP.MU,$APP.Wx]));continue}else if($APP.k(l(fa))){Z=$APP.Li.K(ia,new $APP.H(null,1,5,$APP.I,[k5b],null),$APP.Vd,fa);continue}else if($APP.k(p(fa))){Z=
$APP.rg.B(Z,$APP.MU,$APP.Wx);continue}else throw gE(b,"Invalid try form");case "finally":Z=$APP.rg.C(ia,G8b,fa,$APP.y([$APP.MU,ymb]));continue;case "done":throw gE(b,"Unexpected form after finally");default:throw Error(["No matching clause: ",$APP.m.j(ja)].join(""));}}else return Z}();a=$APP.qe(a);var v=$APP.C.A(a,$APP.gm),t=$APP.C.A(a,k5b),A=$APP.C.A(a,X8b),B=$APP.C.A(a,G8b),G=$APP.r(B)?$APP.rg.B(function(){var Z=NE;NE=$APP.Yd(null,NE);try{var fa=$APP.rg.B(b,KE,qQa),ia=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
$APP.Qh,null,1,null),$APP.Fc(B))));return IE?IE(fa,ia):JE.call(null,fa,ia)}finally{NE=Z}}(),PE,!0):null,J=$APP.k(function(){var Z=$APP.r(t);return Z?Z:A}())?$APP.Oj.j("e"):null;a=function(){if($APP.k(A)){var Z=$APP.r(A);$APP.u(Z);Z=$APP.w(Z);$APP.u(Z);var fa=$APP.w(Z);Z=$APP.u(fa);fa=$APP.w(fa);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,Z,null,1,null),new $APP.D(null,J,null,1,null))))),null,1,null),$APP.y([fa]))))}return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,
$APP.ci,null,1,null),new $APP.D(null,J,null,1,null))))}();var O=$APP.r(t)?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.NDa,null,1,null),$APP.bf.C(function(Z){Z=$APP.r(Z);$APP.u(Z);var fa=$APP.w(Z);Z=$APP.u(fa);var ia=$APP.w(fa);fa=$APP.u(ia);ia=$APP.w(ia);return $APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,TPa,null,1,null),new $APP.D(null,Z,null,1,null),$APP.y([new $APP.D(null,J,null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.hm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,fa,null,1,null),new $APP.D(null,J,null,1,null))))),null,1,null),$APP.y([ia])))),null,1,null)))))},$APP.y([t])),$APP.y([new $APP.D(null,$APP.vr,null,1,null),new $APP.D(null,a,null,1,null)])))):a;a=LD.j(g);var R=$APP.k(J)?$APP.rg.B(a,J,new $APP.f(null,3,[$APP.Q,J,$APP.Xi,VD(J,b),$APP.Aj,WD(J,b)],null)):a;a=$APP.k(O)?function(){var Z=NE;NE=$APP.Yd(null,NE);try{var fa=$APP.rg.B(g,LD,R);return IE?IE(fa,O):JE.call(null,
fa,O)}finally{NE=Z}}():null;var W=function(){var Z=NE;NE=$APP.Yd(null,NE);try{var fa=$APP.k($APP.k(J)?J:G)?g:b,ia=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Qh,null,1,null),v)));return IE?IE(fa,ia):JE.call(null,fa,ia)}finally{NE=Z}}();return new $APP.f(null,8,[$APP.Xl,b,$APP.cy,$APP.Mia,$APP.Qw,c,$APP.gm,$APP.rg.B(W,PE,!0),$APP.Wx,G,$APP.Q,J,G9b,a,HD,$APP.tf($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.gm],null),$APP.k(a)?new $APP.H(null,1,5,$APP.I,[G9b],null):null,$APP.y([$APP.k(G)?new $APP.H(null,
1,5,$APP.I,[$APP.Wx],null):null])))],null)});var Aec=function Aec(a){a=$APP.qe(a);var c=$APP.C.A(a,$APP.cy),d=function(){var g=new $APP.ug(null,new $APP.f(null,2,[$APP.Nw,null,$APP.Ok,null],null),null);return g.j?g.j(c):g.call(null,c)}();if($APP.k(d))return d;d=function(){var g=new $APP.ug(null,new $APP.f(null,3,[$APP.nj,null,$APP.uj,null,$APP.oj,null],null),null);return g.j?g.j(c):g.call(null,c)}();return $APP.k(d)?$APP.Ge(Aec,ZPa(a)):d};
rF.F(null,$APP.di,function(a,b,c){if(4<$APP.Tc(c))throw gE(b,"Too many arguments to def");var d=$APP.Je.A(function(){function ia(ca,V,da,Y){return new $APP.f(null,3,[$APP.mx,V,$APP.P,da,JD,Y],null)}function ja(ca,V,da){return new $APP.f(null,2,[$APP.mx,V,JD,da],null)}function ta(ca,V){return new $APP.f(null,1,[$APP.mx,V],null)}var ua=null;ua=function(ca,V,da,Y){switch(arguments.length){case 2:return ta.call(this,ca,V);case 3:return ja.call(this,ca,V,da);case 4:return ia.call(this,ca,V,da,Y)}throw Error("Invalid arity: "+
arguments.length);};ua.A=ta;ua.B=ja;ua.K=ia;return ua}(),c),g=$APP.mx.j(d);a=$APP.Nw.j($APP.ed(g));var l=$APP.ed(g),n=$APP.tj.j($APP.ed(g)),p=XPa($APP.Pm.j($APP.ed(g))),v=$APP.im.j($APP.ed(g)),t=$APP.Q.j($APP.yl.j(b));LD.j(b);var A=$APP.Zg.j([$APP.m.j(t),".",$APP.m.j(g)].join("")),B=$APP.ae(g);if($APP.k($APP.k(B)?!oD($APP.Zg.j(B),t):B))throw gE(b,["Can't def ns-qualified name in namespace ",B].join(""));var G=null!=B?$APP.Zg.j($APP.Ag(g)):g;null!=$APP.am.A($APP.Fb(null),new $APP.H(null,2,5,$APP.I,
[RD,A],null))&&$D(VE,b,new $APP.f(null,2,[$APP.yl,$APP.Zg.j([$APP.m.j(t),".",$APP.m.j(G)].join("")),$APP.Gk,$APP.Zg.A($APP.m.j(t),$APP.m.j(G))],null));if(null!=$APP.Nw.j(xE($APP.Oi.A(b,LD),G)))throw gE(b,"Can't redefine a constant");g=$APP.P.j(d);if(null!=g&&"string"!==typeof g)throw gE(b,"Too many arguments to def");$APP.eb(v)&&$Pa(G)&&!bQa(t)&&$D(Hac,b,new $APP.f(null,1,[$APP.Gk,$APP.m.j(G)],null));var J=$APP.am.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[RD,t,lE,G],null));null!=J&&($APP.k(function(){var ia=
$APP.eb(ZY);return ia?(ia=$APP.eb($APP.Ru.j(J)))?(ia=$APP.eb($APP.Ru.j(l)))?$APP.k(null)?$APP.C.A($APP.Fb(null),G):null:ia:ia:ia}())&&$D(Y1b,b,new $APP.f(null,2,[$APP.mx,G,$APP.Xi,$APP.Xi.j(J)],null)),$APP.k(function(){var ia=$APP.Ru.j(J);return $APP.k(ia)?(ia=$APP.U.j(J),$APP.k(ia)?$APP.qg.A($APP.U.j(J),$APP.U.j(l)):ia):ia}())&&$D(kEb,b,new $APP.f(null,4,[yX,t,$APP.mx,G,$APP.Ru,$APP.Xc($APP.U.j(J)),IBb,$APP.Xc($APP.U.j(l))],null)));var O=$APP.qg.A(t,$APP.An)&&UOa(b,G)||null!=$APP.am.A($APP.Fb(null),
new $APP.H(null,4,5,$APP.I,[RD,t,tE,G],null))?function(){var ia=APa($APP.Oi.A(b,LD),$APP.z(G,new $APP.f(null,1,[$APP.pw,!0],null))),ja=$APP.fn.A($APP.Vd,$APP.vg);VOa($APP.yl.j(ia),G)&&$D(h4b,b,new $APP.f(null,3,[$APP.mx,G,$APP.yl,$APP.yl.j(ia),yX,t],null));$APP.lh.C(null,$APP.Li,new $APP.H(null,3,5,$APP.I,[RD,t,mE],null),ja,$APP.y([G]));return $APP.Li.K(b,new $APP.H(null,2,5,$APP.I,[$APP.yl,mE],null),ja,G)}():b,R=$APP.Q.j(xE($APP.Oi.A(O,LD),G)),W=$APP.Bd(d,JD)?function(){$APP.lh.K(null,$APP.cm,new $APP.H(null,
4,5,$APP.I,[RD,t,lE,G],null),$APP.Ni.C($APP.y([new $APP.f(null,1,[$APP.Q,R],null),l,!0===v?new $APP.f(null,1,[$APP.im,!0],null):null,XD(R,O)])));var ia=NE;NE=$APP.Yd(null,NE);try{var ja=$Y;$Y=!1;try{var ta=$APP.rg.B(O,KE,$APP.Ck),ua=JD.j(d);return nSa?nSa(ta,ua,G):JE.call(null,ta,ua,G)}finally{$Y=ja}}finally{NE=ia}}():null;A=(g=null!=W&&$APP.Uc.A($APP.cy.j(W),$APP.Hk))?function(){var ia=yE.j(W);return $APP.k(ia)?ia:$APP.k(n)?n:wQb.j(W)}():$APP.k(n)?n:$APP.k(v)?$APP.jy:$APP.tj.j(W);B=function(){var ia=
L8b.j($APP.ed(G));return $APP.k(ia)?$APP.Uc.A(!0,ia)?R:ia:null}();var Z=function(){var ia=$APP.P.j(d);return $APP.k(ia)?ia:$APP.P.j($APP.ed(G))}(),fa=$APP.am.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[RD,t,lE,G],null));null!=fa&&$APP.eb($APP.Ru.j($APP.ed(G)))&&!0===RE.j(fa)&&!g&&$D(RE,O,new $APP.f(null,2,[yX,t,$APP.mx,G],null));if(null==$APP.am.A($APP.Fb(null),new $APP.H(null,4,5,$APP.I,[RD,t,lE,G],null))||$APP.eb($APP.Ru.j(l)))$APP.k(null)&&$APP.lh.B(null,$APP.Vd,G),$APP.lh.K(null,$APP.cm,new $APP.H(null,
4,5,$APP.I,[RD,t,lE,G],null),$APP.Ni.C($APP.y([new $APP.f(null,1,[$APP.Q,R],null),$APP.k($APP.Pr.j(l))?$APP.rg.B(l,$APP.Pr,!0):l,new $APP.f(null,1,[$APP.h,$APP.Li.B($APP.Oi.A(l,$APP.Pr),new $APP.H(null,1,5,$APP.I,[$APP.Wi],null),function(ia){return $APP.Uc.A($APP.Q.j($APP.yl.j(O)),$APP.An)?"cljs/core.cljs":ia})],null),$APP.k(Z)?new $APP.f(null,1,[$APP.P,Z],null):null,$APP.k(a)?function(){a:{var ia=tF;tF=$APP.Vd.A(tF,YPa());try{var ja=JD.j(d);var ta=IE?IE(O,ja):JE.call(null,O,ja);break a}finally{tF=
ia}ta=void 0}return $APP.k(Aec(ta))?new $APP.f(null,1,[HRa,ta],null):null}():null,!0===v?new $APP.f(null,1,[$APP.im,!0],null):null,XD(R,O),$APP.k(p)?new $APP.f(null,1,[$APP.Pm,p],null):null,function(){var ia=FE.j($APP.ed(G));return $APP.k(ia)?new $APP.f(null,3,[FE,ia,$APP.Yu,fS.j($APP.ed(ia)),Zjb,$APP.vg],null):null}(),g?function(){var ia=$APP.Vg.A(function(ja){return $APP.tf($APP.Vg.A($APP.Q,$APP.fm.j(ja)))},$APP.Om.j(W));return $APP.Ni.C($APP.y([new $APP.f(null,3,[RE,$APP.eb($APP.Dl.j(l)),ME,ME.j(W),
Oyb,Oyb.j(W)],null),function(){var ja=$APP.ky.j(l);return null==ja?new $APP.f(null,5,[$APP.tu,$APP.tu.j(W),$APP.qw,$APP.qw.j(W),$APP.wy,ia,$APP.U,$APP.U.j(l),$APP.Cx,$APP.Ej.j($APP.Vg.A($APP.ed,$APP.U.j(l)))],null):ja}()]))}():null,$APP.k(function(){var ia=$APP.Ru.j(l);return $APP.k(ia)?$APP.U.j(l):ia}())?new $APP.f(null,3,[$APP.Ru,!0,RE,!0,$APP.wy,$APP.Xc($APP.U.j(l))],null):null,g&&null!=A?new $APP.f(null,1,[yE,A],null):$APP.k(A)?new $APP.f(null,1,[$APP.tj,A],null):null])));return $APP.Ni.C($APP.y([new $APP.f(null,
8,[$APP.Xl,O,$APP.cy,$APP.Ir,$APP.Qw,c,$APP.yl,t,$APP.Q,R,$APP.Gk,$APP.rg.B(function(){var ia=$APP.rg.B($APP.rg.B($APP.Oi.A(O,LD),KE,$APP.Ck),GRa,!0);return IE?IE(ia,G):JE.call(null,ia,G)}(),$APP.cy,$APP.Gk),$APP.P,Z,gU,gU.j(l)],null),function(){var ia=bec.j(l);return $APP.k(ia)?new $APP.f(null,1,[bec,ia],null):null}(),!0===Nac.j(O)?new $APP.f(null,1,[g1b,OPa(O,G)],null):null,function(){var ia=$APP.Pr.j(l);if(null==ia)ia=null;else{var ja=$APP.rg.B(O,KE,$APP.Ck);ia=IE?IE(ja,ia):JE.call(null,ja,ia);
ia=new $APP.f(null,1,[$APP.Pr,ia],null)}return ia}(),null!=A?g?new $APP.f(null,1,[yE,A],null):new $APP.f(null,1,[$APP.tj,A],null):null,!0===v?new $APP.f(null,1,[$APP.im,!0],null):null,null!=B?new $APP.f(null,1,[L8b,B],null):null,null!=W?new $APP.f(null,2,[JD,W,HD,new $APP.H(null,2,5,$APP.I,[$APP.Gk,JD],null)],null):new $APP.f(null,1,[HD,new $APP.H(null,1,5,$APP.I,[$APP.Gk],null)],null)]))});
rF.F(null,$APP.Xh,function(a,b,c,d){a=$APP.r(c);$APP.u(a);var g=$APP.w(a);d=(a=$APP.u(g)instanceof $APP.q)?new $APP.H(null,2,5,$APP.I,[$APP.u(g),$APP.w(g)],null):new $APP.H(null,2,5,$APP.I,[d,$APP.r(g)],null);var l=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var n=$APP.od($APP.u(d))?new $APP.D(null,d,null,1,null):d;g=LD.j(b);d=oQa(b,g,l);var p=null!=l?$APP.Li.K(b,new $APP.H(null,1,5,$APP.I,[mQa],null),$APP.Vd,d):b,v=null!=g&&a?$APP.rg.B(g,l,d):g;b=$APP.ed(c);var t=X4b.j(b);g=wib.j(b);var A=PHb.j(b),B=
$APP.Ni.C($APP.y([$APP.Oi.A(1<$APP.Tc(n)?$APP.rg.B(p,KE,$APP.Ck):p,zQa),new $APP.f(null,2,[ME,g,Oyb,A],null)])),G=$APP.Vg.A(function(Z){var fa=$Y;$Y=!1;try{return kQa(B,v,Z,t,null==l)}finally{$Y=fa}},n);b=$APP.Xs.K($APP.Vg.j($APP.Un),$APP.Hj,0,G);var J=$APP.vd($APP.He($APP.tu,G)),O=a?$APP.Li.C(v,new $APP.H(null,1,5,$APP.I,[l],null),$APP.rg,RE,!0,$APP.tu,$APP.y([J,$APP.qw,b,$APP.wy,$APP.Vg.A($APP.fm,G)])):v,R=null!=l?function(){var Z=$Y;$Y=!1;try{return pQa(B,O,t,n)}finally{$Y=Z}}():$APP.tf(G);c=$APP.Yj.S(c,
$APP.Oi,wib,PHb,X4b);a=!0===J?"@param {...*} var_args":null;G=null!=d?new $APP.H(null,2,5,$APP.I,[$APP.Bl,$APP.Om],null):new $APP.H(null,1,5,$APP.I,[$APP.Om],null);var W=function(){var Z=$APP.Vg.A($APP.Pi.A(HE,p),$APP.Vg.A($APP.gm,R));return $APP.k($APP.Je.A($APP.Uc,Z))?$APP.u(Z):null}();c=$APP.Ni.C($APP.y([$APP.fg([HD,Oyb,$APP.Q,fOa,wQb,ME,$APP.cy,$APP.Xl,$APP.tu,$APP.Om,PAb,$APP.qw,$APP.Qw,$APP.tj,zQa,gU],[G,A,d,QE,W,g,$APP.Hk,p,J,R,NE,b,c,$APP.jx,zQa.j(p),new $APP.H(null,1,5,$APP.I,[a],null)]),
null!=d?new $APP.f(null,1,[$APP.Bl,d],null):null]));a=$APP.Lf.B($APP.sf,$APP.Jl.A($APP.df.j($APP.tu),$APP.We.j(1)),R);g=0<$APP.Tc(a)?$APP.Tc($APP.fm.j($APP.x.A(a,0))):0;A=$APP.Lf.B($APP.sf,$APP.Vg.j($APP.Jl.A($APP.Tc,$APP.fm)),R);1<$APP.Tc(a)&&$D(P$b,p,new $APP.f(null,1,[$APP.Q,d],null));0!==g&&g!==1+b&&$D(NSb,p,new $APP.f(null,1,[$APP.Q,d],null));$APP.qg.A($APP.Ot.j(A),A)&&$D(fGb,p,new $APP.f(null,1,[$APP.Q,d],null));return mF.j?mF.j(c):mF.call(null,c)});
rF.F(null,$APP.uda,function(a,b,c){a=$APP.r(c);$APP.u(a);a=$APP.w(a);var d=$APP.u(a),g=$APP.w(a);if(!$APP.od(d)||!$APP.Ie($APP.Tc(d)))throw gE(b,"bindings must be vector of even number of elements");var l=$APP.Lf.A($APP.F,$APP.Vg.A($APP.wi.A($APP.u,$APP.Xc),$APP.Ll.A(2,d)));a=$APP.ng(l);var n=KE.j(b);d=$APP.Id.B(function(v,t){var A=$APP.x.B(v,0,null),B=$APP.qe(A),G=$APP.C.A(B,LD);v=$APP.x.B(v,1,null);var J=$APP.tj.j($APP.ed(t)),O=function(){var R=aE;aE=$APP.Bg($APP.ng(aE),$APP.Vj.j(!1));try{var W=
l.j?l.j(t):l.call(null,t);return IE?IE(B,W):JE.call(null,B,W)}finally{aE=R}}();A=function(){var R=$APP.fg([$APP.Q,$APP.wy,$APP.cy,$APP.Aj,$APP.tu,$APP.Xi,$APP.qw,RE,LE,$APP.Bl],[t,$APP.Vg.A($APP.fm,$APP.Om.j(O)),eQa,WD(t,B),$APP.tu.j(O),VD(t,B),$APP.qw.j(O),!0,vE(t,G.j?G.j(t):G.call(null,t)),uib]);return $APP.k(J)?$APP.rg.B(R,yE,J):R}();return new $APP.H(null,2,5,$APP.I,[$APP.cm(B,new $APP.H(null,2,5,$APP.I,[LD,t],null),A),$APP.Vd.A(v,A)],null)},new $APP.H(null,2,5,$APP.I,[b,$APP.sf],null),a);a=$APP.x.B(d,
0,null);d=$APP.x.B(d,1,null);a=$APP.rg.B(a,KE,$APP.Ck);a=$APP.Id.B(function(v,t){var A=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);var B=$APP.qe(t);t=$APP.C.A(B,$APP.Q);var G=$APP.C.A(B,LE);A=$APP.cm(A,new $APP.H(null,2,5,$APP.I,[LD,t],null),G);G=l.j?l.j(t):l.call(null,t);G=IE?IE(A,G):JE.call(null,A,G);B=$APP.rg.C(B,JD,G,$APP.y([$APP.tu,$APP.tu.j(G),$APP.qw,$APP.qw.j(G),$APP.wy,$APP.Vg.A($APP.fm,$APP.Om.j(G)),HD,new $APP.H(null,1,5,$APP.I,[JD],null)]));return new $APP.H(null,2,5,$APP.I,[$APP.cm(A,new $APP.H(null,
2,5,$APP.I,[LD,t],null),B),$APP.Vd.A(v,B)],null)},new $APP.H(null,2,5,$APP.I,[a,$APP.sf],null),d);var p=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);d=$APP.rg.B(function(){var v=$APP.rg.B(p,KE,$APP.Uc.A($APP.Ck,n)?OE:n),t=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Qh,null,1,null),g)));return IE?IE(v,t):JE.call(null,v,t)}(),PE,!0);return new $APP.f(null,6,[$APP.Xl,b,$APP.cy,uib,$APP.Vl,a,$APP.gm,d,$APP.Qw,c,HD,new $APP.H(null,2,5,$APP.I,[$APP.Vl,$APP.gm],null)],null)});
rF.F(null,$APP.Qh,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a);a=sQa(b,d);if(1>=$APP.Tc(d))var g=function(){var p=$APP.u(d);return IE?IE(b,p):JE.call(null,b,p)}(),l=new $APP.H(null,2,5,$APP.I,[ID,KD],null);else{var n=$APP.Uc.A(qQa,KE.j(b))?$APP.rg.B(b,KE,qQa):$APP.rg.B(b,KE,OE);g=function(){var p=$APP.$c(d);return IE?IE(n,p):JE.call(null,n,p)}();l=new $APP.H(null,2,5,$APP.I,[ID,KD],null)}return new $APP.f(null,6,[$APP.cy,A3b,$APP.Xl,b,$APP.Qw,c,ID,a,KD,g,HD,l],null)});
rF.F(null,$APP.Vh,function(a,b,c){return AQa(b,c,!1)});rF.F(null,$APP.Ph,function(a,b,c){return AQa(b,c,!0)});
rF.F(null,$APP.Yh,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a);KE.j(b);var g=$APP.u(NE),l=function(){var v=ME.j(g);return $APP.k(v)?$APP.Uc.A($APP.Tc(d),$APP.Tc($APP.fm.j(g))-1):v}(),n=$APP.k(l)?$APP.Yd(null,d):d,p=function(){var v=NE;NE=$APP.Yd(null,NE);try{return $APP.tf($APP.Vg.A(function(t){var A=$APP.rg.B(b,KE,$APP.Ck);return IE?IE(A,t):JE.call(null,A,t)},n))}finally{NE=v}}();if(!$APP.k(g))throw gE(b,"Can't recur here");if(!$APP.Uc.A($APP.Tc(p),$APP.Tc($APP.fm.j(g))))throw gE(b,["recur argument count mismatch, expected: ",
$APP.m.j($APP.Tc($APP.fm.j(g)))," args, got: ",$APP.m.j($APP.Tc(p))].join(""));$APP.k(function(){var v=ME.j(g);return $APP.k(v)?$APP.eb(l):v}())&&$D(uNb,b,new $APP.f(null,1,[$APP.Qw,$APP.Qw.j($APP.u(p))],null));$APP.Ne(hQa.j(g),!0);$APP.lh.A($APP.Ay.j(g),function(v){return $APP.Hl.B(function(t,A){return $APP.Uc.A(yQa,$APP.Bl.j(A))?$APP.jy:YY.A(t,$APP.tj.j(A))},v,p)});return $APP.rg.C(new $APP.f(null,3,[$APP.Xl,b,$APP.cy,c6b,$APP.Qw,c],null),l_b,g,$APP.y([vvb,p,HD,new $APP.H(null,1,5,$APP.I,[vvb],
null)]))});rF.F(null,$APP.K,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);if($APP.qg.A(2,$APP.Tc(c)))throw gE(b,"Wrong number of args to quote");var d=$APP.rg.B(b,FRa,!0);d=IE?IE(d,a):JE.call(null,d,a);d=$APP.qe(d);d=$APP.C.A(d,$APP.tj);a=new $APP.f(null,6,[$APP.cy,$APP.Nw,$APP.Xl,b,rwb,!0,$APP.X,a,$APP.tj,d,$APP.Qw,a],null);return new $APP.f(null,6,[$APP.cy,$APP.Ok,$APP.Ck,a,$APP.Xl,b,$APP.Qw,c,$APP.tj,$APP.tj.j(a),HD,new $APP.H(null,1,5,$APP.I,[$APP.Ck],null)],null)});
var Bec=new $APP.f(null,6,[$APP.Nia,$APP.dy,$APP.kBa,$APP.Gy,$APP.nDa,$APP.Sx,$APP.cta,$APP.$u,$APP.Npa,$APP.jx,$APP.epa,$APP.zv],null);
rF.F(null,$APP.Sh,function(a,b,c){a=$APP.r(c);$APP.u(a);a=$APP.w(a);var d=$APP.u(a);a=$APP.w(a);var g=NE;NE=$APP.Yd(null,NE);try{var l=$APP.rg.B(b,KE,$APP.Ck),n=IE?IE(l,d):JE.call(null,l,d),p=$APP.k(function(){var G=$APP.cy.j(n),J=new $APP.ug(null,new $APP.f(null,3,[$APP.Gk,null,uE,null,$APP.Bl,null],null),null);return J.j?J.j(G):J.call(null,G)}())?APa(b,d):null,v=$APP.k(function(){var G=SQa.j(p);return $APP.k(G)?$APP.eb(aY.j($APP.ed(d))):G}())?$APP.Vj.A(3,IE?IE(l,null):JE.call(null,l,null)):null,
t=$APP.Lf.A($APP.tf($APP.Vg.A(function(G){return IE?IE(l,G):JE.call(null,l,G)},a)),v),A=RQa.j(p),B=$APP.Tc(a);$APP.eb(aY.j($APP.ed(d)))&&null!=A&&$APP.eb(function(){var G=$APP.Uc.A(A,B);if(G)return G;G=SQa.j(p);return $APP.k(G)?$APP.Uc.A(2+A,B):G}())&&$D(jF,b,new $APP.f(null,2,[kF,B,YOa,d],null));return new $APP.f(null,7,[$APP.Xl,b,$APP.cy,Hrb,$APP.Qw,c,$APP.Vm,n,$APP.Xj,t,HD,new $APP.H(null,2,5,$APP.I,[$APP.Vm,$APP.Xj],null),$APP.tj,function(){var G=$APP.tj.j($APP.Yu.j(n));if(oE(G)&&!$APP.Bd(Bec,
G))return $APP.bx;G=$APP.Q.j($APP.Yu.j(n));var J=Bec.j?Bec.j(G):Bec.call(null,G);return $APP.k(J)?J:G}()],null)}finally{NE=g}});
rF.F(null,$APP.Zh,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);var d=$APP.x.B(c,2,null),g=$APP.x.B(c,3,null);a=$APP.k(g)?new $APP.H(null,2,5,$APP.I,[$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.$h,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)])))),g],null):new $APP.H(null,2,5,$APP.I,[a,d],null);var l=$APP.x.B(a,0,null),n=$APP.x.B(a,1,null);a=NE;NE=$APP.Yd(null,NE);try{d=EE;EE=!0;try{var p=$APP.rg.B(b,KE,$APP.Ck),v=l instanceof $APP.q?function(){if(!$APP.Uc.A(l,
SEb)||!0!==n&&!1!==n)if(!$APP.Uc.A(l,cqb)||!0!==n&&!1!==n)!$APP.Uc.A(l,Njb)||!0!==n&&!1!==n||(aE=$APP.rg.B(aE,cF,n));if(null!=$APP.Nw.j(xE($APP.Oi.A(b,LD),l)))throw gE(b,"Can't set! a constant");var J=vE(l,function(){var O=LD.j(b);return l.j?l.j(O):l.call(null,O)}());if(!$APP.k(function(){var O=null==J;if(O)return O;O=WE.j(J);if($APP.k(O)){O=$APP.io.j(J);if($APP.k(O))return O;O=NQa.j(J);return $APP.k(O)?O:$APP.by.j(J)}return O}()))throw gE(b,"Can't set! local var or non-mutable field");return IRa.A?
IRa.A(p,l):IRa.call(null,p,l)}():$APP.td(l)?function(){if($APP.k(Leb.j($APP.ed(l))))a:{var J=aE;aE=$APP.rg.B(aE,cF,!1);try{var O=pF?pF(p,l,null):WRa.call(null,p,l,null);break a}finally{aE=J}O=void 0}else O=pF?pF(p,l,null):WRa.call(null,p,l,null);return $APP.k(WE.j(O))?O:null}():null,t=IE?IE(p,n):JE.call(null,p,n);if($APP.td(l)){var A=null==l?null:$APP.Xc(l),B=$APP.ed(A),G=function(){var J=$APP.Uc.A($APP.Hk,$APP.cy.j(t));return J?$APP.ky.j(B):J}();$APP.k(G)&&$APP.lh.C(null,$APP.Li,new $APP.H(null,
5,5,$APP.I,[RD,$APP.Q.j($APP.yl.j(b)),lE,A,$APP.Om],null),$APP.fn.A($APP.Vd,$APP.sf),$APP.y([$APP.Ni.C($APP.y([$APP.sg(G,new $APP.H(null,2,5,$APP.I,[$APP.Un,$APP.tu],null)),$APP.sg($APP.u($APP.Om.j(t)),new $APP.H(null,1,5,$APP.I,[$APP.tj],null))]))]))}if(!$APP.k(v))throw gE(b,"set! target must be a field or a symbol naming a var");return $APP.eb(Nac.j(b))&&null!=function(){var J=new $APP.ug(null,new $APP.f(null,3,[Njb,"null",cqb,"null",SEb,"null"],null),null);return J.j?J.j(l):J.call(null,l)}()?new $APP.f(null,
2,[$APP.Xl,b,$APP.cy,Jvb],null):new $APP.f(null,6,[$APP.Xl,b,$APP.cy,mAb,$APP.Qw,c,$E,v,$APP.X,t,HD,new $APP.H(null,2,5,$APP.I,[$E,$APP.X],null)],null)}finally{EE=d}}finally{NE=a}});
rF.F(null,$APP.Th,function(a,b,c,d,g){a=$APP.r(c);$APP.u(a);d=$APP.w(a);a=$APP.u(d);var l=$APP.w(d);if(!$APP.k($Y))throw gE(b,"Namespace declarations must appear at the top-level.");if(!(a instanceof $APP.q))throw gE(b,"Namespaces must be named by a symbol.");var n=$APP.k(hkb.j(g))?LQa(a):a;a=$APP.qi.A($APP.Ag(n),/\./);$APP.Uc.A(1,$APP.Tc(a))&&$D(b1b,b,new $APP.f(null,1,[$APP.Q,n],null));null!=$APP.He(xec,a)&&$D(slb,b,new $APP.f(null,1,[$APP.Q,n],null));KQa(b,n,a);a="string"===typeof $APP.u(l)?$APP.u(l):
null;d=$APP.P.j($APP.ed(n));l=null!=a?$APP.w(l):l;var p=$APP.md($APP.u(l))?$APP.u(l):null;l=JQa(null!=p?$APP.w(l):l);l=$Na(l);l=$APP.qe(l);var v=$APP.C.A(l,ED);l=$APP.C.A(l,DD);var t=$APP.Yj.B(n,$APP.Ni,p);n=CQa(b,v);p=$APP.qe(n);n=$APP.C.A(p,mE);p=$APP.C.A(p,AE);p=$APP.Id.B(function(ua,ca){var V=$APP.x.B(ca,0,null);ca=$APP.x.B(ca,1,null);return $APP.rg.B(ua,ca,$APP.Zg.A("cljs.core",$APP.m.j(V)))},$APP.F,p);var A=$APP.kh.j($APP.sf),B=$APP.kh.j(new $APP.f(null,2,[EQa,l,CE,l],null)),G=new $APP.f(null,
5,[$APP.Zj,$APP.Pi.C(TE,b,!1,A,$APP.y([B])),$APP.vn,$APP.Pi.C(TE,b,!0,A,$APP.y([B])),$APP.gn,$APP.Jl.A($APP.Pi.C(TE,b,!1,A,$APP.y([B])),$APP.Pi.A(DQa,b)),BE,$APP.Jl.A($APP.Pi.C(TE,b,!0,A,$APP.y([B])),$APP.Pi.A(DQa,b)),UE,$APP.Pi.B(FQa,b,A)],null),J=$APP.kh.j(new $APP.ug(null,new $APP.f(null,5,[BE,null,$APP.gn,null,$APP.Zj,null,$APP.vn,null,UE,null],null),null)),O=$APP.kh.j(new $APP.f(null,4,[$APP.gn,null,$APP.Zj,null,BE,null,$APP.vn,null],null)),R=$APP.kh.j($APP.F);v=$APP.Id.B(function(ua,ca){var V=
$APP.r(ca),da=$APP.u(V);V=$APP.w(V);if(!$APP.k(function(){var Y=new $APP.ug(null,new $APP.f(null,5,[BE,null,$APP.gn,null,$APP.Zj,null,$APP.vn,null,UE,null],null),null);return Y.j?Y.j(da):Y.call(null,da)}()))throw gE(b,["Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported. Got ",$APP.m.j(ca)," instead."].join(""));if(!$APP.k(function(){var Y=$APP.Fb(J);return Y.j?Y.j(da):Y.call(null,da)}()))throw gE(b,["Only one ",$APP.m.j(da)," form is allowed per namespace definition"].join(""));
$APP.lh.B(J,$APP.Am,da);$APP.Uc.A(UE,da)||(null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.nn,null],null),null),V)&&$APP.lh.K(O,$APP.rg,da,$APP.nn),null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.on,null],null),null),V)&&$APP.lh.K(O,$APP.rg,da,$APP.on));(ca=$APP.r($APP.df.A(function(Y){return $APP.nn.j($APP.ed(Y))},V)))&&$APP.lh.K(R,$APP.rg,da,$APP.Bg($APP.Vg.A($APP.u,ca),$APP.Vg.A(function(Y){return $APP.nn.j($APP.ed(Y))},ca)));return $APP.Je.K($APP.Qo,$APP.Ni,ua,$APP.Vg.A(G.j?G.j(da):
G.call(null,da),$APP.un.A(new $APP.ug(null,new $APP.f(null,2,[$APP.nn,null,$APP.on,null],null),null),V)))},$APP.F,$APP.un.A(function(ua){ua=$APP.x.B(ua,0,null);return $APP.Uc.A(ua,FD)},v));var W=$APP.qe(v);v=$APP.C.A(W,$APP.gn);B=$APP.C.A(W,$APP.Zj);var Z=$APP.C.A(W,$APP.dn),fa=$APP.C.A(W,BE),ia=$APP.C.A(W,$APP.vn),ja=$APP.C.A(W,DE);W=$APP.C.A(W,UE);ia=$APP.Vg.A(function(ua){if($APP.k(hkb.j(g))){var ca=$APP.Zg.j($APP.Og.B($APP.m.j(t),0,$APP.m.j(t).length-7));return $APP.Id.B(function(V,da){var Y=
$APP.x.B(da,0,null);da=$APP.x.B(da,1,null);return oD(da,ca)?V:$APP.rg.B(V,Y,da)},$APP.F,ua)}return ua},new $APP.H(null,2,5,$APP.I,[ia,fa],null));fa=$APP.x.B(ia,0,null);ia=$APP.x.B(ia,1,null);var ta=$APP.fg([DE,AE,BE,mE,$APP.Q,$APP.um,$APP.bk,tE,$APP.vn,$APP.P,DD],[ja,$APP.Ni.C($APP.y([Z,p])),ia,n,t,W,B,v,fa,$APP.k(a)?a:d,l]);$APP.lh.C(null,$APP.Li,new $APP.H(null,2,5,$APP.I,[RD,t],null),$APP.Ni,$APP.y([ta]));return $APP.Ni.C($APP.y([new $APP.f(null,6,[$APP.cy,$APP.yl,$APP.Xl,b,$APP.Qw,c,y5b,$APP.Lf.A($APP.sf,
$APP.Ot.j($APP.Fb(A))),$APP.nn,$APP.Fb(O),HHb,$APP.Fb(R)],null),function(){var ua=$APP.k(function(){var ca=$APP.Fb(O);return ca.j?ca.j($APP.gn):ca.call(null,$APP.gn)}())?$APP.Li.B(ta,new $APP.H(null,1,5,$APP.I,[tE],null),function(ca){var V=$APP.Fb(O);V=V.j?V.j($APP.gn):V.call(null,$APP.gn);return $APP.z(ca,$APP.pe([V,!0]))}):ta;return $APP.k(function(){var ca=$APP.Fb(O);return ca.j?ca.j($APP.Zj):ca.call(null,$APP.Zj)}())?$APP.Li.B(ua,new $APP.H(null,1,5,$APP.I,[$APP.bk],null),function(ca){var V=$APP.Fb(O);
V=V.j?V.j($APP.Zj):V.call(null,$APP.Zj);return $APP.z(ca,$APP.pe([V,!0]))}):ua}()]))});
rF.F(null,$APP.tda,function(a,b,c){$APP.x.B(c,0,null);a=$APP.x.B(c,1,null);var d=$APP.u($APP.un.A(function(fa){return $APP.td(fa)&&$APP.Uc.A($APP.K,$APP.u(fa))},$APP.un.A($APP.Zd,a)));if($APP.k(d))throw gE(b,["Arguments to ",$APP.Ag($APP.u(a))," must be quoted. Offending spec: ",$APP.m.j(d)].join(""));if(!$APP.k($Y))throw gE(b,["Calls to `",$APP.Ag($APP.u(a)),"` must appear at the top-level."].join(""));d=$APP.Uc.A(UE,$APP.u(a))?HQa(a):GQa(a);a=$APP.Q.j($APP.yl.j(b));d=JQa(new $APP.D(null,d,null,
1,null));d=$Na(d);d=$APP.qe(d);var g=$APP.C.A(d,ED);d=$APP.C.A(d,DD);var l=CQa(b,g),n=$APP.qe(l);l=$APP.C.A(n,mE);n=$APP.C.A(n,AE);n=$APP.Id.B(function(fa,ia){var ja=$APP.x.B(ia,0,null);ia=$APP.x.B(ia,1,null);return $APP.rg.B(fa,ia,$APP.Zg.A("cljs.core",$APP.m.j(ja)))},$APP.F,n);var p=$APP.kh.j($APP.sf),v=$APP.kh.j(new $APP.f(null,2,[EQa,d,CE,d],null)),t=new $APP.f(null,5,[$APP.Zj,$APP.Pi.C(TE,b,!1,p,$APP.y([v])),$APP.vn,$APP.Pi.C(TE,b,!0,p,$APP.y([v])),$APP.gn,$APP.Jl.A($APP.Pi.C(TE,b,!1,p,$APP.y([v])),
$APP.Pi.A(DQa,b)),BE,$APP.Jl.A($APP.Pi.C(TE,b,!0,p,$APP.y([v])),$APP.Pi.A(DQa,b)),UE,$APP.Pi.B(FQa,b,p)],null),A=$APP.kh.j(new $APP.f(null,4,[$APP.gn,null,$APP.Zj,null,BE,null,$APP.vn,null],null)),B=$APP.kh.j($APP.F);g=$APP.Id.B(function(fa,ia){var ja=$APP.r(ia);ia=$APP.u(ja);ja=$APP.w(ja);$APP.Uc.A(UE,ia)||(null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.nn,null],null),null),ja)&&$APP.lh.K(A,$APP.rg,ia,$APP.nn),null!=$APP.He(new $APP.ug(null,new $APP.f(null,1,[$APP.on,null],null),null),ja)&&
$APP.lh.K(A,$APP.rg,ia,$APP.on));var ta=$APP.r($APP.df.A(function(ua){return $APP.nn.j($APP.ed(ua))},ja));null!=ta&&$APP.lh.K(B,$APP.rg,ia,$APP.Bg($APP.Vg.A($APP.u,ta),$APP.Vg.A(function(ua){return $APP.nn.j($APP.ed(ua))},ta)));return $APP.Je.K($APP.Qo,$APP.Ni,fa,$APP.Vg.A(t.j?t.j(ia):t.call(null,ia),$APP.un.A(new $APP.ug(null,new $APP.f(null,2,[$APP.nn,null,$APP.on,null],null),null),ja)))},$APP.F,$APP.un.A(function(fa){fa=$APP.x.B(fa,0,null);return $APP.Uc.A(fa,FD)},g));var G=$APP.qe(g);g=$APP.C.A(G,
$APP.gn);v=$APP.C.A(G,$APP.Zj);var J=$APP.C.A(G,$APP.dn),O=$APP.C.A(G,BE),R=$APP.C.A(G,$APP.vn),W=$APP.C.A(G,DE);G=$APP.C.A(G,UE);var Z=$APP.fg([DE,AE,BE,mE,$APP.Q,$APP.um,$APP.bk,tE,$APP.vn,DD],[W,$APP.Ni.C($APP.y([J,n])),O,l,a,G,v,g,R,d]);$APP.lh.C(null,$APP.Li,new $APP.H(null,2,5,$APP.I,[RD,a],null),MQa,$APP.y([Z,b]));return $APP.Ni.C($APP.y([new $APP.f(null,6,[$APP.cy,szb,$APP.Xl,b,$APP.Qw,c,y5b,$APP.Lf.A($APP.sf,$APP.Ot.j($APP.Fb(p))),$APP.nn,$APP.Fb(A),HHb,$APP.Fb(B)],null),function(){var fa=
$APP.k(function(){var ia=$APP.Fb(A);return ia.j?ia.j($APP.gn):ia.call(null,$APP.gn)}())?$APP.Li.B(Z,new $APP.H(null,1,5,$APP.I,[tE],null),function(ia){var ja=$APP.Fb(A);ja=ja.j?ja.j($APP.gn):ja.call(null,$APP.gn);return $APP.z(ia,$APP.pe([ja,!0]))}):Z;return $APP.k(function(){var ia=$APP.Fb(A);return ia.j?ia.j($APP.Zj):ia.call(null,$APP.Zj)}())?$APP.Li.B(fa,new $APP.H(null,1,5,$APP.I,[$APP.bk],null),function(ia){var ja=$APP.Fb(A);ja=ja.j?ja.j($APP.Zj):ja.call(null,$APP.Zj);return $APP.z(ia,$APP.pe([ja,
!0]))}):fa}()]))});rF.F(null,$APP.vda,function(a,b,c){return WQa(KYb,b,c)});rF.F(null,$APP.sda,function(a,b,c){return WQa(OQa,b,c)});var aF=function(){var a=$APP.kh.j($APP.F),b=$APP.kh.j($APP.F),c=$APP.kh.j($APP.F),d=$APP.kh.j($APP.F),g=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));return new $APP.Ch($APP.Zg.A("cljs.analyzer","build-dot-form"),function(l){return aRa(l)},$APP.yj,g,a,b,c,d)}();
aF.F(null,new $APP.H(null,3,5,$APP.I,[ZE,YQa,$APP.Ec],null),function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);$APP.x.B(a,2,null);return new $APP.f(null,3,[bRa,LXb,$E,b,WE,$APP.z($APP.Zg.j($APP.Ag(c).substring(1)),$APP.ed(c))],null)});aF.F(null,new $APP.H(null,3,5,$APP.I,[ZE,YQa,$Qa],null),function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);throw Error(["Cannot provide arguments ",$APP.m.j(a)," on property access ",$APP.m.j(b)].join(""));});
aF.F(null,new $APP.H(null,3,5,$APP.I,[ZE,ZQa,ZE],null),function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return dRa(b,c,a)});aF.F(null,new $APP.H(null,3,5,$APP.I,[ZE,ZQa,$APP.Ec],null),function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return dRa(b,c,a)});aF.F(null,new $APP.H(null,3,5,$APP.I,[ZE,$Qa,$APP.Ec],null),function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);$APP.x.B(a,2,null);return dRa(b,$APP.u(c),$APP.Fc(c))});
aF.F(null,$APP.yj,function(a){throw Error(["Unknown dot form of ",$APP.m.j($APP.Mn.A($APP.$h,a))," with classification ",$APP.m.j(aRa(a))].join(""));});rF.F(null,$APP.$h,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a);a=$APP.u(d);d=$APP.w(d);var g=$APP.r(d);d=$APP.u(g);g=$APP.w(g);var l=NE;NE=$APP.Yd(null,NE);try{return jRa(b,a,d,g,c)}finally{NE=l}});
var aZ=function aZ(a,b){var d=b.indexOf("~{");if(-1===d)return new $APP.D(null,b,null,1,null);var g=b.indexOf("}",d),l=$APP.Q.j(APa(a,$APP.Zg.j($APP.Og.B(b,2+d,g))));return new $APP.de(null,function(){var n=$APP.Og.B(b,0,d);var p=$APP.Og.A(b,g+1);p=aZ.A?aZ.A(a,p):aZ.call(null,a,p);return $APP.Yd(n,$APP.Yd(l,p))},null,null)},gF=function gF(a){var c=a.indexOf("~{");if(-1===c)return new $APP.D(null,a,null,1,null);var d=a.indexOf("}",c);return new $APP.de(null,function(){var g=$APP.Og.B(a,0,c);var l=
$APP.Og.A(a,d+1);l=gF.j?gF.j(l):gF.call(null,l);return $APP.Yd(g,l)},null,null)},lRa=new $APP.ug(null,new $APP.f(null,4,[$APP.jy,"null",$APP.Av,"null",$APP.py,"null",$APP.$u,"null"],null),null),nRa=new $APP.ug(null,new $APP.f(null,10,[$APP.zv,"null",$APP.bAa,"null",$APP.Wza,"null",n0b,"null",$APP.Sx,"null",$APP.aqa,"null",$APP.Jva,"null",$APP.XAa,"null",$APP.lua,"null",$APP.uxa,"null"],null),null);
rF.F(null,$APP.Wh,function(a,b,c){a=$APP.r(c);$APP.u(a);var d=$APP.w(a);a=$APP.u(d);d=$APP.w(d);if("string"!==typeof a)throw gE(b,"Invalid js* form");if(null!=d){a:{var g=NE;NE=$APP.Yd(null,NE);try{var l=tRa(b,a,d,c);break a}finally{NE=g}l=void 0}return l}l=$APP.Je.A($APP.m,aZ(b,a));a=kRa(c);g=$APP.ed(c);d=fF.j(g);g=eF.j(g);return new $APP.f(null,7,[$APP.cy,$APP.sE,$APP.Xl,b,$APP.Qw,c,$APP.Ypa,l,$APP.tj,a,fF,d,eF,g],null)});
var nF=function nF(a){a=$APP.qe(a);var c=$APP.C.A(a,$APP.cy);switch(c instanceof $APP.E?c.ga:null){case "var":case "local":if(fPa($APP.Zg.j($APP.Ag($APP.Q.j(a))))){var d=$APP.Ag($APP.Q.j(a)),g=d.lastIndexOf(".");c=$APP.z($APP.Zg.A($APP.ae($APP.Q.j(a)),$APP.Og.B(d,0,g)),$APP.ed($APP.Qw.j(a)));d=$APP.Zg.j($APP.Og.A(d,g+1));g=$APP.Xl.j(a);var l=new $APP.D(null,$APP.$h,new $APP.D(null,c,new $APP.D(null,d,null,1,null),2,null),3,null);c=$APP.cm($APP.cm($APP.Oi.A($APP.rg.C(a,$APP.Q,c,$APP.y([$APP.Qw,c])),
$APP.tj),new $APP.H(null,2,5,$APP.I,[$APP.Yu,$APP.Q],null),c),new $APP.H(null,2,5,$APP.I,[$APP.Xl,KE],null),$APP.Ck);c=nF.j?nF.j(c):nF.call(null,c);return new $APP.f(null,7,[$APP.cy,hRa,$APP.Xl,g,$APP.Qw,l,$E,c,WE,d,$APP.tj,$APP.tj.j(a),HD,new $APP.H(null,1,5,$APP.I,[$E],null)],null)}return a;default:return a}},NRa=new $APP.bh(function(){return $APP.C.A(RNa(),Tub)},null),Cec=function(){var a=new $APP.f(null,2,[gjb,function(c){return oRa($APP.u(c))&&$APP.Ge(mRa,$APP.Fc(c))},Ihb,kbc],null),b=new $APP.f(null,
2,[gjb,function(c){return oRa($APP.u(c))&&$APP.Ge(mRa,$APP.zg($APP.Fc(c)))},Ihb,kbc],null);return new $APP.f(null,4,[Meb,a,VWb,b,D3b,a,Tab,b],null)}(),lSa=new $APP.H(null,3,5,$APP.I,[function Dec(a,b,c){b=$APP.qe(b);var g=$APP.C.A(b,$APP.tj);if(null==g||$APP.Uc.A($APP.jx,g)){if($APP.Uc.A($APP.Hk,$APP.cy.j(b)))return $APP.Gj.B(b,$APP.Om,function(l){return $APP.Lf.B($APP.sf,$APP.Vg.j(function(n){return Dec.B?Dec.B(a,n,c):Dec.call(null,a,n,c)}),l)});g=HE(a,b);return null==g?b:$APP.rg.B(b,$APP.tj,g)}return b},
function(a,b){if(a=eOa(b))a=KD.j($APP.gm.j(b)),a=$APP.Uc.A($APP.Oi.A($APP.Pr.j(a),$APP.Xl),$APP.Oi.A($APP.vr.j(a),$APP.Xl));if(a&&cOa(GE.j(KD.j($APP.gm.j(b))))){a=$APP.u($APP.Vl.j(b));var c=$APP.qe(a);a=$APP.C.A(c,JD);var d=$APP.C.A(c,$APP.Q);c=$APP.Xl.j(b);var g=new $APP.H(null,3,5,$APP.I,["((",") \x26\x26 (","))"],null),l=$APP.I,n=$APP.cm(GE.j(KD.j($APP.gm.j(b))),new $APP.H(null,2,5,$APP.I,[$APP.Xl,KE],null),$APP.Ck);d=GD(n,new $APP.H(null,1,5,$APP.I,[hOa(d)],null),null);b=new $APP.f(null,7,[$APP.cy,
$APP.sE,$APP.Xl,c,sRa,g,$APP.Xj,new $APP.H(null,2,5,l,[a,d],null),$APP.Qw,$APP.Qw.j(b),HD,new $APP.H(null,1,5,$APP.I,[$APP.Xj],null),$APP.tj,$APP.zv],null)}else{if(a=eOa(b))a=KD.j($APP.gm.j(b)),a=$APP.Uc.A($APP.Oi.A($APP.Pr.j(a),$APP.Xl),$APP.Oi.A(GE.j(a),$APP.Xl));a&&cOa($APP.vr.j(KD.j($APP.gm.j(b))))&&(a=$APP.u($APP.Vl.j(b)),c=$APP.qe(a),a=$APP.C.A(c,JD),d=$APP.C.A(c,$APP.Q),c=$APP.Xl.j(b),g=new $APP.H(null,3,5,$APP.I,["((",") || (","))"],null),l=$APP.I,n=$APP.cm($APP.vr.j(KD.j($APP.gm.j(b))),new $APP.H(null,
2,5,$APP.I,[$APP.Xl,KE],null),$APP.Ck),d=GD(n,new $APP.H(null,1,5,$APP.I,[hOa(d)],null),null),b=new $APP.f(null,7,[$APP.cy,$APP.sE,$APP.Xl,c,sRa,g,$APP.Xj,new $APP.H(null,2,5,l,[a,d],null),$APP.Qw,$APP.Qw.j(b),HD,new $APP.H(null,1,5,$APP.I,[$APP.Xj],null),$APP.tj,$APP.zv],null))}return b},function(a,b){b=$APP.qe(b);var c=$APP.C.A(b,$APP.cy);if(!vRa(b)&&$APP.$d(DRa,c)){var d=$APP.Dd(Cec,$APP.Q.j($APP.Yu.j($APP.Hk.j(b))));if(null!=d){c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var g=$APP.qe(d);d=$APP.C.A(g,
gjb);g=$APP.C.A(g,Ihb);var l=$APP.Hl.A($APP.tj,$APP.Xj.j(b));$APP.k(d.j?d.j(l):d.call(null,l))||$D(g,a,new $APP.f(null,2,[$APP.Q,c,qRa,l],null))}}return uRa(b)}],null);$APP.FEa={};var bZ=function bZ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return bZ.C(arguments[0],arguments[1],c)};
bZ.C=function(a,b,c){c=$APP.qe(c);a=$APP.C.A(c,$APP.Uu);c=$APP.C.A(c,IG);b=$APP.rg.B(b,BX,!0);return $APP.Bd(b,$APP.Era)?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Rh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.yl,null,1,null),new $APP.D(null,$APP.Era,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,a,null,1,null),new $APP.D(null,c,null,1,null)])))):a};bZ.G=2;bZ.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};
var oSa=$APP.Vg.A($APP.Jl.B($APP.Zg,$APP.m,$APP.Md),$APP.Jj.A(97,123)),cZ=function cZ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=4<c.length?new $APP.Bc(c.slice(4),0,null):null;return cZ.C(arguments[0],arguments[1],arguments[2],arguments[3],c)};
cZ.C=function(a,b,c,d,g){$APP.rg.B(b,BX,!0);b=$APP.od(d)?d:new $APP.H(null,1,5,$APP.I,[d],null);a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);var l=$APP.k(b)?new $APP.H(null,3,5,$APP.I,[PX,a,b],null):new $APP.H(null,2,5,$APP.I,[hI,a],null);d="string"===typeof $APP.u(g)?["generic ",$APP.m.j(c),".\n\n",$APP.m.j($APP.u(g))].join(""):["generic ",$APP.m.j(c)].join("");g="string"===typeof $APP.u(g)?$APP.w(g):g;var n=$APP.md($APP.u(g))?new $APP.H(null,2,5,$APP.I,[$APP.u(g),$APP.w(g)],null):new $APP.H(null,2,
5,$APP.I,[$APP.F,g],null);g=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);var p=bZ.C(IG,$APP.E,$APP.y([$APP.Uu,iF]));l=$APP.rg.C(g,ZH,l,$APP.y([$APP.Q,$APP.Q.A(g,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,c,null,1,null)))))]));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Qh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.iCa,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null),new $APP.D(null,$APP.Je.A($APP.Kk,
$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.U,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,pSa(a,b),null,1,null)))),null,1,null))))),null,1,null),new $APP.D(null,Qnb,null,1,null),n])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Mm,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,p,null,1,null))))),null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,
Itb,null,1,null))))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,l,null,1,null),new $APP.D(null,Itb,null,1,null)))),null,1,null)])))),null,1,null)]))))};cZ.G=4;cZ.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);var g=$APP.w(d);d=$APP.u(g);g=$APP.w(g);return this.C(b,a,c,d,g)};var vF=BigInt(0),zF=BigInt(1),Eec=BigInt(10),xF=-zF;uF.prototype.valueOf=function(){return wF.j?wF.j(this):wF.call(null,this)};uF.prototype.toString=function(){return[$APP.m.j(this.n),"/",$APP.m.j(this.d)].join("")};uF.prototype.ka=function(){return $APP.Lb(this.n)^$APP.Lb(this.d)};uF.prototype.Tb=function(a,b){return b instanceof uF?wSa.A?wSa.A(this,b):wSa.call(null,this,b):$APP.Uc.A("bigint",$APP.la(b))?$APP.Ed(this.n,this.d*b):$APP.Oa(this,b.valueOf())};var xSa=new uF(zF,zF),Fec=/(-?\d+)(\.(\d+))?([Ee]([+-]\d+))?/;BSa._=!0;BF._=function(){return!1};var LP=function LP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return LP.C(c)};LP.C=function(a){return $APP.Hl.A(DF,a)};LP.G=0;LP.M=function(a){return this.C($APP.r(a))};var GSa=$APP.kh.j($APP.F);$APP.ju.A($APP.Xd,$R);$APP.ju.A($APP.Bc,$R);$APP.ju.A($APP.H,$R);$APP.ju.A($APP.de,$R);$APP.ju.A($APP.D,$R);$APP.ju.A($APP.Gg,$R);$APP.ju.A(IY,GG);$APP.ju.A(GG,FG);$APP.ju.A(ET,FG);
$APP.ju.A(FG,VM);$APP.ju.A(VM,HF);$APP.ju.A(Number,FG);$APP.ju.A(BigInt,GG);$APP.ju.A($APP.za,GG);$APP.ju.A($APP.qa,GG);BSa.number=!0;BF.number=function(){return!0};CF.number=!0;DF.number=function(a){var b=Number.isInteger(a);return $APP.k($APP.k(b)?Math.abs(a)<Number.MAX_SAFE_INTEGER:b)?IY:ET};CF["boolean"]=!0;DF["boolean"]=function(a){return $APP.hb(a)};CF["null"]=!0;DF["null"]=function(){return null};CF._=!0;DF._=function(a){return $APP.Ui.A(a,$APP.hb(a))};
var hG,Gec=$APP.kh.j($APP.F),Hec=$APP.kh.j($APP.F),Iec=$APP.kh.j($APP.F),Jec=$APP.kh.j($APP.F),Kec=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));hG=new $APP.Ch($APP.Zg.A("emmy.value","\x3d"),LP,$APP.yj,Kec,Gec,Hec,Iec,Jec);hG.F(null,new $APP.H(null,2,5,$APP.I,[VM,VM],null),function(a,b){return a===b});hG.F(null,new $APP.H(null,2,5,$APP.I,[$R,$R],null),function(a,b){var c=hG.A($APP.Tc(a),$APP.Tc(b));return $APP.k(c)?$APP.Ge($APP.rd,$APP.Vg.B(hG,a,b)):c});
hG.F(null,$APP.yj,function(a,b){return $APP.vh(DF(a),VM)||$APP.vh(DF(b),VM)?!1:$APP.Uc.A(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[IY,BigInt],null),function(a,b){return a==b});hG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,IY],null),function(a,b){return a==b});
for(var dZ=$APP.r(new $APP.H(null,5,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.qa,$APP.za,TNa],null),new $APP.H(null,3,5,$APP.I,[IY,$APP.za,TNa],null),new $APP.H(null,3,5,$APP.I,[IY,$APP.qa,UNa],null),new $APP.H(null,3,5,$APP.I,[$APP.qa,BigInt,uD],null),new $APP.H(null,3,5,$APP.I,[$APP.za,BigInt,uD],null)],null)),eZ=null,fZ=0,gZ=0;;)if(gZ<fZ){var hZ=eZ.aa(null,gZ),Lec=$APP.x.B(hZ,0,null),Mec=$APP.x.B(hZ,1,null),Nec=$APP.x.B(hZ,2,null);hG.F(null,new $APP.H(null,2,5,$APP.I,[Lec,Mec],null),function(a,
b,c,d,g,l,n,p){return function(v,t){return $APP.Uc.A(p.j?p.j(v):p.call(null,v),t)}}(dZ,eZ,fZ,gZ,hZ,Lec,Mec,Nec));hG.F(null,new $APP.H(null,2,5,$APP.I,[Mec,Lec],null),function(a,b,c,d,g,l,n,p){return function(v,t){return $APP.Uc.A(v,p.j?p.j(t):p.call(null,t))}}(dZ,eZ,fZ,gZ,hZ,Lec,Mec,Nec));gZ+=1}else{var Oec=$APP.r(dZ);if(Oec){var iZ=Oec;if($APP.pd(iZ)){var Pec=$APP.lc(iZ),Qec=$APP.mc(iZ),Rec=Pec,Sec=$APP.Tc(Pec);dZ=Qec;eZ=Rec;fZ=Sec}else{var jZ=$APP.u(iZ),Tec=$APP.x.B(jZ,0,null),Uec=$APP.x.B(jZ,1,
null),Vec=$APP.x.B(jZ,2,null);hG.F(null,new $APP.H(null,2,5,$APP.I,[Tec,Uec],null),function(a,b,c,d,g,l,n,p){return function(v,t){return $APP.Uc.A(p.j?p.j(v):p.call(null,v),t)}}(dZ,eZ,fZ,gZ,jZ,Tec,Uec,Vec,iZ,Oec));hG.F(null,new $APP.H(null,2,5,$APP.I,[Uec,Tec],null),function(a,b,c,d,g,l,n,p){return function(v,t){return $APP.Uc.A(v,p.j?p.j(t):p.call(null,t))}}(dZ,eZ,fZ,gZ,jZ,Tec,Uec,Vec,iZ,Oec));dZ=$APP.w(iZ);eZ=null;fZ=0}gZ=0}else break}
hG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.equals(b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.equals(b)});$APP.Kb.number=function(a,b){return"number"===typeof b?a===b:IF(b)?hG.A(a,b.valueOf()):!1};$APP.za.prototype.Y=function(a,b){return $APP.Uc.A($APP.za,$APP.hb(b))?this.equals(b):hG.A(this,b.valueOf())};$APP.qa.prototype.Y=function(a,b){return $APP.Uc.A($APP.qa,$APP.hb(b))?this.equals(b):hG.A(this,b.valueOf())};
$APP.e=BigInt.prototype;$APP.e.ke=$APP.xc;$APP.e.ka=function(){return $APP.yc(this.toString(16))};$APP.e.Y=function(a,b){a=b.valueOf();return SNa(a)?this==a:hG.A(this,a)};$APP.e.Oa=$APP.xc;$APP.e.ea=function(a,b){a=(0>this?-this:this)<Number.MAX_SAFE_INTEGER?$APP.m.j(this):['"',$APP.m.j(this),'"'].join("");return $APP.Sg(b,$APP.y(["#emmy/bigint ",a]))};$APP.qa.prototype.ke=$APP.xc;$APP.qa.prototype.ka=function(){return this.hb()};$APP.qa.prototype.valueOf=function(){return this.toNumber()};
$APP.za.prototype.ke=$APP.xc;$APP.za.prototype.ka=function(){return $APP.yc(this.toString(16))};$APP.za.prototype.valueOf=function(){return this.toNumber()};$APP.ic.number=!0;$APP.jc.number=function(a,b){var c=b.valueOf();if(FF(c))return $APP.Oa(a,c);throw Error(["Cannot compare ",$APP.m.j(a)," to ",$APP.m.j(b)].join(""));};BigInt.prototype.qc=$APP.xc;
BigInt.prototype.Tb=function(a,b){a=b.valueOf();if(FF(a))return $APP.Oa(this,a);throw Error(["Cannot compare ",$APP.m.j(this)," to ",$APP.m.j(b)].join(""));};$APP.za.prototype.qc=$APP.xc;$APP.za.prototype.Tb=function(a,b){a=b.valueOf();if(a instanceof $APP.za)return this.compare(a);if(FF(a))return $APP.Oa(this,a);throw Error(["Cannot compare ",$APP.m.j(this)," to ",$APP.m.j(b)].join(""));};$APP.qa.prototype.qc=$APP.xc;
$APP.qa.prototype.Tb=function(a,b){a=b.valueOf();if(a instanceof $APP.qa)return this.compare(a);if(FF(a))return $APP.Oa(this,a);throw Error(["Cannot compare ",$APP.m.j(this)," to ",$APP.m.j(b)].join(""));};BigInt.prototype.nd=function(){return!0};$APP.za.prototype.nd=function(){return!0};$APP.qa.prototype.nd=function(){return!0};BigInt.prototype.rb=function(){return BigInt};$APP.za.prototype.rb=function(){return $APP.za};$APP.qa.prototype.rb=function(){return $APP.qa};var DSa=Symbol.for("Symbol.__emmy_meta__");
$APP.Gb["function"]=!0;$APP.Hb["function"]=function(a){a=$APP.Na(a,DSa);return $APP.k(a)?a:null};var LF=2*Math.PI;var MF,Wec=$APP.kh.j($APP.F),Xec=$APP.kh.j($APP.F),Yec=$APP.kh.j($APP.F),Zec=$APP.kh.j($APP.F),$ec=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));MF=new $APP.Ch($APP.Zg.A("emmy.generic","zero?"),LP,$APP.yj,$ec,Wec,Xec,Yec,Zec);MF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,$APP.Cv],null);return b.j?b.j(a):b.call(null,a)});
var uG,afc=$APP.kh.j($APP.F),bfc=$APP.kh.j($APP.F),cfc=$APP.kh.j($APP.F),dfc=$APP.kh.j($APP.F),efc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));uG=new $APP.Ch($APP.Zg.A("emmy.generic","one?"),LP,$APP.yj,efc,afc,bfc,cfc,dfc);uG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,x$b],null);return b.j?b.j(a):b.call(null,a)});
var kZ,ffc=$APP.kh.j($APP.F),gfc=$APP.kh.j($APP.F),hfc=$APP.kh.j($APP.F),ifc=$APP.kh.j($APP.F),jfc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));kZ=new $APP.Ch($APP.Zg.A("emmy.generic","identity?"),LP,$APP.yj,jfc,ffc,gfc,hfc,ifc);kZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,lS],null);return b.j?b.j(a):b.call(null,a)});
var vG,kfc=$APP.kh.j($APP.F),lfc=$APP.kh.j($APP.F),mfc=$APP.kh.j($APP.F),nfc=$APP.kh.j($APP.F),ofc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));vG=new $APP.Ch($APP.Zg.A("emmy.generic","zero-like"),LP,$APP.yj,ofc,kfc,lfc,mfc,nfc);vG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,wcc],null);return b.j?b.j(a):b.call(null,a)});
var PF,pfc=$APP.kh.j($APP.F),qfc=$APP.kh.j($APP.F),rfc=$APP.kh.j($APP.F),sfc=$APP.kh.j($APP.F),tfc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));PF=new $APP.Ch($APP.Zg.A("emmy.generic","one-like"),LP,$APP.yj,tfc,pfc,qfc,rfc,sfc);PF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,Lpb],null);return b.j?b.j(a):b.call(null,a)});
var lZ,ufc=$APP.kh.j($APP.F),vfc=$APP.kh.j($APP.F),wfc=$APP.kh.j($APP.F),xfc=$APP.kh.j($APP.F),yfc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));lZ=new $APP.Ch($APP.Zg.A("emmy.generic","identity-like"),LP,$APP.yj,yfc,ufc,vfc,wfc,xfc);lZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,b$b],null);return b.j?b.j(a):b.call(null,a)});
var VF,zfc=$APP.kh.j($APP.F),Afc=$APP.kh.j($APP.F),Bfc=$APP.kh.j($APP.F),Cfc=$APP.kh.j($APP.F),Dfc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));VF=new $APP.Ch($APP.Zg.A("emmy.generic","exact?"),LP,$APP.yj,Dfc,zfc,Afc,Bfc,Cfc);VF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,avb],null);return b.j?b.j(a):b.call(null,a)});
var cG,Efc=$APP.kh.j($APP.F),Ffc=$APP.kh.j($APP.F),Gfc=$APP.kh.j($APP.F),Hfc=$APP.kh.j($APP.F),Ifc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));cG=new $APP.Ch($APP.Zg.A("emmy.generic","freeze"),LP,$APP.yj,Ifc,Efc,Ffc,Gfc,Hfc);cG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,K1b],null);return b.j?b.j(a):b.call(null,a)});cG.F(null,new $APP.H(null,1,5,$APP.I,[String],null),function(a){return a});
cG.F(null,new $APP.H(null,1,5,$APP.I,[null],null),function(){return null});var gH,Jfc=$APP.kh.j($APP.F),Kfc=$APP.kh.j($APP.F),Lfc=$APP.kh.j($APP.F),Mfc=$APP.kh.j($APP.F),Nfc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));gH=new $APP.Ch($APP.Zg.A("emmy.generic","add"),LP,$APP.yj,Nfc,Jfc,Kfc,Lfc,Mfc);
gH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[$APP.Q,$APP.Iv,eN,function(){return 1},fN,function(){return 1},ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null)],null);return b.j?b.j(a):b.call(null,a)});
var mG=function mG(a){switch(arguments.length){case 0:return mG.J();case 1:return mG.j(arguments[0]);case 2:return mG.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return mG.C(arguments[0],arguments[1],c)}};mG.J=function(){return 0};mG.j=function(a){return a};mG.A=function(a,b){return $APP.k(NF(a))?b:$APP.k(NF(b))?a:gH.A(a,b)};mG.C=function(a,b,c){return $APP.Id.B(mG,mG.A(a,b),c)};
mG.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};mG.G=2;var RF,Ofc=$APP.kh.j($APP.F),Pfc=$APP.kh.j($APP.F),Qfc=$APP.kh.j($APP.F),Rfc=$APP.kh.j($APP.F),Sfc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));RF=new $APP.Ch($APP.Zg.A("emmy.generic","negate"),LP,$APP.yj,Sfc,Ofc,Pfc,Qfc,Rfc);
RF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[$APP.Q,$APP.Jv,eN,function(){return-1},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null)],null);return b.j?b.j(a):b.call(null,a)});var AG,Tfc=$APP.kh.j($APP.F),Ufc=$APP.kh.j($APP.F),Vfc=$APP.kh.j($APP.F),Wfc=$APP.kh.j($APP.F),Xfc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));AG=new $APP.Ch($APP.Zg.A("emmy.generic","sub"),LP,$APP.yj,Xfc,Tfc,Ufc,Vfc,Wfc);
AG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[$APP.Q,$APP.Jv,eN,function(){return 1},fN,function(){return-1},ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null)],null);return b.j?b.j(a):b.call(null,a)});AG.F(null,$APP.yj,function(a,b){return gH.A(a,RF.j(b))});
var TF=function TF(a){switch(arguments.length){case 0:return TF.J();case 1:return TF.j(arguments[0]);case 2:return TF.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return TF.C(arguments[0],arguments[1],c)}};TF.J=function(){return 0};TF.j=function(a){return RF.j(a)};TF.A=function(a,b){return $APP.k(NF(b))?a:$APP.k(NF(a))?RF.j(b):AG.A(a,b)};TF.C=function(a,b,c){return TF.A(a,$APP.Je.B(mG,b,c))};
TF.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};TF.G=2;var OF,Yfc=$APP.kh.j($APP.F),Zfc=$APP.kh.j($APP.F),$fc=$APP.kh.j($APP.F),agc=$APP.kh.j($APP.F),bgc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));OF=new $APP.Ch($APP.Zg.A("emmy.generic","mul"),LP,$APP.yj,bgc,Yfc,Zfc,$fc,agc);
OF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[$APP.Q,$APP.Hv,eN,function(c,d){return d},fN,function(c){return c},ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null)],null);return b.j?b.j(a):b.call(null,a)});
var kG=function kG(a){switch(arguments.length){case 0:return kG.J();case 1:return kG.j(arguments[0]);case 2:return kG.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return kG.C(arguments[0],arguments[1],c)}};kG.J=function(){return 1};kG.j=function(a){return a};
kG.A=function(a,b){var c=BF(a),d=BF(b);return $APP.k(c?MF.j(a):c)?vG.j(b):$APP.k(d?MF.j(b):d)?vG.j(a):$APP.k(c?uG.j(a):c)?b:$APP.k(d?uG.j(b):d)?a:OF.A(a,b)};kG.C=function(a,b,c){return $APP.Id.B(kG,kG.A(a,b),c)};kG.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};kG.G=2;var QF,cgc=$APP.kh.j($APP.F),dgc=$APP.kh.j($APP.F),egc=$APP.kh.j($APP.F),fgc=$APP.kh.j($APP.F),ggc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
QF=new $APP.Ch($APP.Zg.A("emmy.generic","invert"),LP,$APP.yj,ggc,cgc,dgc,egc,fgc);QF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[$APP.Q,$APP.sj,eN,function(c){c=nG.j?nG.j(c):nG.call(null,c);return BG.A?BG.A(-1,c):BG.call(null,-1,c)},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null)],null);return b.j?b.j(a):b.call(null,a)});var hgc=!1;QF.F(null,$APP.yj,function(a){var b=hgc;hgc=!0;try{return BG.A?BG.A(1,a):BG.call(null,1,a)}finally{hgc=b}});
var BG,igc=$APP.kh.j($APP.F),jgc=$APP.kh.j($APP.F),kgc=$APP.kh.j($APP.F),lgc=$APP.kh.j($APP.F),mgc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));BG=new $APP.Ch($APP.Zg.A("emmy.generic","div"),LP,$APP.yj,mgc,igc,jgc,kgc,lgc);
BG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[$APP.Q,$APP.sj,eN,function(c,d){return BG.A(1,d)},fN,function(c,d){return BG.A(RF.j(c),nG.j?nG.j(d):nG.call(null,d))},ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null)],null);return b.j?b.j(a):b.call(null,a)});BG.F(null,$APP.yj,function(a,b){if($APP.k(hgc))throw $APP.Zi.A("No implementation of [[invert]] or [[div]].",new $APP.f(null,2,[$APP.ny,LY,$APP.Xj,new $APP.H(null,2,5,$APP.I,[a,b],null)],null));return OF.A(a,QF.j(b))});
var SF=function SF(a){switch(arguments.length){case 0:return SF.J();case 1:return SF.j(arguments[0]);case 2:return SF.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return SF.C(arguments[0],arguments[1],c)}};SF.J=function(){return 1};SF.j=function(a){return QF.j(a)};SF.A=function(a,b){var c=(c=GF(b))?uG.j(b):c;return $APP.k(c)?a:BG.A(a,b)};SF.C=function(a,b,c){return SF.A(a,$APP.Je.B(kG,b,c))};
SF.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};SF.G=2;var kM,ngc=$APP.kh.j($APP.F),ogc=$APP.kh.j($APP.F),pgc=$APP.kh.j($APP.F),qgc=$APP.kh.j($APP.F),rgc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));kM=new $APP.Ch($APP.Zg.A("emmy.generic","exact-divide"),LP,$APP.yj,rgc,ngc,ogc,pgc,qgc);
kM.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,w6b],null);return b.j?b.j(a):b.call(null,a)});var qG,sgc=$APP.kh.j($APP.F),tgc=$APP.kh.j($APP.F),ugc=$APP.kh.j($APP.F),vgc=$APP.kh.j($APP.F),wgc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));qG=new $APP.Ch($APP.Zg.A("emmy.generic","exp"),LP,$APP.yj,wgc,sgc,tgc,ugc,vgc);
qG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,qG,ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,BJ],null);return b.j?b.j(a):b.call(null,a)});var mZ,xgc=$APP.kh.j($APP.F),ygc=$APP.kh.j($APP.F),zgc=$APP.kh.j($APP.F),Agc=$APP.kh.j($APP.F),Bgc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));mZ=new $APP.Ch($APP.Zg.A("emmy.generic","exp2"),LP,$APP.yj,Bgc,xgc,ygc,zgc,Agc);
mZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,kQb],null);return b.j?b.j(a):b.call(null,a)});mZ.F(null,$APP.yj,function(a){return tI.A?tI.A(2,a):tI.call(null,2,a)});var nZ,Cgc=$APP.kh.j($APP.F),Dgc=$APP.kh.j($APP.F),Egc=$APP.kh.j($APP.F),Fgc=$APP.kh.j($APP.F),Ggc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));nZ=new $APP.Ch($APP.Zg.A("emmy.generic","exp10"),LP,$APP.yj,Ggc,Cgc,Dgc,Egc,Fgc);
nZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,cdc],null);return b.j?b.j(a):b.call(null,a)});nZ.F(null,$APP.yj,function(a){return tI.A?tI.A(10,a):tI.call(null,10,a)});var rG,Hgc=$APP.kh.j($APP.F),Igc=$APP.kh.j($APP.F),Jgc=$APP.kh.j($APP.F),Kgc=$APP.kh.j($APP.F),Lgc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));rG=new $APP.Ch($APP.Zg.A("emmy.generic","log"),LP,$APP.yj,Lgc,Hgc,Igc,Jgc,Kgc);
rG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,QF,ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,DJ],null);return b.j?b.j(a):b.call(null,a)});var oZ,Mgc=$APP.kh.j($APP.F),Ngc=$APP.kh.j($APP.F),Ogc=$APP.kh.j($APP.F),Pgc=$APP.kh.j($APP.F),Qgc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));oZ=new $APP.Ch($APP.Zg.A("emmy.generic","log2"),LP,$APP.yj,Qgc,Mgc,Ngc,Ogc,Pgc);
oZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,Etb],null);return b.j?b.j(a):b.call(null,a)});var Rgc=Math.log(2);oZ.F(null,$APP.yj,function(a){return BG.A(rG.j(a),Rgc)});var pZ,Sgc=$APP.kh.j($APP.F),Tgc=$APP.kh.j($APP.F),Ugc=$APP.kh.j($APP.F),Vgc=$APP.kh.j($APP.F),Wgc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
pZ=new $APP.Ch($APP.Zg.A("emmy.generic","log10"),LP,$APP.yj,Wgc,Sgc,Tgc,Ugc,Vgc);pZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,Ynb],null);return b.j?b.j(a):b.call(null,a)});var Xgc=Math.log(10);pZ.F(null,$APP.yj,function(a){return BG.A(rG.j(a),Xgc)});var tI,Ygc=$APP.kh.j($APP.F),Zgc=$APP.kh.j($APP.F),$gc=$APP.kh.j($APP.F),ahc=$APP.kh.j($APP.F),bhc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
tI=new $APP.Ch($APP.Zg.A("emmy.generic","expt"),LP,$APP.yj,bhc,Ygc,Zgc,$gc,ahc);tI.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[eN,function(c,d){return OF.A(d,tI.A(c,AG.A(d,1)))},fN,function(c,d){var g=(g=GF(c))?MF.j(c):g;return $APP.k(g)?GF(d)?$APP.eb(sG.j?sG.j(d):sG.call(null,d))?0:yD("Derivative undefined: expt"):0:OF.A(rG.j(c),tI.A(c,d))},ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,FJ],null);return b.j?b.j(a):b.call(null,a)});var KSa=100*OR;
tI.F(null,$APP.yj,function(a,b){return $APP.xd(b)?JSa(a,b):qG.j(OF.A(b,rG.j(a)))});var nG,chc=$APP.kh.j($APP.F),dhc=$APP.kh.j($APP.F),ehc=$APP.kh.j($APP.F),fhc=$APP.kh.j($APP.F),ghc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));nG=new $APP.Ch($APP.Zg.A("emmy.generic","square"),LP,$APP.yj,ghc,chc,dhc,ehc,fhc);
nG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return OF.A(2,c)},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,cT],null);return b.j?b.j(a):b.call(null,a)});nG.F(null,$APP.yj,function(a){return tI.A(a,2)});var qZ,hhc=$APP.kh.j($APP.F),ihc=$APP.kh.j($APP.F),jhc=$APP.kh.j($APP.F),khc=$APP.kh.j($APP.F),lhc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
qZ=new $APP.Ch($APP.Zg.A("emmy.generic","cube"),LP,$APP.yj,lhc,hhc,ihc,jhc,khc);qZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return OF.A(3,nG.j(c))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,vV],null);return b.j?b.j(a):b.call(null,a)});qZ.F(null,$APP.yj,function(a){return tI.A(a,3)});var lG,mhc=$APP.kh.j($APP.F),nhc=$APP.kh.j($APP.F),ohc=$APP.kh.j($APP.F),phc=$APP.kh.j($APP.F),qhc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
lG=new $APP.Ch($APP.Zg.A("emmy.generic","sqrt"),LP,$APP.yj,qhc,mhc,nhc,ohc,phc);lG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return QF.j(OF.A(lG.j(c),2))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,HJ],null);return b.j?b.j(a):b.call(null,a)});lG.F(null,$APP.yj,function(a){return qG.j(OF.A(BG.A(1,2),rG.j(a)))});
var sG,rhc=$APP.kh.j($APP.F),shc=$APP.kh.j($APP.F),thc=$APP.kh.j($APP.F),uhc=$APP.kh.j($APP.F),vhc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));sG=new $APP.Ch($APP.Zg.A("emmy.generic","negative?"),LP,$APP.yj,vhc,rhc,shc,thc,uhc);sG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,AX],null);return b.j?b.j(a):b.call(null,a)});sG.F(null,$APP.yj,function(a){return 0>$APP.Ed(a,vG.j(a))});
var oG,whc=$APP.kh.j($APP.F),xhc=$APP.kh.j($APP.F),yhc=$APP.kh.j($APP.F),zhc=$APP.kh.j($APP.F),Ahc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));oG=new $APP.Ch($APP.Zg.A("emmy.generic","infinite?"),LP,$APP.yj,Ahc,whc,xhc,yhc,zhc);oG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,$APP.dw],null);return b.j?b.j(a):b.call(null,a)});oG.F(null,$APP.yj,function(){return!1});
var jG,Bhc=$APP.kh.j($APP.F),Chc=$APP.kh.j($APP.F),Dhc=$APP.kh.j($APP.F),Ehc=$APP.kh.j($APP.F),Fhc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));jG=new $APP.Ch($APP.Zg.A("emmy.generic","abs"),LP,$APP.yj,Fhc,Bhc,Chc,Dhc,Ehc);jG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,$APP.Ku],null);return b.j?b.j(a):b.call(null,a)});
var rZ,Ghc=$APP.kh.j($APP.F),Hhc=$APP.kh.j($APP.F),Ihc=$APP.kh.j($APP.F),Jhc=$APP.kh.j($APP.F),Khc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));rZ=new $APP.Ch($APP.Zg.A("emmy.generic","floor"),LP,$APP.yj,Khc,Ghc,Hhc,Ihc,Jhc);rZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,dT],null);return b.j?b.j(a):b.call(null,a)});
rZ.F(null,$APP.yj,function(a){return $APP.k(sG.j(a))?AG.A(sZ.j?sZ.j(a):sZ.call(null,a),1):sZ.j?sZ.j(a):sZ.call(null,a)});var tZ,Lhc=$APP.kh.j($APP.F),Mhc=$APP.kh.j($APP.F),Nhc=$APP.kh.j($APP.F),Ohc=$APP.kh.j($APP.F),Phc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));tZ=new $APP.Ch($APP.Zg.A("emmy.generic","ceiling"),LP,$APP.yj,Phc,Lhc,Mhc,Nhc,Ohc);
tZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,lY],null);return b.j?b.j(a):b.call(null,a)});tZ.F(null,$APP.yj,function(a){return RF.j(rZ.j(RF.j(a)))});var sZ,Qhc=$APP.kh.j($APP.F),Rhc=$APP.kh.j($APP.F),Shc=$APP.kh.j($APP.F),Thc=$APP.kh.j($APP.F),Uhc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));sZ=new $APP.Ch($APP.Zg.A("emmy.generic","integer-part"),LP,$APP.yj,Uhc,Qhc,Rhc,Shc,Thc);
sZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,YV],null);return b.j?b.j(a):b.call(null,a)});var uZ,Vhc=$APP.kh.j($APP.F),Whc=$APP.kh.j($APP.F),Xhc=$APP.kh.j($APP.F),Yhc=$APP.kh.j($APP.F),Zhc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));uZ=new $APP.Ch($APP.Zg.A("emmy.generic","fractional-part"),LP,$APP.yj,Zhc,Vhc,Whc,Xhc,Yhc);
uZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,zW],null);return b.j?b.j(a):b.call(null,a)});uZ.F(null,$APP.yj,function(a){return AG.A(a,rZ.j(a))});var sI,$hc=$APP.kh.j($APP.F),aic=$APP.kh.j($APP.F),bic=$APP.kh.j($APP.F),cic=$APP.kh.j($APP.F),dic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));sI=new $APP.Ch($APP.Zg.A("emmy.generic","quotient"),LP,$APP.yj,dic,$hc,aic,bic,cic);
sI.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,nX],null);return b.j?b.j(a):b.call(null,a)});var nI,eic=$APP.kh.j($APP.F),fic=$APP.kh.j($APP.F),gic=$APP.kh.j($APP.F),hic=$APP.kh.j($APP.F),iic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));nI=new $APP.Ch($APP.Zg.A("emmy.generic","modulo"),LP,$APP.yj,iic,eic,fic,gic,hic);
nI.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,$X],null);return b.j?b.j(a):b.call(null,a)});nI.F(null,$APP.yj,function(a,b){return AG.A(a,OF.A(b,rZ.j(BG.A(a,b))))});var CG,jic=$APP.kh.j($APP.F),kic=$APP.kh.j($APP.F),lic=$APP.kh.j($APP.F),mic=$APP.kh.j($APP.F),nic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
CG=new $APP.Ch($APP.Zg.A("emmy.generic","remainder"),LP,$APP.yj,nic,jic,kic,lic,mic);CG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,gS],null);return b.j?b.j(a):b.call(null,a)});CG.F(null,$APP.yj,function(a,b){var c=BG.A(a,b);return $APP.Uc.A(sG.j(a),sG.j(b))?OF.A(b,AG.A(c,rZ.j(c))):OF.A(b,AG.A(c,tZ.j(c)))});
var yM,oic=$APP.kh.j($APP.F),pic=$APP.kh.j($APP.F),qic=$APP.kh.j($APP.F),ric=$APP.kh.j($APP.F),sic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));yM=new $APP.Ch($APP.Zg.A("emmy.generic","gcd"),LP,$APP.yj,sic,oic,pic,qic,ric);yM.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,kK],null);return b.j?b.j(a):b.call(null,a)});
var qM,tic=$APP.kh.j($APP.F),uic=$APP.kh.j($APP.F),vic=$APP.kh.j($APP.F),wic=$APP.kh.j($APP.F),xic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));qM=new $APP.Ch($APP.Zg.A("emmy.generic","lcm"),LP,$APP.yj,xic,tic,uic,vic,wic);qM.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,FV],null);return b.j?b.j(a):b.call(null,a)});
qM.F(null,$APP.yj,function(a,b){var c=yM.A(a,b);return $APP.k(MF.j(c))?c:jG.j(kG.A(kM.A(a,c),b))});var hO,yic=$APP.kh.j($APP.F),zic=$APP.kh.j($APP.F),Aic=$APP.kh.j($APP.F),Bic=$APP.kh.j($APP.F),Cic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));hO=new $APP.Ch($APP.Zg.A("emmy.generic","cos"),LP,$APP.yj,Cic,yic,zic,Aic,Bic);
hO.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(iO.j?iO.j(c):iO.call(null,c))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,uH],null);return b.j?b.j(a):b.call(null,a)});var iO,Dic=$APP.kh.j($APP.F),Eic=$APP.kh.j($APP.F),Fic=$APP.kh.j($APP.F),Gic=$APP.kh.j($APP.F),Hic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));iO=new $APP.Ch($APP.Zg.A("emmy.generic","sin"),LP,$APP.yj,Hic,Dic,Eic,Fic,Gic);
iO.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,hO,ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,mH],null);return b.j?b.j(a):b.call(null,a)});var vZ,Iic=$APP.kh.j($APP.F),Jic=$APP.kh.j($APP.F),Kic=$APP.kh.j($APP.F),Lic=$APP.kh.j($APP.F),Mic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));vZ=new $APP.Ch($APP.Zg.A("emmy.generic","tan"),LP,$APP.yj,Mic,Iic,Jic,Kic,Lic);
vZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return QF.j(nG.j(hO.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,nK],null);return b.j?b.j(a):b.call(null,a)});vZ.F(null,$APP.yj,function(a){return BG.A(iO.j(a),hO.j(a))});var wZ,Nic=$APP.kh.j($APP.F),Oic=$APP.kh.j($APP.F),Pic=$APP.kh.j($APP.F),Qic=$APP.kh.j($APP.F),Ric=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
wZ=new $APP.Ch($APP.Zg.A("emmy.generic","cot"),LP,$APP.yj,Ric,Nic,Oic,Pic,Qic);wZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(nG.j(xZ.j?xZ.j(c):xZ.call(null,c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,OM],null);return b.j?b.j(a):b.call(null,a)});wZ.F(null,$APP.yj,function(a){return BG.A(hO.j(a),iO.j(a))});
var yZ,Sic=$APP.kh.j($APP.F),Tic=$APP.kh.j($APP.F),Uic=$APP.kh.j($APP.F),Vic=$APP.kh.j($APP.F),Wic=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));yZ=new $APP.Ch($APP.Zg.A("emmy.generic","sec"),LP,$APP.yj,Wic,Sic,Tic,Uic,Vic);yZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return OF.A(yZ.j(c),vZ.j(c))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,NM],null);return b.j?b.j(a):b.call(null,a)});yZ.F(null,$APP.yj,function(a){return QF.j(hO.j(a))});
var xZ,Xic=$APP.kh.j($APP.F),Yic=$APP.kh.j($APP.F),Zic=$APP.kh.j($APP.F),$ic=$APP.kh.j($APP.F),ajc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));xZ=new $APP.Ch($APP.Zg.A("emmy.generic","csc"),LP,$APP.yj,ajc,Xic,Yic,Zic,$ic);xZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(OF.A(wZ.j(c),xZ.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,PM],null);return b.j?b.j(a):b.call(null,a)});xZ.F(null,$APP.yj,function(a){return QF.j(iO.j(a))});
var tG,bjc=$APP.kh.j($APP.F),cjc=$APP.kh.j($APP.F),djc=$APP.kh.j($APP.F),ejc=$APP.kh.j($APP.F),fjc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));tG=new $APP.Ch($APP.Zg.A("emmy.generic","atan"),LP,$APP.yj,fjc,bjc,cjc,djc,ejc);
tG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,4,[eN,function(){function c(l,n){return BG.A(n,gH.A(nG.j(n),nG.j(l)))}function d(l){return QF.j(gH.A(1,nG.j(l)))}var g=null;g=function(l,n){switch(arguments.length){case 1:return d.call(this,l);case 2:return c.call(this,l,n)}throw Error("Invalid arity: "+arguments.length);};g.j=d;g.A=c;return g}(),fN,function(c,d){return BG.A(RF.j(c),gH.A(nG.j(d),nG.j(c)))},ZH,new $APP.H(null,3,5,$APP.I,[PX,1,2],null),$APP.Q,jK],
null);return b.j?b.j(a):b.call(null,a)});var zZ,gjc=$APP.kh.j($APP.F),hjc=$APP.kh.j($APP.F),ijc=$APP.kh.j($APP.F),jjc=$APP.kh.j($APP.F),kjc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));zZ=new $APP.Ch($APP.Zg.A("emmy.generic","asin"),LP,$APP.yj,kjc,gjc,hjc,ijc,jjc);
zZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return QF.j(lG.j(AG.A(1,nG.j(c))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,lK],null);return b.j?b.j(a):b.call(null,a)});zZ.F(null,$APP.yj,function(a){return tG.j(BG.A(a,lG.j(AG.A(1,nG.j(a)))))});var mO,ljc=$APP.kh.j($APP.F),mjc=$APP.kh.j($APP.F),njc=$APP.kh.j($APP.F),ojc=$APP.kh.j($APP.F),pjc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
mO=new $APP.Ch($APP.Zg.A("emmy.generic","acos"),LP,$APP.yj,pjc,ljc,mjc,njc,ojc);mO.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(QF.j(lG.j(AG.A(1,nG.j(c)))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,mK],null);return b.j?b.j(a):b.call(null,a)});mO.F(null,$APP.yj,function(a){return tG.j(BG.A(lG.j(AG.A(1,nG.j(a))),a))});
var AZ,qjc=$APP.kh.j($APP.F),rjc=$APP.kh.j($APP.F),sjc=$APP.kh.j($APP.F),tjc=$APP.kh.j($APP.F),ujc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));AZ=new $APP.Ch($APP.Zg.A("emmy.generic","acot"),LP,$APP.yj,ujc,qjc,rjc,sjc,tjc);AZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(QF.j(gH.A(1,nG.j(c))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,ZS],null);return b.j?b.j(a):b.call(null,a)});
AZ.F(null,$APP.yj,function(a){return AG.A(SF.A(Math.PI,2),tG.j(a))});var BZ,vjc=$APP.kh.j($APP.F),wjc=$APP.kh.j($APP.F),xjc=$APP.kh.j($APP.F),yjc=$APP.kh.j($APP.F),zjc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));BZ=new $APP.Ch($APP.Zg.A("emmy.generic","asec"),LP,$APP.yj,zjc,vjc,wjc,xjc,yjc);
BZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return QF.j(OF.A(c,lG.j(AG.A(nG.j(c),1))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,Nnb],null);return b.j?b.j(a):b.call(null,a)});BZ.F(null,$APP.yj,function(a){return tG.j(lG.j(AG.A(nG.j(a),1)))});var CZ,Ajc=$APP.kh.j($APP.F),Bjc=$APP.kh.j($APP.F),Cjc=$APP.kh.j($APP.F),Djc=$APP.kh.j($APP.F),Ejc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
CZ=new $APP.Ch($APP.Zg.A("emmy.generic","acsc"),LP,$APP.yj,Ejc,Ajc,Bjc,Cjc,Djc);CZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(QF.j(OF.A(c,lG.j(AG.A(nG.j(c),1)))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,Ohb],null);return b.j?b.j(a):b.call(null,a)});CZ.F(null,$APP.yj,function(a){return tG.j(QF.j(lG.j(AG.A(nG.j(a),1))))});
var vH,Fjc=$APP.kh.j($APP.F),Gjc=$APP.kh.j($APP.F),Hjc=$APP.kh.j($APP.F),Ijc=$APP.kh.j($APP.F),Jjc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));vH=new $APP.Ch($APP.Zg.A("emmy.generic","cosh"),LP,$APP.yj,Jjc,Fjc,Gjc,Hjc,Ijc);vH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,xH,ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,wH],null);return b.j?b.j(a):b.call(null,a)});
vH.F(null,$APP.yj,function(a){return BG.A(gH.A(qG.j(a),qG.j(RF.j(a))),2)});var xH,Kjc=$APP.kh.j($APP.F),Ljc=$APP.kh.j($APP.F),Mjc=$APP.kh.j($APP.F),Njc=$APP.kh.j($APP.F),Ojc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));xH=new $APP.Ch($APP.Zg.A("emmy.generic","sinh"),LP,$APP.yj,Ojc,Kjc,Ljc,Mjc,Njc);
xH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,vH,ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,yH],null);return b.j?b.j(a):b.call(null,a)});xH.F(null,$APP.yj,function(a){return BG.A(AG.A(qG.j(a),qG.j(RF.j(a))),2)});var DZ,Pjc=$APP.kh.j($APP.F),Qjc=$APP.kh.j($APP.F),Rjc=$APP.kh.j($APP.F),Sjc=$APP.kh.j($APP.F),Tjc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
DZ=new $APP.Ch($APP.Zg.A("emmy.generic","tanh"),LP,$APP.yj,Tjc,Pjc,Qjc,Rjc,Sjc);DZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return AG.A(1,nG.j(DZ.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,qX],null);return b.j?b.j(a):b.call(null,a)});DZ.F(null,$APP.yj,function(a){a=qG.j(gH.A(a,a));return BG.A(AG.A(a,1),gH.A(a,1))});
var EZ,Ujc=$APP.kh.j($APP.F),Vjc=$APP.kh.j($APP.F),Wjc=$APP.kh.j($APP.F),Xjc=$APP.kh.j($APP.F),Yjc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));EZ=new $APP.Ch($APP.Zg.A("emmy.generic","sech"),LP,$APP.yj,Yjc,Ujc,Vjc,Wjc,Xjc);EZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(OF.A(EZ.j(c),DZ.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,uT],null);return b.j?b.j(a):b.call(null,a)});
EZ.F(null,$APP.yj,function(a){return BG.A(2,gH.A(qG.j(a),qG.j(RF.j(a))))});var FZ,Zjc=$APP.kh.j($APP.F),$jc=$APP.kh.j($APP.F),akc=$APP.kh.j($APP.F),bkc=$APP.kh.j($APP.F),ckc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));FZ=new $APP.Ch($APP.Zg.A("emmy.generic","coth"),LP,$APP.yj,ckc,Zjc,$jc,akc,bkc);
FZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(nG.j(GZ.j?GZ.j(c):GZ.call(null,c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,vW],null);return b.j?b.j(a):b.call(null,a)});FZ.F(null,$APP.yj,function(a){a=qG.j(gH.A(a,a));return BG.A(gH.A(a,1),AG.A(a,1))});var GZ,dkc=$APP.kh.j($APP.F),ekc=$APP.kh.j($APP.F),fkc=$APP.kh.j($APP.F),gkc=$APP.kh.j($APP.F),hkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
GZ=new $APP.Ch($APP.Zg.A("emmy.generic","csch"),LP,$APP.yj,hkc,dkc,ekc,fkc,gkc);GZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(OF.A(FZ.j(c),GZ.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,gW],null);return b.j?b.j(a):b.call(null,a)});GZ.F(null,$APP.yj,function(a){return BG.A(2,AG.A(qG.j(a),qG.j(RF.j(a))))});
var HZ,ikc=$APP.kh.j($APP.F),jkc=$APP.kh.j($APP.F),kkc=$APP.kh.j($APP.F),lkc=$APP.kh.j($APP.F),mkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));HZ=new $APP.Ch($APP.Zg.A("emmy.generic","acosh"),LP,$APP.yj,mkc,ikc,jkc,kkc,lkc);HZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return QF.j(OF.A(lG.j(AG.A(c,1)),lG.j(gH.A(c,1))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,qV],null);return b.j?b.j(a):b.call(null,a)});
HZ.F(null,$APP.yj,function(a){return OF.A(2,rG.j(gH.A(lG.j(BG.A(gH.A(a,1),2)),lG.j(BG.A(AG.A(a,1),2)))))});var IZ,nkc=$APP.kh.j($APP.F),okc=$APP.kh.j($APP.F),pkc=$APP.kh.j($APP.F),qkc=$APP.kh.j($APP.F),rkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));IZ=new $APP.Ch($APP.Zg.A("emmy.generic","asinh"),LP,$APP.yj,rkc,nkc,okc,pkc,qkc);
IZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return QF.j(lG.j(gH.A(1,nG.j(c))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,hW],null);return b.j?b.j(a):b.call(null,a)});IZ.F(null,$APP.yj,function(a){return rG.j(gH.A(a,lG.j(gH.A(1,nG.j(a)))))});var JZ,skc=$APP.kh.j($APP.F),tkc=$APP.kh.j($APP.F),ukc=$APP.kh.j($APP.F),vkc=$APP.kh.j($APP.F),wkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
JZ=new $APP.Ch($APP.Zg.A("emmy.generic","atanh"),LP,$APP.yj,wkc,skc,tkc,ukc,vkc);JZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return QF.j(AG.A(1,nG.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,HV],null);return b.j?b.j(a):b.call(null,a)});JZ.F(null,$APP.yj,function(a){return BG.A(AG.A(rG.j(gH.A(1,a)),rG.j(AG.A(1,a))),2)});
var KZ,xkc=$APP.kh.j($APP.F),ykc=$APP.kh.j($APP.F),zkc=$APP.kh.j($APP.F),Akc=$APP.kh.j($APP.F),Bkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));KZ=new $APP.Ch($APP.Zg.A("emmy.generic","acoth"),LP,$APP.yj,Bkc,xkc,ykc,zkc,Akc);KZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return QF.j(AG.A(1,nG.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,MEb],null);return b.j?b.j(a):b.call(null,a)});
KZ.F(null,$APP.yj,function(a){return BG.A(AG.A(rG.j(gH.A(a,1)),rG.j(AG.A(a,1))),2)});var LZ,Ckc=$APP.kh.j($APP.F),Dkc=$APP.kh.j($APP.F),Ekc=$APP.kh.j($APP.F),Fkc=$APP.kh.j($APP.F),Gkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));LZ=new $APP.Ch($APP.Zg.A("emmy.generic","asech"),LP,$APP.yj,Gkc,Ckc,Dkc,Ekc,Fkc);
LZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){var d=gH.A(c,1);return RF.j(QF.j(OF.A(OF.A(c,d),lG.j(BG.A(AG.A(1,c),d)))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,O3b],null);return b.j?b.j(a):b.call(null,a)});LZ.F(null,$APP.yj,function(a){return rG.j(BG.A(gH.A(1,lG.j(AG.A(1,nG.j(a)))),a))});
var MZ,Hkc=$APP.kh.j($APP.F),Ikc=$APP.kh.j($APP.F),Jkc=$APP.kh.j($APP.F),Kkc=$APP.kh.j($APP.F),Lkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));MZ=new $APP.Ch($APP.Zg.A("emmy.generic","acsch"),LP,$APP.yj,Lkc,Hkc,Ikc,Jkc,Kkc);MZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return RF.j(QF.j(OF.A(c,lG.j(gH.A(nG.j(c),1)))))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,vhb],null);return b.j?b.j(a):b.call(null,a)});
MZ.F(null,$APP.yj,function(a){return rG.j(BG.A(gH.A(1,lG.j(gH.A(1,nG.j(a)))),a))});var tR,Mkc=$APP.kh.j($APP.F),Nkc=$APP.kh.j($APP.F),Okc=$APP.kh.j($APP.F),Pkc=$APP.kh.j($APP.F),Qkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));tR=new $APP.Ch($APP.Zg.A("emmy.generic","sinc"),LP,$APP.yj,Qkc,Mkc,Nkc,Okc,Pkc);
tR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return $APP.k(MF.j(c))?c:AG.A(BG.A(hO.j(c),c),BG.A(iO.j(c),nG.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,I$b],null);return b.j?b.j(a):b.call(null,a)});tR.F(null,$APP.yj,function(a){return $APP.k(MF.j(a))?PF.j(a):BG.A(iO.j(a),a)});var NZ,Rkc=$APP.kh.j($APP.F),Skc=$APP.kh.j($APP.F),Tkc=$APP.kh.j($APP.F),Ukc=$APP.kh.j($APP.F),Vkc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
NZ=new $APP.Ch($APP.Zg.A("emmy.generic","tanc"),LP,$APP.yj,Vkc,Rkc,Skc,Tkc,Ukc);NZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){if($APP.k(MF.j(c)))return c;var d=yZ.j(c);return AG.A(BG.A(kG.A(d,d),c),BG.A(vZ.j(c),nG.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,zXb],null);return b.j?b.j(a):b.call(null,a)});NZ.F(null,$APP.yj,function(a){return $APP.k(MF.j(a))?PF.j(a):BG.A(vZ.j(a),a)});
var vR,Wkc=$APP.kh.j($APP.F),Xkc=$APP.kh.j($APP.F),Ykc=$APP.kh.j($APP.F),Zkc=$APP.kh.j($APP.F),$kc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));vR=new $APP.Ch($APP.Zg.A("emmy.generic","sinhc"),LP,$APP.yj,$kc,Wkc,Xkc,Ykc,Zkc);
vR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){return $APP.k(MF.j(c))?c:AG.A(BG.A(vH.j(c),c),BG.A(xH.j(c),nG.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,N_b],null);return b.j?b.j(a):b.call(null,a)});vR.F(null,$APP.yj,function(a){return $APP.k(MF.j(a))?PF.j(a):BG.A(xH.j(a),a)});var OZ,alc=$APP.kh.j($APP.F),blc=$APP.kh.j($APP.F),clc=$APP.kh.j($APP.F),dlc=$APP.kh.j($APP.F),elc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));
OZ=new $APP.Ch($APP.Zg.A("emmy.generic","tanhc"),LP,$APP.yj,elc,alc,blc,clc,dlc);OZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,3,[eN,function(c){if($APP.k(MF.j(c)))return c;var d=EZ.j(c);return AG.A(BG.A(kG.A(d,d),c),BG.A(DZ.j(c),nG.j(c)))},ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,Fnb],null);return b.j?b.j(a):b.call(null,a)});OZ.F(null,$APP.yj,function(a){return $APP.k(MF.j(a))?PF.j(a):BG.A(DZ.j(a),a)});
var PZ,flc=$APP.kh.j($APP.F),glc=$APP.kh.j($APP.F),hlc=$APP.kh.j($APP.F),ilc=$APP.kh.j($APP.F),jlc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));PZ=new $APP.Ch($APP.Zg.A("emmy.generic","make-rectangular"),LP,$APP.yj,jlc,flc,glc,hlc,ilc);PZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,RV],null);return b.j?b.j(a):b.call(null,a)});
var QZ,klc=$APP.kh.j($APP.F),llc=$APP.kh.j($APP.F),mlc=$APP.kh.j($APP.F),nlc=$APP.kh.j($APP.F),olc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));QZ=new $APP.Ch($APP.Zg.A("emmy.generic","make-polar"),LP,$APP.yj,olc,klc,llc,mlc,nlc);QZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,FT],null);return b.j?b.j(a):b.call(null,a)});
var zH,plc=$APP.kh.j($APP.F),qlc=$APP.kh.j($APP.F),rlc=$APP.kh.j($APP.F),slc=$APP.kh.j($APP.F),tlc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));zH=new $APP.Ch($APP.Zg.A("emmy.generic","real-part"),LP,$APP.yj,tlc,plc,qlc,rlc,slc);zH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,bU],null);return b.j?b.j(a):b.call(null,a)});
var CH,ulc=$APP.kh.j($APP.F),vlc=$APP.kh.j($APP.F),wlc=$APP.kh.j($APP.F),xlc=$APP.kh.j($APP.F),ylc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));CH=new $APP.Ch($APP.Zg.A("emmy.generic","imag-part"),LP,$APP.yj,ylc,ulc,vlc,wlc,xlc);CH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,jV],null);return b.j?b.j(a):b.call(null,a)});
var zG,zlc=$APP.kh.j($APP.F),Alc=$APP.kh.j($APP.F),Blc=$APP.kh.j($APP.F),Clc=$APP.kh.j($APP.F),Dlc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));zG=new $APP.Ch($APP.Zg.A("emmy.generic","magnitude"),LP,$APP.yj,Dlc,zlc,Alc,Blc,Clc);zG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,CK],null);return b.j?b.j(a):b.call(null,a)});
var RZ,Elc=$APP.kh.j($APP.F),Flc=$APP.kh.j($APP.F),Glc=$APP.kh.j($APP.F),Hlc=$APP.kh.j($APP.F),Ilc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));RZ=new $APP.Ch($APP.Zg.A("emmy.generic","angle"),LP,$APP.yj,Ilc,Elc,Flc,Glc,Hlc);RZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,EY],null);return b.j?b.j(a):b.call(null,a)});
var sL,Jlc=$APP.kh.j($APP.F),Klc=$APP.kh.j($APP.F),Llc=$APP.kh.j($APP.F),Mlc=$APP.kh.j($APP.F),Nlc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));sL=new $APP.Ch($APP.Zg.A("emmy.generic","conjugate"),LP,$APP.yj,Nlc,Jlc,Klc,Llc,Mlc);sL.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,pY],null);return b.j?b.j(a):b.call(null,a)});
var gR,Olc=$APP.kh.j($APP.F),Plc=$APP.kh.j($APP.F),Qlc=$APP.kh.j($APP.F),Rlc=$APP.kh.j($APP.F),Slc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));gR=new $APP.Ch($APP.Zg.A("emmy.generic","transpose"),LP,$APP.yj,Slc,Olc,Plc,Qlc,Rlc);gR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,$APP.XX],null);return b.j?b.j(a):b.call(null,a)});
var SZ,Tlc=$APP.kh.j($APP.F),Ulc=$APP.kh.j($APP.F),Vlc=$APP.kh.j($APP.F),Wlc=$APP.kh.j($APP.F),Xlc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));SZ=new $APP.Ch($APP.Zg.A("emmy.generic","trace"),LP,$APP.yj,Xlc,Tlc,Ulc,Vlc,Wlc);SZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,cY],null);return b.j?b.j(a):b.call(null,a)});
var aR,Ylc=$APP.kh.j($APP.F),Zlc=$APP.kh.j($APP.F),$lc=$APP.kh.j($APP.F),amc=$APP.kh.j($APP.F),bmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));aR=new $APP.Ch($APP.Zg.A("emmy.generic","determinant"),LP,$APP.yj,bmc,Ylc,Zlc,$lc,amc);aR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,aSb],null);return b.j?b.j(a):b.call(null,a)});
var NO,cmc=$APP.kh.j($APP.F),dmc=$APP.kh.j($APP.F),emc=$APP.kh.j($APP.F),fmc=$APP.kh.j($APP.F),gmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));NO=new $APP.Ch($APP.Zg.A("emmy.generic","dimension"),LP,$APP.yj,gmc,cmc,dmc,emc,fmc);NO.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,$APP.CY],null);return b.j?b.j(a):b.call(null,a)});
var DH,hmc=$APP.kh.j($APP.F),imc=$APP.kh.j($APP.F),jmc=$APP.kh.j($APP.F),kmc=$APP.kh.j($APP.F),lmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));DH=new $APP.Ch($APP.Zg.A("emmy.generic","dot-product"),LP,$APP.yj,lmc,hmc,imc,jmc,kmc);DH.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,IX],null);return b.j?b.j(a):b.call(null,a)});
var TZ,mmc=$APP.kh.j($APP.F),nmc=$APP.kh.j($APP.F),omc=$APP.kh.j($APP.F),pmc=$APP.kh.j($APP.F),qmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));TZ=new $APP.Ch($APP.Zg.A("emmy.generic","inner-product"),LP,$APP.yj,qmc,mmc,nmc,omc,pmc);TZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,tX],null);return b.j?b.j(a):b.call(null,a)});
var UZ,rmc=$APP.kh.j($APP.F),smc=$APP.kh.j($APP.F),tmc=$APP.kh.j($APP.F),umc=$APP.kh.j($APP.F),vmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));UZ=new $APP.Ch($APP.Zg.A("emmy.generic","outer-product"),LP,$APP.yj,vmc,rmc,smc,tmc,umc);UZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,LQb],null);return b.j?b.j(a):b.call(null,a)});
var VZ,wmc=$APP.kh.j($APP.F),xmc=$APP.kh.j($APP.F),ymc=$APP.kh.j($APP.F),zmc=$APP.kh.j($APP.F),Amc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));VZ=new $APP.Ch($APP.Zg.A("emmy.generic","cross-product"),LP,$APP.yj,Amc,wmc,xmc,ymc,zmc);VZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,Icc],null);return b.j?b.j(a):b.call(null,a)});gR.F(null,new $APP.H(null,1,5,$APP.I,[HF],null),function(a){return a});
SZ.F(null,new $APP.H(null,1,5,$APP.I,[HF],null),function(a){return a});aR.F(null,new $APP.H(null,1,5,$APP.I,[HF],null),function(a){return a});NO.F(null,new $APP.H(null,1,5,$APP.I,[HF],null),function(){return 1});DH.F(null,new $APP.H(null,2,5,$APP.I,[HF,HF],null),function(a,b){return OF.A(a,b)});TZ.F(null,new $APP.H(null,2,5,$APP.I,[HF,HF],null),function(a,b){return DH.A(a,b)});
var XF,Bmc=$APP.kh.j($APP.F),Cmc=$APP.kh.j($APP.F),Dmc=$APP.kh.j($APP.F),Emc=$APP.kh.j($APP.F),Fmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));XF=new $APP.Ch($APP.Zg.A("emmy.generic","solve-linear"),LP,$APP.yj,Fmc,Bmc,Cmc,Dmc,Emc);XF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,B_b],null);return b.j?b.j(a):b.call(null,a)});
var eR,Gmc=$APP.kh.j($APP.F),Hmc=$APP.kh.j($APP.F),Imc=$APP.kh.j($APP.F),Jmc=$APP.kh.j($APP.F),Kmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));eR=new $APP.Ch($APP.Zg.A("emmy.generic","solve-linear-right"),LP,$APP.yj,Kmc,Gmc,Hmc,Imc,Jmc);eR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,iDb],null);return b.j?b.j(a):b.call(null,a)});
XF.F(null,new $APP.H(null,2,5,$APP.I,[HF,HF],null),function(a,b){return BG.A(b,a)});eR.F(null,new $APP.H(null,2,5,$APP.I,[HF,HF],null),function(a,b){return BG.A(a,b)});var oR,Lmc=$APP.kh.j($APP.F),Mmc=$APP.kh.j($APP.F),Nmc=$APP.kh.j($APP.F),Omc=$APP.kh.j($APP.F),Pmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));oR=new $APP.Ch($APP.Zg.A("emmy.generic","partial-derivative"),LP,$APP.yj,Pmc,Lmc,Mmc,Nmc,Omc);
oR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,kS],null);return b.j?b.j(a):b.call(null,a)});var dR,Qmc=$APP.kh.j($APP.F),Rmc=$APP.kh.j($APP.F),Smc=$APP.kh.j($APP.F),Tmc=$APP.kh.j($APP.F),Umc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));dR=new $APP.Ch($APP.Zg.A("emmy.generic","Lie-derivative"),LP,$APP.yj,Umc,Qmc,Rmc,Smc,Tmc);
dR.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,cR],null);return b.j?b.j(a):b.call(null,a)});var dG,Vmc=$APP.kh.j($APP.F),Wmc=$APP.kh.j($APP.F),Xmc=$APP.kh.j($APP.F),Ymc=$APP.kh.j($APP.F),Zmc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));dG=new $APP.Ch($APP.Zg.A("emmy.generic","simplify"),LP,$APP.yj,Zmc,Vmc,Wmc,Xmc,Ymc);
dG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.Q,bS],null);return b.j?b.j(a):b.call(null,a)});dG.F(null,$APP.yj,function(a){return a});dG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){return a});
HSa($APP.fg([$APP.Zs,$APP.yr,$APP.at,$APP.Od,$APP.Ys,kG,$APP.Uc,$APP.Qd,$APP.Mba,$APP.ct,TF,$APP.zd,$APP.$s,$APP.bt,SF,$APP.Pd,mG,$APP.Ek],[$APP.sj,$APP.Iv,$APP.Xv,$X,$APP.Hv,$APP.Hv,$APP.bw,gS,AX,$APP.cw,$APP.Jv,$APP.dw,$APP.$v,$APP.aw,$APP.sj,nX,$APP.Iv,$APP.Jv]));var $mc=new $APP.ug(null,new $APP.f(null,4,[F9b,null,x6b,null,RM,null,geb,null],null),null);$APP.e=YF.prototype;$APP.e.nd=function(){return $APP.Uc.A(this.type,RM)};$APP.e.rb=function(){return this.type};$APP.e.toString=function(){return $APP.jh.C($APP.y([this.expression]))};$APP.e.valueOf=function(){return"number"===typeof this.expression?this.expression:GF(this.expression)?this.expression.valueOf():this};$APP.e.ba=function(){return this.ca};
$APP.e.da=function(a,b){return new YF(this.type,this.expression,b)};$APP.e.Y=function(a,b){return b instanceof YF?(a=$APP.Uc.A(this.type,b.type))?(a=hG.A(this.expression,b.expression),$APP.k(a)?$APP.Uc.A(this.ca,b.ca):a):a:hG.A(this.expression,b)};$APP.e.Tb=function(a,b){return b instanceof YF?$APP.jc(this.expression,b.expression):$APP.jc(this.expression,b)};$APP.e.ea=function(a,b){return $APP.Vb(b,$APP.m.j(this.expression))};
var WZ=function WZ(a){switch(arguments.length){case 3:return WZ.B(arguments[0],arguments[1],arguments[2]);case 2:return WZ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};WZ.B=function(a,b,c){return WZ.A(a,$APP.pe([b,c]))};WZ.A=function(a,b){return ZF(a)?QSa(function(c){return WZ.A(c,b)},a):$APP.Bo(b,a)};WZ.G=3;
var bG=function bG(a,b){for(;;){var d=$APP.kd(a),g=$APP.kd(b),l=b instanceof $APP.q,n="string"===typeof b,p=d&&$APP.hd(a),v=g&&$APP.hd(b),t=new $APP.bh(function(A,B){return function(){return $APP.Ed($APP.yc(A),$APP.yc(B))}}(a,b,d,g,l,n,p,v),null);if(p&&v)return 0;if(p)return-1;if(v)return 1;if(FF(a))return FF(b)?$APP.Ed(a,b):l||n||g?-1:$APP.Fb(t);if(FF(b))return 1;if(a instanceof $APP.q)return l?$APP.Ed(a,b):n||g?-1:$APP.Fb(t);if(l)return 1;if("string"===typeof a)return n?$APP.Ed(a,b):g?-1:$APP.Fb(t);
if(n)return 1;if(d)if(g){d=$APP.Tc(a);g=$APP.Tc(b);if(d<g)return-1;if(g<d)return 1;d=function(){var A=$APP.u(a),B=$APP.u(b);return bG.A?bG.A(A,B):bG.call(null,A,B)}();if(0===d)d=$APP.Fc(a),g=$APP.Fc(b),a=d,b=g;else return d}else return $APP.Fb(t);else return g?1:$APP.Fb(t)}},XZ=function XZ(a){switch(arguments.length){case 2:return XZ.A(arguments[0],arguments[1]);case 3:return XZ.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));
}};XZ.A=function(a,b){return $APP.ZA.C(dG.j(a),$APP.y([$APP.Ax,b]))};XZ.B=function(a,b,c){b=$APP.Je.A($APP.N,$APP.rg.B(c,$APP.Ax,b));a=dG.j(a);return $APP.Je.B($APP.ZA,a,b)};XZ.G=3;MF.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(a){a=a.expression;var b=GF(a);return b?MF.j(a):b});uG.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(a){a=a.expression;var b=GF(a);return b?uG.j(a):b});kZ.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(a){return uG.j(a)});
vG.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(){return 0});PF.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(){return 1});lZ.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(){return 1});VF.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(a){a=a.expression;var b=GF(a);return b?VF.j(a):b});cG.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(a){return cG.j(a.expression)});$APP.e=eG.prototype;$APP.e.rb=function(){return hT};$APP.e.bi=$APP.xc;$APP.e.nd=function(){return!0};$APP.e.toString=function(){return gG.j?gG.j(this):gG.call(null,this)};$APP.e.Y=function(a,b){return VSa.A?VSa.A(this,b):VSa.call(null,this,b)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([gG.j?gG.j(this):gG.call(null,this)]))};var eTa=new eG(0,0),anc=new eG(1,0),pG=new eG(0,1),gTa=new eG(0,-1),cTa=new eG(Infinity,Infinity),bTa=new eG(NaN,NaN),lTa=Math.PI/2,XSa=/([+-]?\d+(\.\d*)?([Ee][+-]?\d+)?)(\s?([+-])?\s?([+-]?\d+(\.\d*)?([Ee][+-]?\d+)?)[Ii])?/;$APP.ju.A(hT,VM);var yG=function yG(a){switch(arguments.length){case 1:return yG.j(arguments[0]);case 2:return yG.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};yG.j=function(a){if("string"===typeof a)return ZSa(a);if($APP.od(a)){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return fG(b,a)}return fG(a,0)};yG.A=function(a,b){return fG(a,b)};yG.G=2;MF.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return iG(a)});
uG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=uG.j(a.ha);return $APP.k(b)?MF.j(a.ia):b});kZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return uG.j(a)});vG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return fG(vG.j(a.ha),vG.j(a.ia))});PF.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return rTa(a)});lZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return rTa(a)});
cG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;return $APP.k(MF.j(a))?b:new $APP.D(null,fY,new $APP.D(null,b,new $APP.D(null,a,null,1,null),2,null),3,null)});VF.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=VF.j(a.ha);return $APP.k(b)?VF.j(a.ia):b});yM.F(null,new $APP.H(null,2,5,$APP.I,[hT,hT],null),function(a,b){return vTa(a,b)});yM.F(null,new $APP.H(null,2,5,$APP.I,[hT,FG],null),function(a,b){return vTa(a,b)});
yM.F(null,new $APP.H(null,2,5,$APP.I,[FG,hT],null),function(a,b){return vTa(a,b)});PZ.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return $APP.k(MF.j(b))?a:yG.A(a,b)});QZ.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return $APP.k(MF.j(a))?a:$APP.k(MF.j(b))?a:yG.A(kG.A(a,hO.j(b)),kG.A(a,iO.j(b)))});zH.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return a.ha});CH.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return a.ia});
zG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return WSa(a)});RZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return tG.A(a.ia,a.ha)});sL.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return fG(a.ha,RF.j(a.ia))});DH.F(null,new $APP.H(null,2,5,$APP.I,[hT,hT],null),function(a,b){return mG.A(kG.A(a.ha,b.ha),kG.A(a.ia,b.ia))});DH.F(null,new $APP.H(null,2,5,$APP.I,[hT,FG],null),function(a,b){return kG.A(a.ha,b)});
DH.F(null,new $APP.H(null,2,5,$APP.I,[FG,hT],null),function(a,b){return kG.A(a,b.ha)});hG.F(null,new $APP.H(null,2,5,$APP.I,[hT,hT],null),function(a,b){return VSa(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[hT,FG],null),function(a,b){var c=MF.j(a.ia);return $APP.k(c)?hG.A(a.ha,b):c});hG.F(null,new $APP.H(null,2,5,$APP.I,[FG,hT],null),function(a,b){var c=MF.j(b.ia);return $APP.k(c)?hG.A(a,b.ha):c});gH.F(null,new $APP.H(null,2,5,$APP.I,[hT,hT],null),function(a,b){return $Sa(a,b)});
gH.F(null,new $APP.H(null,2,5,$APP.I,[hT,FG],null),function(a,b){return $Sa(a,yG.j(b))});gH.F(null,new $APP.H(null,2,5,$APP.I,[FG,hT],null),function(a,b){return $Sa(yG.j(a),b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[hT,hT],null),function(a,b){return aTa(a,b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[hT,FG],null),function(a,b){return aTa(a,yG.j(b))});AG.F(null,new $APP.H(null,2,5,$APP.I,[FG,hT],null),function(a,b){return aTa(yG.j(a),b)});
OF.F(null,new $APP.H(null,2,5,$APP.I,[hT,hT],null),function(a,b){return dTa(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[hT,FG],null),function(a,b){return dTa(a,yG.j(b))});OF.F(null,new $APP.H(null,2,5,$APP.I,[FG,hT],null),function(a,b){return dTa(yG.j(a),b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[hT,hT],null),function(a,b){return fTa(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[hT,FG],null),function(a,b){return fTa(a,yG.j(b))});
BG.F(null,new $APP.H(null,2,5,$APP.I,[FG,hT],null),function(a,b){return fTa(yG.j(a),b)});QF.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){if($APP.k(iG(a)))var b=cTa;else if($APP.k(oG.j(a)))b=eTa;else{b=a.ha;a=a.ia;var c=mG.A(kG.A(b,b),kG.A(a,a));b=fG(SF.A(b,c),SF.A(RF.j(a),c))}return b});RF.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return fG(RF.j(a.ha),RF.j(a.ia))});tI.F(null,new $APP.H(null,2,5,$APP.I,[hT,hT],null),function(a,b){return hTa(a,b)});
tI.F(null,new $APP.H(null,2,5,$APP.I,[hT,FG],null),function(a,b){return hTa(a,yG.j(b))});tI.F(null,new $APP.H(null,2,5,$APP.I,[FG,hT],null),function(a,b){return hTa(yG.j(a),b)});nG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return kG.A(a,a)});qZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return kG.C(a,a,$APP.y([a]))});jG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return WSa(a)});
qG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=qG.j(a.ha);a=a.ia;return fG(kG.A(b,hO.j(a)),kG.A(b,iO.j(a)))});rG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return jTa(a)});lG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return iTa(a)});iO.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;return fG(kG.A(iO.j(b),vH.j(a)),kG.A(hO.j(b),xH.j(a)))});
hO.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;return fG(kG.A(hO.j(b),vH.j(a)),kG.C(-1,iO.j(b),$APP.y([xH.j(a)])))});vZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=kG.A(2,a.ha);a=kG.A(2,a.ia);var c=mG.A(hO.j(b),vH.j(a));return fG(SF.A(iO.j(b),c),SF.A(xH.j(a),c))});
yZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;var c=SF.A(mG.A(vH.j(kG.A(2,a)),hO.j(kG.A(2,b))),2);return fG(SF.A(kG.A(hO.j(b),vH.j(a)),c),SF.A(kG.A(iO.j(b),xH.j(a)),c))});xZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;var c=SF.A(TF.A(vH.j(kG.A(2,a)),hO.j(kG.A(2,b))),2);return fG(SF.A(kG.A(iO.j(b),vH.j(a)),c),SF.A(kG.C(-1,hO.j(b),$APP.y([xH.j(a)])),c))});
wZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=kG.A(2,a.ha);a=kG.A(2,a.ia);var c=TF.A(hO.j(b),vH.j(a));return fG(SF.A(RF.j(iO.j(b)),c),SF.A(xH.j(a),c))});zZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return kTa(a)});mO.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return mTa(a)});tG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return nTa(a)});
CZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){if($APP.k(iG(a)))var b=fG(lTa,Infinity);else{b=a.ha;a=a.ia;var c=mG.A(nG.j(b),nG.j(a));b=kTa(fG(SF.A(b,c),SF.A(RF.j(a),c)))}return b});BZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){if($APP.k(iG(a)))var b=fG(0,Infinity);else{b=a.ha;a=a.ia;var c=mG.A(nG.j(b),nG.j(a));b=mTa(fG(SF.A(b,c),SF.A(RF.j(a),c)))}return b});
AZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;if($APP.k(MF.j(a)))b=fG(tG.A(1,b),0);else{var c=mG.A(nG.j(b),nG.j(a));b=$APP.k(MF.j(c))?nTa(fG($APP.k(MF.j(b))?0:SF.A(b,0),$APP.k(MF.j(a))?0:SF.A(RF.j(a),0))):nTa(fG(SF.A(b,c),SF.A(RF.j(a),c)))}return b});IZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return oTa(a)});HZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return pTa(a)});JZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){return qTa(a)});
LZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){if($APP.k(iG(a)))var b=cTa;else{b=a.ha;a=a.ia;var c=mG.A(nG.j(b),nG.j(a));b=pTa(fG(SF.A(b,c),SF.A(RF.j(a),c)))}return b});MZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;if($APP.k(MF.j(a)))b=$APP.k(MF.j(b))?fG(Infinity,0):fG(rG.j(mG.A(b,lG.j(mG.A(nG.j(b),1)))),0);else{var c=mG.A(nG.j(b),nG.j(a));b=oTa(fG(SF.A(b,c),SF.A(RF.j(a),c)))}return b});
KZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){if($APP.k(iG(a)))var b=fG(0,lTa);else{b=a.ha;a=a.ia;var c=mG.A(nG.j(b),nG.j(a));b=qTa(fG(SF.A(b,c),SF.A(RF.j(a),c)))}return b});rZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=Math.pow(10,0);return fG(Math.floor(a.ha*b)/b,Math.floor(a.ia*b)/b)});tZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=Math.pow(10,0);return fG(Math.ceil(a.ha*b)/b,Math.ceil(a.ia*b)/b)});
vH.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;return fG(kG.A(vH.j(b),hO.j(a)),kG.A(xH.j(b),iO.j(a)))});xH.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;return fG(kG.A(xH.j(b),hO.j(a)),kG.A(vH.j(b),iO.j(a)))});DZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=kG.A(2,a.ha);a=kG.A(2,a.ia);var c=mG.A(vH.j(b),hO.j(a));return fG(SF.A(xH.j(b),c),SF.A(iO.j(a),c))});
EZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;var c=mG.A(hO.j(kG.A(2,a)),vH.j(kG.A(2,b)));return fG(SF.A(kG.C(2,vH.j(b),$APP.y([hO.j(a)])),c),SF.A(kG.C(-2,xH.j(b),$APP.y([iO.j(a)])),c))});GZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=a.ha;a=a.ia;var c=TF.A(hO.j(kG.A(2,a)),vH.j(kG.A(2,b)));return fG(SF.A(kG.C(-2,xH.j(b),$APP.y([hO.j(a)])),c),SF.A(kG.C(2,vH.j(b),$APP.y([iO.j(a)])),c))});
FZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=kG.A(2,a.ha);a=kG.A(2,a.ia);var c=TF.A(vH.j(b),hO.j(a));return fG(SF.A(xH.j(b),c),SF.A(RF.j(iO.j(a)),c))});sZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=sZ.j(a.ha);a=sZ.j(a.ia);return $APP.k(MF.j(a))?b:yG.A(b,a)});uZ.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=uZ.j(a.ha);a=uZ.j(a.ia);return $APP.k(MF.j(a))?b:yG.A(b,a)});
sG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=MF.j(a.ia);return $APP.k(b)?sG.j(a.ha):b});oG.F(null,new $APP.H(null,1,5,$APP.I,[hT],null),function(a){var b=oG.j(a.ha);return $APP.k(b)?b:oG.j(a.ia)});yM.F(null,$APP.yj,function(a,b){return wTa(a,b)});$APP.ju.A(uF,FG);yTa._=!0;DG._=function(a){return a};EG._=function(){return 1};uF.prototype.Lg=function(){return this.n};uF.prototype.Kg=function(){return this.d};var YZ=function YZ(a){switch(arguments.length){case 1:return YZ.j(arguments[0]);case 2:return YZ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
YZ.j=function(a){if(!(EF(a)||a instanceof uF))if(FF(a)){var b=$APP.Lg(Fec,a.toString());if($APP.k(b)){$APP.x.B(b,0,null);a=$APP.x.B(b,1,null);$APP.x.B(b,2,null);var c=$APP.x.B(b,3,null);$APP.x.B(b,4,null);b=$APP.x.B(b,5,null);var d=parseInt($APP.k(b)?b:"0")-$APP.Tc($APP.k(c)?c:"");b=0>d;a=BigInt([$APP.m.j(a),$APP.m.j(c)].join(""));c=BigInt(Eec**BigInt(Math.abs(d)));a=b?yF(a,c):new uF(a*c,zF)}else throw Error(["Cannot convert ",$APP.m.j(a)," to ratio."].join(""));}else a=AD(["Cannot rationalize ",
$APP.m.j(a)].join(""));return a};YZ.A=function(a,b){a=BigInt(a);b=BigInt(b);0===b&&qSa();b=yF(a,b);return AF(b)};YZ.G=2;var bnc=/(-?\d+)\/(\d+)/;VF.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(){return!0});cG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){var b=DG(a);a=EG(a);return $APP.k(uG.j(a))?b:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sj,null,1,null),new $APP.D(null,cG.j(b),null,1,null),$APP.y([new $APP.D(null,cG.j(a),null,1,null)]))))});$APP.e=uF.prototype;
$APP.e.bi=$APP.xc;$APP.e.nd=function(){return!0};$APP.e.Y=function(a,b){if(b instanceof uF){a=this.d;var c=b.d;return this.n===b.n&&a===c}a=uG.j(this.d);return $APP.k(a)?hG.A(this.n,b):a};$APP.e.Oa=$APP.xc;$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#emmy/ratio "',this.n,"/",this.d,'"']))};hG.F(null,new $APP.H(null,2,5,$APP.I,[FG,uF],null),function(a,b){return $APP.Uc.A(b,a)});gH.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF(tSa(a,b))});
AG.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF(uSa(a,b))});OF.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF(vSa(a,b))});BG.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF(yF(a.n*b.d,a.d*b.n))});kM.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF(yF(a.n*b.d,a.d*b.n))});MF.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return vF===a.n});
uG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return a.n===a.d});kZ.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return a.n===a.d});vG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(){return 0});PF.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(){return 1});lZ.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(){return 1});RF.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return AF(new uF(xF*a.n,a.d))});
sG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return 0>a.n});oG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(){return!1});QF.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){var b=a.n;a=a.d;var c=0>b;vF===b&&qSa();return AF(c?new uF(xF*a,xF*b):new uF(a,b))});nG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return AF(vSa(a,a))});qZ.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return AF(ySa(a,3))});
jG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return AF(sSa(a))});zG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return AF(sSa(a))});tI.F(null,new $APP.H(null,2,5,$APP.I,[uF,GG],null),function(a,b){return AF(ySa(a,b))});tI.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF($APP.k(uG.j(b.d))?ySa(a,b.n):tI.A(wF(a),wF(b)))});lG.F(null,new $APP.H(null,1,5,$APP.I,[uF],null),function(a){return 0>a?lG.j(wF(a)):BG.A(lG.j(DG(a)),lG.j(EG(a)))});
sI.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF(zSa(a,b))});CG.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF(ASa(a,b))});nI.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){return AF(ASa(tSa(ASa(a,b),b),b))});yM.F(null,new $APP.H(null,2,5,$APP.I,[uF,uF],null),function(a,b){var c=a.d,d=b.d;a=sSa(yF(rSa(a.n,b.n)*rSa(c,d),c*d));return AF(a)});ATa(kM);ATa(yM);zTa(tI);
for(var cnc=$APP.r(new $APP.H(null,9,5,$APP.I,[gH,OF,AG,yM,qM,nI,CG,sI,BG],null)),dnc=null,enc=0,fnc=0;;)if(fnc<enc){var gnc=dnc.aa(null,fnc);ATa(gnc);zTa(gnc);fnc+=1}else{var hnc=$APP.r(cnc);if(hnc){var ZZ=hnc;if($APP.pd(ZZ)){var inc=$APP.lc(ZZ),jnc=$APP.mc(ZZ),knc=inc,lnc=$APP.Tc(inc);cnc=jnc;dnc=knc;enc=lnc}else{var mnc=$APP.u(ZZ);ATa(mnc);zTa(mnc);cnc=$APP.w(ZZ);dnc=null;enc=0}fnc=0}else break};var $Z=Boolean;MF.F(null,new $APP.H(null,1,5,$APP.I,[$Z],null),function(a){return $APP.eb(a)});uG.F(null,new $APP.H(null,1,5,$APP.I,[$Z],null),function(a){return a});kZ.F(null,new $APP.H(null,1,5,$APP.I,[$Z],null),function(a){return a});vG.F(null,new $APP.H(null,1,5,$APP.I,[$Z],null),function(){return!1});PF.F(null,new $APP.H(null,1,5,$APP.I,[$Z],null),function(){return!0});lZ.F(null,new $APP.H(null,1,5,$APP.I,[$Z],null),function(){return!0});vG.F(null,new $APP.H(null,1,5,$APP.I,[ET],null),function(){return 0});
PF.F(null,new $APP.H(null,1,5,$APP.I,[ET],null),function(){return 1});lZ.F(null,new $APP.H(null,1,5,$APP.I,[ET],null),function(){return 1});MF.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 0===a});uG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 1===a});kZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 1===a});vG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(){return 0});PF.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(){return 1});
lZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(){return 1});VF.F(null,new $APP.H(null,1,5,$APP.I,[GG],null),function(){return!0});VF.F(null,new $APP.H(null,1,5,$APP.I,[ET],null),function(){return!1});cG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return a});gH.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return a+b});OF.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return a*b});
AG.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return a-b});RF.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return-a});sG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 0>a});tI.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return 0>a&&0!==uZ.j(b)?qG.j(OF.A(b,rG.j(a))):WY.A?WY.A(a,b):WY.call(null,a,b)});jG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return mQ.j?mQ.j(a):mQ.call(null,a)});
zG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return mQ.j?mQ.j(a):mQ.call(null,a)});BG.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return a/b});QF.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 1/a});rZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return $APP.Nd(Math.floor(a))});tZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return $APP.Nd(Math.ceil(a))});sZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return Math.trunc(a)});
oG.F(null,new $APP.H(null,1,5,$APP.I,[GG],null),function(){return!1});oG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return $APP.zd(a)});zH.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return a});CH.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(){return 0});RZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 0>a?Math.PI:vG.j(a)});sL.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return a});
tR.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return $APP.k(MF.j(a))?1:$APP.k(oG.j(a))?0:SF.A(iO.j(a),a)});iO.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return $APP.k(MF.j(a))?0:Math.sin(a)});hO.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return $APP.k(MF.j(a))?1:Math.cos(a)});vZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return Math.tan(a)});vH.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return Math.cosh(a)});
xH.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return Math.sinh(a)});DZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return Math.tanh(a)});tG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return Math.atan(a)});tG.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return Math.atan2(a,b)});zZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 1<jG.j(a)?zZ.j(yG.j(a)):Math.asin(a)});
mO.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 1<jG.j(a)?mO.j(yG.j(a)):Math.acos(a)});HZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 1<=a?Math.acosh(a):HZ.j(yG.j(a))});IZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 1<=a?Math.asinh(a):IZ.j(yG.j(a))});JZ.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 1<=jG.j(a)?JZ.j(yG.j(a)):Math.atanh(a)});
lG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 0>a?lG.j(yG.j(a)):uec.j?uec.j(a):uec.call(null,a)});rG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 0>a?rG.j(yG.j(a)):Math.log(a)});pZ.F(null,new $APP.H(null,1,5,$APP.I,[Number],null),function(a){return 0>a?pZ.j(yG.j(a)):Math.log10(a)});oZ.F(null,new $APP.H(null,1,5,$APP.I,[Number],null),function(a){return 0>a?oZ.j(yG.j(a)):Math.log2(a)});
qG.F(null,new $APP.H(null,1,5,$APP.I,[FG],null),function(a){return 0===a?1:Math.exp(a)});kM.F(null,new $APP.H(null,2,5,$APP.I,[HF,FG],null),function(a,b){var c=BTa(a,b);return $APP.k(c)?c:yD(["exact-divide not allowed between: ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))});sI.F(null,new $APP.H(null,2,5,$APP.I,[HF,FG],null),function(a,b){var c=BTa(a,b);return $APP.k(c)?c:yD(["quotient not allowed between: ",$APP.m.j(a),", ",$APP.m.j(b)].join(""))});
kM.F(null,new $APP.H(null,2,5,$APP.I,[GG,GG],null),function(a,b){return sI.A(a,b)});sZ.F(null,new $APP.H(null,1,5,$APP.I,[GG],null),function(a){return a});uZ.F(null,new $APP.H(null,1,5,$APP.I,[GG],null),function(){return 0});rZ.F(null,new $APP.H(null,1,5,$APP.I,[GG],null),function(a){return a});tZ.F(null,new $APP.H(null,1,5,$APP.I,[GG],null),function(a){return a});sI.F(null,new $APP.H(null,2,5,$APP.I,[IY,IY],null),function(a,b){return $APP.Pd(a,b)});
CG.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return $APP.Qd(a,b)});nI.F(null,new $APP.H(null,2,5,$APP.I,[FG,FG],null),function(a,b){return $APP.Od(a,b)});yM.F(null,new $APP.H(null,2,5,$APP.I,[IY,IY],null),function(a,b){a=0>a?-a:a;for(b=0>b?-b:b;;){if(0===b)return a;var c=$APP.Qd(a,b);a=b;b=c}});yM.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return CTa(a,b)});yM.F(null,new $APP.H(null,2,5,$APP.I,[IY,BigInt],null),function(a,b){return CTa(BigInt(a),b)});
yM.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,IY],null),function(a,b){return CTa(a,BigInt(b))});tI.F(null,new $APP.H(null,2,5,$APP.I,[IY,IY],null),function(a,b){if(0>b){var c=QF.j;b=-b;a=WY.A?WY.A(a,b):WY.call(null,a,b);c=c.call(QF,a)}else c=WY.A?WY.A(a,b):WY.call(null,a,b);return c});BG.F(null,new $APP.H(null,2,5,$APP.I,[GG,GG],null),function(a,b){var c=CG.A(a,b);return $APP.k(MF.j(c))?sI.A(a,b):YZ.A(a,b)});
QF.F(null,new $APP.H(null,1,5,$APP.I,[GG],null),function(a){return $APP.k(uG.j(a))?a:YZ.A(1,a)});var a_=BigInt(0),b_=BigInt(1);gH.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a+b});OF.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a*b});nI.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return AG.A(a,OF.A(b,rZ.j(BG.A(a,b))))});AG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a-b});
RF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return-a});tI.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return $APP.k(sG.j(b))?QF.j(a**-b):a**b});MF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return a_==a});uG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return b_==a});kZ.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return b_==a});vG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return a_});
PF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return b_});lZ.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return b_});VF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return!0});jG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return 0>a?-a:a});sI.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a/b});CG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return a%b});
zG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return 0>a?-a:a});BG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return $APP.k(MF.j(a%b))?a/b:YZ.A(a,b)});
for(var c_=$APP.r(new $APP.H(null,8,5,$APP.I,[gH,OF,AG,BG,tI,nI,CG,sI],null)),d_=null,e_=0,f_=0;;)if(f_<e_){var g_=d_.aa(null,f_);g_.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,GG],null),function(a,b,c,d,g){return function(l,n){n=BigInt(n);return g.A?g.A(l,n):g.call(null,l,n)}}(c_,d_,e_,f_,g_,a_,b_));g_.F(null,new $APP.H(null,2,5,$APP.I,[GG,BigInt],null),function(a,b,c,d,g){return function(l,n){l=BigInt(l);return g.A?g.A(l,n):g.call(null,l,n)}}(c_,d_,e_,f_,g_,a_,b_));g_.F(null,new $APP.H(null,2,5,$APP.I,
[BigInt,ET],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(c_,d_,e_,f_,g_,a_,b_));g_.F(null,new $APP.H(null,2,5,$APP.I,[ET,BigInt],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(c_,d_,e_,f_,g_,a_,b_));f_+=1}else{var h_=$APP.r(c_);if(h_){var i_=h_;if($APP.pd(i_)){var nnc=$APP.lc(i_),onc=$APP.mc(i_),pnc=nnc,qnc=$APP.Tc(nnc);c_=onc;d_=pnc;e_=qnc}else{var j_=$APP.u(i_);j_.F(null,new $APP.H(null,2,5,$APP.I,
[BigInt,GG],null),function(a,b,c,d,g){return function(l,n){n=BigInt(n);return g.A?g.A(l,n):g.call(null,l,n)}}(c_,d_,e_,f_,j_,i_,h_,a_,b_));j_.F(null,new $APP.H(null,2,5,$APP.I,[GG,BigInt],null),function(a,b,c,d,g){return function(l,n){l=BigInt(l);return g.A?g.A(l,n):g.call(null,l,n)}}(c_,d_,e_,f_,j_,i_,h_,a_,b_));j_.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,ET],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(c_,d_,e_,f_,j_,i_,h_,a_,b_));j_.F(null,
new $APP.H(null,2,5,$APP.I,[ET,BigInt],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(c_,d_,e_,f_,j_,i_,h_,a_,b_));c_=$APP.w(i_);d_=null;e_=0}f_=0}else break}
for(var k_=$APP.r(new $APP.H(null,20,5,$APP.I,[hO,iO,vZ,zZ,mO,tG,vH,xH,DZ,IZ,HZ,HZ,wZ,yZ,xZ,EZ,GZ,rG,qG,lG],null)),l_=null,m_=0,n_=0;;)if(n_<m_){var rnc=l_.aa(null,n_);rnc.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a,b,c,d,g){return function(l){l=Number(l);return g.j?g.j(l):g.call(null,l)}}(k_,l_,m_,n_,rnc,a_,b_));n_+=1}else{var snc=$APP.r(k_);if(snc){var o_=snc;if($APP.pd(o_)){var tnc=$APP.lc(o_),unc=$APP.mc(o_),vnc=tnc,wnc=$APP.Tc(tnc);k_=unc;l_=vnc;m_=wnc}else{var xnc=$APP.u(o_);
xnc.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a,b,c,d,g){return function(l){l=Number(l);return g.j?g.j(l):g.call(null,l)}}(k_,l_,m_,n_,xnc,o_,snc,a_,b_));k_=$APP.w(o_);l_=null;m_=0}n_=0}else break}tG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,FG],null),function(a,b){return tG.A(Number(a),b)});tG.F(null,new $APP.H(null,2,5,$APP.I,[FG,BigInt],null),function(a,b){return tG.A(a,Number(b))});tG.F(null,new $APP.H(null,2,5,$APP.I,[BigInt,BigInt],null),function(a,b){return tG.A(Number(a),Number(b))});
VF.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(){return!0});cG.F(null,new $APP.H(null,1,5,$APP.I,[BigInt],null),function(a){return jG.j(a)<Number.MAX_SAFE_INTEGER?Number(a):a});MF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return a.Rb()});uG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return $APP.Uc.A($APP.Ha,a)});kZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return $APP.Uc.A($APP.Ha,a)});
vG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(){return $APP.Aa});PF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(){return $APP.Ha});lZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(){return $APP.Ha});VF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(){return!0});cG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return a});MF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return a.Rb()});
uG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return $APP.Uc.A($APP.Hs,a)});kZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return $APP.Uc.A($APP.Hs,a)});vG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(){return $APP.va});PF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(){return $APP.Hs});lZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(){return $APP.Hs});VF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(){return!0});
cG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return a});gH.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.add(b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.multiply(b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.Wc(b)});RF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return a.Za()});
jG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return $APP.k(a.nb())?a.Za():a});CG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.Xe(b)});zG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.qa],null),function(a){return $APP.k(a.nb())?a.Za():a});tI.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return $APP.k(b.nb())?QF.j(DTa(a,b.Za())):DTa(a,b)});
for(var p_=$APP.r(new $APP.H(null,8,5,$APP.I,[gH,OF,AG,yM,qM,tI,CG,sI],null)),q_=null,r_=0,s_=0;;)if(s_<r_){var t_=q_.aa(null,s_);t_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,IY],null),function(a,b,c,d,g){return function(l,n){n=$APP.xa(n);return g.A?g.A(l,n):g.call(null,l,n)}}(p_,q_,r_,s_,t_,a_,b_));t_.F(null,new $APP.H(null,2,5,$APP.I,[IY,$APP.qa],null),function(a,b,c,d,g){return function(l,n){l=$APP.xa(l);return g.A?g.A(l,n):g.call(null,l,n)}}(p_,q_,r_,s_,t_,a_,b_));t_.F(null,new $APP.H(null,2,
5,$APP.I,[$APP.qa,ET],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(p_,q_,r_,s_,t_,a_,b_));t_.F(null,new $APP.H(null,2,5,$APP.I,[ET,$APP.qa],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(p_,q_,r_,s_,t_,a_,b_));s_+=1}else{var u_=$APP.r(p_);if(u_){var v_=u_;if($APP.pd(v_)){var ync=$APP.lc(v_),znc=$APP.mc(v_),Anc=ync,Bnc=$APP.Tc(ync);p_=znc;q_=Anc;r_=Bnc}else{var w_=$APP.u(v_);w_.F(null,new $APP.H(null,
2,5,$APP.I,[$APP.qa,IY],null),function(a,b,c,d,g){return function(l,n){n=$APP.xa(n);return g.A?g.A(l,n):g.call(null,l,n)}}(p_,q_,r_,s_,w_,v_,u_,a_,b_));w_.F(null,new $APP.H(null,2,5,$APP.I,[IY,$APP.qa],null),function(a,b,c,d,g){return function(l,n){l=$APP.xa(l);return g.A?g.A(l,n):g.call(null,l,n)}}(p_,q_,r_,s_,w_,v_,u_,a_,b_));w_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,ET],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(p_,q_,r_,s_,w_,v_,u_,a_,
b_));w_.F(null,new $APP.H(null,2,5,$APP.I,[ET,$APP.qa],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(p_,q_,r_,s_,w_,v_,u_,a_,b_));p_=$APP.w(v_);q_=null;r_=0}s_=0}else break}gH.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.add(b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.multiply(b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.Wc(b)});
RF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return a.Za()});jG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return $APP.k(a.nb())?a.Za():a});CG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.Xe(b)});zG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.za],null),function(a){return $APP.k(a.nb())?a.Za():a});tI.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return $APP.k(b.nb())?QF.j(ETa(a,b.Za())):ETa(a,b)});
for(var x_=$APP.r(new $APP.H(null,8,5,$APP.I,[gH,OF,AG,yM,qM,tI,CG,sI],null)),y_=null,z_=0,A_=0;;)if(A_<z_){var B_=y_.aa(null,A_);B_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,IY],null),function(a,b,c,d,g){return function(l,n){n=$APP.Ca(n);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,B_,a_,b_));B_.F(null,new $APP.H(null,2,5,$APP.I,[IY,$APP.za],null),function(a,b,c,d,g){return function(l,n){l=$APP.Ca(l);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,B_,a_,b_));B_.F(null,new $APP.H(null,2,
5,$APP.I,[$APP.za,ET],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,B_,a_,b_));B_.F(null,new $APP.H(null,2,5,$APP.I,[ET,$APP.za],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,B_,a_,b_));B_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.qa],null),function(a,b,c,d,g){return function(l,n){n=$APP.Ca(n);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,B_,a_,b_));B_.F(null,
new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.za],null),function(a,b,c,d,g){return function(l,n){l=$APP.Ca(l);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,B_,a_,b_));A_+=1}else{var C_=$APP.r(x_);if(C_){var D_=C_;if($APP.pd(D_)){var Cnc=$APP.lc(D_),Dnc=$APP.mc(D_),Enc=Cnc,Fnc=$APP.Tc(Cnc);x_=Dnc;y_=Enc;z_=Fnc}else{var E_=$APP.u(D_);E_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,IY],null),function(a,b,c,d,g){return function(l,n){n=$APP.Ca(n);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,E_,D_,
C_,a_,b_));E_.F(null,new $APP.H(null,2,5,$APP.I,[IY,$APP.za],null),function(a,b,c,d,g){return function(l,n){l=$APP.Ca(l);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,E_,D_,C_,a_,b_));E_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,ET],null),function(a,b,c,d,g){return function(l,n){l=Number(l);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,E_,D_,C_,a_,b_));E_.F(null,new $APP.H(null,2,5,$APP.I,[ET,$APP.za],null),function(a,b,c,d,g){return function(l,n){n=Number(n);return g.A?g.A(l,n):g.call(null,
l,n)}}(x_,y_,z_,A_,E_,D_,C_,a_,b_));E_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.qa],null),function(a,b,c,d,g){return function(l,n){n=$APP.Ca(n);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,E_,D_,C_,a_,b_));E_.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.za],null),function(a,b,c,d,g){return function(l,n){l=$APP.Ca(l);return g.A?g.A(l,n):g.call(null,l,n)}}(x_,y_,z_,A_,E_,D_,C_,a_,b_));x_=$APP.w(D_);y_=null;z_=0}A_=0}else break}
sI.F(null,new $APP.H(null,2,5,$APP.I,[$APP.qa,$APP.qa],null),function(a,b){return a.div(b)});sI.F(null,new $APP.H(null,2,5,$APP.I,[$APP.za,$APP.za],null),function(a,b){return a.divide(b)});var F_=function F_(a){switch(arguments.length){case 0:return F_.J();case 1:return F_.j(arguments[0]);case 2:return F_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};F_.J=function(){return 0};F_.j=function(a){return a};F_.A=function(a,b){return mG.A(a,b)};F_.G=2;
var G_=function G_(a){switch(arguments.length){case 1:return G_.j(arguments[0]);case 2:return G_.A(arguments[0],arguments[1]);case 3:return G_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};G_.j=function(a){return G_.B(a,a,a)};G_.A=function(a,b){return G_.B(a,a,b)};
G_.B=function(a,b,c){return function(){function d(n,p,v){p=$APP.Jj.A(p,v);return $APP.Xs.B($APP.Vg.j(n),b,p)}function g(n){n=$APP.Id.B(b,a.J?a.J():a.call(null),n);return c.j?c.j(n):c.call(null,n)}var l=null;l=function(n,p,v){switch(arguments.length){case 1:return g.call(this,n);case 3:return d.call(this,n,p,v)}throw Error("Invalid arity: "+arguments.length);};l.j=g;l.B=d;return l}()};G_.G=3;
var H_=function H_(a){switch(arguments.length){case 0:return H_.J();case 1:return H_.j(arguments[0]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};H_.J=function(){return H_.j(function(){return!0})};
H_.j=function(a){return function(){function b(d,g){return $APP.k(a.j?a.j(g):a.call(null,g))?d+1:d}var c=null;c=function(d,g){switch(arguments.length){case 0:return 0;case 1:return d;case 2:return b.call(this,d,g)}throw Error("Invalid arity: "+arguments.length);};c.J=function(){return 0};c.j=function(d){return d};c.A=b;return c}()};H_.G=1;
var I_=function I_(a){switch(arguments.length){case 0:return I_.J();case 1:return I_.j(arguments[0]);case 2:return I_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};I_.J=function(){return null};I_.j=function(a){return a};I_.A=function(a,b){return $APP.k(a)?a<b?a:b:b};I_.G=2;
var J_=function J_(a){switch(arguments.length){case 0:return J_.J();case 1:return J_.j(arguments[0]);case 2:return J_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};J_.J=function(){return null};J_.j=function(a){return a};J_.A=function(a,b){return $APP.k(a)?a>b?a:b:b};J_.G=2;
var K_=function K_(a){switch(arguments.length){case 0:return K_.J();case 1:return K_.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return K_.C(arguments[0],c)}};K_.J=function(){return FTa($APP.sf)};K_.j=function(a){return a};
K_.C=function(a,b){var c=$APP.Yd(a,b);return function(){function d(p,v){return $APP.Hl.B(function(t,A){return t.A?t.A(A,v):t.call(null,A,v)},c,p)}function g(p){return $APP.Hl.B(function(v,t){return v.j?v.j(t):v.call(null,t)},c,p)}function l(){return $APP.Hl.A(function(p){return p.J?p.J():p.call(null)},c)}var n=null;n=function(p,v){switch(arguments.length){case 0:return l.call(this);case 1:return g.call(this,p);case 2:return d.call(this,p,v)}throw Error("Invalid arity: "+arguments.length);};n.J=l;
n.j=g;n.A=d;return n}()};K_.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};K_.G=1;var GI=function GI(a){switch(arguments.length){case 1:return GI.j(arguments[0]);case 2:return GI.A(arguments[0],arguments[1]);case 3:return GI.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};GI.j=function(a){return GI.B(a,a,a)};GI.A=function(a,b){return GI.B(a,a,b)};
GI.B=function(a,b,c){return function(){function d(n,p,v){return l.j($APP.Vg.A(n,$APP.Jj.A(p,v)))}function g(n){return $APP.Vg.A(c,$APP.Fc($APP.Ut.B(b,a.J?a.J():a.call(null),n)))}var l=null;l=function(n,p,v){switch(arguments.length){case 1:return g.call(this,n);case 3:return d.call(this,n,p,v)}throw Error("Invalid arity: "+arguments.length);};l.j=g;l.B=d;return l}()};GI.G=3;
var L_=function L_(a){switch(arguments.length){case 0:return L_.J();case 1:return L_.j(arguments[0]);case 2:return L_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};L_.J=function(){return new $APP.H(null,2,5,$APP.I,[0,0],null)};L_.j=function(a){var b=$APP.x.B(a,0,null);$APP.x.B(a,1,null);return b};L_.A=function(a,b){var c=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);b-=a;a=c+b;return new $APP.H(null,2,5,$APP.I,[a,a-c-b],null)};L_.G=2;
var FI=function FI(a){switch(arguments.length){case 0:return FI.J();case 1:return FI.j(arguments[0]);case 2:return FI.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};FI.J=function(){return new $APP.H(null,2,5,$APP.I,[0,0],null)};FI.j=function(a){return $APP.Id.A($APP.yr,a)};FI.A=function(a,b){var c=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);var d=c+b;return new $APP.H(null,2,5,$APP.I,[d,a+(Math.abs(c)>=Math.abs(b)?c-d+b:b-d+c)],null)};
FI.G=2;var M_=function M_(a){switch(arguments.length){case 0:return M_.J();case 1:return M_.j(arguments[0]);case 2:return M_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};M_.J=function(){return new $APP.H(null,3,5,$APP.I,[0,0,0],null)};M_.j=function(a){return $APP.Id.A($APP.yr,a)};
M_.A=function(a,b){var c=$APP.x.B(a,0,null),d=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);var g=c+b;b=Math.abs(c)>=Math.abs(b)?c-g+b:b-g+c;c=d+b;return new $APP.H(null,3,5,$APP.I,[g,c,a+(Math.abs(d)>=Math.abs(b)?d-c+b:b-c+d)],null)};M_.G=2;var jL=G_.j(mG),HQ=function HQ(a){switch(arguments.length){case 1:return HQ.j(arguments[0]);case 3:return HQ.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};HQ.j=function(a){return FI.call(null,$APP.Id.B(FI,FI.call(null),a))};HQ.B=function(a,b,c){b=$APP.Jj.A(b,c);return $APP.Xs.B($APP.Vg.j(a),FI,b)};HQ.G=3;
var DI=function DI(a){switch(arguments.length){case 1:return DI.j(arguments[0]);case 3:return DI.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};DI.j=function(a){return $APP.Vg.A(FI,$APP.Fc($APP.Ut.B(FI,FI.call(null),a)))};DI.B=function(a,b,c){return DI.j($APP.Vg.A(a,$APP.Jj.A(b,c)))};DI.G=3;
var N_=function N_(a){switch(arguments.length){case 1:return N_.j(arguments[0]);case 3:return N_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};N_.j=function(a){return function d(c){var g=$APP.Tc(c);if(128>=g)return $APP.Id.A($APP.yr,c);var l=g>>1;g=$APP.pi.B(c,0,l);c=$APP.pi.A(c,l);return d(g)+d(c)}($APP.od(a)?a:$APP.Lf.A($APP.sf,a))};N_.B=function(a,b,c){return N_.j($APP.Hl.A(a,$APP.Jj.A(b,c)))};N_.G=3;
var O_=function O_(a){switch(arguments.length){case 2:return O_.A(arguments[0],arguments[1]);case 3:return O_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};O_.A=function(a,b){return O_.B(a,b,null)};
O_.B=function(a,b,c){var d=PTa(a,c);return function(){function g(p,v){return a.A?a.A(p,v):a.call(null,p,v)}var l=null,n=function(){function p(t,A,B){var G=null;if(2<arguments.length){G=0;for(var J=Array(arguments.length-2);G<J.length;)J[G]=arguments[G+2],++G;G=new $APP.Bc(J,0,null)}return v.call(this,t,A,G)}function v(t,A,B){return $APP.Id.B(d,t,$APP.Yd(A,B))}p.G=2;p.M=function(t){var A=$APP.u(t);t=$APP.w(t);var B=$APP.u(t);t=$APP.Fc(t);return v(A,B,t)};p.C=v;return p}();l=function(p,v,t){switch(arguments.length){case 0:return b;
case 1:return p;case 2:return g.call(this,p,v);default:var A=null;if(2<arguments.length){A=0;for(var B=Array(arguments.length-2);A<B.length;)B[A]=arguments[A+2],++A;A=new $APP.Bc(B,0,null)}return n.C(p,v,A)}throw Error("Invalid arity: "+arguments.length);};l.G=2;l.M=n.M;l.J=function(){return b};l.j=function(p){return p};l.A=g;l.C=n.C;return l}()};O_.G=3;
var P_=function P_(a){switch(arguments.length){case 4:return P_.K(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return P_.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};P_.K=function(a,b,c,d){return P_.S(a,b,c,d,null)};
P_.S=function(a,b,c,d,g){var l=PTa(b,g);return function(){function n(A,B){return a.A?a.A(A,B):a.call(null,A,B)}function p(A){return c.j?c.j(A):c.call(null,A)}var v=null,t=function(){function A(G,J,O){var R=null;if(2<arguments.length){R=0;for(var W=Array(arguments.length-2);R<W.length;)W[R]=arguments[R+2],++R;R=new $APP.Bc(W,0,null)}return B.call(this,G,J,R)}function B(G,J,O){J=$APP.Id.B(l,J,O);return a.A?a.A(G,J):a.call(null,G,J)}A.G=2;A.M=function(G){var J=$APP.u(G);G=$APP.w(G);var O=$APP.u(G);G=
$APP.Fc(G);return B(J,O,G)};A.C=B;return A}();v=function(A,B,G){switch(arguments.length){case 0:return d;case 1:return p.call(this,A);case 2:return n.call(this,A,B);default:var J=null;if(2<arguments.length){J=0;for(var O=Array(arguments.length-2);J<O.length;)O[J]=arguments[J+2],++J;J=new $APP.Bc(O,0,null)}return t.C(A,B,J)}throw Error("Invalid arity: "+arguments.length);};v.G=2;v.M=t.M;v.J=function(){return d};v.j=p;v.A=n;v.C=t.C;return v}()};P_.G=5;/*

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
JG.ld={};JG.ld.s=function(a,b,c){return isNaN(c)||""==c||a.length>=Number(c)?a:a=-1<b.indexOf("-",0)?a+(0,$APP.Js)(" ",Number(c)-a.length):(0,$APP.Js)(" ",Number(c)-a.length)+a};
JG.ld.f=function(a,b,c,d,g){d=a.toString();isNaN(g)||""==g||(d=parseFloat(a).toFixed(g));let l;l=0>Number(a)?"-":0<=b.indexOf("+")?"+":0<=b.indexOf(" ")?" ":"";0<=Number(a)&&(d=l+d);if(isNaN(c)||d.length>=Number(c))return d;d=isNaN(g)?Math.abs(Number(a)).toString():Math.abs(Number(a)).toFixed(g);a=Number(c)-d.length-l.length;0<=b.indexOf("-",0)?d=l+d+(0,$APP.Js)(" ",a):(b=0<=b.indexOf("0",0)?"0":" ",d=l+(0,$APP.Js)(b,a)+d);return d};
JG.ld.d=function(a,b,c,d,g,l,n,p){return JG.ld.f(parseInt(a,10),b,c,d,0,l,n,p)};JG.ld.i=JG.ld.d;JG.ld.u=JG.ld.d;var Gnc=new $APP.H(null,3,5,$APP.I,[3,43,0],null);$APP.Uc.A("default","nodejs");var Hnc="undefined"!==typeof window?window:null,$G=function $G(a){switch(arguments.length){case 3:return $G.B(arguments[0],arguments[1],arguments[2]);case 2:return $G.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(3),0,null);return $G.C(arguments[0],arguments[1],arguments[2],c)}};
$G.B=function(a,b,c){return $APP.Bd(a,b)?a:$APP.rg.B(a,b,c)};$G.C=function(a,b,c,d){return TTa($G,$G.B(a,b,c),d)};$G.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};$G.A=function(a,b){return $APP.Jd(function(c,d,g){return $APP.Bd(c,d)?c:$APP.rg.B(c,d,g)},null==a?$APP.F:a,b)};$G.G=3;
var Q_=function Q_(a){switch(arguments.length){case 2:return Q_.A(arguments[0],arguments[1]);case 3:return Q_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Q_.A=function(a,b){b=0>b?0:b;var c=$APP.Tc(a);return b>=c?$APP.sf:$APP.pi.B(a,b,c)};Q_.B=function(a,b,c){b=0>b?0:b;var d=$APP.Nd($APP.Tc(a));c=c>d?d:c;return b>=c?$APP.sf:$APP.pi.B(a,b,c)};Q_.G=3;
var R_=function R_(a){switch(arguments.length){case 2:return R_.A(arguments[0],arguments[1]);case 3:return R_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};R_.A=function(a,b){var c=$APP.Tc(a);return 0>b?(b+=c,$APP.pi.B(a,0>b?0:b,c)):b>=c?$APP.sf:$APP.pi.B(a,b,c)};
R_.B=function(a,b,c){if(0>=c)return $APP.sf;var d=$APP.Nd($APP.Tc(a));if(0>b)return b+=d,b=0>b?0:b,c=b+c,$APP.pi.B(a,b,c>d?d:c);c=b+c;d=c>d?d:c;return b>=d?$APP.sf:$APP.pi.B(a,b,d)};R_.G=3;$APP.Pi.A($APP.Id,$APP.N);
(function(){var a=$APP.Na(Hnc,$APP.Ag("performance"),null);if($APP.k(a)){var b=function(){var c=$APP.Na(a,$APP.Ag("now"),null);if($APP.k(c))return c;c=$APP.Na(a,$APP.Ag("mozNow"),null);if($APP.k(c))return c;c=$APP.Na(a,$APP.Ag("msNow"),null);if($APP.k(c))return c;c=$APP.Na(a,$APP.Ag("oNow"),null);return $APP.k(c)?c:$APP.Na(a,$APP.Ag("webkitNow"),null)}();return $APP.k(b)?function(){return 1E6*$APP.Nd(b.call(a))}:function(){return 1E6*(new Date).getTime()}}return function(){return 1E6*(new Date).getTime()}})();
var Inc=function(){function a(d){return new $APP.Sa(d)}function b(){return new $APP.Sa}var c=null;c=function(d){switch(arguments.length){case 0:return b.call(this);case 1:return a.call(this,d)}throw Error("Invalid arity: "+arguments.length);};c.J=b;c.j=a;return c}(),hVa=function(){function a(g,l){g=g instanceof $APP.Sa?g:Inc.j($APP.m.j(g));l=$APP.m.j(l);return g.append(l)}function b(g){return g instanceof $APP.Sa?g:Inc.j($APP.m.j(g))}function c(){return Inc.J()}var d=null;d=function(g,l){switch(arguments.length){case 0:return c.call(this);
case 1:return b.call(this,g);case 2:return a.call(this,g,l)}throw Error("Invalid arity: "+arguments.length);};d.J=c;d.j=b;d.A=a;return d}();$APP.mh(function(a,b){var c=$APP.Tc(a);b=$APP.Nd(b);if(1>c||256<c)throw $APP.Zi.A("`alphabet`: must be ℕ∈[1,256]",$APP.F);if(0>=b)throw $APP.Zi.A("`len`: must be ℕ∈[0,∞)",$APP.F);var d=(2<<(Math.floor(Math.log(c-1)/Math.log(2))|0))-1;return new $APP.H(null,3,5,$APP.I,[d,$APP.Nd(Math.ceil(1.6*d*b/c)),$APP.Hl.A($APP.m,a)],null)});$APP.Hl.A($APP.m,"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_");
var S_=function S_(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return S_.C(c)};
S_.C=function(a){var b=$APP.qe(a);a=$APP.C.A(b,$APP.GBa);var c=$APP.C.A(b,jmb),d=$APP.C.A(b,$Db),g=$APP.C.A(b,SFb),l=$APP.C.A(b,PQb),n=$APP.C.A(b,Snb),p=$APP.C.A(b,N7b),v=$APP.C.A(b,Wtb);b=$APP.C.A(b,VUb);return Math.round(($APP.k(b)?31536E6*b:0)+($APP.k(g)?2551392E3*g:0)+($APP.k(c)?6048E5*c:0)+($APP.k(p)?864E5*p:0)+($APP.k(v)?36E5*v:0)+($APP.k(n)?6E4*n:0)+($APP.k(l)?1E3*l:0)+($APP.k(d)?d:0)+($APP.k(a)?a:0))};S_.G=0;S_.M=function(a){return this.C($APP.r(a))};
$APP.Jl.A(function(a){return $APP.Pd($APP.Nd(a),1E3)},S_);$APP.Jl.A($APP.re,Q_);$APP.Jl.A($APP.re,R_);var T_=function T_(a){switch(arguments.length){case 2:return T_.A(arguments[0],arguments[1]);case 3:return T_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};T_.A=function(a,b){return a.substring(b)};T_.B=function(a,b,c){return b>=c?"":a.substring(b,c)};T_.G=3;
var U_=function U_(a){switch(arguments.length){case 2:return U_.A(arguments[0],arguments[1]);case 3:return U_.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};U_.A=function(a,b){return RTa(a.substr(b))};U_.B=function(a,b,c){return RTa(a.substr(b,c))};U_.G=3;$APP.Jl.A(RTa,T_);$APP.Jl.A(RTa,U_);$APP.kh.j($APP.zu);var Jnc={jj:["BC","AD"],ij:["Before Christ","Anno Domini"],lj:"JFMAMJJASOND".split(""),sj:"JFMAMJJASOND".split(""),kj:"January February March April May June July August September October November December".split(" "),rj:"January February March April May June July August September October November December".split(" "),oj:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),uj:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),xj:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
wj:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),qj:"Sun Mon Tue Wed Thu Fri Sat".split(" "),vj:"Sun Mon Tue Wed Thu Fri Sat".split(" "),fl:"SMTWTFS".split(""),tj:"SMTWTFS".split(""),pj:["Q1","Q2","Q3","Q4"],mj:["1st quarter","2nd quarter","3rd quarter","4th quarter"],fj:["AM","PM"],uh:["EEEE, MMMM d, y","MMMM d, y","MMM d, y","M/d/yy"],yh:["h:mm:ss a zzzz","h:mm:ss a z","h:mm:ss a","h:mm a"],gj:["{1} 'at' {0}","{1} 'at' {0}","{1}, {0}","{1}, {0}"],vh:6,il:[5,6],wh:5},HUa=
Jnc;HUa=Jnc;var MUa=[/^'(?:[^']|'')*('|$)/,/^(?:G+|y+|Y+|M+|k+|S+|E+|a+|h+|K+|H+|c+|L+|Q+|d+|m+|s+|v+|V+|w+|z+|Z+)/,/^[^'GyYMkSEahKHcLQdmsvVwzZ]+/];
KUa.prototype.format=function(a,b){if(!a)throw Error("The date to format must be non-null.");var c=b?6E4*(a.getTimezoneOffset()-(b.Tf-SG(b,a))):0;let d=c?new Date(a.getTime()+c):a,g=d;b&&d.getTimezoneOffset()!=a.getTimezoneOffset()&&(d=new Date(d.getTime()+6E4*(d.getTimezoneOffset()-a.getTimezoneOffset())),g=new Date(a.getTime()+(c+(0<c?-864E5:864E5))));c=[];for(let l=0;l<this.Kf.length;++l){const n=this.Kf[l].text;1==this.Kf[l].type?c.push(NUa(this,n,a,d,g,b)):c.push(n)}return c.join("")};
var LUa=!1;(function(a){var b=$APP.x.B(Gnc,0,null),c=$APP.x.B(Gnc,1,null),d=$APP.x.B(Gnc,2,null),g=$APP.od(a)?a:WTa.j(YTa(a));a=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);g=$APP.Hl.A(function(n){return $APP.k(n)?n:0},new $APP.H(null,3,5,$APP.I,[a,l,g],null));a=$APP.x.B(g,0,null);l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);if(b>a||$APP.Uc.A(b,a)&&(c>l||$APP.Uc.A(c,l)&&d>=g))return null;throw $APP.Zi.A("Insufficient `com.taoensso/encore` version, you may have a dependency conflict: see http://goo.gl/qBbLvC for solutions.",
new $APP.f(null,2,[W5b,$APP.Kl.A(".",new $APP.H(null,3,5,$APP.I,[a,l,g],null)),IEb,$APP.Kl.A(".",new $APP.H(null,3,5,$APP.I,[b,c,d],null))],null));})(new $APP.H(null,3,5,$APP.I,[3,43,0],null));
var Knc=$APP.mh(function(a){return tUa(a)}),SUa=$APP.mh(function(a,b){a=Knc(a);return a.j?a.j(b):a.call(null,b)}),UUa=$APP.mh(function(a,b){return VTa(function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return $APP.k(SUa(d,b))?QUa(c):null},a)}),IVa=$APP.mh(function(a,b){a=kUa(b);$APP.x.B(a,0,null);return $APP.x.B(a,1,null)}),aH=function aH(a){switch(arguments.length){case 2:return aH.A(arguments[0],arguments[1]);case 1:return aH.j(arguments[0]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));
}};aH.A=function(a,b){a=$APP.hd(a)?b:$APP.rg.B(b,XG,$APP.Vd.A(a,$APP.C.A(b,XG)));return aH.j(a)};
aH.j=function(a){var b=$APP.qe(a),c=$APP.C.A(b,XG);$APP.C.A(b,CUa);var d=$APP.C.A(b,lVa);$APP.C.A(b,gyb);var g=$APP.C.A(b,kVa),l=$APP.C.A(b,$APP.av),n=$APP.C.A(b,PG),p=$APP.C.A(b,MVa);b=$APP.C.A(b,mVa);return[function(){var v=$APP.dh(p);return $APP.k(v)?[$APP.m.j(v)," "].join(""):null}(),$APP.li($APP.Ag(l))," [",$APP.m.j($APP.k(g)?g:$APP.k(d)?d:"?"),":",$APP.m.j($APP.k(b)?b:"?"),"] - ",$APP.m.j(function(){var v=$APP.C.B(c,j8b,iVa);return $APP.k(v)?v.j?v.j(a):v.call(null,a):null}()),function(){if($APP.k(n)){var v=
$APP.C.B(c,wac,V_);return $APP.k(v)?$APP.k($APP.C.A(c,tqb))?null:["\n",$APP.m.j(v.j?v.j(a):v.call(null,a))].join(""):null}return null}()].join("")};aH.G=2;
var V_=function V_(a){var c=$APP.qe(a),d=$APP.C.A(c,PG);$APP.C.A(c,XG);return[$APP.m.j(d.stack),function(){var g=$APP.Ih(d);return $APP.k(g)?["\nex-data:\n    ",$APP.jh.C($APP.y([g]))].join(""):null}(),function(){var g=$APP.Kh(d);if($APP.k(g)){var l=$APP.m;var n=l.j;g=$APP.rg.B(c,PG,g);g=V_.j?V_.j(g):V_.call(null,g);l=["\n\nCaused by:\n",n.call(l,g)].join("")}else l=null;return l}()].join("")},DVa=new $APP.f(null,1,[BVa,CVa],null),YUa=new $APP.f(null,6,[ZUa,$APP.zu,$Ua,new $APP.ug(null,new $APP.f(null,
1,["*",null],null),null),wVa,$APP.sf,EVa,DVa,QG,aH,OVa,"undefined"!==typeof window?new $APP.f(null,1,[WLb,zUa.j?zUa.j($APP.F):zUa.call(null,$APP.F)],null):new $APP.f(null,1,[ksb,vUa.j?vUa.j($APP.F):vUa.call(null,$APP.F)],null)],null);var GJ=function GJ(a){switch(arguments.length){case 2:return GJ.A(arguments[0],arguments[1]);case 3:return GJ.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};GJ.A=function(a,b){return GJ.B(a,b,null)};GJ.B=function(a,b){$APP.k(!0)&&bH($APP.kw,"emmy.util.logic",22,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,[["Assuming ",$APP.m.j(a)," in ",$APP.m.j(b)].join("")],null)},null),-1664117629);return!0};GJ.G=3;var TM=null,hH=cH($APP.Iv),jH=cH($APP.Hv),m0a=cH(HJ),dH=cH(FJ),Lnc=cH($APP.sj),Mnc=cH(jK),bWa=cH(eH),nH=Math.PI,Nnc=nH/4,VVa=2*nH,UVa=2*Nnc,W_=function W_(a){switch(arguments.length){case 1:return W_.j(arguments[0]);case 2:return W_.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
W_.j=function(a){return GF(a)?$APP.eb(VF.j(a))?tG.j(a):$APP.k(MF.j(a))?0:new $APP.D(null,jK,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,jK,new $APP.D(null,a,null,1,null),2,null)};
W_.A=function(a,b){if($APP.k(uG.j(b)))return W_.j(a);if($APP.k(WF(a))){if(GF(b))return $APP.k(sG.j(b))?pH:0;a=GJ.A($APP.T.j($APP.r($APP.N.A(new $APP.D(null,tM,null,1,null),new $APP.D(null,b,null,1,null)))),rZb);return $APP.k(a)?0:a}if($APP.k(WF(b))){if(GF(a))return $APP.k(sG.j(a))?$APP.M($APP.Jv,$APP.M($APP.sj,pH,2)):$APP.M($APP.sj,pH,2);a=GJ.A($APP.T.j($APP.r($APP.N.A(new $APP.D(null,tM,null,1,null),new $APP.D(null,a,null,1,null)))),rZb);return $APP.k(a)?$APP.M($APP.sj,pH,2):a}return GF(b)&&GF(a)&&
($APP.eb(VF.j(b))||$APP.eb(VF.j(a)))?tG.A(a,b):new $APP.D(null,jK,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)};W_.G=2;
var Onc=fH(lG,HJ),Pnc=fH(rG,DJ),Qnc=fH(qG,BJ),EH=function EH(a,b){if(GF(a)&&GF(b))return tI.A(a,b);if(GF(a))return $APP.k(uG.j(a))?1:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,FJ,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))));if(GF(b)){if($APP.k(MF.j(b)))return 1;if($APP.k(uG.j(b)))return a;if($APP.k(function(){var l=$APP.xd(b);return l?(l=$APP.Ie(b))?m0a(a):l:l}())){var d=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a)),g=$APP.Pd(b,2);return EH.A?EH.A(d,
g):EH.call(null,d,g)}return $APP.k(function(){var l=dH(a);return $APP.k(l)?GF($APP.Xc($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a)))&&$APP.xd($APP.Xc($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a))*b):l}())?(d=$APP.u($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a)),g=$APP.Xc($APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a))*b,EH.A?EH.A(d,g):EH.call(null,d,g)):0>b?TVa(function(){var l=-b;return EH.A?EH.A(a,l):EH.call(null,a,l)}()):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,FJ,null,1,null),new $APP.D(null,a,null,
1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))}return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,FJ,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))},Rnc=new $APP.ug(null,new $APP.f(null,31,[gW,null,vV,null,zP,null,yH,null,mH,null,nK,null,uH,null,cdc,null,$APP.sj,null,jX,null,DJ,null,wH,null,FJ,null,$APP.Iv,null,NM,null,RX,null,uT,null,Ynb,null,cT,null,kQb,null,$APP.Hv,null,Etb,null,jK,null,PM,null,mK,null,$APP.Jv,null,yP,null,HJ,null,lK,null,BJ,null,qX,null],
null),null),AH=function AH(a){return GF(a)?sL.j(a):$APP.td(a)&&$APP.Bd(Rnc,$APP.u.j?$APP.u.j(a):$APP.u.call(null,a))?$APP.Yd($APP.u.j?$APP.u.j(a):$APP.u.call(null,a),$APP.Vg.A(AH,$APP.Fc.j?$APP.Fc.j(a):$APP.Fc.call(null,a))):new $APP.D(null,pY,new $APP.D(null,a,null,1,null),2,null)},Snc=fH(zG,function(a){return Onc(kH(AH(a),a))}),Tnc=fH(RZ,function(a){return W_.A($Va(a),BH(a))}),X_=function X_(a){switch(arguments.length){case 0:return X_.J();case 1:return X_.j(arguments[0]);case 2:return X_.A(arguments[0],
arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return X_.C(arguments[0],arguments[1],c)}};X_.J=function(){return!0};X_.j=function(){return!0};X_.A=function(a,b){return eWa(a,b)};X_.C=function(a,b,c){a=$APP.Yd(a,$APP.Yd(b,c));a=$APP.Ll.B(2,1,a);return $APP.Id.B(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);l=eWa(l,g);return $APP.k(l)?dWa(d,l):$APP.Mc(!1)},!0,a)};
X_.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};X_.G=2;
var gWa=$APP.fg([gS,$APP.ko,gW,FT,vV,yH,mH,nK,uH,kK,$X,$APP.sj,$APP.Ku,jX,IX,$APP.Iu,bU,DJ,$APP.bw,wH,vW,FJ,zW,$APP.Iv,NM,RX,uT,cT,CK,$APP.Hv,$APP.Cv,jK,RV,PM,FV,mK,ZS,dT,jV,$APP.Jv,tX,lY,pY,HJ,lK,BJ,YV,iub,qX,$APP.po,lS,EY,x$b],[function Unc(a,b){return QVa(a,b,Unc,gS)},O_.B(dWa,!0,$APP.Bba),function(a){return lH(1,ZVa(a))},function(a,b){return $APP.k(WF(a))?a:$APP.k(WF(b))?a:FF(a)&&FF(b)?QZ.A(a,b):kH(a,iH(XVa(b),kH(pG,WVa(b))))},function(a){return EH(a,3)},ZVa,WVa,function(a){return GF(a)?$APP.k(VF.j(a))?
$APP.k(MF.j(a))?0:new $APP.D(null,nK,new $APP.D(null,a,null,1,null),2,null):UF(a/nH)?0:UF((a-Nnc)/nH)?1:UF((a+Nnc)/nH)?-1:UF((a-UVa)/nH)?yD("Undefined: tan"):Math.tan(a):a instanceof $APP.q?$APP.k((new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,4,[oH,null,pH,null,qH,null,rH,null],null),null)).call(null,a))?0:$APP.k((new $APP.ug(null,new $APP.f(null,
2,[oK,null,pK,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,2,[oK,null,pK,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[oK,null,pK,null],null),null)).call(null,a))?1:$APP.k((new $APP.ug(null,new $APP.f(null,1,[qK,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,1,[qK,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,1,[qK,null],null),null)).call(null,a))?-1:$APP.k((new $APP.ug(null,new $APP.f(null,2,[sH,null,tH,null],null),null)).j?(new $APP.ug(null,new $APP.f(null,
2,[sH,null,tH,null],null),null)).j(a):(new $APP.ug(null,new $APP.f(null,2,[sH,null,tH,null],null),null)).call(null,a))?yD("Undefined: tan"):new $APP.D(null,nK,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,nK,new $APP.D(null,a,null,1,null),2,null)},XVa,O_.A(function(a,b){return GF(a)&&GF(b)?yM.A(a,b):GF(a)?$APP.k(MF.j(a))?b:$APP.k(uG.j(a))?1:new $APP.D(null,kK,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null):GF(b)?$APP.k(MF.j(b))?a:$APP.k(uG.j(b))?1:new $APP.D(null,kK,new $APP.D(null,
a,new $APP.D(null,b,null,1,null),2,null),3,null):$APP.Uc.A(a,b)?a:new $APP.D(null,kK,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)},0),function Vnc(a,b){return QVa(a,b,Vnc,$X)},P_.S(lH,kH,TVa,1,MF),function(a){return GF(a)?jG.j(a):new $APP.D(null,$APP.Ku,new $APP.D(null,a,null,1,null),2,null)},TVa,aWa,function(a){return $APP.sd(a)?!a:new $APP.D(null,$APP.Iu,new $APP.D(null,a,null,1,null),2,null)},BH,Pnc,X_,YVa,function(a){return lH(YVa(a),ZVa(a))},EH,function(a){return GF(a)?uZ.j(a):
new $APP.D(null,zW,new $APP.D(null,a,null,1,null),2,null)},O_.A(iH,0),function(a){return GF(a)?$APP.eb(VF.j(a))?yZ.j(a):$APP.k(MF.j(a))?1:$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sj,null,1,null),new $APP.D(null,1,null,1,null),$APP.y([new $APP.D(null,XVa(a),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sj,null,1,null),new $APP.D(null,1,null,1,null),$APP.y([new $APP.D(null,XVa(a),null,1,null)]))))},SVa,function(a){return lH(1,YVa(a))},function(a){return EH(a,2)},Snc,O_.B(kH,1,
MF),function(a){return GF(a)?MF.j(a):new $APP.D(null,$APP.bw,new $APP.D(null,0,new $APP.D(null,a,null,1,null),2,null),3,null)},W_,function(a,b){return $APP.k(WF(b))?a:FF(a)&&FF(b)?PZ.A(a,b):iH(a,kH(pG,b))},function(a){return GF(a)?$APP.eb(VF.j(a))?xZ.j(a):$APP.k(MF.j(a))?yD(["Zero argument -- g/csc",$APP.m.j(a)].join("")):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sj,null,1,null),new $APP.D(null,1,null,1,null),$APP.y([new $APP.D(null,WVa(a),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.sj,null,1,null),new $APP.D(null,1,null,1,null),$APP.y([new $APP.D(null,WVa(a),null,1,null)]))))},O_.B(function(a,b){return GF(a)&&GF(b)?qM.A(a,b):GF(a)?$APP.k(MF.j(a))?0:$APP.k(uG.j(a))?b:new $APP.D(null,FV,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null):GF(b)?$APP.k(MF.j(b))?0:$APP.k(uG.j(b))?a:new $APP.D(null,FV,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null):$APP.Uc.A(a,b)?a:new $APP.D(null,FV,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)},
1,MF),function(a){return GF(a)?$APP.eb(VF.j(a))?mO.j(a):$APP.k(uG.j(a))?0:new $APP.D(null,mK,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,mK,new $APP.D(null,a,null,1,null),2,null)},function(a){return RVa($APP.M($APP.sj,pH,2),W_.j(a))},function(a){return GF(a)?rZ.j(a):new $APP.D(null,dT,new $APP.D(null,a,null,1,null),2,null)},$Va,P_.K(RVa,iH,SVa,0),aWa,function(a){return GF(a)?tZ.j(a):new $APP.D(null,lY,new $APP.D(null,a,null,1,null),2,null)},AH,Onc,function(a){return GF(a)?$APP.eb(VF.j(a))?
zZ.j(a):$APP.k(MF.j(a))?0:new $APP.D(null,lK,new $APP.D(null,a,null,1,null),2,null):new $APP.D(null,lK,new $APP.D(null,a,null,1,null),2,null)},Qnc,function(a){return GF(a)?sZ.j(a):new $APP.D(null,YV,new $APP.D(null,a,null,1,null),2,null)},cWa,function(a){return lH(ZVa(a),YVa(a))},O_.B(function(a,b){return!0===a?a:!1===a?b:!0===b?b:!1===b?a:$APP.Uc.A(a,b)?b:new $APP.D(null,$APP.po,new $APP.D(null,a,new $APP.D(null,b,null,1,null),2,null),3,null)},!1,$APP.rd),fWa,Tnc,fWa]);var FM=function FM(a){switch(arguments.length){case 0:return FM.J();case 1:return FM.j(arguments[0]);case 2:return FM.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};FM.J=function(){return FM.A(4,"_")};FM.j=function(a){return FM.A(a,"_")};
FM.A=function(a,b){var c=$APP.kh.j(0);return function(){function d(n){var p=$APP.m.j($APP.lh.A(c,$APP.Lc)),v=a-p.length;0>v&&zD(["Symbol generator of width ",$APP.m.j(a)," exhausted"].join(""));return $APP.Zg.j($APP.Je.A($APP.m,$APP.N.C($APP.m.j(n),$APP.Vj.A(v,"0"),$APP.y([p]))))}function g(){return l.j(b)}var l=null;l=function(n){switch(arguments.length){case 0:return g.call(this);case 1:return d.call(this,n)}throw Error("Invalid arity: "+arguments.length);};l.J=g;l.j=d;return l}()};FM.G=2;
var Wnc=function(){function a(d,g,l,n){var p=Y_[$APP.la(null==d?null:d)];if(null!=p)return p.K?p.K(d,g,l,n):p.call(null,d,g,l,n);p=Y_._;if(null!=p)return p.K?p.K(d,g,l,n):p.call(null,d,g,l,n);throw $APP.ib("ICanonicalize.expression-\x3e",d);}function b(d,g,l){var n=Y_[$APP.la(null==d?null:d)];if(null!=n)return n.B?n.B(d,g,l):n.call(null,d,g,l);n=Y_._;if(null!=n)return n.B?n.B(d,g,l):n.call(null,d,g,l);throw $APP.ib("ICanonicalize.expression-\x3e",d);}var c=null;c=function(d,g,l,n){switch(arguments.length){case 3:return b.call(this,
d,g,l);case 4:return a.call(this,d,g,l,n)}throw Error("Invalid arity: "+arguments.length);};c.B=b;c.K=a;return c}(),Y_=function Y_(a){switch(arguments.length){case 3:return Y_.B(arguments[0],arguments[1],arguments[2]);case 4:return Y_.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Y_.B=function(a,b,c){return null!=a&&null!=a.Jg?a.Jg(a,b,c):Wnc(a,b,c)};
Y_.K=function(a,b,c,d){return null!=a&&null!=a.Af?a.Af(a,b,c,d):Wnc(a,b,c,d)};Y_.G=4;var GM=function GM(a){switch(arguments.length){case 1:return GM.j(arguments[0]);case 2:return GM.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};GM.j=function(a){return GM.A(a,FM.A(16,"-g-"))};
GM.A=function(a,b){function c(Z){var fa=$APP.Ej.j($APP.Vg.A(p,Z));Z=$APP.u.j?$APP.u.j(fa):$APP.u.call(null,fa);var ia=FH(Z);return $APP.k(ia)?(fa=$APP.Je.A(ia,$APP.Fc.j?$APP.Fc.j(fa):$APP.Fc.call(null,fa)),$APP.kd(fa)&&$APP.Uc.A($APP.u.j?$APP.u.j(fa):$APP.u.call(null,fa),Z)?d(fa):R(fa)):d(fa)}function d(Z){Z=$APP.Ej.j($APP.Vg.A(B,Z));return B(Z)}function g(Z){return W(l(Z))}function l(Z){var fa=TM;TM=!1;try{var ia=hWa(aG(Z));$APP.Ne(O,ia);var ja=R(Z);return p(ja)}finally{TM=fa}}function n(Z){v();
return g($F(Z))}function p(Z){return $APP.k(t(Z))?Y_(a,Z,function(fa,ia){return iWa(a,fa,ia)},A):Z}function v(){$APP.Ne(O,$APP.Ed);$APP.Ne.A?$APP.Ne.A(G,$APP.F):$APP.Ne.call(null,G,$APP.F);$APP.Ne.A?$APP.Ne.A(J,$APP.F):$APP.Ne.call(null,J,$APP.F);return null}function t(Z){return $APP.kd(Z)&&!$APP.Uc.A($APP.u(Z),$APP.K)}function A(Z,fa){var ia=$APP.Fb(O);return ia.A?ia.A(Z,fa):ia.call(null,Z,fa)}function B(Z){if($APP.k(t(Z))){var fa=cG.j(Z);var ia=$APP.Fb(G);ia=ia.j?ia.j(fa):ia.call(null,fa);$APP.k(ia)?
Z=ia:(ia=b.J?b.J():b.call(null),$APP.lh.K?$APP.lh.K(G,$APP.rg,fa,ia):$APP.lh.call(null,G,$APP.rg,fa,ia),$APP.lh.K?$APP.lh.K(J,$APP.rg,ia,Z):$APP.lh.call(null,J,$APP.rg,ia,Z),Z=ia);return Z}return Z}var G=$APP.kh.j?$APP.kh.j($APP.F):$APP.kh.call(null,$APP.F),J=$APP.kh.j?$APP.kh.j($APP.F):$APP.kh.call(null,$APP.F),O=$APP.kh.j($APP.Ed),R=function ia(fa){if($APP.k(t(fa))){var ja=$APP.Ej.j($APP.Vg.A(ia,fa));if($APP.k(function(){var ta=jWa(a,$APP.u.j?$APP.u.j(ja):$APP.u.call(null,ja));$APP.k(ta)&&($APP.k(!0)?
(ta=dH(ja),ta=$APP.k(ta)?!EF($APP.Xc($APP.Fc.j?$APP.Fc.j(ja):$APP.Fc.call(null,ja))):ta):ta=!0,ta=$APP.eb(ta));return ta}()))return ja;fa=function(){var ta=$APP.Fb(G);return ta.j?ta.j(ja):ta.call(null,ja)}();return $APP.k(fa)?fa:c(ja)}return fa},W=function ja(ia){if($APP.kd(ia))return $APP.Ej.j($APP.Vg.A(ja,ia));if(ia instanceof $APP.q){var ta=$APP.Fb(J);ta=ta.j?ta.j(ia):ta.call(null,ia);return $APP.k(ta)?ja(ta):ia}return ia};return new $APP.f(null,6,[kWa,function(ia){return ZF(ia)?QSa(n,ia):n(ia)},
mWa,function(ia){return ZF(ia)?QSa(g,ia):g(ia)},QHb,v,yUb,l,CMb,function(){return $APP.Fb(J)},aNb,function(){return $APP.Fb(G)}],null)};GM.G=2;$APP.e=KH.prototype;$APP.e.Ka=function(a,b){return this.fa(null,b,null)};$APP.e.fa=function(a,b,c){switch(b instanceof $APP.E?b.ga:null){case "id-\x3epartial":return this.Pc;default:return $APP.C.B(this.N,b,c)}};$APP.e.lb=function(a,b,c){return $APP.Id.B(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return b.B?b.B(d,l,g):b.call(null,d,l,g)},c,this)};
$APP.e.ea=function(a,b,c){return $APP.Rg(b,function(d){return $APP.Rg(b,$APP.Ug,""," ","",c,d)},"#emmy.dual.Completed{",", ","}",c,$APP.N.A(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[yV,this.Pc],null)],null),this.N))};$APP.e.Qa=function(){return new $APP.Ff(this,1,new $APP.H(null,1,5,$APP.I,[yV],null),$APP.k(this.N)?$APP.qc(this.N):$APP.we())};$APP.e.ba=function(){return this.R};$APP.e.qa=function(){return new KH(this.Pc,this.R,this.N,this.P)};$APP.e.ta=function(){return 1+$APP.Tc(this.N)};
$APP.e.ka=function(){var a=this.P;return null!=a?a:this.P=a=804361140^$APP.Kc(this)};$APP.e.Y=function(a,b){return null!=b&&this.constructor===b.constructor&&$APP.Uc.A(this.Pc,b.Pc)&&$APP.Uc.A(this.N,b.N)};$APP.e.ac=function(a,b,c){return new KH(HH(this.Pc,b,c),null,null,null)};$APP.e.$b=function(){return null};$APP.e.ic=function(a,b){return $APP.C.B(this.Pc,b,0)};
$APP.e.Hb=function(a,b){return $APP.Bd(new $APP.ug(null,new $APP.f(null,1,[yV,null],null),null),b)?$APP.Oi.A($APP.Ib($APP.Lf.A($APP.F,this),this.R),b):new KH(this.Pc,this.R,$APP.re($APP.Oi.A(this.N,b)),null)};$APP.e.Va=function(a,b){switch(b instanceof $APP.E?b.ga:null){case "id-\x3epartial":return!0;default:return $APP.Bd(this.N,b)}};
$APP.e.sa=function(a,b,c){return $APP.k($APP.$d.A?$APP.$d.A(yV,b):$APP.$d.call(null,yV,b))?new KH(c,this.R,this.N,null):new KH(this.Pc,this.R,$APP.rg.B(this.N,b,c),null)};$APP.e.ma=function(){return $APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[new $APP.Cd(yV,this.Pc,null)],null),this.N))};$APP.e.da=function(a,b){return new KH(this.Pc,b,this.N,this.P)};$APP.e.ua=function(a,b){return $APP.od(b)?this.sa(null,$APP.bd(b,0),$APP.bd(b,1)):$APP.Id.B($APP.nb,this,b)};var Z_=oWa($APP.F);
MF.F(null,new $APP.H(null,1,5,$APP.I,[KH],null),function(){return!1});uG.F(null,new $APP.H(null,1,5,$APP.I,[KH],null),function(){return!1});kZ.F(null,new $APP.H(null,1,5,$APP.I,[KH],null),function(){return!1});nWa["null"]=!0;HH["null"]=function(){return null};JH["null"]=function(){return 0};IH["null"]=function(a,b,c){return $APP.Uc.A(c,TH)?0:Z_};nWa._=!0;HH._=function(a){return a};JH._=function(){return 0};IH._=function(a,b,c){return $APP.Uc.A(c,TH)?vG.j(a):Z_};var pWa=$APP.kh.j(-1);
$APP.ju.A(jN,HF);$APP.e=MH.prototype;$APP.e.ac=function(a,b,c){return $APP.Uc.A(b,this.tag)?new MH(c,this.xc,this.ze):this};$APP.e.$b=function(a,b,c){return $APP.qg.A(c,TH)?Z_:$APP.Uc.A(b,this.tag)?this.ze:0};$APP.e.rb=function(){return jN};$APP.e.valueOf=function(){return this.xc.valueOf()};$APP.e.toString=function(){return["#emmy.dual.Dual",$APP.m.j(new $APP.f(null,3,[$APP.tj,this.tag,wcb,this.xc,Rnb,this.ze],null))].join("")};$APP.e.Y=function(a,b){return $_.A?$_.A(this,b):$_.call(null,this,b)};
$APP.e.Tb=function(a,b){return sWa.A?sWa.A(this,b):sWa.call(null,this,b)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};var dN=function dN(a){switch(arguments.length){case 1:return dN.j(arguments[0]);case 2:return dN.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};dN.j=function(a){return NH(a)?new $APP.H(null,2,5,$APP.I,[a.xc,a.ze],null):new $APP.H(null,2,5,$APP.I,[a,0],null)};
dN.A=function(a,b){return NH(a)&&$APP.Uc.A(b,OH(a))?new $APP.H(null,2,5,$APP.I,[a.xc,a.ze],null):new $APP.H(null,2,5,$APP.I,[a,0],null)};dN.G=2;var RH=function RH(a){switch(arguments.length){case 1:return RH.j(arguments[0]);case 2:return RH.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};RH.j=function(a){return $APP.x.A(dN.j(a),0)};RH.A=function(a,b){return $APP.x.A(dN.A(a,b),0)};RH.G=2;
var YN=function YN(a){switch(arguments.length){case 1:return YN.j(arguments[0]);case 2:return YN.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};YN.j=function(a){return $APP.x.A(dN.j(a),1)};YN.A=function(a,b){return $APP.x.A(dN.A(a,b),1)};YN.G=2;
var SH=function SH(a){switch(arguments.length){case 1:return SH.j(arguments[0]);case 2:return SH.A(arguments[0],arguments[1]);case 3:return SH.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};SH.j=function(a){return SH.B(a,1,LH())};SH.A=function(a,b){return SH.B(a,1,b)};SH.B=function(a,b,c){return $APP.k(MF.j(b))?a:qWa(c,a,b)};SH.G=3;
var PH=$APP.Ec,a0=function a0(a){switch(arguments.length){case 1:return a0.j(arguments[0]);case 2:return a0.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return a0.C(arguments[0],arguments[1],c)}};a0.j=function(){return!0};a0.A=function(a,b){return hG.A(dN.j(a),dN.j(b))};a0.C=function(a,b,c){for(;;)if($APP.k(a0.A(a,b)))if($APP.w(c))a=b,b=$APP.u(c),c=$APP.w(c);else return a0.A(b,$APP.u(c));else return!1};
a0.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};a0.G=2;var $_=function $_(a){switch(arguments.length){case 1:return $_.j(arguments[0]);case 2:return $_.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return $_.C(arguments[0],arguments[1],c)}};$_.j=function(){return!0};$_.A=function(a,b){return hG.A(RH.j(a),RH.j(b))};
$_.C=function(a,b,c){for(;;)if($APP.k($_.A(a,b)))if($APP.w(c))a=b,b=$APP.u(c),c=$APP.w(c);else return $_.A(b,$APP.u(c));else return!1};$_.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};$_.G=2;vG.F(null,new $APP.H(null,1,5,$APP.I,[jN],null),function(){return 0});PF.F(null,new $APP.H(null,1,5,$APP.I,[jN],null),function(){return 1});lZ.F(null,new $APP.H(null,1,5,$APP.I,[jN],null),function(){return 1});
cG.F(null,new $APP.H(null,1,5,$APP.I,[jN],null),function(a){return $APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,c4b,null,1,null),new $APP.D(null,OH(a),null,1,null),$APP.y([new $APP.D(null,cG.j(RH.j(a)),null,1,null),new $APP.D(null,cG.j(YN.j(a)),null,1,null)])))))});dG.F(null,new $APP.H(null,1,5,$APP.I,[jN],null),function(a){return new MH(a.tag,dG.j(a.xc),dG.j(a.ze))});var LQ=Error();uWa._=!0;UH._=function(a){a=ZH.j($APP.ed(a));return $APP.k(a)?a:new $APP.H(null,2,5,$APP.I,[hI,1],null)};$APP.q.prototype.bc=function(){return new $APP.H(null,2,5,$APP.I,[hI,0],null)};$APP.Ch.prototype.bc=function(){return this.j(ZH)};XH.A=function(a,b){return XH.B(a,b,$APP.F)};XH.B=function(a,b,c){b=$APP.rg.B($APP.Ni.C($APP.y([$APP.ed(a),c])),ZH,b);return ESa(a,b)};XH.G=3;YH.C=function(a){var b=$APP.$c(a);b=UH($APP.k(b)?b:$APP.Kd);return XH.A($APP.Je.A($APP.Jl,a),b)};YH.G=0;YH.M=function(a){return this.C($APP.r(a))};
aI.A=function(a,b){return WH(a)?YH.C($APP.y([function(c){return aI.A(c,b)},a])):$APP.C.A(a,b)};aI.B=function(a,b,c){return WH(a)?YH.C($APP.y([function(d){return aI.B(d,b,c)},a])):$APP.C.B(a,b,c)};aI.G=3;bI.A=function(a,b){return WH(a)?YH.C($APP.y([function(c){return bI.A(c,b)},a])):$APP.am.A(a,b)};bI.B=function(a,b,c){return WH(a)?YH.C($APP.y([function(d){return bI.B(d,b,c)},a])):$APP.am.B(a,b,c)};bI.G=3;
dI.C=function(a,b){var c=$APP.N.A(b,$APP.Vj.j(0));return XH.A(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return $APP.Je.A(a,$APP.Vg.B(mG,l,c))}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),UH(a))};dI.G=1;dI.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
eI.C=function(a,b){var c=$APP.N.A(b,$APP.Vj.j(1));return XH.A(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return $APP.Je.A(a,$APP.Vg.B(kG,l,c))}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),UH(a))};eI.G=1;eI.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};$APP.Ch.prototype.rb=function(){return VH};CF["function"]=!0;
DF["function"]=function(){return VH};$APP.Ac.prototype.rb=function(){return VH};$APP.dd.prototype.rb=function(){return VH};var Xnc=$APP.mh(function(a){var b=zWa(a);return $APP.vd(a.C)?$APP.Uc.A(new $APP.H(null,4,5,$APP.I,[0,1,2,3],null),b)?new $APP.H(null,2,5,$APP.I,[hI,1],null):new $APP.H(null,2,5,$APP.I,[XS,$APP.u(b)],null):$APP.Uc.A(1,$APP.Tc(b))?new $APP.H(null,2,5,$APP.I,[hI,$APP.u(b)],null):new $APP.H(null,3,5,$APP.I,[PX,$APP.u(b),$APP.$c(b)],null)});uWa["function"]=!0;
UH["function"]=function(a){return ZH.A($APP.ed(a),Xnc(a))};$APP.dd.prototype.bc=function(){return ZH.A($APP.ed(this),Xnc(this))};fI.J=function(){return new $APP.H(null,2,5,$APP.I,[XS,0],null)};fI.j=function(a){return a};
fI.A=function(a,b){function c(){return $APP.k(!1)?yD(["Incompatible arities: ",$APP.m.j(a)," ",$APP.m.j(b)].join("")):new $APP.H(null,2,5,$APP.I,[XS,0],null)}if(0<$APP.Ed($APP.u(a),$APP.u(b)))return fI.A(b,a);try{if($APP.od(a)&&2===$APP.Tc(a))try{var d=$APP.x.A(a,0);if($APP.$d(d,XS))try{if($APP.od(b)&&2===$APP.Tc(b))try{var g=$APP.x.A(b,0);if($APP.$d(g,XS)){var l=$APP.x.A(b,1),n=$APP.x.A(a,1);return new $APP.H(null,2,5,$APP.I,[XS,function(){var V=n;return V>l?V:l}()],null)}throw LQ;}catch(V){if(V instanceof
Error){var p=V;if(p===LQ)throw LQ;throw p;}throw V;}else throw LQ;}catch(V){if(V instanceof Error)if(p=V,p===LQ)try{if($APP.od(b)&&3===$APP.Tc(b))try{var v=$APP.x.A(b,0);if($APP.$d(v,PX)){var t=$APP.x.A(b,1),A=$APP.x.A(b,2);n=$APP.x.A(a,1);var B=function(){var da=n,Y=t;return da>Y?da:Y}();return $APP.Uc.A(B,A)?new $APP.H(null,2,5,$APP.I,[hI,B],null):B<A?new $APP.H(null,3,5,$APP.I,[PX,B,A],null):c()}throw LQ;}catch(da){if(da instanceof Error){var G=da;if(G===LQ)throw LQ;throw G;}throw da;}else throw LQ;
}catch(da){if(da instanceof Error)if(G=da,G===LQ)try{if($APP.od(b)&&2===$APP.Tc(b))try{var J=$APP.x.A(b,0);if($APP.$d(J,hI)){var O=$APP.x.A(b,1);n=$APP.x.A(a,1);return O>=n?new $APP.H(null,2,5,$APP.I,[hI,O],null):c()}throw LQ;}catch(Y){if(Y instanceof Error){var R=Y;if(R===LQ)throw LQ;throw R;}throw Y;}else throw LQ;}catch(Y){if(Y instanceof Error){R=Y;if(R===LQ)throw LQ;throw R;}throw Y;}else throw G;else throw da;}else throw p;else throw V;}else throw LQ;}catch(V){if(V instanceof Error){p=V;if(p===
LQ)throw LQ;throw p;}throw V;}else throw LQ;}catch(V){if(V instanceof Error)if(p=V,p===LQ)try{if($APP.od(a)&&3===$APP.Tc(a))try{var W=$APP.x.A(a,0);if($APP.$d(W,PX))try{if($APP.od(b)&&3===$APP.Tc(b))try{var Z=$APP.x.A(b,0);if($APP.$d(Z,PX)){var fa=$APP.x.A(b,1),ia=$APP.x.A(b,2);t=$APP.x.A(a,1);A=$APP.x.A(a,2);B=function(){var da=t;return da>fa?da:fa}();var ja=function(){var da=A;return da<ia?da:ia}();return $APP.Uc.A(B,ja)?new $APP.H(null,2,5,$APP.I,[hI,B],null):B<ja?new $APP.H(null,3,5,$APP.I,[PX,
B,ja],null):c()}throw LQ;}catch(da){if(da instanceof Error){G=da;if(G===LQ)throw LQ;throw G;}throw da;}else throw LQ;}catch(da){if(da instanceof Error)if(G=da,G===LQ)try{if($APP.od(b)&&2===$APP.Tc(b))try{var ta=$APP.x.A(b,0);if($APP.$d(ta,hI))return n=$APP.x.A(b,1),t=$APP.x.A(a,1),A=$APP.x.A(a,2),t<=n&&n<=A?new $APP.H(null,2,5,$APP.I,[hI,n],null):c();throw LQ;}catch(Y){if(Y instanceof Error){R=Y;if(R===LQ)throw LQ;throw R;}throw Y;}else throw LQ;}catch(Y){if(Y instanceof Error){R=Y;if(R===LQ)throw LQ;
throw R;}throw Y;}else throw G;else throw da;}else throw LQ;}catch(da){if(da instanceof Error){G=da;if(G===LQ)throw LQ;throw G;}throw da;}else throw LQ;}catch(da){if(da instanceof Error)if(G=da,G===LQ)try{if($APP.od(a)&&2===$APP.Tc(a))try{var ua=$APP.x.A(a,0);if($APP.$d(ua,hI))try{if($APP.od(b)&&2===$APP.Tc(b))try{var ca=$APP.x.A(b,0);if($APP.$d(ca,hI))return O=$APP.x.A(b,1),n=$APP.x.A(a,1),$APP.Uc.A(n,O)?new $APP.H(null,2,5,$APP.I,[hI,n],null):c();throw LQ;}catch(Y){if(Y instanceof Error){R=Y;if(R===
LQ)throw LQ;throw R;}throw Y;}else throw LQ;}catch(Y){if(Y instanceof Error){R=Y;if(R===LQ)throw LQ;throw R;}throw Y;}else throw LQ;}catch(Y){if(Y instanceof Error){R=Y;if(R===LQ)throw LQ;throw R;}throw Y;}else throw LQ;}catch(Y){if(Y instanceof Error){R=Y;if(R===LQ)throw Error(["No matching clause: ",$APP.m.j(a)," ",$APP.m.j(b)].join(""));throw R;}throw Y;}else throw G;else throw da;}else throw p;else throw V;}};fI.G=2;$APP.ju.A(HF,lI);jI(gH,mG);jI(AG,TF);jI(OF,kG);iI(QF);jI(BG,SF);kI(tI);iI(lG);
iI(RF);iI(sG);iI(jG);iI(rZ);iI(tZ);iI(sZ);iI(uZ);kI(sI);kI(CG);kI(nI);iI(iO);iI(hO);iI(vZ);iI(zZ);iI(mO);iI(tG);kI(tG);iI(xH);iI(vH);iI(DZ);iI(nG);iI(qZ);iI(qG);iI(rG);gR.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(a){return function(b){return function(c){c=a.j?a.j(c):a.call(null,c);return b.j?b.j(c):b.call(null,c)}}});iI(aR);iI(SZ);kI(yM);kI(qM);kI(kM);kI(XF);kI(eR);iI(NO);kI(DH);kI(TZ);kI(UZ);kI(VZ);kI(PZ);kI(QZ);iI(zH);iI(CH);iI(zG);iI(RZ);iI(sL);
MF.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(){return!1});uG.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(){return!1});kZ.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(){return!1});vG.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(a){return wWa(a)});PF.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(a){return yWa(a)});lZ.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(a){return XH.B($APP.Kd,UH(a),new $APP.f(null,1,[cI,oPb],null))});
VF.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(a){return YH.C($APP.y([VF,a]))});cG.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(a){var b=$APP.C,c=b.B,d=$APP.Fb(GSa);if(a instanceof $APP.Ch){var g=$APP.Dh(a,new $APP.H(null,1,5,$APP.I,[$APP.E],null));g=$APP.k(g)?g.j?g.j($APP.Q):g.call(null,$APP.Q):a}else g=a instanceof $APP.dd?$APP.Q.A(a.meta,a):a instanceof $APP.Ac?cG.j($APP.Fb(a)):a;return c.call(b,d,a,g)});$APP.Ch.prototype.ac=function(a,b,c){return EWa(this,b,c)};
$APP.Ch.prototype.$b=function(a,b,c){return DWa(this,b,c)};$APP.Ch.prototype.ic=function(a,b){return $APP.Jl.A(function(c){return JH(c,b)},this)};nWa["function"]=!0;HH["function"]=function(a,b,c){return EWa(a,b,c)};IH["function"]=function(a,b,c){return DWa(a,b,c)};JH["function"]=function(a,b){return $APP.Jl.A(function(c){return JH(c,b)},a)};$APP.dd.prototype.ac=function(a,b,c){return EWa(this.afn,b,c)};$APP.dd.prototype.$b=function(a,b,c){return DWa(this.afn,b,c)};
$APP.dd.prototype.ic=function(a,b){return $APP.Jl.A(function(c){return JH(c,b)},this.afn)};dG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.H],null),function(a){return $APP.Hl.A(dG,a)});vG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.H],null),function(a){return $APP.Hl.A(vG,a)});VF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.H],null),function(a){return $APP.Ge(VF,a)});cG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.H],null),function(a){return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,zP,null,1,null),$APP.Vg.A(cG,a))))});$APP.e=$APP.H.prototype;$APP.e.rb=function(){return $APP.hb(this)};
$APP.e.bc=function(){return new $APP.H(null,3,5,$APP.I,[PX,1,2],null)};$APP.e.ac=function(a,b,c){return $APP.Hl.A(function(d){return HH(d,b,c)},this)};$APP.e.$b=function(a,b,c){return $APP.Hl.A(function(d){return IH(d,b,c)},this)};$APP.e.ic=function(a,b){return $APP.Hl.A(function(c){return JH(c,b)},this)};dG.F(null,new $APP.H(null,1,5,$APP.I,[$R],null),function(a){return $APP.Vg.A(dG,a)});
for(var b0=$APP.r(new $APP.H(null,6,5,$APP.I,[$APP.Xd,$APP.Bc,$APP.de,$APP.D,$APP.Gg,$APP.Fg],null)),c0=null,d0=0,e0=0;;)if(e0<d0){var f0=c0.aa(null,e0);MF.F(null,new $APP.H(null,1,5,$APP.I,[f0],null),function(){return function(){return!1}}(b0,c0,d0,e0,f0));uG.F(null,new $APP.H(null,1,5,$APP.I,[f0],null),function(){return function(){return!1}}(b0,c0,d0,e0,f0));kZ.F(null,new $APP.H(null,1,5,$APP.I,[f0],null),function(){return function(){return!1}}(b0,c0,d0,e0,f0));vG.F(null,new $APP.H(null,1,5,$APP.I,
[f0],null),function(){return function(a){return $APP.Vg.A(vG,a)}}(b0,c0,d0,e0,f0));VF.F(null,new $APP.H(null,1,5,$APP.I,[f0],null),function(){return function(a){return $APP.Ge(VF,a)}}(b0,c0,d0,e0,f0));cG.F(null,new $APP.H(null,1,5,$APP.I,[f0],null),function(){return function(a){return $APP.Vg.A(cG,a)}}(b0,c0,d0,e0,f0));f0.prototype.rb=function(){return function(){return $APP.hb(this)}}(b0,c0,d0,e0,f0);f0.prototype.ac=function(a,b,c,d,g){return function(l,n,p){return $APP.Vg.A(function(){return function(v){return HH(v,
n,p)}}(a,b,c,d,this,g),this)}}(b0,c0,d0,e0,f0);f0.prototype.$b=function(a,b,c,d,g){return function(l,n,p){return $APP.Vg.A(function(){return function(v){return IH(v,n,p)}}(a,b,c,d,this,g),this)}}(b0,c0,d0,e0,f0);f0.prototype.ic=function(a,b,c,d,g){return function(l,n){return $APP.Vg.A(function(){return function(p){return JH(p,n)}}(a,b,c,d,this,g),this)}}(b0,c0,d0,e0,f0);e0+=1}else{var g0=$APP.r(b0);if(g0){var h0=g0;if($APP.pd(h0)){var Ync=$APP.lc(h0),Znc=$APP.mc(h0),$nc=Ync,aoc=$APP.Tc(Ync);b0=Znc;
c0=$nc;d0=aoc}else{var i0=$APP.u(h0);MF.F(null,new $APP.H(null,1,5,$APP.I,[i0],null),function(){return function(){return!1}}(b0,c0,d0,e0,i0,h0,g0));uG.F(null,new $APP.H(null,1,5,$APP.I,[i0],null),function(){return function(){return!1}}(b0,c0,d0,e0,i0,h0,g0));kZ.F(null,new $APP.H(null,1,5,$APP.I,[i0],null),function(){return function(){return!1}}(b0,c0,d0,e0,i0,h0,g0));vG.F(null,new $APP.H(null,1,5,$APP.I,[i0],null),function(){return function(a){return $APP.Vg.A(vG,a)}}(b0,c0,d0,e0,i0,h0,g0));VF.F(null,
new $APP.H(null,1,5,$APP.I,[i0],null),function(){return function(a){return $APP.Ge(VF,a)}}(b0,c0,d0,e0,i0,h0,g0));cG.F(null,new $APP.H(null,1,5,$APP.I,[i0],null),function(){return function(a){return $APP.Vg.A(cG,a)}}(b0,c0,d0,e0,i0,h0,g0));i0.prototype.rb=function(){return function(){return $APP.hb(this)}}(b0,c0,d0,e0,i0,h0,g0);i0.prototype.ac=function(a,b,c,d,g,l,n){return function(p,v,t){return $APP.Vg.A(function(){return function(A){return HH(A,v,t)}}(a,b,c,d,this,g,l,n),this)}}(b0,c0,d0,e0,i0,
h0,g0);i0.prototype.$b=function(a,b,c,d,g,l,n){return function(p,v,t){return $APP.Vg.A(function(){return function(A){return IH(A,v,t)}}(a,b,c,d,this,g,l,n),this)}}(b0,c0,d0,e0,i0,h0,g0);i0.prototype.ic=function(a,b,c,d,g,l,n){return function(p,v){return $APP.Vg.A(function(){return function(t){return JH(t,v)}}(a,b,c,d,this,g,l,n),this)}}(b0,c0,d0,e0,i0,h0,g0);b0=$APP.w(h0);c0=null;d0=0}e0=0}else break}$APP.ju.A($APP.eg,VT);$APP.ju.A($APP.f,VT);$APP.ju.A($APP.kg,VT);
RF.F(null,new $APP.H(null,1,5,$APP.I,[VT],null),function(a){return sD(RF,a)});gH.F(null,new $APP.H(null,2,5,$APP.I,[VT,VT],null),function(a,b){return $APP.Qo.C(gH,$APP.y([a,b]))});AG.F(null,new $APP.H(null,2,5,$APP.I,[VT,VT],null),function(a,b){return $APP.Qo.C(gH,$APP.y([a,sD(RF,b)]))});OF.F(null,new $APP.H(null,2,5,$APP.I,[VT,HF],null),function(a,b){return sD(function(c){return OF.A(c,b)},a)});
OF.F(null,new $APP.H(null,2,5,$APP.I,[HF,VT],null),function(a,b){return sD(function(c){return OF.A(a,c)},b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[VT,HF],null),function(a,b){return sD(function(c){return BG.A(c,b)},a)});PZ.F(null,new $APP.H(null,2,5,$APP.I,[VT,VT],null),function(a,b){return FWa(PZ,a,b)});QZ.F(null,new $APP.H(null,2,5,$APP.I,[VT,VT],null),function(a,b){return FWa(QZ,a,b)});zH.F(null,new $APP.H(null,1,5,$APP.I,[VT],null),function(a){return sD(zH,a)});
CH.F(null,new $APP.H(null,1,5,$APP.I,[VT],null),function(a){return sD(CH,a)});dG.F(null,new $APP.H(null,1,5,$APP.I,[VT],null),function(a){return sD(dG,a)});var boc=new $APP.Ef;hG.F(null,new $APP.H(null,2,5,$APP.I,[VT,VT],null),function(a,b){return $APP.vd($APP.Tc(a)===$APP.Tc(b)?$APP.Jd(function(c,d,g){return $APP.k(hG.A($APP.C.B(b,d,boc),g))?!0:$APP.Mc(!1)},!0,a):null)});oR.F(null,new $APP.H(null,2,5,$APP.I,[VT,$R],null),function(a,b){return sD(function(c){return oR.A(c,b)},a)});
for(var j0=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.eg,$APP.f,$APP.kg],null)),k0=null,l0=0,m0=0;;)if(m0<l0){var n0=k0.aa(null,m0);MF.F(null,new $APP.H(null,1,5,$APP.I,[n0],null),function(){return function(a){return $APP.Ge(MF,$APP.pg(a))}}(j0,k0,l0,m0,n0));uG.F(null,new $APP.H(null,1,5,$APP.I,[n0],null),function(){return function(){return!1}}(j0,k0,l0,m0,n0));kZ.F(null,new $APP.H(null,1,5,$APP.I,[n0],null),function(){return function(){return!1}}(j0,k0,l0,m0,n0));vG.F(null,new $APP.H(null,1,5,$APP.I,
[n0],null),function(){return function(a){return sD(vG,a)}}(j0,k0,l0,m0,n0));VF.F(null,new $APP.H(null,1,5,$APP.I,[n0],null),function(){return function(a){return $APP.Ge(VF,$APP.pg(a))}}(j0,k0,l0,m0,n0));cG.F(null,new $APP.H(null,1,5,$APP.I,[n0],null),function(){return function(a){return sD(cG,a)}}(j0,k0,l0,m0,n0));$APP.e=n0.prototype;$APP.e.rb=function(){return function(){return $APP.ld(this)?$APP.hb(this):$APP.Ui.A(this,$APP.hb(this))}}(j0,k0,l0,m0,n0);$APP.e.bc=function(){return function(){return new $APP.H(null,
3,5,$APP.I,[PX,1,2],null)}}(j0,k0,l0,m0,n0);$APP.e.ac=function(a,b,c,d,g){return function(l,n,p){return sD(function(){return function(v){return HH(v,n,p)}}(a,b,c,d,this,g),this)}}(j0,k0,l0,m0,n0);$APP.e.$b=function(a,b,c,d,g){return function(l,n,p){l=$APP.Ui.j(this);return $APP.k(l)?wD(["`extract-tangent` not supported for type ",$APP.m.j(l),"."].join("")):sD(function(){return function(v){return IH(v,n,p)}}(a,b,c,d,l,this,g),this)}}(j0,k0,l0,m0,n0);$APP.e.ic=function(a,b,c,d,g){return function(l,
n){l=$APP.Ui.j(this);return $APP.k(l)?wD(["`extract-id` not supported for type ",$APP.m.j(l),"."].join("")):sD(function(){return function(p){return JH(p,n)}}(a,b,c,d,l,this,g),this)}}(j0,k0,l0,m0,n0);m0+=1}else{var o0=$APP.r(j0);if(o0){var p0=o0;if($APP.pd(p0)){var coc=$APP.lc(p0),doc=$APP.mc(p0),eoc=coc,foc=$APP.Tc(coc);j0=doc;k0=eoc;l0=foc}else{var q0=$APP.u(p0);MF.F(null,new $APP.H(null,1,5,$APP.I,[q0],null),function(){return function(a){return $APP.Ge(MF,$APP.pg(a))}}(j0,k0,l0,m0,q0,p0,o0));uG.F(null,
new $APP.H(null,1,5,$APP.I,[q0],null),function(){return function(){return!1}}(j0,k0,l0,m0,q0,p0,o0));kZ.F(null,new $APP.H(null,1,5,$APP.I,[q0],null),function(){return function(){return!1}}(j0,k0,l0,m0,q0,p0,o0));vG.F(null,new $APP.H(null,1,5,$APP.I,[q0],null),function(){return function(a){return sD(vG,a)}}(j0,k0,l0,m0,q0,p0,o0));VF.F(null,new $APP.H(null,1,5,$APP.I,[q0],null),function(){return function(a){return $APP.Ge(VF,$APP.pg(a))}}(j0,k0,l0,m0,q0,p0,o0));cG.F(null,new $APP.H(null,1,5,$APP.I,
[q0],null),function(){return function(a){return sD(cG,a)}}(j0,k0,l0,m0,q0,p0,o0));$APP.e=q0.prototype;$APP.e.rb=function(){return function(){return $APP.ld(this)?$APP.hb(this):$APP.Ui.A(this,$APP.hb(this))}}(j0,k0,l0,m0,q0,p0,o0);$APP.e.bc=function(){return function(){return new $APP.H(null,3,5,$APP.I,[PX,1,2],null)}}(j0,k0,l0,m0,q0,p0,o0);$APP.e.ac=function(a,b,c,d,g,l,n){return function(p,v,t){return sD(function(){return function(A){return HH(A,v,t)}}(a,b,c,d,this,g,l,n),this)}}(j0,k0,l0,m0,q0,
p0,o0);$APP.e.$b=function(a,b,c,d,g,l,n){return function(p,v,t){p=$APP.Ui.j(this);return $APP.k(p)?wD(["`extract-tangent` not supported for type ",$APP.m.j(p),"."].join("")):sD(function(){return function(A){return IH(A,v,t)}}(a,b,c,d,p,this,g,l,n),this)}}(j0,k0,l0,m0,q0,p0,o0);$APP.e.ic=function(a,b,c,d,g,l,n){return function(p,v){p=$APP.Ui.j(this);return $APP.k(p)?wD(["`extract-id` not supported for type ",$APP.m.j(p),"."].join("")):sD(function(){return function(t){return JH(t,v)}}(a,b,c,d,p,this,
g,l,n),this)}}(j0,k0,l0,m0,q0,p0,o0);j0=$APP.w(p0);k0=null;l0=0}m0=0}else break}$APP.ju.A($APP.ug,aQb);$APP.ju.A($APP.xg,aQb);gH.F(null,new $APP.H(null,2,5,$APP.I,[aQb,aQb],null),function(a,b){return $APP.kz.A(a,b)});
for(var r0=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.ug,$APP.xg],null)),s0=null,t0=0,u0=0;;)if(u0<t0){var v0=s0.aa(null,u0);MF.F(null,new $APP.H(null,1,5,$APP.I,[v0],null),function(){return function(a){return $APP.hd(a)}}(r0,s0,t0,u0,v0));uG.F(null,new $APP.H(null,1,5,$APP.I,[v0],null),function(){return function(){return!1}}(r0,s0,t0,u0,v0));kZ.F(null,new $APP.H(null,1,5,$APP.I,[v0],null),function(){return function(){return!1}}(r0,s0,t0,u0,v0));vG.F(null,new $APP.H(null,1,5,$APP.I,[v0],null),function(){return function(){return $APP.vg}}(r0,
s0,t0,u0,v0));VF.F(null,new $APP.H(null,1,5,$APP.I,[v0],null),function(){return function(a){return $APP.Ge(VF,a)}}(r0,s0,t0,u0,v0));v0.prototype.rb=function(){return function(){return $APP.hb(this)}}(r0,s0,t0,u0,v0);v0.prototype.bc=function(){return function(){return new $APP.H(null,3,5,$APP.I,[PX,1,2],null)}}(r0,s0,t0,u0,v0);u0+=1}else{var w0=$APP.r(r0);if(w0){var x0=w0;if($APP.pd(x0)){var goc=$APP.lc(x0),hoc=$APP.mc(x0),ioc=goc,joc=$APP.Tc(goc);r0=hoc;s0=ioc;t0=joc}else{var y0=$APP.u(x0);MF.F(null,
new $APP.H(null,1,5,$APP.I,[y0],null),function(){return function(a){return $APP.hd(a)}}(r0,s0,t0,u0,y0,x0,w0));uG.F(null,new $APP.H(null,1,5,$APP.I,[y0],null),function(){return function(){return!1}}(r0,s0,t0,u0,y0,x0,w0));kZ.F(null,new $APP.H(null,1,5,$APP.I,[y0],null),function(){return function(){return!1}}(r0,s0,t0,u0,y0,x0,w0));vG.F(null,new $APP.H(null,1,5,$APP.I,[y0],null),function(){return function(){return $APP.vg}}(r0,s0,t0,u0,y0,x0,w0));VF.F(null,new $APP.H(null,1,5,$APP.I,[y0],null),function(){return function(a){return $APP.Ge(VF,
a)}}(r0,s0,t0,u0,y0,x0,w0));y0.prototype.rb=function(){return function(){return $APP.hb(this)}}(r0,s0,t0,u0,y0,x0,w0);y0.prototype.bc=function(){return function(){return new $APP.H(null,3,5,$APP.I,[PX,1,2],null)}}(r0,s0,t0,u0,y0,x0,w0);r0=$APP.w(x0);s0=null;t0=0}u0=0}else break};mI.prototype.rb=function(){return lT};mI.prototype.Y=function(a,b){return oI.A?oI.A(this,b):oI.call(null,this,b)};mI.prototype.toString=function(){return["[",$APP.m.j(this.i)," mod ",$APP.m.j(this.ca),"]"].join("")};mI.prototype.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.modint.ModInt "',this.toString(),'"]']))};var z0=function z0(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return z0.C(c)};
z0.C=function(a){var b=$APP.Xs.B($APP.Vg.j(IWa),kG,a),c=$APP.Vg.j(function(d){var g=d.i;d=d.ca;var l=sI.A(b,d);return kG.C(g,l,$APP.y([JWa(l,d).i]))});return nI.A($APP.Xs.B(c,mG,a),b)};z0.G=0;z0.M=function(a){return this.C($APP.r(a))};var koc=qI(gH),loc=qI(AG),A0=qI(OF),moc=qI(CG),noc=qI(nI);hG.F(null,new $APP.H(null,2,5,$APP.I,[VM,lT],null),function(a,b){return oI(b,a)});hG.F(null,new $APP.H(null,2,5,$APP.I,[lT,VM],null),function(a,b){return oI(a,b)});
MF.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return MF.j(a.i)});uG.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return uG.j(a.i)});kZ.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return uG.j(a.i)});vG.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return new mI(vG.j(a.i),a.ca)});PF.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return new mI(PF.j(a.i),a.ca)});
lZ.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return new mI(PF.j(a.i),a.ca)});cG.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return new $APP.D(null,dUb,new $APP.D(null,a.i,new $APP.D(null,a.ca,null,1,null),2,null),3,null)});VF.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(){return!0});sZ.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return a.i});uZ.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(){return 0});
rZ.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return a});tZ.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return a});gH.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return koc(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return A0(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return A0(a,rI(b))});AG.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return loc(a,b)});
RF.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return pI(RF.j(a.i),a.ca)});QF.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return rI(a)});zG.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return nI.A(a.i,a.ca)});jG.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){var b=a.i;return $APP.k(sG.j(b))?pI(b,a.ca):a});sI.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return A0(a,rI(b))});
CG.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return moc(a,b)});nI.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return noc(a,b)});kM.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return A0(a,rI(b))});sG.F(null,new $APP.H(null,1,5,$APP.I,[lT],null),function(a){return sG.j(a.i)});tI.F(null,new $APP.H(null,2,5,$APP.I,[GG,lT],null),function(a,b){return KWa(a,b.i,b.ca)});
tI.F(null,new $APP.H(null,2,5,$APP.I,[lT,GG],null),function(a,b){return KWa(a.i,b,a.ca)});XF.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return A0(b,rI(a))});eR.F(null,new $APP.H(null,2,5,$APP.I,[lT,lT],null),function(a,b){return A0(a,rI(b))});
for(var B0=$APP.r(new $APP.H(null,3,5,$APP.I,[gH,OF,AG],null)),C0=null,D0=0,E0=0;;)if(E0<D0){var ooc=C0.aa(null,E0);ooc.F(null,new $APP.H(null,2,5,$APP.I,[GG,lT],null),function(a,b,c,d,g){return function(l,n){var p=n.i;l=g.A?g.A(l,p):g.call(null,l,p);return pI(l,n.ca)}}(B0,C0,D0,E0,ooc));ooc.F(null,new $APP.H(null,2,5,$APP.I,[lT,GG],null),function(a,b,c,d,g){return function(l,n){var p=l.i;n=g.A?g.A(p,n):g.call(null,p,n);return pI(n,l.ca)}}(B0,C0,D0,E0,ooc));E0+=1}else{var poc=$APP.r(B0);if(poc){var F0=
poc;if($APP.pd(F0)){var qoc=$APP.lc(F0),roc=$APP.mc(F0),soc=qoc,toc=$APP.Tc(qoc);B0=roc;C0=soc;D0=toc}else{var uoc=$APP.u(F0);uoc.F(null,new $APP.H(null,2,5,$APP.I,[GG,lT],null),function(a,b,c,d,g){return function(l,n){var p=n.i;l=g.A?g.A(l,p):g.call(null,l,p);return pI(l,n.ca)}}(B0,C0,D0,E0,uoc,F0,poc));uoc.F(null,new $APP.H(null,2,5,$APP.I,[lT,GG],null),function(a,b,c,d,g){return function(l,n){var p=l.i;n=g.A?g.A(p,n):g.call(null,p,n);return pI(n,l.ca)}}(B0,C0,D0,E0,uoc,F0,poc));B0=$APP.w(F0);C0=
null;D0=0}E0=0}else break}
for(var G0=$APP.r(new $APP.H(null,6,5,$APP.I,[BG,XF,eR,sI,CG,kM],null)),T0=null,U0=0,V0=0;;)if(V0<U0){var voc=T0.aa(null,V0);voc.F(null,new $APP.H(null,2,5,$APP.I,[GG,lT],null),function(a,b,c,d,g){return function(l,n){l=pI(l,n.ca);return g.A?g.A(l,n):g.call(null,l,n)}}(G0,T0,U0,V0,voc));voc.F(null,new $APP.H(null,2,5,$APP.I,[lT,GG],null),function(a,b,c,d,g){return function(l,n){n=pI(n,l.ca);return g.A?g.A(l,n):g.call(null,l,n)}}(G0,T0,U0,V0,voc));V0+=1}else{var woc=$APP.r(G0);if(woc){var W0=woc;if($APP.pd(W0)){var xoc=
$APP.lc(W0),yoc=$APP.mc(W0),zoc=xoc,Aoc=$APP.Tc(xoc);G0=yoc;T0=zoc;U0=Aoc}else{var Boc=$APP.u(W0);Boc.F(null,new $APP.H(null,2,5,$APP.I,[GG,lT],null),function(a,b,c,d,g){return function(l,n){l=pI(l,n.ca);return g.A?g.A(l,n):g.call(null,l,n)}}(G0,T0,U0,V0,Boc,W0,woc));Boc.F(null,new $APP.H(null,2,5,$APP.I,[lT,GG],null),function(a,b,c,d,g){return function(l,n){n=pI(n,l.ca);return g.A?g.A(l,n):g.call(null,l,n)}}(G0,T0,U0,V0,Boc,W0,woc));G0=$APP.w(W0);T0=null;U0=0}V0=0}else break};var Coc={},X0,Doc,AI=new $APP.Ac(function(){return $APP.Lt},llb,$APP.fg([$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.ky,$APP.Aj,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[$APP.An,$APP.$ya,"cljs/core.cljs",17,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(Apb)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Apb],null)),$APP.Cx,$APP.M(null)],null),1,9057,9057,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Apb],null)),"keyval \x3d\x3e key val\n  Returns a new sorted map with supplied mappings.",
$APP.k($APP.Lt)?$APP.Lt.Z:null])),uI=AI.J?AI.J():AI.call(null),nM=function nM(a){switch(arguments.length){case 1:return nM.j(arguments[0]);case 2:return nM.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};nM.j=function(a){return a};nM.A=function(a,b){var c=$APP.sg(a,$APP.ng(b));a=$APP.sg(b,$APP.ng(a));return $APP.Qo.C($APP.dt,$APP.y([c,a]))};nM.G=2;
var iM=function iM(a){switch(arguments.length){case 0:return iM.J();case 1:return iM.j(arguments[0]);case 2:return iM.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};iM.J=function(){return uI};iM.j=function(a){return a};iM.A=function(a,b){return $APP.Qo.C($APP.Hj,$APP.y([a,b]))};iM.G=2;var zI=function zI(a){switch(arguments.length){case 1:return zI.j(arguments[0]);case 2:return zI.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};zI.j=function(a){return new $APP.H(null,2,5,$APP.I,[uI,a],null)};zI.A=function(a,b){return new $APP.H(null,2,5,$APP.I,[a,b],null)};zI.G=2;
var YWa=QTa(new $APP.Ac(function(){return SWa},Z2b,$APP.fg([$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.Aj,$APP.im,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[$APP.z(k7b,new $APP.f(null,1,[$APP.Eza,!0],null)),blb,"emmy/polynomial/impl.cljc",32,1,!0,77,77,$APP.Ec,"This variable defines monomial order used in the construction and arithmetic of\n  polynomials. Bind this variable to a comparator on the exponents of each\n  monomial term.\n\n  Defaults to [[exponent/graded-lex-order]].",$APP.k(SWa)?SWa.Z:null])),
gH,MF,zI);var Y0=function Y0(a){switch(arguments.length){case 2:return Y0.A(arguments[0],arguments[1]);case 3:return Y0.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Y0.A=function(a,b){return $APP.Vg.A($APP.fd,BI(CI(dXa,gXa(b),a)))};Y0.B=function(a,b,c){return $APP.Vg.A($APP.fd,$APP.x.A(CI(dXa,gXa(b),a),c))};Y0.G=3;var Z0,Eoc=$APP.kh.j($APP.F),Foc=$APP.kh.j($APP.F),Goc=$APP.kh.j($APP.F),Hoc=$APP.kh.j($APP.F),Ioc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));Z0=new $APP.Ch($APP.Zg.A("emmy.special.factorial","falling-factorial"),LP,$APP.yj,Ioc,Eoc,Foc,Goc,Hoc);Z0.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,lWb],null);return b.j?b.j(a):b.call(null,a)});
Z0.F(null,$APP.yj,function(a,b){if(0===b)return 1;if(0>b){var c=function(){var d=gH.A(a,1),g=TF.j(b);return $0.A?$0.A(d,g):$0.call(null,d,g)}();return $APP.k(MF.j(c))?Infinity:QF.j(c)}return $APP.Xs.B($APP.Jl.A($APP.Vg.j(function(d){return gH.A(a,TF.j(d))}),$APP.Vg.j(oXa)),kG,$APP.Jj.j(b))});
Z0.F(null,new $APP.H(null,2,5,$APP.I,[IY,IY],null),function(a,b){if(0===b)return 1;if(0>b)return a+=1,b=-b,b=$0.A?$0.A(a,b):$0.call(null,a,b),$APP.k(MF.j(b))?Infinity:SF.A(1,b);b=$APP.Jj.B(a,a-b,-1);return $APP.Xs.B($APP.Vg.j(uD),kG,b)});var $0,Joc=$APP.kh.j($APP.F),Koc=$APP.kh.j($APP.F),Loc=$APP.kh.j($APP.F),Moc=$APP.kh.j($APP.F),Noc=$APP.C.B($APP.F,$APP.zm,$APP.th.J?$APP.th.J():$APP.th.call(null));$0=new $APP.Ch($APP.Zg.A("emmy.special.factorial","rising-factorial"),LP,$APP.yj,Noc,Joc,Koc,Loc,Moc);
$0.F(null,new $APP.H(null,1,5,$APP.I,[$APP.E],null),function(a){var b=new $APP.f(null,2,[ZH,new $APP.H(null,2,5,$APP.I,[hI,2],null),$APP.Q,Elb],null);return b.j?b.j(a):b.call(null,a)});$0.F(null,$APP.yj,function(a,b){return 0===b?1:0>b?(b=Z0.A(AG.A(a,1),TF.j(b)),$APP.k(MF.j(b))?Infinity:QF.j(b)):$APP.Xs.B($APP.Jl.A($APP.Vg.j(function(c){return gH.A(a,c)}),$APP.Vg.j(oXa)),kG,$APP.Jj.j(b))});
$0.F(null,new $APP.H(null,2,5,$APP.I,[IY,IY],null),function(a,b){if(0===b)return 1;if(0>b)return a=Z0.A(a-1,-b),$APP.k(MF.j(a))?Infinity:SF.A(1,a);a=$APP.Jj.A(a,a+b);return $APP.Xs.B($APP.Vg.j(uD),kG,a)});
var a1=function a1(a,b){if(0===b)return 1;if(0>a){if(0<b){var d=$APP.Ie(b)?1:-1,g=function(){var n=-a+b+-1;return a1.A?a1.A(n,b):a1.call(null,n,b)}();return kG.A?kG.A(d,g):kG.call(null,d,g)}if(b<=a){var l=a-b;d=$APP.Ie(l)?1:-1;g=function(){var n=-b-1;return a1.A?a1.A(n,l):a1.call(null,n,l)}();return kG.A?kG.A(d,g):kG.call(null,d,g)}return 0}if(0>b||b>a)return 0;g=function(){var n=a-b;return b<n?b:n}();d=Z0.A(a,g);g=HI(g);return SF.A?SF.A(d,g):SF.call(null,d,g)},b1=function b1(a){for(var c=[],d=arguments.length,
g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return b1.C(arguments[0],arguments[1],c)};
b1.C=function(a,b,c){c=$APP.qe(c);var d=$APP.C.A(c,E8b),g=$APP.kh.j(null);$APP.Ne(g,$APP.mh(function(l,n){if(0===l)return 0===n?1:0;var p=l-1,v=$APP.k(d)?p:-p;if(0===v){l=n-1;var t=$APP.Fb(g);return t.A?t.A(p,l):t.call(null,p,l)}l=function(){var A=n-1,B=$APP.Fb(g);return B.A?B.A(p,A):B.call(null,p,A)}();t=function(){var A=$APP.Fb(g);A=A.A?A.A(p,n):A.call(null,p,n);A=BigInt(A);return kG.A?kG.A(v,A):kG.call(null,v,A)}();return mG.A?mG.A(l,t):mG.call(null,l,t)}));if(0===b)return 0===a?1:0;if(b>a)return 0;
c=$APP.Fb(g);return c.A?c.A(a,b):c.call(null,a,b)};b1.G=2;b1.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var LI=function LI(a,b){var d=function n(l){return new $APP.de(null,function(){if($APP.k(MF.j($APP.u(l))))return $APP.Yd($APP.u(l),n($APP.Fc(l)));var p=OF.A($APP.u(l),$APP.u(b)),v=KI($APP.u(l),$APP.Fc(b)),t=n($APP.Fc(l));return $APP.Yd(p,sXa(v,t))},null,null)};return new $APP.de(null,function(){if($APP.k(MF.j($APP.u(b)))){var l=$APP.u(b);var n=$APP.Fc(b);n=LI.A?LI.A(a,n):LI.call(null,a,n);l=$APP.Yd(l,n)}else l=d(a);return l},null,null)},c1=function c1(a,b){return new $APP.de(null,function(){var d=
$APP.u(a),g=$APP.Fc(a),l=$APP.u(b),n=$APP.Fc(b);if($APP.k(function(){var v=MF.j(d);return $APP.k(v)?MF.j(l):v}()))return c1.A?c1.A(g,n):c1.call(null,g,n);if($APP.k(MF.j(d)))return $APP.Yd(d,c1.A?c1.A(g,b):c1.call(null,g,b));if($APP.k(MF.j(l)))return AD("ERROR: denominator has a zero constant term");var p=BG.A(d,l);return $APP.Yd(p,function(){var v=vXa(g,KI(p,n));return c1.A?c1.A(v,b):c1.call(null,v,b)}())},null,null)},NI=function NI(a){return new $APP.de(null,function(){var c=QF.j($APP.u(a)),d=LI($APP.Fc(a),
NI.j?NI.j(a):NI.call(null,a));d=KI(c,$APP.Vg.A(RF,d));return $APP.Yd(c,d)},null,null)},d1=function d1(a){var c=$APP.r(a),d=$APP.u(c);c=$APP.w(c);c=$APP.r(c);var g=$APP.u(c);c=$APP.w(c);if($APP.k(function(){var n=MF.j(d);return $APP.k(n)?MF.j(g):n}()))return $APP.Yd(d,d1.j?d1.j(c):d1.call(null,c));var l=lG.j(d);return function v(p){return new $APP.de(null,function(){return OI(c1($APP.Vg.B(kG,$APP.Fc(p),$APP.af($APP.Lc,1)),KI(2,v(p))),l)},null,null)}(a)};
$APP.N.A(new $APP.H(null,2,5,$APP.I,[0,0],null),$APP.af($APP.Lc,9));
var Ooc=new $APP.de(null,function(){return OI(Ooc,1)},null,null),f1=new $APP.de(null,function(){return OI(e1,0)},null,null),e1=new $APP.de(null,function(){return JI(1,OI(f1,0))},null,null),Poc=c1(f1,e1),Qoc=NI(e1),Roc=zXa(f1),Soc=OI($APP.Ve(new $APP.H(null,4,5,$APP.I,[1,0,-1,0],null)),0),Toc=JI(Math.PI/2,Roc),Uoc=JI(Math.PI/2,Soc),Voc=new $APP.de(null,function(){return OI(g1,1)},null,null),g1=new $APP.de(null,function(){return OI(Voc,0)},null,null),Woc=c1(g1,Voc),Xoc=zXa(g1),Yoc=zXa(Woc),Zoc=OI($APP.Vj.j(-1),
0),$oc=OI($APP.Ve(new $APP.H(null,2,5,$APP.I,[1,-1],null)),0),apc=$APP.N.A(new $APP.de(null,function(){return new $APP.H(null,1,5,$APP.I,[1],null)},null,null),new $APP.de(null,function(){return LI(apc,apc)},null,null)),cpc=$APP.N.A(new $APP.de(null,function(){return new $APP.H(null,1,5,$APP.I,[0],null)},null,null),new $APP.de(null,function(){return bpc},null,null)),dpc=$APP.N.A(new $APP.de(null,function(){return new $APP.H(null,1,5,$APP.I,[1],null)},null,null),new $APP.de(null,function(){return dpc},
null,null)),bpc=MI(dpc,cpc),epc=$APP.N.A(new $APP.de(null,function(){return new $APP.H(null,2,5,$APP.I,[0,1],null)},null,null),new $APP.de(null,function(){return $APP.Vg.B($APP.yr,epc,$APP.Fc(epc))},null,null)),fpc=$APP.Ut.A(mG,$APP.Vg.A(SF,$APP.af($APP.Lc,1))),gpc=$APP.Vg.A(rXa,$APP.af($APP.Lc,1));$APP.e=PI.prototype;$APP.e.toString=function(){return $APP.m.j(cG.j(this))};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.series.Series "',this.toString(),'"]']))};$APP.e.ba=function(){return this.ca};$APP.e.rb=function(){return sT};$APP.e.bc=function(){return UH($APP.u(this.xs))};$APP.e.ma=function(){return this.xs};$APP.e.da=function(a,b){return new PI(this.xs,b)};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Kb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){var a=this.xs;a=WI.A?WI.A(a,$APP.sf):WI.call(null,a,$APP.sf);return new PI(a,null)};$APP.e.j=function(a){var b=this.xs;a=new $APP.H(null,1,5,$APP.I,[a],null);b=WI.A?WI.A(b,a):WI.call(null,b,a);return new PI(b,null)};
$APP.e.A=function(a,b){var c=this.xs;a=new $APP.H(null,2,5,$APP.I,[a,b],null);c=WI.A?WI.A(c,a):WI.call(null,c,a);return new PI(c,null)};$APP.e.B=function(a,b,c){var d=this.xs;a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);d=WI.A?WI.A(d,a):WI.call(null,d,a);return new PI(d,null)};$APP.e.K=function(a,b,c,d){var g=this.xs;a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);g=WI.A?WI.A(g,a):WI.call(null,g,a);return new PI(g,null)};
$APP.e.S=function(a,b,c,d,g){var l=this.xs;a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);l=WI.A?WI.A(l,a):WI.call(null,l,a);return new PI(l,null)};$APP.e.la=function(a,b,c,d,g,l){var n=this.xs;a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);n=WI.A?WI.A(n,a):WI.call(null,n,a);return new PI(n,null)};$APP.e.Ga=function(a,b,c,d,g,l,n){var p=this.xs;a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);p=WI.A?WI.A(p,a):WI.call(null,p,a);return new PI(p,null)};
$APP.e.va=function(a,b,c,d,g,l,n,p){var v=this.xs;a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);v=WI.A?WI.A(v,a):WI.call(null,v,a);return new PI(v,null)};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){var t=this.xs;a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);t=WI.A?WI.A(t,a):WI.call(null,t,a);return new PI(t,null)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){var A=this.xs;a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);A=WI.A?WI.A(A,a):WI.call(null,A,a);return new PI(A,null)};
$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){var B=this.xs;a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);B=WI.A?WI.A(B,a):WI.call(null,B,a);return new PI(B,null)};$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){var G=this.xs;a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);G=WI.A?WI.A(G,a):WI.call(null,G,a);return new PI(G,null)};
$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){var J=this.xs;a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);J=WI.A?WI.A(J,a):WI.call(null,J,a);return new PI(J,null)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){var O=this.xs;a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);O=WI.A?WI.A(O,a):WI.call(null,O,a);return new PI(O,null)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){var R=this.xs;a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);R=WI.A?WI.A(R,a):WI.call(null,R,a);return new PI(R,null)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R){var W=this.xs;a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R],null);W=WI.A?WI.A(W,a):WI.call(null,W,a);return new PI(W,null)};
$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W){var Z=this.xs;a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W],null);Z=WI.A?WI.A(Z,a):WI.call(null,Z,a);return new PI(Z,null)};$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z){var fa=this.xs;a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z],null);fa=WI.A?WI.A(fa,a):WI.call(null,fa,a);return new PI(fa,null)};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa){var ia=this.xs;a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa],null);ia=WI.A?WI.A(ia,a):WI.call(null,ia,a);return new PI(ia,null)};$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia){var ja=this.xs;a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null);ja=WI.A?WI.A(ja,a):WI.call(null,ja,a);return new PI(ja,null)};
$APP.e.Kb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja){var ta=this.xs;a=$APP.N.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null),ja);ta=WI.A?WI.A(ta,a):WI.call(null,ta,a);return new PI(ta,null)};$APP.e.ac=function(a,b,c){function d(g){return HH(g,b,c)}return XI.A?XI.A(d,this):XI.call(null,d,this)};$APP.e.$b=function(a,b,c){function d(g){return IH(g,b,c)}return XI.A?XI.A(d,this):XI.call(null,d,this)};
$APP.e.ic=function(a,b){function c(d){return JH(d,b)}return XI.A?XI.A(c,this):XI.call(null,c,this)};$APP.e=RI.prototype;$APP.e.toString=function(){return $APP.m.j(cG.j(this))};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.series.PowerSeries "',this.toString(),'"]']))};$APP.e.ba=function(){return this.ca};$APP.e.rb=function(){return bV};$APP.e.bc=function(){return new $APP.H(null,2,5,$APP.I,[hI,1],null)};$APP.e.ma=function(){return this.xs};
$APP.e.da=function(a,b){return new RI(this.xs,b)};$APP.e.call=function(a){switch(arguments.length-1){case 1:return this.j(arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.j=function(a){return new PI(EXa.A?EXa.A(this.xs,a):EXa.call(null,this.xs,a),null)};$APP.e.ac=function(a,b,c){function d(g){return HH(g,b,c)}return XI.A?XI.A(d,this):XI.call(null,d,this)};
$APP.e.$b=function(a,b,c){function d(g){return IH(g,b,c)}return XI.A?XI.A(d,this):XI.call(null,d,this)};$APP.e.ic=function(a,b){function c(d){return JH(d,b)}return XI.A?XI.A(c,this):XI.call(null,c,this)};var h1=function h1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return h1.C(c)};h1.C=function(a){return UI(a)};h1.G=0;h1.M=function(a){return this.C($APP.r(a))};
var i1=function i1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return i1.C(c)};i1.C=function(a){return VI(a)};i1.G=0;i1.M=function(a){return this.C($APP.r(a))};
var hpc=UI(new $APP.H(null,1,5,$APP.I,[0],null)),ipc=UI(new $APP.H(null,1,5,$APP.I,[1],null)),jpc=UI(new $APP.H(null,2,5,$APP.I,[0,1],null)),kpc=VI(new $APP.H(null,1,5,$APP.I,[0],null)),lpc=VI(new $APP.H(null,1,5,$APP.I,[1],null)),mpc=VI(new $APP.H(null,2,5,$APP.I,[0,1],null)),j1=function j1(a){switch(arguments.length){case 1:return j1.j(arguments[0]);case 2:return j1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
j1.j=function(a){return VI(new $APP.H(null,1,5,$APP.I,[a],null))};j1.A=function(a,b){a=II(new $APP.H(null,1,5,$APP.I,[a],null));b=CXa(b);return b.A?b.A(a,null):b.call(null,a,null)};j1.G=2;var k1=function k1(a){switch(arguments.length){case 1:return k1.j(arguments[0]);case 2:return k1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};k1.j=function(a){return SI($APP.Vg.A(a,$APP.Jj.J()),null)};
k1.A=function(a,b){a=$APP.Vg.A(a,$APP.Jj.J());b=CXa(b);return b.A?b.A(a,null):b.call(null,a,null)};k1.G=2;var l1=function l1(a){switch(arguments.length){case 1:return l1.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return l1.C(arguments[0],c)}};l1.j=function(a){return l1.C(a,$APP.y([0]))};
l1.C=function(a,b){return SI(function n(d,g,l){return new $APP.de(null,function(){return $APP.Yd(SF.A($APP.Je.A(g,b),l),n(d+1,oR.A(g,$APP.sf),l*d))},null,null)}(1,a,1),null)};l1.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};l1.G=1;var m1=function m1(a){switch(arguments.length){case 1:return m1.j(arguments[0]);case 2:return m1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};m1.j=function(a){return m1.A(a,0)};
m1.A=function(a,b){return SI(OI($APP.r(a),b),$APP.ed(a))};m1.G=2;var QK=SI(Ooc,null),n1=SI(f1,null),o1=SI(e1,null),p1=SI(Poc,null),q1=SI(Qoc,null),r1=SI(Roc,null),s1=SI(Toc,null),t1=SI(Soc,null),u1=SI(Uoc,null),v1=SI(g1,null),w1=SI(Voc,null),x1=SI(Woc,null),y1=SI(Xoc,null),z1=SI(Yoc,null),npc=SI($oc,null),opc=SI(Zoc,null),ppc=QI(epc,null),qpc=QI(apc,null),rpc=QI(fpc,null),spc=QI(gpc,null);$APP.ju.A(HF,nT);$APP.ju.A(VH,nT);
for(var A1=$APP.r(new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[QI,sT],null),new $APP.H(null,2,5,$APP.I,[SI,bV],null)],null)),B1=null,C1=0,D1=0;;)if(D1<C1){var E1=B1.aa(null,D1),F1=$APP.x.B(E1,0,null),G1=$APP.x.B(E1,1,null);MF.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),function(){return function(){return!1}}(A1,B1,C1,D1,E1,F1,G1));uG.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),function(){return function(){return!1}}(A1,B1,C1,D1,E1,F1,G1));kZ.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),
function(){return function(){return!1}}(A1,B1,C1,D1,E1,F1,G1));gH.F(null,new $APP.H(null,2,5,$APP.I,[G1,G1],null),function(a,b,c,d,g,l){return function(n,p){n=sXa($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(A1,B1,C1,D1,E1,F1,G1));gH.F(null,new $APP.H(null,2,5,$APP.I,[nT,G1],null),function(a,b,c,d,g,l){return function(n,p){n=tXa(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(A1,B1,C1,D1,E1,F1,G1));gH.F(null,new $APP.H(null,2,5,$APP.I,[G1,nT],null),function(a,
b,c,d,g,l){return function(n,p){p=uXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));RF.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),function(a,b,c,d,g,l){return function(n){var p=$APP.Vg.A(RF,$APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));AG.F(null,new $APP.H(null,2,5,$APP.I,[G1,G1],null),function(a,b,c,d,g,l){return function(n,p){n=vXa($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(A1,B1,C1,D1,E1,
F1,G1));AG.F(null,new $APP.H(null,2,5,$APP.I,[nT,G1],null),function(a,b,c,d,g,l){return function(n,p){n=JI(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(A1,B1,C1,D1,E1,F1,G1));AG.F(null,new $APP.H(null,2,5,$APP.I,[G1,nT],null),function(a,b,c,d,g,l){return function(n,p){p=wXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));OF.F(null,new $APP.H(null,2,5,$APP.I,[G1,G1],null),function(a,b,c,d,g,l){return function(n,p){n=LI($APP.r(n),$APP.r(p));
return l.A?l.A(n,null):l.call(null,n,null)}}(A1,B1,C1,D1,E1,F1,G1));OF.F(null,new $APP.H(null,2,5,$APP.I,[nT,G1],null),function(a,b,c,d,g,l){return function(n,p){n=KI(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(A1,B1,C1,D1,E1,F1,G1));OF.F(null,new $APP.H(null,2,5,$APP.I,[G1,nT],null),function(a,b,c,d,g,l){return function(n,p){p=xXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));nG.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),function(a,
b,c,d,g,l){return function(n){var p=$APP.r(n);p=LI(p,p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));qZ.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),function(a,b,c,d,g,l){return function(n){var p=$APP.r(n);p=LI(LI(p,p),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));tI.F(null,new $APP.H(null,2,5,$APP.I,[G1,IY],null),function(a,b,c,d,g,l){return function(n,p){p=AXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,
D1,E1,F1,G1));QF.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),function(a,b,c,d,g,l){return function(n){var p=NI($APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));BG.F(null,new $APP.H(null,2,5,$APP.I,[nT,G1],null),function(a,b,c,d,g,l){return function(n,p){var v=$APP.r(p);n=KI(n,NI(v));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(A1,B1,C1,D1,E1,F1,G1));BG.F(null,new $APP.H(null,2,5,$APP.I,[G1,nT],null),function(a,b,c,d,g,l){return function(n,p){p=yXa($APP.r(n),
p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));BG.F(null,new $APP.H(null,2,5,$APP.I,[G1,G1],null),function(a,b,c,d,g,l){return function(n,p){n=c1($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(A1,B1,C1,D1,E1,F1,G1));eR.F(null,new $APP.H(null,2,5,$APP.I,[nT,G1],null),function(){return function(a,b){return BG.A(a,b)}}(A1,B1,C1,D1,E1,F1,G1));eR.F(null,new $APP.H(null,2,5,$APP.I,[G1,nT],null),function(){return function(a,b){return BG.A(a,b)}}(A1,B1,C1,
D1,E1,F1,G1));eR.F(null,new $APP.H(null,2,5,$APP.I,[G1,G1],null),function(){return function(a,b){return BG.A(a,b)}}(A1,B1,C1,D1,E1,F1,G1));XF.F(null,new $APP.H(null,2,5,$APP.I,[nT,G1],null),function(){return function(a,b){return BG.A(b,a)}}(A1,B1,C1,D1,E1,F1,G1));XF.F(null,new $APP.H(null,2,5,$APP.I,[G1,nT],null),function(){return function(a,b){return BG.A(b,a)}}(A1,B1,C1,D1,E1,F1,G1));XF.F(null,new $APP.H(null,2,5,$APP.I,[G1,G1],null),function(){return function(a,b){return BG.A(b,a)}}(A1,B1,C1,D1,
E1,F1,G1));lG.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),function(a,b,c,d,g,l){return function(n){var p=d1($APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,E1,F1,G1));dG.F(null,new $APP.H(null,1,5,$APP.I,[G1],null),function(){return function(a){return XI(dG,a)}}(A1,B1,C1,D1,E1,F1,G1));D1+=1}else{var H1=$APP.r(A1);if(H1){var I1=H1;if($APP.pd(I1)){var tpc=$APP.lc(I1),upc=$APP.mc(I1),vpc=tpc,wpc=$APP.Tc(tpc);A1=upc;B1=vpc;C1=wpc}else{var J1=$APP.u(I1),K1=$APP.x.B(J1,0,null),
L1=$APP.x.B(J1,1,null);MF.F(null,new $APP.H(null,1,5,$APP.I,[L1],null),function(){return function(){return!1}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));uG.F(null,new $APP.H(null,1,5,$APP.I,[L1],null),function(){return function(){return!1}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));kZ.F(null,new $APP.H(null,1,5,$APP.I,[L1],null),function(){return function(){return!1}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));gH.F(null,new $APP.H(null,2,5,$APP.I,[L1,L1],null),function(a,b,c,d,g,l){return function(n,p){n=sXa($APP.r(n),$APP.r(p));return l.A?
l.A(n,null):l.call(null,n,null)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));gH.F(null,new $APP.H(null,2,5,$APP.I,[nT,L1],null),function(a,b,c,d,g,l){return function(n,p){n=tXa(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));gH.F(null,new $APP.H(null,2,5,$APP.I,[L1,nT],null),function(a,b,c,d,g,l){return function(n,p){p=uXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));RF.F(null,new $APP.H(null,1,5,$APP.I,[L1],null),function(a,
b,c,d,g,l){return function(n){var p=$APP.Vg.A(RF,$APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));AG.F(null,new $APP.H(null,2,5,$APP.I,[L1,L1],null),function(a,b,c,d,g,l){return function(n,p){n=vXa($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));AG.F(null,new $APP.H(null,2,5,$APP.I,[nT,L1],null),function(a,b,c,d,g,l){return function(n,p){n=JI(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(A1,
B1,C1,D1,J1,K1,L1,I1,H1));AG.F(null,new $APP.H(null,2,5,$APP.I,[L1,nT],null),function(a,b,c,d,g,l){return function(n,p){p=wXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));OF.F(null,new $APP.H(null,2,5,$APP.I,[L1,L1],null),function(a,b,c,d,g,l){return function(n,p){n=LI($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));OF.F(null,new $APP.H(null,2,5,$APP.I,[nT,L1],null),function(a,b,c,d,g,l){return function(n,
p){n=KI(n,$APP.r(p));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));OF.F(null,new $APP.H(null,2,5,$APP.I,[L1,nT],null),function(a,b,c,d,g,l){return function(n,p){p=xXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));nG.F(null,new $APP.H(null,1,5,$APP.I,[L1],null),function(a,b,c,d,g,l){return function(n){var p=$APP.r(n);p=LI(p,p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));qZ.F(null,
new $APP.H(null,1,5,$APP.I,[L1],null),function(a,b,c,d,g,l){return function(n){var p=$APP.r(n);p=LI(LI(p,p),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));tI.F(null,new $APP.H(null,2,5,$APP.I,[L1,IY],null),function(a,b,c,d,g,l){return function(n,p){p=AXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));QF.F(null,new $APP.H(null,1,5,$APP.I,[L1],null),function(a,b,c,d,g,l){return function(n){var p=NI($APP.r(n));n=$APP.ed(n);
return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));BG.F(null,new $APP.H(null,2,5,$APP.I,[nT,L1],null),function(a,b,c,d,g,l){return function(n,p){var v=$APP.r(p);n=KI(n,NI(v));p=$APP.ed(p);return l.A?l.A(n,p):l.call(null,n,p)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));BG.F(null,new $APP.H(null,2,5,$APP.I,[L1,nT],null),function(a,b,c,d,g,l){return function(n,p){p=yXa($APP.r(n),p);n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));BG.F(null,new $APP.H(null,2,5,$APP.I,
[L1,L1],null),function(a,b,c,d,g,l){return function(n,p){n=c1($APP.r(n),$APP.r(p));return l.A?l.A(n,null):l.call(null,n,null)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));eR.F(null,new $APP.H(null,2,5,$APP.I,[nT,L1],null),function(){return function(a,b){return BG.A(a,b)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));eR.F(null,new $APP.H(null,2,5,$APP.I,[L1,nT],null),function(){return function(a,b){return BG.A(a,b)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));eR.F(null,new $APP.H(null,2,5,$APP.I,[L1,L1],null),function(){return function(a,b){return BG.A(a,
b)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));XF.F(null,new $APP.H(null,2,5,$APP.I,[nT,L1],null),function(){return function(a,b){return BG.A(b,a)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));XF.F(null,new $APP.H(null,2,5,$APP.I,[L1,nT],null),function(){return function(a,b){return BG.A(b,a)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));XF.F(null,new $APP.H(null,2,5,$APP.I,[L1,L1],null),function(){return function(a,b){return BG.A(b,a)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));lG.F(null,new $APP.H(null,1,5,$APP.I,[L1],null),function(a,b,c,d,g,l){return function(n){var p=
d1($APP.r(n));n=$APP.ed(n);return l.A?l.A(p,n):l.call(null,p,n)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));dG.F(null,new $APP.H(null,1,5,$APP.I,[L1],null),function(){return function(a){return XI(dG,a)}}(A1,B1,C1,D1,J1,K1,L1,I1,H1));A1=$APP.w(I1);B1=null;C1=0}D1=0}else break}qG.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Ooc,$APP.r(a)),$APP.ed(a))});hO.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(e1,$APP.r(a)),$APP.ed(a))});
iO.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(f1,$APP.r(a)),$APP.ed(a))});vZ.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Poc,$APP.r(a)),$APP.ed(a))});yZ.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Qoc,$APP.r(a)),$APP.ed(a))});zZ.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Roc,$APP.r(a)),$APP.ed(a))});mO.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Toc,$APP.r(a)),$APP.ed(a))});
tG.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Soc,$APP.r(a)),$APP.ed(a))});AZ.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Uoc,$APP.r(a)),$APP.ed(a))});vH.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Voc,$APP.r(a)),$APP.ed(a))});xH.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(g1,$APP.r(a)),$APP.ed(a))});DZ.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Woc,$APP.r(a)),$APP.ed(a))});
IZ.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Xoc,$APP.r(a)),$APP.ed(a))});JZ.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){return SI(MI(Yoc,$APP.r(a)),$APP.ed(a))});oR.F(null,new $APP.H(null,2,5,$APP.I,[sT,$R],null),function(a,b){return QI($APP.Vg.A(function(c){return oR.A(c,b)},a.xs),a.ca)});
oR.F(null,new $APP.H(null,2,5,$APP.I,[bV,$R],null),function(a,b){return $APP.hd(b)?SI($APP.Vg.B(kG,$APP.Fc(a.xs),$APP.af($APP.Lc,1)),a.ca):yD(["Cannot yet take partial derivatives of a power series: ",$APP.m.j(a),$APP.m.j(b)].join(""))});vG.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(){return kpc});PF.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(){return lpc});lZ.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(){return mpc});
vG.F(null,new $APP.H(null,1,5,$APP.I,[sT],null),function(){return hpc});PF.F(null,new $APP.H(null,1,5,$APP.I,[sT],null),function(){return ipc});lZ.F(null,new $APP.H(null,1,5,$APP.I,[sT],null),function(){return jpc});VF.F(null,new $APP.H(null,1,5,$APP.I,[sT],null),function(){return!1});VF.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(){return!1});
cG.F(null,new $APP.H(null,1,5,$APP.I,[bV],null),function(a){a=$APP.Lf.B($APP.sf,$APP.Jl.A($APP.ip.j(function(b,c){return $APP.k(MF.j(c))?$APP.sf:$APP.k(uG.j(c))?new $APP.H(null,1,5,$APP.I,[new $APP.D(null,FJ,new $APP.D(null,$APP.Kv,new $APP.D(null,b,null,1,null),2,null),3,null)],null):new $APP.H(null,1,5,$APP.I,[new $APP.D(null,$APP.Hv,new $APP.D(null,c,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,$APP.Kv,new $APP.D(null,b,null,1,null),2,null),3,null),null,1,null),2,null),3,null)],null)}),$APP.eh),
cG.j(dG.j($APP.We.A(4,a.xs))));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),a,$APP.y([new $APP.D(null,tpb,null,1,null)]))))});cG.F(null,new $APP.H(null,1,5,$APP.I,[sT],null),function(a){a=cG.j(dG.j($APP.We.A(4,a.xs)));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Iv,null,1,null),a,$APP.y([new $APP.D(null,tpb,null,1,null)]))))});var M1=function M1(a){function c(n){var p=OXa(eJ,M1,n);return $APP.od(n)?$APP.Lf.B($APP.sf,$APP.eh,p):$APP.Yd($APP.GCa,$APP.Je.A($APP.N,p))}if(a instanceof $APP.q)return new $APP.D(null,$APP.K,new $APP.D(null,a,null,1,null),2,null);if(dJ(a)||eJ(a))return $APP.Xc(a);if($APP.kd(a)){if($APP.k(function(){var n=KXa(a);if($APP.k(n))return n;n=$I(a);return $APP.k(n)?n:aJ(a)}())){var d=$APP.r(a),g=$APP.u(d),l=$APP.w(d);d=$APP.u(l);l=$APP.w(l);if(eJ(d))return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,sUb,null,
1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,g,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.sy,null,1,null),new $APP.D(null,$APP.Xc(d),null,1,null),$APP.y([new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(l)))),null,1,null)])))),null,1,null)]))));d=dJ(d)?$APP.Xc(d):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,d,null,1,null))));return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,
$APP.GCa,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,g,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,d,null,1,null),l]))))}return c(a)}return $APP.md(a)?sD(M1,a):a};var N1=function N1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return N1.C(arguments[0],c)};N1.C=function(a,b){return function(c,d,g){c=$APP.Je.B(a,c,b);return $APP.k(c)?g.j?g.j(c):g.call(null,c):null}};N1.G=1;N1.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var O1=function O1(a){switch(arguments.length){case 1:return O1.j(arguments[0]);case 2:return O1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};O1.j=function(a){return O1.A(a,$APP.Uc)};O1.A=function(a,b){return XXa(function(c){return b.A?b.A(a,c):b.call(null,a,c)})};O1.G=2;
var rK=function rK(a){switch(arguments.length){case 1:return rK.j(arguments[0]);case 2:return rK.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};rK.j=function(a){return rK.A(a,function(){return!0})};
rK.A=function(a,b){return YI(a)?XXa(b):function(c,d,g){if($APP.k(b.j?b.j(d):b.call(null,d))){var l=$APP.Dd(c,a);if($APP.k(l))return $APP.x.B(l,0,null),l=$APP.x.B(l,1,null),(d=$APP.Uc.A(l,d))?g.j?g.j(c):g.call(null,c):d;c=$APP.rg.B(c,a,d);return g.j?g.j(c):g.call(null,c)}return null}};rK.G=2;
var P1=function P1(a){switch(arguments.length){case 2:return P1.A(arguments[0],arguments[1]);case 3:return P1.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};P1.A=function(a,b){return ZXa(a,b)};P1.B=function(a,b,c){var d=hJ.j?hJ.j(b):hJ.call(null,b),g=hJ.j?hJ.j(c):hJ.call(null,c);return function(l,n,p){return $APP.k(a.j?a.j(n):a.call(null,n))?d.B?d.B(l,n,p):d.call(null,l,n,p):g.B?g.B(l,n,p):g.call(null,l,n,p)}};P1.G=3;
var tK=function tK(a){switch(arguments.length){case 0:return tK.J();case 1:return tK.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return tK.C(arguments[0],c)}};tK.J=function(){return VXa};tK.j=function(a){return hJ.j?hJ.j(a):hJ.call(null,a)};tK.C=function(a,b){var c=$APP.Vg.A(hJ,$APP.Yd(a,b));return function(d,g,l){return $APP.He(function(n){return n.B?n.B(d,g,l):n.call(null,d,g,l)},c)}};
tK.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};tK.G=1;var uK=function uK(a){switch(arguments.length){case 0:return uK.J();case 1:return uK.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return uK.C(arguments[0],c)}};uK.J=function(){return WXa};uK.j=function(a){return hJ.j?hJ.j(a):hJ.call(null,a)};
uK.C=function(a,b){var c=$APP.Vg.A(hJ,$APP.Yd(a,b));return function(d,g,l){return $APP.Id.B(function(n,p){return $APP.k(n)?p.B?p.B(n,g,l):p.call(null,n,g,l):$APP.Mc(n)},d,c)}};uK.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};uK.G=1;var Q1=function Q1(a){switch(arguments.length){case 1:return Q1.j(arguments[0]);case 2:return Q1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Q1.j=function(a){return Q1.A(a,$APP.Le(!0))};
Q1.A=function(a,b){return bYa(function(c,d,g){d=$APP.k(d)?d:$APP.sf;if($APP.kd(d)){var l=function(){var t=!YI(a);return t?c.j?c.j(a):c.call(null,a):t}();if($APP.k(l)){if($APP.k(b.j?b.j(l):b.call(null,l))){var n=$APP.Tc(l);if($APP.Uc.A($APP.We.A(n,d),l))return d=$APP.Se.A(n,d),g.A?g.A(c,d):g.call(null,c,d)}return null}for(var p=$APP.sf,v=d;;)if(d=function(){var t=b.j?b.j(p):b.call(null,p);return $APP.k(t)?(t=YI(a)?c:$APP.rg.B(c,a,p),g.A?g.A(t,v):g.call(null,t,v)):t}(),!$APP.k(d)&&(d=$APP.r(v)))d=$APP.Vd.A(p,
$APP.u(v)),l=$APP.w(v),p=d,v=l;else return d}else return null})};Q1.G=2;var R1=function R1(a){switch(arguments.length){case 1:return R1.j(arguments[0]);case 2:return R1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};R1.j=function(a){return R1.A(a,$APP.Le(!0))};
R1.A=function(a,b){return bYa(function(c,d,g){d=$APP.k(d)?d:$APP.sf;if($APP.kd(d)){var l=c.j?c.j(a):c.call(null,a);if($APP.k(l)&&$APP.od(l)){var n=$APP.Tc(l);l=$APP.Qb(l);l=(l=$APP.Uc.A($APP.We.A(n,d),l))?b.j?b.j(d):b.call(null,d):l;if($APP.k(l))return d=$APP.Se.A(n,d),g.A?g.A(c,d):g.call(null,c,d)}}return null})};R1.G=2;var S1=function S1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return S1.C(c)};S1.C=function(a){return dYa(a)};
S1.G=0;S1.M=function(a){return this.C($APP.r(a))};var hJ=function hJ(a){if($APP.cd(a))var c=a;else if($APP.k(KXa(a)))c=rK.A(bJ(a),cJ(a));else if($APP.k($I(a)))c=Q1.A(bJ(a),cJ(a));else if($APP.k(aJ(a)))c=R1.A(NXa(a),cJ(a));else if(YI(a))c=WXa;else if($APP.td(a)||$APP.od(a))if($APP.hd(a))c=O1.j(a);else{c=$APP.N.A;var d=$APP.Vg.A(hJ,$APP.zg(a));a=$APP.$c(a);a=new $APP.H(null,1,5,$APP.I,[$APP.k($I(a))?cYa(bJ(a),cJ(a)):hJ.j?hJ.j(a):hJ.call(null,a)],null);c=dYa(c.call($APP.N,d,a))}else c=O1.j(a);return c};
$APP.e=iJ.prototype;$APP.e.Ka=function(a,b){return this.fa(null,b,null)};$APP.e.fa=function(a,b,c){return $APP.C.B(this.N,b,c)};$APP.e.lb=function(a,b,c){return $APP.Id.B(function(d,g){var l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return b.B?b.B(d,l,g):b.call(null,d,l,g)},c,this)};$APP.e.ea=function(a,b,c){return $APP.Rg(b,function(d){return $APP.Rg(b,$APP.Ug,""," ","",c,d)},"#emmy.pattern.match.Failure{",", ","}",c,$APP.N.A($APP.sf,this.N))};
$APP.e.Qa=function(){return new $APP.Ff(this,0,$APP.sf,$APP.k(this.N)?$APP.qc(this.N):$APP.we())};$APP.e.ba=function(){return this.R};$APP.e.qa=function(){return new iJ(this.R,this.N,this.P)};$APP.e.ta=function(){return 0+$APP.Tc(this.N)};$APP.e.ka=function(){var a=this.P;return null!=a?a:this.P=a=-73365589^$APP.Kc(this)};$APP.e.Y=function(a,b){return null!=b&&this.constructor===b.constructor&&$APP.Uc.A(this.N,b.N)};
$APP.e.Hb=function(a,b){return $APP.Bd($APP.vg,b)?$APP.Oi.A($APP.Ib($APP.Lf.A($APP.F,this),this.R),b):new iJ(this.R,$APP.re($APP.Oi.A(this.N,b)),null)};$APP.e.Va=function(a,b){return $APP.Bd(this.N,b)};$APP.e.sa=function(a,b,c){return new iJ(this.R,$APP.rg.B(this.N,b,c),null)};$APP.e.ma=function(){return $APP.r($APP.N.A($APP.sf,this.N))};$APP.e.da=function(a,b){return new iJ(b,this.N,this.P)};
$APP.e.ua=function(a,b){return $APP.od(b)?this.sa(null,$APP.bd(b,0),$APP.bd(b,1)):$APP.Id.B($APP.nb,this,b)};var lJ=new iJ(null,null,null),kJ=function kJ(a){switch(arguments.length){case 1:return kJ.j(arguments[0]);case 2:return kJ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};kJ.j=function(a){var b=hJ(a);return function(c){c=b.B?b.B($APP.F,c,$APP.Kd):b.call(null,$APP.F,c,$APP.Kd);return $APP.k(c)?c:lJ}};
kJ.A=function(a,b){function c(g){var l=b.j?b.j(g):b.call(null,g);return $APP.k(l)?$APP.k($APP.k(l)?$Xa(jJ(l)):l)?$APP.md(l)?$APP.Ni.C($APP.y([g,l])):g:null:null}var d=hJ(a);return function(g){g=d.B?d.B($APP.F,g,c):d.call(null,$APP.F,g,c);return $APP.k(g)?g:lJ}};kJ.G=2;var T1=function T1(a){switch(arguments.length){case 2:return T1.A(arguments[0],arguments[1]);case 3:return T1.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
T1.A=function(a,b){return kJ.j(a)(b)};T1.B=function(a,b,c){return kJ.A(a,b)(c)};T1.G=3;var zJ=$APP.Le(!0),xpc=$APP.Le(!1),xJ=function xJ(a){switch(arguments.length){case 1:return xJ.j(arguments[0]);case 2:return xJ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};xJ.j=function(a){return kJ.j(a)};xJ.A=function(a,b){return $APP.k($APP.k(b)?$APP.qg.A(b,zJ):b)?kJ.A(a,b):kJ.j(a)};xJ.G=2;
var U1=function U1(a){switch(arguments.length){case 3:return U1.B(arguments[0],arguments[1],arguments[2]);case 4:return U1.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};U1.B=function(a,b,c){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,a0b,null,1,null),new $APP.D(null,M1(c),null,1,null))))};
U1.K=function(a,b,c,d){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,a0b,null,1,null),new $APP.D(null,M1(c),null,1,null),$APP.y([$APP.k(d)?new $APP.H(null,1,5,$APP.I,[d],null):null]))))};U1.G=4;var V1=function V1(a){switch(arguments.length){case 3:return V1.B(arguments[0],arguments[1],arguments[2]);case 4:return V1.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
V1.B=function(a,b,c){$APP.rg.B(b,BX,!0);return UXa($APP.F,c)};V1.K=function(a,b,c,d){$APP.rg.B(b,BX,!0);a=$APP.Oj.J();return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,a,null,1,null),new $APP.D(null,c,null,1,null))))),null,1,null),$APP.y([new $APP.D(null,UXa(a,d),null,1,null)]))))};V1.G=4;
var W1=function W1(a){switch(arguments.length){case 2:return W1.A(arguments[0],arguments[1]);case 3:return W1.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};W1.A=function(a,b){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,fub,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,L2b,null,1,null),new $APP.D(null,a,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,b,null,1,null)]))))};
W1.B=function(a,b,c){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,fub,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,L2b,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,Zgb,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)]))))};W1.G=3;
var X1=function X1(a){switch(arguments.length){case 4:return X1.K(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return X1.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};X1.K=function(a,b,c,d){$APP.rg.B(b,BX,!0);return W1.A(c,d)};X1.S=function(a,b,c,d,g){$APP.rg.B(b,BX,!0);return W1.B(c,d,g)};X1.G=5;
var oJ=function oJ(a){switch(arguments.length){case 0:return oJ.J();case 1:return oJ.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return oJ.C(arguments[0],c)}};oJ.J=function(){return hYa};oJ.j=function(a){return a};oJ.C=function(a,b){return kYa($APP.Yd(a,b))};oJ.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};oJ.G=1;
var qJ=function qJ(a){switch(arguments.length){case 0:return qJ.J();case 1:return qJ.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return qJ.C(arguments[0],c)}};qJ.J=function(){return gYa};qJ.j=function(a){return a};qJ.C=function(a,b){return lYa($APP.Yd(a,b))};qJ.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};qJ.G=1;
var Y1=function Y1(a){switch(arguments.length){case 1:return Y1.j(arguments[0]);case 2:return Y1.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Y1.j=function(a){return Y1.A(a,$APP.Zt)};Y1.A=function(a,b){var c=$APP.Oj.j("t_");return function(d){var g=new $APP.f(null,2,[$APP.Yl,c,G4b,d],null);b.j?b.j(g):b.call(null,g);d=a.j?a.j(d):a.call(null,d);g=new $APP.f(null,2,[$APP.Yl,c,lDb,d],null);b.j?b.j(g):b.call(null,g);return d}};Y1.G=2;
var wJ=function wJ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return wJ.C(c)};wJ.C=function(a){return pJ($APP.Je.A(oJ,a))};wJ.G=0;wJ.M=function(a){return this.C($APP.r(a))};var Z1=function Z1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return Z1.C(arguments[0],arguments[1],c)};
Z1.C=function(a,b,c){$APP.rg.B(b,BX,!0);$APP.Tc(c);a=$APP.Ll.A(3,c);a=$APP.Vg.A(function(d){return $APP.Je.A(W1,d)},a);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,kub,null,1,null),a)))};Z1.G=2;Z1.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var AJ=function AJ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return AJ.C(c)};
AJ.C=function(a){return qYa($APP.Je.A(qJ,$APP.Vg.A(pJ,a)))};AJ.G=0;AJ.M=function(a){return this.C($APP.r(a))};var $1=function $1(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return $1.C(c)};$1.C=function(a){return $APP.Je.A(AJ,a)};$1.G=0;$1.M=function(a){return this.C($APP.r(a))};var a2=function a2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return a2.C(c)};a2.C=function(a){a=$APP.Lf.A($APP.vg,a);return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),zJ),function(b){b=EJ.j?EJ.j(b):EJ.call(null,b);return $APP.k(b)?b:fJ(b)})]))};a2.G=0;a2.M=function(a){return this.C($APP.r(a))};
var b2=function b2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return b2.C(c)};
b2.C=function(a){function b(c){return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,c,new $APP.D(null,yJ,null,1,null),2,null),zJ),function(d){d=$APP.tf(yJ.j?yJ.j(d):yJ.call(null,d));return $APP.k(d)?d:fJ(d)}),mJ(xJ.A(EJ,zJ),function(d){d=$APP.tf(new $APP.H(null,1,5,$APP.I,[EJ.j?EJ.j(d):EJ.call(null,d)],null));return $APP.k(d)?d:fJ(d)})]))}a=$APP.Lf.A($APP.vg,a);return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,VJ,
new $APP.D(null,new $APP.D(null,sK,new $APP.D(null,WJ,null,1,null),2,null),new $APP.D(null,XJ,null,1,null),2,null),3,null),4,null),zJ),function(c){var d=$APP.N.C,g=new $APP.H(null,1,5,$APP.I,[sK.j?sK.j(c):sK.call(null,c)],null),l=VJ.j?VJ.j(c):VJ.call(null,c),n=$APP.qe(c);c=$APP.C.A(n,sK);var p=$APP.C.A(n,WJ);n=$APP.C.A(n,XJ);c=$APP.bf.C(b(c),$APP.y([$APP.N.A(p,n)]));return(d=$APP.r(d.call($APP.N,g,l,$APP.y([c]))))?d:fJ(d)})]))};b2.G=0;b2.M=function(a){return this.C($APP.r(a))};
var c2=function c2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return c2.C(c)};
c2.C=function(a){a=$APP.Lf.A($APP.vg,a);return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,yJ,null,1,null),2,null),zJ),function(b){var c=$APP.N.A,d=new $APP.H(null,1,5,$APP.I,[sK.j?sK.j(b):sK.call(null,b)],null);b=SSa(b.j?b.j(yJ):b.call(null,yJ));return(c=$APP.r(c.call($APP.N,d,b)))?c:fJ(c)})]))};c2.G=0;c2.M=function(a){return this.C($APP.r(a))};
var d2=function d2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return d2.C(c)};
d2.C=function(a){a=$APP.Lf.A($APP.vg,a);return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,JV,new $APP.D(null,EJ,new $APP.D(null,EJ,new $APP.D(null,JX,null,1,null),2,null),3,null),4,null),5,null),zJ),function(b){var c=$APP.N.A,d=new $APP.H(null,1,5,$APP.I,[sK.j?sK.j(b):sK.call(null,b)],null);var g=$APP.Gl.j;b=$APP.r($APP.N.C(JV.j?JV.j(b):JV.call(null,b),new $APP.H(null,1,5,$APP.I,[EJ.j?EJ.j(b):EJ.call(null,
b)],null),$APP.y([JX.j?JX.j(b):JX.call(null,b)])));g=g.call($APP.Gl,b?b:fJ(b));return(c=$APP.r(c.call($APP.N,d,g)))?c:fJ(c)})]))};d2.G=0;d2.M=function(a){return this.C($APP.r(a))};
var ypc=wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,sK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,QU,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){var b=$APP.I,c=sK.j?sK.j(a):sK.call(null,a);a=mG.A(a.j?a.j(CJ):a.call(null,CJ),a.j?a.j(QU):a.call(null,QU));return(b=$APP.r(new $APP.H(null,
3,5,b,[FJ,c,a],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,JV,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,sK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,sK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,QU,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,JX,null,1,null),2,null),3,null),
4,null),5,null),zJ),function(a){var b=$APP.N.C,c=new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),d=JV.j?JV.j(a):JV.call(null,a),g=$APP.I,l=$APP.I,n=sK.j?sK.j(a):sK.call(null,a);var p=mG.A(a.j?a.j(CJ):a.call(null,CJ),a.j?a.j(QU):a.call(null,QU));return(a=$APP.r(b.call($APP.N,c,d,$APP.y([new $APP.H(null,1,5,g,[$APP.r(new $APP.H(null,3,5,l,[FJ,n,p],null))],null),JX.j?JX.j(a):JX.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,JV,new $APP.D(null,sK,new $APP.D(null,new $APP.D(null,
FJ,new $APP.D(null,sK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,JX,null,1,null),2,null),3,null),4,null),5,null),zJ),function(a){var b=$APP.N.C,c=new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),d=JV.j?JV.j(a):JV.call(null,a),g=$APP.I,l=$APP.I,n=sK.j?sK.j(a):sK.call(null,a);var p=mG.A(a.j?a.j(CJ):a.call(null,CJ),1);return(a=$APP.r(b.call($APP.N,c,d,$APP.y([new $APP.H(null,1,5,g,[$APP.r(new $APP.H(null,
3,5,l,[FJ,n,p],null))],null),JX.j?JX.j(a):JX.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,JV,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,sK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,sK,new $APP.D(null,JX,null,1,null),2,null),3,null),4,null),5,null),zJ),function(a){var b=$APP.N.C,c=new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),d=JV.j?JV.j(a):JV.call(null,a),g=
$APP.I,l=$APP.I,n=sK.j?sK.j(a):sK.call(null,a);var p=mG.A(a.j?a.j(CJ):a.call(null,CJ),1);return(a=$APP.r(b.call($APP.N,c,d,$APP.y([new $APP.H(null,1,5,g,[$APP.r(new $APP.H(null,3,5,l,[FJ,n,p],null))],null),JX.j?JX.j(a):JX.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,JV,new $APP.D(null,sK,new $APP.D(null,sK,new $APP.D(null,JX,null,1,null),2,null),3,null),4,null),5,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),JV.j?JV.j(a):JV.call(null,
a),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,sK.j?sK.j(a):sK.call(null,a),2],null))],null),JX.j?JX.j(a):JX.call(null,a)]))))?a:fJ(a)})])),mZa=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,CK,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,FF,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){a=$APP.Jl.A(zG,CJ)(a);return $APP.k(a)?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,CK,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,yJ,
null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),function(b){b=$APP.qe(b);b=$APP.C.A(b,yJ);return $APP.Vg.A(function(c){return new $APP.D(null,CK,new $APP.D(null,c,null,1,null),2,null)},b)}(a))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,CK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,1,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[CK,EJ.j?EJ.j(a):
EJ.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,CK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,vYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(a):EJ.call(null,a),CJ.j?CJ.j(a):CJ.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,CK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,
new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,EF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){var b=$APP.I,c=$APP.r(new $APP.H(null,2,5,$APP.I,[CK,EJ.j?EJ.j(a):EJ.call(null,a)],null)),d=$APP.I,g=EJ.j?EJ.j(a):EJ.call(null,a);a=TF.A(a.j?a.j(CJ):a.call(null,CJ),1);return(b=$APP.r(new $APP.H(null,3,5,b,[$APP.Hv,c,$APP.r(new $APP.H(null,3,5,d,[FJ,g,a],null))],null)))?b:fJ(b)})]))])),TJ=function TJ(a){switch(arguments.length){case 2:return TJ.A(arguments[0],
arguments[1]);case 3:return TJ.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};TJ.A=function(a,b){return GJ.B($APP.T.j($APP.r($APP.N.A(new $APP.D(null,tM,null,1,null),new $APP.D(null,a,null,1,null)))),b,function(){return!1})};
TJ.B=function(a,b,c){return GJ.B($APP.T.j($APP.r($APP.N.A(new $APP.D(null,tM,null,1,null),new $APP.D(null,a,null,1,null)))),c,function(){return!1})&&GJ.B($APP.T.j($APP.r($APP.N.A(new $APP.D(null,tM,null,1,null),new $APP.D(null,b,null,1,null)))),c,function(){return!1})};TJ.G=3;
var zpc=function(){var a=yG.A(0,2);return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,HJ,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,jK,new $APP.D(null,TU,null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,TU.j?TU.j(b):TU.call(null,b)],null))],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,TU.j?TU.j(b):TU.call(null,b)],null))],null))],null))],null)),a],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,lK,new $APP.D(null,TU,
null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,TF.j(pG),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,TU.j?TU.j(b):TU.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,TU.j?TU.j(b):TU.call(null,b),2],null))],null))],null))],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,mK,new $APP.D(null,
TU,null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,TF.j(pG),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,TU.j?TU.j(b):TU.call(null,b),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,TU.j?TU.j(b):TU.call(null,b),2],null))],null))],null))],null))],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,yH,
new $APP.D(null,SU,null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,SU.j?SU.j(b):SU.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,-1,SU.j?SU.j(b):SU.call(null,b)],null))],null))],null)),2],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,wH,new $APP.D(null,SU,null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,
5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,SU.j?SU.j(b):SU.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,-1,SU.j?SU.j(b):SU.call(null,b)],null))],null))],null)),2],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,LJ,new $APP.D(null,sYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,
2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,LJ.j?LJ.j(b):LJ.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null))],null)))?b:fJ(b)})]))]))}(),Apc=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,
EJ.j?EJ.j(a):EJ.call(null,a),-1],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,1,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(a):EJ.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,
new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,-1,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,
new $APP.D(null,$APP.sj,new $APP.D(null,3,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(a):EJ.call(null,a)],null)),3],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,-3,new $APP.D(null,
2,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,EJ.j?EJ.j(a):EJ.call(null,a)],null)),-3],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,VS,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WS,null,
1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(a):EJ.call(null,a),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VS.j?VS.j(a):VS.call(null,a),$APP.y([WS.j?WS.j(a):WS.call(null,a)])))],null)))?a:fJ(a)})]))])),h1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,oY,new $APP.D(null,$J,new $APP.D(null,yJ,null,1,null),2,null),3,null),4,null),null,1,null),
2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,oY.j?oY.j(a):oY.call(null,a)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,$J.j?$J.j(a):$J.call(null,a)],null),yJ.j?yJ.j(a):yJ.call(null,a)))],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,oY,new $APP.D(null,$J,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,oY.j?oY.j(a):oY.call(null,a)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$J.j?$J.j(a):$J.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,DJ,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,EJ,new $APP.D(null,Yyb,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,Yyb.j?Yyb.j(a):Yyb.call(null,a),$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,
EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)))?a:fJ(a)})]))])),Bpc=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,EF,null,1,null),2,null),3,null),new $APP.D(null,dK,new $APP.D(null,new $APP.D(null,DJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,eK,null,1,null),2,null),3,null),4,null),5,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),dK.j?dK.j(a):dK.call(null,a),$APP.y([new $APP.H(null,
1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[DJ,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,EJ.j?EJ.j(a):EJ.call(null,a),CJ.j?CJ.j(a):CJ.call(null,a)],null))],null))],null),eK.j?eK.j(a):eK.call(null,a)]))))?a:fJ(a)})]))])),m1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,zT,null,1,null),2,null),new $APP.D(null,RU,null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=
$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,a))),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a)))],null)),RU.j?RU.j(a):RU.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,
zT,null,1,null),2,null),new $APP.D(null,cU,null,1,null),2,null),3,null),new $APP.D(null,RU,null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,a))),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a)))],null),cU.j?cU.j(a):cU.call(null,a))),RU.j?RU.j(a):RU.call(null,a)],null)))?
a:fJ(a)}),mJ(xJ.A(new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,CJ,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,zT,null,1,null),2,null),new $APP.D(null,RU,null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,
1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,a))),CJ.j?CJ.j(a):CJ.call(null,a)],null)),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a)))],null)),RU.j?RU.j(a):RU.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,zT,null,1,null),2,null),new $APP.D(null,CJ,null,1,null),2,null),3,
null),new $APP.D(null,RU,null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,a))),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a))),CJ.j?CJ.j(a):CJ.call(null,a)],null))],null)),RU.j?RU.j(a):RU.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,
new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,CJ,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,zT,null,1,null),2,null),new $APP.D(null,QU,null,1,null),2,null),3,null),new $APP.D(null,RU,null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,
3,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,a))),CJ.j?CJ.j(a):CJ.call(null,a)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a))),QU.j?QU.j(a):QU.call(null,a)],null))],null)),RU.j?RU.j(a):RU.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,
CJ,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,zT,null,1,null),2,null),new $APP.D(null,cU,null,1,null),2,null),3,null),new $APP.D(null,RU,null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,
a))),CJ.j?CJ.j(a):CJ.call(null,a)],null)),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a)))],null),cU.j?cU.j(a):cU.call(null,a))),RU.j?RU.j(a):RU.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,zT,null,1,null),2,null),new $APP.D(null,QU,null,
1,null),2,null),3,null),new $APP.D(null,cU,null,1,null),2,null),3,null),new $APP.D(null,RU,null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,a))),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a))),QU.j?QU.j(a):QU.call(null,a)],null))],
null),cU.j?cU.j(a):cU.call(null,a))),RU.j?RU.j(a):RU.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,CJ,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,zT,null,1,null),2,null),new $APP.D(null,QU,null,1,null),2,null),3,null),new $APP.D(null,cU,null,1,
null),2,null),3,null),new $APP.D(null,RU,null,1,null),2,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,a))),CJ.j?CJ.j(a):CJ.call(null,a)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a))),QU.j?QU.j(a):
QU.call(null,a)],null))],null),cU.j?cU.j(a):cU.call(null,a))),RU.j?RU.j(a):RU.call(null,a)],null)))?a:fJ(a)})])),rJ(function(){return!0},mJ(xJ.A(new $APP.D(null,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,yJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,AT,null,1,null),2,null),new $APP.D(null,UJ,new $APP.D(null,new $APP.D(null,$APP.Vw,new $APP.D(null,zT,null,1,null),2,null),new $APP.D(null,jac,null,1,null),2,null),3,null),4,null),5,null),6,null),new $APP.D(null,RU,null,1,null),
2,null),new $APP.D(null,bWb,null,1,null),2,null),function(a){var b=$APP.qe(a);a=$APP.C.A(b,AT);b=$APP.C.A(b,zT);return 0<$APP.Ed($APP.tf(a),$APP.tf(b))}),function(a){return(a=$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),yJ.j?yJ.j(a):yJ.call(null,a),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),zT.j?zT.j(a):zT.call(null,a)))],null),UJ.j?UJ.j(a):UJ.call(null,
a),new $APP.H(null,1,5,$APP.I,[$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Vw],null),AT.j?AT.j(a):AT.call(null,a)))],null),jac.j?jac.j(a):jac.call(null,a)]))),RU.j?RU.j(a):RU.call(null,a)],null))],null),bWb.j?bWb.j(a):bWb.call(null,a))))?a:fJ(a)}))])),l1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,nK,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,EJ.j?EJ.j(a):EJ.call(null,a)],null)),$APP.r(new $APP.H(null,
2,5,$APP.I,[uH,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,OM,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,EJ.j?EJ.j(a):EJ.call(null,a)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,NM,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,
[$APP.sj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,PM,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,jK,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,LJ,new $APP.D(null,EJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=
$APP.r(new $APP.H(null,3,5,$APP.I,[jK,LJ.j?LJ.j(a):LJ.call(null,a),EJ.j?EJ.j(a):EJ.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,jK,new $APP.D(null,LJ,null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[jK,LJ.j?LJ.j(a):LJ.call(null,a),1],null)))?a:fJ(a)})]))])),a1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),
2,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[nK,EJ.j?EJ.j(a):EJ.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,VS,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WS,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,
1,5,$APP.I,[$APP.Hv],null),VS.j?VS.j(a):VS.call(null,a),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[nK,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null),WS.j?WS.j(a):WS.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,wS,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,xS,null,1,null),2,null),3,
null),4,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[nK,EJ.j?EJ.j(a):EJ.call(null,a)],null)),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),wS.j?wS.j(a):wS.call(null,a),$APP.y([xS.j?xS.j(a):xS.call(null,a)])))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,VS,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,
WS,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,wS,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,xS,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),VS.j?VS.j(a):VS.call(null,a),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[nK,EJ.j?EJ.j(a):
EJ.call(null,a)],null))],null),WS.j?WS.j(a):WS.call(null,a)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),wS.j?wS.j(a):wS.call(null,a),$APP.y([xS.j?xS.j(a):xS.call(null,a)])))],null)))?a:fJ(a)})]))])),c1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,sJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){var b=$APP.I;a=-(a.j?a.j(CJ):a.call(null,CJ));return(b=$APP.r(new $APP.H(null,2,5,b,[uH,
a],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,BT,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){var b=$APP.I,c=$APP.N.A,d=$APP.I;var g=-(a.j?a.j(CJ):a.call(null,CJ));return(a=$APP.r(new $APP.H(null,2,5,b,[uH,$APP.r(c.call($APP.N,new $APP.H(null,2,5,d,[$APP.Hv,g],null),BT.j?BT.j(a):BT.call(null,a)))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,
uH,new $APP.D(null,new $APP.D(null,$APP.Iv,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,BT,null,1,null),2,null),3,null),new $APP.D(null,DT,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){var b=$APP.I,c=$APP.N.A,d=$APP.I,g=$APP.N.A,l=$APP.I;var n=-(a.j?a.j(CJ):a.call(null,CJ));return(a=$APP.r(new $APP.H(null,2,5,b,[uH,$APP.r(c.call($APP.N,new $APP.H(null,2,5,d,[$APP.Jv,
$APP.r(g.call($APP.N,new $APP.H(null,2,5,l,[$APP.Hv,n],null),BT.j?BT.j(a):BT.call(null,a)))],null),DT.j?DT.j(a):DT.call(null,a)))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,sJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){var b=$APP.I,c=$APP.I;a=-(a.j?a.j(CJ):a.call(null,CJ));return(b=$APP.r(new $APP.H(null,2,5,b,[$APP.Jv,$APP.r(new $APP.H(null,2,5,c,[mH,a],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,
mH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,BT,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){var b=$APP.I,c=$APP.I,d=$APP.N.A,g=$APP.I;var l=-(a.j?a.j(CJ):a.call(null,CJ));return(a=$APP.r(new $APP.H(null,2,5,b,[$APP.Jv,$APP.r(new $APP.H(null,2,5,c,[mH,$APP.r(d.call($APP.N,new $APP.H(null,2,5,g,[$APP.Hv,l],null),BT.j?BT.j(a):BT.call(null,a)))],null))],null)))?a:fJ(a)}),
mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,$APP.Iv,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,BT,null,1,null),2,null),3,null),new $APP.D(null,DT,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){var b=$APP.I,c=$APP.I,d=$APP.N.A,g=$APP.I,l=$APP.N.A,n=$APP.I;var p=-(a.j?a.j(CJ):a.call(null,CJ));return(a=$APP.r(new $APP.H(null,2,5,b,[$APP.Jv,$APP.r(new $APP.H(null,
2,5,c,[mH,$APP.r(d.call($APP.N,new $APP.H(null,2,5,g,[$APP.Jv,$APP.r(l.call($APP.N,new $APP.H(null,2,5,n,[$APP.Hv,p],null),BT.j?BT.j(a):BT.call(null,a)))],null),DT.j?DT.j(a):DT.call(null,a)))],null))],null)))?a:fJ(a)})]))])),Cpc=function(){function a(b){var c=EF(b);return c?(c=VF.j(b),$APP.k(c)?3<b:c):c}return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,2,new $APP.D(null,EJ,new $APP.D(null,DT,null,1,null),2,null),3,null),4,null),null,
1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,2,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(b):EJ.call(null,b)],null),DT.j?DT.j(b):DT.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(b):EJ.call(null,b)],null),DT.j?DT.j(b):DT.call(null,b)))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Hv,
new $APP.D(null,2,new $APP.D(null,EJ,new $APP.D(null,DT,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,2,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(b):EJ.call(null,b)],null),DT.j?DT.j(b):DT.call(null,b)))],null)),2],null))],null)),1],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,
new $APP.D(null,$APP.Hv,new $APP.D(null,3,new $APP.D(null,EJ,new $APP.D(null,DT,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,3,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(b):EJ.call(null,b)],null),DT.j?DT.j(b):DT.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,-4,$APP.r(new $APP.H(null,3,5,$APP.I,
[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(b):EJ.call(null,b)],null),DT.j?DT.j(b):DT.call(null,b)))],null)),3],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,3,new $APP.D(null,EJ,new $APP.D(null,DT,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,4,$APP.r(new $APP.H(null,
3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(b):EJ.call(null,b)],null),DT.j?DT.j(b):DT.call(null,b)))],null)),3],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,-3,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(b):EJ.call(null,b)],null),DT.j?DT.j(b):DT.call(null,b)))],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,$APP.Hv,
new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.wU,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,RU,new $APP.D(null,TS,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Hv,function(c){return TF.A(c.j?c.j($APP.wU):c.call(null,$APP.wU),1)}(b),RU.j?RU.j(b):RU.call(null,b)],
null),TS.j?TS.j(b):TS.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,RU.j?RU.j(b):RU.call(null,b)],null),TS.j?TS.j(b):TS.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Hv,function(c){return TF.A(c.j?c.j($APP.wU):c.call(null,$APP.wU),1)}(b),RU.j?RU.j(b):RU.call(null,b)],null),TS.j?TS.j(b):TS.call(null,b)))],null)),$APP.r(new $APP.H(null,
2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,RU.j?RU.j(b):RU.call(null,b)],null),TS.j?TS.j(b):TS.call(null,b)))],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,$APP.Iv,new $APP.D(null,EJ,new $APP.D(null,LJ,new $APP.D(null,UJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,EJ.j?
EJ.j(b):EJ.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Iv,LJ.j?LJ.j(b):LJ.call(null,b)],null),UJ.j?UJ.j(b):UJ.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,EJ.j?EJ.j(b):EJ.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Iv,LJ.j?LJ.j(b):LJ.call(null,b)],null),UJ.j?UJ.j(b):UJ.call(null,b)))],null))],null))],null)))?
b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.wU,new $APP.D(null,a,null,1,null),2,null),3,null),new $APP.D(null,RU,new $APP.D(null,TS,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Hv,function(c){return TF.A(c.j?
c.j($APP.wU):c.call(null,$APP.wU),1)}(b),RU.j?RU.j(b):RU.call(null,b)],null),TS.j?TS.j(b):TS.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,RU.j?RU.j(b):RU.call(null,b)],null),TS.j?TS.j(b):TS.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,3,5,$APP.I,[$APP.Hv,function(c){return TF.A(c.j?c.j($APP.wU):c.call(null,$APP.wU),1)}(b),RU.j?RU.j(b):
RU.call(null,b)],null),TS.j?TS.j(b):TS.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,RU.j?RU.j(b):RU.call(null,b)],null),TS.j?TS.j(b):TS.call(null,b)))],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Iv,new $APP.D(null,EJ,new $APP.D(null,LJ,new $APP.D(null,UJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,EJ.j?EJ.j(b):EJ.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Iv,LJ.j?LJ.j(b):LJ.call(null,b)],null),UJ.j?UJ.j(b):UJ.call(null,b)))],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,EJ.j?EJ.j(b):EJ.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Iv,LJ.j?
LJ.j(b):LJ.call(null,b)],null),UJ.j?UJ.j(b):UJ.call(null,b)))],null))],null))],null)))?b:fJ(b)})]))]))}(),Dpc=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WJ,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,XJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Iv,
$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,2,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null))],null))],null),VJ.j?VJ.j(a):VJ.call(null,
a),$APP.y([WJ.j?WJ.j(a):WJ.call(null,a),XJ.j?XJ.j(a):XJ.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null),new $APP.D(null,XJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,
2,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,2,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null))],null))],null),VJ.j?
VJ.j(a):VJ.call(null,a),$APP.y([WJ.j?WJ.j(a):WJ.call(null,a),XJ.j?XJ.j(a):XJ.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null),new $APP.D(null,WJ,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,XJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=
$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,2,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],
null))],null))],null),VJ.j?VJ.j(a):VJ.call(null,a),$APP.y([WJ.j?WJ.j(a):WJ.call(null,a),XJ.j?XJ.j(a):XJ.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,XJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Iv,
$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,2,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null))],null))],null),VJ.j?VJ.j(a):VJ.call(null,
a),$APP.y([WJ.j?WJ.j(a):WJ.call(null,a),XJ.j?XJ.j(a):XJ.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,WJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null),new $APP.D(null,XJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,
2,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,-2,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null))],null))],null),VJ.j?
VJ.j(a):VJ.call(null,a),$APP.y([WJ.j?WJ.j(a):WJ.call(null,a),XJ.j?XJ.j(a):XJ.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,VJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,-1,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null),new $APP.D(null,WJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,XJ,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=
$APP.r($APP.N.C(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,-2,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null)),2],null))],
null))],null))],null),VJ.j?VJ.j(a):VJ.call(null,a),$APP.y([WJ.j?WJ.j(a):WJ.call(null,a),XJ.j?XJ.j(a):XJ.call(null,a)]))))?a:fJ(a)})]))])),g1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,QJ,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,CT,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,
3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null))],null))],null),PJ.j?PJ.j(a):PJ.call(null,a),$APP.y([QJ.j?QJ.j(a):QJ.call(null,
a),CT.j?CT.j(a):CT.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,QJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,CT,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,
[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null))],null))],null),PJ.j?PJ.j(a):PJ.call(null,a),$APP.y([QJ.j?QJ.j(a):QJ.call(null,a),CT.j?CT.j(a):CT.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,
new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,QJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,CT,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,
a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null))],null))],null),PJ.j?PJ.j(a):PJ.call(null,a),$APP.y([QJ.j?QJ.j(a):QJ.call(null,a),CT.j?CT.j(a):CT.call(null,a)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,PJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,QJ,new $APP.D(null,new $APP.D(null,
mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,CT,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null))],null))],null),PJ.j?PJ.j(a):PJ.call(null,a),$APP.y([QJ.j?QJ.j(a):QJ.call(null,a),CT.j?CT.j(a):CT.call(null,a)]))))?a:fJ(a)})]))])),Epc=function(){function a(b){var c=EF(b);return c?(c=VF.j(b),$APP.k(c)?1<b:c):c}return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,
a,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),g=$APP.I,l=$APP.r(new $APP.H(null,2,5,$APP.I,[mH,EJ.j?EJ.j(b):EJ.call(null,b)],null));var n=(b.j?b.j(CJ):b.call(null,CJ))-2;return(b=$APP.r(new $APP.H(null,4,5,c,[$APP.Hv,d,$APP.r(new $APP.H(null,3,5,g,[FJ,l,n],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,2,EJ.j?EJ.j(b):
EJ.call(null,b)],null))],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,a,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,2],null)),g=$APP.I,l=$APP.r(new $APP.H(null,2,5,$APP.I,[uH,EJ.j?EJ.j(b):EJ.call(null,b)],null));var n=(b.j?b.j(CJ):b.call(null,CJ))-2;
return(b=$APP.r(new $APP.H(null,4,5,c,[$APP.Hv,d,$APP.r(new $APP.H(null,3,5,g,[FJ,l,n],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,1,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,2,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null))],null))],null)))?b:fJ(b)})]))]))}(),e1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,
vJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){var b=$APP.I,c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[mH,EJ.j?EJ.j(a):EJ.call(null,a)],null));var g=(a.j?a.j(CJ):a.call(null,CJ))-2;return(a=$APP.r(new $APP.H(null,3,5,b,[$APP.Hv,$APP.r(new $APP.H(null,3,5,c,[FJ,d,g],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,EJ.j?EJ.j(a):EJ.call(null,a)],null)),2],null))],null))],null)))?a:fJ(a)})]))])),
Fpc=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,vJ,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){var b=$APP.I,c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[uH,EJ.j?EJ.j(a):EJ.call(null,a)],null));var g=(a.j?a.j(CJ):a.call(null,CJ))-2;return(a=$APP.r(new $APP.H(null,3,5,b,[$APP.Hv,$APP.r(new $APP.H(null,3,5,c,[FJ,d,g],
null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,EJ.j?EJ.j(a):EJ.call(null,a)],null)),2],null))],null))],null)))?a:fJ(a)})]))])),jZa=function(){function a(b){b=$APP.qe(b);var c=$APP.C.A(b,CJ);c=TF.A(c,2);c=$APP.k(uG.j(c))?b=$APP.r(new $APP.H(null,2,5,$APP.I,[sK.j?sK.j(b):sK.call(null,b),EJ.j?EJ.j(b):EJ.call(null,b)],null)):b=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[sK.j?sK.j(b):sK.call(null,
b),EJ.j?EJ.j(b):EJ.call(null,b)],null)),c],null));return c?c:fJ(b)}return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,dK,new $APP.D(null,new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,new $APP.ug(null,new $APP.f(null,2,[mH,null,uH,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,yYa,null,1,null),2,null),
3,null),null,1,null),2,null),3,null),new $APP.D(null,eK,null,1,null),2,null),3,null),4,null),zJ),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),dK.j?dK.j(b):dK.call(null,b),$APP.y([new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[sK.j?sK.j(b):sK.call(null,b),EJ.j?EJ.j(b):EJ.call(null,b)],null)),2],null)),a(b)],null),eK.j?eK.j(b):eK.call(null,b)]))))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,$APP.Iv,new $APP.D(null,vK,new $APP.D(null,
new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,sK,new $APP.D(null,new $APP.ug(null,new $APP.f(null,2,[mH,null,uH,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,yYa,null,1,null),2,null),3,null),null,1,null),2,null),3,null),new $APP.D(null,wK,null,1,null),2,null),3,null),4,null),zJ),function(b){return(b=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Iv],
null),vK.j?vK.j(b):vK.call(null,b),$APP.y([new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[sK.j?sK.j(b):sK.call(null,b),EJ.j?EJ.j(b):EJ.call(null,b)],null)),2],null)),a(b)],null))],null),wK.j?wK.j(b):wK.call(null,b)]))))?b:fJ(b)})]))]))}(),Gpc=function(){var a=TF.j(pG);return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,a,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null))],null)),yG.A(0,2)],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,a,EJ.j?EJ.j(b):EJ.call(null,b)],null))],null))],null)),2],null)))?b:fJ(b)})]))]))}(),Hpc=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.Jv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null))],null))],null)),kG.A(2,pG)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,EJ,null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null))],null))],null)),2],null)))?a:fJ(a)})]))])),Ipc=function(){function a(c){c=CH.j(c.j?c.j(jT):c.call(null,jT));return $APP.k(sG.j(c))?new $APP.f(null,1,[oT,c],
null):null}function b(c){c=CH.j(c.j?c.j(jT):c.call(null,jT));var d=sG.j(c);d=$APP.k(d)?d:MF.j(c);return $APP.k($APP.eb(d))?new $APP.f(null,1,[oT,c],null):null}return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,jT,new $APP.D(null,tJ,null,1,null),2,null),3,null),null,1,null),2,null),b),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,oT.j?oT.j(c):oT.call(null,c)],null)),$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.Hv,pG,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,oT.j?oT.j(c):oT.call(null,c)],null))],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,jT,new $APP.D(null,tJ,null,1,null),2,null),3,null),null,1,null),2,null),a),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,function(d){return-(d.j?d.j(oT):d.call(null,oT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,TF.j(pG),$APP.r(new $APP.H(null,
2,5,$APP.I,[mH,function(d){return-(d.j?d.j(oT):d.call(null,oT))}(c)],null))],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,jT,new $APP.D(null,tJ,null,1,null),2,null),3,null),new $APP.D(null,yT,null,1,null),2,null),3,null),null,1,null),2,null),b),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,oT.j?
oT.j(c):oT.call(null,c)],null),yT.j?yT.j(c):yT.call(null,c)))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,oT.j?oT.j(c):oT.call(null,c)],null),yT.j?yT.j(c):yT.call(null,c)))],null))],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,jT,new $APP.D(null,tJ,null,1,null),2,null),3,null),new $APP.D(null,yT,null,
1,null),2,null),3,null),null,1,null),2,null),a),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,function(d){return zH.j(d.j?d.j(jT):d.call(null,jT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,function(d){return-(d.j?d.j(oT):d.call(null,oT))}(c)],null),yT.j?yT.j(c):yT.call(null,c)))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,TF.j(pG),$APP.r(new $APP.H(null,
2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,function(d){return-(d.j?d.j(oT):d.call(null,oT))}(c)],null),yT.j?yT.j(c):yT.call(null,c)))],null))],null))],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,jT,new $APP.D(null,uJ,null,1,null),2,null),3,null),null,1,null),2,null),b),function(c){var d=$APP.I,g=$APP.I;var l=zH.j(c.j?c.j(jT):c.call(null,jT));return(c=$APP.r(new $APP.H(null,3,5,d,[$APP.Hv,$APP.r(new $APP.H(null,2,5,
g,[BJ,l],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,oT.j?oT.j(c):oT.call(null,c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,oT.j?oT.j(c):oT.call(null,c)],null))],null))],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,jT,new $APP.D(null,uJ,null,1,null),2,null),3,null),null,1,null),2,null),a),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,
$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,function(d){return zH.j(d.j?d.j(jT):d.call(null,jT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,function(d){return-(d.j?d.j(oT):d.call(null,oT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,TF.j(pG),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,function(d){return-(d.j?d.j(oT):d.call(null,oT))}(c)],null))],null))],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,
new $APP.D(null,ZI,new $APP.D(null,jT,new $APP.D(null,uJ,null,1,null),2,null),3,null),new $APP.D(null,yT,null,1,null),2,null),3,null),null,1,null),2,null),b),function(c){var d=$APP.I,g=$APP.I;var l=zH.j(c.j?c.j(jT):c.call(null,jT));return(c=$APP.r(new $APP.H(null,3,5,d,[$APP.Hv,$APP.r(new $APP.H(null,2,5,g,[BJ,l],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,oT.j?oT.j(c):oT.call(null,c)],null),yT.j?yT.j(c):
yT.call(null,c)))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,oT.j?oT.j(c):oT.call(null,c)],null),yT.j?yT.j(c):yT.call(null,c)))],null))],null))],null))],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,jT,new $APP.D(null,uJ,null,1,null),2,null),3,null),new $APP.D(null,yT,null,1,null),2,null),3,null),null,1,null),
2,null),a),function(c){return(c=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,function(d){return zH.j(d.j?d.j(jT):d.call(null,jT))}(c)],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,function(d){return-(d.j?d.j(oT):d.call(null,oT))}(c)],null),yT.j?yT.j(c):yT.call(null,c)))],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,TF.j(pG),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,$APP.r($APP.N.A(new $APP.H(null,
2,5,$APP.I,[$APP.Hv,function(d){return-(d.j?d.j(oT):d.call(null,oT))}(c)],null),yT.j?yT.j(c):yT.call(null,c)))],null))],null))],null))],null)))?c:fJ(c)})]))]))}(),k1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,ZJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,$J,null,1,null),2,null),new $APP.D(null,aK,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,bK,null,1,null),2,null),new $APP.D(null,cK,null,1,null),2,null),3,null),4,null),5,null),6,null),zJ),function(a){return(a=
$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),ZJ.j?ZJ.j(a):ZJ.call(null,a),$APP.y([aK.j?aK.j(a):aK.call(null,a),cK.j?cK.j(a):cK.call(null,a),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$J.j?$J.j(a):$J.call(null,a),bK.j?bK.j(a):bK.call(null,a)],null))],null))],null)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,azb,null,1,null),2,null),
3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,azb.j?azb.j(a):azb.call(null,a),EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,
5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,ZJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,fK,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,LJ,null,1,null),2,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],
null),ZJ.j?ZJ.j(a):ZJ.call(null,a),$APP.y([fK.j?fK.j(a):fK.call(null,a),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null))],null)]))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,GY,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,LJ,null,
1,null),2,null),new $APP.D(null,HY,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null)),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),GY.j?GY.j(a):GY.call(null,a),$APP.y([HY.j?HY.j(a):HY.call(null,a)])))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,
new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,ZJ,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,fK,null,1,null),2,null),3,null),4,null),new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,GY,new $APP.D(null,new $APP.D(null,BJ,new $APP.D(null,LJ,null,1,null),2,null),new $APP.D(null,HY,null,1,null),2,null),3,null),4,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r($APP.N.C(new $APP.H(null,
1,5,$APP.I,[$APP.Hv],null),ZJ.j?ZJ.j(a):ZJ.call(null,a),$APP.y([fK.j?fK.j(a):fK.call(null,a),new $APP.H(null,1,5,$APP.I,[$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,EJ.j?EJ.j(a):EJ.call(null,a),LJ.j?LJ.j(a):LJ.call(null,a)],null))],null))],null)]))),$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),GY.j?GY.j(a):GY.call(null,a),$APP.y([HY.j?HY.j(a):HY.call(null,a)])))],null)))?a:fJ(a)})]))])),i1a=function(){function a(b){var c=EF(b);return c?VF.j(b):c}
return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Jv,new $APP.D(null,oY,null,1,null),2,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,1,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,oY.j?oY.j(b):oY.call(null,b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Jv,new $APP.D(null,oY,new $APP.D(null,$J,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=
$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,oY.j?oY.j(b):oY.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$J.j?$J.j(b):$J.call(null,b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Iv,new $APP.D(null,oY,new $APP.D(null,$J,new $APP.D(null,yJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,oY.j?
oY.j(b):oY.call(null,b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Iv,$J.j?$J.j(b):$J.call(null,b)],null),yJ.j?yJ.j(b):yJ.call(null,b)))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,EJ,new $APP.D(null,rYa,new $APP.D(null,function(b){return 1<CH.j(b)},null,1,null),2,null),3,null),4,null),new $APP.D(null,aW,null,1,null),2,null),3,null),null,1,null),
2,null),zJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,pG],null),aW.j?aW.j(b):aW.call(null,b)))],null));b=CH.j(b.j?b.j(EJ):b.call(null,EJ));return(c=$APP.r(new $APP.H(null,3,5,c,[FJ,d,b],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,EJ,new $APP.D(null,rYa,new $APP.D(null,function(b){return-1>CH.j(b)},null,1,null),2,null),3,null),4,null),
new $APP.D(null,aW,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,TF.j(pG)],null),aW.j?aW.j(b):aW.call(null,b)))],null));b=TF.j(CH.j(b.j?b.j(EJ):b.call(null,EJ)));return(c=$APP.r(new $APP.H(null,3,5,c,[FJ,d,b],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,a,new $APP.D(null,
function(b){return 1<b},null,1,null),2,null),3,null),4,null),new $APP.D(null,aW,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),aW.j?aW.j(b):aW.call(null,b)))],null)),CJ.j?CJ.j(b):CJ.call(null,b)],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,
a,new $APP.D(null,function(b){return-1>b},null,1,null),2,null),3,null),4,null),new $APP.D(null,aW,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){var c=$APP.I,d=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,-1],null),aW.j?aW.j(b):aW.call(null,b)))],null));b=-(b.j?b.j(CJ):b.call(null,CJ));return(c=$APP.r(new $APP.H(null,3,5,c,[FJ,d,b],null)))?c:fJ(c)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,EJ,new $APP.D(null,
uJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,function(c){return zH.j(c.j?c.j(EJ):c.call(null,EJ))}(b)],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,function(c){return kG.A(CH.j(c.j?c.j(EJ):c.call(null,EJ)),$APP.te.$a.j?$APP.te.$a.j(pG):$APP.te.$a.call(null,pG))}(b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,BJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,
ZI,new $APP.D(null,EJ,new $APP.D(null,uJ,null,1,null),2,null),3,null),new $APP.D(null,aW,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,function(c){return zH.j(c.j?c.j(EJ):c.call(null,EJ))}(b)],null),aW.j?aW.j(b):aW.call(null,b)))],null)),$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,function(c){return kG.A(CH.j(c.j?
c.j(EJ):c.call(null,EJ)),$APP.te.$a.j?$APP.te.$a.j(pG):$APP.te.$a.call(null,pG))}(b)],null),aW.j?aW.j(b):aW.call(null,b)))],null))],null)))?b:fJ(b)})]))]))}(),b1a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,pG,null,1,null),2,null),zJ),function(){var a=$APP.r(new $APP.H(null,2,5,$APP.I,[wH,1],null));return a?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,TU,new $APP.D(null,pG,null,1,null),2,null),3,null),null,1,null),2,null),zJ),
function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[wH,TU.j?TU.j(a):TU.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,pG,new $APP.D(null,TU,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[wH,TU.j?TU.j(a):TU.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,yJ,new $APP.D(null,pG,new $APP.D(null,UJ,null,
1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[wH,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),yJ.j?yJ.j(a):yJ.call(null,a),$APP.y([UJ.j?UJ.j(a):UJ.call(null,a)])))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,pG,null,1,null),2,null),zJ),function(){var a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,$APP.r(new $APP.H(null,2,5,$APP.I,[yH,1],null))],null));return a?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,
new $APP.D(null,$APP.Hv,new $APP.D(null,TU,new $APP.D(null,pG,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,$APP.r(new $APP.H(null,2,5,$APP.I,[yH,TU.j?TU.j(a):TU.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,pG,new $APP.D(null,TU,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,
$APP.r(new $APP.H(null,2,5,$APP.I,[yH,TU.j?TU.j(a):TU.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,yJ,new $APP.D(null,pG,new $APP.D(null,UJ,null,1,null),2,null),3,null),4,null),null,1,null),2,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,$APP.r(new $APP.H(null,2,5,$APP.I,[yH,$APP.r($APP.N.C(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),yJ.j?yJ.j(a):yJ.call(null,a),$APP.y([UJ.j?UJ.j(a):UJ.call(null,
a)])))],null))],null)))?a:fJ(a)})]))])),Jpc=function(){var a=$APP.M(ZI,sK,new $APP.ug(null,new $APP.f(null,2,[RV,"null",fY,"null"],null),null));return AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,a,new $APP.D(null,new $APP.D(null,uH,new $APP.D(null,oS,null,1,null),2,null),new $APP.D(null,new $APP.D(null,mH,new $APP.D(null,oS,null,1,null),2,null),null,1,null),2,null),3,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[BJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,pG,oS.j?oS.j(b):
oS.call(null,b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,bU,new $APP.D(null,new $APP.D(null,a,new $APP.D(null,jY,new $APP.D(null,$APP.Kv,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){b=jY.j?jY.j(b):jY.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,jV,new $APP.D(null,new $APP.D(null,a,new $APP.D(null,$APP.Kv,new $APP.D(null,oT,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){b=oT.j?oT.j(b):oT.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,
CK,new $APP.D(null,new $APP.D(null,a,new $APP.D(null,jY,new $APP.D(null,oT,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,jY.j?jY.j(b):jY.call(null,b),2],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,oT.j?oT.j(b):oT.call(null,b),2],null))],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,EY,new $APP.D(null,new $APP.D(null,a,new $APP.D(null,jY,new $APP.D(null,
oT,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[jK,oT.j?oT.j(b):oT.call(null,b),jY.j?jY.j(b):jY.call(null,b)],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,bU,new $APP.D(null,new $APP.D(null,FT,new $APP.D(null,QU,new $APP.D(null,IJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,QU.j?QU.j(b):QU.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[uH,IJ.j?IJ.j(b):IJ.call(null,
b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,jV,new $APP.D(null,new $APP.D(null,FT,new $APP.D(null,QU,new $APP.D(null,IJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){return(b=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,QU.j?QU.j(b):QU.call(null,b),$APP.r(new $APP.H(null,2,5,$APP.I,[mH,IJ.j?IJ.j(b):IJ.call(null,b)],null))],null)))?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,CK,new $APP.D(null,new $APP.D(null,FT,new $APP.D(null,QU,new $APP.D(null,$APP.Kv,null,1,null),2,null),3,null),
null,1,null),2,null),zJ),function(b){b=QU.j?QU.j(b):QU.call(null,b);return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,EY,new $APP.D(null,new $APP.D(null,FT,new $APP.D(null,$APP.Kv,new $APP.D(null,IJ,null,1,null),2,null),3,null),null,1,null),2,null),zJ),function(b){b=IJ.j?IJ.j(b):IJ.call(null,b);return $APP.k(b)?b:fJ(b)})]))]))}(),X0a=AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,1,new $APP.D(null,hS,null,1,null),2,null),3,null),zJ),function(a){a=hS.j?hS.j(a):hS.call(null,
a);return $APP.k(a)?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,1,new $APP.D(null,aW,null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),aW.j?aW.j(a):aW.call(null,a))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,GF,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,PU,new $APP.D(null,GF,null,1,null),2,null),3,null),null,1,null),
2,null),3,null),zJ),function(a){var b=$APP.qe(a);a=$APP.C.A(b,CJ);b=$APP.C.A(b,PU);a=SF.A(a,b);return $APP.k(a)?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Iv,new $APP.D(null,zKb,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,PU,new $APP.D(null,GF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Iv],null),function(b){return $APP.Vg.A(function(c){return(c=$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.sj,c,PU.j?PU.j(b):PU.call(null,b)],null)))?c:fJ(c)},b.j?b.j(zKb):b.call(null,zKb))}(a))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,CJ,new $APP.D(null,GF,null,1,null),2,null),3,null),new $APP.D(null,aW,null,1,null),2,null),3,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,PU,new $APP.D(null,GF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){var b=$APP.N.A,
c=$APP.I,d=$APP.qe(a);var g=$APP.C.A(d,CJ);d=$APP.C.A(d,PU);g=SF.A(g,d);return(a=$APP.r(b.call($APP.N,new $APP.H(null,2,5,c,[$APP.Hv,g],null),aW.j?aW.j(a):aW.call(null,a))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,aW,null,1,null),2,null),new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,PU,new $APP.D(null,GF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){var b=$APP.N.A,c=$APP.I;var d=QF.j(a.j?a.j(PU):a.call(null,
PU));return(a=$APP.r(b.call($APP.N,new $APP.H(null,2,5,c,[$APP.Hv,d],null),aW.j?aW.j(a):aW.call(null,a))))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,PU,new $APP.D(null,GF,null,1,null),2,null),3,null),new $APP.D(null,hS,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,CJ.j?
CJ.j(a):CJ.call(null,a),PU.j?PU.j(a):PU.call(null,a)],null)),hS.j?hS.j(a):hS.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,PU,new $APP.D(null,GF,null,1,null),2,null),3,null),new $APP.D(null,aW,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,CJ.j?CJ.j(a):
CJ.call(null,a),PU.j?PU.j(a):PU.call(null,a)],null)),$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),aW.j?aW.j(a):aW.call(null,a)))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.sj,new $APP.D(null,CJ,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,PU,new $APP.D(null,GF,null,1,null),2,null),3,null),null,1,null),2,null),3,null),zJ),function(a){var b=$APP.I;var c=QF.j(a.j?a.j(PU):a.call(null,PU));return(a=$APP.r(new $APP.H(null,3,5,b,[$APP.Hv,c,CJ.j?CJ.j(a):CJ.call(null,a)],null)))?a:
fJ(a)})]))]));var Kpc=AJ.C($APP.y([b2.C($APP.y([$APP.Iv,$APP.Hv])),ypc,a2.C($APP.y([$APP.Iv,$APP.Hv]))]));$APP.e=DK.prototype;$APP.e.rb=function(){return OK.j(this.context)};$APP.e.bc=function(){return this.arity};$APP.e.ac=function(a,b,c){return new DK(HH(this.o,b,c),this.arity,this.name,this.context,this.ca)};$APP.e.$b=function(a,b,c){return new DK(IH(this.o,b,c),this.arity,this.name,this.context,this.ca)};$APP.e.ic=function(a,b){return new DK(JH(this.o,b),this.arity,this.name,this.context,this.ca)};
$APP.e.toString=function(){var a=cG.j(this);return $APP.m.j($APP.ud(a)?$APP.r(a):a)};$APP.e.ba=function(){return this.ca};$APP.e.da=function(a,b){return new DK(this.o,this.arity,this.name,this.context,b)};$APP.e.Ka=function(a,b){return oZa.A?oZa.A(this,b):oZa.call(null,this,b)};$APP.e.fa=function(){return yD("Operators don't support the not-found arity of get!")};
$APP.e.call=function(a){switch(arguments.length-1){case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);case 11:return this.xa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13]);
case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],arguments[2],arguments[3],arguments[4],
arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],
arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Kb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],
arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.j=function(a){return this.o.j?this.o.j(a):this.o.call(null,a)};$APP.e.A=function(a,b){return this.o.A?this.o.A(a,b):this.o.call(null,a,b)};$APP.e.B=function(a,b,c){return this.o.B?this.o.B(a,b,c):this.o.call(null,a,b,c)};
$APP.e.K=function(a,b,c,d){return this.o.K?this.o.K(a,b,c,d):this.o.call(null,a,b,c,d)};$APP.e.S=function(a,b,c,d,g){return this.o.S?this.o.S(a,b,c,d,g):this.o.call(null,a,b,c,d,g)};$APP.e.la=function(a,b,c,d,g,l){return this.o.la?this.o.la(a,b,c,d,g,l):this.o.call(null,a,b,c,d,g,l)};$APP.e.Ga=function(a,b,c,d,g,l,n){return this.o.Ga?this.o.Ga(a,b,c,d,g,l,n):this.o.call(null,a,b,c,d,g,l,n)};
$APP.e.va=function(a,b,c,d,g,l,n,p){return this.o.va?this.o.va(a,b,c,d,g,l,n,p):this.o.call(null,a,b,c,d,g,l,n,p)};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){return this.o.Ha?this.o.Ha(a,b,c,d,g,l,n,p,v):this.o.call(null,a,b,c,d,g,l,n,p,v)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){return this.o.wa?this.o.wa(a,b,c,d,g,l,n,p,v,t):this.o.call(null,a,b,c,d,g,l,n,p,v,t)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){return this.o.xa?this.o.xa(a,b,c,d,g,l,n,p,v,t,A):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){return this.o.ya?this.o.ya(a,b,c,d,g,l,n,p,v,t,A,B):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){return this.o.za?this.o.za(a,b,c,d,g,l,n,p,v,t,A,B,G):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){return this.o.Aa?this.o.Aa(a,b,c,d,g,l,n,p,v,t,A,B,G,J):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){return this.o.Ba?this.o.Ba(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R){return this.o.Ca?this.o.Ca(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R)};$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W){return this.o.Da?this.o.Da(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W)};
$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z){return this.o.Ea?this.o.Ea(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z)};$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa){return this.o.Fa?this.o.Fa(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa)};
$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia){return this.o.La?this.o.La(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia):this.o.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia)};$APP.e.Kb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja){return $APP.Je.C(this.o,a,b,c,d,$APP.y([g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja]))};$APP.e.Oa=$APP.xc;$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};
var LK=function LK(a){switch(arguments.length){case 1:return LK.j(arguments[0]);case 2:return LK.A(arguments[0],arguments[1]);case 3:return LK.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};LK.j=function(a){return LK.B(a,Zmb,$APP.F)};LK.A=function(a,b){return LK.B(a,b,$APP.F)};LK.B=function(a,b,c){return EK(a,ZH.A(c,UH(a)),b,$APP.Lf.A(new $APP.f(null,1,[OK,GW],null),c),null)};LK.G=3;
var Lpc=LK.A($APP.Kd,$APP.Fx),e2=function e2(a){switch(arguments.length){case 0:return e2.J();case 1:return e2.j(arguments[0]);case 2:return e2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};e2.J=function(){return Lpc};e2.j=function(a){return a};
e2.A=function(a,b){var c=pZa(a,b);return $APP.k(kZ.j(a))?KK(b,c):$APP.k(kZ.j(b))?KK(a,c):$APP.k(MF.j(a))?KK(a,c):EK(YH.C($APP.y([a,b])),HK(b),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Hv,null,1,null),new $APP.D(null,IK(a),null,1,null),$APP.y([new $APP.D(null,IK(b),null,1,null)])))),c,null)};e2.G=2;
var f2=function f2(a){switch(arguments.length){case 1:return f2.j(arguments[0]);case 2:return f2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};f2.j=function(a){return zZa(a)};f2.A=function(a,b){return EK(FXa(QK.j?QK.j(a):QK.call(null,a),b),new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.T.j($APP.r($APP.N.A(new $APP.D(null,BJ,null,1,null),new $APP.D(null,IK(a),null,1,null)))),JK(a),$APP.ed(a))};f2.G=2;$APP.ju.A(HF,MV);$APP.ju.A(VH,MV);
for(var g2=$APP.r(new $APP.H(null,14,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[qG,QK,BJ],null),new $APP.H(null,3,5,$APP.I,[hO,o1,uH],null),new $APP.H(null,3,5,$APP.I,[iO,n1,mH],null),new $APP.H(null,3,5,$APP.I,[vZ,p1,nK],null),new $APP.H(null,3,5,$APP.I,[yZ,q1,NM],null),new $APP.H(null,3,5,$APP.I,[mO,s1,mK],null),new $APP.H(null,3,5,$APP.I,[zZ,r1,lK],null),new $APP.H(null,3,5,$APP.I,[tG,t1,jK],null),new $APP.H(null,3,5,$APP.I,[AZ,u1,ZS],null),new $APP.H(null,3,5,$APP.I,[vH,w1,wH],null),new $APP.H(null,
3,5,$APP.I,[xH,v1,yH],null),new $APP.H(null,3,5,$APP.I,[DZ,x1,qX],null),new $APP.H(null,3,5,$APP.I,[IZ,y1,hW],null),new $APP.H(null,3,5,$APP.I,[JZ,z1,HV],null)],null)),h2=null,i2=0,j2=0;;)if(j2<i2){var Mpc=h2.aa(null,j2),Npc=$APP.x.B(Mpc,0,null),Opc=$APP.x.B(Mpc,1,null),Ppc=$APP.x.B(Mpc,2,null),Qpc=["g/",$APP.m.j(Ppc)," :emmy.operator/operator"].join("");Npc.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a,b,c,d,g,l,n,p,v){return function(t){return EK(p.j?p.j(t):p.call(null,t),new $APP.H(null,
2,5,$APP.I,[hI,1],null),$APP.T.j($APP.r($APP.N.A(new $APP.D(null,v,null,1,null),new $APP.D(null,IK(t),null,1,null)))),JK(t),null)}}(g2,h2,i2,j2,Qpc,Mpc,Npc,Opc,Ppc));j2+=1}else{var Rpc=$APP.r(g2);if(Rpc){var k2=Rpc;if($APP.pd(k2)){var Spc=$APP.lc(k2),Tpc=$APP.mc(k2),Upc=Spc,Vpc=$APP.Tc(Spc);g2=Tpc;h2=Upc;i2=Vpc}else{var Wpc=$APP.u(k2),Xpc=$APP.x.B(Wpc,0,null),Ypc=$APP.x.B(Wpc,1,null),Zpc=$APP.x.B(Wpc,2,null),$pc=["g/",$APP.m.j(Zpc)," :emmy.operator/operator"].join("");Xpc.F(null,new $APP.H(null,1,
5,$APP.I,[GW],null),function(a,b,c,d,g,l,n,p,v){return function(t){return EK(p.j?p.j(t):p.call(null,t),new $APP.H(null,2,5,$APP.I,[hI,1],null),$APP.T.j($APP.r($APP.N.A(new $APP.D(null,v,null,1,null),new $APP.D(null,IK(t),null,1,null)))),JK(t),null)}}(g2,h2,i2,j2,$pc,Wpc,Xpc,Ypc,Zpc,k2,Rpc));g2=$APP.w(k2);h2=null;i2=0}j2=0}else break}MF.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){var b=$APP.R3a.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):$APP.Uc.A(a.o,vG)});
uG.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){var b=Gzb.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):!1});kZ.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){var b=Feb.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):$APP.Uc.A(a.o,$APP.Kd)});vG.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){var b=vWa.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):new DK(vG,a.arity,LDb,a.context,a.ca)});
PF.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){var b=xWa.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):new DK($APP.Kd,a.arity,$APP.Fx,a.context,a.ca)});lZ.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){var b=oPb.j(a.context);return $APP.k(b)?b.j?b.j(a):b.call(null,a):new DK($APP.Kd,a.arity,$APP.Fx,a.context,a.ca)});cG.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){a=cG.j(a.name);return Kpc.j?Kpc.j(a):Kpc.call(null,a)});
gH.F(null,new $APP.H(null,2,5,$APP.I,[GW,GW],null),function(a,b){return uZa(a,b)});gH.F(null,new $APP.H(null,2,5,$APP.I,[GW,MV],null),function(a,b){return rZa(gH,$APP.Iv,a,b)});gH.F(null,new $APP.H(null,2,5,$APP.I,[MV,GW],null),function(a,b){return qZa(gH,$APP.Iv,a,b)});RF.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){return sZa(a)});AG.F(null,new $APP.H(null,2,5,$APP.I,[GW,GW],null),function(a,b){return tZa(a,b)});
AG.F(null,new $APP.H(null,2,5,$APP.I,[GW,MV],null),function(a,b){return rZa(AG,$APP.Jv,a,b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[MV,GW],null),function(a,b){return qZa(AG,$APP.Jv,a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[GW,GW],null),function(a,b){return e2.A(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[GW,MV],null),function(a,b){return wZa(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[MV,GW],null),function(a,b){return vZa(a,b)});
nG.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){return e2.A(a,a)});qZ.F(null,new $APP.H(null,1,5,$APP.I,[GW],null),function(a){return e2.A(a,e2.A(a,a))});tI.F(null,new $APP.H(null,2,5,$APP.I,[GW,IY],null),function(a,b){return $APP.Id.A(e2,$APP.Vj.A(b,a))});BG.F(null,new $APP.H(null,2,5,$APP.I,[GW,HF],null),function(a,b){return xZa(a,b)});eR.F(null,new $APP.H(null,2,5,$APP.I,[GW,HF],null),function(a,b){return xZa(a,b)});
XF.F(null,new $APP.H(null,2,5,$APP.I,[HF,GW],null),function(a,b){return xZa(b,a)});var l2=new $APP.f(null,2,[UK,zP,ZK,yP],null),fL=new $APP.f(null,2,[UK,"↑",ZK,"_"],null),BP=new $APP.f(null,2,[UK,ZK,ZK,UK],null);$APP.ju.A(UK,cS);$APP.ju.A(ZK,cS);$APP.ju.A($APP.H,UK);$APP.ju.A(Array,UK);$APP.ju.A(cS,lI);$APP.ju.A(cS,MV);var m2=function m2(a){switch(arguments.length){case 1:return m2.j(arguments[0]);case 2:return m2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};m2.j=function(a){return $APP.Vg.A($APP.Pi.A(AZa,a),$APP.Jj.J())};
m2.A=function(a,b){return $APP.We.A(a,m2.j(b))};m2.G=2;$APP.e=RK.prototype;$APP.e.Hc=$APP.xc;$APP.e.Ac=function(a,b){return $APP.wb(this.v,b)};$APP.e.toString=function(){return["(",$APP.m.j(this.orientation.j?this.orientation.j(l2):this.orientation.call(null,l2))," ",$APP.Kl.A(" ",$APP.Vg.A($APP.jh,this.v)),")"].join("")};$APP.e.Ka=function(a,b){return $APP.Os(this.v,b)};$APP.e.fa=function(a,b,c){return $APP.Os(this.v,b,c)};$APP.e.lb=function(a,b,c){return $APP.Jb(this.v,b,c)};
$APP.e.aa=function(a,b){return $APP.bd(this.v,b)};$APP.e.eb=function(a,b,c){return $APP.bd(this.v,b,c)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};$APP.e.Qa=function(){return $APP.qc(this.v)};$APP.e.ba=function(){return this.ca};$APP.e.ta=function(){return $APP.lb(this.v)};$APP.e.Ic=function(){return $APP.Qb(this.v)};$APP.e.Y=function(a,b){return CZa.A?CZa.A(this,b):CZa.call(null,this,b)};$APP.e.Sa=function(){return new RK(this.orientation,$APP.sf,this.ca)};
$APP.e.fb=function(a,b){return $APP.Ps(this.v,b)};$APP.e.bb=function(a,b,c){return $APP.Ps(this.v,b,c)};$APP.e.rb=function(){return this.orientation};$APP.e.bc=function(){return BWa(this.v)};$APP.e.sa=function(a,b,c){return new RK(this.orientation,$APP.vb(this.v,b,c),this.ca)};$APP.e.Va=function(a,b){return $APP.ub(this.v,b)};$APP.e.ma=function(){return $APP.Mb(this.v)};$APP.e.da=function(a,b){return new RK(this.orientation,this.v,b)};
$APP.e.ua=function(a,b){return new RK(this.orientation,$APP.nb(this.v,b),this.ca)};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Kb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){return new RK(this.orientation,$APP.Hl.A(function(a){return a.J?a.J():a.call(null)},this.v),this.ca)};$APP.e.j=function(a){return new RK(this.orientation,$APP.Hl.A(function(b){return b.j?b.j(a):b.call(null,a)},this.v),this.ca)};
$APP.e.A=function(a,b){return new RK(this.orientation,$APP.Hl.A(function(c){return c.A?c.A(a,b):c.call(null,a,b)},this.v),this.ca)};$APP.e.B=function(a,b,c){return new RK(this.orientation,$APP.Hl.A(function(d){return d.B?d.B(a,b,c):d.call(null,a,b,c)},this.v),this.ca)};$APP.e.K=function(a,b,c,d){return new RK(this.orientation,$APP.Hl.A(function(g){return g.K?g.K(a,b,c,d):g.call(null,a,b,c,d)},this.v),this.ca)};
$APP.e.S=function(a,b,c,d,g){return new RK(this.orientation,$APP.Hl.A(function(l){return l.S?l.S(a,b,c,d,g):l.call(null,a,b,c,d,g)},this.v),this.ca)};$APP.e.la=function(a,b,c,d,g,l){return new RK(this.orientation,$APP.Hl.A(function(n){return n.la?n.la(a,b,c,d,g,l):n.call(null,a,b,c,d,g,l)},this.v),this.ca)};$APP.e.Ga=function(a,b,c,d,g,l,n){return new RK(this.orientation,$APP.Hl.A(function(p){return p.Ga?p.Ga(a,b,c,d,g,l,n):p.call(null,a,b,c,d,g,l,n)},this.v),this.ca)};
$APP.e.va=function(a,b,c,d,g,l,n,p){return new RK(this.orientation,$APP.Hl.A(function(v){return v.va?v.va(a,b,c,d,g,l,n,p):v.call(null,a,b,c,d,g,l,n,p)},this.v),this.ca)};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){return new RK(this.orientation,$APP.Hl.A(function(t){return t.Ha?t.Ha(a,b,c,d,g,l,n,p,v):t.call(null,a,b,c,d,g,l,n,p,v)},this.v),this.ca)};
$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){return new RK(this.orientation,$APP.Hl.A(function(A){return A.wa?A.wa(a,b,c,d,g,l,n,p,v,t):A.call(null,a,b,c,d,g,l,n,p,v,t)},this.v),this.ca)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){return new RK(this.orientation,$APP.Hl.A(function(B){return B.xa?B.xa(a,b,c,d,g,l,n,p,v,t,A):B.call(null,a,b,c,d,g,l,n,p,v,t,A)},this.v),this.ca)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){return new RK(this.orientation,$APP.Hl.A(function(G){return G.ya?G.ya(a,b,c,d,g,l,n,p,v,t,A,B):G.call(null,a,b,c,d,g,l,n,p,v,t,A,B)},this.v),this.ca)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){return new RK(this.orientation,$APP.Hl.A(function(J){return J.za?J.za(a,b,c,d,g,l,n,p,v,t,A,B,G):J.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G)},this.v),this.ca)};
$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){return new RK(this.orientation,$APP.Hl.A(function(O){return O.Aa?O.Aa(a,b,c,d,g,l,n,p,v,t,A,B,G,J):O.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J)},this.v),this.ca)};$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){return new RK(this.orientation,$APP.Hl.A(function(R){return R.Ba?R.Ba(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O):R.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O)},this.v),this.ca)};
$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R){return new RK(this.orientation,$APP.Hl.A(function(W){return W.Ca?W.Ca(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R):W.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R)},this.v),this.ca)};$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W){return new RK(this.orientation,$APP.Hl.A(function(Z){return Z.Da?Z.Da(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W):Z.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W)},this.v),this.ca)};
$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z){return new RK(this.orientation,$APP.Hl.A(function(fa){return fa.Ea?fa.Ea(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z):fa.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z)},this.v),this.ca)};$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa){return new RK(this.orientation,$APP.Hl.A(function(ia){return ia.Fa?ia.Fa(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa):ia.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa)},this.v),this.ca)};
$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia){return new RK(this.orientation,$APP.Hl.A(function(ja){return ja.La?ja.La(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia):ja.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia)},this.v),this.ca)};$APP.e.Kb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja){return new RK(this.orientation,$APP.Hl.A(function(ta){return $APP.Je.C(ta,a,b,c,d,$APP.y([g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja]))},this.v),this.ca)};
$APP.e.ac=function(a,b,c){function d(g){return HH(g,b,c)}return mL.A?mL.A(d,this):mL.call(null,d,this)};$APP.e.$b=function(a,b,c){function d(g){return IH(g,b,c)}return mL.A?mL.A(d,this):mL.call(null,d,this)};$APP.e.ic=function(a,b){function c(d){return JH(d,b)}return mL.A?mL.A(c,this):mL.call(null,c,this)};RK.prototype[$APP.Cc]=function(){return $APP.Hc(this)};RK.prototype.map=function(a){return mL.A?mL.A(a,this):mL.call(null,a,this)};RK.prototype.at=function(a){return $APP.x.A(this.v,a)};
var tP=function tP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return tP.C(c)};tP.C=function(a){return function(b){return $APP.am.A(b,a)}};tP.G=0;tP.M=function(a){return this.C($APP.r(a))};hG.F(null,new $APP.H(null,2,5,$APP.I,[ZK,UK],null),function(){return!1});hG.F(null,new $APP.H(null,2,5,$APP.I,[UK,ZK],null),function(){return!1});hG.F(null,new $APP.H(null,2,5,$APP.I,[ZK,$R],null),function(){return!1});
hG.F(null,new $APP.H(null,2,5,$APP.I,[$R,ZK],null),function(){return!1});$APP.qda(hG,new $APP.H(null,2,5,$APP.I,[UK,ZK],null),new $APP.H(null,2,5,$APP.I,[$R,ZK],null));$APP.qda(hG,new $APP.H(null,2,5,$APP.I,[ZK,UK],null),new $APP.H(null,2,5,$APP.I,[ZK,$R],null));
for(var n2=$APP.r(new $APP.H(null,2,5,$APP.I,[UK,ZK],null)),o2=null,p2=0,q2=0;;)if(q2<p2){var r2=o2.aa(null,q2);MF.F(null,new $APP.H(null,1,5,$APP.I,[r2],null),function(){return function(a){return $APP.Ge(MF,a)}}(n2,o2,p2,q2,r2));uG.F(null,new $APP.H(null,1,5,$APP.I,[r2],null),function(){return function(){return!1}}(n2,o2,p2,q2,r2));kZ.F(null,new $APP.H(null,1,5,$APP.I,[r2],null),function(){return function(){return!1}}(n2,o2,p2,q2,r2));vG.F(null,new $APP.H(null,1,5,$APP.I,[r2],null),function(){return function(a){return new RK(a.orientation,
vG.j(a.v),a.ca)}}(n2,o2,p2,q2,r2));PF.F(null,new $APP.H(null,1,5,$APP.I,[r2],null),function(){return function(){return 1}}(n2,o2,p2,q2,r2));lZ.F(null,new $APP.H(null,1,5,$APP.I,[r2],null),function(){return function(){return 1}}(n2,o2,p2,q2,r2));VF.F(null,new $APP.H(null,1,5,$APP.I,[r2],null),function(){return function(a){return $APP.Ge(VF,a.v)}}(n2,o2,p2,q2,r2));cG.F(null,new $APP.H(null,1,5,$APP.I,[r2],null),function(){return function(a){var b=$APP.T.j,c=$APP.N.A;var d=a.orientation;d=d.j?d.j(l2):
d.call(null,l2);return b.call($APP.T,$APP.r(c.call($APP.N,new $APP.D(null,d,null,1,null),$APP.Vg.A(cG,a.v))))}}(n2,o2,p2,q2,r2));q2+=1}else{var s2=$APP.r(n2);if(s2){var t2=s2;if($APP.pd(t2)){var aqc=$APP.lc(t2),bqc=$APP.mc(t2),cqc=aqc,dqc=$APP.Tc(aqc);n2=bqc;o2=cqc;p2=dqc}else{var u2=$APP.u(t2);MF.F(null,new $APP.H(null,1,5,$APP.I,[u2],null),function(){return function(a){return $APP.Ge(MF,a)}}(n2,o2,p2,q2,u2,t2,s2));uG.F(null,new $APP.H(null,1,5,$APP.I,[u2],null),function(){return function(){return!1}}(n2,
o2,p2,q2,u2,t2,s2));kZ.F(null,new $APP.H(null,1,5,$APP.I,[u2],null),function(){return function(){return!1}}(n2,o2,p2,q2,u2,t2,s2));vG.F(null,new $APP.H(null,1,5,$APP.I,[u2],null),function(){return function(a){return new RK(a.orientation,vG.j(a.v),a.ca)}}(n2,o2,p2,q2,u2,t2,s2));PF.F(null,new $APP.H(null,1,5,$APP.I,[u2],null),function(){return function(){return 1}}(n2,o2,p2,q2,u2,t2,s2));lZ.F(null,new $APP.H(null,1,5,$APP.I,[u2],null),function(){return function(){return 1}}(n2,o2,p2,q2,u2,t2,s2));VF.F(null,
new $APP.H(null,1,5,$APP.I,[u2],null),function(){return function(a){return $APP.Ge(VF,a.v)}}(n2,o2,p2,q2,u2,t2,s2));cG.F(null,new $APP.H(null,1,5,$APP.I,[u2],null),function(){return function(a){var b=$APP.T.j,c=$APP.N.A;var d=a.orientation;d=d.j?d.j(l2):d.call(null,l2);return b.call($APP.T,$APP.r(c.call($APP.N,new $APP.D(null,d,null,1,null),$APP.Vg.A(cG,a.v))))}}(n2,o2,p2,q2,u2,t2,s2));n2=$APP.w(t2);o2=null;p2=0}q2=0}else break}
var eqc=KZa(ZK,ZK),fqc=KZa(UK,UK),gqc=KZa(UK,ZK),hqc=KZa(ZK,UK),wL=function wL(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return wL.C(c)};wL.C=function(a){return bL(a)};wL.G=0;wL.M=function(a){return this.C($APP.r(a))};var SN=function SN(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return SN.C(c)};
SN.C=function(a){return aL(ZK,a)};SN.G=0;SN.M=function(a){return this.C($APP.r(a))};var v2=function v2(a){switch(arguments.length){case 1:return v2.j(arguments[0]);case 2:return v2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};v2.j=function(a){return XK(a)?v2.A(a,TK(a)):a};v2.A=function(a,b){a=VK(a);a=BP.j?BP.j(a):BP.call(null,a);return aL(a,b)};v2.G=2;
var w2=function w2(a,b){return OZa(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return XK($APP.u(l))?w2.A?w2.A(a,l):w2.call(null,a,l):$APP.Je.A(a,l)}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),b)},qP=function qP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),
0,null):null;return qP.C(arguments[0],c)};qP.C=function(a,b){return w2(a,b)};qP.G=1;qP.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var $N=function $N(a){switch(arguments.length){case 2:return $N.A(arguments[0],arguments[1]);case 3:return $N.B(arguments[0],arguments[1],arguments[2]);case 4:return $N.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
$N.A=function(a,b){return $N.K(a,a.J?a.J():a.call(null),a,b)};$N.B=function(a,b,c){return $N.K(a,b,a,c)};$N.K=function(a,b,c,d){b=function t(l,n,p,v){if(XK(n)){var A=VK(n);return $APP.Id.B(function(G,J){return t(G,BZa(n,J),$APP.Vd.A(p,J),$APP.Vd.A(v,A))},l,$APP.Jj.j($APP.Tc(n)))}var B=new $APP.H(null,3,5,$APP.I,[n,p,v],null);return a.A?a.A(l,B):a.call(null,l,B)}(b,d,$APP.sf,$APP.sf);return c.j?c.j(b):c.call(null,b)};$N.G=4;
var x2=function x2(a,b){return PZa(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return XK($APP.u(l))?x2.A?x2.A(a,l):x2.call(null,a,l):$APP.Je.A(a,l)}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),b)},mL=function mL(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),
0,null):null;return mL.C(arguments[0],c)};mL.C=function(a,b){return x2(a,b)};mL.G=1;mL.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var HN=function HN(a){switch(arguments.length){case 2:return HN.A(arguments[0],arguments[1]);case 3:return HN.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};HN.A=function(a,b){return HN.B(dL,a,b)};
HN.B=function(a,b,c){return $APP.Xc(function n(g,l){if(XK(l)){var p=$APP.Id.B(function(v,t){var A=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);A=n(A,t);t=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return new $APP.H(null,2,5,$APP.I,[t,$APP.Vd.A(v,A)],null)},new $APP.H(null,2,5,$APP.I,[g,$APP.sf],null),l);g=$APP.x.B(p,0,null);p=$APP.x.B(p,1,null);return new $APP.H(null,2,5,$APP.I,[g,a.A?a.A(l,p):a.call(null,l,p)],null)}return new $APP.H(null,2,5,$APP.I,[$APP.Fc(g),$APP.u(g)],null)}(b,c))};HN.G=3;
var oL=function oL(a){if(XK(a)){var c=VK(a);c=BP.j?BP.j(c):BP.call(null,c);a=SK(c,$APP.Hl.A(oL,TK(a)),$APP.ed(a))}return a},tL=function tL(a,b){return!FZa(a,b)&&$APP.Uc.A($APP.Tc(a),$APP.Tc(b))&&$APP.Ge(function(d){var g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);var l=!XK(g);return l?l:(l=!XK(d))?l:tL.A?tL.A(g,d):tL.call(null,g,d)},$APP.Vg.B($APP.ps,a,b))};gH.F(null,new $APP.H(null,2,5,$APP.I,[ZK,ZK],null),function(a,b){return YZa(mG,a,b)});
gH.F(null,new $APP.H(null,2,5,$APP.I,[UK,UK],null),function(a,b){return YZa(mG,a,b)});RF.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return mL.C(RF,$APP.y([a]))});AG.F(null,new $APP.H(null,2,5,$APP.I,[ZK,ZK],null),function(a,b){return YZa(TF,a,b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[UK,UK],null),function(a,b){return YZa(TF,a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[cS,cS],null),function(a,b){return uL(a,b)});
OF.F(null,new $APP.H(null,2,5,$APP.I,[cS,HF],null),function(a,b){return TZa(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[HF,cS],null),function(a,b){return UZa(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[cS,HF],null),function(a,b){return TZa(a,QF.j(b))});OF.F(null,new $APP.H(null,2,5,$APP.I,[GW,cS],null),function(a,b){return dL(b,$APP.Vg.A(function(c){return kG.A(a,c)},b))});OF.F(null,new $APP.H(null,2,5,$APP.I,[cS,GW],null),function(a,b){return dL(a,$APP.Vg.A(function(c){return kG.A(c,b)},a))});
nG.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return vL(a,a)});qZ.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return uL(a,uL(a,a))});tI.F(null,new $APP.H(null,2,5,$APP.I,[cS,GG],null),function(a,b){var c=PF.j(b);return $APP.k(uG.j(b))?a:b>c?kG.A(a,tI.A(a,TF.A(b,c))):AD(["Cannot: ",$APP.m.j($APP.T.j($APP.r($APP.N.C(new $APP.D(null,bVb,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))))].join(""))});
dG.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return mL.C(dG,$APP.y([a]))});zG.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){var b=lG.j;a=vL(sL.j(a),a);return b.call(lG,a)});jG.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return lG.j(vL(a,a))});PZ.F(null,new $APP.H(null,2,5,$APP.I,[UK,UK],null),function(a,b){return mL.C(PZ,$APP.y([a,b]))});PZ.F(null,new $APP.H(null,2,5,$APP.I,[ZK,ZK],null),function(a,b){return mL.C(PZ,$APP.y([a,b]))});
QZ.F(null,new $APP.H(null,2,5,$APP.I,[UK,UK],null),function(a,b){return mL.C(QZ,$APP.y([a,b]))});QZ.F(null,new $APP.H(null,2,5,$APP.I,[ZK,ZK],null),function(a,b){return mL.C(QZ,$APP.y([a,b]))});zH.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return mL.C(zH,$APP.y([a]))});CH.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return mL.C(CH,$APP.y([a]))});sL.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return mL.C(sL,$APP.y([a]))});
gR.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return oL(a)});NO.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return WK(a)});DH.F(null,new $APP.H(null,2,5,$APP.I,[cS,cS],null),function(a,b){return vL(a,b)});TZ.F(null,new $APP.H(null,2,5,$APP.I,[cS,cS],null),function(a,b){return vL(sL.j(a),b)});UZ.F(null,new $APP.H(null,2,5,$APP.I,[cS,cS],null),function(a,b){return WZa(a,b)});VZ.F(null,new $APP.H(null,2,5,$APP.I,[UK,UK],null),function(a,b){return XZa(a,b)});$APP.e=xL.prototype;$APP.e.toString=function(){return y2.j?y2.j(this):y2.call(null,this)};$APP.e.ac=function(a,b,c){function d(g){return HH(g,b,c)}return KL.A?KL.A(d,this):KL.call(null,d,this)};$APP.e.$b=function(a,b,c){function d(g){return IH(g,b,c)}return KL.A?KL.A(d,this):KL.call(null,d,this)};$APP.e.ic=function(a,b){function c(d){return JH(d,b)}return KL.A?KL.A(c,this):KL.call(null,c,this)};
$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.polynomial.Polynomial "',this.toString(),'"]']))};$APP.e.ba=function(){return this.ca};$APP.e.Y=function(a,b){return FL.A?FL.A(this,b):FL.call(null,this,b)};$APP.e.rb=function(){return ZL};$APP.e.bc=function(){return new $APP.H(null,3,5,$APP.I,[PX,0,this.arity],null)};$APP.e.ma=function(){return $APP.r(this.Ra)};$APP.e.da=function(a,b){return new xL(this.arity,this.Ra,b)};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Kb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){return WL.A?WL.A(this,$APP.sf):WL.call(null,this,$APP.sf)};$APP.e.j=function(a){a=new $APP.H(null,1,5,$APP.I,[a],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};
$APP.e.A=function(a,b){a=new $APP.H(null,2,5,$APP.I,[a,b],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.B=function(a,b,c){a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.K=function(a,b,c,d){a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.S=function(a,b,c,d,g){a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};
$APP.e.la=function(a,b,c,d,g,l){a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.Ga=function(a,b,c,d,g,l,n){a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.va=function(a,b,c,d,g,l,n,p){a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};
$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R){a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};
$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W){a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z){a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa){a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia){a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null);return WL.A?WL.A(this,a):WL.call(null,this,a)};
$APP.e.Kb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja){a=$APP.Lf.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null),ja);return WL.A?WL.A(this,a):WL.call(null,this,a)};var VL=function VL(a){switch(arguments.length){case 1:return VL.j(arguments[0]);case 2:return VL.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};VL.j=function(a){a=VWa(a);return AL(1,a)};VL.A=function(a,b){b=WWa(b);return AL(a,b)};
VL.G=2;var DL=function DL(a){switch(arguments.length){case 1:return DL.j(arguments[0]);case 2:return DL.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};DL.j=function(a){return DL.A(1,a)};DL.A=function(a,b){return yL(a,UWa(b),null)};DL.G=2;
var BL=function BL(a){switch(arguments.length){case 0:return BL.J();case 1:return BL.j(arguments[0]);case 2:return BL.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};BL.J=function(){return BL.A(1,0)};BL.j=function(a){return BL.A(a,0)};BL.A=function(a,b){b=AI.A?AI.A(b,1):AI.call(null,b,1);return yL(a,new $APP.H(null,1,5,$APP.I,[zI.A(b,1)],null),null)};BL.G=2;
var UL=function UL(a){switch(arguments.length){case 1:return UL.j(arguments[0]);case 2:return UL.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};UL.j=function(a){return $APP.k(MF.j(a))?-1:zL(a)?vI(xI(HL.j?HL.j(a):HL.call(null,a))):0};UL.A=function(a,b){var c=d_a(a,b);return $APP.k(MF.j(a))?-1:zL(a)?$APP.Xs.K($APP.Vg.j(function(d){return wI(xI(d),c)}),$APP.Hj,0,a.Ra):0};UL.G=2;
var y2=function y2(a){switch(arguments.length){case 1:return y2.j(arguments[0]);case 2:return y2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};y2.j=function(a){return y2.A(a,10)};y2.A=function(a,b){var c=a.Ra;a=a.arity;var d=$APP.Tc(c);c=$APP.We.A(b,$APP.Vg.A(TWa,c));b=d>b?["... and ",$APP.m.j(d-b)," more terms"].join(""):null;return[$APP.m.j(a),": (",$APP.Kl.A(" + ",c),b,")"].join("")};y2.G=2;
var jM=function jM(a){switch(arguments.length){case 2:return jM.A(arguments[0],arguments[1]);case 3:return jM.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};jM.A=function(a,b){return jM.B(a,b,null)};
jM.B=function(a,b,c){function d(){var g=a.j?a.j(uI):a.call(null,uI);if($APP.hd(g))return b;var l=$APP.k(c)?c:yD("`new-arity` argument to `map-exponents` required when promoting constant.");return yL(l,new $APP.H(null,1,5,$APP.I,[zI.A(g,b)],null),null)}return zL(b)?VL.A($APP.k(c)?c:b.arity,function(){return function n(l){return new $APP.de(null,function(){for(;;){var p=$APP.r(l);if(p){if($APP.pd(p)){var v=$APP.lc(p),t=$APP.Tc(v),A=$APP.fe(t);a:for(var B=0;;)if(B<t){var G=$APP.bd(v,B),J=$APP.x.B(G,
0,null);G=$APP.x.B(G,1,null);J=a.j?a.j(J):a.call(null,J);$APP.je(A,zI.A(J,G));B+=1}else{v=!0;break a}return v?$APP.ie($APP.ke(A),n($APP.mc(p))):$APP.ie($APP.ke(A),null)}v=$APP.u(p);A=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);A=a.j?a.j(A):a.call(null,A);return $APP.Yd(zI.A(A,v),n($APP.Fc(p)))}return null}},null,null)}(b.Ra)}()):$APP.k(MF.j(b))?b:d()};jM.G=3;
var z2=function z2(a){switch(arguments.length){case 1:return z2.j(arguments[0]);case 2:return z2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};z2.j=function(a){return z2.A(a,UL.j(a))};
z2.A=function(a,b){if(!zL(a))return $APP.Lf.A(new $APP.H(null,1,5,$APP.I,[a],null),$APP.Vj.A(b,0));var c=UL.j(a);a=a.Ra;for(var d=$APP.bc($APP.sf),g=0;;){if(g>c)return $APP.Lf.A($APP.dc(d),$APP.Vj.A(b-c,0));var l=$APP.u(a),n=xI(l);n=wI(n,0);$APP.Uc.A(n,g)?(a=$APP.Fc(a),d=$APP.mf.A(d,yI(l)),g+=1):(d=$APP.mf.A(d,0),g+=1)}};z2.G=2;
var A2=function A2(a){switch(arguments.length){case 1:return A2.j(arguments[0]);case 2:return A2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};A2.j=function(a){return A2.A(a,IL(a))};A2.A=function(a,b){return $APP.k(uG.j(b))?a:$APP.k(MF.j(b))?AD(["Divide by zero: ",$APP.m.j(a),$APP.m.j(b)].join("")):zL(b)?TL.A?TL.A(a,b):TL.call(null,a,b):i_a(a,QF.j(b))};A2.G=2;
var B2=function B2(a){switch(arguments.length){case 1:return B2.j(arguments[0]);case 2:return B2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};B2.j=function(a){return B2.A(a,0)};B2.A=function(a,b){if(zL(a)){var c=UL.A(a,b);return 0===c?a:jM.A(function(d){var g=wI(d,b);g=c-g;return 0===g?$APP.Oi.A(d,b):$APP.rg.B(d,b,g)},a)}return a};B2.G=2;
var C2=function C2(a){switch(arguments.length){case 2:return C2.A(arguments[0],arguments[1]);case 3:return C2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};C2.A=function(a,b){return C2.B(a,b,$APP.ps)};
C2.B=function(a,b,c){var d=IL(a);return function B(l,n,p,v,t,A){var G=UL.j(A),J=zL(A)?l-G:l;if($APP.Uc.A(J,1)){var O=b*n+IL(A);l=b*p+n;p=b*v+p;t=Math.abs(b)*t+Math.abs(O)}else if($APP.Uc.A(J,2)){var R=b*b,W=Math.abs(R);O=R*n+IL(A);l=R*p+2*b*n;p=R*v+2*b*p+n;t=W*(t+n)+Math.abs(O)}else{var Z=RL(b,J-2),fa=Z*b;R=fa*b;W=Math.abs(R);O=R*n+IL(A);l=R*p+J*fa*n;p=R*v+J*fa*p+.5*J*(J-1)*Z*n;t=W*(t+(J-1)*n)+Math.abs(O)}n=O;O=p;zL(A)?A=B(G,n,l,O,t,k_a(A)):(A=2*O,G=OR*(t-Math.abs(n)+t),A=c.K?c.K(n,l,A,G):c.call(null,
n,l,A,G));return A}(UL.j(a),d,0,0,.5*Math.abs(d),k_a(a))};C2.G=3;var iqc=$APP.fg([vV,kK,FJ,$APP.Iv,RX,cT,$APP.Hv,FV,$APP.Jv],[qZ,O_.A(yM,0),tI,O_.A(gH,0),RF,nG,O_.B(OF,1,MF),O_.B(qM,1,MF),P_.K(AG,gH,RF,0)]),jqc=rD(iqc),D2=function D2(a){switch(arguments.length){case 1:return D2.j(arguments[0]);case 2:return D2.A(arguments[0],arguments[1]);case 3:return D2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
D2.j=function(a){return D2.B(a,$APP.ps,$APP.Ed)};D2.A=function(a,b){return D2.B(a,b,$APP.Ed)};D2.B=function(a,b,c){var d=$APP.mz.A(aG(a),jqc),g=$APP.Tc(d);c=$APP.gi.A(c,d);g=$APP.Bg(c,CL(g));a=RSa(a,g,iqc);return b.A?b.A(a,c):b.call(null,a,c)};D2.G=3;var A_a=FH($APP.Hv),B_a=FH($APP.Iv),z_a=FH(FJ),T0a;
if("undefined"===typeof eM||"undefined"===typeof Coc||"undefined"===typeof X0)X0=function(a){this.pk=a;this.O=393216;this.U=0},$APP.e=X0.prototype,$APP.e.da=function(a,b){return new X0(b)},$APP.e.ba=function(){return this.pk},$APP.e.Jg=function(a,b,c){return D2.A(b,c)},$APP.e.Af=function(a,b,c,d){return D2.B(b,c,d)},$APP.e.zf=function(a,b,c){return YL(b,c)},$APP.e.Le=function(a,b){return $APP.Bd(jqc,b)},X0.cb=!0,X0.Ya="emmy.polynomial/t_emmy$polynomial48683",X0.gb=function(a){return $APP.Vb(a,"emmy.polynomial/t_emmy$polynomial48683")},
Doc=function(a){return new X0(a)};T0a=new X0($APP.F);$APP.ju.A(HF,$L);$APP.ju.A(lT,$L);hG.F(null,new $APP.H(null,2,5,$APP.I,[ZL,ZL],null),function(a,b){return FL(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[ZL,$L],null),function(a,b){return FL(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[$L,ZL],null),function(a,b){return FL(b,a)});aM(gH,ML);aM(AG,NL);aM(OF,OL);aM(sI,function(a,b){return $APP.x.A(SL(a,b),0)});aM(CG,function(a,b){return $APP.x.A(SL(a,b),1)});
MF.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){return $APP.hd(a.Ra)});uG.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){a=a.Ra;var b=$APP.Uc.A($APP.Tc(a),1);return b?(a=$APP.x.B(a,0,null),(b=$APP.hd(xI(a)))?uG.j(yI(a)):b):b});kZ.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){var b=a.Ra;a=uG.j(a.arity);return $APP.k(a)?(a=$APP.Uc.A($APP.Tc(b),1))?(b=$APP.x.B(b,0,null),(a=$APP.Uc.A(new $APP.f(null,1,[0,1],null),xI(b)))?uG.j(yI(b)):a):a:a});
vG.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){a=$APP.x.A(a.Ra,0);return $APP.k(a)?vG.j(yI(a)):0});PF.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){a=$APP.x.A(a.Ra,0);return $APP.k(a)?PF.j(yI(a)):1});lZ.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){var b=$APP.x.A(a.Ra,0);b=$APP.k(b)?PF.j(yI(b)):1;b=zI.A(AI.A?AI.A(0,1):AI.call(null,0,1),b);return new xL(1,new $APP.H(null,1,5,$APP.I,[b],null),a.ca)});
cG.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,Klb,null,1,null),new $APP.D(null,a.arity,null,1,null),$APP.y([new $APP.D(null,a.Ra,null,1,null)]))))});VF.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(){return!1});sG.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){return JL(a)});jG.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){return o_a(a)});RF.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){return LL(a)});
nG.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){return PL(a)});qZ.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){return QL(a)});tI.F(null,new $APP.H(null,2,5,$APP.I,[ZL,IY],null),function(a,b){return RL(a,b)});kM.F(null,new $APP.H(null,2,5,$APP.I,[ZL,ZL],null),function(a,b){return TL(a,b)});kM.F(null,new $APP.H(null,2,5,$APP.I,[ZL,$L],null),function(a,b){return TL(a,b)});dG.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){return KL(dG,a)});
oR.F(null,new $APP.H(null,2,5,$APP.I,[ZL,$R],null),function(a,b){return $APP.hd(b)?$APP.Uc.A(1,a.arity)?XL(a,0):cL(y_a(a)):$APP.Uc.A(1,$APP.Tc(b))?XL(a,$APP.u(b)):yD("Invalid selector! Only 1 deep supported.")});var kqc="undefined"!==typeof window?window:null,E2="undefined"!==typeof performance?performance:$APP.k(kqc)?kqc.performance:null,lqc=function(){var a=$APP.k(E2)?E2.now:null;if($APP.k(a))return a;a=$APP.k(E2)?E2.mozNow:null;if($APP.k(a))return a;a=$APP.k(E2)?E2.msNow:null;if($APP.k(a))return a;a=$APP.k(E2)?E2.oNow:null;return $APP.k(a)?a:$APP.k(E2)?E2.webkitNow:null}(),mqc=$APP.Uc.A("nodejs","default")?process:null,F2=$APP.k(mqc)?mqc.hrtime:null;var nqc=$APP.vd(lqc)?function(){var a=lqc.call(E2);return function(){return 1E6*(lqc.call(E2)-a)}}:null,oqc=$APP.vd(F2)?function(){var a=F2.J?F2.J():F2.call(null);return function(){var b=F2.j?F2.j(a):F2.call(null,a),c=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return 1E9*c+b}}:null,pqc=$APP.k(nqc)?nqc:$APP.k(oqc)?oqc:C_a;var J_a={},fM,F_a=new $APP.H(null,7,5,$APP.I,[G_a,Lbb,Xbb,flb,t5b,Wtb,N7b],null),qqc=new $APP.f(null,7,[G_a,"ns",Lbb,"μs",Xbb,"ms",flb,"s",t5b,"min",Wtb,"h",N7b,"d"],null);dM.prototype.Cf=function(){return $APP.k(this.gi)?this:new dM(pqc.J?pqc.J():pqc.call(null),this.offset,!0)};dM.prototype.Mg=function(a,b){return E_a($APP.k(this.gi)?(this.Ig.J?this.Ig.J():this.Ig.call(null))+this.offset:this.offset,b)};
dM.prototype.Bf=function(){var a=H_a(bM(this,G_a)),b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b)," ",$APP.m.j(qqc.j?qqc.j(a):qqc.call(null,a))].join("")};var hM=new $APP.H(null,2,5,$APP.I,[1E3,Xbb],null),gM=null,R_a=$APP.kh.j($APP.F),S_a=$APP.kh.j(0),T_a=$APP.kh.j(0),Y_a=$APP.kh.j(0),a0a=$APP.kh.j(0),oM=function oM(a){switch(arguments.length){case 1:return oM.j(arguments[0]);case 2:return oM.A(arguments[0],arguments[1]);case 3:return oM.B(arguments[0],arguments[1],arguments[2]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(3),0,null);return oM.C(arguments[0],arguments[1],arguments[2],
c)}};oM.j=function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return new $APP.H(null,2,5,$APP.I,[b,a],null)};oM.A=function(a,b){var c=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return b.A?b.A(c,a):b.call(null,c,a)};oM.B=function(a,b,c){var d=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return b.B?b.B(d,a,c):b.call(null,d,a,c)};
oM.C=function(a,b,c,d){function g(n,p){return $APP.Je.K(oM,new $APP.H(null,2,5,$APP.I,[n,p],null),c,d)}var l=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return b.B?b.B(l,a,g):b.call(null,l,a,g)};oM.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};oM.G=3;
var lM=O_.B(function(a,b){return GF(a)&&GF(b)?yM.A(a,b):1},0,uG),pM=function pM(a){switch(arguments.length){case 2:return pM.A(arguments[0],arguments[1]);case 3:return pM.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};pM.A=function(a,b){return pM.B(0,a,b)};
pM.B=function(a,b,c){N_a(a,"full-gcd",$APP.y([b,c]));b=U_a(function(d,g){var l=$_a(d,g);if($APP.k(l))return l;l=b_a(d,g);if(f_a(d))return b0a(d,g);if(f_a(g))return b0a(g,d);if($APP.Uc.A(l,1))return d0a(d,g);l=O_.B(function(n,p){return pM.B(a+1,n,p)},0,uG);P_a("full-gcd");return oM.C(new $APP.H(null,2,5,$APP.I,[d,g],null),u_a,X_a(l),$APP.y([c0a(l)]))},b,c);N_a(a,"\x3c-",$APP.y([b]));return b};pM.G=3;var rM=O_.A(f0a,0);aM(qM,g0a);
yM.F(null,new $APP.H(null,2,5,$APP.I,[ZL,ZL],null),function(a,b){return f0a(a,b)});yM.F(null,new $APP.H(null,2,5,$APP.I,[ZL,$L],null),function(a,b){return $APP.k(MF.j(b))?a:mM(a,b)});yM.F(null,new $APP.H(null,2,5,$APP.I,[$L,ZL],null),function(a,b){return $APP.k(MF.j(a))?b:mM(b,a)});var rqc={},G2,sqc,H2=AJ.C($APP.y([b2.C($APP.y([$APP.Hv])),a2.C($APP.y([$APP.Hv])),zYa($APP.Hv,1),mJ(xJ.A(new $APP.D(null,$APP.Hv,null,1,null),zJ),function(){return $APP.k(1)?1:fJ(1)})])),I2=function I2(a){switch(arguments.length){case 2:return I2.A(arguments[0],arguments[1]);case 3:return I2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};I2.A=function(a,b){return I2.B(a,b,$APP.Kd)};
I2.B=function(a,b,c){try{var d=$APP.Vg.A(function(l){l=YL(l,b);return c.j?c.j(l):c.call(null,l)},i0a(a)),g=j0a(d);return H2.j?H2.j(g):H2.call(null,g)}catch(l){if(l instanceof Error)return bH($APP.kw,"emmy.polynomial.factor",120,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,["Factorization choked! Simplifying the unfactored polynomial."],null)},null),-37723055),a=YL(a,b),H2.j?H2.j(a):H2.call(null,a);throw l;}};I2.G=3;
var J2=function J2(a){switch(arguments.length){case 1:return J2.j(arguments[0]);case 2:return J2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};J2.j=function(a){return J2.A(a,$APP.Kd)};J2.A=function(a,b){return D2.A($F(a),function(c,d){return I2.B(c,d,b)})};J2.G=2;
var tqc=function(){var a=FM.A(16,"-f-");return GM.A(function(){if("undefined"===typeof eM||"undefined"===typeof Coc||"undefined"===typeof rqc||"undefined"===typeof G2)G2=function(b,c){this.Yk=b;this.qk=c;this.O=393216;this.U=0},G2.prototype.da=function(b,c){return new G2(this.Yk,c)},G2.prototype.ba=function(){return this.qk},G2.prototype.Af=function(b,c,d,g){return D2.B(c,d,g)},G2.prototype.zf=function(b,c,d){return I2.A(c,d)},G2.prototype.Le=function(b,c){return T0a.Le(null,c)},G2.cb=!0,G2.Ya="emmy.polynomial.factor/t_emmy$polynomial$factor49028",
G2.gb=function(b){return $APP.Vb(b,"emmy.polynomial.factor/t_emmy$polynomial$factor49028")},sqc=function(b,c){return new G2(b,c)};return new G2(a,$APP.F)}(),a)}(),sM=lWa(tqc);var uqc={},K2,vqc,L2=function L2(a){switch(arguments.length){case 2:return L2.A(arguments[0],arguments[1]);case 3:return L2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};L2.A=function(a,b){return L2.B(a,b,null)};L2.B=function(a,b,c){a=CI(p0a,q0a(b),a);return $APP.Vg.A($APP.fd,$APP.k(c)?$APP.x.A(a,c):BI(a))};L2.G=3;$APP.e=uM.prototype;$APP.e.toString=function(){return[$APP.m.j(this.Jb)," : ",$APP.m.j(this.v)].join("")};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.rational-function.RationalFunction "',this.toString(),'"]']))};$APP.e.ba=function(){return this.ca};$APP.e.Y=function(a,b){return xM.A?xM.A(this,b):xM.call(null,this,b)};$APP.e.rb=function(){return DM};$APP.e.bc=function(){return new $APP.H(null,3,5,$APP.I,[PX,0,this.arity],null)};
$APP.e.ma=function(){return new $APP.D(null,this.Jb,new $APP.D(null,this.v,null,1,null),2,null)};$APP.e.da=function(a,b){return new uM(this.arity,this.Jb,this.v,b)};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Kb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){return BM.A?BM.A(this,$APP.sf):BM.call(null,this,$APP.sf)};$APP.e.j=function(a){a=new $APP.H(null,1,5,$APP.I,[a],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};
$APP.e.A=function(a,b){a=new $APP.H(null,2,5,$APP.I,[a,b],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.B=function(a,b,c){a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.K=function(a,b,c,d){a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.S=function(a,b,c,d,g){a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};
$APP.e.la=function(a,b,c,d,g,l){a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.Ga=function(a,b,c,d,g,l,n){a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.va=function(a,b,c,d,g,l,n,p){a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};
$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R){a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};
$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W){a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z){a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa){a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia){a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null);return BM.A?BM.A(this,a):BM.call(null,this,a)};
$APP.e.Kb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja){a=$APP.Lf.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null),ja);return BM.A?BM.A(this,a):BM.call(null,this,a)};$APP.e.Lg=function(){return this.Jb};$APP.e.Kg=function(){return this.v};
var wqc=$APP.rg.C(iqc,$APP.sj,P_.S(BG,OF,QF,1,MF),$APP.y([jX,QF])),xqc=rD(wqc),M2=function M2(a){switch(arguments.length){case 1:return M2.j(arguments[0]);case 2:return M2.A(arguments[0],arguments[1]);case 3:return M2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};M2.j=function(a){return M2.B(a,$APP.ps,$APP.Ed)};M2.A=function(a,b){return M2.B(a,b,$APP.Ed)};
M2.B=function(a,b,c){var d=$APP.mz.A(aG(a),xqc),g=$APP.Tc(d);c=$APP.gi.A(c,d);g=$APP.Bg(c,CL(g));a=RSa(a,g,wqc);return b.A?b.A(a,c):b.call(null,a,c)};M2.G=3;var V0a;
if("undefined"===typeof eM||"undefined"===typeof uqc||"undefined"===typeof K2)K2=function(a){this.rk=a;this.O=393216;this.U=0},$APP.e=K2.prototype,$APP.e.da=function(a,b){return new K2(b)},$APP.e.ba=function(){return this.rk},$APP.e.Jg=function(a,b,c){return M2.A(b,c)},$APP.e.Af=function(a,b,c,d){return M2.B(b,c,d)},$APP.e.zf=function(a,b,c){return R0a(b,c)},$APP.e.Le=function(a,b){return $APP.Bd(xqc,b)},K2.cb=!0,K2.Ya="emmy.rational-function/t_emmy$rational_function49062",K2.gb=function(a){return $APP.Vb(a,
"emmy.rational-function/t_emmy$rational_function49062")},vqc=function(a){return new K2(a)};V0a=new K2($APP.F);QF.F(null,new $APP.H(null,1,5,$APP.I,[ZL],null),function(a){var b=a.arity;return $APP.k(sG.j(a))?vM(b,-1,RF.j(a),$APP.ed(a)):vM(b,1,a,$APP.ed(a))});aM(BG,zM);aM(eR,zM);aM(XF,function(a,b){return AM(b,a)});kM.F(null,new $APP.H(null,2,5,$APP.I,[$L,ZL],null),function(a,b){var c=b.Ra,d=$APP.x.B(c,0,null);return $APP.Uc.A($APP.Tc(c),1)&&$APP.hd(xI(d))?kM.A(a,yI(d)):zM(a,b)});
hG.F(null,new $APP.H(null,2,5,$APP.I,[DM,DM],null),function(a,b){return xM(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[ZL,DM],null),function(a,b){return xM(b,a)});hG.F(null,new $APP.H(null,2,5,$APP.I,[$L,DM],null),function(a,b){return xM(b,a)});hG.F(null,new $APP.H(null,2,5,$APP.I,[DM,ZL],null),function(a,b){return xM(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[DM,$L],null),function(a,b){return xM(a,b)});EM(gH,I0a);EM(AG,J0a);EM(OF,K0a);EM(BG,AM);EM(kM,AM);EM(eR,AM);
EM(XF,function(a,b){return AM(b,a)});EM(yM,P0a);MF.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return MF.j(a.Jb)});uG.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){var b=uG.j(a.Jb);return $APP.k(b)?uG.j(a.v):b});kZ.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){var b=kZ.j(a.Jb);return $APP.k(b)?uG.j(a.v):b});vG.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return vG.j(a.Jb)});PF.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return PF.j(a.Jb)});
lZ.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return new uM(a.arity,lZ.j(a.Jb),PF.j(a.v),a.ca)});cG.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return new $APP.D(null,$APP.sj,new $APP.D(null,cG.j(a.Jb),new $APP.D(null,cG.j(a.v),null,1,null),2,null),3,null)});sG.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return z0a(a)});jG.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return H0a(a)});RF.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return G0a(a)});
QF.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return O0a(a)});nG.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return L0a(a)});qZ.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return M0a(a)});tI.F(null,new $APP.H(null,2,5,$APP.I,[DM,GG],null),function(a,b){return N0a(a,b)});dG.F(null,new $APP.H(null,1,5,$APP.I,[DM],null),function(a){return $APP.z(zM(dG.j(a.Jb),dG.j(a.v)),$APP.ed(a))});
oR.F(null,new $APP.H(null,2,5,$APP.I,[DM,$R],null),function(a,b){return $APP.hd(b)?$APP.Uc.A(1,a.arity)?CM(a,0):cL(Q0a(a)):$APP.Uc.A(1,$APP.Tc(b))?CM(a,$APP.u(b)):yD("Invalid selector! Only 1 deep supported.")});var HM=$APP.mh(GH(U0a())),IM=S0a($APP.mh(GH(W0a()))),Y0a=LM($APP.Jl.A(nZa(new $APP.Ac(function(){return IM},CX,$APP.fg([$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.Aj,$APP.im,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[hV,LT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(IM)?IM.Z:null]))),n0a)),QM=nZa(new $APP.Ac(function(){return IM},CX,$APP.fg([$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.Aj,$APP.im,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[hV,LT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(IM)?IM.Z:
null]))),$0a=WYa(new $APP.Ac(function(){return IM},CX,$APP.fg([$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.Aj,$APP.im,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[hV,LT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(IM)?IM.Z:null]))),Z0a=QYa(new $APP.Ac(function(){return IM},CX,$APP.fg([$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.Aj,$APP.im,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[hV,LT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(IM)?IM.Z:null]))),j1a=XYa(new $APP.Ac(function(){return IM},CX,$APP.fg([$APP.yl,
$APP.Q,$APP.Wi,$APP.Nr,$APP.Aj,$APP.im,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[hV,LT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(IM)?IM.Z:null]))),d1a=lZa(new $APP.Ac(function(){return IM},CX,$APP.fg([$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.Aj,$APP.im,$APP.Xi,$APP.Or,$APP.U,$APP.P,$APP.Pr],[hV,LT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(IM)?IM.Z:null]))),f1a=kZa(new $APP.Ac(function(){return IM},CX,$APP.fg([$APP.yl,$APP.Q,$APP.Wi,$APP.Nr,$APP.Aj,$APP.im,$APP.Xi,$APP.Or,$APP.U,
$APP.P,$APP.Pr],[hV,LT,"emmy/simplify.cljc",29,1,!0,47,47,$APP.Ec,null,$APP.k(IM)?IM.Z:null])));$APP.q.prototype.nd=function(){return!0};$APP.q.prototype.rb=function(){return $APP.q};$APP.ju.A($APP.q,RM);$APP.ju.A(RM,HF);hG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.q,$R],null),function(){return!1});hG.F(null,new $APP.H(null,2,5,$APP.I,[$R,$APP.q],null),function(){return!1});hG.F(null,new $APP.H(null,2,5,$APP.I,[$APP.q,VM],null),function(){return!1});hG.F(null,new $APP.H(null,2,5,$APP.I,[VM,$APP.q],null),function(){return!1});
hG.F(null,new $APP.H(null,2,5,$APP.I,[RM,$R],null),function(a,b){return hG.A($F(a),b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[$R,RM],null),function(a,b){return hG.A(a,$F(b))});hG.F(null,new $APP.H(null,2,5,$APP.I,[RM,VM],null),function(a,b){return hG.A($F(a),b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[VM,RM],null),function(a,b){return hG.A(a,$F(b))});hG.F(null,new $APP.H(null,2,5,$APP.I,[RM,RM],null),function(a,b){return $APP.Uc.A($F(a),$F(b))});WM(gH,$APP.Iv);WM(AG,$APP.Jv);WM(OF,$APP.Hv);WM(BG,$APP.sj);
WM(nI,$X);WM(CG,gS);WM(tI,FJ);UM(RF,RX);UM(QF,jX);UM(sZ,YV);UM(uZ,zW);UM(rZ,dT);UM(tZ,lY);UM(iO,mH);UM(hO,uH);UM(vZ,nK);UM(yZ,NM);UM(xZ,PM);UM(zZ,lK);UM(mO,mK);UM(tG,jK);WM(tG,jK);UM(AZ,ZS);UM(xH,yH);UM(vH,wH);UM(DZ,qX);UM(FZ,vW);UM(EZ,uT);UM(GZ,gW);UM(jG,$APP.Ku);UM(lG,HJ);UM(rG,DJ);var N2=FH(DJ),O2=FH($APP.sj);oZ.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(a){a=$F(a);a=N2.j?N2.j(a):N2.call(null,a);var b=N2.j?N2.j(2):N2.call(null,2);a=O2.A?O2.A(a,b):O2.call(null,a,b);return SM(a)});
pZ.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(a){a=$F(a);a=N2.j?N2.j(a):N2.call(null,a);var b=N2.j?N2.j(10):N2.call(null,10);a=O2.A?O2.A(a,b):O2.call(null,a,b);return SM(a)});UM(qG,BJ);WM(PZ,RV);WM(QZ,FT);UM(zH,bU);UM(CH,jV);UM(zG,CK);UM(RZ,EY);UM(sL,pY);WM(DH,IX);WM(TZ,tX);WM(yM,kK);WM(qM,FV);sG.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(){return!1});MF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(){return!1});
uG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(){return!1});kZ.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(){return!1});cG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(a){return a});VF.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(){return!1});dG.F(null,new $APP.H(null,1,5,$APP.I,[$APP.q],null),function(a){return a});dG.F(null,new $APP.H(null,1,5,$APP.I,[RM],null),function(a){return SM(n1a($F(a)))});var p1a=$APP.mh(dG);$APP.ju.A(kN,HF);$APP.e=XM.prototype;$APP.e.rb=function(){return kN};$APP.e.ac=function(a,b,c){return $APP.Uc.A(b,this.tag)?new XM(c,this.id,this.xc,this.Td):this};$APP.e.$b=function(a,b,c){return $APP.Uc.A(c,TH)?0:$APP.Uc.A(b,this.tag)?y1a.j?y1a.j(this):y1a.call(null,this):Z_};$APP.e.ic=function(){return 0};$APP.e.nd=function(){return!1};$APP.e.valueOf=function(){return this.xc.valueOf()};
$APP.e.toString=function(){return["#emmy.tape.TapeCell",$APP.m.j(new $APP.f(null,4,[$APP.tj,this.tag,$APP.Yl,this.id,wcb,this.xc,xib,this.Td],null))].join("")};$APP.e.Tb=function(a,b){return v1a.A?v1a.A(this,b):v1a.call(null,this,b)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};
var $M=function $M(a,b){return IF(a)?s1a(b,a):XK(a)?mL.C(function(d){return $M.A?$M.A(d,b):$M.call(null,d,b)},$APP.y([a])):WH(a)?yD("Function input not yet supported."):a},bN=function bN(a,b,c){if(YM(a)&&$APP.Uc.A(c,a.tag))return JH(b,a.id);if(XK(a))return v2.A(a,$APP.Hl.A(function(g){return bN.B?bN.B(g,b,c):bN.call(null,g,b,c)},a));if(WH(a))throw $APP.Zi.A("function inputs not supported.",new $APP.f(null,1,[YSa,a],null));throw $APP.Zi.A("unknown input type!",new $APP.f(null,1,[YSa,a],null));};
vG.F(null,new $APP.H(null,1,5,$APP.I,[kN],null),function(){return 0});PF.F(null,new $APP.H(null,1,5,$APP.I,[kN],null),function(){return 1});lZ.F(null,new $APP.H(null,1,5,$APP.I,[kN],null),function(){return 1});
cG.F(null,new $APP.H(null,1,5,$APP.I,[kN],null),function(a){return $APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,Rac,null,1,null),new $APP.D(null,a.tag,null,1,null),$APP.y([new $APP.D(null,a.id,null,1,null),new $APP.D(null,cG.j(ZM(a)),null,1,null),new $APP.D(null,$APP.Hl.A(function(b){var c=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return new $APP.H(null,2,5,$APP.I,[cG.j(c),cG.j(b)],null)},a.Td),null,1,null)])))))});
dG.F(null,new $APP.H(null,1,5,$APP.I,[kN],null),function(a){return new XM(a.tag,a.id,dG.j(a.xc),$APP.Hl.A(function(b){var c=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return new $APP.H(null,2,5,$APP.I,[dG.j(c),dG.j(b)],null)},a.Td))});var P2=function P2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return P2.C(c)};P2.C=function(a){var b=$APP.He($APP.Je.A($APP.Bm,a),PH);return $APP.k(b)?b:$APP.Je.A($APP.Hj,a)};P2.G=0;P2.M=function(a){return this.C($APP.r(a))};var gN=function gN(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return gN.C(c)};
gN.C=function(a){var b=$APP.Vg.j(function(c){var d=YM(c)?c.tag:NH(c)?OH(c):null;return $APP.k(d)?new $APP.H(null,2,5,$APP.I,[d,c],null):null});a=$APP.Lf.B($APP.F,b,a);return $APP.r(a)?(b=$APP.Je.A(P2,$APP.ng(a)),new $APP.H(null,2,5,$APP.I,[b,a.j?a.j(b):a.call(null,b)],null)):null};gN.G=0;gN.M=function(a){return this.C($APP.r(a))};mN(gH);iN(RF);mN(AG);var yqc=C1a(OF);lN(OF,yqc);lN(DH,yqc);mN(tI);iN(nG);iN(qZ);iN(QF);mN(BG);
hN(jG,function(a){var b=cN(a);return(0>b?A1a(RF,function(){return-1}):0<b?A1a($APP.Kd,function(){return 1}):$APP.Uc.A(b,0)?yD("Derivative of g/abs undefined at zero"):yD(["error! derivative of g/abs at",$APP.m.j(a)].join("")))(a)});hN(rZ,D1a(rZ,0));hN(tZ,D1a(tZ,0));hN(sZ,D1a(sZ,0));hN(uZ,D1a(uZ,1));var zqc=C1a(BG);lN(XF,function(a,b){return zqc.A?zqc.A(b,a):zqc.call(null,b,a)});lN(eR,zqc);iN(lG);iN(rG);iN(qG);iN(hO);iN(iO);iN(vZ);iN(wZ);iN(yZ);iN(xZ);iN(tG);mN(tG);iN(zZ);iN(mO);iN(AZ);iN(BZ);iN(CZ);
iN(vH);iN(xH);iN(DZ);iN(EZ);iN(FZ);iN(GZ);iN(HZ);iN(IZ);iN(JZ);iN(KZ);iN(LZ);iN(MZ);iN(tR);iN(vR);iN(NZ);iN(OZ);lN(hG,nN(hG));hN(MF,function(){var a=nN(MF);return function(b){if(YM(b))return a(b);var c=dN.j(b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);b=MF.j(b);return $APP.k(b)?MF.j(c):b}}());hN(uG,function(){var a=nN(uG);return function(b){if(YM(b))b=a(b);else{var c=dN.j(b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);b=uG.j(b);b=$APP.k(b)?MF.j(c):b}return b}}());
hN(kZ,function(){var a=nN(kZ);return function(b){if(YM(b))b=a(b);else{var c=dN.j(b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);b=kZ.j(b);b=$APP.k(b)?MF.j(c):b}return b}}());hN(sG,nN(sG));hN(oG,nN(oG));$APP.ju.A(wT,mV);$APP.ju.A(aV,mV);$APP.ju.A(ZW,mV);$APP.ju.A(mV,lI);$APP.e=oN.prototype;$APP.e.Hc=$APP.xc;$APP.e.Ac=function(a,b){return $APP.wb(this.v,b)};$APP.e.toString=function(){return $APP.jh.C($APP.y([this.v]))};$APP.e.Ka=function(a,b){return $APP.Os(this.v,b)};$APP.e.fa=function(a,b,c){return $APP.Os(this.v,b,c)};$APP.e.aa=function(a,b){return $APP.bd(this.v,b)};$APP.e.eb=function(a,b,c){return $APP.bd(this.v,b,c)};
$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y(['#object[emmy.structure.Matrix "',this.toString(),'"]']))};$APP.e.ta=function(){return $APP.lb(this.v)};$APP.e.Y=function(a,b){return uN.A?uN.A(this,b):uN.call(null,this,b)};$APP.e.Sa=function(){return vG.j(this)};$APP.e.rb=function(){return $APP.Uc.A(this.r,this.c)?wT:$APP.Uc.A(this.r,1)?ZW:$APP.Uc.A(this.c,1)?aV:mV};$APP.e.bc=function(){return $APP.Xs.B($APP.Vg.j(BWa),fI,this.v)};
$APP.e.sa=function(a,b,c){return new oN(this.r,this.c,$APP.vb(this.v,b,c))};$APP.e.Va=function(a,b){return $APP.ub(this.v,b)};$APP.e.ma=function(){return $APP.Mb(this.v)};
$APP.e.call=function(a){switch(arguments.length-1){case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);case 11:return this.xa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13]);
case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],arguments[2],arguments[3],arguments[4],
arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],
arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Kb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],
arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.j=function(a){return new oN(this.r,this.c,$APP.Hl.A(function(b){return $APP.Hl.A(function(c){return c.j?c.j(a):c.call(null,a)},b)},this.v))};$APP.e.A=function(a,b){return new oN(this.r,this.c,$APP.Hl.A(function(c){return $APP.Hl.A(function(d){return d.A?d.A(a,b):d.call(null,a,b)},c)},this.v))};
$APP.e.B=function(a,b,c){return new oN(this.r,this.c,$APP.Hl.A(function(d){return $APP.Hl.A(function(g){return g.B?g.B(a,b,c):g.call(null,a,b,c)},d)},this.v))};$APP.e.K=function(a,b,c,d){return new oN(this.r,this.c,$APP.Hl.A(function(g){return $APP.Hl.A(function(l){return l.K?l.K(a,b,c,d):l.call(null,a,b,c,d)},g)},this.v))};$APP.e.S=function(a,b,c,d,g){return new oN(this.r,this.c,$APP.Hl.A(function(l){return $APP.Hl.A(function(n){return n.S?n.S(a,b,c,d,g):n.call(null,a,b,c,d,g)},l)},this.v))};
$APP.e.la=function(a,b,c,d,g,l){return new oN(this.r,this.c,$APP.Hl.A(function(n){return $APP.Hl.A(function(p){return p.la?p.la(a,b,c,d,g,l):p.call(null,a,b,c,d,g,l)},n)},this.v))};$APP.e.Ga=function(a,b,c,d,g,l,n){return new oN(this.r,this.c,$APP.Hl.A(function(p){return $APP.Hl.A(function(v){return v.Ga?v.Ga(a,b,c,d,g,l,n):v.call(null,a,b,c,d,g,l,n)},p)},this.v))};
$APP.e.va=function(a,b,c,d,g,l,n,p){return new oN(this.r,this.c,$APP.Hl.A(function(v){return $APP.Hl.A(function(t){return t.va?t.va(a,b,c,d,g,l,n,p):t.call(null,a,b,c,d,g,l,n,p)},v)},this.v))};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){return new oN(this.r,this.c,$APP.Hl.A(function(t){return $APP.Hl.A(function(A){return A.Ha?A.Ha(a,b,c,d,g,l,n,p,v):A.call(null,a,b,c,d,g,l,n,p,v)},t)},this.v))};
$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){return new oN(this.r,this.c,$APP.Hl.A(function(A){return $APP.Hl.A(function(B){return B.wa?B.wa(a,b,c,d,g,l,n,p,v,t):B.call(null,a,b,c,d,g,l,n,p,v,t)},A)},this.v))};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){return new oN(this.r,this.c,$APP.Hl.A(function(B){return $APP.Hl.A(function(G){return G.xa?G.xa(a,b,c,d,g,l,n,p,v,t,A):G.call(null,a,b,c,d,g,l,n,p,v,t,A)},B)},this.v))};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){return new oN(this.r,this.c,$APP.Hl.A(function(G){return $APP.Hl.A(function(J){return J.ya?J.ya(a,b,c,d,g,l,n,p,v,t,A,B):J.call(null,a,b,c,d,g,l,n,p,v,t,A,B)},G)},this.v))};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){return new oN(this.r,this.c,$APP.Hl.A(function(J){return $APP.Hl.A(function(O){return O.za?O.za(a,b,c,d,g,l,n,p,v,t,A,B,G):O.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G)},J)},this.v))};
$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){return new oN(this.r,this.c,$APP.Hl.A(function(O){return $APP.Hl.A(function(R){return R.Aa?R.Aa(a,b,c,d,g,l,n,p,v,t,A,B,G,J):R.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J)},O)},this.v))};$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){return new oN(this.r,this.c,$APP.Hl.A(function(R){return $APP.Hl.A(function(W){return W.Ba?W.Ba(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O):W.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O)},R)},this.v))};
$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R){return new oN(this.r,this.c,$APP.Hl.A(function(W){return $APP.Hl.A(function(Z){return Z.Ca?Z.Ca(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R):Z.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R)},W)},this.v))};$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W){return new oN(this.r,this.c,$APP.Hl.A(function(Z){return $APP.Hl.A(function(fa){return fa.Da?fa.Da(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W):fa.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W)},Z)},this.v))};
$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z){return new oN(this.r,this.c,$APP.Hl.A(function(fa){return $APP.Hl.A(function(ia){return ia.Ea?ia.Ea(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z):ia.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z)},fa)},this.v))};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa){return new oN(this.r,this.c,$APP.Hl.A(function(ia){return $APP.Hl.A(function(ja){return ja.Fa?ja.Fa(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa):ja.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa)},ia)},this.v))};
$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia){return new oN(this.r,this.c,$APP.Hl.A(function(ja){return $APP.Hl.A(function(ta){return ta.La?ta.La(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia):ta.call(null,a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia)},ja)},this.v))};
$APP.e.Kb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja){return new oN(this.r,this.c,$APP.Hl.A(function(ta){return $APP.Hl.A(function(ua){return $APP.Je.C(ua,a,b,c,d,$APP.y([g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja]))},ta)},this.v))};$APP.e.ac=function(a,b,c){function d(g){return HH(g,b,c)}return vN.A?vN.A(d,this):vN.call(null,d,this)};$APP.e.$b=function(a,b,c){function d(g){return IH(g,b,c)}return vN.A?vN.A(d,this):vN.call(null,d,this)};
$APP.e.ic=function(a,b){function c(d){return JH(d,b)}return vN.A?vN.A(c,this):vN.call(null,c,this)};var xN=function xN(a){switch(arguments.length){case 2:return xN.A(arguments[0],arguments[1]);case 3:return xN.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};xN.A=function(a,b){return xN.B(a,a,b)};
xN.B=function(a,b,c){return pN(a,b,$APP.Hl.A(function(d){return $APP.Hl.A(function(g){return c.A?c.A(d,g):c.call(null,d,g)},$APP.Jj.j(b))},$APP.Jj.j(a)))};xN.G=3;var Q2=function Q2(a){switch(arguments.length){case 2:return Q2.A(arguments[0],arguments[1]);case 3:return Q2.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Q2.A=function(a,b){return Q2.B(a,b,b)};
Q2.B=function(a,b,c){var d=[$APP.m.j(a),"_"].join("");return xN.B(b,c,function(g,l){return $APP.Zg.j([d,$APP.m.j(l),"↑",$APP.m.j(g)].join(""))})};Q2.G=3;var EN=function EN(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return EN.C(c)};EN.C=function(a){return K1a(a)};EN.G=0;EN.M=function(a){return this.C($APP.r(a))};
var R2=function R2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return R2.C(c)};R2.C=function(a){return L1a(a)};R2.G=0;R2.M=function(a){return this.C($APP.r(a))};var S2=function S2(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return S2.C(c)};S2.C=function(a){return M1a(a)};S2.G=0;S2.M=function(a){return this.C($APP.r(a))};
var BR=function BR(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return BR.C(c)};BR.C=function(a){return wN(a)};BR.G=0;BR.M=function(a){return this.C($APP.r(a))};var zN=function zN(a){switch(arguments.length){case 1:return zN.j(arguments[0]);case 4:return zN.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
zN.j=function(a){return zN.K(a,ZK,UK,!0)};zN.K=function(a,b,c,d){a=$APP.k(d)?yN(a):a;return aL(b,$APP.Hl.A(function(g){return aL(c,g)},a))};zN.G=4;var TO=function TO(a){switch(arguments.length){case 2:return TO.A(arguments[0],arguments[1]);case 3:return TO.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};TO.A=function(a,b){var c=qL(kG.A(a,b));return TO.B(c,a,b)};
TO.B=function(a,b,c){var d=WK(a),g=WK(c);return xN.B(d,g,function(l,n){return kG.A(HN.A(m2.A(d,l),a),kG.A(b,HN.A(m2.A(g,n),c)))})};TO.G=3;var sP=function sP(a){switch(arguments.length){case 2:return sP.A(arguments[0],arguments[1]);case 3:return sP.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};sP.A=function(a,b){var c=qL(kG.A(a,b));return sP.B(c,a,b)};sP.B=function(a,b,c){return IN(c,yN(TO.B(a,b,c)),a)};sP.G=3;
var T2=d2a(mG,TF,kG,NF),JN=e2a(mG,TF,kG,SF,NF),LN=function LN(a){switch(arguments.length){case 2:return LN.A(arguments[0],arguments[1]);case 3:return LN.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};LN.A=function(a,b){var c=qL(kG.A(a,b));return LN.B(c,a,b)};LN.B=function(a,b,c){return IN(qL(c),JN(TO.B(a,b,c)),qL(a))};LN.G=3;
var U2=function U2(a){switch(arguments.length){case 1:return U2.j(arguments[0]);case 2:return U2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};U2.j=function(a){return U2.A(a,a)};U2.A=function(a,b){return xN.B(a,b,$APP.Le(0))};U2.G=2;var V2=function V2(a){switch(arguments.length){case 1:return V2.j(arguments[0]);case 2:return V2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
V2.j=function(a){var b=$APP.tf(a);a=$APP.Tc(b);return xN.B(a,a,function(c,d){return $APP.Uc.A(c,d)?b.j?b.j(c):b.call(null,c):0})};V2.A=function(a,b){return xN.B(a,a,function(c,d){return $APP.Uc.A(c,d)?b:0})};V2.G=2;var W2=function W2(a){switch(arguments.length){case 1:return W2.j(arguments[0]);case 2:return W2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};W2.j=function(a){return W2.A(a,BL.J())};
W2.A=function(a,b){var c=rN(a),d=sN(a);$APP.Uc.A(c,d)||yD("not square");b=V2.A(c,b);return T2(TF.A(b,a))};W2.G=2;var NN=j2a(mG,TF,kG,SF,NF);MF.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return $APP.Ge(function(b){return $APP.Ge(MF,b)},a)});uG.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(){return!1});kZ.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return i2a(a)});vG.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return vN(vG,a)});
PF.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return h2a(a)});lZ.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return h2a(a)});cG.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return $APP.Uc.A(a.c,1)?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,mjb,null,1,null),$APP.Vg.A($APP.Jl.A(cG,$APP.u),a.v)))):$APP.T.j($APP.r($APP.N.A(new $APP.D(null,wFb,null,1,null),$APP.Vg.A(function(b){return $APP.Hl.A(cG,b)},a.v))))});
VF.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return $APP.Ge(function(b){return $APP.Ge(VF,b)},a.v)});hG.F(null,new $APP.H(null,2,5,$APP.I,[mV,mV],null),function(a,b){return uN(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[wT,HF],null),function(a,b){var c=tN(a);c?(c=rN(a),b=V2.A?V2.A(c,b):V2.call(null,c,b),a=uN(a,b)):a=c;return a});hG.F(null,new $APP.H(null,2,5,$APP.I,[HF,wT],null),function(a,b){var c=tN(b);c?(c=rN(b),a=V2.A?V2.A(c,a):V2.call(null,c,a),b=uN(a,b)):b=c;return b});
RF.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return vN(RF,a)});AG.F(null,new $APP.H(null,2,5,$APP.I,[mV,mV],null),function(a,b){return AN(TF,a,b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[wT,HF],null),function(a,b){return AN(TF,a,V2.A(rN(a),b))});AG.F(null,new $APP.H(null,2,5,$APP.I,[HF,wT],null),function(a,b){return AN(TF,V2.A(rN(b),a),b)});gH.F(null,new $APP.H(null,2,5,$APP.I,[mV,mV],null),function(a,b){return AN(mG,a,b)});
gH.F(null,new $APP.H(null,2,5,$APP.I,[wT,HF],null),function(a,b){return AN(mG,a,V2.A(rN(a),b))});gH.F(null,new $APP.H(null,2,5,$APP.I,[HF,wT],null),function(a,b){return AN(mG,V2.A(rN(b),a),b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[mV,mV],null),function(a,b){return O1a(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[HF,mV],null),function(a,b){return P1a(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[mV,HF],null),function(a,b){return Q1a(a,b)});
OF.F(null,new $APP.H(null,2,5,$APP.I,[mV,UK],null),function(a,b){return S1a(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[ZK,mV],null),function(a,b){return T1a(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[mV,HF],null),function(a,b){return Q1a(a,QF.j(b))});BG.F(null,new $APP.H(null,2,5,$APP.I,[HF,wT],null),function(a,b){return P1a(a,JN(b))});BG.F(null,new $APP.H(null,2,5,$APP.I,[aV,wT],null),function(a,b){return ON(a,b)});
BG.F(null,new $APP.H(null,2,5,$APP.I,[ZW,wT],null),function(a,b){return ON(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[UK,wT],null),function(a,b){return ON(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[ZK,wT],null),function(a,b){return ON(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[mV,wT],null),function(a,b){return O1a(a,JN(b))});qG.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return QK.j?QK.j(a):QK.call(null,a)});
hO.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return o1.j?o1.j(a):o1.call(null,a)});iO.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return n1.j?n1.j(a):n1.call(null,a)});vZ.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return p1.j?p1.j(a):p1.call(null,a)});yZ.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return q1.j?q1.j(a):q1.call(null,a)});mO.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return s1.j?s1.j(a):s1.call(null,a)});
zZ.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return r1.j?r1.j(a):r1.call(null,a)});tG.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return t1.j?t1.j(a):t1.call(null,a)});AZ.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return u1.j?u1.j(a):u1.call(null,a)});vH.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return w1.j?w1.j(a):w1.call(null,a)});xH.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return v1.j?v1.j(a):v1.call(null,a)});
DZ.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return x1.j?x1.j(a):x1.call(null,a)});IZ.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return y1.j?y1.j(a):y1.call(null,a)});JZ.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return z1.j?z1.j(a):z1.call(null,a)});dG.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return vN(dG,a)});QF.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return JN(a)});
PZ.F(null,new $APP.H(null,2,5,$APP.I,[mV,mV],null),function(a,b){return AN(PZ,a,b)});QZ.F(null,new $APP.H(null,2,5,$APP.I,[mV,mV],null),function(a,b){return AN(QZ,a,b)});zH.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return vN(zH,a)});CH.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return vN(CH,a)});sL.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return vN(sL,a)});gR.F(null,new $APP.H(null,1,5,$APP.I,[mV],null),function(a){return yN(a)});
aR.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return T2(a)});aR.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return BN(a,function(b){return T2(b)})});SZ.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return c2a(a)});SZ.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return BN(a,function(b){return c2a(b)})});QF.F(null,new $APP.H(null,1,5,$APP.I,[cS],null),function(a){return Z1a(a)});
BG.F(null,new $APP.H(null,2,5,$APP.I,[cS,cS],null),function(a,b){return f2a(b,a)});XF.F(null,new $APP.H(null,2,5,$APP.I,[wT,UK],null),function(a,b){return ON(b,a)});XF.F(null,new $APP.H(null,2,5,$APP.I,[wT,ZK],null),function(a,b){return ON(b,a)});XF.F(null,new $APP.H(null,2,5,$APP.I,[wT,aV],null),function(a,b){return ON(b,a)});XF.F(null,new $APP.H(null,2,5,$APP.I,[wT,ZW],null),function(a,b){return ON(b,a)});XF.F(null,new $APP.H(null,2,5,$APP.I,[cS,cS],null),function(a,b){return f2a(a,b)});
XF.F(null,new $APP.H(null,2,5,$APP.I,[cS,HF],null),function(a,b){return TZa(Z1a(a),b)});eR.F(null,new $APP.H(null,2,5,$APP.I,[ZW,wT],null),function(a,b){return ON(a,b)});eR.F(null,new $APP.H(null,2,5,$APP.I,[sCb,wT],null),function(a,b){return ON(a,b)});eR.F(null,new $APP.H(null,2,5,$APP.I,[cS,cS],null),function(a,b){return g2a(a,b)});eR.F(null,new $APP.H(null,2,5,$APP.I,[HF,cS],null),function(a,b){return UZa(a,Z1a(b))});NO.F(null,new $APP.H(null,1,5,$APP.I,[wT],null),function(a){return rN(a)});
NO.F(null,new $APP.H(null,1,5,$APP.I,[aV],null),function(a){return rN(a)});NO.F(null,new $APP.H(null,1,5,$APP.I,[ZW],null),function(a){return sN(a)});DH.F(null,new $APP.H(null,2,5,$APP.I,[ZW,ZW],null),function(a,b){return DH.A(FN(a),FN(b))});DH.F(null,new $APP.H(null,2,5,$APP.I,[aV,aV],null),function(a,b){return DH.A(DN(a),DN(b))});TZ.F(null,new $APP.H(null,2,5,$APP.I,[ZW,ZW],null),function(a,b){return TZ.A(GN(a),GN(b))});
TZ.F(null,new $APP.H(null,2,5,$APP.I,[aV,aV],null),function(a,b){return TZ.A(DN(a),DN(b))});VZ.F(null,new $APP.H(null,2,5,$APP.I,[ZW,ZW],null),function(a,b){return EN.C($APP.y([TK(VZ.A(GN(a),GN(b)))]))});VZ.F(null,new $APP.H(null,2,5,$APP.I,[aV,aV],null),function(a,b){return wN(VZ.A(DN(a),DN(b)))});UZ.F(null,new $APP.H(null,2,5,$APP.I,[aV,ZW],null),function(a,b){return O1a(a,b)});oR.F(null,new $APP.H(null,2,5,$APP.I,[mV,$R],null),function(a,b){return vN(function(c){return oR.A(c,b)},a)});$APP.ju.A(tV,VH);$APP.e=p2a.prototype;$APP.e.rb=function(){return tV};$APP.e.bc=function(){return this.arity};$APP.e.toString=function(){return $APP.m.j(this.qd)};$APP.e.Y=function(a,b){return r2a.A?r2a.A(this,b):r2a.call(null,this,b)};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};
$APP.e.call=function(a){switch(arguments.length-1){case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);case 11:return this.xa(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13]);
case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],arguments[2],arguments[3],arguments[4],
arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],
arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Kb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],
arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.j=function(a){a=new $APP.H(null,1,5,$APP.I,[a],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.A=function(a,b){a=new $APP.H(null,2,5,$APP.I,[a,b],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};
$APP.e.B=function(a,b,c){a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.K=function(a,b,c,d){a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.S=function(a,b,c,d,g){a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.la=function(a,b,c,d,g,l){a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};
$APP.e.Ga=function(a,b,c,d,g,l,n){a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.va=function(a,b,c,d,g,l,n,p){a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};
$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};
$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};
$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R){a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W){a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};
$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z){a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa){a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};
$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia){a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.e.Kb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja){a=$APP.N.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null),ja);return ZN.A?ZN.A(this,a):ZN.call(null,this,a)};$APP.ju.A(p2a,tV);
VN.j=function(a){return UN(a,new $APP.H(null,2,5,$APP.I,[hI,1],null),new $APP.H(null,1,5,$APP.I,[0],null),0)};VN.A=function(a,b){var c=o2a(b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return VN.B(a,b,c)};VN.B=function(a,b,c){if("number"===typeof c){var d=$APP.od(b)?$APP.Tc(b):1;return UN(a,new $APP.H(null,2,5,$APP.I,[hI,d],null),$APP.od(b)?b:new $APP.H(null,1,5,$APP.I,[b],null),c)}return XK(c)?(d=$APP.Tc(c),a=gL(a,d,VK(c)),mL.C(function(g,l){return VN.B(g,b,l)},$APP.y([a,c]))):yD(["WTF range",$APP.m.j(c)].join(""))};
VN.G=3;XN.C=function(a,b,c,d){$APP.rg.B(b,BX,!0);a=s2a(c);a=$APP.Lf.B($APP.sf,$APP.eh,a);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hm,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([d]))))};XN.G=3;XN.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};dG.F(null,new $APP.H(null,1,5,$APP.I,[tV],null),function(a){return UN(dG.j(a.qd),UH(a),a.domain,a.range)});
vG.F(null,new $APP.H(null,1,5,$APP.I,[tV],null),function(a){return function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(){return vG.j(a.range)}b.G=0;b.M=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}()});
PF.F(null,new $APP.H(null,1,5,$APP.I,[tV],null),function(a){return function(){function b(d){var g=null;if(0<arguments.length){g=0;for(var l=Array(arguments.length-0);g<l.length;)l[g]=arguments[g+0],++g;g=new $APP.Bc(l,0,null)}return c.call(this,g)}function c(){return PF.j(a.range)}b.G=0;b.M=function(d){d=$APP.r(d);return c(d)};b.C=c;return b}()});lZ.F(null,new $APP.H(null,1,5,$APP.I,[tV],null),function(a){return $APP.z($APP.Kd,new $APP.f(null,2,[ZH,a.arity,cI,oPb],null))});
VF.F(null,new $APP.H(null,1,5,$APP.I,[tV],null),function(a){return YH.C($APP.y([VF,a]))});cG.F(null,new $APP.H(null,1,5,$APP.I,[tV],null),function(a){return cG.j(a.qd)});var fO={},G2a={},gO,H2a;var JQ=function JQ(a){switch(arguments.length){case 1:return JQ.j(arguments[0]);case 2:return JQ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};JQ.j=function(a){return JQ.A(a,1)};JQ.A=function(a,b){return $APP.af(function(c){return a*c},b)};JQ.G=2;
var X2=function X2(a){switch(arguments.length){case 1:return X2.j(arguments[0]);case 2:return X2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};X2.j=function(a){return X2.A(a,1)};X2.A=function(a,b){return $APP.af(function(c){return c/a},b)};X2.G=2;
var FQ=function FQ(a){switch(arguments.length){case 1:return FQ.j(arguments[0]);case 2:return FQ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};FQ.j=function(a){return FQ.A(a,$APP.F)};
FQ.A=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,qib,2),d=$APP.C.A(b,AHb),g=$APP.C.B(b,N$a,JR);b=$APP.C.B(b,Ayb,M2a(g));if($APP.hd(a))return new $APP.f(null,3,[qQ,!1,EQ,0,pQ,null],null);var l=$APP.k(d)?function(A){return A>=d}:$APP.Le(!1);g=$APP.r(a);$APP.u(g);g=$APP.w(g);$APP.x.B(g,0,null);g=a;for(a=1;;){var n=$APP.r(g);g=$APP.u(n);var p=n=$APP.w(n);n=$APP.x.B(p,0,null);if($APP.hd(p))return new $APP.f(null,3,[qQ,!1,EQ,a,pQ,g],null);var v=a+1,t=b.A?b.A(g,n):b.call(null,g,n);if($APP.k(function(){var A=
v>=c;return A?(A=t,$APP.k(A)?A:l(v)):A}()))return new $APP.f(null,3,[qQ,t,EQ,v,pQ,n],null);a=v;g=p}};FQ.G=2;var Y2=function Y2(a){switch(arguments.length){case 1:return Y2.j(arguments[0]);case 2:return Y2.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Y2.j=function(a){return Y2.A(a,null)};
Y2.A=function(a,b){b=null==b?OR:kG.A(b,OR);b=M2a(b);var c=$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[2,2],null)),d=GF(c);$APP.k(d?b(c,-1):d)?(b=Math.PI,c=TF.j(tG.A(TF.j($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[0,1],null))),$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[0,0],null)))),a=0):$APP.k(d?b(c,1):d)?(b=0,c=tG.A(TF.j($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[0,1],null))),$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[0,0],null))),a=0):(b=mO.j(c),d=iO.j(b),c=tG.A(SF.A($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[0,2],
null)),d),TF.j(SF.A($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[1,2],null)),d))),a=tG.A(SF.A($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[2,0],null)),d),SF.A($APP.am.A(a,new $APP.H(null,2,5,$APP.I,[2,1],null)),d)));return wL.C($APP.y([b,c,a]))};Y2.G=2;var LO={},Z2,Aqc,$2,Bqc,a3,Cqc,b3,Dqc,MO,E3a,OO,G3a,PO,I3a,QO,K3a,c3,Eqc,d3,Fqc,e3=function e3(a){switch(arguments.length){case 1:return e3.j(arguments[0]);case 2:return e3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};e3.j=function(a){return e3.A(a,PN)};e3.A=function(a,b){return new $APP.f(null,4,[b3a,b,yNb,a,sO,$APP.F,$APP.Ui,Y2a],null)};e3.G=2;
var f3=function f3(a){switch(arguments.length){case 2:return f3.A(arguments[0],arguments[1]);case 3:return f3.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};f3.A=function(a,b){return f3.B(a,b,b)};f3.B=function(a,b,c){return new $APP.f(null,5,[a3a,a,$APP.Q,JG(yNb.j(a),b),HO,b,D3a,c,$APP.Ui,qO],null)};f3.G=3;
var g3=function g3(a){switch(arguments.length){case 1:return g3.j(arguments[0]);case 2:return g3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};g3.j=function(a){var b=KO(a);return g3.A(a,b)};
g3.A=function(a,b){var c=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof Z2)Z2=function(d,g,l,n){this.Pa=d;this.Ub=g;this.id=l;this.uk=n;this.O=393216;this.U=0},Z2.prototype.da=function(d,g){return new Z2(this.Pa,this.Ub,this.id,g)},Z2.prototype.ba=function(){return this.uk},Z2.prototype.cd=$APP.xc,Z2.prototype.Cc=function(d,g){return $APP.Uc.A(WK(g),HO.j(this.Pa))},Z2.prototype.Mc=function(d,g){return zO(g,this.Pa)},
Z2.prototype.Nc=function(d,g){return xO(g,this.Pa,this,g)},Z2.prototype.Oc=function(d,g){return AO(g,this,function(){return yO(g)})},Z2.prototype.dd=function(){return this.id},Z2.cb=!0,Z2.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57394",Z2.gb=function(d){return $APP.Vb(d,"emmy.calculus.manifold/t_emmy$calculus$manifold57394")},Aqc=function(d,g,l,n){return new Z2(d,g,l,n)};return new Z2(a,b,c,$APP.F)}(),new $APP.f(null,2,[DO,b,qO,a],null))};g3.G=2;
var h3=function h3(a){switch(arguments.length){case 1:return h3.j(arguments[0]);case 2:return h3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};h3.j=function(a){var b=KO(a);return h3.A(a,b)};
h3.A=function(a,b){var c=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof $2)$2=function(d,g,l,n){this.Pa=d;this.Ub=g;this.id=l;this.vk=n;this.O=393216;this.U=0},$2.prototype.da=function(d,g){return new $2(this.Pa,this.Ub,this.id,g)},$2.prototype.ba=function(){return this.vk},$2.prototype.cd=$APP.xc,$2.prototype.Cc=function(d,g){return(d=YK(g))?(d=$APP.Uc.A(WK(g),HO.j(this.Pa)))?(d=1<WK(g))?(g=$APP.x.A(g,0),!GF(g)||0<=
g):d:d:d},$2.prototype.Mc=function(d,g){return zO(g,this.Pa)},$2.prototype.Nc=function(d,g){d=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);return xO($APP.rg.B($APP.rg.B(g,0,kG.A(d,hO.j(l))),1,kG.A(d,iO.j(l))),this.Pa,this,g)},$2.prototype.Oc=function(d,g){var l=this;return AO(g,this,function(){var n=yO(g);YK(n)&&$APP.Uc.A(WK(n),D3a.j(l.Pa))||yD("PolarCylindrical bad point");var p=$APP.x.B(n,0,null),v=$APP.x.B(n,1,null),t=mG.A(nG.j(p),nG.j(v));$APP.k(MF.j(t))&&zD("PolarCylindrical singular");return $APP.rg.B($APP.rg.B(n,
0,lG.j(t)),1,tG.A(v,p))})},$2.prototype.dd=function(){return this.id},$2.cb=!0,$2.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57399",$2.gb=function(d){return $APP.Vb(d,"emmy.calculus.manifold/t_emmy$calculus$manifold57399")},Bqc=function(d,g,l,n){return new $2(d,g,l,n)};return new $2(a,b,c,$APP.F)}(),new $APP.f(null,2,[DO,b,qO,a],null))};h3.G=2;
var i3=function i3(a){switch(arguments.length){case 1:return i3.j(arguments[0]);case 2:return i3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};i3.j=function(a){var b=KO(a);return i3.A(a,b)};
i3.A=function(a,b){var c=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof a3)a3=function(d,g,l,n){this.Pa=d;this.Ub=g;this.id=l;this.wk=n;this.O=393216;this.U=0},a3.prototype.da=function(d,g){return new a3(this.Pa,this.Ub,this.id,g)},a3.prototype.ba=function(){return this.wk},a3.prototype.cd=$APP.xc,a3.prototype.Cc=function(d,g){return(d=YK(g))?(d=$APP.Uc.A(NO.j(g),HO.j(this.Pa)))?$APP.k($APP.Ys)?!GF(g)||0<=$APP.x.A(g,
0):$APP.Ys:d:d},a3.prototype.Mc=function(d,g){return zO(g,this.Pa)},a3.prototype.Nc=function(d,g){d=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null),n=$APP.x.B(g,2,null);return xO($APP.rg.B($APP.rg.B($APP.rg.B(g,0,kG.C(d,iO.j(l),$APP.y([hO.j(n)]))),1,kG.C(d,iO.j(l),$APP.y([iO.j(n)]))),2,kG.A(d,hO.j(l))),this.Pa,this,g)},a3.prototype.Oc=function(d,g){var l=this;return AO(g,this,function(){var n=yO(g);YK(n)&&$APP.Uc.A(NO.j(n),D3a.j(l.Pa))||yD("SphericalCylindrical bad point");var p=$APP.x.B(n,0,null),v=
$APP.x.B(n,1,null),t=$APP.x.B(n,2,null),A=lG.j(mG.C(nG.j(p),nG.j(v),$APP.y([nG.j(t)])));$APP.k(MF.j(A))&&zD("SphericalCylindrical singular");return $APP.rg.B($APP.rg.B($APP.rg.B(n,0,A),1,mO.j(SF.A?SF.A(t,A):SF.call(null,t,A))),2,tG.A(v,p))})},a3.prototype.dd=function(){return this.id},a3.cb=!0,a3.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57410",a3.gb=function(d){return $APP.Vb(d,"emmy.calculus.manifold/t_emmy$calculus$manifold57410")},Cqc=function(d,g,l,n){return new a3(d,g,l,n)};return new a3(a,
b,c,$APP.F)}(),new $APP.f(null,2,[DO,b,qO,a],null))};i3.G=2;var j3=function j3(a){switch(arguments.length){case 1:return j3.j(arguments[0]);case 2:return j3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};j3.j=function(a){var b=KO(a);return j3.A(a,b)};
j3.A=function(a,b){var c=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof b3)b3=function(d,g,l,n){this.Pa=d;this.Ub=g;this.id=l;this.xk=n;this.O=393216;this.U=0},b3.prototype.da=function(d,g){return new b3(this.Pa,this.Ub,this.id,g)},b3.prototype.ba=function(){return this.xk},b3.prototype.cd=$APP.xc,b3.prototype.Cc=function(d,g){return YK(g)&&$APP.Uc.A(NO.j(g),4)},b3.prototype.Mc=function(d,g){return zO(g,this.Pa)},b3.prototype.Nc=
function(d,g){d=$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null),n=$APP.x.B(g,2,null),p=$APP.x.B(g,3,null);return xO(wL.C($APP.y([d,kG.C(l,iO.j(n),$APP.y([hO.j(p)])),kG.C(l,iO.j(n),$APP.y([iO.j(p)])),kG.A(l,hO.j(n))])),this.Pa,this,g)},b3.prototype.Oc=function(d,g){var l=this;return AO(g,l,function(){var n=yO(g);if($APP.eb(l.Cc(null,n)))throw $APP.Zi.A("bad -\x3eSpacetimeSpherical point: ",new $APP.f(null,2,[$APP.RO,g,IO,l],null));var p=$APP.x.B(n,0,null),v=$APP.x.B(n,1,null),t=$APP.x.B(n,2,null);n=$APP.x.B(n,
3,null);var A=lG.j(mG.C(nG.j(v),nG.j(t),$APP.y([nG.j(n)])));var B=(B=GF(A))?MF.j(A):B;if($APP.k(B))throw $APP.Zi.A("-\x3eSpacetimeSpherical singular: ",new $APP.f(null,2,[$APP.RO,g,IO,l],null));return wL.C($APP.y([p,A,mO.j(SF.A(n,A)),tG.A(t,v)]))})},b3.prototype.dd=function(){return this.id},b3.cb=!0,b3.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57421",b3.gb=function(d){return $APP.Vb(d,"emmy.calculus.manifold/t_emmy$calculus$manifold57421")},Dqc=function(d,g,l,n){return new b3(d,g,l,n)};
return new b3(a,b,c,$APP.F)}(),new $APP.f(null,2,[DO,b,qO,a],null))};j3.G=2;var k3=function k3(a){switch(arguments.length){case 1:return k3.j(arguments[0]);case 2:return k3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};k3.j=function(a){var b=KO(a);return k3.A(a,b)};
k3.A=function(a,b){var c=HO.j(a),d=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof c3)c3=function(g,l,n,p,v){this.Pa=g;this.Ub=l;this.n=n;this.id=p;this.Ck=v;this.O=393216;this.U=0},c3.prototype.da=function(g,l){return new c3(this.Pa,this.Ub,this.n,this.id,l)},c3.prototype.ba=function(){return this.Ck},c3.prototype.cd=$APP.xc,c3.prototype.Cc=function(g,l){return(g=YK(l))?(g=$APP.Uc.A(NO.j(l),this.n))?(l=$APP.x.A(l,0),
!GF(l)||$APP.eb(MF.j(l))):g:g},c3.prototype.Mc=function(g,l){return zO(l,this.Pa)},c3.prototype.Nc=function(g,l){var n=$APP.x.B(l,0,null),p=$APP.x.B(l,1,null);g=$APP.x.B(l,2,null);n=jO(n);p=lO(p);g=lO(g);g=kG.C(p,n,$APP.y([g]));return xO(g,this.Pa,this,l)},c3.prototype.Oc=function(g,l){return AO(l,this,function(){var n=yO(l),p=mO.j($APP.am.A(n,new $APP.H(null,2,5,$APP.I,[2,2],null))),v=tG.A($APP.am.A(n,new $APP.H(null,2,5,$APP.I,[0,2],null)),RF.j($APP.am.A(n,new $APP.H(null,2,5,$APP.I,[1,2],null))));
n=tG.A($APP.am.A(n,new $APP.H(null,2,5,$APP.I,[2,0],null)),$APP.am.A(n,new $APP.H(null,2,5,$APP.I,[2,1],null)));return wL.C($APP.y([p,v,n]))})},c3.prototype.dd=function(){return this.id},c3.cb=!0,c3.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57463",c3.gb=function(g){return $APP.Vb(g,"emmy.calculus.manifold/t_emmy$calculus$manifold57463")},Eqc=function(g,l,n,p,v){return new c3(g,l,n,p,v)};return new c3(a,b,c,d,$APP.F)}(),new $APP.f(null,2,[DO,b,qO,a],null))};k3.G=2;
var l3=function l3(a){switch(arguments.length){case 1:return l3.j(arguments[0]);case 2:return l3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};l3.j=function(a){var b=KO(a);return l3.A(a,b)};
l3.A=function(a,b){var c=HO.j(a),d=xD();return $APP.z(function(){if("undefined"===typeof eM||"undefined"===typeof fO||"undefined"===typeof LO||"undefined"===typeof d3)d3=function(g,l,n,p,v){this.Pa=g;this.Ub=l;this.n=n;this.id=p;this.Dk=v;this.O=393216;this.U=0},d3.prototype.da=function(g,l){return new d3(this.Pa,this.Ub,this.n,this.id,l)},d3.prototype.ba=function(){return this.Dk},d3.prototype.cd=$APP.xc,d3.prototype.Cc=function(g,l){return YK(l)&&$APP.Uc.A(NO.j(l),this.n)&&(!GF($APP.x.A(l,0))||
Math.PI/-2<$APP.x.A(l,0)&&$APP.x.A(l,0)<Math.PI/2)},d3.prototype.Mc=function(g,l){return zO(l,this.Pa)},d3.prototype.Nc=function(g,l){var n=$APP.x.B(l,0,null),p=$APP.x.B(l,1,null);g=$APP.x.B(l,2,null);n=jO(n);p=lO(p);g=kO(g);g=kG.C(p,n,$APP.y([g]));return xO(g,this.Pa,this,l)},d3.prototype.Oc=function(g,l){return AO(l,this,function(){var n=yO(l),p=zZ.j($APP.am.A(n,new $APP.H(null,2,5,$APP.I,[2,1],null))),v=tG.A(RF.j($APP.am.A(n,new $APP.H(null,2,5,$APP.I,[0,1],null))),$APP.am.A(n,new $APP.H(null,
2,5,$APP.I,[1,1],null)));n=tG.A(RF.j($APP.am.A(n,new $APP.H(null,2,5,$APP.I,[2,0],null))),$APP.am.A(n,new $APP.H(null,2,5,$APP.I,[2,2],null)));return wL.C($APP.y([p,v,n]))})},d3.prototype.dd=function(){return this.id},d3.cb=!0,d3.Ya="emmy.calculus.manifold/t_emmy$calculus$manifold57471",d3.gb=function(g){return $APP.Vb(g,"emmy.calculus.manifold/t_emmy$calculus$manifold57471")},Fqc=function(g,l,n,p,v){return new d3(g,l,n,p,v)};return new d3(a,b,c,d,$APP.F)}(),new $APP.f(null,2,[DO,b,qO,a],null))};
l3.G=2;
var m3=uO(uO(uO(tO(e3.j("R(%d)"),TR),gV,TR,g3),eeb,TR,h3),XXb,TR,i3),Gqc=f3.A(m3,1),Hqc=vO(Gqc,gV,TR),Iqc=f3.A(m3,2),Jqc=vO(Iqc,gV,TR),Kqc=vO(Iqc,eeb,TR),n3=f3.A(m3,3),Lqc=vO(n3,gV,TR),Mqc=vO(n3,eeb,TR),Nqc=vO(n3,XXb,TR),Oqc=f3.A(m3,4),Pqc=vO(Oqc,gV,TR),Qqc=vO(Oqc,eeb,TR),Rqc=f3.A(uO(m3,w7b,TR,j3),4),Sqc=vO(Rqc,gV,TR),Tqc=vO(Rqc,w7b,TR),Uqc=uO(uO(uO(uO(uO(uO(uO(tO(tO(tO(e3.j("S2"),rY),YW),WR),GV,rY,F3a(SN.C($APP.y([wL.C($APP.y([1,0,0])),wL.C($APP.y([0,1,0])),wL.C($APP.y([0,0,1]))])))),GV,WR,F3a(SN.C($APP.y([wL.C($APP.y([1,
0,0])),wL.C($APP.y([0,0,1])),wL.C($APP.y([0,-1,0]))])))),GV,YW,F3a(SN.C($APP.y([wL.C($APP.y([1,0,0])),wL.C($APP.y([0,1,0])),wL.C($APP.y([0,0,-1]))])))),vS,rY,J3a(MN)),vS,YW,J3a(function(a){return xN.B(a,a,function(b,c){return $APP.Uc.A(b,c)?$APP.Uc.A(c,a)?-1:1:0})})),sY,rY,L3a(MN)),sY,YW,L3a(function(a){return xN.B(a,a,function(b,c){return $APP.Uc.A(b,c)?$APP.Uc.A(c,a)?-1:1:0})})),o3=f3.B(Uqc,2,3),Vqc=vO(o3,GV,rY),Wqc=vO(o3,GV,WR),Xqc=vO(o3,vS,rY),Yqc=vO(o3,sY,rY),p3=uO(uO(uO(uO(uO(uO(uO(tO(tO(tO(e3.j("S(%d)"),
rY),YW),WR),GV,rY,H3a(MN)),GV,YW,H3a(function(a){return xN.B(a,a,function(b,c){return $APP.Uc.A(b,c)?$APP.Uc.A(c,a)?-1:1:0})})),GV,WR,H3a(function(a){return eL(a,ZK,function(b){return eL(a,UK,function(c){return $APP.Uc.A(c,a-2)&&$APP.Uc.A(b,a-1)?-1:$APP.Uc.A(c,a-1)&&$APP.Uc.A(b,a-2)?1:$APP.Uc.A(c,b)&&c<a-2?1:0})})})),sY,rY,L3a(MN)),sY,YW,L3a(function(a){return xN.B(a,a,function(b,c){return $APP.Uc.A(b,c)?$APP.Uc.A(c,a)?-1:1:0})})),vS,rY,J3a(MN)),vS,YW,J3a(function(a){return xN.B(a,a,function(b,c){return $APP.Uc.A(b,
c)?$APP.Uc.A(c,a)?-1:1:0})})),q3=f3.A(p3,1),Zqc=vO(q3,GV,rY),$qc=vO(q3,GV,WR),arc=vO(q3,vS,rY),brc=vO(q3,sY,rY),r3=f3.A(p3,2),crc=vO(r3,GV,rY),drc=vO(r3,GV,WR),erc=vO(r3,vS,rY),frc=vO(r3,sY,rY),s3=f3.A(p3,3),grc=vO(s3,GV,rY),hrc=vO(s3,GV,WR),irc=vO(s3,sY,rY),jrc=vO(s3,vS,YW),krc=uO(uO(tO(tO(e3.j("SO3"),Orb),tAb),i_b,Orb,k3),dlb,tAb,l3),lrc=f3.A(krc,3),mrc=vO(lrc,i_b,Orb),nrc=vO(lrc,dlb,tAb);var SO=function SO(a,b){return XH.B(function(){function d(n){var p=a.j?a.j(b):a.call(null,b);return p.j?p.j(n):p.call(null,n)}var g=null,l=function(){function n(v,t){var A=null;if(1<arguments.length){A=0;for(var B=Array(arguments.length-1);A<B.length;)B[A]=arguments[A+1],++A;A=new $APP.Bc(B,0,null)}return p.call(this,v,A)}function p(v,t){v=N1a($APP.Yd(v,t));t=function(){function A(B){return $APP.Je.A(b,B)}return SO.A?SO.A(a,A):SO.call(null,a,A)}();return t.j?t.j(v):t.call(null,v)}n.G=1;n.M=function(v){var t=
$APP.u(v);v=$APP.Fc(v);return p(t,v)};n.C=p;return n}();g=function(n,p){switch(arguments.length){case 0:return 0;case 1:return d.call(this,n);default:var v=null;if(1<arguments.length){v=0;for(var t=Array(arguments.length-1);v<t.length;)t[v]=arguments[v+1],++v;v=new $APP.Bc(t,0,null)}return l.C(n,v)}throw Error("Invalid arity: "+arguments.length);};g.G=1;g.M=l.M;g.J=function(){return 0};g.j=d;g.C=l.C;return g}(),UH(b),new $APP.f(null,1,[cI,e2b],null))},t3=function t3(a){switch(arguments.length){case 1:return t3.j(arguments[0]);
case 2:return t3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};t3.j=function(a){return t3.A(a,$APP.sf)};t3.A=function(a,b){return SO(function(c){return z1a(c,b)},a)};t3.G=2;
for(var u3=aN,v3=$APP.r(new $APP.H(null,2,5,$APP.I,[VH,cS],null)),w3=null,x3=0,y3=0;;)if(y3<x3){var orc=w3.aa(null,y3);oR.F(null,new $APP.H(null,2,5,$APP.I,[orc,$R],null),function(){return function(a,b){return $APP.Uc.A(u3,TH)?P3a(a,b):t3.A(a,b)}}(v3,w3,x3,y3,orc));oR.F(null,new $APP.H(null,2,5,$APP.I,[orc,null],null),function(){return function(a){return $APP.Uc.A(u3,TH)?P3a(a,$APP.sf):t3.A(a,$APP.sf)}}(v3,w3,x3,y3,orc));y3+=1}else{var prc=$APP.r(v3);if(prc){var z3=prc;if($APP.pd(z3)){var qrc=$APP.lc(z3),
rrc=$APP.mc(z3),src=qrc,trc=$APP.Tc(qrc);v3=rrc;w3=src;x3=trc}else{var urc=$APP.u(z3);oR.F(null,new $APP.H(null,2,5,$APP.I,[urc,$R],null),function(){return function(a,b){return $APP.Uc.A(u3,TH)?P3a(a,b):t3.A(a,b)}}(v3,w3,x3,y3,urc,z3,prc));oR.F(null,new $APP.H(null,2,5,$APP.I,[urc,null],null),function(){return function(a){return $APP.Uc.A(u3,TH)?P3a(a,$APP.sf):t3.A(a,$APP.sf)}}(v3,w3,x3,y3,urc,z3,prc));v3=$APP.w(z3);w3=null;x3=0}y3=0}else break}
var vrc=LK.A(function(a){var b=u3;u3=TH;try{return oR.A(a,$APP.sf)}finally{u3=b}},eH),UO=LK.A(function(a){var b=u3;u3=aN;try{return oR.A(a,$APP.sf)}finally{u3=b}},eH),A3=function A3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return A3.C(c)};A3.C=function(a){return LK.A(function(b){var c=u3;u3=TH;try{return oR.A(b,a)}finally{u3=c}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Vw,null,1,null),a))))};A3.G=0;
A3.M=function(a){return this.C($APP.r(a))};var SQ=function SQ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return SQ.C(c)};SQ.C=function(a){return LK.A(function(b){var c=u3;u3=aN;try{return oR.A(b,a)}finally{u3=c}},$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.Vw,null,1,null),a))))};SQ.G=0;SQ.M=function(a){return this.C($APP.r(a))};
var B3=function B3(a){switch(arguments.length){case 1:return B3.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return B3.C(arguments[0],c)}};B3.j=function(a){return B3.C(a,$APP.y([0]))};B3.C=function(a,b){var c=$APP.Je,d=c.A,g=qG.j(UO);a=g.j?g.j(a):g.call(null,a);return DXa(d.call(c,a,b))};B3.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};B3.G=1;
var C3=function C3(a){switch(arguments.length){case 1:return C3.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return C3.C(arguments[0],c)}};C3.j=function(a){return C3.C(a,$APP.y([0]))};
C3.C=function(a,b){var c=$APP.Vg.A(nL,b),d=$APP.Bg($APP.ef(c),$APP.ef(b));a=$APP.Je.B(B3,a,c);return XI(function(g){return dG.j(mL.C(function p(n){return NH(n)?SH.B(p(RH.j(n)),p(YN.j(n)),OH(n)):YM(n)?r1a(n.tag,n.id,p(ZM(n)),$APP.Hl.A(function(v){var t=$APP.x.B(v,0,null);v=$APP.x.B(v,1,null);return new $APP.H(null,2,5,$APP.I,[p(t),p(v)],null)},n.Td)):WZ.A(dG.j(n),d)},$APP.y([g])))},a)};C3.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};C3.G=1;$APP.ju.A(VO,GW);var ZO=function ZO(a){switch(arguments.length){case 2:return ZO.A(arguments[0],arguments[1]);case 3:return ZO.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};ZO.A=function(a,b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.meb,null,1,null),new $APP.D(null,a,null,1,null))));return ZO.B(a,b,c)};ZO.B=function(a,b,c){return YO($H($APP.Jl.A($H,U3a(a,b))),c)};ZO.G=3;
var D3=function D3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return D3.C(arguments[0],c)};D3.C=function(a,b){return function(c){var d=YH,g=d.C;c=YH.C($APP.y([c,GO(a)]));var l=$APP.Je.A(SQ,b);c=l.j?l.j(c):l.call(null,c);return g.call(d,$APP.y([c,FO(a)]))}};D3.G=1;D3.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var $O=function $O(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return $O.C(arguments[0],arguments[1],c)};$O.C=function(a,b,c){a=$APP.Je.B(D3,a,c);return YO($H($APP.Jl.A($H,a)),b)};$O.G=2;$O.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var k4a={},bP,l4a,E3=function E3(a,b){return 0===b?$APP.M($APP.Ec):$APP.hd(a)?$APP.Ec:$APP.N.A($APP.Vg.A(function(d){return $APP.Vd.A(d,$APP.u(a))},function(){var d=$APP.Fc(a),g=b-1;return E3.A?E3.A(d,g):E3.call(null,d,g)}()),function(){var d=$APP.Fc(a);return E3.A?E3.A(d,b):E3.call(null,d,b)}())},AP=function AP(a){return $APP.hd(a)?$APP.M($APP.Ec):function g(d){return new $APP.de(null,function(){for(var l=d;;){var n=$APP.r(l);if(n){var p=n,v=$APP.u(p);if(n=$APP.r(function(t,A,B,G){return function R(O){return new $APP.de(null,
function(W,Z){return function(){for(;;){var fa=$APP.r(O);if(fa){if($APP.pd(fa)){var ia=$APP.lc(fa),ja=$APP.Tc(ia),ta=$APP.fe(ja);a:for(var ua=0;;)if(ua<ja){var ca=$APP.bd(ia,ua);$APP.je(ta,$APP.Yd(ca,Z));ua+=1}else{ia=!0;break a}return ia?$APP.ie($APP.ke(ta),R($APP.mc(fa))):$APP.ie($APP.ke(ta),null)}ta=$APP.u(fa);return $APP.Yd($APP.Yd(ta,Z),R($APP.Fc(fa)))}return null}}}(t,A,B,G),null,null)}}(l,v,p,n)($APP.u(a))))return $APP.N.A(n,g($APP.Fc(l)));l=$APP.Fc(l)}else return null}},null,null)}(function(){var d=
$APP.Fc(a);return AP.j?AP.j(d):AP.call(null,d)}())},F3=function F3(a){switch(arguments.length){case 1:return F3.j(arguments[0]);case 2:return F3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};F3.j=function(a){a=f4a(a);return $APP.Ie(a)?1:-1};F3.A=function(a,b){var c;if(c=$APP.Uc.A($APP.Tc(a),$APP.Tc(b)))c=$APP.Uc.A($APP.Vs.A($APP.yc,a),$APP.Vs.A($APP.yc,b));return c?$APP.Ie(e4a(a,b))?1:-1:0};F3.G=2;$APP.ju.A(gP,dP);$APP.ju.A(dP,GW);
var t4a=new $APP.f(null,5,[$APP.R3a,function(a){return eP(a)&&$APP.Uc.A(GK(a),p4a)},vWa,function(a){return LK.B(p4a,AKb,JK(a))},xWa,function(){return wD("form fields don't have an identity.")},Feb,function(){return!1},oPb,function(){return wD("form fields don't have a multiplicative identity.")}],null),iP=function iP(a){switch(arguments.length){case 2:return iP.A(arguments[0],arguments[1]);case 3:return iP.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));
}};iP.A=function(a,b){var c=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,Wub,null,1,null),new $APP.D(null,cG.j(a),null,1,null))));return iP.B(a,b,c)};iP.B=function(a,b,c){return hP(u4a(a,b),c)};iP.G=3;var G3=function G3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return G3.C(arguments[0],c)};
G3.C=function(a,b){return function(c){return mL.C(function(d){var g=YH.C($APP.y([$APP.Je.A(tP,b),FO(a)]));return d.j?d.j(g):d.call(null,g)},$APP.y([c]))}};G3.G=1;G3.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var jP=function jP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return jP.C(arguments[0],arguments[1],c)};jP.C=function(a,b,c){a=$APP.Je.B(G3,a,c);return hP($H($APP.Jl.A($H,a)),b)};
jP.G=2;jP.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var H3=function H3(a){switch(arguments.length){case 0:return H3.J();case 1:return H3.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return H3.C(arguments[0],c)}};H3.J=function(){return $APP.Le(1)};H3.j=function(a){return a};H3.C=function(a,b){return $APP.Id.A(function(c,d){return C4a(d,c)},$APP.Wd($APP.Yd(a,b)))};
H3.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};H3.G=1;OF.F(null,new $APP.H(null,2,5,$APP.I,[dP,dP],null),function(a,b){return C4a(a,b)});var I3=function I3(a){switch(arguments.length){case 1:return I3.j(arguments[0]);case 2:return I3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};I3.j=function(a){return a};I3.A=function(a,b){var c=cP(a),d=cP(b);return kG.A(HI(c+d)/(HI(c)*HI(d)),E4a(G4a(a,b)))};I3.G=2;
var J3=function J3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return J3.C(c)};J3.C=function(a){return $APP.Id.B(I3,$APP.Le(1),a)};J3.G=0;J3.M=function(a){return this.C($APP.r(a))};
var WP=LK.A(function(a){function b(d,g){return $APP.N.A($APP.We.A(d,g),$APP.Se.A(d+1,g))}var c=cP(a);return $APP.Uc.A(c,0)?mP.j?mP.j(a):mP.call(null,a):fP(function(){function d(l){var n=null;if(0<arguments.length){n=0;for(var p=Array(arguments.length-0);n<p.length;)p[n]=arguments[n+0],++n;n=new $APP.Bc(p,0,null)}return g.call(this,n)}function g(l){return function(n){var p=HO.j(o3a(n));if(c<p){p=function(t){var A=b(t,l);return mG.A(kG.A($APP.Ie(t)?1:-1,function(){var B=$APP.Je.A(a,A);var G=$APP.x.A(l,
t);B=G.j?G.j(B):G.call(null,B);return B.j?B.j(n):B.call(null,n)}()),function(){function B(O){var R=kG.A,W=$APP.Ie(t+O)?1:-1;O=$APP.Je.A(a,$APP.Yd(PK($APP.x.A(l,t),$APP.x.A(l,O)),b(O-1,A)));O=O.j?O.j(n):O.call(null,n);return R.call(kG,W,O)}var G=t+1,J=c+1;return jL.B?jL.B(B,G,J):jL.call(null,B,G,J)}())};var v=c+1;return jL.B?jL.B(p,0,v):jL.call(null,p,0,v)}return 0}}d.G=0;d.M=function(l){l=$APP.r(l);return g(l)};d.C=g;return d}(),c+1,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.lP,null,1,null),new $APP.D(null,
cG.j(a),null,1,null)))))},$APP.lP);$APP.ju.A(H4a,M4a);var K3=function K3(a){switch(arguments.length){case 1:return K3.j(arguments[0]);case 2:return K3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};K3.j=function(a){return K3.A(a,null)};K3.A=function(a,b){return function(c){return WO(c)?null==b?yD("Pullback of a vector requires inverse map"):f5a(b,a)(c):n5a(a)(c)}};K3.G=2;var L3=function L3(a){var c=cG.j(a),d=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,cR,null,1,null),new $APP.D(null,c,null,1,null))));return LK.A(function(g){if(WH(g))return a.j?a.j(g):a.call(null,g);if(WO(g))return PK(a,g);if(eP(g)){var l=cP(g),n=function(){function v(A){var B=null;if(0<arguments.length){B=0;for(var G=Array(arguments.length-0);B<G.length;)G[B]=arguments[B+0],++B;B=new $APP.Bc(G,0,null)}return t.call(this,B)}function t(A){var B=$APP.Lf.A($APP.sf,A);return TF.A(function(){var G=$APP.Je.A(g,
B),J=dR.j(a);return J.j?J.j(G):J.call(null,G)}(),function(){function G(J){J=$APP.Gj.B(B,J,dR.j(a));return $APP.Je.A(g,J)}return jL.B?jL.B(G,0,l):jL.call(null,G,0,l)}())}v.G=0;v.M=function(A){A=$APP.r(A);return t(A)};v.C=t;return v}(),p=$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,cR,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null),new $APP.D(null,cG.j(g),null,1,null))));return fP(n,l,p)}return XK(g)?mL.C(L3.j?L3.j(a):L3.call(null,a),$APP.y([g])):wD("Bad argument: Lie Derivative")},
d)};dR.F(null,new $APP.H(null,1,5,$APP.I,[VO],null),function(a){return L3(a)});var MP=function MP(a){switch(arguments.length){case 1:return MP.j(arguments[0]);case 2:return MP.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};MP.j=function(a){return L5a(a)};MP.A=function(a,b){a=G5a(a,b);return L5a(GP(YH.C($APP.y([HP(a),CP.j?CP.j(b):CP.call(null,b)])),IP(a)))};MP.G=2;var M3=function M3(a){var c;if(c=$APP.kd(a)){c=$APP.u(a);var d=new $APP.ug(null,new $APP.f(null,2,[yP,"null",zP,"null"],null),null);c=d.j?d.j(c):d.call(null,c)}return $APP.k(c)?$APP.bf.C(M3,$APP.y([$APP.Fc(a)])):$APP.od(a)?$APP.bf.C(M3,$APP.y([a])):a instanceof $APP.q?new $APP.H(null,1,5,$APP.I,[a],null):yD(["Invalid coordinate prototype: ",$APP.m.j(a)].join(""))},N3=function N3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=3<c.length?new $APP.Bc(c.slice(3),
0,null):null;return N3.C(arguments[0],arguments[1],arguments[2],c)};
N3.C=function(a,b,c,d){$APP.rg.B(b,BX,!0);$APP.Ie($APP.Tc(c))||yD("let-coordinates requires an even number of bindings");b=$APP.Ll.A(2,c);a=$APP.Vg.A($APP.u,b);b=$APP.Vg.A($APP.Xc,b);c=$APP.Vg.A($APP.Jl.A($APP.Zg,$APP.Ag),b);var g=$APP.bf.C(M3,$APP.y([a])),l=$APP.Vg.A(Z3a,g),n=$APP.Vg.A(x4a,g);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hm,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.C(c,new $APP.D(null,$APP.dk,null,1,null),
$APP.y([new $APP.D(null,UPb,null,1,null)]))))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.nRb,null,1,null),new $APP.D(null,jWb,null,1,null),$APP.y([new $APP.D(null,$APP.Lf.A($APP.sf,b),null,1,null),new $APP.D(null,$APP.Hl.A(Q5a,a),null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.Lf.A($APP.sf,g),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,t$b,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.EX,null,1,null),
new $APP.D(null,jS,null,1,null),$APP.y([new $APP.D(null,UPb,null,1,null)])))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Lf.A($APP.sf,l),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,t$b,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.EX,null,1,null),new $APP.D(null,NX,null,1,null),$APP.y([new $APP.D(null,UPb,null,1,null)])))),null,1,null)))),null,1,null),new $APP.D(null,$APP.Lf.A($APP.sf,n),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
t$b,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.EX,null,1,null),new $APP.D(null,xT,null,1,null),$APP.y([new $APP.D(null,UPb,null,1,null)])))),null,1,null)))),null,1,null)]))))),null,1,null),$APP.y([d]))))};N3.G=3;N3.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};
var O3=function O3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=4<c.length?new $APP.Bc(c.slice(4),0,null):null;return O3.C(arguments[0],arguments[1],arguments[2],arguments[3],c)};O3.C=function(a,b,c,d,g){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,zlb,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.A(new $APP.D(null,c,null,1,null),new $APP.D(null,d,null,1,null))))),null,1,null),$APP.y([g]))))};O3.G=4;
O3.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);var g=$APP.w(d);d=$APP.u(g);g=$APP.w(g);return this.C(b,a,c,d,g)};var wrc=function(){var a=P5a(Vqc),b=$APP.x.B(a,0,null);a=kP(Vqc);var c=$APP.x.B(a,0,null),d=$APP.x.B(a,1,null);return vP(function(g,l){return mG.A(kG.A(c.j?c.j(g):c.call(null,g),c.j?c.j(l):c.call(null,l)),kG.C(tI.A(iO.j(b),2),d.j?d.j(g):d.call(null,g),$APP.y([d.j?d.j(l):d.call(null,l)])))},new $APP.H(null,2,5,$APP.I,[VO,VO],null))}();var XP=function XP(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return XP.C(arguments[0],arguments[1],c)};
XP.C=function(a,b,c){c=$APP.qe(c);c=$APP.C.B(c,Bdc,!1);b=O4a(b)?$APP.k(c)?x6a(b,a,c):b:$APP.k(c)?x6a(nP(b),a,b):nP(b);var d=$APP.ef(pP(b)),g=$APP.ef(oP(b));b=K1a($APP.Vg.A(function(n){return $APP.Vg.A(function(p){return a.A?a.A(n,p):a.call(null,n,p)},d)},d));var l=V1a(b);return function(n){var p=cP(n);if(0===p)return kG.A(n,$APP.Je.A(H3,g));var v=E3(d,p);v=$APP.Vg.A(function(G){return $APP.Je.A(n,G)},v);var t=E3(g,p),A=$APP.Vg.A(function(G){return $APP.un.A($APP.Lf.A($APP.vg,G),g)},t),B=$APP.Vg.A(function(G){return $APP.Je.A(H3,
G)},A);p=$APP.Vg.K(function(G,J,O){return kG.A($APP.Je.A(kG,G),F3.A($APP.N.A(J,O),g))},E3(l,p),t,A);return $APP.Je.A(mG,$APP.Vg.K(kG,p,v,B))}};XP.G=2;XP.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var P3=LK.A(function(a){return YH.C($APP.y([v2,UO.j?UO.j(a):UO.call(null,a)]))},VDb),xrc=LK.A(YH.C($APP.y([SZ,P3])),XNb),YP=function YP(a){switch(arguments.length){case 1:return YP.j(arguments[0]);case 2:return YP.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
YP.j=function(a){var b=IP(a),c=MP.j(a);return function(d){return function(g){return rP(function(l,n){l=c(l);l=l.j?l.j(d):l.call(null,d);n=n.j?n.j(l):n.call(null,l);return n.j?n.j(g):n.call(null,g)},b)}}};YP.A=function(a,b){b=XP(a,b);return YH.C($APP.y([b,WP,b,RP(a)]))};YP.G=2;
var yrc=LK.A(function(a){var b=$APP.Vg.A(SQ,new $APP.H(null,3,5,$APP.I,[0,1,2],null)),c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=aI.A(a,0),l=aI.A(a,1);a=aI.A(a,2);return wL.C($APP.y([TF.A(d.j?d.j(a):d.call(null,a),b.j?b.j(l):b.call(null,l)),TF.A(b.j?b.j(g):b.call(null,g),c.j?c.j(a):c.call(null,a)),TF.A(c.j?c.j(l):c.call(null,l),d.j?d.j(g):d.call(null,g))]))},AQb),zrc=LK.A(YH.C($APP.y([SZ,kG.A(P3,P3)])),zBb);var O6a=oJ.C(mJ(xJ.A(new $APP.D(null,FJ,new $APP.D(null,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Nv,new $APP.D(null,new $APP.ug(null,new $APP.f(null,3,[mH,null,nK,null,uH,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),new $APP.D(null,2,null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[$APP.r(new $APP.H(null,3,5,$APP.I,[FJ,$APP.Nv.j?$APP.Nv.j(a):$APP.Nv.call(null,a),2],null)),EJ.j?EJ.j(a):EJ.call(null,a)],
null)))?a:fJ(a)}),$APP.y([jYa(null)])),S6a=wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,new $APP.D(null,new $APP.ug(null,new $APP.f(null,2,[-1,null,-1,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[hQ,EJ.j?EJ.j(a):EJ.call(null,a)],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,$APP.Kv,
new $APP.D(null,new $APP.ug(null,new $APP.f(null,2,[-1,null,-1,null],null),null),null,1,null),2,null),3,null),new $APP.D(null,BT,null,1,null),2,null),3,null),zJ),function(a){return(a=$APP.r(new $APP.H(null,2,5,$APP.I,[hQ,$APP.r($APP.N.A(new $APP.H(null,1,5,$APP.I,[$APP.Hv],null),BT.j?BT.j(a):BT.call(null,a)))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,OU,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,EJ,null,1,null),2,null),
3,null),zJ),function(a){var b=$APP.I,c=$APP.I;var d=RF.j(a.j?a.j(OU):a.call(null,OU));return(a=$APP.r(new $APP.H(null,2,5,b,[hQ,$APP.r(new $APP.H(null,3,5,c,[$APP.Hv,d,EJ.j?EJ.j(a):EJ.call(null,a)],null))],null)))?a:fJ(a)}),mJ(xJ.A(new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,ZI,new $APP.D(null,OU,new $APP.D(null,sJ,null,1,null),2,null),3,null),new $APP.D(null,BT,null,1,null),2,null),3,null),zJ),function(a){var b=$APP.I,c=$APP.N.A,d=$APP.I;var g=RF.j(a.j?a.j(OU):a.call(null,OU));return(a=
$APP.r(new $APP.H(null,2,5,b,[hQ,$APP.r(c.call($APP.N,new $APP.H(null,2,5,d,[$APP.Hv,g],null),BT.j?BT.j(a):BT.call(null,a)))],null)))?a:fJ(a)})])),Arc=new $APP.H(null,10,5,$APP.I,"⁰¹²³⁴⁵⁶⁷⁸⁹".split(""),null),Brc=new $APP.H(null,10,5,$APP.I,"₀₁₂₃₄₅₆₇₈₉".split(""),null),Crc=/(.+)_([0-9a-zA-ZϖγηΦνΩδυσιΔρϵωϱςψΠπϑΞκφχζΨτΓΛΘΥμθαℓβΣξλφε]+)$/,Drc=/(.+)↑([0-9a-zA-ZϖγηΦνΩδυσιΔρϵωϱςψΠπϑΞκφχζΨτΓΛΘΥμθαℓβΣξλφε]+)$/,Erc=$APP.fg("Epsilon Mu Iota omicron Omicron Eta Zeta Alpha Rho Chi Nu Tau Kappa Beta".split(" "),
"ΕΜΙοOΗΖΑΡΧΝΤΚΒ".split("")),Frc=$APP.fg("ldots varpi gamma eta Phi nu Omega delta upsilon sigma iota Delta rho varepsilon omega varrho varsigma psi Pi pi vartheta Xi kappa varphi chi zeta Psi tau Gamma Lambda Theta Upsilon mu theta alpha ell beta Sigma xi lambda phi epsilon".split(" "),"... ϖ γ η Φ ν Ω δ υ σ ι Δ ρ ϵ ω ϱ ς ψ Π π ϑ Ξ κ φ χ ζ Ψ τ Γ Λ Θ Υ μ θ α ℓ β Σ ξ λ φ ε".split(" ")),Grc=$APP.Lf.B($APP.F,$APP.Vg.j(function(a){a=$APP.x.B(a,0,null);return new $APP.H(null,2,5,$APP.I,[a,["\\",$APP.m.j(a)].join("")],
null)}),Frc),Hrc=function(){var a=sD(function(b){return["\\",$APP.m.j(b)].join("")},$APP.rja(Frc));return $APP.Ni.C($APP.y([Grc,a,$APP.fg("cosh csc cot atan sin _ tan cos sinh sec asin tanh acos".split(" "),"\\sinh \\csc \\cot \\arctan \\sin \\_ \\tan \\cos \\sinh \\sec \\arcsin \\sinh \\arccos".split(" "))]))}(),Irc=$APP.Ni.C($APP.y([Erc,Frc])),Jrc=a7a($APP.y([Z6a,$APP.fg([hQ,$APP.bw,$APP.$v,$APP.Xv,$APP.Hv,FJ,$APP.aw,$APP.Jv,$APP.po,eH,$APP.Iu,$APP.sj,gQ,$APP.cw,$APP.Vw,$APP.Iv,$X,$APP.ko,gS],[6,
3,3,3,5,8,3,4,1,9,4,5,7,3,9,4,5,2,5]),V6a,new $APP.ug(null,new $APP.f(null,15,[hQ,"null",$APP.bw,"null",$APP.$v,"null",$APP.Xv,"null",$APP.Hv,"null",FJ,"null",$APP.aw,"null",$APP.Jv,"null",$APP.po,"null",$APP.sj,"null",$APP.cw,"null",$APP.Iv,"null",$X,"null",$APP.ko,"null",gS,"null"],null),null),T6a," ",$6a,!0,X6a,new $APP.f(null,3,[zW,"frac",YV,"int",$APP.Iu,"¬"],null),U6a,$APP.fg([gS,$APP.ko,$X,$APP.sj,FJ,dT,$APP.Vw,lY,$APP.po],[function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b),
" % ",$APP.m.j(a)].join("")},function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b)," ∧ ",$APP.m.j(a)].join("")},function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b)," mod ",$APP.m.j(a)].join("")},N6a,function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);var c=(c=$APP.xd(a))?$APP.Ke($APP.Mba)(a):c;return $APP.k(c)?[$APP.m.j(b),$APP.m.j(b7a(a,Arc))].join(""):null},function(a){a=$APP.x.B(a,0,null);return["⌊",$APP.m.j(a),"⌋"].join("")},function(a){return $APP.Uc.A($APP.Tc(a),
1)&&$APP.xd($APP.u(a))?["∂",$APP.m.j(b7a($APP.u(a),Brc))].join(""):null},function(a){a=$APP.x.B(a,0,null);return["⌈",$APP.m.j(a),"⌉"].join("")},function(a){var b=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return[$APP.m.j(b)," ∨ ",$APP.m.j(a)].join("")}]),W6a,function Q3(a){a:switch(a){case Infinity:var c="∞";break a;case -Infinity:c="-∞";break a;default:c=null}if($APP.k(c))return c;c=$APP.m.j(a);var d=Irc.j?Irc.j(c):Irc.call(null,c);if($APP.k(d))return d;d=$APP.Mg.A?$APP.Mg.A(Drc,c):$APP.Mg.call(null,
Drc,c);if($APP.k(d))return function(g){$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);var n=$APP.Lg(/[0-9]+/,g);return $APP.k(n)?[$APP.m.j(Q3(l)),$APP.m.j(b7a(n,Arc))].join(""):[$APP.m.j(Q3(l)),"↑",$APP.m.j(Q3(g))].join("")}(d);c=$APP.Mg.A?$APP.Mg.A(Crc,c):$APP.Mg.call(null,Crc,c);return $APP.k(c)?function(g){$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);var n=$APP.Lg(/[0-9]+/,g);return $APP.k(n)?[$APP.m.j(Q3(l)),$APP.m.j(b7a(n,Brc))].join(""):[$APP.m.j(Q3(l)),
"_",$APP.m.j(Q3(g))].join("")}(c):a}])),R3=function(){function a(A){return["\\left(",$APP.m.j(A),"\\right)"].join("")}function b(A){$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);A=jQ(R3.j?R3.j(A):R3.call(null,A));return[$APP.m.j(A),"^{\\prime\\prime}"].join("")}function c(A){$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);A=jQ(R3.j?R3.j(A):R3.call(null,A));return[$APP.m.j(A),"^\\prime"].join("")}function d(A){return function(B){$APP.x.B(B,0,null);B=$APP.x.B(B,1,null);return["\\",$APP.m.j(A)," ",$APP.m.j(jQ(R3.j?
R3.j(B):R3.call(null,B)))].join("")}}var g=d("dot"),l=d("ddot"),n=d("hat"),p=d("bar"),v=d("vec"),t=d("tilde");return a7a($APP.y([Z6a,$APP.fg([hQ,$APP.bw,$APP.$v,$APP.Xv,$APP.Hv,FJ,$APP.aw,$APP.Jv,$APP.po,eH,$APP.Iu,$APP.sj,gQ,$APP.cw,$APP.Vw,$APP.Iv,$X,$APP.ko,gS],[6,3,3,3,5,8,3,4,1,9,1,0,7,3,9,4,5,2,5]),Y6a,a,V6a,new $APP.ug(null,new $APP.f(null,15,[hQ,"null",$APP.bw,"null",$APP.$v,"null",$APP.Xv,"null",$APP.Hv,"null",FJ,"null",$APP.aw,"null",$APP.Jv,"null",$APP.po,"null",$APP.sj,"null",$APP.cw,
"null",$APP.Iv,"null",$X,"null",$APP.ko,"null",gS,"null"],null),null),T6a,"\\,",$6a,!0,U6a,$APP.fg([gS,$APP.ko,zP,$APP.cw,$X,$APP.sj,wFb,$APP.Iu,mjb,$APP.Xv,FJ,zW,dT,$APP.Vw,lY,yP,HJ,YV,$APP.po],[function(A){var B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return[$APP.m.j(jQ(B))," \\mathbin{\\%} ",$APP.m.j(jQ(A))].join("")},function(A){var B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return[$APP.m.j(B)," \\land ",$APP.m.j(A)].join("")},function(A){return["\\begin{pmatrix}",$APP.Kl.A(" \\cr \\cr ",$APP.Vg.A(c7a,
A)),"\\end{pmatrix}"].join("")},function(A){return $APP.Kl.A(" \\geq ",A)},function(A){var B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return[$APP.m.j(jQ(B))," \\bmod ",$APP.m.j(jQ(A))].join("")},function(A){var B=$APP.Tc(A);return $APP.Uc.A(B,1)?["\\frac",iQ(1),iQ($APP.u(A))].join(""):$APP.Uc.A(B,2)?["\\frac",iQ($APP.u(A)),iQ($APP.Xc(A))].join(""):null},function(A){return["\\begin{bmatrix}",$APP.Kl.A(" \\cr \\cr ",$APP.Vg.A(function(B){B=$APP.Vg.A($APP.Jl.A(c7a,R3),B);return $APP.Kl.A(" \x26 ",B)},
A)),"\\end{bmatrix}"].join("")},function(A){A=$APP.x.B(A,0,null);return["\\lnot",a(A)].join("")},function(A){return["\\begin{bmatrix}",$APP.Kl.A(" \\cr \\cr ",$APP.Vg.A(c7a,A)),"\\end{bmatrix}"].join("")},function(A){return $APP.Kl.A(" \\leq ",A)},function(A){var B=$APP.x.B(A,0,null);A=$APP.x.B(A,1,null);return[$APP.m.j(jQ(B)),"^",$APP.m.j(jQ(A))].join("")},function(A){A=$APP.x.B(A,0,null);return["\\mathsf{frac} ",a(A)].join("")},function(A){A=$APP.x.B(A,0,null);return["\\left\\lfloor ",$APP.m.j(A),
" \\right\\rfloor"].join("")},function(A){return["\\partial_",$APP.m.j(jQ($APP.Kl.A(",",A)))].join("")},function(A){A=$APP.x.B(A,0,null);return["\\left\\lceil ",$APP.m.j(A)," \\right\\rceil"].join("")},function(A){return["\\begin{bmatrix}",$APP.Kl.A($APP.k(!1)?" \\cr \\cr ":"\x26",$APP.Vg.A(c7a,A)),"\\end{bmatrix}"].join("")},function(A){return["\\sqrt ",$APP.m.j(jQ($APP.u(A)))].join("")},function(A){A=$APP.x.B(A,0,null);return["\\mathsf{int} ",a(A)].join("")},function(A){var B=$APP.x.B(A,0,null);
A=$APP.x.B(A,1,null);return[$APP.m.j(B)," \\lor ",$APP.m.j(A)].join("")}]),W6a,function G(B){if(xTa(B))return["\\frac",iQ(DG(B)),iQ(EG(B))].join("");a:switch(B){case Infinity:var J="\\infty";break a;case -Infinity:J="-\\infty";break a;default:J=null}if($APP.k(J))return J;var O=$APP.m.j(B);J=Hrc.j?Hrc.j(O):Hrc.call(null,O);if($APP.k(J))return J;J=$APP.Mg.A?$APP.Mg.A(Drc,O):$APP.Mg.call(null,Drc,O);if($APP.k(J))return function(R){$APP.x.B(R,0,null);var W=$APP.x.B(R,1,null);R=$APP.x.B(R,2,null);return[$APP.m.j(jQ(G(W))),
"^",$APP.m.j(jQ(G(R)))].join("")}(J);J=$APP.Mg.A?$APP.Mg.A(Crc,O):$APP.Mg.call(null,Crc,O);if($APP.k(J))return function(R){$APP.x.B(R,0,null);var W=$APP.x.B(R,1,null);R=$APP.x.B(R,2,null);return[$APP.m.j(jQ(G(W))),"_",$APP.m.j(jQ(G(R)))].join("")}(J);J=function(){var R=/(.+)dotdot$/;return $APP.Mg.A?$APP.Mg.A(R,O):$APP.Mg.call(null,R,O)}();if($APP.k(J))return l(J);J=function(){var R=/(.+)dot$/;return $APP.Mg.A?$APP.Mg.A(R,O):$APP.Mg.call(null,R,O)}();if($APP.k(J))return g(J);J=function(){var R=/(.+)hat$/;
return $APP.Mg.A?$APP.Mg.A(R,O):$APP.Mg.call(null,R,O)}();if($APP.k(J))return n(J);J=function(){var R=/(.+)primeprime$/;return $APP.Mg.A?$APP.Mg.A(R,O):$APP.Mg.call(null,R,O)}();if($APP.k(J))return b(J);J=function(){var R=/(.+)prime$/;return $APP.Mg.A?$APP.Mg.A(R,O):$APP.Mg.call(null,R,O)}();if($APP.k(J))return c(J);J=function(){var R=/(.+)bar$/;return $APP.Mg.A?$APP.Mg.A(R,O):$APP.Mg.call(null,R,O)}();if($APP.k(J))return p(J);J=function(){var R=/(.+)vec$/;return $APP.Mg.A?$APP.Mg.A(R,O):$APP.Mg.call(null,
R,O)}();if($APP.k(J))return v(J);J=function(){var R=/(.+)tilde$/;return $APP.Mg.A?$APP.Mg.A(R,O):$APP.Mg.call(null,R,O)}();return $APP.k(J)?t(J):B instanceof $APP.q&&1<O.length&&$APP.eb($APP.Lg(/^d[a-zαωθφ]/,O))?$APP.k(!0)?["\\mathsf",iQ(O)].join(""):iQ(O):B}]))}(),S3=function S3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return S3.C(arguments[0],c)};
S3.C=function(a,b){b=$APP.qe(b);b=$APP.C.A(b,IDb);a=R3.j?R3.j(a):R3.call(null,a);return $APP.k(b)?["\\begin{equation}\n","string"===typeof b&&$APP.r(b)?["\\label{",$APP.m.j(b),"}\n"].join(""):"",$APP.m.j(a),"\n\\end{equation}"].join(""):a};S3.G=1;S3.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var BQ=function(){function a(b){return["[",$APP.Kl.A(", ",b),"]"].join("")}return a7a($APP.y([Z6a,$APP.fg([hQ,$APP.bw,$APP.$v,$APP.Xv,$APP.Hv,$APP.aw,$APP.Jv,$APP.po,eH,$APP.Iu,$APP.sj,gQ,$APP.cw,$APP.Iv,$APP.ko],[7,2,2,2,5,2,3,1,8,9,5,8,2,3,1]),V6a,new $APP.ug(null,new $APP.f(null,6,[hQ,"null",$APP.bw,"null",$APP.Hv,"null",$APP.Jv,"null",$APP.sj,"null",$APP.Iv,"null"],null),null),X6a,$APP.fg([yH,mH,nK,uH,$APP.Ku,$APP.Iu,DJ,wH,FJ,jK,mK,dT,qV,lY,HJ,lK,BJ,YV,hW,qX,HV],"Math.sinh Math.sin Math.tan Math.cos Math.abs ! Math.log Math.cosh Math.pow Math.atan Math.acos Math.floor Math.acosh Math.ceil Math.sqrt Math.asin Math.exp Math.trunc Math.asinh Math.tanh Math.atanh".split(" ")),
W6a,function(b){return b instanceof $APP.q?$APP.hi(b):b},U6a,function(){function b(c){return["(",$APP.m.j(c),")"].join("")}return new $APP.f(null,7,[zP,a,yP,a,$X,function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return b([b([b([$APP.m.j(d)," % ",$APP.m.j(c)].join(""))," + ",$APP.m.j(c)].join(""))," % ",$APP.m.j(c)].join(""))},gS,function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return[$APP.m.j(d)," % ",$APP.m.j(c)].join("")},$APP.ko,function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,
1,null);return[$APP.m.j(d)," \x26\x26 ",$APP.m.j(c)].join("")},$APP.po,function(c){var d=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return[$APP.m.j(d)," || ",$APP.m.j(c)].join("")},$APP.sj,N6a],null)}()]))}();var y7a=(lG.j(5)+1)/2,x7a=(lG.j(5)-1)/2,w7a=1-x7a,T3=function T3(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return T3.C(c)};T3.C=function(a){return $APP.Je.B($APP.Pt,$APP.Xc,a)};T3.G=0;T3.M=function(a){return this.C($APP.r(a))};
var U3=function U3(a){switch(arguments.length){case 3:return U3.B(arguments[0],arguments[1],arguments[2]);case 4:return U3.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};U3.B=function(a,b,c){return U3.K(a,b,c,$APP.F)};
U3.K=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,$zb,T3);var l=$APP.C.B(g,$APP.Xw,$APP.Le(null)),n=VY.j(a);a=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);b=$APP.od(b)?b:new $APP.H(null,2,5,$APP.I,[b,n.j?n.j(b):n.call(null,b)],null);var p=$APP.x.B(b,0,null),v=$APP.od(c)?c:new $APP.H(null,2,5,$APP.I,[c,n.j?n.j(c):n.call(null,c)],null),t=$APP.x.B(v,0,null);c=$APP.Ni.C($APP.y([new $APP.f(null,5,[oQ,1E3,nQ,1E3,s7a,1E-8,D7a,1E-8,F7a,a],null),g]));var A=tQ(t,p);p=tQ(p,t);g=E7a(c);c=G7a($APP.rg.B(c,F7a,a));
b=new $APP.H(null,4,5,$APP.I,[b,new $APP.H(null,2,5,$APP.I,[A,n.j?n.j(A):n.call(null,A)],null),new $APP.H(null,2,5,$APP.I,[p,n.j?n.j(p):n.call(null,p)],null),v],null);$APP.x.B(b,0,null);$APP.x.B(b,1,null);$APP.x.B(b,2,null);$APP.x.B(b,3,null);v=b;for(b=0;;){A=$APP.x.B(v,0,null);p=$APP.x.B(v,1,null);t=$APP.x.B(v,2,null);var B=$APP.x.B(v,3,null);l.S?l.S(A,p,t,B,b):l.call(null,A,p,t,B,b);v=g(A,p,t,B,b);var G=v;G=$APP.k(G)?G:c(A,p,t,B,b);if($APP.k(G))return l=d.K?d.K(A,p,t,B):d.call(null,A,p,t,B),d=$APP.x.B(l,
0,null),l=$APP.x.B(l,1,null),new $APP.f(null,5,[pQ,d,$APP.iw,l,qQ,$APP.vd(v),rQ,b,sQ,$APP.Fb(a)],null);v=z7a(n,A,p,t,B);b+=1}};U3.G=4;var V3=function V3(a){switch(arguments.length){case 3:return V3.B(arguments[0],arguments[1],arguments[2]);case 4:return V3.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};V3.B=function(a,b,c){return V3.K(a,b,c,$APP.F)};
V3.K=function(a,b,c,d){a=$APP.Jl.A(RF,a);return $APP.Gj.B(U3.K(a,b,c,d),$APP.iw,RF)};V3.G=4;var W3=function W3(a){switch(arguments.length){case 1:return W3.j(arguments[0]);case 2:return W3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};W3.j=function(a){return W3.A(a,$APP.F)};
W3.A=function(a,b){function c(B,G,J,O){var R=$APP.x.B(B,0,null),W=$APP.x.B(J,0,null);G=new $APP.f(null,5,[z4b,B,qvb,G,T2b,J,sQ,$APP.Fb(v),rQ,O],null);return W<R?$APP.rg.C(G,z4b,J,$APP.y([T2b,B])):G}function d(B,G,J,O){$APP.x.B(G,0,null);B=$APP.x.B(G,1,null);$APP.x.B(J,0,null);J=$APP.x.B(J,1,null);return O>n||$APP.Fb(v)>p||B<=J}b=$APP.qe(b);var g=$APP.C.B(b,T4b,0),l=$APP.C.B(b,U4b,1),n=$APP.C.B(b,nQ,1E3),p=$APP.C.B(b,oQ,1E3);a=VY.j(a);var v=$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);b=L7a(a,b);l=H7a(a,
g,l);g=$APP.x.B(l,0,null);var t=$APP.x.B(g,0,null);l=$APP.x.B(l,1,null);var A=$APP.x.B(l,0,null);t=uQ(t,A);a=a.j?a.j(t):a.call(null,t);a=new $APP.H(null,3,5,$APP.I,[l,g,new $APP.H(null,2,5,$APP.I,[t,a],null)],null);$APP.x.B(a,0,null);$APP.x.B(a,1,null);$APP.x.B(a,2,null);g=a;for(a=0;;){t=g;g=$APP.x.B(t,0,null);l=$APP.x.B(t,1,null);t=$APP.x.B(t,2,null);if(d(g,l,t,a))return c(g,l,t,a);g=b(g,l,t);a+=1}};W3.G=2;
var X3=function X3(a){switch(arguments.length){case 1:return X3.j(arguments[0]);case 2:return X3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};X3.j=function(a){return X3.A(a,$APP.F)};X3.A=function(a,b){a=$APP.Jl.A(RF,a);return W3.A(a,b)};X3.G=2;
var Y3=function Y3(a){switch(arguments.length){case 1:return Y3.j(arguments[0]);case 2:return Y3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Y3.j=function(a){return Y3.A(a,$APP.F)};
Y3.A=function(a,b){b=$APP.qe(b);var c=$APP.C.B(b,$APP.pq,0),d=$APP.C.B(b,uZb,10);b=$APP.C.B(b,nQ,1E3);var g=VY.j(a);a=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var l=H7a(g,c,c+d);c=$APP.x.B(l,0,null);d=$APP.x.B(c,0,null);l=$APP.x.B(l,1,null);var n=$APP.x.B(l,0,null);n=d+(d-n);a:{d=c;var p=new $APP.H(null,2,5,$APP.I,[n,g.j?g.j(n):g.call(null,n)],null);for(c=0;;){n=$APP.x.B(l,0,null);var v=l;l=p;p=$APP.x.B(l,0,null);var t=v,A=d,B=l,G=c;$APP.x.B(t,0,null);t=$APP.x.B(t,1,null);$APP.x.B(A,0,null);A=$APP.x.B(A,
1,null);$APP.x.B(B,0,null);B=$APP.x.B(B,1,null);if(G>b||A<=(t<B?t:B)){g=v;v=c;c=$APP.x.B(g,0,null);n=$APP.x.B(l,0,null);b=new $APP.f(null,6,[z4b,g,qvb,d,T2b,l,sQ,$APP.Fb(a),qQ,v<=b,rQ,v],null);b=n<c?$APP.rg.C(b,z4b,l,$APP.y([T2b,g])):b;break a}v=p+(p-n);n=l;v=new $APP.H(null,2,5,$APP.I,[v,g.j?g.j(v):g.call(null,v)],null);c+=1;l=d;d=n;p=v}}return b};Y3.G=2;
var Z3=function Z3(a){switch(arguments.length){case 1:return Z3.j(arguments[0]);case 2:return Z3.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};Z3.j=function(a){return Z3.A(a,$APP.F)};Z3.A=function(a,b){a=$APP.Jl.A(RF,a);return W3.A(a,b)};Z3.G=2;var vQ=function vQ(a){switch(arguments.length){case 3:return vQ.B(arguments[0],arguments[1],arguments[2]);case 4:return vQ.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};vQ.B=function(a,b,c){return vQ.K(a,b,c,$APP.F)};
vQ.K=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,V4b,1E-11);var l=$APP.C.B(g,SLb,JR),n=$APP.C.B(g,Oqb,b+w7a*(c-b)),p=$APP.C.B(g,nQ,1E3),v=$APP.C.A(g,oQ);g=$APP.C.B(g,$APP.Xw,$APP.Le(null));v=$APP.k(v)?v:p+1;b=new $APP.H(null,2,5,$APP.I,[b<c?b:c,b>c?b:c],null);c=$APP.x.B(b,0,null);var t=$APP.x.B(b,1,null);b=VY.j(a);a=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);n=new $APP.H(null,2,5,$APP.I,[n,b.j?b.j(n):b.call(null,n)],null);c=new $APP.H(null,3,5,$APP.I,[c,n,t],null);$APP.x.B(c,0,null);t=$APP.x.B(c,
1,null);$APP.x.B(t,0,null);$APP.x.B(t,1,null);$APP.x.B(c,2,null);n=new $APP.H(null,2,5,$APP.I,[n,n],null);$APP.x.B(n,0,null);$APP.x.B(n,1,null);for(var A=n,B=n=0,G=0;;){var J=c;t=$APP.x.B(J,0,null);c=$APP.x.B(J,1,null);var O=$APP.x.B(c,0,null),R=$APP.x.B(c,1,null);J=$APP.x.B(J,2,null);var W=A;A=$APP.x.B(W,0,null);W=$APP.x.B(W,1,null);var Z=n;n=G;var fa=l+d*jG.j(O);G=2*fa;var ia=G;var ja=.5*(J-t);ia=jG.j(O-.5*(t+J))+ja<=ia;g.B?g.B(n,O,R):g.call(null,n,O,R);if(n>p||$APP.Fb(a)>v||ia)return new $APP.f(null,
5,[pQ,O,$APP.iw,R,rQ,n,qQ,ia,sQ,$APP.Fb(a)],null);jG.j(Z)<=fa?R=M7a(t,O,J):(ia=I7a(W,c,A),R=$APP.x.B(ia,0,null),ia=$APP.x.B(ia,1,null),ja=Z,Z=R>ia*(t-O)&&R<ia*(J-O),ja=jG.j(R)<jG.j(.5*ia*ja),R=Z&&ja?new $APP.H(null,2,5,$APP.I,[B,R/ia],null):M7a(t,O,J));B=R;R=$APP.x.B(B,0,null);B=$APP.x.B(B,1,null);Z=O;ia=B;ja=Z+ia;fa=ja-t<G||J-ja<G?Z<=.5*(t+J)?Z+fa:Z-fa:jG.j(ia)<fa?0<ia?Z+fa:Z-fa:ja;G=new $APP.H(null,2,5,$APP.I,[fa,b.j?b.j(fa):b.call(null,fa)],null);ia=fa<O?new $APP.H(null,2,5,$APP.I,[G,c],null):
new $APP.H(null,2,5,$APP.I,[c,G],null);Z=$APP.x.B(ia,0,null);O=$APP.x.B(Z,0,null);fa=$APP.x.B(Z,1,null);var ta=$APP.x.B(ia,1,null);ia=$APP.x.B(ta,0,null);ja=$APP.x.B(ta,1,null);t=fa<=ja?new $APP.H(null,3,5,$APP.I,[t,Z,ia],null):new $APP.H(null,3,5,$APP.I,[O,ta,J],null);J=A;A=W;ta=G;W=$APP.x.B(J,0,null);O=$APP.x.B(J,1,null);G=$APP.x.B(A,0,null);fa=$APP.x.B(A,1,null);Z=$APP.x.B(c,0,null);ia=$APP.x.B(c,1,null);ja=$APP.x.B(ta,0,null);ta=$APP.x.B(ta,1,null);J=ta<=ia?new $APP.H(null,2,5,$APP.I,[A,c],null):
ta<=fa||$APP.Uc.A(G,Z)?new $APP.H(null,2,5,$APP.I,[A,new $APP.H(null,2,5,$APP.I,[ja,ta],null)],null):ta<=O||$APP.Uc.A(W,Z)||$APP.Uc.A(W,G)?new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[ja,ta],null),A],null):new $APP.H(null,2,5,$APP.I,[J,A],null);W=R;R=B;O=n+1;c=t;A=J;n=W;B=R;G=O}};vQ.G=4;var $3=function $3(a){switch(arguments.length){case 3:return $3.B(arguments[0],arguments[1],arguments[2]);case 4:return $3.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};$3.B=function(a,b,c){return $3.K(a,b,c,$APP.Le(null))};$3.K=function(a,b,c,d){return vQ.K(a,b,c,new $APP.f(null,1,[$APP.Xw,d],null))};$3.G=4;
var a4=function a4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return a4.C(arguments[0],arguments[1],c)};a4.C=function(a,b,c){var d=$APP.qe(c);c=$APP.C.A(d,Z6b);a=v7a(a,b,d);return $APP.k(qQ.j(a))?$APP.k(c)?a:pQ.j(a):WNa(["multidimensional-minimize failed to converge: ",$APP.m.j(a)].join(""))};a4.G=2;a4.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var Krc=$APP.kh.j($APP.F),Lrc=$APP.fg([nX,gS,zP,yH,mH,nK,uH,$X,$APP.sj,$APP.Ku,DJ,wH,FJ,zW,$APP.Iv,$APP.Hv,jK,mK,dT,$APP.Jv,qV,lY,yP,HJ,lK,BJ,YV,hW,qX,HV],[new $APP.f(null,2,[$APP.mx,bLb,$APP.Dy,$APP.Pd],null),new $APP.f(null,2,[$APP.mx,ZYb,$APP.Dy,$APP.Qd],null),new $APP.f(null,2,[$APP.mx,RMb,$APP.Dy,$APP.ps],null),new $APP.f(null,2,[$APP.mx,WBb,$APP.Dy,function(a){return Math.sinh(a)}],null),new $APP.f(null,2,[$APP.mx,uKb,$APP.Dy,function(a){return Math.sin(a)}],null),new $APP.f(null,2,[$APP.mx,
Sbc,$APP.Dy,function(a){return Math.tan(a)}],null),new $APP.f(null,2,[$APP.mx,M$b,$APP.Dy,function(a){return Math.cos(a)}],null),new $APP.f(null,2,[$APP.mx,YFb,$APP.Dy,$APP.Od],null),new $APP.f(null,2,[$APP.mx,Ydc,$APP.Dy,$APP.Zs],null),new $APP.f(null,2,[$APP.mx,fOb,$APP.Dy,function(a){return Math.abs(a)}],null),new $APP.f(null,2,[$APP.mx,ZCb,$APP.Dy,function(a){return Math.log(a)}],null),new $APP.f(null,2,[$APP.mx,Ljb,$APP.Dy,function(a){return Math.cosh(a)}],null),new $APP.f(null,2,[$APP.mx,EUb,
$APP.Dy,function(a,b){return Math.pow(a,b)}],null),new $APP.f(null,2,[$APP.mx,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.ay,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,$APP.Yv,null,1,null))))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Jy,null,1,null),new $APP.D(null,$APP.Yv,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,VNb,null,1,null),new $APP.D(null,$APP.Yv,null,1,null)))),null,1,null)])))),
null,1,null)])))),$APP.Hk,function(a){return a-Math.floor(a)}],null),new $APP.f(null,2,[$APP.mx,HG,$APP.Dy,$APP.yr],null),new $APP.f(null,2,[$APP.mx,odc,$APP.Dy,$APP.Ys],null),new $APP.f(null,2,[$APP.mx,kKb,$APP.Dy,function(a){return Math.atan(a)}],null),new $APP.f(null,2,[$APP.mx,DQb,$APP.Dy,function(a){return Math.acos(a)}],null),new $APP.f(null,2,[$APP.mx,VNb,$APP.Dy,function(a){return Math.floor(a)}],null),new $APP.f(null,2,[$APP.mx,$APP.Jy,$APP.Dy,$APP.Ek],null),new $APP.f(null,2,[$APP.mx,f_b,
$APP.Dy,function(a){return Math.acosh(a)}],null),new $APP.f(null,2,[$APP.mx,P5b,$APP.Dy,function(a){return Math.ceil(a)}],null),new $APP.f(null,2,[$APP.mx,OP,$APP.Dy,SN],null),new $APP.f(null,2,[$APP.mx,u$b,$APP.Dy,function(a){return Math.sqrt(a)}],null),new $APP.f(null,2,[$APP.mx,ANb,$APP.Dy,function(a){return Math.asin(a)}],null),new $APP.f(null,2,[$APP.mx,u2b,$APP.Dy,function(a){return Math.exp(a)}],null),new $APP.f(null,2,[$APP.mx,oGb,$APP.Dy,function(a){return Math.trunc(a)}],null),new $APP.f(null,
2,[$APP.mx,icb,$APP.Dy,function(a){return Math.asinh(a)}],null),new $APP.f(null,2,[$APP.mx,$eb,$APP.Dy,function(a){return Math.tanh(a)}],null),new $APP.f(null,2,[$APP.mx,Ldc,$APP.Dy,function(a){return Math.atanh(a)}],null)]),f8a=sD($APP.mx,Lrc),T7a=$APP.Oi.C(Lrc,zP,$APP.y([yP])),Mrc=B9b,wQ=new $APP.ug(null,new $APP.f(null,5,[$APP.sE,null,$APP.Mi,null,B9b,null,IG,null,WPb,null],null),null),AQ=function AQ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?
new $APP.Bc(c.slice(2),0,null):null;return AQ.C(arguments[0],arguments[1],c)},ONa;
AQ.C=function(a,b,c){var d=G6a(a),g=function(){return function p(n){return new $APP.de(null,function(){for(var v=n;;){var t=$APP.r(v);if(t){var A=t,B=$APP.u(A);if(t=$APP.r(function(G,J,O,R,W){return function ia(fa){return new $APP.de(null,function(){return function(){for(;;){var ja=$APP.r(fa);if(ja){if($APP.pd(ja)){var ta=$APP.lc(ja),ua=$APP.Tc(ta),ca=$APP.fe(ua);a:for(var V=0;;)if(V<ua){var da=$APP.bd(ta,V);ca.add(da);V+=1}else{ta=!0;break a}return ta?$APP.ie($APP.ke(ca),ia($APP.mc(ja))):$APP.ie($APP.ke(ca),
null)}ca=$APP.u(ja);return $APP.Yd(ca,ia($APP.Fc(ja)))}return null}}}(G,J,O,R,W),null,null)}}(v,B,A,t,d)(B)))return $APP.N.A(t,p($APP.Fc(v)));v=$APP.Fc(v)}else return null}},null,null)}(b)}();return L6a($APP.Uc.A(ZP(fQ(d)),$APP.hm)?M6a(dQ(fQ(d)),function(l){return $APP.k(c)?$APP.Lf.A($APP.sf,$APP.N.A(g,l)):$APP.Lf.A(l,g)}):eQ(d,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.hm,null,1,null),new $APP.D(null,$APP.tf(g),null,1,null),$APP.y([new $APP.D(null,ZP(d),null,1,null)]))))))};AQ.G=2;
AQ.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};ONa=$APP.$ja(new $APP.f(null,2,[$APP.Wo,new $APP.f(null,1,[$APP.$w,Math],null),$APP.bm,new $APP.f(null,1,[Bcb,new $APP.f(null,2,[zP,wL,yP,SN],null)],null)],null));
$APP.MR=function MR(a){switch(arguments.length){case 3:return MR.B(arguments[0],arguments[1],arguments[2]);case 4:return MR.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};$APP.MR.B=function(a,b,c){return $APP.MR.K(a,b,c,$APP.F)};
$APP.MR.K=function(a,b,c,d){var g=$APP.qe(d),l=$APP.C.B(g,$APP.hq,Mrc);d=$APP.C.B(g,$APP.xQ,kV);var n=$APP.C.A(g,ZH),p=$APP.C.B(g,$APP.iYb,$APP.vd(b)),v=$APP.C.B(g,R7a,FM.j(4)),t=$APP.C.B(g,oUa,!0);g=$APP.C.B(g,$APP.cV,!0);var A=new $APP.f(null,5,[$APP.xQ,d,$APP.iYb,p,$APP.hq,l,ZH,n,$APP.Dy,a],null);n=function(){if($APP.k(t)){var J=$APP.Fb(Krc);return J.j?J.j(A):J.call(null,A)}return t}();if($APP.k(n))return bH($APP.Yu,"emmy.expression.compile",607,new $APP.bh(function(){return new $APP.H(null,1,
5,$APP.I,["compiled state function cache hit"],null)},null),298571733),n;var B=M_a(),G=W7a(l);l=function(){function J(R,W){var Z=null;if(1<arguments.length){Z=0;for(var fa=Array(arguments.length-1);Z<fa.length;)fa[Z]=arguments[Z+1],++Z;Z=new $APP.Bc(fa,0,null)}return O.call(this,R,Z)}function O(R,W){W=$APP.qe(W);return $APP.Ni.C($APP.y([new $APP.f(null,1,[$APP.gm,R],null),W]))}J.G=1;J.M=function(R){var W=$APP.u(R);R=$APP.Fc(R);return O(W,R)};J.C=O;return J}();c=l8a(c,v);n=function(){return $APP.k(b)?
$APP.k(p)?function R(O){return new $APP.de(null,function(){for(;;){var W=$APP.r(O);if(W){if($APP.pd(W)){var Z=$APP.lc(W),fa=$APP.Tc(Z),ia=$APP.fe(fa);a:for(var ja=0;;)if(ja<fa)$APP.bd(Z,ja),$APP.je(ia,v.j?v.j($APP.Sv):v.call(null,$APP.Sv)),ja+=1;else{Z=!0;break a}return Z?$APP.ie($APP.ke(ia),R($APP.mc(W))):$APP.ie($APP.ke(ia),null)}$APP.u(W);return $APP.Yd(v.j?v.j($APP.Sv):v.call(null,$APP.Sv),R($APP.Fc(W)))}return null}},null,null)}(b):b:b}();a=!1!==n?$APP.Je.A(a,n):a;a:switch(d instanceof $APP.E?
d.ga:null){case "native":a=$APP.Je.A(a,c);break a;default:a=a.j?a.j(c):a.call(null,c)}d=b8a($7a(c8a($APP.Gj.B(Z7a(l(cG.j($APP.k(g)?dG.j(a):a),$APP.xQ,d,$APP.fm,$APP.k(p)?n:null,Y7a,c),v),$APP.gm,U7a)),function(){return v.j?v.j("_"):v.call(null,"_")}));a=function(){var J=G instanceof $APP.E?G.ga:null;switch(J){case "source":return i8a;case "clj":return g8a;case "js":return i8a;case "native":return j8a;case "sci":return k8a;default:throw Error(["No matching clause: ",$APP.m.j(J)].join(""));}}();d=a.j?
a.j(d):a.call(null,d);bH($APP.Yu,"emmy.expression.compile",640,new $APP.bh(function(){return new $APP.H(null,2,5,$APP.I,["compiled function in",B.Bf(null)],null)},null),-368687219);$APP.k($APP.k(t)?p:t)&&$APP.lh.K(Krc,$APP.rg,A,d);return d};$APP.MR.G=4;
$APP.b4=function b4(a){switch(arguments.length){case 1:return b4.j(arguments[0]);case 2:return b4.A(arguments[0],arguments[1]);case 3:return b4.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
$APP.b4.j=function(a){var b=$APP.b4.A;var c=UH(a);var d=$APP.x.B(c,0,null),g=$APP.x.B(c,1,null);c=$APP.Uc.A(d,hI)?g:yD(["`compile-fn` can only infer arity for functions with just one\n           arity, not ",$APP.m.j(c),". Please pass an explicit `n`."].join(""));return b.call($APP.b4,a,c)};$APP.b4.A=function(a,b){return $APP.b4.B(a,b,$APP.F)};
$APP.b4.B=function(a,b,c){var d=$APP.Lf.A($APP.sf,$APP.Pn.A(b,function(){return $APP.Oj.j($APP.Yv)}));return $APP.MR.K(a,!1,d,$APP.Ni.C($APP.y([new $APP.f(null,2,[$APP.xQ,B9b,ZH,b],null),c])))};$APP.b4.G=3;var p8a=new $APP.H(null,2,5,$APP.I,[bCb,bCb],null),S8a=new $APP.H(null,2,5,$APP.I,[CQ,CQ],null),R8a=new $APP.H(null,2,5,$APP.I,[bCb,CQ],null),T8a=new $APP.H(null,2,5,$APP.I,[CQ,bCb],null);$APP.Vg.B(function(a,b){return a/2*b},$APP.af(function(a){return 2*a},4),$APP.af(function(a){return a/lG.j(2+lG.j(4-nG.j(a)))},Math.sqrt(2)));var IQ=function IQ(a){switch(arguments.length){case 2:return IQ.A(arguments[0],arguments[1]);case 3:return IQ.B(arguments[0],arguments[1],arguments[2]);case 4:return IQ.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};IQ.A=function(a,b){return BI(u8a(a,b,$APP.af($APP.Lc,1)))};
IQ.B=function(a,b,c){return BI(u8a(a,b,c))};IQ.K=function(a,b,c,d){return IQ.B(a,b,$APP.af(function(g){return d+g},c))};IQ.G=4;var c4=function c4(a){switch(arguments.length){case 3:return c4.B(arguments[0],arguments[1],arguments[2]);case 4:return c4.K(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return c4.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
c4.B=function(a,b,c){return $APP.x.A(u8a(a,c,$APP.af($APP.Lc,1)),b)};c4.K=function(a,b,c,d){return $APP.x.A(u8a(a,c,d),b)};c4.S=function(a,b,c,d,g){return c4.K(a,b,c,$APP.af(function(l){return g+l},d))};c4.G=5;var d4=function d4(a){switch(arguments.length){case 1:return d4.j(arguments[0]);case 3:return d4.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};d4.j=function(a){return d4.B(a,1,$APP.Lc)};
d4.B=function(a,b,c){return EI(function(d){return new $APP.H(null,2,5,$APP.I,[b,d],null)},function(d,g){var l=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var n=Math.pow(a,l),p=n-1;return new $APP.H(null,2,5,$APP.I,[c.j?c.j(l):c.call(null,l),(n*d-g)/p],null)},function(d){return $APP.fd($APP.$c(d))})};d4.G=3;
var e4=function e4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return e4.C(arguments[0],c)};e4.C=function(a,b){return G_.j($APP.Je.B(d4,a,b))};e4.G=1;e4.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var f4=function f4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return f4.C(arguments[0],c)};
f4.C=function(a,b){return GI.j($APP.Je.B(d4,a,b))};f4.G=1;f4.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var g4=function g4(a){switch(arguments.length){case 3:return g4.B(arguments[0],arguments[1],arguments[2]);case 4:return g4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};g4.B=function(a,b,c){return g4.K(a,b,c,$APP.F)};g4.K=function(a,b,c,d){return B8a(G8a(w8a(a,b,c),D8a(a,b,c),2,$APP.tr.A(d,1)),d)};g4.G=4;
var h4=function h4(a){switch(arguments.length){case 3:return h4.B(arguments[0],arguments[1],arguments[2]);case 4:return h4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};h4.B=function(a,b,c){return h4.K(a,b,c,$APP.F)};h4.K=function(a,b,c,d){return B8a(G8a(x8a(a,b,c),D8a(a,b,c),2,$APP.tr.A(d,1)),d)};h4.G=4;
var i4=function i4(a){switch(arguments.length){case 3:return i4.B(arguments[0],arguments[1],arguments[2]);case 4:return i4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};i4.B=function(a,b,c){return i4.K(a,b,c,$APP.F)};i4.K=function(a,b,c,d){d=$APP.qe(d);var g=$APP.C.B(d,$APP.tr,1);g="number"===typeof g?JQ.A(2,g):g;return B8a($APP.Vg.A(z8a(a,b,c),g),d)};i4.G=4;
var j4=function j4(a){switch(arguments.length){case 3:return j4.B(arguments[0],arguments[1],arguments[2]);case 4:return j4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};j4.B=function(a,b,c){return j4.K(a,b,c,$APP.F)};j4.K=function(a,b,c,d){d=$APP.qe(d);var g=$APP.C.B(d,$APP.tr,1);g="number"===typeof g?JQ.A(2,g):g;return B8a($APP.Vg.A(y8a(a,b,c),g),d)};j4.G=4;
var Nrc=GQ(function(a,b,c){return(a.j?a.j(b):a.call(null,b))*(c-b)},g4),Orc=GQ(function(a,b,c){return(a.j?a.j(c):a.call(null,c))*(c-b)},h4),Prc=GQ(function(a,b,c){var d=a.j?a.j(b):a.call(null,b);a=a.j?a.j(c):a.call(null,c);return(d<a?d:a)*(c-b)},i4),Qrc=GQ(function(a,b,c){var d=a.j?a.j(b):a.call(null,b);a=a.j?a.j(c):a.call(null,c);return(d>a?d:a)*(c-b)},j4);$APP.Pi.A(KQ,function(a){return 4/(1+a*a)});$APP.Pi.A(KQ,function(a){return 4/(1+a*a)});var k4=function k4(a){switch(arguments.length){case 3:return k4.B(arguments[0],arguments[1],arguments[2]);case 4:return k4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};k4.B=function(a,b,c){return k4.K(a,b,c,new $APP.f(null,1,[$APP.tr,1],null))};
k4.K=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,$APP.tr,1);g=$APP.C.A(g,A8a);a=G8a(H8a(a,b,c),D8a(a,b,c),2,d);return $APP.k($APP.k(g)?"number"===typeof d:g)?IQ.K(a,2,2,2):a};k4.G=4;var Rrc=GQ(KQ,k4);var l4=function l4(a){switch(arguments.length){case 3:return l4.B(arguments[0],arguments[1],arguments[2]);case 4:return l4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};l4.B=function(a,b,c){return l4.K(a,b,c,new $APP.f(null,1,[$APP.tr,1],null))};l4.K=function(a,b,c,d){d=$APP.qe(d);d=$APP.C.B(d,$APP.tr,1);return c4.S(k4.K(a,b,c,d),2,2,2,2)};l4.G=4;var Src=GQ($APP.Jl.A($APP.u,l4),l4);var m4=function m4(a){switch(arguments.length){case 3:return m4.B(arguments[0],arguments[1],arguments[2]);case 4:return m4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};m4.B=function(a,b,c){return m4.K(a,b,c,new $APP.f(null,1,[$APP.tr,1],null))};
m4.K=function(a,b,c,d){var g=$APP.qe(d);d=$APP.C.B(g,$APP.tr,1);g=$APP.C.A(g,A8a);a=G8a(C8a(a,b,c),J8a(a,b,c),3,d);return $APP.k($APP.k(g)?"number"===typeof d:g)?IQ.K(a,3,2,2):a};m4.G=4;var Trc=GQ(I8a,m4);var L8a=$APP.Uj.A(JQ.A(2,2),JQ.A(2,3)),Urc=GQ(I8a,O8a(m4)),Vrc=GQ(KQ,O8a(k4));var n4=function n4(a){switch(arguments.length){case 3:return n4.B(arguments[0],arguments[1],arguments[2]);case 4:return n4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};n4.B=function(a,b,c){return n4.K(a,b,c,new $APP.f(null,1,[$APP.tr,1],null))};n4.K=function(a,b,c,d){d=$APP.qe(d);var g=$APP.C.B(d,$APP.tr,1);return c4.S(m4.K(a,b,c,$APP.rg.B(d,$APP.tr,JQ.A(2,g))),1,2,2,2)};n4.G=4;
var Wrc=GQ($APP.Jl.A($APP.u,n4),n4);var o4=function o4(a){switch(arguments.length){case 3:return o4.B(arguments[0],arguments[1],arguments[2]);case 4:return o4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};o4.B=function(a,b,c){return o4.K(a,b,c,$APP.F)};o4.K=function(a,b,c,d){d=$APP.qe(d);$APP.C.B(d,$APP.tr,1);return IQ.K(m4.K(a,b,c,d),3,2,2)};o4.G=4;
var p4=function p4(a){switch(arguments.length){case 3:return p4.B(arguments[0],arguments[1],arguments[2]);case 4:return p4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};p4.B=function(a,b,c){return p4.K(a,b,c,$APP.F)};p4.K=function(a,b,c,d){d=$APP.qe(d);$APP.C.B(d,$APP.tr,1);return IQ.K(k4.K(a,b,c,d),2,2,2)};p4.G=4;var Xrc=GQ(I8a,o4),Yrc=GQ(KQ,p4);var q4=function q4(a){switch(arguments.length){case 3:return q4.B(arguments[0],arguments[1],arguments[2]);case 4:return q4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};q4.B=function(a,b,c){return q4.K(a,b,c,new $APP.f(null,1,[$APP.tr,1],null))};q4.K=function(a,b,c,d){d=$APP.qe(d);d=$APP.C.B(d,$APP.tr,1);return c4.S(k4.K(a,b,c,d),1,2,2,2)};q4.G=4;var Zrc=GQ($APP.Jl.A($APP.u,q4),q4);var r4=function r4(a){switch(arguments.length){case 3:return r4.B(arguments[0],arguments[1],arguments[2]);case 4:return r4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};r4.B=function(a,b,c){return r4.K(a,b,c,new $APP.f(null,1,[$APP.tr,1],null))};r4.K=function(a,b,c,d){d=$APP.qe(d);d=$APP.C.B(d,$APP.tr,1);return c4.S(k4.K(a,b,c,new $APP.f(null,1,[$APP.tr,JQ.A(3,d)],null)),1,3,2,2)};r4.G=4;
var $rc=GQ($APP.Jl.A($APP.u,r4),r4);var asc=$APP.fg([TT,Ovb,O$b,tlb,shb,fac,pxb,qTb,Ltb,Spb,Alb,AVb,dcc,$4b,axb,Jmb,GJb,lX,wNb],[new $APP.f(null,2,[$APP.ny,lX,$APP.DQ,p8a],null),$rc,new $APP.f(null,2,[$APP.ny,lX,$APP.DQ,S8a],null),Rrc,Prc,new $APP.f(null,2,[$APP.ny,lX,$APP.DQ,T8a],null),Yrc,Zrc,Trc,Vrc,Xrc,Orc,Nrc,Src,new $APP.f(null,2,[$APP.ny,lX,$APP.DQ,R8a],null),Wrc,Urc,function(a,b){return function(){function c(l,n,p,v){v=$APP.Ni.C($APP.y([new $APP.f(null,3,[AHb,10,bUb,.05,$APP.DQ,p8a],null),v]));var t=new $APP.H(null,1,5,$APP.I,
[new $APP.H(null,3,5,$APP.I,[n,p,$APP.DQ.j(v)],null)],null);n=FI.call(null);for(p=0;;){if($APP.hd(t))return new $APP.f(null,3,[qQ,!0,rQ,p,pQ,FI.call(null,n)],null);var A=$APP.fd(t),B=$APP.x.B(A,0,null),G=$APP.x.B(A,1,null);A=$APP.x.B(A,2,null);t=$APP.gd(t);var J=B;var O=G;J=$APP.Uc.A(A,S8a)?b.K?b.K(l,J,O,v):b.call(null,l,J,O,v):a.K?a.K(l,J,O,v):a.call(null,l,J,O,v);O=$APP.qe(J);J=$APP.C.A(O,qQ);O=$APP.C.A(O,pQ);if($APP.k(J))B=t,n=FI.call(null,n,O),p+=1,t=B;else{J=B;var R=bUb.j(v);O=G-J;R=0===R?.5:
.5+R*($APP.du.j(2)-1);J+=R*O;B=$APP.Vd.C(t,new $APP.H(null,3,5,$APP.I,[J,G,m8a(A)],null),$APP.y([new $APP.H(null,3,5,$APP.I,[B,J,n8a(A)],null)]));p+=1;t=B}}}function d(l,n,p){return g.K(l,n,p,$APP.F)}var g=null;g=function(l,n,p,v){switch(arguments.length){case 3:return d.call(this,l,n,p);case 4:return c.call(this,l,n,p,v)}throw Error("Invalid arity: "+arguments.length);};g.B=d;g.K=c;return g}()}(Urc,Vrc),Qrc]),bsc=$APP.Lf.A($APP.vg,$APP.ng(asc)),s4=function s4(a){if($APP.cd(a))return new $APP.H(null,
2,5,$APP.I,[a,$APP.F],null);if(a instanceof $APP.E)return a=asc.j?asc.j(a):asc.call(null,a),s4.j?s4.j(a):s4.call(null,a);if($APP.md(a)){var c=$APP.ny.j(a);var d=s4.j?s4.j(c):s4.call(null,c);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return new $APP.H(null,2,5,$APP.I,[c,$APP.Ni.C($APP.y([$APP.Oi.A(a,$APP.ny),d]))],null)}return null},t4=function t4(a){switch(arguments.length){case 3:return t4.B(arguments[0],arguments[1],arguments[2]);case 4:return t4.K(arguments[0],arguments[1],arguments[2],arguments[3]);
default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};t4.B=function(a,b,c){return t4.K(a,b,c,$APP.F)};t4.K=function(a,b,c,d){var g=s4(a);return $APP.k(g)?(a=$APP.x.B(g,0,null),g=$APP.x.B(g,1,null),b=oG.j(b),c=$APP.k(b)?b:oG.j(c),new $APP.H(null,2,5,$APP.I,[$APP.k(c)?U8a(a):a,$APP.Oi.A($APP.Ni.C($APP.y([g,d])),$APP.ny)],null)):null};t4.G=4;
var u4=function u4(a){switch(arguments.length){case 3:return u4.B(arguments[0],arguments[1],arguments[2]);case 4:return u4.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};u4.B=function(a,b,c){return u4.K(a,b,c,$APP.F)};
u4.K=function(a,b,c,d){var g=$APP.qe(d),l=$APP.C.B(g,$APP.ny,TT),n=$APP.C.B(g,h9a,!1);d=$APP.C.B(g,Z6b,!1);g=t4.K(l,b,c,g);return $APP.k(g)?(l=$APP.x.B(g,0,null),g=$APP.x.B(g,1,null),a=$APP.k(n)?$APP.b4.A(a,1):$APP.Jl.A(vD,a),b=l.K?l.K(a,b,c,g):l.call(null,a,b,c,g),$APP.k(d)?b:pQ.j(b)):yD(["Unknown method: ",$APP.m.j(l),". Try one of: ",$APP.m.j(bsc)].join(""))};u4.G=4;var v4=function v4(a){switch(arguments.length){case 0:return v4.J();case 1:return v4.j(arguments[0]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};v4.J=function(){return $APP.M($APP.gv,$APP.M(k2a,PN,$APP.M(TN,PN),$APP.M(TN,PN)),PN)};
v4.j=function(a){return(a=$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.gv,$APP.r(new $APP.H(null,4,5,$APP.I,[k2a,PN,$APP.r(new $APP.H(null,3,5,$APP.I,[TN,PN,a],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[TN,PN,a],null))],null)),PN],null)))?a:fJ(a)};v4.G=1;var QQ=function QQ(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=3<c.length?new $APP.Bc(c.slice(3),0,null):null;return QQ.C(arguments[0],arguments[1],arguments[2],c)};
QQ.C=function(a,b,c,d){return $APP.Je.S(wL,a,b,c,d)};QQ.G=3;QQ.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};var TQ=function TQ(a){switch(arguments.length){case 1:return TQ.j(arguments[0]);case 2:return TQ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
TQ.j=function(a){var b=UO.j?UO.j(a):UO.call(null,a);return XH.A(function(c){return wL.C($APP.y([c,a.j?a.j(c):a.call(null,c),b.j?b.j(c):b.call(null,c)]))},new $APP.H(null,2,5,$APP.I,[hI,1],null))};TQ.A=function(a,b){a=$APP.We.A(b-1,$APP.af(UO,a));var c=$APP.Lf.A(wL.C($APP.y([$APP.Kd])),a);return XH.A(function(d){return c.j?c.j(d):c.call(null,d)},new $APP.H(null,2,5,$APP.I,[hI,1],null))};TQ.G=2;
var w4=function w4(a){switch(arguments.length){case 1:return w4.j(arguments[0]);case 2:return w4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};w4.j=function(a){return w4.A(a,null)};
w4.A=function(a,b){return function(c){var d=TQ.j(c);return TF.C(function(){var g=YH,l=g.C;var n=SQ.j?SQ.j(2):SQ.call(null,2);n=n.j?n.j(a):n.call(null,a);g=l.call(g,$APP.y([n,d]));return UO.j?UO.j(g):UO.call(null,g)}(),YH.C($APP.y([function(){var g=SQ.j?SQ.j(1):SQ.call(null,1);return g.j?g.j(a):g.call(null,a)}(),d])),$APP.y([$APP.k(b)?TF.j(YH.C($APP.y([function(){var g=SQ.j?SQ.j(2):SQ.call(null,2);return g.j?g.j(b):g.call(null,b)}(),d]))):0]))}};w4.G=2;
var x4=function x4(a){switch(arguments.length){case 1:return x4.j(arguments[0]);case 2:return x4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};x4.j=function(a){return x4.A(a,null)};
x4.A=function(a,b){var c=function(){var g=SQ.j?SQ.j(2):SQ.call(null,2);return g.j?g.j(a):g.call(null,a)}(),d=function(){var g=SQ.j?SQ.j(1):SQ.call(null,1);return g.j?g.j(a):g.call(null,a)}();return LSa(function(){var g=SQ.j?SQ.j(2):SQ.call(null,2);return g.j?g.j(c):g.call(null,c)}(),TF.C(d,$APP.k(b)?function(){var g=SQ.j?SQ.j(2):SQ.call(null,2);return g.j?g.j(b):g.call(null,b)}():0,$APP.y([mG.A(function(){var g=SQ.j?SQ.j(0):SQ.call(null,0);return g.j?g.j(c):g.call(null,c)}(),kG.A(function(){var g=
SQ.j?SQ.j(1):SQ.call(null,1);return g.j?g.j(c):g.call(null,c)}(),OQ))])))};x4.G=2;$APP.RQ=function RQ(a){switch(arguments.length){case 1:return RQ.j(arguments[0]);case 2:return RQ.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};$APP.RQ.j=function(a){return $APP.RQ.A(a,null)};$APP.RQ.A=function(a,b){var c=x4.A(a,b);return function(d){return wL.C($APP.y([1,OQ(d),c.j?c.j(d):c.call(null,d)]))}};$APP.RQ.G=2;
var UQ=function UQ(a){switch(arguments.length){case 4:return UQ.K(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return UQ.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};UQ.K=function(a,b,c,d){return UQ.S(a,b,c,d,$APP.F)};UQ.S=function(a,b,c,d,g){return u4.K(YH.C($APP.y([a,TQ.j(b)])),c,d,g)};UQ.G=5;
var y4=function y4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=6<c.length?new $APP.Bc(c.slice(6),0,null):null;return y4.C(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],c)};y4.C=function(a,b,c,d,g,l,n){n=$APP.qe(n);n=$APP.C.A(n,cab);l=e9a(c,g,l);a=a4.C(i9a(a,b,c,d,g),l,$APP.y([$APP.Xw,n]));return g9a(b,c,d,g,a)};y4.G=6;
y4.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);var g=$APP.w(d);d=$APP.u(g);var l=$APP.w(g);g=$APP.u(l);var n=$APP.w(l);l=$APP.u(n);n=$APP.w(n);return this.C(b,a,c,d,g,l,n)};var WQ=LK.A(k9a,Izb);var z4=LK.A(D9a,CCb),csc=LK.A(function(a){return function(b){function c(n){n=wL.C($APP.y([d,g,n]));return a.j?a.j(n):a.call(null,n)}var d=$APP.x.B(b,0,null),g=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var l=z4.j?z4.j(c):z4.call(null,c);return l.j?l.j(b):l.call(null,b)}},AMb),dsc=LK.A(function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=D9a(function(l){l=YQ(c,d,l);return a.j?a.j(l):a.call(null,l)});return g.j?g.j(b):g.call(null,b)}},p0b),bR=function bR(a,
b){return function(d){var g=a.j?a.j(d):a.call(null,d),l=b.j?b.j(d):b.call(null,d);if(XK(g)||XK(l))return mL.C(function(n){return mL.C(function(p){var v=$APP.Jl.A($APP.Je.A(tP,n),a);p=$APP.Jl.A($APP.Je.A(tP,p),b);v=bR.A?bR.A(v,p):bR.call(null,v,p);return v.j?v.j(d):v.call(null,d)},$APP.y([lL(l)]))},$APP.y([lL(g)]));g=TF.A(kG.A(function(){var n=SQ.j?SQ.j(1):SQ.call(null,1);return n.j?n.j(a):n.call(null,a)}(),function(){var n=SQ.j?SQ.j(2):SQ.call(null,2);return n.j?n.j(b):n.call(null,b)}()),kG.A(function(){var n=
SQ.j?SQ.j(2):SQ.call(null,2);return n.j?n.j(a):n.call(null,a)}(),function(){var n=SQ.j?SQ.j(1):SQ.call(null,1);return n.j?n.j(b):n.call(null,b)}()));return g.j?g.j(d):g.call(null,d)}};dR.F(null,new $APP.H(null,1,5,$APP.I,[VH],null),function(a){return E9a(a)});$APP.e=hR.prototype;$APP.e.Hc=$APP.xc;$APP.e.Ac=function(a,b){return this.Va(null,b)?new $APP.Cd(b,this.eb(null,b,null),null):null};$APP.e.toString=function(){return["#emmy/quaternion [",$APP.m.j(this.r)," ",$APP.m.j(this.i)," ",$APP.m.j(this.Ma)," ",$APP.m.j(this.k),"]"].join("")};$APP.e.Ka=function(a,b){return this.fa(null,b,null)};$APP.e.fa=function(a,b,c){return"number"===typeof b?this.eb(null,b,c):c};
$APP.e.lb=function(a,b,c){a=b.B?b.B(c,this.r,0):b.call(null,c,this.r,0);c=this.i;a=b.B?b.B(a,c,1):b.call(null,a,c,1);c=this.Ma;a=b.B?b.B(a,c,2):b.call(null,a,c,2);c=this.k;return b.B?b.B(a,c,3):b.call(null,a,c,3)};$APP.e.aa=function(a,b){return this.eb(null,b,null)};$APP.e.eb=function(a,b,c){switch(b){case 0:return this.r;case 1:return this.i;case 2:return this.Ma;case 3:return this.k;default:return c}};$APP.e.ea=function(a,b){return $APP.Sg(b,$APP.y([this.toString()]))};
$APP.e.Qa=function(){return $APP.eca($APP.tf(this),0,4)};$APP.e.ba=function(){return this.ca};$APP.e.ta=function(){return 4};$APP.e.Ic=function(){return new $APP.D(null,this.k,new $APP.D(null,this.Ma,new $APP.D(null,this.i,new $APP.D(null,this.r,null,1,null),2,null),3,null),4,null)};$APP.e.Y=function(a,b){return lR.A?lR.A(this,b):lR.call(null,this,b)};$APP.e.Sa=function(){return new hR(0,0,0,0,this.ca)};
$APP.e.fb=function(a,b){a=b.A?b.A(this.r,this.i):b.call(null,this.r,this.i);var c=this.Ma;a=b.A?b.A(a,c):b.call(null,a,c);c=this.k;return b.A?b.A(a,c):b.call(null,a,c)};$APP.e.bb=function(a,b,c){a=b.A?b.A(c,this.r):b.call(null,c,this.r);c=this.i;a=b.A?b.A(a,c):b.call(null,a,c);c=this.Ma;a=b.A?b.A(a,c):b.call(null,a,c);c=this.k;return b.A?b.A(a,c):b.call(null,a,c)};$APP.e.rb=function(){return LU};$APP.e.bc=function(){return g$a.j?g$a.j(this):g$a.call(null,this)};
$APP.e.sa=function(a,b,c){switch(b){case 0:return new hR(c,this.i,this.Ma,this.k,this.ca);case 1:return new hR(this.r,c,this.Ma,this.k,this.ca);case 2:return new hR(this.r,this.i,c,this.k,this.ca);case 3:return new hR(this.r,this.i,this.Ma,c,this.ca);default:throw Error("Quaternion's key for assoc must be 0, 1, 2 or 3.");}};$APP.e.Va=function(a,b){a=new $APP.ug(null,new $APP.f(null,4,[0,null,1,null,3,null,2,null],null),null);b=a.j?a.j(b):a.call(null,b);return $APP.vd(b)};
$APP.e.ma=function(){return new $APP.D(null,this.r,new $APP.D(null,this.i,new $APP.D(null,this.Ma,new $APP.D(null,this.k,null,1,null),2,null),3,null),4,null)};$APP.e.da=function(a,b){return new hR(this.r,this.i,this.Ma,this.k,b)};$APP.e.ua=function(){throw Error("conj not suported on Quaternion instances. convert to vector first!");};
$APP.e.call=function(a){switch(arguments.length-1){case 0:return this.J();case 1:return this.j(arguments[1]);case 2:return this.A(arguments[1],arguments[2]);case 3:return this.B(arguments[1],arguments[2],arguments[3]);case 4:return this.K(arguments[1],arguments[2],arguments[3],arguments[4]);case 5:return this.S(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);case 6:return this.la(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]);case 7:return this.Ga(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);case 8:return this.va(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8]);case 9:return this.Ha(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9]);case 10:return this.wa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10]);
case 11:return this.xa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);case 12:return this.ya(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12]);case 13:return this.za(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],
arguments[11],arguments[12],arguments[13]);case 14:return this.Aa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14]);case 15:return this.Ba(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15]);case 16:return this.Ca(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16]);case 17:return this.Da(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17]);case 18:return this.Ea(arguments[1],arguments[2],
arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18]);case 19:return this.Fa(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19]);case 20:return this.La(arguments[1],
arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],arguments[18],arguments[19],arguments[20]);case 21:return this.Kb(arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15],arguments[16],arguments[17],
arguments[18],arguments[19],arguments[20],arguments[21]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length-1)].join(""));}};$APP.e.apply=function(a,b){return this.call.apply(this,[this].concat($APP.kb(b)))};$APP.e.J=function(){return nR.A?nR.A(this,$APP.sf):nR.call(null,this,$APP.sf)};$APP.e.j=function(a){a=new $APP.H(null,1,5,$APP.I,[a],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};
$APP.e.A=function(a,b){a=new $APP.H(null,2,5,$APP.I,[a,b],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.B=function(a,b,c){a=new $APP.H(null,3,5,$APP.I,[a,b,c],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.K=function(a,b,c,d){a=new $APP.H(null,4,5,$APP.I,[a,b,c,d],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.S=function(a,b,c,d,g){a=new $APP.H(null,5,5,$APP.I,[a,b,c,d,g],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};
$APP.e.la=function(a,b,c,d,g,l){a=new $APP.H(null,6,5,$APP.I,[a,b,c,d,g,l],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.Ga=function(a,b,c,d,g,l,n){a=new $APP.H(null,7,5,$APP.I,[a,b,c,d,g,l,n],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.va=function(a,b,c,d,g,l,n,p){a=new $APP.H(null,8,5,$APP.I,[a,b,c,d,g,l,n,p],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};
$APP.e.Ha=function(a,b,c,d,g,l,n,p,v){a=new $APP.H(null,9,5,$APP.I,[a,b,c,d,g,l,n,p,v],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.wa=function(a,b,c,d,g,l,n,p,v,t){a=new $APP.H(null,10,5,$APP.I,[a,b,c,d,g,l,n,p,v,t],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.xa=function(a,b,c,d,g,l,n,p,v,t,A){a=new $APP.H(null,11,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};
$APP.e.ya=function(a,b,c,d,g,l,n,p,v,t,A,B){a=new $APP.H(null,12,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.za=function(a,b,c,d,g,l,n,p,v,t,A,B,G){a=new $APP.H(null,13,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.Aa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J){a=new $APP.H(null,14,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};
$APP.e.Ba=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O){a=new $APP.H(null,15,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.Ca=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R){a=new $APP.H(null,16,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};
$APP.e.Da=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W){a=new $APP.H(null,17,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.Ea=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z){a=new $APP.H(null,18,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};
$APP.e.Fa=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa){a=new $APP.H(null,19,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.La=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia){a=new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null);return nR.A?nR.A(this,a):nR.call(null,this,a)};
$APP.e.Kb=function(a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia,ja){a=$APP.Lf.A(new $APP.H(null,20,5,$APP.I,[a,b,c,d,g,l,n,p,v,t,A,B,G,J,O,R,W,Z,fa,ia],null),ja);return nR.A?nR.A(this,a):nR.call(null,this,a)};$APP.e.ac=function(a,b,c){return new hR(HH(this.r,b,c),HH(this.i,b,c),HH(this.Ma,b,c),HH(this.k,b,c),this.ca)};$APP.e.$b=function(a,b,c){return new hR(IH(this.r,b,c),IH(this.i,b,c),IH(this.Ma,b,c),IH(this.k,b,c),this.ca)};
$APP.e.ic=function(a,b){return new hR(JH(this.r,b),JH(this.i,b),JH(this.Ma,b),JH(this.k,b),this.ca)};var A4=function A4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return A4.C(arguments[0],c)};A4.C=function(a,b){b=$APP.qe(b);b=$APP.C.A(b,$APP.LR);a=rR.j?rR.j(a):rR.call(null,a);return $APP.k(b)?KF(b)(1,lG.j(a)):uG.j(a)};A4.G=1;A4.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var B4=iR(0,0,0,0,null),esc=iR(1,0,0,0,null),fsc=iR(0,1,0,0,null),gsc=iR(0,0,1,0,null),hsc=iR(0,0,0,1,null),mR=function mR(a){switch(arguments.length){case 1:return mR.j(arguments[0]);case 2:return mR.A(arguments[0],arguments[1]);case 4:return mR.K(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};mR.j=function(a){return a$a(a)?a:$APP.kd(a)?$APP.Je.A(mR,$APP.We.A(4,a)):xG(a)?iR(a.ha,a.ia,0,0,null):iR(a,0,0,0,null)};
mR.A=function(a,b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return iR(a,c,d,b,null)};mR.K=function(a,b,c,d){return iR(a,b,c,d,null)};mR.G=4;var xR=function xR(a){switch(arguments.length){case 0:return xR.J();case 1:return xR.j(arguments[0]);case 2:return xR.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return xR.C(arguments[0],arguments[1],c)}};xR.J=function(){return B4};
xR.j=function(a){return a};xR.A=function(a,b){return mR.K(gH.A(a.r,b.r),gH.A(a.i,b.i),gH.A(a.Ma,b.Ma),gH.A(a.k,b.k))};xR.C=function(a,b,c){return $APP.Id.B(xR,xR.A(a,b),c)};xR.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};xR.G=2;
var yR=function yR(a){switch(arguments.length){case 0:return yR.J();case 1:return yR.j(arguments[0]);case 2:return yR.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return yR.C(arguments[0],arguments[1],c)}};yR.J=function(){return B4};yR.j=function(a){return pR(a)};yR.A=function(a,b){return mR.K(AG.A(a.r,b.r),AG.A(a.i,b.i),AG.A(a.Ma,b.Ma),AG.A(a.k,b.k))};
yR.C=function(a,b,c){return yR.A(a,$APP.Je.B(xR,b,c))};yR.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};yR.G=2;var zR=function zR(a){switch(arguments.length){case 0:return zR.J();case 1:return zR.j(arguments[0]);case 2:return zR.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return zR.C(arguments[0],arguments[1],c)}};zR.J=function(){return esc};zR.j=function(a){return a};
zR.A=function(a,b){var c=a.r,d=a.i,g=a.Ma;a=a.k;var l=b.r,n=b.i,p=b.Ma;b=b.k;return mR.K(TF.A(kG.A(c,l),mG.C(kG.A(d,n),kG.A(g,p),$APP.y([kG.A(a,b)]))),mG.C(kG.A(c,n),kG.A(d,l),$APP.y([kG.A(g,b),kG.C(-1,a,$APP.y([p]))])),mG.C(kG.A(c,p),kG.C(-1,d,$APP.y([b])),$APP.y([kG.A(g,l),kG.A(a,n)])),mG.C(kG.A(c,b),kG.A(d,p),$APP.y([kG.C(-1,g,$APP.y([n])),kG.A(a,l)])))};zR.C=function(a,b,c){return $APP.Id.B(zR,zR.A(a,b),c)};
zR.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};zR.G=2;var wR=function wR(a){switch(arguments.length){case 0:return wR.J();case 1:return wR.j(arguments[0]);case 2:return wR.A(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(2),0,null);return wR.C(arguments[0],arguments[1],c)}};wR.J=function(){return esc};wR.j=function(a){return n$a(a)};
wR.A=function(a,b){return zR.A(a,n$a(b))};wR.C=function(a,b,c){return wR.A(a,$APP.Je.B(zR,b,c))};wR.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};wR.G=2;
var isc=EN.C($APP.y([new $APP.H(null,4,5,$APP.I,[1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,1,0,0],null),new $APP.H(null,4,5,$APP.I,[0,0,1,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,1],null)])),C4=EN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,1,0,0],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,-1],null),new $APP.H(null,4,5,$APP.I,[0,0,1,0],null)])),D4=EN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,0,1,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,1],null),new $APP.H(null,
4,5,$APP.I,[-1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,-1,0,0],null)])),E4=EN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,0,0,1],null),new $APP.H(null,4,5,$APP.I,[0,0,-1,0],null),new $APP.H(null,4,5,$APP.I,[0,1,0,0],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null)])),jsc=zN.j(isc),ksc=zN.j(C4),lsc=zN.j(D4),msc=zN.j(E4),F4=SF.A(1,4);MF.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return e$a(a)});uG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return f$a(a)});
kZ.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return f$a(a)});vG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return new hR(vG.j(a.r),0,0,0,a.ca)});PF.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return new hR(PF.j(a.r),0,0,0,a.ca)});lZ.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return new hR(PF.j(a.r),0,0,0,a.ca)});
VF.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){var b=VF.j(a.r);return $APP.k(b)?(b=VF.j(a.i),$APP.k(b)?(b=VF.j(a.Ma),$APP.k(b)?VF.j(a.k):b):b):b});cG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return new $APP.D(null,D0b,new $APP.D(null,cG.j(a.r),new $APP.D(null,cG.j(a.i),new $APP.D(null,cG.j(a.Ma),new $APP.D(null,cG.j(a.k),null,1,null),2,null),3,null),4,null),5,null)});hG.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return lR(a,b)});
hG.F(null,new $APP.H(null,2,5,$APP.I,[$R,LU],null),function(a,b){return lR(b,a)});hG.F(null,new $APP.H(null,2,5,$APP.I,[LU,$R],null),function(a,b){return lR(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){return lR(b,a)});hG.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return lR(a,b)});hG.F(null,new $APP.H(null,2,5,$APP.I,[FG,LU],null),function(a,b){return lR(b,a)});hG.F(null,new $APP.H(null,2,5,$APP.I,[LU,FG],null),function(a,b){return lR(a,b)});
dG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return iR(dG.j(a.r),dG.j(a.i),dG.j(a.Ma),dG.j(a.k),$APP.ed(a))});gH.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return xR.A(a,b)});gH.F(null,new $APP.H(null,2,5,$APP.I,[HF,LU],null),function(a,b){return mR.K(gH.A(a,b.r),b.i,b.Ma,b.k)});gH.F(null,new $APP.H(null,2,5,$APP.I,[LU,HF],null),function(a,b){return mR.K(gH.A(a.r,b),a.i,a.Ma,a.k)});
gH.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){return xR.A(mR.j(a),b)});gH.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return xR.A(a,mR.j(b))});RF.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return pR(a)});AG.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return yR.A(a,b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[HF,LU],null),function(a,b){return mR.K(AG.A(a,b.r),RF.j(b.i),RF.j(b.Ma),RF.j(b.k))});
AG.F(null,new $APP.H(null,2,5,$APP.I,[LU,HF],null),function(a,b){return mR.K(AG.A(a.r,b),a.i,a.Ma,a.k)});AG.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){return yR.A(mR.j(a),b)});AG.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return yR.A(a,mR.j(b))});OF.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return zR.A(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[HF,LU],null),function(a,b){return i$a(a,b)});
OF.F(null,new $APP.H(null,2,5,$APP.I,[LU,HF],null),function(a,b){return j$a(a,b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){return zR.A(mR.j(a),b)});OF.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return zR.A(a,mR.j(b))});tI.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return v$a(a,b)});tI.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return v$a(a,mR.j(b))});
tI.F(null,new $APP.H(null,2,5,$APP.I,[LU,FG],null),function(a,b){return v$a(a,b)});QF.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return n$a(a)});BG.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return wR.A(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[HF,LU],null),function(a,b){return i$a(a,QF.j(b))});BG.F(null,new $APP.H(null,2,5,$APP.I,[LU,HF],null),function(a,b){return qR(a,b)});BG.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){return wR.A(mR.j(a),b)});
BG.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return wR.A(a,mR.j(b))});lG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return w$a(a)});rG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return o$a(a)});qG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return uR(a)});iO.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return q$a(a)});hO.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return p$a(a)});
vZ.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return r$a(a)});vH.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return s$a(a)});xH.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return t$a(a)});DZ.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return u$a(a)});oG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){var b=oG.j(a.r);if($APP.k(b))return b;b=oG.j(a.i);if($APP.k(b))return b;b=oG.j(a.Ma);return $APP.k(b)?b:oG.j(a.k)});
jG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return sR(a)});zG.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return sR(a)});sL.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return k$a(a)});zH.F(null,new $APP.H(null,1,5,$APP.I,[LU],null),function(a){return a.r});oR.F(null,new $APP.H(null,2,5,$APP.I,[LU,$R],null),function(a,b){return h$a(a,b)});VZ.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return m$a(a,b)});
VZ.F(null,new $APP.H(null,2,5,$APP.I,[LU,HF],null),function(){return B4});VZ.F(null,new $APP.H(null,2,5,$APP.I,[HF,LU],null),function(){return B4});VZ.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){b=b.ia;return mR.K(0,0,kG.A(a.k,b),TF.j(kG.A(a.Ma,b)))});VZ.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){a=a.ia;return mR.K(0,0,TF.j(kG.A(a,b.k)),kG.A(a,b.Ma))});DH.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return l$a(a,b)});
DH.F(null,new $APP.H(null,2,5,$APP.I,[HF,LU],null),function(a,b){return kG.A(a,b.r)});DH.F(null,new $APP.H(null,2,5,$APP.I,[LU,HF],null),function(a,b){return kG.A(a.r,b)});DH.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){return mG.A(kG.A(a.ha,b.r),kG.A(a.ia,b.i))});DH.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return mG.A(kG.A(a.r,b.ha),kG.A(a.i,b.ia))});eR.F(null,new $APP.H(null,2,5,$APP.I,[LU,HF],null),function(a,b){return qR(a,b)});
eR.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return wR.A(a,b)});eR.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){return wR.A(mR.j(a),b)});eR.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return wR.A(a,mR.j(b))});XF.F(null,new $APP.H(null,2,5,$APP.I,[HF,LU],null),function(a,b){return qR(b,a)});XF.F(null,new $APP.H(null,2,5,$APP.I,[LU,LU],null),function(a,b){return wR.A(b,a)});
XF.F(null,new $APP.H(null,2,5,$APP.I,[hT,LU],null),function(a,b){return wR.A(b,mR.j(a))});XF.F(null,new $APP.H(null,2,5,$APP.I,[LU,hT],null),function(a,b){return wR.A(mR.j(b),a)});var nsc=EN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,1,0,0],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,1],null),new $APP.H(null,4,5,$APP.I,[0,0,-1,0],null)])),osc=EN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,0,1,0],null),new $APP.H(null,4,5,$APP.I,[0,0,0,-1],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null),new $APP.H(null,4,5,$APP.I,[0,1,0,0],null)])),psc=EN.C($APP.y([new $APP.H(null,4,5,$APP.I,[0,0,0,1],null),new $APP.H(null,4,5,$APP.I,[0,0,1,0],null),new $APP.H(null,
4,5,$APP.I,[0,-1,0,0],null),new $APP.H(null,4,5,$APP.I,[-1,0,0,0],null)]));var G4=function G4(a){switch(arguments.length){case 1:return G4.j(arguments[0]);case 2:return G4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
G4.j=function(a){return function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);var c=$APP.x.B(b,2,null);c=$APP.x.B(c,0,null);var d=function(){var p=SQ.A?SQ.A(2,0):SQ.call(null,2,0);return p.j?p.j(a):p.call(null,a)}(),g=function(){var p=SQ.A?SQ.A(1,0):SQ.call(null,1,0);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}(),l=function(){var p=SQ.A?SQ.A(2,1):SQ.call(null,2,1);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}(),n=function(){var p=kG.A;var v=SQ.A?SQ.A(1,1):SQ.call(null,
1,1);v=v.j?v.j(a):v.call(null,a);p=p.call(kG,-1,v);return p.j?p.j(b):p.call(null,b)}();return kG.A(LN.B(c,function(){var p=SQ.A?SQ.A(2,0):SQ.call(null,2,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),c),TF.A(g,mG.C(function(){var p=SQ.j?SQ.j(0):SQ.call(null,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),kG.A(function(){var p=SQ.A?SQ.A(1,0):SQ.call(null,1,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),c),$APP.y([kG.A(function(){var p=SQ.A?
SQ.A(1,1):SQ.call(null,1,1);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),l),kG.A(function(){var p=SQ.A?SQ.A(2,1):SQ.call(null,2,1);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),n)]))))}};
G4.A=function(a,b){return function(c){var d=$APP.x.B(c,0,null),g=$APP.x.B(c,1,null),l=$APP.x.B(c,2,null);l=$APP.x.B(l,0,null);var n=function(){var A=SQ.A?SQ.A(2,0):SQ.call(null,2,0);return A.j?A.j(a):A.call(null,a)}(),p=function(){var A=SQ.A?SQ.A(1,0):SQ.call(null,1,0);A=A.j?A.j(a):A.call(null,a);return A.j?A.j(c):A.call(null,c)}(),v=function(){var A=SQ.A?SQ.A(2,1):SQ.call(null,2,1);A=A.j?A.j(a):A.call(null,a);return A.j?A.j(c):A.call(null,c)}(),t=wL.C($APP.y([d,g,wL.C($APP.y([l,v]))]));d=function(){var A=
SQ.A?SQ.A(2,0):SQ.call(null,2,0);A=A.j?A.j(b):A.call(null,b);return A.j?A.j(t):A.call(null,t)}();g=function(){var A=SQ.A?SQ.A(2,1):SQ.call(null,2,1);A=A.j?A.j(b):A.call(null,b);return A.j?A.j(t):A.call(null,t)}();g=TF.A(function(){var A=kG.A;var B=SQ.A?SQ.A(1,1):SQ.call(null,1,1);B=B.j?B.j(a):B.call(null,a);A=A.call(kG,-1,B);return A.j?A.j(c):A.call(null,c)}(),g);return kG.A(LN.B(l,function(){var A=SQ.A?SQ.A(2,0):SQ.call(null,2,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),l),
mG.A(TF.A(p,mG.C(function(){var A=SQ.j?SQ.j(0):SQ.call(null,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),kG.A(function(){var A=SQ.A?SQ.A(1,0):SQ.call(null,1,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),l),$APP.y([kG.A(function(){var A=SQ.A?SQ.A(1,1):SQ.call(null,1,1);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),v),kG.A(function(){var A=SQ.A?SQ.A(2,1):SQ.call(null,2,1);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),g)]))),
d))}};G4.G=2;$APP.H4=function H4(a){switch(arguments.length){case 1:return H4.j(arguments[0]);case 2:return H4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};
$APP.H4.j=function(a){return function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);var c=$APP.x.B(b,2,null);c=$APP.x.B(c,0,null);var d=function(){var p=SQ.A?SQ.A(2,0):SQ.call(null,2,0);return p.j?p.j(a):p.call(null,a)}(),g=function(){var p=SQ.A?SQ.A(1,0):SQ.call(null,1,0);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}(),l=function(){var p=SQ.A?SQ.A(2,1):SQ.call(null,2,1);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}(),n=TF.j(function(){var p=SQ.A?SQ.A(1,1):SQ.call(null,
1,1);p=p.j?p.j(a):p.call(null,a);return p.j?p.j(b):p.call(null,b)}());return wL.C($APP.y([1,wL.C($APP.y([c,l])),wL.C($APP.y([kG.A(LN.B(c,function(){var p=SQ.A?SQ.A(2,0):SQ.call(null,2,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),c),TF.A(g,mG.C(function(){var p=SQ.j?SQ.j(0):SQ.call(null,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),kG.A(function(){var p=SQ.A?SQ.A(1,0):SQ.call(null,1,0);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),c),$APP.y([kG.A(function(){var p=
SQ.A?SQ.A(1,1):SQ.call(null,1,1);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),l),kG.A(function(){var p=SQ.A?SQ.A(2,1):SQ.call(null,2,1);p=p.j?p.j(d):p.call(null,d);return p.j?p.j(b):p.call(null,b)}(),n)])))),n]))]))}};
$APP.H4.A=function(a,b){return function(c){var d=$APP.x.B(c,0,null),g=$APP.x.B(c,1,null),l=$APP.x.B(c,2,null);l=$APP.x.B(l,0,null);var n=function(){var A=SQ.A?SQ.A(2,0):SQ.call(null,2,0);return A.j?A.j(a):A.call(null,a)}(),p=function(){var A=SQ.A?SQ.A(1,0):SQ.call(null,1,0);A=A.j?A.j(a):A.call(null,a);return A.j?A.j(c):A.call(null,c)}(),v=function(){var A=SQ.A?SQ.A(2,1):SQ.call(null,2,1);A=A.j?A.j(a):A.call(null,a);return A.j?A.j(c):A.call(null,c)}(),t=wL.C($APP.y([d,g,wL.C($APP.y([l,v]))]));d=function(){var A=
SQ.A?SQ.A(2,0):SQ.call(null,2,0);A=A.j?A.j(b):A.call(null,b);return A.j?A.j(t):A.call(null,t)}();g=function(){var A=SQ.A?SQ.A(2,1):SQ.call(null,2,1);A=A.j?A.j(b):A.call(null,b);return A.j?A.j(t):A.call(null,t)}();g=TF.A(function(){var A=kG.A;var B=SQ.A?SQ.A(1,1):SQ.call(null,1,1);B=B.j?B.j(a):B.call(null,a);A=A.call(kG,-1,B);return A.j?A.j(c):A.call(null,c)}(),g);return wL.C($APP.y([1,wL.C($APP.y([l,v])),wL.C($APP.y([kG.A(LN.B(l,function(){var A=SQ.A?SQ.A(2,0):SQ.call(null,2,0);A=A.j?A.j(n):A.call(null,
n);return A.j?A.j(c):A.call(null,c)}(),l),mG.A(TF.A(p,mG.C(function(){var A=SQ.j?SQ.j(0):SQ.call(null,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),kG.A(function(){var A=SQ.A?SQ.A(1,0):SQ.call(null,1,0);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),l),$APP.y([kG.A(function(){var A=SQ.A?SQ.A(1,1):SQ.call(null,1,1);A=A.j?A.j(n):A.call(null,n);return A.j?A.j(c):A.call(null,c)}(),v),kG.A(function(){var A=SQ.A?SQ.A(2,1):SQ.call(null,2,1);A=A.j?A.j(n):A.call(null,
n);return A.j?A.j(c):A.call(null,c)}(),g)]))),d)),g]))]))}};$APP.H4.G=2;var FR=function FR(a){switch(arguments.length){case 2:return FR.A(arguments[0],arguments[1]);case 3:return FR.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};FR.A=function(a,b){return FR.B(a,b,a.j?a.j(b):a.call(null,b))};FR.B=function(a,b,c){return function(d){var g=b+d;return((a.j?a.j(g):a.call(null,g))-c)/d}};FR.G=3;
var HR=function HR(a){switch(arguments.length){case 2:return HR.A(arguments[0],arguments[1]);case 3:return HR.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};HR.A=function(a,b){return HR.B(a,b,a.j?a.j(b):a.call(null,b))};HR.B=function(a,b,c){return function(d){var g=b-d;g=a.j?a.j(g):a.call(null,g);return(c-g)/d}};HR.G=3;
var IR=function IR(a){switch(arguments.length){case 2:return IR.A(arguments[0],arguments[1]);case 3:return IR.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};IR.A=function(a,b){return IR.B(a,b,a.j?a.j(b):a.call(null,b))};IR.B=function(a,b,c){var d=2*c;return function(g){return(function(){var l=b+g;return a.j?a.j(l):a.call(null,l)}()+function(){var l=b-g;return a.j?a.j(l):a.call(null,l)}()-d)/(g*g)}};IR.G=3;
var L$a=new $APP.ug(null,new $APP.f(null,4,[O$a,null,zkb,null,Xrb,null,Qcb,null],null),null),I4=function I4(a){switch(arguments.length){case 1:return I4.j(arguments[0]);case 2:return I4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};I4.j=function(a){return I4.A(a,$APP.F)};
I4.A=function(a,b){var c=P$a(b);return function(){function d(n,p){p=$APP.Ni.C($APP.y([c,p]));var v=$APP.qe(p),t=$APP.C.A(v,AHb),A=$APP.C.A(v,N$a),B=$APP.C.A(v,r3b),G=$APP.C.A(v,$APP.ny);p=$APP.C.A(v,Z6b);G=M$a(G,a,n,a.j?a.j(n):a.call(null,n));var J=$APP.qe(G),O=$APP.C.A(J,GR),R=$APP.C.A(J,ER);G=$APP.C.A(J,YG);J=$APP.C.A(J,DR);n=$APP.k(B)?B:.1*jG.j(n);$APP.k(t)?A=t:(t=O.j?O.j(n):O.call(null,n),A=Math.floor(Math.log(A/(OR*(Math.floor(Math.abs(t))+1)))/Math.log(2))+1);n=$APP.Vg.A(R,X2.A(2,n));v=FQ.A(IQ.K(n,
2,G,J),$APP.rg.B(v,AHb,A));return $APP.k(p)?v:pQ.j(v)}function g(n){return l.A(n,$APP.F)}var l=null;l=function(n,p){switch(arguments.length){case 1:return g.call(this,n);case 2:return d.call(this,n,p)}throw Error("Invalid arity: "+arguments.length);};l.j=g;l.A=d;return l}()};I4.G=2;$APP.$$a=$APP.Xr(2);var U$a={},V$a={},KR;var dab=KF(1E-8),J4=function J4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return J4.C(arguments[0],c)};
J4.C=function(a,b){var c=eab(a,b);return function(){function d(n,p,v){return c(n,0,p,v)}function g(n,p){return l.B(n,p,$APP.F)}var l=null;l=function(n,p,v){switch(arguments.length){case 2:return g.call(this,n,p);case 3:return d.call(this,n,p,v)}throw Error("Invalid arity: "+arguments.length);};l.A=g;l.B=d;return l}()};J4.G=1;J4.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
var K4=function K4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return K4.C(arguments[0],c)};K4.C=function(a,b){return eab(a,b)};K4.G=1;K4.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var L4=function L4(a){switch(arguments.length){case 1:return L4.j(arguments[0]);case 2:return L4.A(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};L4.j=function(a){return L4.A(Math.PI/2,a)};L4.A=function(a,b){var c=Math.sin(a);a=Math.cos(a);a*=a;b*=c;var d=(1-b)*(1+b);return c*(NR(a,d,1)-b*b*(gab(a,d,1)/3))};L4.G=2;
var M4=function M4(a){switch(arguments.length){case 2:return M4.A(arguments[0],arguments[1]);case 3:return M4.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};M4.A=function(a,b){return M4.B(Math.PI/2,a,b)};M4.B=function(a,b,c){var d=Math.sin(a);a=Math.cos(a);b=b*d*d;a*=a;c*=d;c=(1-c)*(1+c);return d*(NR(a,c,1)+b*(iab(a,c,1,1-b)/3))};M4.G=3;
var N4=function N4(a){switch(arguments.length){case 2:return N4.A(arguments[0],arguments[1]);case 3:return N4.B(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};N4.A=function(a,b){return N4.B(a,b,$APP.ps)};
N4.B=function(a,b,c){b=1-b*b;if($APP.Uc.A(b,0)){var d=1/Math.cosh(a);a=Math.tanh(a);var g=b=d;return c.B?c.B(a,b,g):c.call(null,a,b,g)}b=lab(b,a);a=$APP.x.B(b,0,null);var l=$APP.x.B(b,1,null);g=$APP.x.B(b,2,null);b=$APP.x.B(b,3,null);for(var n=1,p=l,v=1,t=$APP.sf,A=$APP.sf;;){var B=Math.sqrt(p),G=.5*(n+B);if(Math.abs(n-B)>JR*n&&13>v){p=G;var J=n*B;v+=1;l=$APP.Yd(n,t);B=$APP.Yd(B,A);n=p;p=J;t=l;A=B}else{g*=G;var O=Math.sin(g);d=Math.cos(g);v=$APP.Uc.A(O,0)?new $APP.H(null,4,5,$APP.I,[n,O,d,1],null):
function(){for(var R=t,W=A,Z=d/O,fa=Z*G,ia=1;;)if($APP.r(R)&&$APP.r(W)){var ja=$APP.u(R),ta=function(){var Y=fa*Z,ea=ia*fa;Y=($APP.u(W)+Y)/(Y+ja);return new $APP.H(null,3,5,$APP.I,[ea/ja,ea,Y],null)}(),ua=$APP.x.B(ta,0,null),ca=$APP.x.B(ta,1,null),V=$APP.x.B(ta,2,null);R=$APP.Fc(R);W=ta=$APP.Fc(W);Z=ua;fa=ca;ia=V}else{var da=1/Math.sqrt(1+fa*fa);ta=function(){var Y=0>O?-da:da;return new $APP.H(null,2,5,$APP.I,[Y,fa*Y],null)}();R=$APP.x.B(ta,0,null);ta=$APP.x.B(ta,1,null);return new $APP.H(null,4,
5,$APP.I,[Z,R,ta,ia],null)}}();n=$APP.x.B(v,0,null);l=$APP.x.B(v,1,null);g=$APP.x.B(v,2,null);v=$APP.x.B(v,3,null);return $APP.k(a)?(a=l/b,b=n,c.B?c.B(a,b,g):c.call(null,a,b,g)):c.B?c.B(l,g,v):c.call(null,l,g,v)}}};N4.G=3;var uab=I2a(function(a,b,c){b=$APP.qe(c);var d=$APP.C.A(b,vab),g=$APP.C.A(b,wab),l=$APP.C.A(b,TR);return function(n){return GO(a)(SR(a,mG.A(pab(d,g)(n),l)))}},function(a,b,c){c=$APP.qe(c);var d=$APP.C.A(c,vab),g=$APP.C.A(c,wab),l=$APP.C.A(c,TR);return function(n){n=pab(TF.j(d),g)(TF.A(FO(a)(n),l));return SR(b,n)}}),qsc=I2a(yab,zab),rsc=qsc(xTb,xTb);var O4=function O4(a){switch(arguments.length){case 3:return O4.B(arguments[0],arguments[1],arguments[2]);case 4:return O4.K(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return O4.S(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",$APP.m.j(arguments.length)].join(""));}};O4.B=function(a,b,c){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,WN,null,1,null),new $APP.D(null,c,null,1,null))))};
O4.K=function(a,b,c,d){$APP.rg.B(b,BX,!0);return $APP.Td(d)&&$APP.Uc.A($APP.gv,$APP.u(d))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,WN,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,d,null,1,null)))),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,WN,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)]))))};
O4.S=function(a,b,c,d,g){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,WN,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null),new $APP.D(null,g,null,1,null)]))))};O4.G=5;var P4=function P4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=2<c.length?new $APP.Bc(c.slice(2),0,null):null;return P4.C(arguments[0],arguments[1],c)};
P4.C=function(a,b,c){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,QVb,null,1,null),c)))};P4.G=2;P4.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);c=$APP.w(c);return this.C(b,a,c)};var Q4=function Q4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=3<c.length?new $APP.Bc(c.slice(3),0,null):null;return Q4.C(arguments[0],arguments[1],arguments[2],c)};
Q4.C=function(a,b,c,d){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,zlb,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([d]))))};Q4.G=3;Q4.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);d=$APP.w(d);return this.C(b,a,c,d)};var R4=function R4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=4<c.length?new $APP.Bc(c.slice(4),0,null):null;return R4.C(arguments[0],arguments[1],arguments[2],arguments[3],c)};
R4.C=function(a,b,c,d,g){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,w1b,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null),g]))))};R4.G=4;R4.M=function(a){var b=$APP.u(a),c=$APP.w(a);a=$APP.u(c);var d=$APP.w(c);c=$APP.u(d);var g=$APP.w(d);d=$APP.u(g);g=$APP.w(g);return this.C(b,a,c,d,g)};
var S4=function S4(a){switch(arguments.length){case 1:return S4.j(arguments[0]);default:for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=new $APP.Bc(c.slice(1),0,null);return S4.C(arguments[0],c)}};S4.j=function(a){return a};
S4.C=function(a,b){return WH(a)?YH.C($APP.y([function(c){return $APP.Je.B(S4,c,b)},a])):FK(a)?LK.A(YH.C($APP.y([function(c){return $APP.Je.B(S4,c,b)},GK(a)])),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.MK,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,NK,null,1,null),b))),null,1,null),$APP.y([new $APP.D(null,IK(a),null,1,null)]))))):$APP.Aba(a)&&$APP.Ge(EF,b)?qN(a)?H1a(a,b):$APP.am.A(a,b):$APP.am.A(a,b)};S4.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};
S4.G=1;var T4=function T4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return T4.C(c)};T4.C=function(a){return function(b){return $APP.Je.B(S4,b,a)}};T4.G=0;T4.M=function(a){return this.C($APP.r(a))};var U4=function U4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=0<c.length?new $APP.Bc(c.slice(0),0,null):null;return U4.C(c)};
U4.C=function(a){return $APP.Ge($APP.xd,a)?$APP.Je.A(SQ,a):$APP.Je.A($APP.Pi,a)};U4.G=0;U4.M=function(a){return this.C($APP.r(a))};var ssc=Math.PI,tsc=TF.j(Math.PI),usc=kG.A(2,Math.PI),vsc=TF.j(usc),wsc=Math.E,xsc,ysc=Math.sqrt(5)+1;xsc=SF.A?SF.A(ysc,2):SF.call(null,ysc,2);var V4=function V4(a){for(var c=[],d=arguments.length,g=0;;)if(g<d)c.push(arguments[g]),g+=1;else break;c=1<c.length?new $APP.Bc(c.slice(1),0,null):null;return V4.C(arguments[0],c)};
V4.C=function(a,b){b=$APP.qe(b);b=$APP.C.A(b,$APP.VW);return S3.C(dG.j(a),$APP.y([IDb,$APP.k(b)?b:!0]))};V4.G=1;V4.M=function(a){var b=$APP.u(a);a=$APP.w(a);return this.C(b,a)};var Dsc=$APP.fg([Kcc,Q5b,vgb,N0b,A8b,obb,$Tb,x0b,mGb,kPb,Jcb,Bcb,xSb,TRb,rmb,i3b,mbc,QFb,bub,jkb,Tnb,vdb,hV,hgb,z$b,V0b,ZNb,K6b,Dwb,IVb,sRb,fBb,w0b,aDb,vYb,ntb,J2b,TUb,g3b,qqb,Zeb,Y5b,tzb,mcb,Urb,myb,gSb,Cib,Rbc,KQb,ADb,Yac,KCb,XGb,j5b,Yxb,GQb,L6b,rkb,Egb,TYb,hGb,krb,b0b,whb,Ozb,m4b,l3b,Hqb,eZb,NWb,e5b,P2b,Ryb,qub,XYb,gib],[$APP.cp(new $APP.f(null,8,[$APP.z(ydb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$W,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],
null)))],null)),new $APP.f(null,3,[$APP.Q,bIb,$APP.X,PR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$W,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null))],null)],null),$APP.z(VEb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$W],null)],null)))],null)),new $APP.f(null,3,[$APP.Q,Gpb,$APP.X,QR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$W],null)],null))],
null)],null),$APP.z(dZb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Yv,$APP.UP,$APP.VP],null)],null)))],null)),new $APP.f(null,3,[$APP.Q,Nib,$APP.X,RR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Yv,$APP.UP,$APP.VP],null)],null))],null)],null),$APP.z(wpb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[iS],null)))],null)),new $APP.f(null,
3,[$APP.Q,WMb,$APP.X,mab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[iS],null))],null)],null),$APP.z(RUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[iS],null)))],null)),new $APP.f(null,3,[$APP.Q,QAb,$APP.X,nab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[iS],null))],null)],null),$APP.z(H_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Wdb],null)))],null)),new $APP.f(null,3,[$APP.Q,$Sb,$APP.X,
oab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Wdb],null))],null)],null),$APP.z($Xb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hFb,PY],null))),$APP.P,"Takes a unit 3-vector `direction` (representing a direction) and a velocity\n  `v:c` normalized by `C`."],null)),new $APP.f(null,3,[$APP.Q,Y$b,$APP.X,pab,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a unit 3-vector `direction` (representing a direction) and a velocity\n  `v:c` normalized by `C`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hFb,PY],null))],null)],null),$APP.z(iWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null)))],null)),new $APP.f(null,3,[$APP.Q,jub,$APP.X,qab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null))],null)],null)],null),$APP.ap(Kcc)),$APP.cp($APP.fg([$APP.z(BKb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(JMb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(qGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))),$APP.P,"Given a 2x2 complex matrix `M` of the form\n\n  ```\n  [ a + b i,  c + d i]\n  [ -c + d i, a - b i]\n  ```\n\n  Returns a [[Quaternion]] instance with coefficients `[a b c d]`."],null)),$APP.z(x$a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))),$APP.P,"Given a normalized [[Quaternion]] `q`, returns the corresponding orthogonal 3x3\n  rotation matrix representing a rotation in 3d-space.\n\n  The implementation here will first normalize `q` for you and then generate a\n  rotation matrix from that new quaternion `q-normal`.\n\n  [[-\x3erotation-matrix]] will still work if `q` isn't normalized; but if\n  a [[Quaternion]] isn't normalized it doesn't make sense to interpret it as a\n  rotation.\n\n  See https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix"],
null)),$APP.z(pS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns `true` if `q` is an instance of [[Quaternion]], false otherwise."],null)),$APP.z($APP.Fac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns a new quaternion generated by dividing each coefficient of the supplied\n  quaternion `q` by the [[magnitude]] of `q`. (If the [[magnitude]]\n  is [[zero?]], returns the zero quaternion `q`.)\n\n  The returned quaternion will have [[magnitude]] (approximately) equal to\n  1. [[unit?]] will return true for a [[normalize]]d quaternion, though you may\n  need to supply an `:epsilon`."],
null)),$APP.z(rdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))),$APP.P,"Given a unit quaternion `q` [representing a spatial\n  rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation) (sometimes\n  called a 'versor'), returns a pair of\n\n  - `theta`, the rotation in radians about the rotation axis\n  - `axis`, a 3-element unit vector with elements `x`, `y` and `z` representing\n    an axis of rotation in 3d Euclidean space.\n\n  If the unit quaternion `q` represents NO rotation, the axis is undefined; this\n  manifests as the squared norm of the non-real vector part of `q` sitting\n  within [[*angle-axis-tolerance*]] of 0.\n\n  In this case, the conversion is degenerate and [[-\x3eangle-axis]] returns the\n  pair [0 [1 0 0]] as a default. (This check only occurs with a quaternion with\n  all numeric elements in the non-real positions.)"],
null)),$APP.z(yH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the hyperbolic sine of the supplied quaternion `q`.\n\n  [[sinh]] is defined in terms of the [[exp]] function as `(e^q - e^{-q}) / 2`."],null)),$APP.z(BLb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(mEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))),$APP.P,"Returns the `r` component of the supplied quaternion `q`.\n\n  Identical to [[real-part]]."],
null)),$APP.z(mH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the sine of the supplied quaternion `q`.\n\n  See the [Boost\n  documentation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/trans.html)\n  and [source](https://www.boost.org/doc/libs/1_78_0/boost/math/quaternion.hpp)\n  for a reference implementation."],null)),$APP.z(Nub,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[xU,$APP.Lh,
new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.ZU],null)],null)],null))),$APP.P,"Returns true if `q` is a unit quaternion (i.e., a 'versor', a quaternion\n  with [[magnitude]] equal to one), false otherwise.\n\n  To check if the [[magnitude]] of `q` is /approximately/ equal to one, pass a\n  tolerance via the `:epsilon` keyword argument.\n\n  For more control, use [[magnitude]] to compute the magnitude directly.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,
1,5,$APP.I,[$APP.M(xU,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.ZU],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[xU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.ZU],null)],null)],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(cXb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(GHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[EY,$APP.DX],null))),$APP.P,"Returns a [[Quaternion]] that represents a rotation of `angle` radians around a\n  normalized version of the vector described by `axis`. `axis` must be a\n  3-vector with components `x`, `y` and `z`.\n\n  Given an `axis` with numeric entries, [[from-angle-axis]] will explicitly\n  normalize `axis` before calling [[from-angle-normal-axis]]. If any entries are\n  non-numerical (i.e., symbolic), [[from-angle-axis]] will instead log an\n  assumption that the magnitude of `axis` \x3d\x3d 1 and proceed.\n\n  NOTE: If you have an already-normalized axis,\n  prefer [[from-angle-normal-axis]]."],
null)),$APP.z(nK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the tangent of the supplied quaternion `q`.\n\n  [[tan]] is defined as `(/ (sin q) (cos q))`."],null)),$APP.z(uH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the cosine of the supplied quaternion `q`.\n\n  See the [Boost\n  documentation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/trans.html)\n  and [source](https://www.boost.org/doc/libs/1_78_0/boost/math/quaternion.hpp)\n  for a reference implementation."],
null)),$APP.z(JHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns true if the quaternion `q` has zero entries for all non-real fields,\n  false otherwise."],null)),$APP.z(Qub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"Given two complex numbers `a` and `b`, returns a quaternion instance with\n\n  - `r` and `i` components set to the real and imaginary components of `a`\n  - `j` and `k` components set to the real and imaginary components of `b`"],
null)),$APP.z(Icc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[nO,$APP.oO],null))),$APP.P,"Returns a quaternion representing the (vector) cross product of the two pure\n  sides (retrieved via [[three-vector]]) of the supplied quaternions `l` and\n  `r`.\n\n  NOTE that the suggestion for this function comes from this [C++ quaternion\n  library](https://github.com/ferd36/quaternions/blob/master/include/quaternion.h#L1109).\n  Strictly, this is not the 'cross product of two quaternions'."],
null)),$APP.z(DEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))),$APP.P,"Returns the `i` component of the supplied quaternion `q`."],null)),$APP.z($APP.LX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null))),$APP.P,"Variadic function for subtracting quaternion arguments.\n\n  - Given no arguments, returns [[ZERO]], the additive identity.\n  - Given 1 argument `q`, acts as identity.\n  - Given 2 arguments, returns the difference of quaternions `q1` and `q2`.\n  - Given more than 2 arguments, returns the difference of the first quaternion\n    `q1` with the sum of all remaining arguments.\n\n  The difference of two quaternions is a new quaternion with coefficients equal\n  to the pairwise difference of the coefficients of `q1` and `q2`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null,null)],null)],null)),$APP.z(dX,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(NBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[EY],null))),$APP.P,"Create a quaternion representing a roll rotation by the supplied\n  `angle` (specified in radians)."],null)),$APP.z(jX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the multiplicative inverse of the supplied quaternion `q`.\n\n  The inverse of a quaternion is a new quaternion that, when [[mul]]tiplied by\n  `q`, will produce the [[ONE]] quaternion (the multiplicative identity)."],null)),$APP.z(EU,new $APP.f(null,
1,[$APP.Nw,!0],null)),$APP.z(IX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[nO,$APP.oO],null))),$APP.P,"Returns the quaternion dot product of the supplied quaternions `l` and `r`.\n\n  The quaternion dot product is the sum of the products of the corresponding\n  coefficients of each quaternion, equal to\n\n  $$r_l * r_r + i_l * i_r + j_l * j_r + k_l * k_r$$"],null)),$APP.z(HYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.P,
"Create a quaternion representing a yaw rotation by the supplied\n  `angle` (specified in radians)."],null)),$APP.z(bU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))),$APP.P,"Returns the `r` component of the supplied quaternion `q`.\n\n  Identical to [[get-r]]."],null)),$APP.z(DJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the logarithm $\\ln q$ of the supplied quaternion `q`.\n\n  Given a quaternion $q$ with real part $r$ and non-real vector $\\vec{v}$, the\n  logarithm [is computed\n  as](https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions)\n\n  $$\n  \\ln(q) \x3d \\ln \\|q\\| + \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\\n  \\arccos \\frac{r}{\\|\\q\\|}\n  $$"],
null)),$APP.z(zbc,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(kS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,ST],null))),$APP.P,"Given a quaternion `q` with function coefficients and a possibly-empty sequence\n  of partial derivative `selectors`, returns a new [[Quaternion]] generated by\n  replacing each (functional) coefficient with its derivative with respect to\n  `selectors`."],null)),$APP.z(vyb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z($APP.U7b,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.oO,UX,Nob,tIb],null))),$APP.P,"Generates a [[Quaternion]] instance, given:\n\n  - a magnitude `r`\n  - a rotation angle `theta`, with a natural range of `-2*pi` to `2*pi`\n  - `colat`, the [colatitude](https://mathworld.wolfram.com/Colatitude.html) of\n    the (non-real) vectorial part of the quaternion\n  - `lon`, the longitude of the vectorial part of the quaternion"],null)),$APP.z(oEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[xU],null))),$APP.P,"Returns the 4x4 matrix representation of the supplied [[Quaternion]] `q`."],null)),$APP.z(VKb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(wH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the hyperbolic cosine of the supplied quaternion `q`.\n\n  [[cosh]] is defined in terms of the [[exp]] function as `(e^q + e^{-q}) / 2`."],null)),$APP.z(iU,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.oO,new $APP.H(null,3,5,$APP.I,[$APP.Rv,uU,$APP.vU],null)],null),new $APP.H(null,4,5,$APP.I,[$APP.oO,$APP.Rv,uU,$APP.vU],null))),$APP.P,"Constructor that builds [[Quaternion]] instances out of a variety of types.\n  Given:\n\n  - a quaternion `x`, acts as identity.\n\n  - a sequential `x`, returns a quaternion with coefficients built from the\n    first four entries.\n\n  - a complex number `x`, returns a quaternion built from the real and imaginary\n    components of `x` with `j` and `k` components equal to zero.\n\n  - a real number `x` and 3-vector, returns a quaternion with real coefficient\n    equal to `x` and imaginary components equal to the elements of the vector\n\n  - 4 distinct arguments `r`, `i`, `j` and `k`, returns a quaternion with these\n    as the coefficients.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.oO,new $APP.H(null,3,5,$APP.I,[$APP.Rv,uU,$APP.vU],null)],null),new $APP.H(null,4,5,$APP.I,[$APP.oO,$APP.Rv,uU,$APP.vU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.oO,new $APP.H(null,3,5,$APP.I,[$APP.Rv,uU,$APP.vU],null)],null),new $APP.H(null,4,5,$APP.I,[$APP.oO,$APP.Rv,
uU,$APP.vU],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(FJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Sv],null))),$APP.P,"Returns the result of raising quaternion `q` to the real, complex or quaternion\n  power `p`."],null)),$APP.z(GU,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(JRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.P,"Create a quaternion representing a pitch rotation by the supplied\n  `angle` (specified in radians)."],
null)),$APP.z(RX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the negation (additive inverse) of the supplied quaternion `q`.\n\n  The additive inverse of a quaternion is a new quaternion that, when [[add]]ed\n  to `q`, will produce the [[ZERO]] quaternion (the additive identity)."],null)),$APP.z(iVb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(Ddb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(CK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[xU],null))),$APP.P,"Returns the norm of the supplied quaternion `q`.\n\n  The norm of a quaternion is the square root of the sum of the squares of the\n  quaternion's coefficients."],null)),$APP.z(LY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null))),$APP.P,"Variadic function for dividing quaternion arguments.\n\n  - Given no arguments, returns [[ONE]], the multiplicative identity.\n  - Given 1 argument `q`, acts as identity.\n  - Given 2 arguments, returns the quotient of quaternions `q1` and `q2`.\n  - Given more than 2 arguments, returns the quotient of the first quaternion\n    `q1` with the product of all remaining arguments.\n\n  The quotient of two quaternions is a new quaternion equal to the product of\n  `q1` and the multiplicative inverse of `q2`",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null,null)],null)],null)),$APP.z(opb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(v3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[xU],null))),$APP.P,"Returns true if the quaternion `q` has a zero real entry, false otherwise.\n\n  A 'pure' quaternion is sometimes called an 'imaginary' quaternion."],null)),$APP.z(ICb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(GDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))),$APP.P,"Returns a pair of complex number created respectively from the `(r,i)`\n  and `(j,k)` components of the supplied quaternion `q`.\n\n  NOTE that this only works if the coefficients of `q` are real numbers, due to\n  restrictions on the current complex number implementation. "],
null)),$APP.z(FEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))),$APP.P,"Returns the `k` component of the supplied quaternion `q`."],null)),$APP.z(JPb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(ojb,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,22,[bT,"null",NT,"null",UV,"null",mU,"null",UW,"null",qU,"null",jU,"null",YE,"null",OLb,"null",zX,"null",US,"null",tS,"null",nS,"null",NY,"null",iV,"null",wX,"null",
wY,"null",pT,"null",TW,"null",lW,"null",TV,"null",vY,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.oO,$APP.Rv,uU,$APP.vU,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,17,[bT,"null",NT,"null",UV,"null",mU,"null",UW,"null",qU,"null",zX,"null",US,"null",tS,"null",nS,"null",iV,"null",wX,"null",wY,"null",pT,"null",TW,"null",lW,"null",vY,"null"],null),null),$APP.P,"Positional factory function for emmy.quaternion/Quaternion."],null)),$APP.z(uCb,new $APP.f(null,
1,[$APP.Ru,!0],null)),$APP.z($APP.iT,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null))),$APP.P,"Variadic function that returns the sum of all supplied quaternions.\n\n  Given 1 argument `q`, acts as identity. Given no arguments, returns [[ZERO]],\n  the additive identity.\n\n  The sum of two or more quaternions is a new quaternion with coefficients equal\n  to the elementwise sum of the coefficients of all supplied quaternions.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null,null)],null)],null)),$APP.z(kMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[OSb,adb,PSb,Zcb],
null))),$APP.P,"Returns a [[Quaternion]] instance with [[complex-1]] part built from the polar\n  coordinates `r1` and `theta1` and [[complex-2]] part built from `r2` and\n  `theta2`"],null)),$APP.z(NJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rac],null))),$APP.P,"Given a 4x4 matrix representation of a quaternion, returns the associated\n  quaternion by extracting the first row."],null)),$APP.z(Ckb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,
5,$APP.I,[$APP.oO,QX,adb,Zcb],null))),$APP.P,"Returns a [[Quaternion]] `q` with magnitude `rho`, built such that:\n\n  - the magnitude of `q` equals `rho`\n  - the magnitude `([[complex-1]] q)` equals `(* rho (cos alpha))`\n  - the angle of `([[complex-1]] q)` equals `theta1`\n  - The magnitude `([[complex-2]] q)` equals `(* rho (cos alpha))`\n  - the angle of `([[complex-2]] q)` equals `theta12`\n\n  This strange, possibly unnecessary constructor taken from the [Boost\n  quaternion\n  implementation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/create.html)."],
null)),$APP.z(eBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns a 2x2 complex matrix representation of the supplied Quaternion `q`.\n\n  For a quaternion with coefficients `[a b c d]`, the returned matrix will have\n  the following form:\n\n  ```\n  [ a + b i,  c + d i]\n  [ -c + d i, a - b i]\n  ```\n\n  NOTE that this currently only works for quaternions `q` with real or symbolic\n  entries."],null)),$APP.z(Y3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the `r` and `i` components of the quaternion `q` as a `Complex` number\n  instance."],null)),$APP.z(W3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the `j` and `k` components of the quaternion `q` as a `Complex` number\n  instance."],null)),$APP.z(pY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the conjugate of the supplied quaternion `q`.\n\n  The conjugate of a quaternion is a new quaternion with real coefficient equal\n  to that of `q` and each imaginary coefficient negated. `(mul q (conjugate q))`\n  will return a [[real?]] quaternion."],
null)),$APP.z(NQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))),$APP.P,"Given an orthogonal 3x3 matrix M representing a rotation in 3-space, returns\n  the unit quaternion that corresponds to the same transformation.\n\n  GJS notes in scmutils that this algorithm is the 'expanded Matt Mason method'.\n\n  NOTE Orthogonal means, no stretching allowed, only rotation!\n\n  NOTE this routine uses non-generic [[clojure.core/\x3e\x3d]]\n  and [[clojure.core/max]] internally, so if you use numeric entries (or if your\n  entries simplify down to numbers), make sure that they work with these native\n  operations. No `BigInt` in ClojureScript for now, for example."],
null)),$APP.z($Eb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[nO,$APP.oO],null))),$APP.P,"Returns the commutator of the supplied quaternions `l` and `r`.\n\n  The commutator of two quaternions is equal to\n\n  ```clj\n  (- (* l r) (* r l))\n  ```"],null)),$APP.z(HJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the square root of the supplied quaternion `q`.\n\n  `([[sqrt]] q)` is identical to, but more efficient than, raising `q` to the\n  1/2 power.\n\n  Thanks to the [Spire\n  library](https://github.com/typelevel/spire/blob/82f607714f94ba1c70b13fd4751063dfdcd155f5/core/src/main/scala/spire/math/Quaternion.scala#L217)\n  for the correct implementation used here."],
null)),$APP.z($APP.kX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Vv],null))),$APP.P,"Returns a new quaternion generated by multiplying each coefficient of the\n  supplied quaternion `q` by the supplied scalar `s` on the right."],null)),$APP.z(aU,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(KNb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(wzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,
new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))),$APP.P,"Returns a 4-vector of the coefficients of quaternion `q`.\n\n  Works identically to `(vec q)`, but more efficient as we are able to create\n  the new vector in one shot."],null)),$APP.z(BJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the exponential $e^q$ of the supplied quaternion `q`.\n\n  Given a quaternion $q$ with real part $r$ and non-real vector $\\vec{v}$, the\n  exponential [is computed\n  as](https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions)\n\n  $$\n  \\exp(q) \x3d e^r \\left(\\cos \\|\\mathbf{v}\\| \\\n  + \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\sin\\|\\mathbf{v}\\| \\right)\n  $$"],
null)),$APP.z(EEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))),$APP.P,"Returns the `j` component of the supplied quaternion `q`."],null)),$APP.z(Jjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[EY,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null))),$APP.P,"Returns a [[Quaternion]] that represents a rotation of `angle` radians around\n  the unit (normalized) vector described by the second argument, a 3-vector with\n  components `x`, `y` and `z`.\n\n  The second argument represents an axis of rotation.\n\n  NOTE: If you have an UN-normalized axis, prefer [[from-angle-axis]]."],
null)),$APP.z(qX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))),$APP.P,"Returns the hyperbolic tangent of the supplied quaternion `q`.\n\n  [[tan]] is defined as `(/ (sinh q) (cosh q))`."],null)),$APP.z(pec,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))),$APP.P,"Returns a 3-vector holding the coefficients of the non-real (imaginary)\n  components of the quaternion `q`."],
null)),$APP.z($U,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null))),$APP.P,"Variadic function that returns the product of all supplied quaternions.\n\n  Given 1 argument `q`, acts as identity. Given no arguments, returns [[ONE]],\n  the multiplicative identity.\n\n  The product of two or more quaternions is a new quaternion generated by\n  multiplying together each quaternion of the form `(r+ai+bj+ck)`, respecting\n  the quaternion rules:\n\n  i^2 \x3d\x3d j^2 \x3d\x3d k^2 \x3d\x3d -1\n  ijk \x3d\x3d -1,\n  ij  \x3d\x3d k,  jk \x3d\x3d i,  ki \x3d\x3d j\n  ji  \x3d\x3d -k, kj \x3d\x3d -i, ik \x3d\x3d -j",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null,null)],null)],null)),$APP.z(sIb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(hTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[xU,$APP.Vv],null))),$APP.P,"Returns a new quaternion generated by dividing each coefficient of the supplied\n  quaternion `q` by the supplied scalar `s`."],null)),$APP.z(Nsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Uv,$APP.oO,UX,ZR],null))),$APP.P,"Returns a [[Quaternion]] `q` with [[real-part]] equal to `t` and\n  the [[three-vector]] part built from the spherical coordinates `r`, `colat`\n  and `lon`."],null)),$APP.z(tXb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.uGb,EY,uU,$APP.vU],null))),$APP.P,"Returns a [[Quaternion]] `q` with [[complex-1]] built from the polar\n  coordinates `mag` and `angle`, and `j` and `k` components equal to the\n  supplied `j` and `k`."],null))],[new $APP.f(null,3,[$APP.Q,kcc,$APP.X,E4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,$xb,$APP.X,B4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,nUb,$APP.X,function(a){a=E1a(a);var b=$APP.x.B(a,0,null);a=$APP.x.B(b,0,null);b=$APP.x.B(b,
1,null);return mR.K(zH.j(a),CH.j(a),zH.j(b),CH.j(b))},$APP.h,new $APP.f(null,2,[$APP.P,"Given a 2x2 complex matrix `M` of the form\n\n  ```\n  [ a + b i,  c + d i]\n  [ -c + d i, a - b i]\n  ```\n\n  Returns a [[Quaternion]] instance with coefficients `[a b c d]`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))],null)],null),new $APP.f(null,3,[$APP.Q,PGb,$APP.X,y$a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a normalized [[Quaternion]] `q`, returns the corresponding orthogonal 3x3\n  rotation matrix representing a rotation in 3d-space.\n\n  The implementation here will first normalize `q` for you and then generate a\n  rotation matrix from that new quaternion `q-normal`.\n\n  [[-\x3erotation-matrix]] will still work if `q` isn't normalized; but if\n  a [[Quaternion]] isn't normalized it doesn't make sense to interpret it as a\n  rotation.\n\n  See https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,vib,$APP.X,a$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `q` is an instance of [[Quaternion]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,cOb,$APP.X,function(a){return $APP.k(e$a(a))?a:qR(a,sR(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new quaternion generated by dividing each coefficient of the supplied\n  quaternion `q` by the [[magnitude]] of `q`. (If the [[magnitude]]\n  is [[zero?]], returns the zero quaternion `q`.)\n\n  The returned quaternion will have [[magnitude]] (approximately) equal to\n  1. [[unit?]] will return true for a [[normalize]]d quaternion, though you may\n  need to supply an `:epsilon`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,SNb,$APP.X,function(a){var b=jR(a),c=rL(b,b);var d=(d=$APP.Ge(GF,b))?KF(1E-8)(0,c):d;if($APP.k(d))return new $APP.H(null,2,5,$APP.I,[0,new $APP.H(null,3,5,$APP.I,[1,0,0],null)],null);c=lG.j(c);a=OF.A(2,tG.A(c,a.r));b=BG.A(b,c);return new $APP.H(null,2,5,$APP.I,[a,b],null)},$APP.h,new $APP.f(null,2,[$APP.P,"Given a unit quaternion `q` [representing a spatial\n  rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation) (sometimes\n  called a 'versor'), returns a pair of\n\n  - `theta`, the rotation in radians about the rotation axis\n  - `axis`, a 3-element unit vector with elements `x`, `y` and `z` representing\n    an axis of rotation in 3d Euclidean space.\n\n  If the unit quaternion `q` represents NO rotation, the axis is undefined; this\n  manifests as the squared norm of the non-real vector part of `q` sitting\n  within [[*angle-axis-tolerance*]] of 0.\n\n  In this case, the conversion is degenerate and [[-\x3eangle-axis]] returns the\n  pair [0 [1 0 0]] as a default. (This check only occurs with a quaternion with\n  all numeric elements in the non-real positions.)",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Qcc,$APP.X,t$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the hyperbolic sine of the supplied quaternion `q`.\n\n  [[sinh]] is defined in terms of the [[exp]] function as `(e^q - e^{-q}) / 2`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,s7b,$APP.X,rR,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns the square of the [[magnitude]] of the supplied quaternion `q`,\n  equivalent to taking the [[dot-product]] of `q` with itself.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,rDb,$APP.X,function(a){return a.r},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `r` component of the supplied quaternion `q`.\n\n  Identical to [[real-part]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))],
null)],null),new $APP.f(null,3,[$APP.Q,Syb,$APP.X,q$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sine of the supplied quaternion `q`.\n\n  See the [Boost\n  documentation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/trans.html)\n  and [source](https://www.boost.org/doc/libs/1_78_0/boost/math/quaternion.hpp)\n  for a reference implementation.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,VAb,$APP.X,A4,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns true if `q` is a unit quaternion (i.e., a 'versor', a quaternion\n  with [[magnitude]] equal to one), false otherwise.\n\n  To check if the [[magnitude]] of `q` is /approximately/ equal to one, pass a\n  tolerance via the `:epsilon` keyword argument.\n\n  For more control, use [[magnitude]] to compute the magnitude directly.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[xU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.ZU],null)],null)],null))],null)],null),new $APP.f(null,
3,[$APP.Q,ZJb,$APP.X,1E-8,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,zvb,$APP.X,function(a,b){if($APP.Ge(GF,b)){var c=jG.j(b);b=BG.A(b,c);return AR(a,b)}c=dG.j(rL(b,b));c=GJ.A(new $APP.D(null,$APP.bw,new $APP.D(null,c,new $APP.D(null,1,null,1,null),2,null),3,null),GHb);return $APP.k(c)?AR(a,b):c},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] that represents a rotation of `angle` radians around a\n  normalized version of the vector described by `axis`. `axis` must be a\n  3-vector with components `x`, `y` and `z`.\n\n  Given an `axis` with numeric entries, [[from-angle-axis]] will explicitly\n  normalize `axis` before calling [[from-angle-normal-axis]]. If any entries are\n  non-numerical (i.e., symbolic), [[from-angle-axis]] will instead log an\n  assumption that the magnitude of `axis` \x3d\x3d 1 and proceed.\n\n  NOTE: If you have an already-normalized axis,\n  prefer [[from-angle-normal-axis]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[EY,$APP.DX],null))],null)],null),new $APP.f(null,3,[$APP.Q,tub,$APP.X,r$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the tangent of the supplied quaternion `q`.\n\n  [[tan]] is defined as `(/ (sin q) (cos q))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,UGb,$APP.X,p$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the cosine of the supplied quaternion `q`.\n\n  See the [Boost\n  documentation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/trans.html)\n  and [source](https://www.boost.org/doc/libs/1_78_0/boost/math/quaternion.hpp)\n  for a reference implementation.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,iFb,$APP.X,kR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the quaternion `q` has zero entries for all non-real fields,\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,vbc,$APP.X,function(a,b){return mR.K(zH.j(a),CH.j(a),zH.j(b),CH.j(b))},$APP.h,new $APP.f(null,2,[$APP.P,"Given two complex numbers `a` and `b`, returns a quaternion instance with\n\n  - `r` and `i` components set to the real and imaginary components of `a`\n  - `j` and `k` components set to the real and imaginary components of `b`",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,wKb,$APP.X,m$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a quaternion representing the (vector) cross product of the two pure\n  sides (retrieved via [[three-vector]]) of the supplied quaternions `l` and\n  `r`.\n\n  NOTE that the suggestion for this function comes from this [C++ quaternion\n  library](https://github.com/ferd36/quaternions/blob/master/include/quaternion.h#L1109).\n  Strictly, this is not the 'cross product of two quaternions'.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[nO,$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,sDb,$APP.X,function(a){return a.i},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `i` component of the supplied quaternion `q`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))],null)],null),new $APP.f(null,3,[$APP.Q,Rsb,$APP.X,yR,$APP.h,new $APP.f(null,2,[$APP.P,"Variadic function for subtracting quaternion arguments.\n\n  - Given no arguments, returns [[ZERO]], the additive identity.\n  - Given 1 argument `q`, acts as identity.\n  - Given 2 arguments, returns the difference of quaternions `q1` and `q2`.\n  - Given more than 2 arguments, returns the difference of the first quaternion\n    `q1` with the sum of all remaining arguments.\n\n  The difference of two quaternions is a new quaternion with coefficients equal\n  to the pairwise difference of the coefficients of `q1` and `q2`.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,GNb,$APP.X,lR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied quaternion `q1` is equal to the value `q2`. The\n  rules for [[eq]] are as follows:\n\n  - If `q2` is a quaternion, returns true if all coefficients match, false\n    otherwise\n\n  - If `q2` is complex, returns true if the real and `i` coefficients are equal,\n    with `j` and `k` coefficients of `q1` equal to zero, false otherwise\n\n  - If `q2` is sequential with a count of 4, it's interpreted as a vector of\n    quaternion coefficients.\n\n  Else, if `q1` is a [[real?]] quaternion, returns true if the real component of\n  `q1` is [[emmy.value/\x3d]] to `q2`, false otherwise.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[DW,EW],null))],null)],null),new $APP.f(null,3,[$APP.Q,dFb,$APP.X,function(a){return AR(a,new $APP.H(null,3,5,$APP.I,[0,0,1],null))},$APP.h,new $APP.f(null,2,[$APP.P,"Create a quaternion representing a roll rotation by the supplied\n  `angle` (specified in radians).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[EY],null))],null)],null),new $APP.f(null,3,[$APP.Q,Z5b,$APP.X,n$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the multiplicative inverse of the supplied quaternion `q`.\n\n  The inverse of a quaternion is a new quaternion that, when [[mul]]tiplied by\n  `q`, will produce the [[ONE]] quaternion (the multiplicative identity).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,A$b,$APP.X,fsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,nPb,$APP.X,l$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the quaternion dot product of the supplied quaternions `l` and `r`.\n\n  The quaternion dot product is the sum of the products of the corresponding\n  coefficients of each quaternion, equal to\n\n  $$r_l * r_r + i_l * i_r + j_l * j_r + k_l * k_r$$",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[nO,$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,EWb,$APP.X,function(a){return AR(a,new $APP.H(null,3,5,$APP.I,[0,1,0],null))},$APP.h,new $APP.f(null,2,[$APP.P,"Create a quaternion representing a yaw rotation by the supplied\n  `angle` (specified in radians).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[EY],null))],null)],null),new $APP.f(null,3,[$APP.Q,Sbb,$APP.X,function(a){return a.r},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `r` component of the supplied quaternion `q`.\n\n  Identical to [[get-r]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))],null)],null),new $APP.f(null,3,[$APP.Q,Bbc,$APP.X,o$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the logarithm $\\ln q$ of the supplied quaternion `q`.\n\n  Given a quaternion $q$ with real part $r$ and non-real vector $\\vec{v}$, the\n  logarithm [is computed\n  as](https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions)\n\n  $$\n  \\ln(q) \x3d \\ln \\|q\\| + \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\\n  \\arccos \\frac{r}{\\|\\q\\|}\n  $$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,NYb,$APP.X,i$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new quaternion generated by multiplying each coefficient of the\n  supplied quaternion `q` by the supplied scalar `s` on the left.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,mOb,$APP.X,h$a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a quaternion `q` with function coefficients and a possibly-empty sequence\n  of partial derivative `selectors`, returns a new [[Quaternion]] generated by\n  replacing each (functional) coefficient with its derivative with respect to\n  `selectors`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,ST],null))],null)],null),new $APP.f(null,3,[$APP.Q,E$b,$APP.X,gsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,xjb,$APP.X,function(a,b,c,d){var g=SF.A(b,2);b=hO.j(g);var l=iO.j(g);g=iO.j(c);l=kG.A(a,l);g=kG.A(l,g);return mR.K(kG.A(a,b),kG.A(g,hO.j(d)),kG.A(g,iO.j(d)),kG.A(l,hO.j(c)))},$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [[Quaternion]] instance, given:\n\n  - a magnitude `r`\n  - a rotation angle `theta`, with a natural range of `-2*pi` to `2*pi`\n  - `colat`, the [colatitude](https://mathworld.wolfram.com/Colatitude.html) of\n    the (non-real) vectorial part of the quaternion\n  - `lon`, the longitude of the vectorial part of the quaternion",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.oO,UX,Nob,tIb],null))],null)],null),new $APP.f(null,3,[$APP.Q,sYb,$APP.X,function(a){return mG.C(kG.A(a.r,isc),kG.A(a.i,C4),$APP.y([kG.A(a.Ma,D4),kG.A(a.k,E4)]))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the 4x4 matrix representation of the supplied [[Quaternion]] `q`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,ahb,$APP.X,ksc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,dob,$APP.X,s$a,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns the hyperbolic cosine of the supplied quaternion `q`.\n\n  [[cosh]] is defined in terms of the [[exp]] function as `(e^q + e^{-q}) / 2`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,RQb,$APP.X,mR,$APP.h,new $APP.f(null,2,[$APP.P,"Constructor that builds [[Quaternion]] instances out of a variety of types.\n  Given:\n\n  - a quaternion `x`, acts as identity.\n\n  - a sequential `x`, returns a quaternion with coefficients built from the\n    first four entries.\n\n  - a complex number `x`, returns a quaternion built from the real and imaginary\n    components of `x` with `j` and `k` components equal to zero.\n\n  - a real number `x` and 3-vector, returns a quaternion with real coefficient\n    equal to `x` and imaginary components equal to the elements of the vector\n\n  - 4 distinct arguments `r`, `i`, `j` and `k`, returns a quaternion with these\n    as the coefficients.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.oO,new $APP.H(null,3,5,$APP.I,[$APP.Rv,uU,$APP.vU],null)],null),new $APP.H(null,4,5,$APP.I,[$APP.oO,$APP.Rv,uU,$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,cDb,$APP.X,v$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of raising quaternion `q` to the real, complex or quaternion\n  power `p`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,
D$b,$APP.X,hsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,L3b,$APP.X,function(a){return AR(a,new $APP.H(null,3,5,$APP.I,[1,0,0],null))},$APP.h,new $APP.f(null,2,[$APP.P,"Create a quaternion representing a pitch rotation by the supplied\n  `angle` (specified in radians).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[EY],null))],null)],null),new $APP.f(null,3,[$APP.Q,hyb,$APP.X,pR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the negation (additive inverse) of the supplied quaternion `q`.\n\n  The additive inverse of a quaternion is a new quaternion that, when [[add]]ed\n  to `q`, will produce the [[ZERO]] quaternion (the additive identity).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,UFb,$APP.X,msc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Vxb,$APP.X,isc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,DVb,$APP.X,sR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the norm of the supplied quaternion `q`.\n\n  The norm of a quaternion is the square root of the sum of the squares of the\n  quaternion's coefficients.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,
3,[$APP.Q,pHb,$APP.X,wR,$APP.h,new $APP.f(null,2,[$APP.P,"Variadic function for dividing quaternion arguments.\n\n  - Given no arguments, returns [[ONE]], the multiplicative identity.\n  - Given 1 argument `q`, acts as identity.\n  - Given 2 arguments, returns the quotient of quaternions `q1` and `q2`.\n  - Given more than 2 arguments, returns the quotient of the first quaternion\n    `q1` with the product of all remaining arguments.\n\n  The quotient of two quaternions is a new quaternion equal to the product of\n  `q1` and the multiplicative inverse of `q2`",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,$ob,$APP.X,esc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,dfb,$APP.X,function(a){return MF.j(a.r)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the quaternion `q` has a zero real entry, false otherwise.\n\n  A 'pure' quaternion is sometimes called an 'imaginary' quaternion.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,t6b,$APP.X,jsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Ajb,$APP.X,function(a){return new $APP.H(null,2,5,$APP.I,[b$a(a),c$a(a)],null)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a pair of complex number created respectively from the `(r,i)`\n  and `(j,k)` components of the supplied quaternion `q`.\n\n  NOTE that this only works if the coefficients of `q` are real numbers, due to\n  restrictions on the current complex number implementation. ",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,uDb,$APP.X,function(a){return a.k},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `k` component of the supplied quaternion `q`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))],null)],null),new $APP.f(null,3,[$APP.Q,acb,$APP.X,lsc,$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.Q,rNb,$APP.X,iR,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.quaternion/Quaternion.",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.oO,$APP.Rv,uU,$APP.vU,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vsb,$APP.X,nR,$APP.h,new $APP.f(null,2,[$APP.P,"Given a quaternion `q` with function coefficients and a sequence `args` of\n  arguments, and returns a new [[Quaternion]] generated by replacing each\n  coefficient with the result of applying the (functional) coefficient to\n  `args`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Ou],null))],null)],null),new $APP.f(null,3,[$APP.Q,Tkb,$APP.X,xR,$APP.h,new $APP.f(null,2,[$APP.P,"Variadic function that returns the sum of all supplied quaternions.\n\n  Given 1 argument `q`, acts as identity. Given no arguments, returns [[ZERO]],\n  the additive identity.\n\n  The sum of two or more quaternions is a new quaternion with coefficients equal\n  to the elementwise sum of the coefficients of all supplied quaternions.",$APP.U,$APP.M($APP.sf,
new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,syb,$APP.X,function(a,b,c,d){return mR.K(kG.A(a,hO.j(b)),kG.A(a,iO.j(b)),kG.A(c,hO.j(d)),kG.A(c,iO.j(d)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] instance with [[complex-1]] part built from the polar\n  coordinates `r1` and `theta1` and [[complex-2]] part built from `r2` and\n  `theta2`",$APP.U,$APP.M(new $APP.H(null,
4,5,$APP.I,[OSb,adb,PSb,Zcb],null))],null)],null),new $APP.f(null,3,[$APP.Q,AYb,$APP.X,function(a){return mR.j($APP.x.A(a,0))},$APP.h,new $APP.f(null,2,[$APP.P,"Given a 4x4 matrix representation of a quaternion, returns the associated\n  quaternion by extracting the first row.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rac],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mlb,$APP.X,function(a,b,c,d){var g=kG.A(a,hO.j(b));a=kG.A(a,iO.j(b));return mR.K(kG.A(g,hO.j(c)),kG.A(g,iO.j(c)),kG.A(a,hO.j(d)),
kG.A(a,iO.j(d)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] `q` with magnitude `rho`, built such that:\n\n  - the magnitude of `q` equals `rho`\n  - the magnitude `([[complex-1]] q)` equals `(* rho (cos alpha))`\n  - the angle of `([[complex-1]] q)` equals `theta1`\n  - The magnitude `([[complex-2]] q)` equals `(* rho (cos alpha))`\n  - the angle of `([[complex-2]] q)` equals `theta12`\n\n  This strange, possibly unnecessary constructor taken from the [Boost\n  quaternion\n  implementation](https://www.boost.org/doc/libs/1_78_0/libs/math/doc/html/math_toolkit/create.html).",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.oO,QX,adb,Zcb],null))],null)],null),new $APP.f(null,3,[$APP.Q,vLb,$APP.X,function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null),d=$APP.x.B(a,2,null);a=$APP.x.B(a,3,null);return EN.C($APP.y([new $APP.H(null,2,5,$APP.I,[PZ.A(b,c),PZ.A(d,a)],null),new $APP.H(null,2,5,$APP.I,[PZ.A(RF.j(d),a),PZ.A(b,RF.j(c))],null)]))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a 2x2 complex matrix representation of the supplied Quaternion `q`.\n\n  For a quaternion with coefficients `[a b c d]`, the returned matrix will have\n  the following form:\n\n  ```\n  [ a + b i,  c + d i]\n  [ -c + d i, a - b i]\n  ```\n\n  NOTE that this currently only works for quaternions `q` with real or symbolic\n  entries.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,VOb,$APP.X,b$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `r` and `i` components of the quaternion `q` as a `Complex` number\n  instance.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,UOb,$APP.X,c$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `j` and `k` components of the quaternion `q` as a `Complex` number\n  instance.",$APP.U,$APP.M(new $APP.H(null,1,
5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,e7b,$APP.X,k$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the conjugate of the supplied quaternion `q`.\n\n  The conjugate of a quaternion is a new quaternion with real coefficient equal\n  to that of `q` and each imaginary coefficient negated. `(mul q (conjugate q))`\n  will return a [[real?]] quaternion.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,MCb,$APP.X,function(a){var b=$APP.x.B(a,
0,null),c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);var g=$APP.x.B(a,1,null),l=$APP.x.B(g,0,null),n=$APP.x.B(g,1,null);g=$APP.x.B(g,2,null);var p=$APP.x.B(a,2,null),v=$APP.x.B(p,0,null);a=$APP.x.B(p,1,null);var t=$APP.x.B(p,2,null);p=kG.A(F4,mG.C(1,c,$APP.y([n,t])));var A=kG.A(F4,mG.C(1,c,$APP.y([TF.j(n),TF.j(t)]))),B=kG.A(F4,mG.C(1,TF.j(c),$APP.y([n,TF.j(t)]))),G=kG.A(F4,mG.C(1,TF.j(c),$APP.y([TF.j(n),t])));t=kG.A(F4,TF.A(a,g));n=kG.A(F4,TF.A(b,v));c=kG.A(F4,TF.A(l,d));d=kG.A(F4,
mG.A(d,l));b=kG.A(F4,mG.A(b,v));g=kG.A(F4,mG.A(g,a));var J=dG.j(p),O=dG.j(A),R=dG.j(B),W=dG.j(G);return GF(J)&&GF(O)&&GF(R)&&GF(W)?(J>=function(){var Z=O>R?O:R;return Z>W?Z:W}()?(l=lG.j(J),a=SF.A(t,l),p=SF.A(n,l),d=SF.A(c,l)):O>=function(){var Z=J>R?J:R;return Z>W?Z:W}()?(a=lG.j(O),l=SF.A(t,a),p=SF.A(d,a),d=SF.A(b,a)):R>=function(){var Z=J>O?J:O;return Z>W?Z:W}()?(p=lG.j(R),l=SF.A(n,p),a=SF.A(d,p),d=SF.A(g,p)):(d=lG.j(W),l=SF.A(c,d),a=SF.A(b,d),p=SF.A(g,d)),mR.K(l,a,p,d)):$APP.eb(MF.j(J))?(l=lG.j(p),
a=SF.A(t,l),p=SF.A(n,l),d=SF.A(c,l),mR.K(l,a,p,d)):$APP.eb(MF.j(O))?(a=lG.j(A),l=0,p=SF.A(d,a),d=SF.A(b,a),mR.K(l,a,p,d)):$APP.eb(MF.j(R))?(p=lG.j(B),a=l=0,d=SF.A(g,p),mR.K(l,a,p,d)):mR.K(0,0,0,0)},$APP.h,new $APP.f(null,2,[$APP.P,"Given an orthogonal 3x3 matrix M representing a rotation in 3-space, returns\n  the unit quaternion that corresponds to the same transformation.\n\n  GJS notes in scmutils that this algorithm is the 'expanded Matt Mason method'.\n\n  NOTE Orthogonal means, no stretching allowed, only rotation!\n\n  NOTE this routine uses non-generic [[clojure.core/\x3e\x3d]]\n  and [[clojure.core/max]] internally, so if you use numeric entries (or if your\n  entries simplify down to numbers), make sure that they work with these native\n  operations. No `BigInt` in ClojureScript for now, for example.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))],null)],null),new $APP.f(null,3,[$APP.Q,xcc,$APP.X,function(a,b){return yR.A(zR.A(a,b),zR.A(b,a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the commutator of the supplied quaternions `l` and `r`.\n\n  The commutator of two quaternions is equal to\n\n  ```clj\n  (- (* l r) (* r l))\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[nO,$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,dJb,$APP.X,w$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the square root of the supplied quaternion `q`.\n\n  `([[sqrt]] q)` is identical to, but more efficient than, raising `q` to the\n  1/2 power.\n\n  Thanks to the [Spire\n  library](https://github.com/typelevel/spire/blob/82f607714f94ba1c70b13fd4751063dfdcd155f5/core/src/main/scala/spire/math/Quaternion.scala#L217)\n  for the correct implementation used here.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,eVb,$APP.X,j$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new quaternion generated by multiplying each coefficient of the\n  supplied quaternion `q` by the supplied scalar `s` on the right.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,HPb,$APP.X,g$a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a quaternion `q` with function coefficients, returns an arity compatible\n  with all function coefficient entries.\n\n  NOTE that by default, if any arities are incompatible, the function will\n  return `[:at-least 0]`. To force strict arity checks,\n  bind [[emmy.function/*strict-arity-checks*]] to `true`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,qlb,$APP.X,D4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,AFb,$APP.X,d$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a 4-vector of the coefficients of quaternion `q`.\n\n  Works identically to `(vec q)`, but more efficient as we are able to create\n  the new vector in one shot.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],
null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,rPb,$APP.X,uR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the exponential $e^q$ of the supplied quaternion `q`.\n\n  Given a quaternion $q$ with real part $r$ and non-real vector $\\vec{v}$, the\n  exponential [is computed\n  as](https://en.wikipedia.org/wiki/Quaternion#Exponential,_logarithm,_and_power_functions)\n\n  $$\n  \\exp(q) \x3d e^r \\left(\\cos \\|\\mathbf{v}\\| \\\n  + \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\sin\\|\\mathbf{v}\\| \\right)\n  $$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,tDb,$APP.X,function(a){return a.Ma},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `j` component of the supplied quaternion `q`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(xU,new $APP.f(null,1,[$APP.tj,mX],null))],null))],null)],null),new $APP.f(null,3,[$APP.Q,bHb,$APP.X,AR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] that represents a rotation of `angle` radians around\n  the unit (normalized) vector described by the second argument, a 3-vector with\n  components `x`, `y` and `z`.\n\n  The second argument represents an axis of rotation.\n\n  NOTE: If you have an UN-normalized axis, prefer [[from-angle-axis]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[EY,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xzb,$APP.X,u$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the hyperbolic tangent of the supplied quaternion `q`.\n\n  [[tan]] is defined as `(/ (sinh q) (cosh q))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lob,$APP.X,jR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a 3-vector holding the coefficients of the non-real (imaginary)\n  components of the quaternion `q`.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pS,xU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,v$b,$APP.X,zR,$APP.h,new $APP.f(null,2,[$APP.P,"Variadic function that returns the product of all supplied quaternions.\n\n  Given 1 argument `q`, acts as identity. Given no arguments, returns [[ONE]],\n  the multiplicative identity.\n\n  The product of two or more quaternions is a new quaternion generated by\n  multiplying together each quaternion of the form `(r+ai+bj+ck)`, respecting\n  the quaternion rules:\n\n  i^2 \x3d\x3d j^2 \x3d\x3d k^2 \x3d\x3d -1\n  ijk \x3d\x3d -1,\n  ij  \x3d\x3d k,  jk \x3d\x3d i,  ki \x3d\x3d j\n  ji  \x3d\x3d -k, kj \x3d\x3d -i, ik \x3d\x3d -j",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[DW,EW],null),new $APP.H(null,4,5,$APP.I,[DW,EW,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,Pyb,$APP.X,C4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,pub,$APP.X,qR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new quaternion generated by dividing each coefficient of the supplied\n  quaternion `q` by the supplied scalar `s`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Vv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,eCb,$APP.X,function(a,b,c,d){var g=kG.A(b,iO.j(c));return mR.K(a,kG.A(g,hO.j(d)),kG.A(g,iO.j(d)),kG.A(b,hO.j(c)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] `q` with [[real-part]] equal to `t` and\n  the [[three-vector]] part built from the spherical coordinates `r`, `colat`\n  and `lon`.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Uv,$APP.oO,UX,ZR],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lrb,$APP.X,function(a,b,c,d){return mR.K(kG.A(a,hO.j(b)),
kG.A(a,iO.j(b)),c,d)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Quaternion]] `q` with [[complex-1]] built from the polar\n  coordinates `mag` and `angle`, and `j` and `k` components equal to the\n  supplied `j` and `k`.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.uGb,EY,uU,$APP.vU],null))],null)],null)]),$APP.ap(Q5b)),$APP.cp(new $APP.f(null,3,[$APP.z(Y6b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[VR],null)))],null)),new $APP.f(null,3,[$APP.Q,sHb,$APP.X,J$a,
$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[VR],null))],null)],null),$APP.z(SWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))],null)),new $APP.f(null,3,[$APP.Q,f$b,$APP.X,function(a){return function(b){return YH.C($APP.y([a.j?a.j(b):a.call(null,b),J$a(TF.j(b))]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))],null)],null),$APP.z(UKb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,
$APP.I,[VR],null)))],null)),new $APP.f(null,3,[$APP.Q,YNb,$APP.X,function(a){return function(b){return YH.C($APP.y([b,J$a(TF.j(a))]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[VR],null))],null)],null)],null),$APP.ap(vgb)),$APP.cp($APP.fg([$APP.z(TNb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,pX],null))),$APP.P,"Alias for [[rule-simplifier]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,
[$APP.M(pX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,pX],null)),$APP.Cx,$APP.M(null)],null)],null)),zyb,$APP.z(scc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MY],null))),$APP.P,"Given some rule `the-rule`, returns a new rule that accepts potentially nested\n  `data` and applies `the-rule` to all subexpressions on the way down AND back\n  up a traversal. This is a sort of hybrid of breadth-first, depth-first.\n\n  The transformation is applied a single time to all subexpressions.\n  See [[iterated-top-down]] for a version that will iterate to convergence."],
null)),$APP.z(LNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Takes a rule `r` and returns a new rule that return either `(r data)` if `r` is\n  successful, or its original input on failure.\n\n  NOTE that the returned rule will never fail! This makes it inappropriate to\n  use with [[choice]], for example, if you expect any rule supplied after this\n  one to ever be matched. [[attempt]] rules are great choices for the final rule\n  passed to [[choice]], however."],
null)),ibb,$APP.z(jXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Returns `true` if `r` was marked as an 'attempt' rule, i.e., a rule that will\n  never fail, but return its input on a failed match."],null)),$APP.z(Lyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MY],null))),$APP.P,"Version of [[top-down]] that iterates on each subexpression to convergence\n  before each subexpression returns. Any change in a subexpression triggers a\n  new iterated-top-down replacement of that subexpression.\n\n  The returned rule keeps an internal memoization cache and will return\n  immediately for subexpressions it's seen before."],
null)),$APP.z(pdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MY],null))),$APP.P,"Version of [[bottom-up]] that iterates on each subexpression to convergence\n  before each subexpression returns. Any change in a subexpression triggers a\n  new iterated-bottom-up replacement of that subexpression.\n\n  The returned rule keeps an internal memoization cache and will return\n  immediately for subexpressions it's seen before."],null)),$APP.z(F$b,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.oO],null))),$APP.P,"Returns a new rule which repeatedly applies `r` until `f` returns `true`\n  between the input and output of the rule `r` applied iteratively to the input\n  `data`, signaling completion.\n\n  See [[while]] for a similar function that treats its predicate differently."],null)),$APP.z(pOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.oO,tMb,Clb],null))),$APP.P,"Takes a rule `r` and returns a new rule that calls `r` with its input.\n\n  The returned rule returns:\n\n  - `(succeed-r (r data)) if `(r data)` is successful,\n  - `(fail-r data) otherwise."],
null)),$APP.z(Qeb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Rule that always fails with an explicit `failure`, no matter the input."],null)),frb,$APP.z(nEb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,pX],null))),$APP.P,"Given some number of `rules`, returns a new rule that will attempt to apply\n  each rule to its input expression (and every subexpression of the input,\n  bottom up), iterating until no rule causes any change in any level of the\n  supplied expression.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(pX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,pX],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(cY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Nv],null))),$APP.P,"Takes a rule `r` and returns a new version of `r` tagged with a unique `id`.\n  The returned rule calls the side-effecting `f` with\n\n  ```clojure\n  {:id id, :in data}\n  ```\n\n  Before calling `r` with `data`, and calls `f` with\n\n  ```clojure\n  {:id id, :out (r data)}\n  ```\n\n  when the rule returns.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Nv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Nv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(xHb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Lh,MW],
null))),$APP.P,"Accepts any number of `rules` and returns a new `rule` that attempts to pipe\n  its input `data` through each rule in `rules`. Only succeeds if every rule\n  succeeds on the previous rule's successful output.\n\n  NOTE: The zero-arity `(pipe)` returns [[pass]], a rule that succeeds for any\n  input by returning the input unchanged.\n\n  See [[pipe*]] for an identical function that accepts an explicit sequence.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,
2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.oO],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Lh,MW],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(X$b,new $APP.f(null,3,[$APP.P,"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,gJ)],null)),$APP.z(OIb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Lh,MW],null))),$APP.P,"Accepts any number of `rules` and returns a new `rule` that attempts to apply\n  each rule in `rules` to its input data. Returns the first non-failing rule's\n  result, or `failure` if no rule succeeds.\n\n  NOTE: The zero-arity `(choice)` returns [[fail]], a rule that fails for any\n  input.\n\n  See [[choice*]] for an identical function that accepts an explicit sequence.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.oO],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Lh,MW],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(dWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.oO],null))),$APP.P,"Returns a rule that applies the rule `r` iteratively `n` times to the input\n  data, failing if any application fails.\n\n  For example, these forms are equivalent, except that the [[n-times]] version\n  will fail immediately if any application fails vs passing on its failure:\n\n  ```clojure\n  (n-times 3 my-rule)\n  (fn [data]\n    (my-rule (my-rule (my-rule data))))\n  ```"],
null)),$APP.z(wGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Takes a rule `r` and returns a new rule that applies `r` to `data` iteratively\n  until (\x3d input (r input))."],null)),$APP.z(F_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pX],null))),$APP.P,"Identical to the multi-arity [[pipe]], but accepts an explicit sequence."],null)),$APP.z(VFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Nv,$APP.oO],null))),$APP.P,"Takes a predicate function `f` and a rule `r`, and returns a new rule that will\n  return `(r data)` if `(f data)` is true, fail otherwise."],null)),$APP.z(Dbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.dx],null))),$APP.P,"Rule that always succeeds by returning its input data unchanged."],null)),$APP.z(e4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Similar to `clojure.core/iterate` for rule application.\n\n  Takes a rule `r` and returns a new rule that will return the last non-failing\n  result of the sequence `[data (r data) (r (r data)) ...]`\n\n  This might be `data` itself if `r` fails on first application. This means that\n  the returned rule will never fail."],
null)),Gob,RS,$APP.z(s0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Marks the supplied rule as an 'attempt' rule that won't fail."],null)),$APP.z(jzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Returns a rule that will pass its input data on unchanged if `(f data)` returns\n  true and fail otherwise."],null)),$APP.z(b6b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,
$APP.I,[$APP.Ev],null),new $APP.H(null,2,5,$APP.I,[$APP.Ev,$APP.Fy],null))),$APP.P,"Builds the pattern portion of a rule from the supplied pattern form or matcher\n  combinator and optional predicate `pred`.\n\n  See [[emmy.pattern.syntax]] for the allowed syntax pattern, or [[emmy.pattern.match]]\n  for details on matcher combinators.\n\n  See [[match/matcher]] for more detailed documentation.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,
1,5,$APP.I,[$APP.Ev],null),new $APP.H(null,2,5,$APP.I,[$APP.Ev,$APP.Fy],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),new $APP.H(null,2,5,$APP.I,[$APP.Ev,$APP.Fy],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(b_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[pX],null))),$APP.P,"Identical to the multi-arity [[choice]], but accepts an explicit sequence."],null)),$APP.z(fYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,
5,$APP.I,[LHb,$APP.gx],null))),$APP.P,"Functional version of [[rule]]. See [[rule]] for documentation."],null)),$APP.z(TIb,new $APP.f(null,3,[$APP.P,"Returns true if `x` is equivalent to the failure sentinel [[failure]], false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,T1b)],null)),$APP.z(FGb,new $APP.f(null,2,[$APP.P,"Singleton object representing the failure of a matcher to match its input.\n  Check for failure with [[failed?]]",
lU,$APP.M($APP.K,Z_b)],null)),$APP.z(Vqb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,pX],null))),$APP.P,"Given some number of `rules`, returns a new rule that will act like [[choice]]\n  and attempt to apply each rule to the input data, returning the first match.\n\n  If all `rules` fail, the returned rule will return its input `data`.\n\n  See [[ruleset]] for a macro that allows inline rule definition.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,
0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(pX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,pX],null)),$APP.Cx,$APP.M(null)],null)],null)),Rdc,$APP.z(uQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns a rule that matches any input and always returns `x`."],null)),afb,$APP.z(L4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MY],null))),$APP.P,"Given some rule `the-rule`, returns a new rule that accepts potentially nested\n  `data` and applies `the-rule` to all subexpressions in depth-first order, from\n  the leaves on up.\n\n  The transformation is applied a single time to all subexpressions.\n  See [[iterated-bottom-up]] for a version that will iterate to convergence."],
null)),$APP.z($APP.Hx,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.oO],null))),$APP.P,"Returns a new rule which repeatedly applies `r` as long as `f` continues to\n  return `true` between the input and output of the rule `r` applied iteratively\n  to the input `data`.\n\n  See [[until]] for a similar function that treats its predicate differently."],null))],[new $APP.f(null,3,[$APP.Q,PXb,$APP.X,$1,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[rule-simplifier]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,pX],null))],null)],null),new $APP.f(null,3,[$APP.Q,Aib,$APP.X,zJ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Qbb,$APP.X,function(a){var b=pJ(a);return nJ(function g(d){d=pYa(g,b.j?b.j(d):b.call(null,d));return b.j?b.j(d):b.call(null,d)})},$APP.h,new $APP.f(null,2,[$APP.P,"Given some rule `the-rule`, returns a new rule that accepts potentially nested\n  `data` and applies `the-rule` to all subexpressions on the way down AND back\n  up a traversal. This is a sort of hybrid of breadth-first, depth-first.\n\n  The transformation is applied a single time to all subexpressions.\n  See [[iterated-top-down]] for a version that will iterate to convergence.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MY],null))],null)],null),new $APP.f(null,3,[$APP.Q,S0b,$APP.X,pJ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a rule `r` and returns a new rule that return either `(r data)` if `r` is\n  successful, or its original input on failure.\n\n  NOTE that the returned rule will never fail! This makes it inappropriate to\n  use with [[choice]], for example, if you expect any rule supplied after this\n  one to ever be matched. [[attempt]] rules are great choices for the final rule\n  passed to [[choice]], however.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,yJb,$APP.X,Z1,$APP.h,new $APP.f(null,4,[$APP.P,"Accepts triplets of the form:\n\n  \x3cpattern\x3e \x3cpredicate\x3e \x3cconsequence-template\x3e\n\n  and returns a new rule that will attempt to match the rules compiled from each\n  triplet in sequence, returning the filled-in `\x3cconsequence-template\x3e` of the\n  first successful match.\n\n  If none of the rules match, the returned rule returns its input data\n  unchanged.\n\n  See [[ruleset*]] for a function version that takes explicit\n  already-constructed rules.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,bvb],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,RVb,$APP.X,nYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `r` was marked as an 'attempt' rule, i.e., a rule that will\n  never fail, but return its input on a failed match.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,KPb,$APP.X,function(a){var b=pJ(a),c=$APP.kh.j(null);$APP.Ne(c,$APP.mh(function(d){var g=b.j?b.j(d):
b.call(null,d);if($APP.Uc.A(g,d)){d=pYa($APP.Fb(c),d);g=b.j?b.j(d):b.call(null,d);if($APP.Uc.A(g,d))return g;d=$APP.Fb(c);return d.j?d.j(g):d.call(null,g)}d=$APP.Fb(c);return d.j?d.j(g):d.call(null,g)}));return nJ($APP.Fb(c))},$APP.h,new $APP.f(null,2,[$APP.P,"Version of [[top-down]] that iterates on each subexpression to convergence\n  before each subexpression returns. Any change in a subexpression triggers a\n  new iterated-top-down replacement of that subexpression.\n\n  The returned rule keeps an internal memoization cache and will return\n  immediately for subexpressions it's seen before.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MY],null))],null)],null),new $APP.f(null,3,[$APP.Q,ejb,$APP.X,qYa,$APP.h,new $APP.f(null,2,[$APP.P,"Version of [[bottom-up]] that iterates on each subexpression to convergence\n  before each subexpression returns. Any change in a subexpression triggers a\n  new iterated-bottom-up replacement of that subexpression.\n\n  The returned rule keeps an internal memoization cache and will return\n  immediately for subexpressions it's seen before.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[MY],null))],null)],null),new $APP.f(null,3,[$APP.Q,uVb,$APP.X,oYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new rule which repeatedly applies `r` until `f` returns `true`\n  between the input and output of the rule `r` applied iteratively to the input\n  `data`, signaling completion.\n\n  See [[while]] for a similar function that treats its predicate differently.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,Q_b,$APP.X,function(a,
b,c){return function(d){var g=a.j?a.j(d):a.call(null,d);return $APP.k(jJ.j?jJ.j(g):jJ.call(null,g))?c.j?c.j(d):c.call(null,d):b.j?b.j(g):b.call(null,g)}},$APP.h,new $APP.f(null,2,[$APP.P,"Takes a rule `r` and returns a new rule that calls `r` with its input.\n\n  The returned rule returns:\n\n  - `(succeed-r (r data)) if `(r data)` is successful,\n  - `(fail-r data) otherwise.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.oO,tMb,Clb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Geb,$APP.X,hYa,
$APP.h,new $APP.f(null,2,[$APP.P,"Rule that always fails with an explicit `failure`, no matter the input.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.Q,jtb,$APP.X,V1,$APP.h,new $APP.f(null,4,[$APP.P,"Provided with a single `form`, [[template]] is similar to Clojure's `unquote`\n  facility, except that symbols are not prefixed by namespace. For example:\n\n  ```clojure\n  (let [x 10]\n    (template (+ ~x y z ~@[4 5])))\n  ;;\x3d\x3e (+ 10 y z 4 5)\n  ```\n\n  When you provide a binding map `m`, [[template]] returns its input form, but\n  replaces any:\n\n  - variable binding form like `?x`\n  - segment binding form like `??x`\n  - reverse-segment binding form, like `$$x`\n\n  with the appropriate entry in `m`. (`m` can be a symbol referencing a binding\n  map in the environment.)\n\n  Splices and unquote splices are respected. For example:\n\n  ```clojure\n  (let [m {'?x 10 '?y 12 '??z [1 2 3]}]\n    (template m (+ ?x ?y ??z ~m ~@[1 2])))\n  ;;\x3d\x3e (+ 10 12 1 2 3 {?x 10, ?y 12, ??z [1 2 3]} 1 2)\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.Ev],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,QRb,$APP.X,AJ,$APP.h,new $APP.f(null,2,[$APP.P,"Given some number of `rules`, returns a new rule that will attempt to apply\n  each rule to its input expression (and every subexpression of the input,\n  bottom up), iterating until no rule causes any change in any level of the\n  supplied expression.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,pX],null))],null)],null),new $APP.f(null,3,[$APP.Q,z8b,$APP.X,Y1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a rule `r` and returns a new version of `r` tagged with a unique `id`.\n  The returned rule calls the side-effecting `f` with\n\n  ```clojure\n  {:id id, :in data}\n  ```\n\n  Before calling `r` with `data`, and calls `f` with\n\n  ```clojure\n  {:id id, :out (r data)}\n  ```\n\n  when the rule returns.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,
2,5,$APP.I,[$APP.oO,$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,x7b,$APP.X,qJ,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts any number of `rules` and returns a new `rule` that attempts to pipe\n  its input `data` through each rule in `rules`. Only succeeds if every rule\n  succeeds on the previous rule's successful output.\n\n  NOTE: The zero-arity `(pipe)` returns [[pass]], a rule that succeeds for any\n  input by returning the input unchanged.\n\n  See [[pipe*]] for an identical function that accepts an explicit sequence.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Lh,MW],null))],null)],null),new $APP.f(null,3,[$APP.Q,BHb,$APP.X,fJ,$APP.h,new $APP.f(null,3,[$APP.P,"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,gJ],null)],null),new $APP.f(null,3,[$APP.Q,Tgb,$APP.X,oJ,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts any number of `rules` and returns a new `rule` that attempts to apply\n  each rule in `rules` to its input data. Returns the first non-failing rule's\n  result, or `failure` if no rule succeeds.\n\n  NOTE: The zero-arity `(choice)` returns [[fail]], a rule that fails for any\n  input.\n\n  See [[choice*]] for an identical function that accepts an explicit sequence.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.oO],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Lh,MW],null))],null)],null),new $APP.f(null,3,[$APP.Q,lZb,$APP.X,function(a,b){return lYa($APP.Vj.A(a,b))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule that applies the rule `r` iteratively `n` times to the input\n  data, failing if any application fails.\n\n  For example, these forms are equivalent, except that the [[n-times]] version\n  will fail immediately if any application fails vs passing on its failure:\n\n  ```clojure\n  (n-times 3 my-rule)\n  (fn [data]\n    (my-rule (my-rule (my-rule data))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,LSb,$APP.X,function(a){return oYa($APP.Uc,a)},$APP.h,new $APP.f(null,2,[$APP.P,"Takes a rule `r` and returns a new rule that applies `r` to `data` iteratively\n  until (\x3d input (r input)).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,VPb,$APP.X,lYa,$APP.h,new $APP.f(null,2,[$APP.P,"Identical to the multi-arity [[pipe]], but accepts an explicit sequence.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pX],null))],null)],null),new $APP.f(null,3,[$APP.Q,oob,$APP.X,rJ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a predicate function `f` and a rule `r`, and returns a new rule that will\n  return `(r data)` if `(f data)` is true, fail otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,Hyb,$APP.X,gYa,$APP.h,new $APP.f(null,2,[$APP.P,"Rule that always succeeds by returning its input data unchanged.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.dx],null))],null)],null),new $APP.f(null,3,[$APP.Q,hpb,$APP.X,function(a){return nJ(function(b){for(;;){var c=a.j?a.j(b):a.call(null,b);if($APP.k(jJ.j?jJ.j(c):jJ.call(null,c)))return b;b=c}})},$APP.h,new $APP.f(null,2,[$APP.P,"Similar to `clojure.core/iterate` for rule application.\n\n  Takes a rule `r` and returns a new rule that will return the last non-failing\n  result of the sequence `[data (r data) (r (r data)) ...]`\n\n  This might be `data` itself if `r` fails on first application. This means that\n  the returned rule will never fail.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,Zgb,$APP.X,function(a,b,c){$APP.rg.B(b,BX,!0);a=$APP.Oj.J();return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.ay,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.j(new $APP.D(null,a,null,1,null))))),null,1,null),$APP.y([new $APP.D(null,UXa(a,c),null,1,null)]))))},$APP.h,new $APP.f(null,4,[$APP.P,"Accepts a skeleton expression `form` and returns a function from a pattern\n  matcher's binding map to a data structure of identical shape to `skel`, with:\n\n  - all variable binding forms like `?x` replaced by their entries in the\n    binding map\n  - same with any segment or reverse-segment binding form like `??x` or `$$x`,\n    with the added note that these will be spliced in\n  - any `unquote` or `unquote-splicing` forms respected.\n\n  Compared to [[template]], these two forms are equivalent:\n\n  ```clojure\n  (fn [m] (template m \x3cform\x3e))\n  (consequence \x3cform\x3e)\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,L2b,$APP.X,U1,$APP.h,new $APP.f(null,4,[$APP.P,"Takes an unevaluated pattern form (or matcher combinator) and an optional\n  predicate `pred`, and returns a matcher appropriate for passing to [[rule*]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),new $APP.H(null,2,5,$APP.I,[$APP.Ev,$APP.Fy],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,yob,$APP.X,
nJ,$APP.h,new $APP.f(null,2,[$APP.P,"Marks the supplied rule as an 'attempt' rule that won't fail.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,RLb,$APP.X,iYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule that will pass its input data on unchanged if `(f data)` returns\n  true and fail otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,a0b,$APP.X,xJ,$APP.h,new $APP.f(null,2,[$APP.P,
"Builds the pattern portion of a rule from the supplied pattern form or matcher\n  combinator and optional predicate `pred`.\n\n  See [[emmy.pattern.syntax]] for the allowed syntax pattern, or [[emmy.pattern.match]]\n  for details on matcher combinators.\n\n  See [[match/matcher]] for more detailed documentation.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null),new $APP.H(null,2,5,$APP.I,[$APP.Ev,$APP.Fy],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ucb,$APP.X,kYa,$APP.h,new $APP.f(null,
2,[$APP.P,"Identical to the multi-arity [[choice]], but accepts an explicit sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[pX],null))],null)],null),new $APP.f(null,3,[$APP.Q,fub,$APP.X,mJ,$APP.h,new $APP.f(null,2,[$APP.P,"Functional version of [[rule]]. See [[rule]] for documentation.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[LHb,$APP.gx],null))],null)],null),new $APP.f(null,3,[$APP.Q,H8b,$APP.X,jJ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` is equivalent to the failure sentinel [[failure]], false\n  otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,T1b],null)],null),new $APP.f(null,3,[$APP.Q,$dc,$APP.X,lJ,$APP.h,new $APP.f(null,2,[$APP.P,"Singleton object representing the failure of a matcher to match its input.\n  Check for failure with [[failed?]]",lU,Z_b],null)],null),new $APP.f(null,3,[$APP.Q,kub,$APP.X,wJ,$APP.h,new $APP.f(null,2,[$APP.P,"Given some number of `rules`, returns a new rule that will act like [[choice]]\n  and attempt to apply each rule to the input data, returning the first match.\n\n  If all `rules` fail, the returned rule will return its input `data`.\n\n  See [[ruleset]] for a macro that allows inline rule definition.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,pX],null))],null)],null),new $APP.f(null,3,[$APP.Q,brb,$APP.X,xpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,hnb,$APP.X,jYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule that matches any input and always returns `x`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ieb,$APP.X,X1,$APP.h,new $APP.f(null,4,[$APP.P,"Accepts either:\n\n  - A pattern written using the syntax from `emmy.pattern.syntax` and a consequence\n    function from binding map \x3d\x3e failure or return form, or\n  - A pattern, predicate and a consequence _skeleton_,\n\n  And returns a rule. A rule is a function from some data object to either\n\n  - A special `failure` singleton (test for this with [[failed?]]), or\n  - A successful transformation provided by a consequence function.\n\n  In the 2-argument case, you must provide an explicit function of the binding\n  map. A return of `failure`, `nil` or `false` will cause the whole rule to\n  fail. To successfully return `nil` or `false`, wrap the result in [[succeed]].\n\n  Notes for the 3-argument case:\n\n  - If the predicate returns `nil`, `false` or `failure`, the rule fails.\n\n  - The predicate can succeed by returning anything else. If the return value is\n    a map, the rule will call the consequence function with this map merged in to\n    the bindings.\n\n  - the third form is a consequence 'skeleton' instead of an explicit function\n    See [[consequence]] for details.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[RS,gdc],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Fy,Cvb],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,Pfb,$APP.X,function(a){var b=pJ(a);return nJ(function g(d){d=pYa(g,d);return b.j?b.j(d):b.call(null,d)})},$APP.h,new $APP.f(null,2,[$APP.P,"Given some rule `the-rule`, returns a new rule that accepts potentially nested\n  `data` and applies `the-rule` to all subexpressions in depth-first order, from\n  the leaves on up.\n\n  The transformation is applied a single time to all subexpressions.\n  See [[iterated-bottom-up]] for a version that will iterate to convergence.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MY],null))],null)],null),new $APP.f(null,3,[$APP.Q,cJb,$APP.X,function(a,b){return nJ(function g(d){return qJ.C(pJ(b),$APP.y([function(l){return $APP.k(a.A?a.A(d,l):a.call(null,d,l))?g(l):l}]))(d)})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new rule which repeatedly applies `r` as long as `f` continues to\n  return `true` between the input and output of the rule `r` applied iteratively\n  to the input `data`.\n\n  See [[until]] for a similar function that treats its predicate differently.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.oO],null))],null)],null)]),$APP.ap(N0b)),$APP.cp(new $APP.f(null,7,[$APP.z(NTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.ix],null))),$APP.P,"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`."],null)),new $APP.f(null,3,[$APP.Q,xdc,$APP.X,J2a,$APP.h,new $APP.f(null,2,[$APP.P,"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.wU,$APP.ix],null))],null)],null),$APP.z($APP.$wa,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.ix],null))),$APP.P,"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`."],null)),new $APP.f(null,3,[$APP.Q,b2b,$APP.X,K2a,$APP.h,new $APP.f(null,2,[$APP.P,"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.ix],null))],
null)],null),$APP.z(ncb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null))),$APP.P,"Returns an infinite sequence of `x * n^i`, starting with `i \x3d\x3d 0`. `x` defaults\n  to 1.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Dub,$APP.X,JQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an infinite sequence of `x * n^i`, starting with `i \x3d\x3d 0`. `x` defaults\n  to 1.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null))],null)],null),$APP.z(jDb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),
new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null))),$APP.P,"Returns an infinite sequence of `x / n^i`, starting with `i \x3d\x3d 0`. `x` defaults\n  to 1.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),
new $APP.f(null,3,[$APP.Q,PTb,$APP.X,X2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an infinite sequence of `x / n^i`, starting with `i \x3d\x3d 0`. `x` defaults\n  to 1.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null))],null)],null),$APP.z(ACb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null))),$APP.P,"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$."],
null)),new $APP.f(null,3,[$APP.Q,LLb,$APP.X,L2a,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null))],null)],null),$APP.z(Zzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Fy,$APP.xx],null))),$APP.P,"Returns a pair of vectors:\n\n  - the first contains the items in coll for which (pred item) returns true\n  - the second contains the items for which (pred item) returns false\n\n  pred must be free of side-effects."],
null)),new $APP.f(null,3,[$APP.Q,I_b,$APP.X,function(a,b){var c=$APP.Id.B(function(d,g){var l=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return $APP.k(a.j?a.j(g):a.call(null,g))?new $APP.H(null,2,5,$APP.I,[$APP.mf.A(l,g),d],null):new $APP.H(null,2,5,$APP.I,[l,$APP.mf.A(d,g)],null)},new $APP.H(null,2,5,$APP.I,[$APP.bc($APP.sf),$APP.bc($APP.sf)],null),b);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);return new $APP.H(null,2,5,$APP.I,[$APP.dc(b),$APP.dc(c)],null)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a pair of vectors:\n\n  - the first contains the items in coll for which (pred item) returns true\n  - the second contains the items for which (pred item) returns false\n\n  pred must be free of side-effects.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Fy,$APP.xx],null))],null)],null),$APP.z($rb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,2,5,$APP.I,[$APP.ix,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,4,5,$APP.I,[zV,Keb,SX,fT],null),$APP.Ml,new $APP.f(null,3,[zV,2,SX,g2b,fT,$APP.M(uJb,SX)],null)],null)],null))),$APP.P,"Accepts a sequence, iterates through it and returns a dictionary of this form:\n\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3csequence element\x3e}\n\n  `:converged?` is true if the sequence reached convergence by passing the tests\n  described below, false otherwise.\n\n  `:terms-checked` will be equal to the number of items examined in the\n  sequence.\n\n  `:result` holds the final item examined in the sequence.\n\n  ## Optional keyword args:\n\n  `:convergence-fn` user-supplied function of two successive elements in `xs`\n  that stops iteration and signals convergence if it returns true.\n\n  `:minterms` `seq-limit` won't return until at least this many terms from the\n  sequence have been processed.\n\n  `:maxterms` `seq-limit` will return (with `:converged? false`) after\n  processing this many elements without passing any other checks.\n\n  `:tolerance` A combination of relative and absolute tolerance. defaults to\n  `sqrt(machine epsilon)`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,2,5,$APP.I,[$APP.ix,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,4,5,$APP.I,[zV,Keb,SX,fT],null),$APP.Ml,new $APP.f(null,3,[zV,2,SX,g2b,fT,$APP.M(uJb,SX)],null)],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,2,5,$APP.I,[$APP.ix,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,4,5,$APP.I,[zV,Keb,SX,fT],null),
$APP.Ml,new $APP.f(null,3,[zV,2,SX,g2b,fT,$APP.M(uJb,SX)],null)],null)],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Pzb,$APP.X,FQ,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a sequence, iterates through it and returns a dictionary of this form:\n\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3csequence element\x3e}\n\n  `:converged?` is true if the sequence reached convergence by passing the tests\n  described below, false otherwise.\n\n  `:terms-checked` will be equal to the number of items examined in the\n  sequence.\n\n  `:result` holds the final item examined in the sequence.\n\n  ## Optional keyword args:\n\n  `:convergence-fn` user-supplied function of two successive elements in `xs`\n  that stops iteration and signals convergence if it returns true.\n\n  `:minterms` `seq-limit` won't return until at least this many terms from the\n  sequence have been processed.\n\n  `:maxterms` `seq-limit` will return (with `:converged? false`) after\n  processing this many elements without passing any other checks.\n\n  `:tolerance` A combination of relative and absolute tolerance. defaults to\n  `sqrt(machine epsilon)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,2,5,$APP.I,[$APP.ix,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,4,5,$APP.I,[zV,Keb,SX,fT],null),$APP.Ml,new $APP.f(null,3,[zV,2,SX,g2b,fT,$APP.M(uJb,SX)],null)],null)],null))],null)],null)],null),$APP.ap(A8b)),$APP.cp($APP.fg([$APP.z($nb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` implements [[IFrame]], false otherwise."],null)),$APP.z(umb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.pW,h6b],null))),$APP.P,"Marks (via metadata) the supplied set of `coords` as being owned by `owner`. If\n  `coords` already has an owner (that is not equal to `owner`), throws."],null)),$APP.z(WUb,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,new $APP.f(null,5,[$APP.z(fHb,new $APP.f(null,1,[$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not."],
null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)],null),$APP.z($vb,new $APP.f(null,1,[$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.Qx],null)],null),$APP.z(sS,new $APP.f(null,1,[$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor."],null)),new $APP.H(null,
1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null),$APP.z(vZb,new $APP.f(null,1,[$APP.P,"Returns the symbolic name of the suppplied frame."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null),$APP.z($APP.Iw,new $APP.f(null,1,[$APP.P,"Returns the parameters registered with the supplied frame."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null)],null)],null),$APP.Ov,new $APP.f(null,5,[jjb,new $APP.f(null,3,[$APP.Q,fHb,$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)),$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not."],null),lLb,new $APP.f(null,3,[$APP.Q,$vb,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.Qx],null)),$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`."],
null),o4b,new $APP.f(null,3,[$APP.Q,sS,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)),$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor."],null),r1b,new $APP.f(null,3,[$APP.Q,vZb,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)),$APP.P,"Returns the symbolic name of the suppplied frame."],null),$APP.fm,new $APP.f(null,3,[$APP.Q,$APP.Iw,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)),$APP.P,"Returns the parameters registered with the supplied frame."],
null)],null),gU,$APP.M("@interface")],null)),$APP.z($vb,new $APP.f(null,3,[$APP.Pm,xX,$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.Qx],null)))],null)),$APP.z(QPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null))),$APP.P,"Returns the owning [[IFrame]] instance of the supplied coordinates `coords`,\n  nil if there's no owner otherwise."],
null)),$APP.z(BQb,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[nS,"null",xX,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,7,5,$APP.I,[sX,aT,zQb,$APP.Yw,sS,$APP.Iw,FJb],null))),$APP.P,"Positional factory function for emmy.calculus.frame/t_emmy$calculus$frame49168."],null)),$APP.z($APP.Iw,new $APP.f(null,3,[$APP.Pm,xX,$APP.P,"Returns the parameters registered with the supplied frame.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],null)),$APP.z(sS,new $APP.f(null,3,[$APP.Pm,xX,$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],null)),$APP.z(fHb,new $APP.f(null,3,[$APP.Pm,xX,$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)))],null)),$APP.z(yRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Returns true if `e` is an event, false otherwise.\n\n  Make new events with [[make-event]]."],null)),$APP.z(tac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),$APP.P,"Marks the input event `e` as an event via its metadata. The return value will\n  return `true` when passed to [[event?]]."],
null)),$APP.z(vZb,new $APP.f(null,3,[$APP.Pm,xX,$APP.P,"Returns the symbolic name of the suppplied frame.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],null)),$APP.z(XMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[sX,aT],null))),$APP.P,"Takes:\n\n  - `c-\x3ee`, a function mapping coordinates to events\n  - `e-\x3ec`, a function mapping events to coordinates\n\n  and returns a function that takes:\n\n  - a symbolic name\n  - an ancestor frame\n  - a dictionary of params\n\n  and returns instance of [[IFrame]].\n\n  Both `c-\x3ee` and `e-\x3ec` must accept three arguments:\n\n  - `ancestor-frame`\n  - the [[IFrame]] instance\n  - a map of parameters supplied to the returned function (possibly empty!)."],
null))],[new $APP.f(null,3,[$APP.Q,gxb,$APP.X,z2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` implements [[IFrame]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ffb,$APP.X,F2a,$APP.h,new $APP.f(null,2,[$APP.P,"Marks (via metadata) the supplied set of `coords` as being owned by `owner`. If\n  `coords` already has an owner (that is not equal to `owner`), throws.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.pW,h6b],
null))],null)],null),new $APP.f(null,3,[$APP.Q,xX,$APP.X,x2a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,g6b,$APP.X,cO,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.Qx],null))],null)],null),new $APP.f(null,3,[$APP.Q,ELb,$APP.X,E2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the owning [[IFrame]] instance of the supplied coordinates `coords`,\n  nil if there's no owner otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null))],null)],null),new $APP.f(null,3,[$APP.Q,bXb,$APP.X,H2a,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.frame/t_emmy$calculus$frame49168.",$APP.U,$APP.M(new $APP.H(null,7,5,$APP.I,[sX,aT,zQb,$APP.Yw,sS,$APP.Iw,FJb],null))],null)],null),new $APP.f(null,3,[$APP.Q,EYb,$APP.X,eO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the parameters registered with the supplied frame.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],
null))],null)],null),new $APP.f(null,3,[$APP.Q,emb,$APP.X,y2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.Q,RSb,$APP.X,bO,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null))],null)],null),new $APP.f(null,3,[$APP.Q,J$b,$APP.X,C2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `e` is an event, false otherwise.\n\n  Make new events with [[make-event]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.Q,esb,$APP.X,B2a,$APP.h,new $APP.f(null,2,[$APP.P,"Marks the input event `e` as an event via its metadata. The return value will\n  return `true` when passed to [[event?]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))],null)],null),new $APP.f(null,3,[$APP.Q,NOb,$APP.X,dO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the symbolic name of the suppplied frame.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.Q,oSb,$APP.X,I2a,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - `c-\x3ee`, a function mapping coordinates to events\n  - `e-\x3ec`, a function mapping events to coordinates\n\n  and returns a function that takes:\n\n  - a symbolic name\n  - an ancestor frame\n  - a dictionary of params\n\n  and returns instance of [[IFrame]].\n\n  Both `c-\x3ee` and `e-\x3ec` must accept three arguments:\n\n  - `ancestor-frame`\n  - the [[IFrame]] instance\n  - a map of parameters supplied to the returned function (possibly empty!).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[sX,aT],null))],null)],null)]),$APP.ap(obb)),$APP.cp($APP.fg([$APP.z(cmb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Yw,$APP.iy,bZb],null)))],null)),$APP.z(h5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))),$APP.P,"Defined on FDG p.72."],null)),$APP.z(Rgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))),$APP.P,"Defined on FDG p.72."],null)),$APP.z($ub,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,q9b],null)))],null)),$APP.z(j0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null)))],null)),$APP.z(ECb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[TX],null)))],null)),$APP.z(m5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null),new $APP.H(null,2,5,$APP.I,[MT,TX],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,
2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[MT],null),new $APP.H(null,2,5,$APP.I,[MT,TX],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null),new $APP.H(null,2,5,$APP.I,[MT,TX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(Rub,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,TX],null)))],null)),$APP.z(nCb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,TX],null)))],null)),$APP.z($Zb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))),$APP.P,"Returns a function which will pull a form back across a map (without needing\n  its inverse)"],null)),Xhb,$APP.z(k5a,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null)))],null))],[new $APP.f(null,3,[$APP.Q,FRb,$APP.X,g5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Yw,$APP.iy,bZb],null))],null)],null),new $APP.f(null,3,[$APP.Q,CNb,$APP.X,i5a,$APP.h,new $APP.f(null,
2,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))],null)],null),new $APP.f(null,3,[$APP.Q,LAb,$APP.X,CP,$APP.h,new $APP.f(null,2,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))],null)],null),new $APP.f(null,3,[$APP.Q,rQb,$APP.X,l5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,q9b],null))],null)],null),new $APP.f(null,3,[$APP.Q,pWb,$APP.X,c5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,
$APP.I,[MT],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xyb,$APP.X,d5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[TX],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lqb,$APP.X,K3,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null),new $APP.H(null,2,5,$APP.I,[MT,TX],null))],null)],null),new $APP.f(null,3,[$APP.Q,nkb,$APP.X,o5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,TX],null))],null)],null),new $APP.f(null,3,[$APP.Q,
Lub,$APP.X,f5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,TX],null))],null)],null),new $APP.f(null,3,[$APP.Q,YOb,$APP.X,n5a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function which will pull a form back across a map (without needing\n  its inverse)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))],null)],null),new $APP.f(null,3,[$APP.Q,kHb,$APP.X,CP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,QKb,$APP.X,DP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[MT],null))],null)],null)]),$APP.ap($Tb)),$APP.cp(new $APP.f(null,1,[$APP.z(FLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Iy,$APP.PW,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.Gw],null),$APP.dk,$APP.Ox],null)],null))),$APP.P,"Find the minimum of the function f: R^n -\x3e R, given an initial point q ∈ R^n.\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked with iteration count,\n  the values of X and the value of f(X) at each intermediate point of\n  evaluation.\n\n  `:info?` if true, wraps the result with evaluation information.\n\n  `:adaptive?` if true, the Nelder-Mead parameters for contraction, expansion,\n  reflection and shrinking will be set adaptively, as functions of the number of\n  dimensions. If false they stay constant.\n\n  `:alpha` sets the reflection coefficient used for each step of Nelder-Mead.\n\n  `:beta` sets the expansion coefficient used for each step of Nelder-Mead.\n\n  `:gamma` sets the contraction coefficient used for each step of Nelder-Mead.\n\n  `:sigma` sets the shrink coefficient used for each step of Nelder-Mead.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  200*dimension.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 200*dimension.\n\n  `:simplex-tolerance` When the absolute value of the max difference between the\n  best point and any point in the simplex falls below this tolerance, the\n  minimizer stops. Defaults to 1e-4.\n\n  `:fn-tolerance` When the absolute value of the max difference between the best\n  point's function value and the fn value of any point in the simplex falls\n  below this tolerance, the minimizer stops. Defaults to 1e-4.\n\n  `:zero-delta` controls the value to which 0 entries in the initial vector are\n  set during initial simplex generation. Defaults to 0.00025.\n\n  `:nonzero-delta` factor by which entries in the initial vector are perturbed to\n  generate the initial simplex. Defaults to 0.05.\n\n  See Gao, F. and Han, L.\n      Implementing the Nelder-Mead simplex algorithm with adaptive\n      parameters. 2012. Computational Optimization and Applications.\n      51:1, pp. 259-277\n  I gratefully acknowledge the [Python implementation in\n  SciPy](https://github.com/scipy/scipy/blob/589c9afe41774ee96ec121f1867361146add8276/scipy/optimize/optimize.py#L556:5)\n  which I have imitated here.\n  "],
null)),new $APP.f(null,3,[$APP.Q,KUb,$APP.X,v7a,$APP.h,new $APP.f(null,2,[$APP.P,"Find the minimum of the function f: R^n -\x3e R, given an initial point q ∈ R^n.\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked with iteration count,\n  the values of X and the value of f(X) at each intermediate point of\n  evaluation.\n\n  `:info?` if true, wraps the result with evaluation information.\n\n  `:adaptive?` if true, the Nelder-Mead parameters for contraction, expansion,\n  reflection and shrinking will be set adaptively, as functions of the number of\n  dimensions. If false they stay constant.\n\n  `:alpha` sets the reflection coefficient used for each step of Nelder-Mead.\n\n  `:beta` sets the expansion coefficient used for each step of Nelder-Mead.\n\n  `:gamma` sets the contraction coefficient used for each step of Nelder-Mead.\n\n  `:sigma` sets the shrink coefficient used for each step of Nelder-Mead.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  200*dimension.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 200*dimension.\n\n  `:simplex-tolerance` When the absolute value of the max difference between the\n  best point and any point in the simplex falls below this tolerance, the\n  minimizer stops. Defaults to 1e-4.\n\n  `:fn-tolerance` When the absolute value of the max difference between the best\n  point's function value and the fn value of any point in the simplex falls\n  below this tolerance, the minimizer stops. Defaults to 1e-4.\n\n  `:zero-delta` controls the value to which 0 entries in the initial vector are\n  set during initial simplex generation. Defaults to 0.00025.\n\n  `:nonzero-delta` factor by which entries in the initial vector are perturbed to\n  generate the initial simplex. Defaults to 0.05.\n\n  See Gao, F. and Han, L.\n      Implementing the Nelder-Mead simplex algorithm with adaptive\n      parameters. 2012. Computational Optimization and Applications.\n      51:1, pp. 259-277\n  I gratefully acknowledge the [Python implementation in\n  SciPy](https://github.com/scipy/scipy/blob/589c9afe41774ee96ec121f1867361146add8276/scipy/optimize/optimize.py#L556:5)\n  which I have imitated here.\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Iy,$APP.PW,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.Gw],null),$APP.dk,$APP.Ox],null)],null))],null)],null)],null),$APP.ap(x0b)),$APP.cp($APP.fg([$APP.z(dmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[yU,$APP.vU,fX],null))),$APP.P,"Direct Clojure translation (via the Scheme translation in scmutils) of W.H.\n  Press, Numerical Recipes, subroutine `sncndn`.\n\n  Calls the supplied continuation `cont` with `sn`, `cn` and `dn` as defined\n  below.\n\n  If no `cont` is supplied, returns a three-vector of `sn`, `cn` and `dn`.\n\n  Comments from Press, page 261:\n\n  The Jacobian elliptic function sn is defined as follows: instead of\n  considering the elliptic integral\n\n  $$u(y, k) \\equiv u\x3dF(\\phi, k)$$\n\n  Consider the _inverse_ function:\n\n  ```\n  $$y \x3d \\sin \\phi \x3d \\mathrm{sn}(u, k)$$\n  ```\n\n  Equivalently,\n\n  ```\n  $$u\x3d\\int_{0}^{\\mathrm{sn}} \\frac{d y}{\\sqrt{\\left(1-y^{2}\\right)\\left(1-k^{2} y^{2}\\right)}}$$\n  ```\n\n  When $k \x3d 0$, $sn$ is just $\\sin$. The functions $cn$ and $dn$ are defined by\n  the relations\n\n  ```\n  $$\\mathrm{sn}^{2}+\\mathrm{cn}^{2}\x3d1, \\quad k^{2} \\mathrm{sn}^{2}+\\mathrm{dn}^{2}\x3d1$$\n  ```\n\n  The function calls the continuation with all three functions $sn$, $cn$, and\n  $dn$ since computing all three is no harder than computing any one of them.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[yU,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[yU,$APP.vU,fX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[yU,$APP.vU,fX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(bGb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.vU],null),new $APP.H(null,2,5,$APP.I,[ZR,$APP.vU],null))),$APP.P,
"Passing `k` returns the complete elliptic integral of the second kind - see\n  Press, 6.11.20.\n\n  The two-arity version returns the Legendre elliptic integral of the second\n  kind E(φ, k). See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.20.\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.vU],null),new $APP.H(null,2,5,$APP.I,[ZR,$APP.vU],
null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.vU],null),new $APP.H(null,2,5,$APP.I,[ZR,$APP.vU],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(cGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[ZR,$APP.vU],null))),$APP.P,"Legendre elliptic integral of the first kind F(φ, k).\n   See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.19\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf)."],null)),$APP.z(qcb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null))),$APP.P,"Computes Carlson’s degenerate elliptic integral, $R_C(x, y)$. `x` must be\n  nonnegative and `y` must be nonzero. If `y \x3c 0`, the Cauchy principal value is\n  returned.\n\n  Internal details:\n\n  - `tiny` must be at least 5 times the machine underflow limit\n  - `big` at most one fifth the machine maximum overflow limit."],null)),$APP.z(Ncb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,
[$APP.Yv,$APP.UP,$APP.VP],null))),$APP.P,"From W.H. Press, Numerical Recipes in C++, 2ed. NR::rf from section 6.11\n\n  Here's the reference for what's going on here:\n  http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf\n\n  Comment from Press, page 257:\n\n  'Computes Carlson’s elliptic integral of the first kind, RF (x, y, z). x, y,\n  and z must be nonnegative, and at most one can be zero. TINY must be at least\n  5 times the machine underflow limit, BIG at most one fifth the machine\n  overflow limit.'\n\n  A value of 0.08 for the error tolerance parameter is adequate for single\n  precision (7 significant digits). Since the error scales as 6 n, we see that\n  0.0025 will yield double precision (16 significant digits) and require at most\n  two or three more iterations.'\n\n  This is called `Carlson-elliptic-1` in scmutils."],
null)),$APP.z(H0b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[ZR,$APP.wU,$APP.vU],null))),$APP.P,"The two-arity call returns the complete elliptic integral of the third kind -\n  see\n  https://en.wikipedia.org/wiki/Carlson_symmetric_form#Complete_elliptic_integrals\n  for reference.\n\n  The three-arity call returns the Legendre elliptic integral of the third kind\n  Π(φ, k). See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.21; Note that\n  our sign convention for `n` is opposite theirs.\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[ZR,$APP.wU,$APP.vU],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[ZR,$APP.wU,$APP.vU],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(Jyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.vU],null))),$APP.P,"Returns a pair of:\n\n  - the elliptic integral of the first kind, `K`\n  - the derivative `dK/dk`\n\n  evaluated at `k`."],
null)),$APP.z(pcb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null))),$APP.P,"Comment from Press, section 6.11, page 257:\n\n  'Computes Carlson’s elliptic integral of the second kind, RD(x, y, z). x and y must be\n  nonnegative, and at most one can be zero. z must be positive. TINY must be at least twice\n  the negative 2/3 power of the machine overflow limit. BIG must be at most 0.1 × ERRTOL\n  times the negative 2/3 power of the machine underflow limit.'\n\n  This is called `Carlson-elliptic-2` in scmutils."],
null)),$APP.z(ZFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.vU],null))),$APP.P,"Complete elliptic integral of the first kind - see Press, 6.11.18."],null)),$APP.z(Ocb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP,$APP.Sv],null))),$APP.P,"Computes\n  [Carlson’s elliptic\n  integral](https://en.wikipedia.org/wiki/Carlson_symmetric_form) of the third\n  kind, `RJ(x, y, z, p)`.\n\n  `x`, `y`, and `z` must be nonnegative, and at most one can be zero. `p` must\n  be nonzero.\n\n  If `p \x3c 0`, the Cauchy principal value is returned. `tiny` internally must be\n  at least twice the cube root of the machine underflow limit, `big` at most one\n  fifth the cube root of the machine overflow limit."],
null)),$APP.z(Wib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.vU,HT],null))),$APP.P,"Computes the first and second complete elliptic integrals at once, and passes\n  them to the supplied continuation as args `K` and `E`."],null))],[new $APP.f(null,3,[$APP.Q,Vkb,$APP.X,N4,$APP.h,new $APP.f(null,2,[$APP.P,"Direct Clojure translation (via the Scheme translation in scmutils) of W.H.\n  Press, Numerical Recipes, subroutine `sncndn`.\n\n  Calls the supplied continuation `cont` with `sn`, `cn` and `dn` as defined\n  below.\n\n  If no `cont` is supplied, returns a three-vector of `sn`, `cn` and `dn`.\n\n  Comments from Press, page 261:\n\n  The Jacobian elliptic function sn is defined as follows: instead of\n  considering the elliptic integral\n\n  $$u(y, k) \\equiv u\x3dF(\\phi, k)$$\n\n  Consider the _inverse_ function:\n\n  ```\n  $$y \x3d \\sin \\phi \x3d \\mathrm{sn}(u, k)$$\n  ```\n\n  Equivalently,\n\n  ```\n  $$u\x3d\\int_{0}^{\\mathrm{sn}} \\frac{d y}{\\sqrt{\\left(1-y^{2}\\right)\\left(1-k^{2} y^{2}\\right)}}$$\n  ```\n\n  When $k \x3d 0$, $sn$ is just $\\sin$. The functions $cn$ and $dn$ are defined by\n  the relations\n\n  ```\n  $$\\mathrm{sn}^{2}+\\mathrm{cn}^{2}\x3d1, \\quad k^{2} \\mathrm{sn}^{2}+\\mathrm{dn}^{2}\x3d1$$\n  ```\n\n  The function calls the continuation with all three functions $sn$, $cn$, and\n  $dn$ since computing all three is no harder than computing any one of them.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[yU,$APP.vU,fX],null))],null)],null),new $APP.f(null,3,[$APP.Q,I7b,$APP.X,L4,$APP.h,new $APP.f(null,2,[$APP.P,"Passing `k` returns the complete elliptic integral of the second kind - see\n  Press, 6.11.20.\n\n  The two-arity version returns the Legendre elliptic integral of the second\n  kind E(φ, k). See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.20.\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.vU],null),new $APP.H(null,2,5,$APP.I,[ZR,$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,J7b,$APP.X,jab,$APP.h,new $APP.f(null,2,[$APP.P,"Legendre elliptic integral of the first kind F(φ, k).\n   See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.19\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[ZR,$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,zPb,$APP.X,hab,$APP.h,
new $APP.f(null,2,[$APP.P,"Computes Carlson’s degenerate elliptic integral, $R_C(x, y)$. `x` must be\n  nonnegative and `y` must be nonzero. If `y \x3c 0`, the Cauchy principal value is\n  returned.\n\n  Internal details:\n\n  - `tiny` must be at least 5 times the machine underflow limit\n  - `big` at most one fifth the machine maximum overflow limit.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null))],null)],null),new $APP.f(null,3,[$APP.Q,yPb,$APP.X,NR,$APP.h,new $APP.f(null,2,[$APP.P,
"From W.H. Press, Numerical Recipes in C++, 2ed. NR::rf from section 6.11\n\n  Here's the reference for what's going on here:\n  http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf\n\n  Comment from Press, page 257:\n\n  'Computes Carlson’s elliptic integral of the first kind, RF (x, y, z). x, y,\n  and z must be nonnegative, and at most one can be zero. TINY must be at least\n  5 times the machine underflow limit, BIG at most one fifth the machine\n  overflow limit.'\n\n  A value of 0.08 for the error tolerance parameter is adequate for single\n  precision (7 significant digits). Since the error scales as 6 n, we see that\n  0.0025 will yield double precision (16 significant digits) and require at most\n  two or three more iterations.'\n\n  This is called `Carlson-elliptic-1` in scmutils.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null))],null)],null),new $APP.f(null,3,[$APP.Q,vpb,$APP.X,M4,$APP.h,new $APP.f(null,2,[$APP.P,"The two-arity call returns the complete elliptic integral of the third kind -\n  see\n  https://en.wikipedia.org/wiki/Carlson_symmetric_form#Complete_elliptic_integrals\n  for reference.\n\n  The three-arity call returns the Legendre elliptic integral of the third kind\n  Π(φ, k). See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.21; Note that\n  our sign convention for `n` is opposite theirs.\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[ZR,$APP.wU,$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,rtb,$APP.X,function(a){return $APP.Uc.A(a,0)?new $APP.H(null,2,5,$APP.I,[Math.PI/2,0],null):kab(a,function(b,c){return new $APP.H(null,2,5,$APP.I,[b,(c/(1-a*a)-b)/a],null)})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a pair of:\n\n  - the elliptic integral of the first kind, `K`\n  - the derivative `dK/dk`\n\n  evaluated at `k`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,uPb,$APP.X,gab,$APP.h,new $APP.f(null,2,[$APP.P,"Comment from Press, section 6.11, page 257:\n\n  'Computes Carlson’s elliptic integral of the second kind, RD(x, y, z). x and y must be\n  nonnegative, and at most one can be zero. z must be positive. TINY must be at least twice\n  the negative 2/3 power of the machine overflow limit. BIG must be at most 0.1 × ERRTOL\n  times the negative 2/3 power of the machine underflow limit.'\n\n  This is called `Carlson-elliptic-2` in scmutils.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null))],null)],null),new $APP.f(null,3,[$APP.Q,H7b,$APP.X,function(a){return jab(Math.PI/2,a)},$APP.h,new $APP.f(null,2,[$APP.P,"Complete elliptic integral of the first kind - see Press, 6.11.18.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,CPb,$APP.X,iab,$APP.h,new $APP.f(null,2,[$APP.P,"Computes\n  [Carlson’s elliptic\n  integral](https://en.wikipedia.org/wiki/Carlson_symmetric_form) of the third\n  kind, `RJ(x, y, z, p)`.\n\n  `x`, `y`, and `z` must be nonnegative, and at most one can be zero. `p` must\n  be nonzero.\n\n  If `p \x3c 0`, the Cauchy principal value is returned. `tiny` internally must be\n  at least twice the cube root of the machine underflow limit, `big` at most one\n  fifth the cube root of the machine overflow limit.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,iMb,$APP.X,kab,$APP.h,new $APP.f(null,2,[$APP.P,"Computes the first and second complete elliptic integrals at once, and passes\n  them to the supplied continuation as args `K` and `E`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.vU,HT],null))],null)],null)]),$APP.ap(mGb)),$APP.cp(new $APP.f(null,8,[$APP.z(Pwb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null))),$APP.P,"Identical to bracket-min, except brackets a maximum of the supplied fn.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null)),$APP.Cx,$APP.M(null,null)],null)],null)),
new $APP.f(null,3,[$APP.Q,FZb,$APP.X,X3,$APP.h,new $APP.f(null,2,[$APP.P,"Identical to bracket-min, except brackets a maximum of the supplied fn.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null))],null)],null),$APP.z(olb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[RW,NVb],null),new $APP.H(null,2,5,$APP.I,[SW,OVb],null),new $APP.H(null,2,5,$APP.I,[QTb,PVb],null)],null),new $APP.f(null,
1,[$APP.eta,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Xh,new $APP.H(null,1,5,$APP.I,[vFb],null),$APP.M($APP.cw,$APP.M($APP.Uua,vFb),0))],null)],null)))),$APP.P,"Accepts three pairs of `[x, (f x)]`, fits a quadratic function to all three\n  points and returns the step from `xb` (the coordinate of the second argument)\n  to the minimum of the fitted quadratic.\n\n  Returns the numerator and denominator `p` and `q` of the required step. If `q`\n  is 0, then the supplied points were colinear.\n\n  `q` is guaranteed to be `\x3e\x3d 0`, while `p` might be negative.\n\n  See these notes for the derivation of this method:\n  http://fourier.eng.hmc.edu/e176/lectures/NM/node25.html"],
null)),new $APP.f(null,3,[$APP.Q,Lcb,$APP.X,I7a,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts three pairs of `[x, (f x)]`, fits a quadratic function to all three\n  points and returns the step from `xb` (the coordinate of the second argument)\n  to the minimum of the fitted quadratic.\n\n  Returns the numerator and denominator `p` and `q` of the required step. If `q`\n  is 0, then the supplied points were colinear.\n\n  `q` is guaranteed to be `\x3e\x3d 0`, while `p` might be negative.\n\n  See these notes for the derivation of this method:\n  http://fourier.eng.hmc.edu/e176/lectures/NM/node25.html",
$APP.U,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[RW,NVb],null),new $APP.H(null,2,5,$APP.I,[SW,OVb],null),new $APP.H(null,2,5,$APP.I,[QTb,PVb],null)],null),new $APP.f(null,1,[$APP.eta,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Xh,new $APP.H(null,1,5,$APP.I,[vFb],null),$APP.M($APP.cw,$APP.M($APP.Uua,vFb),0))],null)],null)))],null)],null),$APP.z(HKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null))),$APP.P,"Returns the points ordered as f(a) \x3c f(b)"],
null)),new $APP.f(null,3,[$APP.Q,kjb,$APP.X,H7a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the points ordered as f(a) \x3c f(b)",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null))],null)],null),$APP.z(pRb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null))),$APP.P,"Identical to bracket-min-scmutils, except brackets a maximum of the supplied\n  fn.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,
$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Tcb,$APP.X,Z3,$APP.h,new $APP.f(null,2,[$APP.P,"Identical to bracket-min-scmutils, except brackets a maximum of the supplied\n  fn.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null))],null)],null),$APP.z(wYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[irb],null),$APP.Ml,new $APP.f(null,1,[irb,110],null)],null)],null))),$APP.P,"Returns a function that performs steps of bracket extension.\n\n  :grow-limit is the maximum factor that the parabolic interpolation can jump\n  the function."],null)),new $APP.f(null,3,[$APP.Q,
JYb,$APP.X,L7a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that performs steps of bracket extension.\n\n  :grow-limit is the maximum factor that the parabolic interpolation can jump\n  the function.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[irb],null),$APP.Ml,new $APP.f(null,1,[irb,110],null)],null)],null))],null)],null),$APP.z(Fxb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,
2,5,$APP.I,[$APP.Nv,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,4,5,$APP.I,[RW,SW,KT,uX],null),$APP.Ml,new $APP.f(null,4,[RW,0,SW,1,KT,1E3,uX,1E3],null),$APP.dk,$APP.Ox],null)],null))),$APP.P,"Generates an interval `[lo, hi]` that is guaranteed to contain a minimum of the\n  function `f`, along with a candidate point `[mid, (f mid)]` that the user can\n  use to start a minimum search.\n\n  Returns a dictionary of the form:\n\n  {:lo `lower end of the bracket`\n   :mid `candidate point`\n   :hi `upper end of the bracket`\n   :fncalls `# of fn evaluations so far`\n   :iterations `total iterations`}\n\n  `:lo`, `:mid` and `:hi` are each pairs of the form `[x, (f x)]`.\n\n  The implementation works by growing the bounds using either:\n\n  - a step outside the bounds that places one bound at the golden-ratio cut\n  point between the new bounds, or\n  - a parabola with a minimum interpolated outside the current bounds, bounded b\n  a max.\n\n  This implementation was ported from `scipy.optimize.optimize.bracket`:\n  https://github.com/scipy/scipy/blob/v1.5.2/scipy/optimize/optimize.py#L2450\n\n  `bracket-min` supports the following optional keyword arguments:\n\n  `:xa` the initial guess for the lower end of the bracket. Defaults to 0.0.\n\n  `:xb` the initial guess for the upper end of the bracket. Defaults to 1.0. (If\n  these points aren't supplied in sorted order they'll be switched.)\n\n  `:grow-limit` The maximum factor that the parabolic interpolation can jump the\n  function. Defaults to 110.0.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n  ",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,4,5,$APP.I,[RW,SW,KT,uX],null),$APP.Ml,new $APP.f(null,4,[RW,0,SW,1,KT,1E3,uX,1E3],null),$APP.dk,$APP.Ox],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,4,5,$APP.I,[RW,SW,KT,uX],
null),$APP.Ml,new $APP.f(null,4,[RW,0,SW,1,KT,1E3,uX,1E3],null),$APP.dk,$APP.Ox],null)],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,FWb,$APP.X,W3,$APP.h,new $APP.f(null,2,[$APP.P,"Generates an interval `[lo, hi]` that is guaranteed to contain a minimum of the\n  function `f`, along with a candidate point `[mid, (f mid)]` that the user can\n  use to start a minimum search.\n\n  Returns a dictionary of the form:\n\n  {:lo `lower end of the bracket`\n   :mid `candidate point`\n   :hi `upper end of the bracket`\n   :fncalls `# of fn evaluations so far`\n   :iterations `total iterations`}\n\n  `:lo`, `:mid` and `:hi` are each pairs of the form `[x, (f x)]`.\n\n  The implementation works by growing the bounds using either:\n\n  - a step outside the bounds that places one bound at the golden-ratio cut\n  point between the new bounds, or\n  - a parabola with a minimum interpolated outside the current bounds, bounded b\n  a max.\n\n  This implementation was ported from `scipy.optimize.optimize.bracket`:\n  https://github.com/scipy/scipy/blob/v1.5.2/scipy/optimize/optimize.py#L2450\n\n  `bracket-min` supports the following optional keyword arguments:\n\n  `:xa` the initial guess for the lower end of the bracket. Defaults to 0.0.\n\n  `:xb` the initial guess for the upper end of the bracket. Defaults to 1.0. (If\n  these points aren't supplied in sorted order they'll be switched.)\n\n  `:grow-limit` The maximum factor that the parabolic interpolation can jump the\n  function. Defaults to 110.0.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n  ",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,4,5,$APP.I,[RW,SW,KT,uX],null),$APP.Ml,new $APP.f(null,4,[RW,0,SW,1,KT,1E3,uX,1E3],null),$APP.dk,$APP.Ox],null)],null))],null)],null),$APP.z(CUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Lv,new $APP.H(null,3,5,$APP.I,[SW,$APP.dk,$APP.sU],null),$APP.Mv],null))),$APP.P,"Fits a parabola through all three points, and returns the coordinate of the\n  minimum of the parabola.\n\n  If the supplied points are colinear, returns a point that takes a large jump\n  in the direction of the downward slope of the line."],
null)),new $APP.f(null,3,[$APP.Q,FUb,$APP.X,J7a,$APP.h,new $APP.f(null,2,[$APP.P,"Fits a parabola through all three points, and returns the coordinate of the\n  minimum of the parabola.\n\n  If the supplied points are colinear, returns a point that takes a large jump\n  in the direction of the downward slope of the line.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Lv,new $APP.H(null,3,5,$APP.I,[SW,$APP.dk,$APP.sU],null),$APP.Mv],null))],null)],null),$APP.z(rqb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[$APP.Ew,$APP.wv,KT],null),$APP.Ml,new $APP.f(null,3,[$APP.Ew,0,$APP.wv,10,KT,1E3],null)],null)],null))),$APP.P," Given a function f, a starting point and a step size, try to bracket a local\n  extremum for f.\n\n  Return a list (retcode a b c fa fb fc iter-count) where a \x3c b \x3c c, and fa, fb,\n  fc are the function values at these points. In the case of a minimum, fb\n  \x3c\x3d (min fa fc); the opposite inequality holds in the case of a maximum.\n\n  iter-count is the number of function evaluations required. retcode is 'okay if\n  the search succeeded, or 'maxcount if it was abandoned.\n  ",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[$APP.Ew,$APP.wv,KT],null),$APP.Ml,new $APP.f(null,3,[$APP.Ew,0,$APP.wv,10,KT,1E3],null)],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[$APP.Ew,$APP.wv,
KT],null),$APP.Ml,new $APP.f(null,3,[$APP.Ew,0,$APP.wv,10,KT,1E3],null)],null)],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Nrb,$APP.X,Y3,$APP.h,new $APP.f(null,2,[$APP.P," Given a function f, a starting point and a step size, try to bracket a local\n  extremum for f.\n\n  Return a list (retcode a b c fa fb fc iter-count) where a \x3c b \x3c c, and fa, fb,\n  fc are the function values at these points. In the case of a minimum, fb\n  \x3c\x3d (min fa fc); the opposite inequality holds in the case of a maximum.\n\n  iter-count is the number of function evaluations required. retcode is 'okay if\n  the search succeeded, or 'maxcount if it was abandoned.\n  ",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[$APP.Ew,$APP.wv,KT],null),$APP.Ml,new $APP.f(null,3,[$APP.Ew,0,$APP.wv,10,KT,1E3],null)],null)],null))],null)],null)],null),$APP.ap(kPb)),$APP.cp($APP.fg([$APP.z(mbb,new $APP.f(null,3,[$APP.Pm,jU,$APP.P,"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[emmy.value/zero-like]] this)`.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Su,$APP.Xx,mW],null)))],null)),$APP.z(byb,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,6,[mU,"null",jU,"null",YE,"null",NY,"null",iV,"null",o7b,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Xx,SS,HW],null))),YR,new $APP.ug(null,new $APP.f(null,3,[mU,"null",iV,"null",o7b,"null"],null),null),$APP.P,"Positional factory function for emmy.dual/Dual."],null)),$APP.z(Ydb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.sf)),$APP.P,"Returns a new, unique tag for use by a perturbation in an automatic\n  differentiation pass."],null)),$APP.z(zTb,new $APP.f(null,4,[aY,!0,$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Iyb],null))),$APP.P,"Positional factory function for emmy.dual/Completed."],null)),$APP.z(tmb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z($APP.Xx,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null))),$APP.P,"If `dx` is an instance of [[Dual]] returns the `tag` component. Else, acts\n  as nil."],
null)),$APP.z(dX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Lv,$APP.sU,$APP.Lh,$APP.Zw],null))),$APP.P,"For non-differentials, this is identical to [[emmy.value/\x3d]].\n  For [[Dual]] instances, equality acts on tangent components too.\n\n  If you want to ignore the tangent components, use [[equiv]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,
new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Lv,$APP.sU,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(uvb,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,new $APP.f(null,3,[$APP.z(feb,new $APP.f(null,1,[$APP.P,"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`."],
null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Su,rpb,Dzb],null)],null),$APP.z(mbb,new $APP.f(null,1,[$APP.P,"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[emmy.value/zero-like]] this)`."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Su,$APP.Xx,mW],null)],null),$APP.z(Qbc,new $APP.f(null,1,[$APP.P,"Given an instance of [[Completed]] (or a container type with [[Completed]]\n    instances at its leaves) and the `id` of an [[emmy.tape/TapeCell]], returns\n    the partial derivative associated with that [[emmy.tape/TapeCell]]'s\n    `id`.\n\n    This function is an internal implementation detail of reverse-mode automatic\n    differentiation."],
null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.wx],null)],null)],null)],null),$APP.Ov,new $APP.f(null,3,[K3b,new $APP.f(null,3,[$APP.Q,feb,$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Su,rpb,Dzb],null)),$APP.P,"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`."],null),Lfb,new $APP.f(null,3,[$APP.Q,mbb,$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Su,
$APP.Xx,mW],null)),$APP.P,"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[emmy.value/zero-like]] this)`."],null),vPb,new $APP.f(null,3,[$APP.Q,Qbc,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.wx],null)),$APP.P,"Given an instance of [[Completed]] (or a container type with [[Completed]]\n    instances at its leaves) and the `id` of an [[emmy.tape/TapeCell]], returns\n    the partial derivative associated with that [[emmy.tape/TapeCell]]'s\n    `id`.\n\n    This function is an internal implementation detail of reverse-mode automatic\n    differentiation."],
null)],null),gU,$APP.M("@interface")],null)),$APP.z(feb,new $APP.f(null,3,[$APP.Pm,jU,$APP.P,"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Su,rpb,Dzb],null)))],null)),$APP.z(wvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null))),$APP.P,"Returns true if the supplied object is an instance of [[Dual]], false\n  otherwise."],
null)),$APP.z(YMb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(r7b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Uv],null))),$APP.P,"Returns a pair of the primal and tangent components of the supplied `dx`, with\n  respect to the supplied `tag`. See the docs for [[primal]]\n  and [[tangent]] for more details.\n\n  [[primal-tangent-pair]] is equivalent to\n\n  `[([[primal]] dx tag) ([[tangent]] dx tag)]`\n\n  but slightly more efficient if you need both.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Uv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Uv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($fb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SS],null),new $APP.H(null,2,5,$APP.I,[SS,$APP.Xx],null),$APP.z(new $APP.H(null,3,5,$APP.I,
[SS,HW,$APP.Xx],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(Aqb,SS)],null)],null)))),$APP.P,"Returns a new [[Dual]] object with the supplied `primal` and `tangent`\n  components, and the supplied internal `tag` that this [[Dual]] will\n  carry around to prevent perturbation confusion.\n\n  If the `tangent` component is `0`, acts as identity on `primal`. `tangent`\n  defaults to 1.\n\n  `tag` defaults to a side-effecting call to [[fresh-tag]]; you can retrieve\n  this unknown tag by calling [[tag]] on the returned [[Dual]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[SS],null),new $APP.H(null,2,5,$APP.I,[SS,$APP.Xx],null),new $APP.H(null,3,5,$APP.I,[SS,HW,$APP.Xx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SS],null),new $APP.H(null,2,5,$APP.I,[SS,$APP.Xx],null),new $APP.H(null,3,5,$APP.I,[SS,HW,$APP.Xx],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z($APP.vw,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(SS,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Xx],null))),$APP.P,"If `dx` is an instance of [[Dual]] returns the `primal` component. Else, acts\n  as identity.\n\n  If the optional `tag` is supplied, [[primal-part]] acts as identity\n  for [[Dual]] instances with a non-matching tag.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,
[bX,$APP.Xx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Xx],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(HW,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Xx],null))),$APP.P,"If `dx` is an instance of [[Dual]] returns the `tangent` component. Else, returns 0.\n\n  If the optional `tag` is supplied, [[primal-part]] returns 0 for [[Dual]]\n  instances with a non-matching tag.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Xx],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Xx],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(hCb,new $APP.f(null,4,[aY,!0,$APP.ow,$APP.oj,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rxb],null))),$APP.P,"Factory function for emmy.dual/Completed, taking a map of keywords to field values."],
null)),$APP.z(oKb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(cYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Xx,$APP.Nv,$APP.Ou],null))),$APP.P,"Like `apply`, but conj-es `tag` onto the dynamic variable [[*active-tags*]]\n  inside the scope of `f`.\n\n  Returns the result of applying `f` to `args`."],null)),$APP.z(C0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"Comparator that compares [[Dual]] instances with each other or\n  non-differentials using all tangent terms each instance. Matches the response\n  of [[eq]].\n\n  Acts as [[emmy.value/compare]] for non-differentials."],
null)),$APP.z(IXb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(Qbc,new $APP.f(null,3,[$APP.Pm,jU,$APP.P,"Given an instance of [[Completed]] (or a container type with [[Completed]]\n    instances at its leaves) and the `id` of an [[emmy.tape/TapeCell]], returns\n    the partial derivative associated with that [[emmy.tape/TapeCell]]'s\n    `id`.\n\n    This function is an internal implementation detail of reverse-mode automatic\n    differentiation.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,
$APP.I,[$APP.Su,$APP.wx],null)))],null)),$APP.z($ib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Xx],null))),$APP.P,"Returns true if `tag` is an element of [[*active-tags*]] (and therefore pending\n  for extraction by some nested derivative), false otherwise."],null)),$APP.z(iub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[emmy.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to handle [[Dual]]\n  inputs in addition to any types that a normal `(f x)` call would present. This\n  restriction does _not_ apply to operations like putting `x` into a container\n  or destructuring; just primitive function calls."],
null)),$APP.z(srb,new $APP.f(null,1,[$APP.Nw,!0],null))],[new $APP.f(null,3,[$APP.Q,M3b,$APP.X,IH,$APP.h,new $APP.f(null,2,[$APP.P,"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[emmy.value/zero-like]] this)`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Su,$APP.Xx,mW],null))],null)],null),new $APP.f(null,3,[$APP.Q,RAb,$APP.X,qWa,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.dual/Dual.",$APP.U,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.Xx,SS,HW],null))],null)],null),new $APP.f(null,3,[$APP.Q,zAb,$APP.X,LH,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new, unique tag for use by a perturbation in an automatic\n  differentiation pass.",$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.Q,ltb,$APP.X,oWa,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.dual/Completed.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Iyb],null))],null)],null),new $APP.f(null,3,[$APP.Q,fPb,$APP.X,$_,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns true if all of the supplied objects have equal [[primal]]s, false\n  otherwise.\n\n  Use [[equiv]] if you want to compare scalars with\n  [[Dual]]s and ignore the tangent. If you _do_ want to take the tangent into\n  account, prefer [[eq]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Lv,$APP.sU,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,M8b,$APP.X,OH,$APP.h,new $APP.f(null,
2,[$APP.P,"If `dx` is an instance of [[Dual]] returns the `tag` component. Else, acts\n  as nil.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null))],null)],null),new $APP.f(null,3,[$APP.Q,V2b,$APP.X,a0,$APP.h,new $APP.f(null,2,[$APP.P,"For non-differentials, this is identical to [[emmy.value/\x3d]].\n  For [[Dual]] instances, equality acts on tangent components too.\n\n  If you want to ignore the tangent components, use [[equiv]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null),new $APP.H(null,
2,5,$APP.I,[$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Lv,$APP.sU,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,jU,$APP.X,nWa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,UTb,$APP.X,HH,$APP.h,new $APP.f(null,2,[$APP.P,"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Su,rpb,Dzb],null))],null)],null),
new $APP.f(null,3,[$APP.Q,a5b,$APP.X,NH,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied object is an instance of [[Dual]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null))],null)],null),new $APP.f(null,3,[$APP.Q,eLb,$APP.X,TH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,wrb,$APP.X,dN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a pair of the primal and tangent components of the supplied `dx`, with\n  respect to the supplied `tag`. See the docs for [[primal]]\n  and [[tangent]] for more details.\n\n  [[primal-tangent-pair]] is equivalent to\n\n  `[([[primal]] dx tag) ([[tangent]] dx tag)]`\n\n  but slightly more efficient if you need both.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Uv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ykb,$APP.X,SH,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new [[Dual]] object with the supplied `primal` and `tangent`\n  components, and the supplied internal `tag` that this [[Dual]] will\n  carry around to prevent perturbation confusion.\n\n  If the `tangent` component is `0`, acts as identity on `primal`. `tangent`\n  defaults to 1.\n\n  `tag` defaults to a side-effecting call to [[fresh-tag]]; you can retrieve\n  this unknown tag by calling [[tag]] on the returned [[Dual]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SS],null),new $APP.H(null,2,5,$APP.I,[SS,$APP.Xx],null),$APP.z(new $APP.H(null,3,5,$APP.I,[SS,HW,$APP.Xx],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(Aqb,SS)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Fgb,$APP.X,sWa,$APP.h,new $APP.f(null,2,[$APP.P,"Comparator that compares [[Dual]] instances with each other or\n  non-differentials using only the [[primal]] of each instance. Matches the\n  response of [[equiv]].\n\n  Acts as [[emmy.value/compare]] for non-differentials.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,xLb,$APP.X,RH,$APP.h,new $APP.f(null,2,[$APP.P,"If `dx` is an instance of [[Dual]] returns the `primal` component. Else, acts\n  as identity.\n\n  If the optional `tag` is supplied, [[primal-part]] acts as identity\n  for [[Dual]] instances with a non-matching tag.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Xx],null))],null)],null),new $APP.f(null,
3,[$APP.Q,Gbb,$APP.X,YN,$APP.h,new $APP.f(null,2,[$APP.P,"If `dx` is an instance of [[Dual]] returns the `tangent` component. Else, returns 0.\n\n  If the optional `tag` is supplied, [[primal-part]] returns 0 for [[Dual]]\n  instances with a non-matching tag.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bX],null),new $APP.H(null,2,5,$APP.I,[bX,$APP.Xx],null))],null)],null),new $APP.f(null,3,[$APP.Q,t1b,$APP.X,function(a){var b=$APP.Oi.A(a,yV);b=$APP.nd(a)?$APP.Lf.A($APP.F,b):b;return new KH(yV.j(a),
null,$APP.re(b),null)},$APP.h,new $APP.f(null,2,[$APP.P,"Factory function for emmy.dual/Completed, taking a map of keywords to field values.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rxb],null))],null)],null),new $APP.f(null,3,[$APP.Q,ESb,$APP.X,PH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,gZb,$APP.X,QH,$APP.h,new $APP.f(null,2,[$APP.P,"Like `apply`, but conj-es `tag` onto the dynamic variable [[*active-tags*]]\n  inside the scope of `f`.\n\n  Returns the result of applying `f` to `args`.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Xx,$APP.Nv,$APP.Ou],null))],null)],null),new $APP.f(null,3,[$APP.Q,O5b,$APP.X,function(a,b){return JF(dN.j(a),dN.j(b))},$APP.h,new $APP.f(null,2,[$APP.P,"Comparator that compares [[Dual]] instances with each other or\n  non-differentials using all tangent terms each instance. Matches the response\n  of [[eq]].\n\n  Acts as [[emmy.value/compare]] for non-differentials.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,
3,[$APP.Q,DRb,$APP.X,aN,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,S9b,$APP.X,JH,$APP.h,new $APP.f(null,2,[$APP.P,"Given an instance of [[Completed]] (or a container type with [[Completed]]\n    instances at its leaves) and the `id` of an [[emmy.tape/TapeCell]], returns\n    the partial derivative associated with that [[emmy.tape/TapeCell]]'s\n    `id`.\n\n    This function is an internal implementation detail of reverse-mode automatic\n    differentiation.",$APP.U,$APP.M(new $APP.H(null,2,5,
$APP.I,[$APP.Su,$APP.wx],null))],null)],null),new $APP.f(null,3,[$APP.Q,jPb,$APP.X,rWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `tag` is an element of [[*active-tags*]] (and therefore pending\n  for extraction by some nested derivative), false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Xx],null))],null)],null),new $APP.f(null,3,[$APP.Q,Eyb,$APP.X,tWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[emmy.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to handle [[Dual]]\n  inputs in addition to any types that a normal `(f x)` call would present. This\n  restriction does _not_ apply to operations like putting `x` into a container\n  or destructuring; just primitive function calls.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,F7b,$APP.X,Z_,$APP.h,$APP.F],null)]),$APP.ap(Jcb)),$APP.cp($APP.fg([$APP.z(oU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures."],null)),$APP.z(zP,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))),
$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ix)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(t2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))),$APP.P,"Construct a down (covariant) tuple from the supplied sequence. For a\n  variadic version, see [[down]]."],
null)),$APP.z(x2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns `true` if `s` is a `down` structure, false otherwise."],null)),$APP.z($APP.CY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"If `s` is sequential, returns its dimension, i.e., the total number of\n  non-sequential entries in the structure. Else, returns 1."],null)),$APP.z($Vb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(smb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null))),$APP.P,"For a non-[[Structure]] `s`, the single-arity case acts as [[identity]]. For\n  a [[Structure]], returns an identical structure with its orientation\n  reversed (up becomes down, down becomes up).\n\n  NOTE that a vector is interpreted as an `up` structure, so:\n\n  (opposite [1 2 3])\n  ;;\x3d\x3e (down 1 2 3)\n\n  The two-arity case returns a new [[Structure]] of opposite orientation to `s`\n  with the contents of the sequence `xs`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(gzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,
[$APP.M($APP.ax,$APP.Wv)],null)],null)))),$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient."],null)),$APP.z(m6b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null))),$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(LOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `s` is an `up` or `down` structure containing all `up` or\n  `down` structures of internally-matching orientation and size, false\n  otherwise."],
null)),$APP.z(k0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,$APP.Vv],null))),$APP.P,"Accepts\n\n  - some symbolic (or string) `name`\n  - a structure `s`\n\n  and returns a new structure of identical shape, with symbolic entries like\n  `'x↑0_1` that show their access chain with proper orientations for each step."],null)),$APP.z(OY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise."],
null)),$APP.z(Fub,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(Zhb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(E7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Return the structure `s` in unoriented vector form."],null)),$APP.z(Bmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))),$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```"],
null)),$APP.z(pKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a structure of the same shape and orientation as `s`, generated by\n  substituting gensymmed symbols in for each entry."],null)),UDb,$APP.z(iU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[oU,$APP.ix],null))),$APP.P,"Generate a structure with the supplied orientation, given some sequence `xs`"],null)),$APP.z(XHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null))),$APP.P,"Returns a new structure of equivalent shape to `s`, generated by applying `f`\n  to three arguments:\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  For example:\n\n  ```clojure\n  (dorun (map-chain println (s/down (s/up 1 2) (s/up 3 4))))\n\n  1 [0 0] [::s/down ::s/up]\n  2 [0 1] [::s/down ::s/up]\n  3 [1 0] [::s/down ::s/up]\n  4 [1 1] [::s/down ::s/up]\n  ```"],
null)),$APP.z(FIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a structure compatible for multiplication with `s` down to 0."],null)),Opb,$APP.z(Ngb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Rv,uU],null))),$APP.P,"Returns `1` if `i`\x3d\x3d `j`, `0` otherwise."],null)),$APP.z(SRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.Uv],null))),$APP.P,"Returns true if the supplied structures have the same orientation, false\n  otherwise."],
null)),$APP.z(A5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null)))),$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient."],null)),$APP.z(YPb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.CY,oU,$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,oU)],null)],null)))),$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`."],null)),$APP.z(HAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))),$APP.P,"Returns the (vector) inner product of `v1` and `v2`; this is equivalent to the\n  sum of the pairwise product of each entry.\n\n    This is equivalent to [[vector-dot-product]] with every element of `v1`\n  transformed into its complex conjugate.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]]."],
null)),$APP.z(sW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null))),$APP.P,"Returns true if the supplied orientation lives in the set of allowed\n  orientations, false otherwise."],null)),$APP.z(OHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)"],null)),$APP.z(Vlb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a new structure with the same orientation as the first element of `s`,\n  filled with elements of the same orientation as `s`.\n\n  Each element is generating by taking the first element of each entry in `s`,\n  the the second, etc... In that sense this is similar to a traditional matrix\n  transpose.\n\n  A comment from `scmutils` states:\n\n  'used only in symmetrize-Christoffel in\n  src/calculus/covariant-derivative.scm.'"],null)),$APP.z(NK,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,qS],null))),$APP.P,"Given an access chain (a sequence of indices), return a function that accepts a\n  structure and returns the element at the specified access chain.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(qS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,qS],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(FAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Vv,$APP.ix],null))),$APP.P,"Returns a structure containing `xs` with the same orientation as `s`."],null)),$APP.z(Gib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Yx,$APP.yY,oU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,oU)],null)],null)))),$APP.P,"Generates a structure of the specified `orientation` and dimension `size`\n  populated by symbolic entries, each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  (\x3d (literal 'x 3 ::s/up)\n     (up 'x↑0 'x↑1 'x↑2))\n\n  See [[literal-up]] and [[literal-down]] for constructors with baked in\n  orientations."],
null)),$APP.z(Pmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UY,$APP.vv],null),new $APP.H(null,3,5,$APP.I,[bF,UY,$APP.vv],null))),$APP.P,"Given:\n\n  - a sequence of `values`\n  - a model `struct`\n\n  Returns a new structure generated by unpacking `values` into a structure with\n  the same shape as `struct`.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[UY,$APP.vv],null),new $APP.H(null,3,
5,$APP.I,[bF,UY,$APP.vv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[UY,$APP.vv],null),new $APP.H(null,3,5,$APP.I,[bF,UY,$APP.vv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(Hab,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given an `up` or `down` structure containing structures of the same\n  orientation and size (a 2 tensor), returns a dictionary with keys:\n\n  ```clj\n  {:outer-orientation \x3c::up or ::down\x3e\n   :inner-orientation \x3c::up or ::down\x3e\n   :outer-size \x3cint\x3e\n   :inner-size \x3cint\x3e}\n\n  If `s` is _not_ a valid tensor, returns nil.\n  ```"],
null)),$APP.z(Oub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Return a structure of the same shape as `s` whose elements are access chains\n  corresponding to position of each element (i.e., the sequence of indices\n  needed to address that element via [[get-in]]).\n\n  Each access chain has the sequence of orientations (`::s/up`, `::s/down`)\n  associated with each step attached to it as metadata, under an `:orientations`\n  key. Use this if the orientation of the indices matters."],
null)),$APP.z(Q0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))),$APP.P,"Returns the (vector) dot product of `v1` and `v2`; this is equivalent to the sum\n  of the pairwise product of each entry.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]]."],null)),$APP.z(Gcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))),$APP.P,"Construct an up (contravariant) tuple from the supplied sequence. For a\n  variadic version, see [[up]]."],
null)),$APP.z(Mvb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null))),$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Nv,CV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null)),$APP.Cx,
$APP.M(null)],null)],null)),$APP.z(vmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.Vv],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.JT,$APP.Vv],null))),$APP.P,"Returns the result of accumulating all non-structural entries in `s` using the\n  supplied fold function `f` into the optional accumulator `init` (defaults\n  to `(f)`).\n\n  `f` must be a 2-argument fn of type `(accumulator, [x chain orientations]) \x3d\x3e\n  accumulator` responsible for merging some value `x` into the ongoing\n  accumulation. The second argument is a 3-vector containing\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  `f` should return a new instance of the accumulator.\n\n  Additional arities allow you to supply\n\n  - `init`, the initial (empty) accumulator (defaults to `(f)`)\n  - `present`, a function that will be applied to the final, aggregated\n    result (defaults to `f`)\n\n  For example:\n\n  ```clojure\n  (fold-chain\n    (fn ([] [])\n     ([acc] acc)\n     ([acc [s chain orientations]]\n      (conj acc {:s s\n                 :chain chain\n                 :orientations orientations})))\n    (s/down (s/up 1 2) (s/up 3 4)))\n\n  [{:s 1, :chain [0 0], :orientations [::s/down ::s/up]}\n   {:s 2, :chain [0 1], :orientations [::s/down ::s/up]}\n   {:s 3, :chain [1 0], :orientations [::s/down ::s/up]}\n   {:s 4, :chain [1 1], :orientations [::s/down ::s/up]}]\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.Vv],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.JT,$APP.Vv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.Vv],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.JT,$APP.Vv],null)),$APP.Cx,$APP.M(null,null,null)],
null)],null)),$APP.z(TFb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(yP,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))),$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ix)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z($APP.XX,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a structure with the same shape as `s`, with all orientations\n  inverted."],null)),$APP.z(Ixb,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,22,[bT,"null",NT,"null",UV,"null",mU,"null",UW,"null",qU,"null",jU,"null",YE,"null",OLb,"null",zX,"null",US,"null",tS,"null",nS,"null",NY,"null",iV,"null",wX,"null",wY,"null",pT,"null",TW,"null",lW,"null",TV,"null",vY,"null"],null),null),$APP.ow,
UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[oU,$APP.Wv,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,17,[bT,"null",NT,"null",UV,"null",mU,"null",UW,"null",qU,"null",zX,"null",US,"null",tS,"null",nS,"null",iV,"null",wX,"null",wY,"null",pT,"null",TW,"null",lW,"null",vY,"null"],null),null),$APP.P,"Positional factory function for emmy.structure/Structure."],null)),$APP.z(yCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms."],
null)),$APP.z(arb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))),$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x↑0 'x↑1 'x↑2))\n  ```"],null)),$APP.z(OCb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(DZb,new $APP.f(null,1,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null))],[new $APP.f(null,3,[$APP.Q,Asb,$APP.X,VK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,NP,$APP.X,wL,$APP.h,new $APP.f(null,2,[$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,h8b,$APP.X,cL,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a down (covariant) tuple from the supplied sequence. For a\n  variadic version, see [[down]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,F8b,$APP.X,DZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is a `down` structure, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ngb,$APP.X,WK,$APP.h,new $APP.f(null,2,[$APP.P,"If `s` is sequential, returns its dimension, i.e., the total number of\n  non-sequential entries in the structure. Else, returns 1.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,yIb,$APP.X,fqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,$Hb,$APP.X,v2,$APP.h,new $APP.f(null,
2,[$APP.P,"For a non-[[Structure]] `s`, the single-arity case acts as [[identity]]. For\n  a [[Structure]], returns an identical structure with its orientation\n  reversed (up becomes down, down becomes up).\n\n  NOTE that a vector is interpreted as an `up` structure, so:\n\n  (opposite [1 2 3])\n  ;;\x3d\x3e (down 1 2 3)\n\n  The two-arity case returns a new [[Structure]] of opposite orientation to `s`\n  with the contents of the sequence `xs`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,H9b,$APP.X,NZa,$APP.h,new $APP.f(null,2,[$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,
new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,eqb,$APP.X,m2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.Q,DNb,$APP.X,LZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is an `up` or `down` structure containing all `up` or\n  `down` structures of internally-matching orientation and size, false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,PDb,$APP.X,RZa,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts\n\n  - some symbolic (or string) `name`\n  - a structure `s`\n\n  and returns a new structure of identical shape, with symbolic entries like\n  `'x↑0_1` that show their access chain with proper orientations for each step.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,uAb,$APP.X,YK,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,dyb,$APP.X,mL,$APP.h,new $APP.f(null,2,[$APP.P,"Return a structure with the same shape as s but with f applied to each\n  primitive (that is, not structural) component.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null))],null)],null),new $APP.f(null,3,[$APP.Q,C_b,$APP.X,eqc,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,A4b,$APP.X,TK,$APP.h,new $APP.f(null,2,[$APP.P,"Return the structure `s` in unoriented vector form.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ghb,$APP.X,iL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))],null)],null),new $APP.f(null,3,[$APP.Q,job,$APP.X,nL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure of the same shape and orientation as `s`, generated by\n  substituting gensymmed symbols in for each entry.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,fgb,$APP.X,BP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Wyb,$APP.X,aL,$APP.h,new $APP.f(null,2,[$APP.P,"Generate a structure with the supplied orientation, given some sequence `xs`",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[oU,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,Nbc,$APP.X,kL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new structure of equivalent shape to `s`, generated by applying `f`\n  to three arguments:\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  For example:\n\n  ```clojure\n  (dorun (map-chain println (s/down (s/up 1 2) (s/up 3 4))))\n\n  1 [0 0] [::s/down ::s/up]\n  2 [0 1] [::s/down ::s/up]\n  3 [1 0] [::s/down ::s/up]\n  4 [1 1] [::s/down ::s/up]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,z1b,$APP.X,pL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure compatible for multiplication with `s` down to 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,skb,$APP.X,pL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Mtb,$APP.X,AZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `1` if `i`\x3d\x3d `j`, `0` otherwise.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Rv,uU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Nlb,$APP.X,FZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied structures have the same orientation, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.Uv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xmb,$APP.X,MZa,$APP.h,new $APP.f(null,2,[$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,qUb,$APP.X,eL,$APP.h,new $APP.f(null,2,[$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`.",$APP.U,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.CY,oU,$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,
oU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,kdc,$APP.X,VZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the (vector) inner product of `v1` and `v2`; this is equivalent to the\n  sum of the pairwise product of each entry.\n\n    This is equivalent to [[vector-dot-product]] with every element of `v1`\n  transformed into its complex conjugate.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.NW,$APP.OW],null))],null)],null),new $APP.f(null,3,[$APP.Q,oYb,$APP.X,EZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied orientation lives in the set of allowed\n  orientations, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Q6b,$APP.X,XK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Pdc,$APP.X,SZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new structure with the same orientation as the first element of `s`,\n  filled with elements of the same orientation as `s`.\n\n  Each element is generating by taking the first element of each entry in `s`,\n  the the second, etc... In that sense this is similar to a traditional matrix\n  transpose.\n\n  A comment from `scmutils` states:\n\n  'used only in symmetrize-Christoffel in\n  src/calculus/covariant-derivative.scm.'",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kbb,$APP.X,tP,$APP.h,new $APP.f(null,2,[$APP.P,"Given an access chain (a sequence of indices), return a function that accepts a\n  structure and returns the element at the specified access chain.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,qS],null))],null)],null),new $APP.f(null,3,[$APP.Q,lrb,$APP.X,dL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure containing `xs` with the same orientation as `s`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,LVb,$APP.X,gL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a structure of the specified `orientation` and dimension `size`\n  populated by symbolic entries, each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  (\x3d (literal 'x 3 ::s/up)\n     (up 'x↑0 'x↑1 'x↑2))\n\n  See [[literal-up]] and [[literal-down]] for constructors with baked in\n  orientations.",$APP.U,$APP.M($APP.z(new $APP.H(null,
3,5,$APP.I,[$APP.Yx,$APP.yY,oU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,oU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,pfb,$APP.X,HN,$APP.h,new $APP.f(null,2,[$APP.P,"Given:\n\n  - a sequence of `values`\n  - a model `struct`\n\n  Returns a new structure generated by unpacking `values` into a structure with\n  the same shape as `struct`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[UY,$APP.vv],null),new $APP.H(null,3,5,$APP.I,[bF,UY,$APP.vv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,ovb,$APP.X,$K,$APP.h,new $APP.f(null,2,[$APP.P,"Given an `up` or `down` structure containing structures of the same\n  orientation and size (a 2 tensor), returns a dictionary with keys:\n\n  ```clj\n  {:outer-orientation \x3c::up or ::down\x3e\n   :inner-orientation \x3c::up or ::down\x3e\n   :outer-size \x3cint\x3e\n   :inner-size \x3cint\x3e}\n\n  If `s` is _not_ a valid tensor, returns nil.\n  ```",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,cPb,$APP.X,lL,$APP.h,new $APP.f(null,2,[$APP.P,"Return a structure of the same shape as `s` whose elements are access chains\n  corresponding to position of each element (i.e., the sequence of indices\n  needed to address that element via [[get-in]]).\n\n  Each access chain has the sequence of orientations (`::s/up`, `::s/down`)\n  associated with each step attached to it as metadata, under an `:orientations`\n  key. Use this if the orientation of the indices matters.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,QIb,$APP.X,rL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the (vector) dot product of `v1` and `v2`; this is equivalent to the sum\n  of the pairwise product of each entry.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))],null)],null),new $APP.f(null,3,[$APP.Q,gAb,$APP.X,bL,$APP.h,
new $APP.f(null,2,[$APP.P,"Construct an up (contravariant) tuple from the supplied sequence. For a\n  variadic version, see [[up]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,MDb,$APP.X,qP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,
$APP.Lh,CV],null))],null)],null),new $APP.f(null,3,[$APP.Q,GEb,$APP.X,$N,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of accumulating all non-structural entries in `s` using the\n  supplied fold function `f` into the optional accumulator `init` (defaults\n  to `(f)`).\n\n  `f` must be a 2-argument fn of type `(accumulator, [x chain orientations]) \x3d\x3e\n  accumulator` responsible for merging some value `x` into the ongoing\n  accumulation. The second argument is a 3-vector containing\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  `f` should return a new instance of the accumulator.\n\n  Additional arities allow you to supply\n\n  - `init`, the initial (empty) accumulator (defaults to `(f)`)\n  - `present`, a function that will be applied to the final, aggregated\n    result (defaults to `f`)\n\n  For example:\n\n  ```clojure\n  (fold-chain\n    (fn ([] [])\n     ([acc] acc)\n     ([acc [s chain orientations]]\n      (conj acc {:s s\n                 :chain chain\n                 :orientations orientations})))\n    (s/down (s/up 1 2) (s/up 3 4)))\n\n  [{:s 1, :chain [0 0], :orientations [::s/down ::s/up]}\n   {:s 2, :chain [0 1], :orientations [::s/down ::s/up]}\n   {:s 3, :chain [1 0], :orientations [::s/down ::s/up]}\n   {:s 4, :chain [1 1], :orientations [::s/down ::s/up]}]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.Vv],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.JT,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Jub,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,OP,$APP.X,SN,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))],null)],
null),new $APP.f(null,3,[$APP.Q,KDb,$APP.X,oL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure with the same shape as `s`, with all orientations\n  inverted.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,QWb,$APP.X,SK,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.structure/Structure.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[oU,$APP.Wv,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,lmb,$APP.X,qL,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,y6b,$APP.X,hL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x↑0 'x↑1 'x↑2))\n  ```",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))],null)],null),new $APP.f(null,3,[$APP.Q,ydc,$APP.X,gqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,eWb,$APP.X,hqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null)]),$APP.ap(Bcb)),$APP.cp(new $APP.f(null,2,[$APP.z(eFb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],
null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,dW],null))),$APP.P,"Find the minimum of the function `f: R -\x3e R` in the interval `[a, b]`.\n\n  If an `observe` function is supplied, it will be invoked with the iteration\n  count and the values of x and f(x) at each search step.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,dW],
null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,dW],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,iNb,$APP.X,$3,$APP.h,new $APP.f(null,2,[$APP.P,"Find the minimum of the function `f: R -\x3e R` in the interval `[a, b]`.\n\n  If an `observe` function is supplied, it will be invoked with the iteration\n  count and the values of x and f(x) at each search step.",$APP.U,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,dW],null))],null)],null),$APP.z(J3b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Iy,$APP.PW,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[eY],null),$APP.dk,$APP.Ox],null)],null))),$APP.P,"Entrypoint for multidimensional minimization routines.\n\n  See [[emmy.numerical.multimin.nelder-mead/nelder-mead]] for the only\n  supported option.",$APP.ky,new $APP.f(null,
6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Iy,$APP.PW,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[eY],null),$APP.dk,$APP.Ox],null))],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Iy,$APP.PW,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[eY],null),$APP.dk,$APP.Ox],null)],null)),$APP.Cx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.Q,pMb,$APP.X,a4,$APP.h,new $APP.f(null,2,[$APP.P,"Entrypoint for multidimensional minimization routines.\n\n  See [[emmy.numerical.multimin.nelder-mead/nelder-mead]] for the only\n  supported option.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Iy,$APP.PW,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[eY],null),$APP.dk,$APP.Ox],null)],null))],null)],null)],null),$APP.ap(xSb)),$APP.cp($APP.fg([$APP.z(BRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[lV],null)))],null)),$APP.z(Dob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null)))],null)),$APP.z(Gxb,new $APP.f(null,
1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],null)),$APP.z(fXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],null)),$APP.z(M1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],null)),SZb,$APP.z(igb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NDb],null)))],null)),$APP.z(tUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(gwb,$APP.Lv)],null)],null)))),$APP.P,"Given an antisymmetric matrix `a` of dimension 3, returns a column vector of\n  its positive components."],null)),$APP.z(Mjb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,xU,TY],null)],null)))],null)),Fwb,$APP.z(iAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],
null)),$APP.z(Upb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[lV],null)))],null)),$APP.z(wub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,new $APP.H(null,3,5,$APP.I,[UX,$APP.Kv,YT],null),new $APP.H(null,3,5,$APP.I,[sWb,Xkb,mnb],null)],null)],null))),$APP.P,"Although this implementation appears to summarize `(M-\x3eomega-body r/Euler-\x3eM)`,\n  it is actually essential to prevent intermediate expression explosion."],
null)),$APP.z(ktb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,xU,TY],null)],null)))],null)),Ejb,$APP.z(Axb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[NDb],null)))],null)),$APP.z(vlb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],null)),$APP.z(Jpb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],null)),$APP.z(T8b,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],null)),$APP.z(HIb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],null)),$APP.z(iib,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null)))],null)),$APP.z(IUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[lV],null)))],null)),$APP.z(CSb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[lV],null)))],null)),$APP.z(Mpb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null)))],null))],[new $APP.f(null,3,[$APP.Q,Qib,$APP.X,function(a){return VQ(A$a(a))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lV],null))],null)],null),new $APP.f(null,3,[$APP.Q,I9b,$APP.X,function(a){var b=$APP.x.B(a,0,null),c=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);return EN.C($APP.y([new $APP.H(null,3,5,$APP.I,[0,TF.j(a),c],null),new $APP.H(null,3,
5,$APP.I,[a,0,TF.j(b)],null),new $APP.H(null,3,5,$APP.I,[TF.j(c),b,0],null)]))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,C1b,$APP.X,function(a,b,c){var d=I$a(a,b,c);return function(g){$APP.x.B(g,0,null);var l=$APP.x.B(g,1,null);g=d(g);l=y$a(mR.j(l));return kG.A(g,gR.j(l))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],
null),new $APP.f(null,3,[$APP.Q,uqb,$APP.X,G$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,HMb,$APP.X,D$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,JXb,$APP.X,H$a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,v5b,$APP.X,E$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NDb],null))],null)],null),new $APP.f(null,3,
[$APP.Q,DJb,$APP.X,z$a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an antisymmetric matrix `a` of dimension 3, returns a column vector of\n  its positive components.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(gwb,$APP.Lv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,p6b,$APP.X,function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null),c=$APP.x.B(a,2,null);a=wN(b);c=M1a(c);var d=SF.A(-2,DH.A(b,b));b=kG.A(d,$APP.am.A(kG.C(c,
nsc,$APP.y([a])),new $APP.H(null,2,5,$APP.I,[0,0],null)));var g=kG.A(d,$APP.am.A(kG.C(c,osc,$APP.y([a])),new $APP.H(null,2,5,$APP.I,[0,0],null)));a=kG.A(d,$APP.am.A(kG.C(c,psc,$APP.y([a])),new $APP.H(null,2,5,$APP.I,[0,0],null)));return wL.C($APP.y([b,g,a]))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,xU,TY],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,cQb,$APP.X,G$a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Yub,$APP.X,function(a,
b,c){return $APP.RQ.j(CR.B?CR.B(a,b,c):CR.call(null,a,b,c))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,lec,$APP.X,function(a){return VQ(B$a(a))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Q7b,$APP.X,F$a,$APP.h,new $APP.f(null,2,[$APP.P,"Although this implementation appears to summarize `(M-\x3eomega-body r/Euler-\x3eM)`,\n  it is actually essential to prevent intermediate expression explosion.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,new $APP.H(null,3,5,$APP.I,[UX,$APP.Kv,YT],null),new $APP.H(null,3,5,$APP.I,[sWb,Xkb,mnb],null)],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,jQb,$APP.X,function(a){$APP.x.B(a,0,null);var b=$APP.x.B(a,1,null);a=$APP.x.B(a,2,null);var c=SF.A(kG.A(2,b),DH.A(b,b));b=DH.A(c,kG.A(C4,a));var d=DH.A(c,kG.A(D4,a));a=DH.A(c,kG.A(E4,a));return wL.C($APP.y([b,d,a]))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Kv,xU,TY],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,DWb,$APP.X,CR,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Zxb,$APP.X,function(a){return function(b){return kG.A(gR.j(pO(a.j?a.j(b):a.call(null,b))),E$a(a)(b))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[NDb],null))],null)],null),new $APP.f(null,3,[$APP.Q,S8b,$APP.X,C$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],
null),new $APP.f(null,3,[$APP.Q,gGb,$APP.X,I$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,xKb,$APP.X,H$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,l9b,$APP.X,function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);g=wN(g);var l=wN(d),n=QF.j($APP.am.A(kG.A(yN(g),g),new $APP.H(null,2,5,$APP.I,
[0,0],null)));d=kG.C(n,C4,$APP.y([l]));var p=kG.C(n,D4,$APP.y([l]));l=kG.C(n,E4,$APP.y([l]));g=kG.A(g,yN(g));return kG.A(2,mG.C(kG.A(a,$APP.am.A(kG.C(yN(d),g,$APP.y([d])),new $APP.H(null,2,5,$APP.I,[0,0],null))),kG.A(b,$APP.am.A(kG.C(yN(p),g,$APP.y([p])),new $APP.H(null,2,5,$APP.I,[0,0],null))),$APP.y([kG.A(c,$APP.am.A(kG.C(yN(l),g,$APP.y([l])),new $APP.H(null,2,5,$APP.I,[0,0],null)))])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],null),new $APP.f(null,
3,[$APP.Q,E6b,$APP.X,CR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,AU,UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vpb,$APP.X,A$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lV],null))],null)],null),new $APP.f(null,3,[$APP.Q,hLb,$APP.X,B$a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[lV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Aob,$APP.X,function(a){return function(b,c,d){return function(g){return kG.A(D$a(b,c,
d)(g),gR.j(a))}}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))],null)],null)]),$APP.ap(TRb)),$APP.cp($APP.fg([$APP.z(NZb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WV],null)))],null)),p0b,$APP.z(Qqb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))],null)),$APP.z(k9b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))],null)),$APP.z(Kvb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),$APP.P,"p. 334"],null)),$APP.z(BIb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null)))],null)),$APP.z(dEb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(ulb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,KU],null)))],null)),$APP.z(sPb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,
5,$APP.I,[$APP.Qr,KU],null)))],null)),$APP.z(cTb,new $APP.f(null,1,[$APP.im,!0],null)),QLb,$APP.z(Atb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null))),$APP.P,"A transformation of configuration coordinates F to a procedure implementing a\n  transformation of phase-space coordinates (p. 320)"],null)),$APP.z(RCb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null)))],null)),$APP.z(xtb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Qr,KU],null)))],null)),$APP.z(dkb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[nAb,oAb],null)))],null)),$APP.z(gUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[BU],null)))],null)),$APP.z(bkb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[BU],null)))],null)),$APP.z(Uhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UR,$APP.DU],null))),$APP.P,"p.324"],null)),$APP.z(UWb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UR,GU],null)))],null)),$APP.z(q5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,tU],null)))],null)),CCb,$APP.z(z9b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wW,xW],null)))],null)),$APP.z(Vvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null))),$APP.P,"p.327"],null)),$APP.z(gXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[UR,$APP.DU],null)))],null)),$APP.z(lJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uv,xU,$APP.Sv],null))),$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q` and momentum tuple (or\n  scalar) `p`, returns a 'Hamiltonian state tuple', i.e., the state expected by a\n  Hamiltonian."],null)),$APP.z(qhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[UR,$APP.DU,wmb],null))),$APP.P,"p.324"],null)),$APP.z(Dlb,new $APP.f(null,
1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WU],null)))],null)),$APP.z(Jbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),$APP.P,"Symplectic test in terms of matrices"],null)),$APP.z(yZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),$APP.P,"p.326"],null)),$APP.z(g5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[i7b],null)))],null)),$APP.z(F9a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))),$APP.P,"the flow derivative generalizes the Lie derivative to allow for time dependent\n  H and F --- computes the 'time' derivative of F along the flow specified by H"],null)),$APP.z(WV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),$APP.P,"Returns function signature for a Hamiltonian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Hamiltonian literal functions."],
null)),$APP.z(mgb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GU],null)))],null)),$APP.z(aTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pob,$APP.Vv)],null)],null)))),$APP.P,"Given a hamiltonian state, returns a [[emmy.structure/up]] containing the\n  coordinate and momentum components. "],null)),$APP.z(G6b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[CU,Nxb],null)))],null)),$APP.z(lGb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[kIb,mTb],null)))],null)),wyb,$APP.z(AGb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))],null)),$APP.z(yXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wW,xW],null)))],null)),$APP.z(dDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[YU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,
2,5,$APP.I,[$APP.M(dY,YU),$APP.M($APP.aw,$APP.M($APP.tv,YU),2)],null)],null)))),$APP.P,"Returns the momentum element of a local Hamiltonian state tuple (by convention,\n  the third element)."],null)),$APP.z(xqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),$APP.P,"p. 334 (used, but not defined there)"],null)),$APP.z(BWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.DU,VR],null))),$APP.P,"The generalization of Lie-transform to include time dependence."],
null)),$APP.z(zCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))),$APP.P,"p. 334"],null)),AMb,$APP.z(mcc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),ztb,$APP.z(Uzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))],null)),$APP.z(u0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null)))],null)),$APP.z(D5b,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Iu,$APP.M($APP.mv,$APP.wU))],null)],null)))),$APP.P,"f is a function of (x y continue fail), which calls continue with the values of\n  x' y' that follow x y in the mapping.\n\n  Returns a map of the same shape that iterates the iterated map n times before\n  invoking the continuation, or invokes the fail continuation if the inner map\n  fails."],null)),
a1b,$APP.z(KNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),$APP.P,"n \x3d\x3d degrees of freedom"],null)),$APP.z(vnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Sv],null)))],null)),$APP.z(c_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[BU],null)))],null)),cob,$APP.z(x8b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.Vv],null),new $APP.f(null,
1,[$APP.Bw,new $APP.H(null,3,5,$APP.I,[$APP.M($APP.bw,$APP.M(fQb,$APP.Qr),1),$APP.M($APP.Kw,$APP.M(gmb,$APP.Qr)),$APP.M($APP.aw,$APP.M(gmb,$APP.Qr),2)],null)],null))))],null)),$APP.z(pob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if the supplied state is\n\n  - of type [[emmy.structure/up]]\n\n  - contains three elements of `time`, `coordinate` and `momentum` of either of\n    the following type shapes:\n\n  ```\n  (up \x3cnumber\x3e \x3cnumber\x3e \x3cnumber\x3e)\n  (up \x3cnumber\x3e (up \x3cnumber\x3e*) (down \x3cnumber\x3e*))\n  ```\n\n  If structural, the dimension of the coordinate and momentum tuples must match."],
null)),$APP.z(ubb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(Rlb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GU],null)))],null)),$APP.z(trb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UR,$APP.DU],null))),$APP.P,"Tests that K yields a canonical transformation if the C is symplectic. (The\n  qp-canonical? code is really a symplectic test without factoring out the\n  Hamiltonian.)"],
null)),$APP.z(hdc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null)))],null)),$APP.z(H9a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.DU,$APP.Uv],null))),$APP.P,"p. 428, the Lie transform is just the time-advance operator using the Lie\n  derivative (see Hamiltonian.scm)."],null)),$APP.z(F0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.vU],null)))],null)),$APP.z(Wfb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `s` is compatible for contraction with a proper H-state, false\n  otherwise."],null))],[new $APP.f(null,3,[$APP.Q,enb,$APP.X,A9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WV],null))],null)],null),new $APP.f(null,3,[$APP.Q,HSb,$APP.X,dsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Ptb,$APP.X,$APP.$Q,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],
null))],null)],null),new $APP.f(null,3,[$APP.Q,Tyb,$APP.X,function(a){return function(b){var c=MQ(b),d=$APP.NQ(b);var g=SQ.j?SQ.j(2):SQ.call(null,2);g=g.j?g.j(a):g.call(null,a);b=g.j?g.j(b):g.call(null,b);return YQ(c,d,b)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))],null)],null),new $APP.f(null,3,[$APP.Q,vUb,$APP.X,$9a,$APP.h,new $APP.f(null,2,[$APP.P,"p. 334",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,K4b,
$APP.X,function(a){return function(b){return TF.j(kG.A(eR.A(ZQ(b),function(){var c=SQ.j?SQ.j(1):SQ.call(null,1);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}()),function(){var c=SQ.j?SQ.j(0):SQ.call(null,0);c=c.j?c.j(a):c.call(null,a);return c.j?c.j(b):c.call(null,b)}()))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Odc,$APP.X,function(a){return function(b){return P9a(U9a(b),a)}},$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Pkb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);c=SF.A(nG.j(c),kG.A(2,a));d=jG.j(d);d=b.j?b.j(d):b.call(null,d);return z9a(c,d)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,KU],null))],null)],null),new $APP.f(null,3,[$APP.Q,zxb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,
2,null);return z9a(SF.A(nG.j(c),kG.A(2,a)),$APP.Je.A(b,d))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,KU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Zlb,$APP.X,!1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,iEb,$APP.X,ZQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,y$b,$APP.X,L9a,$APP.h,new $APP.f(null,2,[$APP.P,"A transformation of configuration coordinates F to a procedure implementing a\n  transformation of phase-space coordinates (p. 320)",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[CU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Reb,$APP.X,function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null),g=$APP.x.B(b,2,null);b=SF.A(mG.A(kG.A(a,nG.j(d)),SF.A(nG.j(g),a)),2);d=tG.A(SF.A(d,lG.j(SF.A(kG.A(2,b),a))),SF.A(g,lG.j(kG.C(2,b,$APP.y([a])))));return wL.C($APP.y([c,d,b]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null))],null)],null),new $APP.f(null,3,[$APP.Q,GOb,$APP.X,function(a,b){return function(c){$APP.x.B(c,
0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(d,0,null);$APP.x.B(d,1,null);d=$APP.x.B(c,2,null);c=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return z9a(SF.A(mG.A(nG.j(c),nG.j(SF.A(d,g))),kG.A(2,a)),b.j?b.j(g):b.call(null,g))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,KU],null))],null)],null),new $APP.f(null,3,[$APP.Q,yvb,$APP.X,function(a,b){return TF.A(kG.A(ZQ.j?ZQ.j(b):ZQ.call(null,b),$APP.NQ.j?$APP.NQ.j(a):$APP.NQ.call(null,a)),kG.A(ZQ.j?ZQ.j(a):ZQ.call(null,a),$APP.NQ.j?
$APP.NQ.j(b):$APP.NQ.call(null,b)))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[nAb,oAb],null))],null)],null),new $APP.f(null,3,[$APP.Q,aib,$APP.X,R9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[BU],null))],null)],null),new $APP.f(null,3,[$APP.Q,kCb,$APP.X,Q9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[BU],null))],null)],null),new $APP.f(null,3,[$APP.Q,bnb,$APP.X,N9a,$APP.h,new $APP.f(null,2,[$APP.P,"p.324",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[UR,$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.Q,D2b,$APP.X,function(a,b){return TF.A(YH.C($APP.y([O9a,a])),kG.A(UO.j?UO.j(a):UO.call(null,a),mG.A(O9a,B9a(b))))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[UR,GU],null))],null)],null),new $APP.f(null,3,[$APP.Q,PRb,$APP.X,bR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,tU],null))],null)],null),new $APP.f(null,3,[$APP.Q,qac,$APP.X,z4,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,
zeb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null);d=SF.A(mG.A(kG.A(a,c),kG.A(b,g)),mG.A(a,b));c=TF.A(g,c);return wL.A?wL.A(d,c):wL.call(null,d,c)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wW,xW],null))],null)],null),new $APP.f(null,3,[$APP.Q,thb,$APP.X,T9a,$APP.h,new $APP.f(null,2,[$APP.P,"p.327",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null))],null)],null),new $APP.f(null,3,[$APP.Q,
k2b,$APP.X,function(a,b){return TF.A(YH.C($APP.y([B9a(b),a])),kG.A(UO.j?UO.j(a):UO.call(null,a),B9a(YH.C($APP.y([b,a])))))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[UR,$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.Q,mtb,$APP.X,YQ,$APP.h,new $APP.f(null,2,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q` and momentum tuple (or\n  scalar) `p`, returns a 'Hamiltonian state tuple', i.e., the state expected by a\n  Hamiltonian.",$APP.U,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.Uv,xU,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kdb,$APP.X,M9a,$APP.h,new $APP.f(null,2,[$APP.P,"p.324",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[UR,$APP.DU,wmb],null))],null)],null),new $APP.f(null,3,[$APP.Q,F6b,$APP.X,function(a){return YQ($APP.Oj.j($APP.Uv),hL($APP.Oj.j($APP.Yv),a),iL($APP.Oj.j($APP.Sv),a))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WU],null))],null)],null),new $APP.f(null,3,[$APP.Q,aPb,$APP.X,function(a){return function(b){var c=
V9a(V8a(b));b=Q3a(a)(b);return TF.A(c,kG.C(b,c,$APP.y([gR.j(b)])))}},$APP.h,new $APP.f(null,2,[$APP.P,"Symplectic test in terms of matrices",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,Rxb,$APP.X,S9a,$APP.h,new $APP.f(null,2,[$APP.P,"p.326",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,msb,$APP.X,fR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[i7b],null))],null)],null),new $APP.f(null,
3,[$APP.Q,W7b,$APP.X,G9a,$APP.h,new $APP.f(null,2,[$APP.P,"the flow derivative generalizes the Lie derivative to allow for time dependent\n  H and F --- computes the 'time' derivative of F along the flow specified by H",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.Q,W8b,$APP.X,w9a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns function signature for a Hamiltonian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Hamiltonian literal functions.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,jVb,$APP.X,J9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[GU],null))],null)],null),new $APP.f(null,3,[$APP.Q,oTb,$APP.X,function(a){return wL.C($APP.y([$APP.NQ(a),ZQ(a)]))},$APP.h,new $APP.f(null,2,[$APP.P,"Given a hamiltonian state, returns a [[emmy.structure/up]] containing the\n  coordinate and momentum components. ",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(pob,$APP.Vv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Ipb,$APP.X,P9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[CU,Nxb],null))],null)],null),new $APP.f(null,3,[$APP.Q,wTb,$APP.X,z9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[kIb,mTb],null))],null)],null),new $APP.f(null,3,[$APP.Q,y4b,$APP.X,ZQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,c0b,$APP.X,function(a){return function(b){var c=
function(){var l=qL(b),n=UO.j?UO.j(fR):UO.call(null,fR);return n.j?n.j(l):n.call(null,l)}(),d=function(){var l=UO.j?UO.j(a):UO.call(null,a);return l.j?l.j(b):l.call(null,b)}(),g=sP.A(d,b);return TF.A(c,kG.C(d,c,$APP.y([g])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,kNb,$APP.X,function(a,b){return function(c){var d=$APP.x.B(c,0,null),g=$APP.x.B(c,1,null),l=$APP.x.B(g,0,null),n=$APP.x.B(g,1,null);c=$APP.x.B(c,2,null);var p=
$APP.x.B(c,0,null),v=$APP.x.B(c,1,null);return wL.C($APP.y([d,function(){var t=SF.A(mG.A(kG.A(a,l),kG.A(b,n)),mG.A(a,b)),A=TF.A(n,l);return wL.A?wL.A(t,A):wL.call(null,t,A)}(),function(){var t=mG.A(p,v),A=SF.A(TF.A(kG.A(a,v),kG.A(b,p)),mG.A(a,b));return SN.A?SN.A(t,A):SN.call(null,t,A)}()]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wW,xW],null))],null)],null),new $APP.f(null,3,[$APP.Q,AOb,$APP.X,ZQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the momentum element of a local Hamiltonian state tuple (by convention,\n  the third element).",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[YU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dY,YU),$APP.M($APP.aw,$APP.M($APP.tv,YU),2)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,gob,$APP.X,W9a,$APP.h,new $APP.f(null,2,[$APP.P,"p. 334 (used, but not defined there)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Uab,$APP.X,function(a,b){return LK.A(qG.j(kG.A(b,G9a(a))),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
BWb,null,1,null),new $APP.D(null,a,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))))},$APP.h,new $APP.f(null,2,[$APP.P,"The generalization of Lie-transform to include time dependence.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.DU,VR],null))],null)],null),new $APP.f(null,3,[$APP.Q,m$b,$APP.X,Y9a,$APP.h,new $APP.f(null,2,[$APP.P,"p. 334",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Q9b,$APP.X,csc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,
xvb,$APP.X,O9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,B$b,$APP.X,L9a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Qhb,$APP.X,B9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.Q,zub,$APP.X,Z9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,mrb,$APP.X,K9a,$APP.h,
new $APP.f(null,2,[$APP.P,"f is a function of (x y continue fail), which calls continue with the values of\n  x' y' that follow x y in the mapping.\n\n  Returns a map of the same shape that iterates the iterated map n times before\n  invoking the continuation, or invokes the fail continuation if the inner map\n  fails.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Iu,$APP.M($APP.mv,$APP.wU))],null)],null)))],
null)],null),new $APP.f(null,3,[$APP.Q,orb,$APP.X,$APP.$Q,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,yLb,$APP.X,V9a,$APP.h,new $APP.f(null,2,[$APP.P,"n \x3d\x3d degrees of freedom",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,oCb,$APP.X,y9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Esb,$APP.X,U9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[BU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ldb,$APP.X,ZQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,g$b,$APP.X,function(a,b){return IN(qL(b),a,1)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.Vv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,3,5,$APP.I,[$APP.M($APP.bw,$APP.M(fQb,$APP.Qr),1),$APP.M($APP.Kw,$APP.M(gmb,$APP.Qr)),$APP.M($APP.aw,$APP.M(gmb,$APP.Qr),2)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,hcb,$APP.X,x9a,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if the supplied state is\n\n  - of type [[emmy.structure/up]]\n\n  - contains three elements of `time`, `coordinate` and `momentum` of either of\n    the following type shapes:\n\n  ```\n  (up \x3cnumber\x3e \x3cnumber\x3e \x3cnumber\x3e)\n  (up \x3cnumber\x3e (up \x3cnumber\x3e*) (down \x3cnumber\x3e*))\n  ```\n\n  If structural, the dimension of the coordinate and momentum tuples must match.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,nec,$APP.X,function(a){return TO.B(qL(a),a,1)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,dub,$APP.X,function(a){var b=ISa(LF);return function(c,d,g){c=b(c-d);d=b(d-a*Math.sin(c));return g.A?g.A(c,d):g.call(null,c,d)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[GU],null))],null)],null),new $APP.f(null,3,[$APP.Q,rec,$APP.X,function(a,b){return function(c){return TF.A(fR(function(){var d=
a.j?a.j(c):a.call(null,c),g=UO.j?UO.j(b):UO.call(null,b);return g.j?g.j(d):g.call(null,d)}()),kG.A(function(){var d=UO.j?UO.j(a):UO.call(null,a);return d.j?d.j(c):d.call(null,c)}(),fR(function(){var d=YH.C($APP.y([b,a]));d=UO.j?UO.j(d):UO.call(null,d);return d.j?d.j(c):d.call(null,c)}())))}},$APP.h,new $APP.f(null,2,[$APP.P,"Tests that K yields a canonical transformation if the C is symplectic. (The\n  qp-canonical? code is really a symplectic test without factoring out the\n  Hamiltonian.)",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[UR,$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.Q,$Pb,$APP.X,function(a){return function(b){var c=MQ(b),d=$APP.NQ(b);var g=SQ.j?SQ.j(2):SQ.call(null,2);g=g.j?g.j(a):g.call(null,a);b=g.j?g.j(b):g.call(null,b);return QQ(c,d,b)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Cqb,$APP.X,I9a,$APP.h,new $APP.f(null,2,[$APP.P,"p. 428, the Lie transform is just the time-advance operator using the Lie\n  derivative (see Hamiltonian.scm).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.DU,$APP.Uv],null))],null)],null),new $APP.f(null,3,[$APP.Q,iob,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);return mG.A(SF.A(nG.j(c),kG.A(2,a)),kG.C(SF.A(1,2),b,$APP.y([nG.j(d)])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,HUb,$APP.X,function(a){return x9a(oL(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is compatible for contraction with a proper H-state, false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null)]),$APP.ap(rmb)),$APP.cp($APP.fg([$APP.z(p5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null))),$APP.P,"Takes a system derivative `R` and returns a operator that takes a function `F`\n  of coordinatized state and performs the operation described below, from\n  ODE.scm in scmutils:\n\n  Let `(sigma t)` be the state of a system at time `t`. Let the\n  (first-order) system of differential equations governing the evolution of\n  this state be:\n\n  ```clojure\n  ((D sigma) t) \x3d (R (sigma t))\n  ```\n\n  ```clojure\n  (D sigma) \x3d (compose R sigma)\n  ```\n\n  i.e. `R` is a system derivative.\n\n  Let `F` be any function of state, then a differential equation for the\n  evolution of `F`, as it is dragged along the integral curve sigma is:\n\n  ```clojure\n  (D (compose F sigma)) \x3d (* (compose (D F) sigma) (D sigma))\n  \x3d (compose (* (D F) R) sigma)\n  ```\n\n  Let's call this operation `Lie-D` (the Lie derivative for coordinates)."],
null)),$APP.z(uOb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Gx,VU],null)))],null)),$APP.z(dvb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[ZT],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(IT,ZT)],null)],null))))],null)),$APP.z(Uub,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))],null)),$APP.z(apb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,
$APP.I,[FX,VU],null))),$APP.P,"Returns a data structure representing [Christoffel symbols of the second\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_second_kind_(symmetric_definition))."],null)),$APP.z(Bnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))],null)),$APP.z(r5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[tyb],null)))],null)),$APP.z(jwb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[ycc,Bdb],null)))],null)),$APP.z(YAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null)))],null)),$APP.z(uIb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tY,rX,uW],null)))],null)),$APP.z(YRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,
1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(r5a,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QN],null)))],null)),$APP.z(IT,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(Hbc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[PV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(XW,PV)],null)],null))))],null)),$APP.z(Cob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null)))],null)),$APP.z(Lgb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null)))],null)),$APP.z(N1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tY,rX,uW],null)))],null)),$APP.z(XW,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(OMb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))],null)),$APP.z(wVb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))],null))],[new $APP.f(null,3,[$APP.Q,Fjb,$APP.X,q5a,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a system derivative `R` and returns a operator that takes a function `F`\n  of coordinatized state and performs the operation described below, from\n  ODE.scm in scmutils:\n\n  Let `(sigma t)` be the state of a system at time `t`. Let the\n  (first-order) system of differential equations governing the evolution of\n  this state be:\n\n  ```clojure\n  ((D sigma) t) \x3d (R (sigma t))\n  ```\n\n  ```clojure\n  (D sigma) \x3d (compose R sigma)\n  ```\n\n  i.e. `R` is a system derivative.\n\n  Let `F` be any function of state, then a differential equation for the\n  evolution of `F`, as it is dragged along the integral curve sigma is:\n\n  ```clojure\n  (D (compose F sigma)) \x3d (* (compose (D F) sigma) (D sigma))\n  \x3d (compose (* (D F) R) sigma)\n  ```\n\n  Let's call this operation `Lie-D` (the Lie derivative for coordinates).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null))],null)],null),new $APP.f(null,3,[$APP.Q,uhb,$APP.X,GP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Gx,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,xJb,$APP.X,B5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[ZT],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(IT,ZT)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,d_b,$APP.X,y5a,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,oac,$APP.X,JP,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a data structure representing [Christoffel symbols of the second\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_second_kind_(symmetric_definition)).",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[FX,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,KXb,$APP.X,z5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,QDb,$APP.X,C5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[tyb],null))],null)],null),new $APP.f(null,3,[$APP.Q,x1b,$APP.X,F5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[ycc,Bdb],null))],null)],null),new $APP.f(null,3,[$APP.Q,p4b,$APP.X,D5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Dib,$APP.X,N5a,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[tY,rX,uW],null))],null)],null),new $APP.f(null,3,[$APP.Q,HFb,$APP.X,MP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null))],null)],null),new $APP.f(null,3,[$APP.Q,zac,$APP.X,s5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[QN],null))],null)],null),new $APP.f(null,3,[$APP.Q,Adc,$APP.X,x5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],
null))],null)],null),new $APP.f(null,3,[$APP.Q,Qdc,$APP.X,A5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(XW,PV)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Jdc,$APP.X,M5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ccb,$APP.X,G5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],
null))],null)],null),new $APP.f(null,3,[$APP.Q,AEb,$APP.X,O5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[tY,rX,uW],null))],null)],null),new $APP.f(null,3,[$APP.Q,AAb,$APP.X,u5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,rXb,$APP.X,IP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))],null)],null),new $APP.f(null,3,[$APP.Q,kOb,$APP.X,HP,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))],null)],null)]),$APP.ap(i3b)),$APP.cp(new $APP.f(null,7,[$APP.z(Y7b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,DY],null),new $APP.H(null,3,5,$APP.I,[$APP.Sv,DY,bS],null))),$APP.P,"Given a polynomial `p`, and a sequence of variables `vars` (one for each\n  indeterminate in `p`), returns a symbolic expression representing the product\n  of all factors of `p`.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Sv,DY],null),new $APP.H(null,3,5,$APP.I,[$APP.Sv,DY,bS],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,DY],null),new $APP.H(null,3,5,$APP.I,[$APP.Sv,DY,bS],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,dPb,$APP.X,I2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a polynomial `p`, and a sequence of variables `vars` (one for each\n  indeterminate in `p`), returns a symbolic expression representing the product\n  of all factors of `p`.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,DY],null),new $APP.H(null,3,5,$APP.I,[$APP.Sv,DY,bS],null))],null)],null),$APP.z(e6b,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[nS,"null",ZX,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[ABb,Gvb],null))),$APP.P,"Positional factory function for emmy.polynomial.factor/t_emmy$polynomial$factor49028."],null)),
new $APP.f(null,3,[$APP.Q,eob,$APP.X,sqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.polynomial.factor/t_emmy$polynomial$factor49028.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[ABb,Gvb],null))],null)],null),$APP.z(wRb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,bS],null))),$APP.P,"Given some symbolic expression containing only polynomial operations, returns a\n  factored version of the expression with basic simplifications applied.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.\n\n  NOTE prefer [[factor]], as [[factor]] can handle expressions with\n  non-polynomial operations. The trigonometric functions, for example.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,bS],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,bS],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,nMb,$APP.X,J2,$APP.h,new $APP.f(null,2,[$APP.P,"Given some symbolic expression containing only polynomial operations, returns a\n  factored version of the expression with basic simplifications applied.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.\n\n  NOTE prefer [[factor]], as [[factor]] can handle expressions with\n  non-polynomial operations. The trigonometric functions, for example.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,bS],null))],null)],null),$APP.z(XIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given a [[Polynomial]] `p`, returns a sequence of factors of in order of\n  increasing power.\n\n  The first element is a constant factor, the next is a factor with power 1, and\n  so on."],null)),new $APP.f(null,3,[$APP.Q,tQb,$APP.X,i0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a [[Polynomial]] `p`, returns a sequence of factors of in order of\n  increasing power.\n\n  The first element is a constant factor, the next is a factor with power 1, and\n  so on.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),$APP.z(k0a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),$APP.P,"Given an unwrapped symbolic expression, returns a new symbolic expression with\n  any perfect square (exponent with an even power) removed from underneath any\n  `sqrt` that appears in the expression.\n\n  To use [[root-out-squares]] with a wrapped symbolic expression,\n  use [[emmy.expression/fmap]]."],null)),new $APP.f(null,
3,[$APP.Q,sLb,$APP.X,n0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an unwrapped symbolic expression, returns a new symbolic expression with\n  any perfect square (exponent with an even power) removed from underneath any\n  `sqrt` that appears in the expression.\n\n  To use [[root-out-squares]] with a wrapped symbolic expression,\n  use [[emmy.expression/fmap]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null),$APP.z(Cdc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Ww],null)))],null)),new $APP.f(null,3,[$APP.Q,mUb,$APP.X,sM,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null),YS,new $APP.f(null,3,[$APP.Q,b3b,$APP.X,tqc,$APP.h,$APP.F],null)],null),$APP.ap(mbc)),$APP.cp($APP.fg([$APP.z(bTb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yw],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yw,$APP.lw],null))),$APP.P,"Returns an [[Operator]] wrapping the supplied procedure `f` with the symbolic\n  name `name`. (`name` defaults to `'???`.)\n\n  Optionally accepts a `context` map that will be stored inside the\n  returned [[Operator]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yw],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yw,$APP.lw],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yw],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yw,$APP.lw],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(hDb,new $APP.f(null,5,[XE,
new $APP.ug(null,new $APP.f(null,8,[UW,"null",jU,"null",YE,"null",nS,"null",NY,"null",pT,"null",lW,"null",TV,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Tv,aU,$APP.Yw,$APP.lw,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,4,[UW,"null",nS,"null",pT,"null",lW,"null"],null),null),$APP.P,"Positional factory function for emmy.operator/Operator."],null)),$APP.z(cFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),
$APP.P,"Returns true if the supplied `x` is an instance of [[Operator]], false\n  otherwise."],null)),$APP.Fx,$APP.z(rdc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Sv],null)))],null)),$APP.z($APP.Yw,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))),$APP.P,"Returns the stored name of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied."],null)),$APP.z($APP.lw,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))),$APP.P,"Returns the context field of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied."],null)),$APP.z(XQb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null),new $APP.H(null,2,5,$APP.I,[FW,$APP.wU],null))),$APP.P,"Similar to `exp`, but takes an optional argument `n` that defines an order for\n  each term of the taylor series expansion.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,
new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[FW],null),new $APP.H(null,2,5,$APP.I,[FW,$APP.wU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null),new $APP.H(null,2,5,$APP.I,[FW,$APP.wU],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(mZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))),$APP.P,"Returns the backing procedure of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied."],null)),$APP.z($Eb,new $APP.f(null,
1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Sv],null)))],null)),$APP.z(aU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))),$APP.P,"Returns the arity of the supplied [[Operator]]. Errors if a non-[[Operator]] is\n  supplied."],null)),$APP.z(BJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))),$APP.P,"Returns an operator represented by a Taylor series expansion of $e^x$, applied\n  to `op`. This expanded series of operators is itself an operator that applies\n  each element to its argument.\n\n  Put another way: `(exp g)` to an operator g means forming the power series\n\n  ```\n  I + g + 1/2 g^2 + ... + 1/n! g^n\n  ```\n\n  where (as elsewhere) exponentiating the operator means `n`-fold composition."],
null))],[new $APP.f(null,3,[$APP.Q,oib,$APP.X,LK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an [[Operator]] wrapping the supplied procedure `f` with the symbolic\n  name `name`. (`name` defaults to `'???`.)\n\n  Optionally accepts a `context` map that will be stored inside the\n  returned [[Operator]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yw],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yw,$APP.lw],null))],null)],null),new $APP.f(null,
3,[$APP.Q,T5b,$APP.X,EK,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.operator/Operator.",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Tv,aU,$APP.Yw,$APP.lw,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,bMb,$APP.X,FK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `x` is an instance of [[Operator]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,g8b,$APP.X,Lpc,$APP.h,$APP.F],
null),new $APP.f(null,3,[$APP.Q,YIb,$APP.X,yZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,m0b,$APP.X,IK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the stored name of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ceb,$APP.X,JK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the context field of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))],null)],null),new $APP.f(null,3,[$APP.Q,T0b,$APP.X,f2,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to `exp`, but takes an optional argument `n` that defines an order for\n  each term of the taylor series expansion.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null),new $APP.H(null,2,5,$APP.I,[FW,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,SSb,$APP.X,GK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the backing procedure of the supplied [[Operator]]. Errors if a\n  non-[[Operator]] is supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))],null)],null),new $APP.f(null,3,[$APP.Q,vcc,$APP.X,PK,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,GBb,$APP.X,HK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the arity of the supplied [[Operator]]. Errors if a non-[[Operator]] is\n  supplied.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))],null)],null),new $APP.f(null,3,[$APP.Q,DTb,$APP.X,zZa,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns an operator represented by a Taylor series expansion of $e^x$, applied\n  to `op`. This expanded series of operators is itself an operator that applies\n  each element to its argument.\n\n  Put another way: `(exp g)` to an operator g means forming the power series\n\n  ```\n  I + g + 1/2 g^2 + ... + 1/n! g^n\n  ```\n\n  where (as elsewhere) exponentiating the operator means `n`-fold composition.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[FW],null))],null)],null)]),$APP.ap(QFb)),
$APP.cp($APP.fg([$APP.z(Rdb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.vU],null)))],null)),$APP.z(ZKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.FU,xU,KW,LW],null),new $APP.H(null,5,5,$APP.I,[$APP.FU,xU,KW,LW,ZV],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,5,$APP.qw,5,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[$APP.FU,xU,KW,LW],null),new $APP.H(null,5,5,$APP.I,[$APP.FU,xU,KW,LW,ZV],null)],null),
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.FU,xU,KW,LW],null),new $APP.H(null,5,5,$APP.I,[$APP.FU,xU,KW,LW,ZV],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(Oab,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,8,5,$APP.I,[bY,JW,CW,KW,DW,$APP.wU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[dW],null)],null)],null))),$APP.P,"SICM p. 23. The optional parameter values is a callback which will report\n  intermediate points of the minimization.",$APP.ky,new $APP.f(null,
6,[$APP.tu,!0,$APP.Un,6,$APP.qw,6,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(bY,JW,CW,KW,DW,$APP.wU,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[dW],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,8,5,$APP.I,[bY,JW,CW,KW,DW,$APP.wU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[dW],null)],null)],null)),$APP.Cx,$APP.M(null)],null)],null)),MPb,a7b,$APP.z(nib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GX],null))),$APP.P,"SICM p. 47. Polar to rectangular coordinates of state."],
null)),aob,$APP.z(YDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[JW,CW,KW,DW,ZSb],null))),$APP.P,"SICM p. 23n"],null)),Eeb,$APP.z(Pob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,KU],null))),$APP.P,"Lagrangian for a point mass on with the potential energy V(x, y)"],null)),$APP.z(IWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null)))],null)),$APP.z(L$b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.oO,UX,ZR],null)],null)))],null)),$APP.z(aqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))),$APP.P,"The state derivative of a Lagrangian is a function carrying a state tuple to\n  its time derivative.\n\n  Alias for the non-dissipative, single-arity version\n  of [[Lagrangian-\x3estate-derivative]]."],null)),oxb,$APP.z(R6b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,
3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null)))],null)),$APP.z(Oob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tU,$APP.Qr,nO],null)))],null)),$APP.z($APP.dv,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),0)],null)],null)))),$APP.P,"Extract the time slot from a state tuple.\n\n  See [[coordinate]] for more detail."],null)),
Sxb,$APP.z(CAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))],null)),$APP.z(eNb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[xW,hSb,KU],null)))],null)),$APP.z(otb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),2)],null)],null)))),$APP.P,"Returns the velocity element of a local tuple (by convention, the third\n  element).\n\n  See [[coordinate]] for more detail."],
null)),$APP.z(jJb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GX],null)))],null)),$APP.z(qob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Hw],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(aIb,$APP.Hw)],null)],null))))],null)),Izb,d3b,$APP.z(dAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bY],null)))],null)),$APP.z(bY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,
1,5,$APP.I,[$APP.wU],null))),$APP.P,"Returns a function signature for a Lagrangian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Lagrangian literal functions.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.wU],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.wU],null)),$APP.Cx,$APP.M(null,null)],null)],null)),Szb,gOb,$APP.z(sFb,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Uv,xU,TY,$APP.Lh,vT],null))),$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q`, velocity tuple (or scalar)\n  `qdot` and any number of additional higher-order derivative tuples (or\n  scalars), returns a 'Local tuple', i.e., the state expected by a Lagrangian.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Uv,xU,TY,vT)],null),$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,
[$APP.Uv,xU,TY,$APP.Lh,vT],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(jec,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,tU],null))),$APP.P,"The Lagrangian of an object experiencing uniform acceleration\n  in the negative y direction, i.e. the acceleration due to gravity"],null)),$APP.z(u5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.PW,$APP.QW,$APP.wU],null)))],null)),fFb,fZb,$APP.z(KVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),3)],null)],null)))),$APP.P,"Returns the acceleration element of a local tuple (by convention, the fourth\n  element).\n\n  See [[coordinate]] for more detail."],null)),$APP.z(J8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,
!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(eQb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null),$APP.z(new $APP.H(null,2,5,$APP.I,[xU,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,
[$APP.M($APP.aw,$APP.wU,1)],null)],null)))),$APP.P,"Gamma takes a path function (from time to coordinates) to a state\n  function (from time to local tuple).",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[xU,$APP.wU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[xU,$APP.wU],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(Hwb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),1)],null)],null)))),$APP.P,"A convenience function on local tuples. A local tuple describes\n  the state of a system at a particular time:\n\n  ```\n  [t, q, D q, D^2 q]\n  ```\n\n  representing time, position, velocity (and optionally acceleration etc.)\n\n  [[coordinate]] returns the `q` element, which is expected to be a mapping from\n  time to a structure of coordinates."],
null)),$APP.z(Qvb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,yyb],null)))],null)),Lvb,$APP.z(sgb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.oO,ZR],null)],null)))],null)),ldb,xyb,$APP.z(upb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))],null)),$APP.z(F2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[nrb],null))),$APP.P,"Given a state tuple (of finite length), reconstitutes the initial segment of\n  the Taylor series corresponding to the state tuple data as a function of t.\n\n  Time is measured beginning at the point of time specified in the input state\n  tuple."],
null)),$APP.z(glb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[kIb,mTb],null)))],null)),$APP.z(nTb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))],null)),$APP.z(Mqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.vU],null))),$APP.P,"The Lagrangian of a simple harmonic oscillator (mass-spring\n  system). m is the mass and k is the spring constant used in\n  Hooke's law. The resulting Lagrangian is a function of the\n  local tuple of the system."],
null)),$APP.z(izb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))],null)),$APP.z(Myb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],
null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(hsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[xW,hSb,nO,tU],null))),$APP.P,"Pendulum of mass m2 and length b, hanging from a support of mass m1 that is\n  free to move horizontally (from Groesberg, Advanced Mechanics, p. 72)"],null)),$APP.z(pJb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rV],null)))],null)),$APP.z(Tib,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[fUb,$APP.ix],null))),$APP.P,"Given `ys` (a sequence of function values) and `xs` (an equal-length sequence\n  of function inputs), returns a [[emmy.polynomial/Polynomial]] instance\n  guaranteed to pass through all supplied `xs` and `ys`.\n\n  The contract for inputs is that `(map vector xs ys)` should return a sequence\n  of pairs of points."],null)),$APP.z(s3b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],
null)))],null)),$APP.z(fob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,xxb],null)))],null)),cxb,$APP.z(XJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[bY,JW,CW,KW,DW],null))),$APP.P,"SICM p. 23"],null)),$APP.z(Cbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rvb],null))),$APP.P,"The lagrangian of a free particle of mass m. The Lagrangian\n  returned is a function of the local tuple. Since the particle\n  is free, there is no potential energy, so the Lagrangian is\n  just the kinetic energy."],
null)),$APP.z(E4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,yyb],null))),$APP.P,"Consider planar motion in a central force field, with an arbitrary potential,\n  `U`, depending only on the radius. The generalized coordinates are polar."],null)),$APP.z(iUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,UR,PNb],null)))],null)),$APP.z(ZDb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WU],null)))],null)),
bob,$APP.z(UJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rV],null))),$APP.P,"SICM p. 83"],null)),cMb,$APP.z(RPb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null)))],null)),Zdb,$APP.z(eec,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Qzb,$APP.Qr],null)))],null)),$APP.z(u4b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,
xY],null))),$APP.P,"Optionally takes a dissipation function.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(PPb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.vU],null)))],
null)),$APP.z(xIb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(sOb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Wv],null)))],null)),Mnb,$APP.z(j1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null)],null)))],null)),bgb],[new $APP.f(null,3,[$APP.Q,YYb,$APP.X,function(a){return function(b){$APP.x.B(b,0,null);$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);return kG.C(b,a,$APP.y([b]))}},$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,y1b,$APP.X,UQ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.FU,xU,KW,LW],null),new $APP.H(null,5,5,$APP.I,[$APP.FU,xU,KW,LW,ZV],null))],null)],null),new $APP.f(null,3,[$APP.Q,cKb,$APP.X,y4,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 23. The optional parameter values is a callback which will report\n  intermediate points of the minimization.",$APP.U,$APP.M(new $APP.H(null,8,
5,$APP.I,[bY,JW,CW,KW,DW,$APP.wU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[dW],null)],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,sNb,$APP.X,TQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,hKb,$APP.X,PQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,d9b,$APP.X,r9a,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 47. Polar to rectangular coordinates of state.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[GX],null))],null)],null),new $APP.f(null,3,[$APP.Q,EDb,$APP.X,MQ,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.Q,Gkb,$APP.X,g9a,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 23n",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[JW,CW,KW,DW,ZSb],null))],null)],null),new $APP.f(null,3,[$APP.Q,w3b,$APP.X,OQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,U2b,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);c=$APP.x.B(c,2,null);return TF.A(kG.C(SF.A(1,2),a,$APP.y([nG.j(c)])),b.A?b.A(g,d):b.call(null,g,d))}},
$APP.h,new $APP.f(null,2,[$APP.P,"Lagrangian for a point mass on with the potential energy V(x, y)",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,KU],null))],null)],null),new $APP.f(null,3,[$APP.Q,D6b,$APP.X,k9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Acb,$APP.X,s9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.oO,UX,ZR],null)],null))],null)],null),new $APP.f(null,
3,[$APP.Q,YXb,$APP.X,function(a){return $APP.RQ.A(a,null)},$APP.h,new $APP.f(null,2,[$APP.P,"The state derivative of a Lagrangian is a function carrying a state tuple to\n  its time derivative.\n\n  Alias for the non-dissipative, single-arity version\n  of [[Lagrangian-\x3estate-derivative]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Eob,$APP.X,SN,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Gwb,$APP.X,u9a,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,Pjb,$APP.X,function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null);d=$APP.x.B(d,2,null);return mG.A(kG.C(SF.A(1,2),b,$APP.y([nG.j(kG.A(c,d))])),kG.C(a,b,$APP.y([c,hO.j(g)])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[tU,$APP.Qr,nO],null))],null)],null),new $APP.f(null,3,[$APP.Q,e_b,$APP.X,MQ,$APP.h,new $APP.f(null,
2,[$APP.P,"Extract the time slot from a state tuple.\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,qbc,$APP.X,PQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,MOb,$APP.X,c9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))],null)],null),new $APP.f(null,
3,[$APP.Q,Uvb,$APP.X,function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null),l=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);var n=$APP.x.B(d,2,null);d=$APP.x.B(n,0,null);n=$APP.x.B(n,1,null);return TF.A(mG.A(kG.C(SF.A(1,2),a,$APP.y([nG.j(d)])),kG.C(SF.A(1,2),b,$APP.y([nG.j(n)]))),c.A?c.A(l,g):c.call(null,l,g))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[xW,hSb,KU],null))],null)],null),new $APP.f(null,3,[$APP.Q,qLb,$APP.X,OQ,$APP.h,new $APP.f(null,2,[$APP.P,
"Returns the velocity element of a local tuple (by convention, the third\n  element).\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),2)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,nKb,$APP.X,p9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[GX],null))],null)],null),new $APP.f(null,3,[$APP.Q,p7b,$APP.X,V8a,$APP.h,
new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Hw],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(aIb,$APP.Hw)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Pvb,$APP.X,WQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Cac,$APP.X,a9a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Fab,$APP.X,n9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bY],null))],null)],null),new $APP.f(null,3,[$APP.Q,NMb,$APP.X,v4,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a function signature for a Lagrangian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Lagrangian literal functions.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,kwb,$APP.X,wL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,htb,$APP.X,m9a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Dvb,$APP.X,QQ,$APP.h,new $APP.f(null,2,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q`, velocity tuple (or scalar)\n  `qdot` and any number of additional higher-order derivative tuples (or\n  scalars), returns a 'Local tuple', i.e., the state expected by a Lagrangian.",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Uv,xU,TY,$APP.Lh,vT],null))],null)],null),new $APP.f(null,3,[$APP.Q,wMb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);c=$APP.x.B(c,2,null);return TF.A(kG.C(SF.A(1,2),a,$APP.y([nG.j(c)])),kG.C(a,b,$APP.y([d])))}},$APP.h,new $APP.f(null,2,[$APP.P,"The Lagrangian of an object experiencing uniform acceleration\n  in the negative y direction, i.e. the acceleration due to gravity",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,tU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Efb,$APP.X,e9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.PW,$APP.QW,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,qdb,$APP.X,$APP.NQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Iwb,$APP.X,QQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,J6b,$APP.X,PQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the acceleration element of a local tuple (by convention, the fourth\n  element).\n\n  See [[coordinate]] for more detail.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),3)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Beb,$APP.X,x4,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wrb,$APP.X,TQ,$APP.h,new $APP.f(null,2,[$APP.P,"Gamma takes a path function (from time to coordinates) to a state\n  function (from time to local tuple).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null),$APP.z(new $APP.H(null,2,5,$APP.I,[xU,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.aw,$APP.wU,1)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,ZAb,$APP.X,$APP.NQ,$APP.h,new $APP.f(null,2,[$APP.P,"A convenience function on local tuples. A local tuple describes\n  the state of a system at a particular time:\n\n  ```\n  [t, q, D q, D^2 q]\n  ```\n\n  representing time, position, velocity (and optionally acceleration etc.)\n\n  [[coordinate]] returns the `q` element, which is expected to be a mapping from\n  time to a structure of coordinates.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),1)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,ffb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null),g=$APP.x.B(c,2,null);c=TF.A;g=kG.C(SF.A(1,2),a,$APP.y([nG.j(g)]));d=jG.j(d);d=b.j?b.j(d):b.call(null,d);return c.call(TF,g,d)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Qr,yyb],null))],null)],null),new $APP.f(null,3,[$APP.Q,fwb,$APP.X,m9a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,hAb,$APP.X,q9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.oO,ZR],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,L5b,$APP.X,PQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,eXb,$APP.X,$APP.NQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,bib,$APP.X,m9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,
$APP.I,[$APP.FU],null))],null)],null),new $APP.f(null,3,[$APP.Q,BDb,$APP.X,j9a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a state tuple (of finite length), reconstitutes the initial segment of\n  the Taylor series corresponding to the state tuple data as a function of t.\n\n  Time is measured beginning at the point of time specified in the input state\n  tuple.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nrb],null))],null)],null),new $APP.f(null,3,[$APP.Q,TVb,$APP.X,function(a,b){return TF.A(a,b)},$APP.h,
new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[kIb,mTb],null))],null)],null),new $APP.f(null,3,[$APP.Q,lwb,$APP.X,a9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Erb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);return TF.A(kG.C(SF.A(1,2),a,$APP.y([nG.j(c)])),kG.C(SF.A(1,2),b,$APP.y([nG.j(d)])))}},$APP.h,new $APP.f(null,2,[$APP.P,"The Lagrangian of a simple harmonic oscillator (mass-spring\n  system). m is the mass and k is the spring constant used in\n  Hooke's law. The resulting Lagrangian is a function of the\n  local tuple of the system.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,OGb,$APP.X,VQ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,TGb,$APP.X,w4,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null))],null)],null),new $APP.f(null,3,[$APP.Q,tSb,$APP.X,function(a,b,c,d){var g=YH,l=g.C;a=Z8a(a,b,d);c=Y8a(c);c=$APP.XQ.j?
$APP.XQ.j(c):$APP.XQ.call(null,c);return l.call(g,$APP.y([a,c]))},$APP.h,new $APP.f(null,2,[$APP.P,"Pendulum of mass m2 and length b, hanging from a support of mass m1 that is\n  free to move horizontally (from Groesberg, Advanced Mechanics, p. 72)",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[xW,hSb,nO,tU],null))],null)],null),new $APP.f(null,3,[$APP.Q,lKb,$APP.X,v9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rV],null))],null)],null),new $APP.f(null,3,[$APP.Q,bfb,$APP.X,f9a,
$APP.h,new $APP.f(null,2,[$APP.P,"Given `ys` (a sequence of function values) and `xs` (an equal-length sequence\n  of function inputs), returns a [[emmy.polynomial/Polynomial]] instance\n  guaranteed to pass through all supplied `xs` and `ys`.\n\n  The contract for inputs is that `(map vector xs ys)` should return a sequence\n  of pairs of points.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[fUb,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,Drb,$APP.X,b9a,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Dmb,$APP.X,function(a,b){return TF.A(d9a(a),function(c){$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);c=$APP.x.B(c,0,null);return b.j?b.j(c):b.call(null,c)})},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,xxb],null))],null)],null),new $APP.f(null,3,[$APP.Q,idc,$APP.X,QQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,xfb,$APP.X,i9a,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 23",$APP.U,
$APP.M(new $APP.H(null,5,5,$APP.I,[bY,JW,CW,KW,DW],null))],null)],null),new $APP.f(null,3,[$APP.Q,XBb,$APP.X,$APP.X8a,$APP.h,new $APP.f(null,2,[$APP.P,"The lagrangian of a free particle of mass m. The Lagrangian\n  returned is a function of the local tuple. Since the particle\n  is free, there is no potential energy, so the Lagrangian is\n  just the kinetic energy.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rvb],null))],null)],null),new $APP.f(null,3,[$APP.Q,iqb,$APP.X,function(a,b){return function(c){$APP.x.B(c,
0,null);var d=$APP.x.B(c,1,null);d=$APP.x.B(d,0,null);var g=$APP.x.B(c,2,null);c=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return TF.A(kG.C(SF.A(1,2),a,$APP.y([mG.A(nG.j(c),nG.j(kG.A(d,g)))])),b.j?b.j(d):b.call(null,d))}},$APP.h,new $APP.f(null,2,[$APP.P,"Consider planar motion in a central force field, with an arbitrary potential,\n  `U`, depending only on the radius. The generalized coordinates are polar.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,yyb],null))],null)],null),new $APP.f(null,
3,[$APP.Q,GCb,$APP.X,function(a,b,c){return function(d){$APP.x.B(d,0,null);var g=$APP.x.B(d,1,null);g=$APP.x.B(g,0,null);var l=$APP.x.B(d,2,null);d=$APP.x.B(l,0,null);var n=$APP.x.B(l,1,null);l=$APP.x.B(l,2,null);return mG.C(kG.C(SF.A(1,2),a,$APP.y([mG.A(nG.j(d),nG.j(kG.A(n,iO.j(g))))])),kG.C(SF.A(1,2),b,$APP.y([nG.j(mG.A(l,kG.A(n,hO.j(g))))])),$APP.y([kG.C(-1,c,$APP.y([hO.j(g)]))]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[BU,UR,PNb],null))],null)],null),new $APP.f(null,
3,[$APP.Q,Vrb,$APP.X,W8a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[WU],null))],null)],null),new $APP.f(null,3,[$APP.Q,CDb,$APP.X,$APP.NQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,nwb,$APP.X,t9a,$APP.h,new $APP.f(null,2,[$APP.P,"SICM p. 83",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rV],null))],null)],null),new $APP.f(null,3,[$APP.Q,drb,$APP.X,OQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,xsb,$APP.X,d9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,rhb,$APP.X,wL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,S_b,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);d=$APP.x.B(d,0,null);var g=$APP.x.B(c,2,null);c=$APP.x.B(g,0,null);g=$APP.x.B(g,1,null);return mG.A(kG.C(SF.A(1,2),b,$APP.y([mG.A(nG.j(c),nG.j(kG.A(d,g)))])),SF.A(kG.A(a,b),d))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[Qzb,$APP.Qr],null))],null)],null),new $APP.f(null,
3,[$APP.Q,agb,$APP.X,$APP.RQ,$APP.h,new $APP.f(null,2,[$APP.P,"Optionally takes a dissipation function.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null))],null)],null),new $APP.f(null,3,[$APP.Q,TJb,$APP.X,function(a,b){return function(c){$APP.x.B(c,0,null);var d=$APP.x.B(c,1,null);c=$APP.x.B(c,2,null);return TF.A(kG.C(SF.A(1,2),c,$APP.y([a,c])),kG.C(SF.A(1,2),d,$APP.y([b,d])))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Qr,$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,HJb,$APP.X,$APP.XQ,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a coordinate transformation `F` from a local tuple to a new coordinate\n  structure, and returns a function from `local -\x3e local` that applies the\n  transformation directly.\n\n  [[F-\x3eC]] handles local tuples of arbitrary length.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wvb,$APP.X,$8a,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[xU,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Yqb,$APP.X,wL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,F1b,$APP.X,o9a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,Eub,$APP.X,OQ,$APP.h,$APP.F],null)]),$APP.ap(bub)),$APP.cp($APP.fg([$APP.z(Qmb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],
null)),$APP.z(sXb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(qQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(oRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(G3b,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(A9b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,Fdb],null))),$APP.P,"Takes a function and returns a pair of:\n\n  - an atom that keeps track of fn invocation counts,\n  - the instrumented fn",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,Fdb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,Fdb],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($APP.Jya,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(Otb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(dCb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(nnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(ybb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Qr],null))),$APP.P,"Returns a map of identical type and key set to `m`, with each value `v`\n  transformed by the supplied function`f` into `(f v)`."],
null)),$APP.z($APP.zx,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"Returns a string containing a randomly generated unique identifier."],null)),$APP.z($APP.ZDa,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),JCb,$APP.z(V$b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(XRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,
"Walks x, removing namespaces from any symbols that are found.\n  Convenient in unit tests, where the distinction between symbols\n  in `clojure.core` vs. `cljs.core` is unimportant"],null)),Rzb,$APP.z(V5b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(I5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if the supplied `x` is a `BigInt`, false otherwise."],null)),$APP.z(jHb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null)))],null)),$APP.z(xEb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(zMb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Uv],null)))],null)),$APP.z(QGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[IW,$APP.Vv],null))),$APP.P,"Returns true if s matches the regex pattern re, false otherwise."],null)),$APP.z(g4b,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(uXb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z($APP.py,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(aub,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z($APP.Av,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(Czb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(SCb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(Lnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),oNb,$APP.z(n1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null))],[new $APP.f(null,3,[$APP.Q,Wnb,$APP.X,VNa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,sfb,$APP.X,OR,$APP.h,$APP.F],
null),new $APP.f(null,3,[$APP.Q,Fcc,$APP.X,XNa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,UQb,$APP.X,function(a){return Number.isNaN(a)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,DGb,$APP.X,$APP.za,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,RKb,$APP.X,VY,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function and returns a pair of:\n\n  - an atom that keeps track of fn invocation counts,\n  - the instrumented fn",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,Fdb],null))],null)],null),new $APP.f(null,3,[$APP.Q,ekb,$APP.X,TNa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,gIb,$APP.X,AD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,s5b,$APP.X,wD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,XVb,$APP.X,function(a){throw Error(a);},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,CZb,$APP.X,sD,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a map of identical type and key set to `m`, with each value `v`\n  transformed by the supplied function`f` into `(f v)`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,
TZb,$APP.X,xD,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string containing a randomly generated unique identifier.",$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.Q,okb,$APP.X,YNa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,mlb,$APP.X,uec,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,SY,$APP.X,uD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,
3,[$APP.Q,OQb,$APP.X,function(a){return $APP.Ao(function(b){return $APP.ce(b)?$APP.Zg.j($APP.Ag(b)):b},a)},$APP.h,new $APP.f(null,2,[$APP.P,"Walks x, removing namespaces from any symbols that are found.\n  Convenient in unit tests, where the distinction between symbols\n  in `clojure.core` vs. `cljs.core` is unimportant",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,nhb,$APP.X,WY,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,J0b,$APP.X,function(a){throw Error(a);
},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,WWb,$APP.X,SNa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `x` is a `BigInt`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,yFb,$APP.X,rD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,vqb,$APP.X,$APP.qa,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.Q,aYb,$APP.X,function(a){return a instanceof Error},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Uv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Hcb,$APP.X,tD,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if s matches the regex pattern re, false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[IW,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,mPb,$APP.X,JR,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,deb,$APP.X,
function(a){return BigInt(a)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,eac,$APP.X,vD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,rKb,$APP.X,zD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,R1b,$APP.X,UNa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Uyb,$APP.X,WNa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,aCb,$APP.X,vec,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,KOb,$APP.X,yD,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,vJb,$APP.X,mQ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Qkb,$APP.X,function(a){return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,
SY,null,1,null),new $APP.D(null,a,null,1,null))))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null)]),$APP.ap(jkb)),$APP.cp($APP.fg([$APP.z(oU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures."],null)),$APP.z(zP,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,
$APP.ix],null))),$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ix)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(t2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))),$APP.P,"Construct a down (covariant) tuple from the supplied sequence. For a\n  variadic version, see [[down]]."],
null)),$APP.z(x2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns `true` if `s` is a `down` structure, false otherwise."],null)),$APP.z($APP.CY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"If `s` is sequential, returns its dimension, i.e., the total number of\n  non-sequential entries in the structure. Else, returns 1."],null)),$APP.z($Vb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(smb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null))),$APP.P,"For a non-[[Structure]] `s`, the single-arity case acts as [[identity]]. For\n  a [[Structure]], returns an identical structure with its orientation\n  reversed (up becomes down, down becomes up).\n\n  NOTE that a vector is interpreted as an `up` structure, so:\n\n  (opposite [1 2 3])\n  ;;\x3d\x3e (down 1 2 3)\n\n  The two-arity case returns a new [[Structure]] of opposite orientation to `s`\n  with the contents of the sequence `xs`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(gzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,
[$APP.M($APP.ax,$APP.Wv)],null)],null)))),$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient."],null)),$APP.z(m6b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null))),$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(LOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `s` is an `up` or `down` structure containing all `up` or\n  `down` structures of internally-matching orientation and size, false\n  otherwise."],
null)),$APP.z(k0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,$APP.Vv],null))),$APP.P,"Accepts\n\n  - some symbolic (or string) `name`\n  - a structure `s`\n\n  and returns a new structure of identical shape, with symbolic entries like\n  `'x↑0_1` that show their access chain with proper orientations for each step."],null)),$APP.z(OY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise."],
null)),$APP.z(Fub,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(Zhb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(E7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Return the structure `s` in unoriented vector form."],null)),$APP.z(Bmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))),$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```"],
null)),$APP.z(pKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a structure of the same shape and orientation as `s`, generated by\n  substituting gensymmed symbols in for each entry."],null)),UDb,$APP.z(iU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[oU,$APP.ix],null))),$APP.P,"Generate a structure with the supplied orientation, given some sequence `xs`"],null)),$APP.z(XHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null))),$APP.P,"Returns a new structure of equivalent shape to `s`, generated by applying `f`\n  to three arguments:\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  For example:\n\n  ```clojure\n  (dorun (map-chain println (s/down (s/up 1 2) (s/up 3 4))))\n\n  1 [0 0] [::s/down ::s/up]\n  2 [0 1] [::s/down ::s/up]\n  3 [1 0] [::s/down ::s/up]\n  4 [1 1] [::s/down ::s/up]\n  ```"],
null)),$APP.z(FIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a structure compatible for multiplication with `s` down to 0."],null)),Opb,$APP.z(Ngb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Rv,uU],null))),$APP.P,"Returns `1` if `i`\x3d\x3d `j`, `0` otherwise."],null)),$APP.z(SRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.Uv],null))),$APP.P,"Returns true if the supplied structures have the same orientation, false\n  otherwise."],
null)),$APP.z(A5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null)))),$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient."],null)),$APP.z(YPb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.CY,oU,$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,oU)],null)],null)))),$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`."],null)),$APP.z(HAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))),$APP.P,"Returns the (vector) inner product of `v1` and `v2`; this is equivalent to the\n  sum of the pairwise product of each entry.\n\n    This is equivalent to [[vector-dot-product]] with every element of `v1`\n  transformed into its complex conjugate.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]]."],
null)),$APP.z(sW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null))),$APP.P,"Returns true if the supplied orientation lives in the set of allowed\n  orientations, false otherwise."],null)),$APP.z(OHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)"],null)),$APP.z(Vlb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a new structure with the same orientation as the first element of `s`,\n  filled with elements of the same orientation as `s`.\n\n  Each element is generating by taking the first element of each entry in `s`,\n  the the second, etc... In that sense this is similar to a traditional matrix\n  transpose.\n\n  A comment from `scmutils` states:\n\n  'used only in symmetrize-Christoffel in\n  src/calculus/covariant-derivative.scm.'"],null)),$APP.z(NK,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,qS],null))),$APP.P,"Given an access chain (a sequence of indices), return a function that accepts a\n  structure and returns the element at the specified access chain.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(qS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,qS],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(FAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Vv,$APP.ix],null))),$APP.P,"Returns a structure containing `xs` with the same orientation as `s`."],null)),$APP.z(Gib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Yx,$APP.yY,oU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,oU)],null)],null)))),$APP.P,"Generates a structure of the specified `orientation` and dimension `size`\n  populated by symbolic entries, each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  (\x3d (literal 'x 3 ::s/up)\n     (up 'x↑0 'x↑1 'x↑2))\n\n  See [[literal-up]] and [[literal-down]] for constructors with baked in\n  orientations."],
null)),$APP.z(Pmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UY,$APP.vv],null),new $APP.H(null,3,5,$APP.I,[bF,UY,$APP.vv],null))),$APP.P,"Given:\n\n  - a sequence of `values`\n  - a model `struct`\n\n  Returns a new structure generated by unpacking `values` into a structure with\n  the same shape as `struct`.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[UY,$APP.vv],null),new $APP.H(null,3,
5,$APP.I,[bF,UY,$APP.vv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[UY,$APP.vv],null),new $APP.H(null,3,5,$APP.I,[bF,UY,$APP.vv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(Hab,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given an `up` or `down` structure containing structures of the same\n  orientation and size (a 2 tensor), returns a dictionary with keys:\n\n  ```clj\n  {:outer-orientation \x3c::up or ::down\x3e\n   :inner-orientation \x3c::up or ::down\x3e\n   :outer-size \x3cint\x3e\n   :inner-size \x3cint\x3e}\n\n  If `s` is _not_ a valid tensor, returns nil.\n  ```"],
null)),$APP.z(Oub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Return a structure of the same shape as `s` whose elements are access chains\n  corresponding to position of each element (i.e., the sequence of indices\n  needed to address that element via [[get-in]]).\n\n  Each access chain has the sequence of orientations (`::s/up`, `::s/down`)\n  associated with each step attached to it as metadata, under an `:orientations`\n  key. Use this if the orientation of the indices matters."],
null)),$APP.z(Q0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))),$APP.P,"Returns the (vector) dot product of `v1` and `v2`; this is equivalent to the sum\n  of the pairwise product of each entry.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]]."],null)),$APP.z(Gcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))),$APP.P,"Construct an up (contravariant) tuple from the supplied sequence. For a\n  variadic version, see [[up]]."],
null)),$APP.z(Mvb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null))),$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Nv,CV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null)),$APP.Cx,
$APP.M(null)],null)],null)),$APP.z(vmb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.Vv],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.JT,$APP.Vv],null))),$APP.P,"Returns the result of accumulating all non-structural entries in `s` using the\n  supplied fold function `f` into the optional accumulator `init` (defaults\n  to `(f)`).\n\n  `f` must be a 2-argument fn of type `(accumulator, [x chain orientations]) \x3d\x3e\n  accumulator` responsible for merging some value `x` into the ongoing\n  accumulation. The second argument is a 3-vector containing\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  `f` should return a new instance of the accumulator.\n\n  Additional arities allow you to supply\n\n  - `init`, the initial (empty) accumulator (defaults to `(f)`)\n  - `present`, a function that will be applied to the final, aggregated\n    result (defaults to `f`)\n\n  For example:\n\n  ```clojure\n  (fold-chain\n    (fn ([] [])\n     ([acc] acc)\n     ([acc [s chain orientations]]\n      (conj acc {:s s\n                 :chain chain\n                 :orientations orientations})))\n    (s/down (s/up 1 2) (s/up 3 4)))\n\n  [{:s 1, :chain [0 0], :orientations [::s/down ::s/up]}\n   {:s 2, :chain [0 1], :orientations [::s/down ::s/up]}\n   {:s 3, :chain [1 0], :orientations [::s/down ::s/up]}\n   {:s 4, :chain [1 1], :orientations [::s/down ::s/up]}]\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.Vv],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.JT,$APP.Vv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.Vv],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.JT,$APP.Vv],null)),$APP.Cx,$APP.M(null,null,null)],
null)],null)),$APP.z(TFb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(yP,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))),$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ix)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z($APP.XX,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a structure with the same shape as `s`, with all orientations\n  inverted."],null)),$APP.z(Ixb,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,22,[bT,"null",NT,"null",UV,"null",mU,"null",UW,"null",qU,"null",jU,"null",YE,"null",OLb,"null",zX,"null",US,"null",tS,"null",nS,"null",NY,"null",iV,"null",wX,"null",wY,"null",pT,"null",TW,"null",lW,"null",TV,"null",vY,"null"],null),null),$APP.ow,
UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[oU,$APP.Wv,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,17,[bT,"null",NT,"null",UV,"null",mU,"null",UW,"null",qU,"null",zX,"null",US,"null",tS,"null",nS,"null",iV,"null",wX,"null",wY,"null",pT,"null",TW,"null",lW,"null",vY,"null"],null),null),$APP.P,"Positional factory function for emmy.structure/Structure."],null)),$APP.z(yCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms."],
null)),$APP.z(arb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))),$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x↑0 'x↑1 'x↑2))\n  ```"],null)),$APP.z(OCb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null)),$APP.z(DZb,new $APP.f(null,1,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))],null))],[new $APP.f(null,3,[$APP.Q,Asb,$APP.X,VK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,NP,$APP.X,wL,$APP.h,new $APP.f(null,2,[$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,h8b,$APP.X,cL,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a down (covariant) tuple from the supplied sequence. For a\n  variadic version, see [[down]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,F8b,$APP.X,DZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is a `down` structure, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ngb,$APP.X,WK,$APP.h,new $APP.f(null,2,[$APP.P,"If `s` is sequential, returns its dimension, i.e., the total number of\n  non-sequential entries in the structure. Else, returns 1.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,yIb,$APP.X,fqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,$Hb,$APP.X,v2,$APP.h,new $APP.f(null,
2,[$APP.P,"For a non-[[Structure]] `s`, the single-arity case acts as [[identity]]. For\n  a [[Structure]], returns an identical structure with its orientation\n  reversed (up becomes down, down becomes up).\n\n  NOTE that a vector is interpreted as an `up` structure, so:\n\n  (opposite [1 2 3])\n  ;;\x3d\x3e (down 1 2 3)\n\n  The two-arity case returns a new [[Structure]] of opposite orientation to `s`\n  with the contents of the sequence `xs`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,H9b,$APP.X,NZa,$APP.h,new $APP.f(null,2,[$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,
new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,eqb,$APP.X,m2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.Q,DNb,$APP.X,LZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is an `up` or `down` structure containing all `up` or\n  `down` structures of internally-matching orientation and size, false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,PDb,$APP.X,RZa,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts\n\n  - some symbolic (or string) `name`\n  - a structure `s`\n\n  and returns a new structure of identical shape, with symbolic entries like\n  `'x↑0_1` that show their access chain with proper orientations for each step.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,uAb,$APP.X,YK,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,dyb,$APP.X,mL,$APP.h,new $APP.f(null,2,[$APP.P,"Return a structure with the same shape as s but with f applied to each\n  primitive (that is, not structural) component.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null))],null)],null),new $APP.f(null,3,[$APP.Q,C_b,$APP.X,eqc,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,A4b,$APP.X,TK,$APP.h,new $APP.f(null,2,[$APP.P,"Return the structure `s` in unoriented vector form.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ghb,$APP.X,iL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))],null)],null),new $APP.f(null,3,[$APP.Q,job,$APP.X,nL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure of the same shape and orientation as `s`, generated by\n  substituting gensymmed symbols in for each entry.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,fgb,$APP.X,BP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Wyb,$APP.X,aL,$APP.h,new $APP.f(null,2,[$APP.P,"Generate a structure with the supplied orientation, given some sequence `xs`",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[oU,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,Nbc,$APP.X,kL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new structure of equivalent shape to `s`, generated by applying `f`\n  to three arguments:\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  For example:\n\n  ```clojure\n  (dorun (map-chain println (s/down (s/up 1 2) (s/up 3 4))))\n\n  1 [0 0] [::s/down ::s/up]\n  2 [0 1] [::s/down ::s/up]\n  3 [1 0] [::s/down ::s/up]\n  4 [1 1] [::s/down ::s/up]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,z1b,$APP.X,pL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure compatible for multiplication with `s` down to 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,skb,$APP.X,pL,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Mtb,$APP.X,AZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `1` if `i`\x3d\x3d `j`, `0` otherwise.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Rv,uU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Nlb,$APP.X,FZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied structures have the same orientation, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.Uv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xmb,$APP.X,MZa,$APP.h,new $APP.f(null,2,[$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,qUb,$APP.X,eL,$APP.h,new $APP.f(null,2,[$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`.",$APP.U,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.CY,oU,$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,
oU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,kdc,$APP.X,VZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the (vector) inner product of `v1` and `v2`; this is equivalent to the\n  sum of the pairwise product of each entry.\n\n    This is equivalent to [[vector-dot-product]] with every element of `v1`\n  transformed into its complex conjugate.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.NW,$APP.OW],null))],null)],null),new $APP.f(null,3,[$APP.Q,oYb,$APP.X,EZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied orientation lives in the set of allowed\n  orientations, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Tv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Q6b,$APP.X,XK,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Pdc,$APP.X,SZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new structure with the same orientation as the first element of `s`,\n  filled with elements of the same orientation as `s`.\n\n  Each element is generating by taking the first element of each entry in `s`,\n  the the second, etc... In that sense this is similar to a traditional matrix\n  transpose.\n\n  A comment from `scmutils` states:\n\n  'used only in symmetrize-Christoffel in\n  src/calculus/covariant-derivative.scm.'",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kbb,$APP.X,tP,$APP.h,new $APP.f(null,2,[$APP.P,"Given an access chain (a sequence of indices), return a function that accepts a\n  structure and returns the element at the specified access chain.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,qS],null))],null)],null),new $APP.f(null,3,[$APP.Q,lrb,$APP.X,dL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure containing `xs` with the same orientation as `s`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,LVb,$APP.X,gL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a structure of the specified `orientation` and dimension `size`\n  populated by symbolic entries, each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  (\x3d (literal 'x 3 ::s/up)\n     (up 'x↑0 'x↑1 'x↑2))\n\n  See [[literal-up]] and [[literal-down]] for constructors with baked in\n  orientations.",$APP.U,$APP.M($APP.z(new $APP.H(null,
3,5,$APP.I,[$APP.Yx,$APP.yY,oU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,oU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,pfb,$APP.X,HN,$APP.h,new $APP.f(null,2,[$APP.P,"Given:\n\n  - a sequence of `values`\n  - a model `struct`\n\n  Returns a new structure generated by unpacking `values` into a structure with\n  the same shape as `struct`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[UY,$APP.vv],null),new $APP.H(null,3,5,$APP.I,[bF,UY,$APP.vv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,ovb,$APP.X,$K,$APP.h,new $APP.f(null,2,[$APP.P,"Given an `up` or `down` structure containing structures of the same\n  orientation and size (a 2 tensor), returns a dictionary with keys:\n\n  ```clj\n  {:outer-orientation \x3c::up or ::down\x3e\n   :inner-orientation \x3c::up or ::down\x3e\n   :outer-size \x3cint\x3e\n   :inner-size \x3cint\x3e}\n\n  If `s` is _not_ a valid tensor, returns nil.\n  ```",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,cPb,$APP.X,lL,$APP.h,new $APP.f(null,2,[$APP.P,"Return a structure of the same shape as `s` whose elements are access chains\n  corresponding to position of each element (i.e., the sequence of indices\n  needed to address that element via [[get-in]]).\n\n  Each access chain has the sequence of orientations (`::s/up`, `::s/down`)\n  associated with each step attached to it as metadata, under an `:orientations`\n  key. Use this if the orientation of the indices matters.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,QIb,$APP.X,rL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the (vector) dot product of `v1` and `v2`; this is equivalent to the sum\n  of the pairwise product of each entry.\n\n  The arguments must have identical length, and all pairwise entries must be\n  compatible via [[g/*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))],null)],null),new $APP.f(null,3,[$APP.Q,gAb,$APP.X,bL,$APP.h,
new $APP.f(null,2,[$APP.P,"Construct an up (contravariant) tuple from the supplied sequence. For a\n  variadic version, see [[up]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,MDb,$APP.X,qP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,
$APP.Lh,CV],null))],null)],null),new $APP.f(null,3,[$APP.Q,GEb,$APP.X,$N,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of accumulating all non-structural entries in `s` using the\n  supplied fold function `f` into the optional accumulator `init` (defaults\n  to `(f)`).\n\n  `f` must be a 2-argument fn of type `(accumulator, [x chain orientations]) \x3d\x3e\n  accumulator` responsible for merging some value `x` into the ongoing\n  accumulation. The second argument is a 3-vector containing\n\n  - the entry in the structure\n  - a vector of its 'access chain', i.e., the path you'd pass\n    to [[clojure.core/get-in]] to access the entry\n  - a vector of orientations associated with each index in the access chain\n\n  `f` should return a new instance of the accumulator.\n\n  Additional arities allow you to supply\n\n  - `init`, the initial (empty) accumulator (defaults to `(f)`)\n  - `present`, a function that will be applied to the final, aggregated\n    result (defaults to `f`)\n\n  For example:\n\n  ```clojure\n  (fold-chain\n    (fn ([] [])\n     ([acc] acc)\n     ([acc [s chain orientations]]\n      (conj acc {:s s\n                 :chain chain\n                 :orientations orientations})))\n    (s/down (s/up 1 2) (s/up 3 4)))\n\n  [{:s 1, :chain [0 0], :orientations [::s/down ::s/up]}\n   {:s 2, :chain [0 1], :orientations [::s/down ::s/up]}\n   {:s 3, :chain [1 0], :orientations [::s/down ::s/up]}\n   {:s 4, :chain [1 1], :orientations [::s/down ::s/up]}]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.Vv],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Cy,$APP.JT,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Jub,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,OP,$APP.X,SN,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))],null)],
null),new $APP.f(null,3,[$APP.Q,KDb,$APP.X,oL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure with the same shape as `s`, with all orientations\n  inverted.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,QWb,$APP.X,SK,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.structure/Structure.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[oU,$APP.Wv,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,lmb,$APP.X,qL,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,y6b,$APP.X,hL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x↑0 'x↑1 'x↑2))\n  ```",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))],null)],null),new $APP.f(null,3,[$APP.Q,ydc,$APP.X,gqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,eWb,$APP.X,hqc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null)]),$APP.ap(Tnb)),$APP.cp(new $APP.f(null,5,[$APP.z(qwb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[R8b,$APP.Yx],null)))],
null)),new $APP.f(null,3,[$APP.Q,anb,$APP.X,function(a,b){a=$APP.GEa(a,b);return $APP.md(a)?a:$APP.ed(a)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[R8b,$APP.Yx],null))],null)],null),Owb,new $APP.f(null,3,[$APP.Q,JTa,$APP.X,bZ,$APP.h,new $APP.f(null,4,[$APP.P,"I borrowed this lovely, mysterious macro from `macrovich`:\n   https://github.com/cgrand/macrovich. This allows us to fork behavior inside\n   of a macro at macroexpansion time, not at read time.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,2,5,$APP.I,[jbc,KPa],null)],null)],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),$db,new $APP.f(null,3,[$APP.Q,tCb,$APP.X,function(a,b,c,d){a=$APP.rg.B(b,BX,!0);b=$APP.Oj.j([$APP.m.j(c),"-value"].join(""));return $APP.k(BX.j(a))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Qh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.di,null,1,null),new $APP.D(null,b,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)])))),
null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,fEb,null,1,null),new $APP.D(null,$APP.ox,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.di,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,b,null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,
fEb,null,1,null),new $APP.D(null,$APP.ox,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.K,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.ai,null,1,null),new $APP.D(null,c,null,1,null)))),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.di,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)]))))},$APP.h,new $APP.f(null,4,[$APP.P,
"Given some namespace `ns`, returns a function of some binding symbol and a\n  form to bind. The function returns either\n\n  - A form like `(def ~sym ~form)`, if `sym` is not currently bound into `ns`\n\n  - If `sym` is bound already, returns a form that emits a warning and then\n    uses `ns-unmap` and `intern` to reassign the binding.\n\n  In Clojure, this behavior matches redefinitions of symbols bound in\n  `clojure.core`. Symbols bound with `def` that are already imported from other\n  namespaces cause an exception, hence this more careful workaround.\n\n  (In ClojureScript, only forms like `(def ~sym ~form)` are emitted, since the\n  compiler does not currently error in case 2 and already handles emitting the\n  warning for us.)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Ev],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),JKb,new $APP.f(null,3,[$APP.Q,Xeb,$APP.X,cZ,$APP.h,new $APP.f(null,4,[$APP.P,"Defines a multifn using the provided symbol. Arranges for the multifn\n  to answer the :arity message, reporting either `[:exactly a]` or\n  `[:between a b]` according to the arguments given.\n\n  - `arities` can be either a single or a vector of 2 numbers.\n\n  The `options` allowed differs slightly from `defmulti`:\n\n  - the first optional argument is a docstring.\n\n  - the second optional argument is a dict of metadata. When you query the\n  defined multimethod with a keyword, it will pass that keyword along as a query\n  to this metadata map. (`:arity` is always overridden if supplied, and `:name`\n  defaults to the symbol `f`.)\n\n  Any remaining options are passed along to `defmulti`.",
$APP.U,$APP.M(new $APP.H(null,6,5,$APP.I,[$APP.Yw,UHb,$APP.txa,$APP.Cu,$APP.Lh,$APP.Au],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),$APP.z(idb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,bW],null)))],null)),new $APP.f(null,3,[$APP.Q,Z7b,$APP.X,function(a,b){return $APP.Jd(function(c,d,g){var l=$APP.C.A(c,d);return null==l?c:$APP.rg.B(c,d,g.j?g.j(l):g.call(null,l))},a,b)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,bW],null))],null)],
null)],null),$APP.ap(vdb)),$APP.cp(new $APP.f(null,4,[$APP.z(Thb,new $APP.f(null,1,[$APP.im,!0],null)),new $APP.f(null,3,[$APP.Q,W1b,$APP.X,HM,$APP.h,$APP.F],null),$APP.z(CLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gY],null))),$APP.P,"Returns the result of executing the supplied `thunk` in an environment where\n  the [[*rf-simplify*]] and [[*poly-simplify*]] are not memoized."],null)),new $APP.f(null,3,[$APP.Q,rOb,$APP.X,function(a){var b=IM,c=HM,d=S0a(GH(W0a())),
g=S0a(GH(U0a()));IM=d;HM=g;try{return a.J?a.J():a.call(null)}finally{HM=c,IM=b}},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of executing the supplied `thunk` in an environment where\n  the [[*rf-simplify*]] and [[*poly-simplify*]] are not memoized.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[gY],null))],null)],null),$APP.z(VHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),$APP.P,"Simplifies an expression representing a complex number. TODO say more!"],
null)),new $APP.f(null,3,[$APP.Q,jMb,$APP.X,n1a,$APP.h,new $APP.f(null,2,[$APP.P,"Simplifies an expression representing a complex number. TODO say more!",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null),$APP.z(LT,new $APP.f(null,1,[$APP.im,!0],null)),new $APP.f(null,3,[$APP.Q,CX,$APP.X,IM,$APP.h,$APP.F],null)],null),$APP.ap(hV)),$APP.cp($APP.fg([$APP.z(oJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.z($APP.Pv,new $APP.f(null,1,[$APP.tj,
Pnb],null))],null))),$APP.P,"Returns a [[Literal]] generated by applying `f` to the expression part of\n  `e`.\n\n  [[literal-type]] and [[meta]] will return the same thing for `e` and the\n  return value."],null)),$APP.z(FFb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null)))],null)),wIb,$APP.z($APP.exa,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null)))],null)),$APP.z(PJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))),$APP.P,"If `x` is a [[Literal]] instance, returns its type. Else, returns nil."],null)),$APP.z(yWb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,Pdb,$APP.Sh],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,lpb],null))),$APP.P,"Returns a form similar to `expr`, with all instances of `old` replaced by\n  `new`. Substitution occurs\n  in [postwalk](https://clojuredocs.org/clojure.walk/postwalk) order.\n\n  NOTE that this now works for expressions too.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Ww,Pdb,$APP.Sh],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,lpb],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,Pdb,$APP.Sh],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,lpb],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($APP.vw,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[nO,$APP.oO],null))),$APP.P,"Comparator for expressions. The rule is that types have the following ordering:\n\n  - empty sequence is \x3c anything (except another empty seq)\n  - real \x3c symbol \x3c string \x3c sequence\n  - sequences compare element-by-element\n\n  Any types _not_ in this list compare with the other type using hashes."],
null)),$APP.z($APP.mya,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null)))],null)),$APP.z(yTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is a [[Literal]] instance, false otherwise."],null)),ISb,$APP.z(uCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,Glb,B6b],null))),$APP.P,"Walk the unwrapped expression `expr` in postorder, replacing symbols found\n  there with their values in the `sym-\x3evar` mapping, if present.\n\n  `sym-\x3ef` is used for elements in function application position (first of a\n  sequence)."],
null)),$APP.z(D7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Wu,$APP.Ww],null))),$APP.P,"Constructs a [[Literal]] instance with the supplied type and an empty metadata\n  map out of the literal form `expr`."],null)),$APP.z(exb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is both a [[Literal]] and has a type specified\n  in [[abstract-types]], false otherwise."],null)),$APP.z(v4b,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),$APP.P,"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`."],null)),$APP.z(Fpb,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,8,[mU,"null",YE,"null",gvb,"null",nS,"null",NY,"null",iV,"null",o7b,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.Wu,ceb,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,5,[mU,"null",nS,"null",iV,"null",o7b,"null",pT,"null"],null),null),$APP.P,"Positional factory function for emmy.expression/Literal."],null)),$APP.z(yac,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ww,dU],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,dU,$APP.Au],null))),$APP.P,"Renders an expression through the simplifier and onto the stream.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,
$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Ww,dU],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,dU,$APP.Au],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ww,dU],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,dU,$APP.Au],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(q4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),$APP.P,"Return the set of 'variables' (e.g. symbols) found in `expr`.\n\n  `expr` is either a symbol, a [[Literal]] instance or some sequence\n  representing a symbolic expression."],
null)),$APP.z(OZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),$APP.P,"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`."],null)),$APP.z(rub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Wu,FW,$APP.Ou],null))),$APP.P,"Similar to [[make-literal]], but accepts:\n\n  - some operation\n  - the arguments to which it applies\n\n  Similar to `clojure.core/apply`.\n\n  For example:\n\n  ```clojure\n  (literal-apply ::numeric 'cos [1 2 3])\n  ;;\x3d\x3e (cos 1 2 3)\n  ```"],
null))],[new $APP.f(null,3,[$APP.Q,Vab,$APP.X,QSa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Literal]] generated by applying `f` to the expression part of\n  `e`.\n\n  [[literal-type]] and [[meta]] will return the same thing for `e` and the\n  return value.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.z($APP.Pv,new $APP.f(null,1,[$APP.tj,Pnb],null))],null))],null)],null),new $APP.f(null,3,[$APP.Q,BAb,$APP.X,USa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],
null))],null)],null),new $APP.f(null,3,[$APP.Q,gtb,$APP.X,$mc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,THb,$APP.X,SSa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,D9b,$APP.X,PSa,$APP.h,new $APP.f(null,2,[$APP.P,"If `x` is a [[Literal]] instance, returns its type. Else, returns nil.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,KGb,$APP.X,WZ,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns a form similar to `expr`, with all instances of `old` replaced by\n  `new`. Substitution occurs\n  in [postwalk](https://clojuredocs.org/clojure.walk/postwalk) order.\n\n  NOTE that this now works for expressions too.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,Pdb,$APP.Sh],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,lpb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wpb,$APP.X,bG,$APP.h,new $APP.f(null,2,[$APP.P,"Comparator for expressions. The rule is that types have the following ordering:\n\n  - empty sequence is \x3c anything (except another empty seq)\n  - real \x3c symbol \x3c string \x3c sequence\n  - sequences compare element-by-element\n\n  Any types _not_ in this list compare with the other type using hashes.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[nO,$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vhb,$APP.X,function(a){return!$APP.kd(a)||$APP.Ge(function(b){var c=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);return 0>=bG(c,b)},$APP.Ll.B(2,1,a))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ukb,$APP.X,ZF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is a [[Literal]] instance, false otherwise.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Bkb,$APP.X,USa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,M7b,$APP.X,RSa,$APP.h,new $APP.f(null,2,[$APP.P,"Walk the unwrapped expression `expr` in postorder, replacing symbols found\n  there with their values in the `sym-\x3evar` mapping, if present.\n\n  `sym-\x3ef` is used for elements in function application position (first of a\n  sequence).",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,Glb,B6b],null))],null)],null),
new $APP.f(null,3,[$APP.Q,gsb,$APP.X,NSa,$APP.h,new $APP.f(null,2,[$APP.P,"Constructs a [[Literal]] instance with the supplied type and an empty metadata\n  map out of the literal form `expr`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Wu,$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.Q,lNb,$APP.X,function(a){return ZF(a)&&$APP.Bd($mc,a.type)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is both a [[Literal]] and has a type specified\n  in [[abstract-types]], false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,jib,$APP.X,$F,$APP.h,new $APP.f(null,2,[$APP.P,"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wbb,$APP.X,MSa,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.expression/Literal.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Wu,ceb,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,twb,$APP.X,XZ,$APP.h,new $APP.f(null,2,[$APP.P,"Renders an expression through the simplifier and onto the stream.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ww,dU],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,dU,$APP.Au],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lwb,$APP.X,aG,$APP.h,new $APP.f(null,2,[$APP.P,"Return the set of 'variables' (e.g. symbols) found in `expr`.\n\n  `expr` is either a symbol, a [[Literal]] instance or some sequence\n  representing a symbolic expression.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.Q,iPb,$APP.X,TSa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.Q,$Bb,$APP.X,OSa,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[make-literal]], but accepts:\n\n  - some operation\n  - the arguments to which it applies\n\n  Similar to `clojure.core/apply`.\n\n  For example:\n\n  ```clojure\n  (literal-apply ::numeric 'cos [1 2 3])\n  ;;\x3d\x3e (cos 1 2 3)\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Wu,FW,$APP.Ou],null))],null)],null)]),$APP.ap(hgb)),$APP.cp(new $APP.f(null,5,[$APP.z(vac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[cW,OV,$APP.UU,KW,$APP.cX],null))),$APP.P,"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt"],
null)),new $APP.f(null,3,[$APP.Q,KIb,$APP.X,fab,$APP.h,new $APP.f(null,2,[$APP.P,"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[cW,OV,$APP.UU,KW,$APP.cX],null))],null)],null),$APP.z(Wac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[cW,Y0b],null))),$APP.P,"make-integrator takes a state derivative function (which in this\n  system is assumed to be a map from a structure to a structure of the\n  same shape, as differentiating a function does not change its\n  shape), and returns an integrator, which is a function of several\n  arguments:\n\n  - the initial state\n  - an intermediate-state observation function\n  - the step size desired\n  - the final time to seek, and\n  - an error tolerance.\n\n  If the `observe` function is not nil, it will be invoked with the time as\n  first argument and integrated state as the second, at each intermediate step."],
null)),new $APP.f(null,3,[$APP.Q,B5b,$APP.X,eab,$APP.h,new $APP.f(null,2,[$APP.P,"make-integrator takes a state derivative function (which in this\n  system is assumed to be a map from a structure to a structure of the\n  same shape, as differentiating a function does not change its\n  shape), and returns an integrator, which is a function of several\n  arguments:\n\n  - the initial state\n  - an intermediate-state observation function\n  - the step size desired\n  - the final time to seek, and\n  - an error tolerance.\n\n  If the `observe` function is not nil, it will be invoked with the time as\n  first argument and integrated state as the second, at each intermediate step.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[cW,Y0b],null))],null)],null),$APP.z(Tqb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null))),$APP.P,"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(cW,OV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null)),$APP.Cx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.Q,jcb,$APP.X,J4,$APP.h,new $APP.f(null,2,[$APP.P,"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null))],null)],null),$APP.z($APP.$Mb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null))),$APP.P,"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.",$APP.ky,new $APP.f(null,6,[$APP.tu,
!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(cW,OV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null)),$APP.Cx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.Q,Yob,$APP.X,K4,$APP.h,new $APP.f(null,2,[$APP.P,"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null))],null)],null),$APP.z(Jeb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.aX,$APP.PW,OTb,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,2,5,$APP.I,[$APP.ZU,pwb],null),$APP.Ml,new $APP.f(null,2,[$APP.ZU,bdc,pwb,!1],null)],null)],null))),$APP.P,"Produces a function, monotonic in its single numeric argument,\n   that represents the integral of the function f' given the initial\n   data $y_0 \x3d f(x_0)$ and an options dictionary (presently containing\n   the tolerance for error $\\epsilon$, but eventually also selecting\n   from a menu of integration techniques).\n\n   This is done by creating an adaptive step-size ODE solver, and\n   advancing its steps as needed to supply function values. (This\n   architecture accounts for why the arguments to f must be presented\n   in order). Old solution segments are discarded. The goal of this\n   approach is to avoid the requirement of supplying an upper limit\n   to the integration. At the cost of requiring monotonic arguments\n   to f, the integrated function can essentially be used forever\n   without accumulating unbounded state.\n\n   The function `f'` should have the signature `[x y y']`, where `y'` is a\n   primitive double array, which the function should fill in based\n   on the values `x` and `y`.) Both `y` and `y'` will be primitive arrays\n   of type double, the same length as that of `y0`. Both arrays are\n   owned by the integrator. In particular, y should never be modified,\n   and neither array should be modified or expected to persist after\n   the return of `f'`. This approach has observable memory and\n   performance impacts.\n\n   The return value of the integrating function, however, is newly\n   allocated and belongs to the caller.\n\n   The integrating function may be called with no arguments to shut down\n   the integration, allowing for the final reclamation of its resources.\n\n   When the ODE solver is provided by Java, it may be necessary to\n   use an auxiliary thread to enable this style of flow control.  If\n   JavaScript, we expect the solver to provide a generator of solution\n   segments."],
null)),new $APP.f(null,3,[$APP.Q,Vdc,$APP.X,aab,$APP.h,new $APP.f(null,2,[$APP.P,"Produces a function, monotonic in its single numeric argument,\n   that represents the integral of the function f' given the initial\n   data $y_0 \x3d f(x_0)$ and an options dictionary (presently containing\n   the tolerance for error $\\epsilon$, but eventually also selecting\n   from a menu of integration techniques).\n\n   This is done by creating an adaptive step-size ODE solver, and\n   advancing its steps as needed to supply function values. (This\n   architecture accounts for why the arguments to f must be presented\n   in order). Old solution segments are discarded. The goal of this\n   approach is to avoid the requirement of supplying an upper limit\n   to the integration. At the cost of requiring monotonic arguments\n   to f, the integrated function can essentially be used forever\n   without accumulating unbounded state.\n\n   The function `f'` should have the signature `[x y y']`, where `y'` is a\n   primitive double array, which the function should fill in based\n   on the values `x` and `y`.) Both `y` and `y'` will be primitive arrays\n   of type double, the same length as that of `y0`. Both arrays are\n   owned by the integrator. In particular, y should never be modified,\n   and neither array should be modified or expected to persist after\n   the return of `f'`. This approach has observable memory and\n   performance impacts.\n\n   The return value of the integrating function, however, is newly\n   allocated and belongs to the caller.\n\n   The integrating function may be called with no arguments to shut down\n   the integration, allowing for the final reclamation of its resources.\n\n   When the ODE solver is provided by Java, it may be necessary to\n   use an auxiliary thread to enable this style of flow control.  If\n   JavaScript, we expect the solver to provide a generator of solution\n   segments.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.aX,$APP.PW,OTb,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,2,5,$APP.I,[$APP.ZU,pwb],null),$APP.Ml,new $APP.f(null,2,[$APP.ZU,bdc,pwb,!1],null)],null)],null))],null)],null)],null),$APP.ap(z$b)),$APP.cp($APP.fg([$APP.z(Hsb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null))),$APP.P,"Return a [[PowerSeries]] starting with the supplied values. The remainder of\n  the series will be filled with the zero-value corresponding to the first of\n  the given values.\n\n  If you have a sequence already, prefer [[power-series*]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.sx)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(NV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `s` is specifically a [[PowerSeries]], false otherwise."],null)),Cgb,hOb,$APP.z(oJb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(bmb,new $APP.f(null,5,[XE,new $APP.ug(null,
new $APP.f(null,10,[UW,"null",jU,"null",YE,"null",tS,"null",nS,"null",NY,"null",iV,"null",wY,"null",pT,"null",TV,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,6,[UW,"null",tS,"null",nS,"null",iV,"null",wY,"null",pT,"null"],null),null),$APP.P,"Positional factory function for emmy.series/Series."],null)),$APP.z(yDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],
null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.cw,$APP.wU,0)],null)],null)))),$APP.P,"Returns a [[PowerSeries]] instance representing $x^n$."],null)),u6b,$APP.z(k1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.wU],null))),$APP.P,"Returns the sum of all elements in the input series `s` up to order\n  `n` (inclusive). For example:\n\n  ```clojure\n  (sum (series 1 1 1 1 1 1 1) 3)\n  ;; \x3d\x3e 4\n  ```\n\n  NOTE that [[sum]] sums the first `n + 1` terms, since a series starts with an\n  order 0 term."],
null)),$APP.z(t_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Accepts a [[Series]] or [[PowerSeries]] and coerces the input to\n  a [[PowerSeries]] without any application. Returns the coerced [[PowerSeries]]\n  instance.\n\n  Supplying a non-series will throw."],null)),$APP.z($S,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[$APP.Mv,$V],null))),$APP.P,"Returns a [[PowerSeries]] representing the supplied constant term.\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[$APP.Mv,$V],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[$APP.Mv,$V],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(yAb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),$APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$S],null),new $APP.f(null,
1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(NV,$APP.Vv)],null)],null)))),$APP.P,"Returns a [[PowerSeries]] $U$ that represents the definite integral of the\n  input power series $S$ with constant term $c$:\n\n  ```\n  $$U \x3d c + \\int_0^{\\infty} S$$\n  ```",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$S],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null),new $APP.H(null,2,5,$APP.I,[$APP.Vv,$S],null)),$APP.Cx,$APP.M(null,null)],null)],null)),LCb,$APP.z(ZWb,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,10,[UW,"null",jU,"null",YE,"null",tS,"null",nS,"null",NY,"null",iV,"null",wY,"null",pT,"null",TV,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,6,[UW,"null",tS,"null",nS,"null",iV,"null",wY,"null",pT,"null"],null),null),$APP.P,"Positional factory function for emmy.series/PowerSeries."],
null)),$APP.z(u7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null))),$APP.P,"Returns a [[PowerSeries]] instance representing a\n  [Binomial series](https://en.wikipedia.org/wiki/Binomial_series), i.e., the\n  taylor series of the function $f$ given by\n\n  ```\n  $$f(x) \x3d (1 + x)^\\alpha$$\n  ```"],null)),$APP.z(leb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.sx],null))),$APP.P,"Given a sequence, returns a new [[Series]] object that wraps that\n  sequence (potentially padding its tail with zeros if it's finite)."],
null)),$APP.z($APP.Fv,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null))),$APP.P,"Returns the value of the supplied [[Series]] or [[PowerSeries]] applied to `xs`.\n\n  If a [[PowerSeries]] is supplied, `xs` (despite its name) must be a single\n  value. Returns a [[Series]] generated by multiplying each `i`th term in `s` by\n  $x^i$, where $x$ is the `xs` argument.\n\n  If a [[Series]] `s` is supplied:\n\n  Assumes that `s` is a series of applicables of arity equal to the count of\n  `xs`. If, in fact, `s` is a series of series-valued applicables, then the\n  result will be a sort of layered sum of the values.\n\n  Concretely, suppose that `s` has the form:\n\n  ```\n  [x \x3d\x3e [A1 A2 A3...], x \x3d\x3e [B1 B2 B3...], x \x3d\x3e [C1 C2 C3...], ...]\n  ```\n\n  Then, this series applied to x will yield the new series:\n\n  ```\n  [A1 (+ A2 B1) (+ A3 B2 C1) ...]\n  ```\n\n  The way to think about this is, that if a power series has some other series\n  as the coefficient of the $x^n$ term, the series must shift by $n$ positions\n  before being added into the final total."],
null)),MSb,A1b,$APP.z($APP.Fx,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(dNb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null))),$APP.P,"Return a [[Series]] starting with the supplied values. The remainder of the\n  series will be filled with the zero-value corresponding to the first of the\n  given values.\n\n  If you have a sequence already, prefer [[series*]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,
5,$APP.I,[$APP.M($APP.sx)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(O1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns a series (of the same type as the input) of partial sums of the terms\n  in the supplied series `s`."],null)),$APP.z(Wjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.wU],null))),$APP.P,"Accepts an input series `s` and an exponent `n`, and expands the series in the\n  `n`th power of its argument. Every term `i` maps to position `i*n`, with zeros\n  padded in the new missing slots.\n\n  For example:\n\n  ```clojure\n  (inflate identity 3)\n  ;; \x3d\x3e (series 0 0 0 1)\n\n  (take 6 (inflate (generate inc) 3))\n  ;; \x3d\x3e (1 0 2 0 3 0)\n  ```\n\n  NOTE this operation makes sense as described for a [[PowerSeries]], where each\n  entry represents the coefficient of some power of `x`; functionally it still\n  works with [[Series]] objects."],
null)),eYb,$APP.z(YPb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$V],null))),$APP.P,"Returns a [[PowerSeries]] generated by `(f i)` for `i` in `0, 1, ...`\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,
2,5,$APP.I,[$APP.Nv,$V],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$V],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($cb,new $APP.f(null,1,[$APP.Ru,!0],null)),i5b,lIb,$APP.z(fWb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null))),$APP.P,"Returns a [[PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) expansion of `f` at the\n  point specified by `xs`. Multiple arguments are allowed. If no arguments `xs`\n  are supplied, the expansion point defaults to 0.\n\n  The expansion at 0 is also called a 'Maclaurin series'.\n\n  NOTE: this function takes derivatives internally, so if you pass a function\n  make sure you require [[emmy.calculus.derivative]] to install the\n  derivative implementation for functions. If you pass some other callable,\n  differentiable function-like thing, like a polynomial, this is not necessary.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(veb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Returns true if `s` is either a [[Series]] or a [[PowerSeries]], false\n  otherwise."],null)),
$APP.z(LDb,new $APP.f(null,1,[$APP.Ru,!0],null)),EXb,$APP.z(fU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,oV],null))),$APP.P,"Given a univariate [[PowerSeries]] and a singleton sequence of `factors`,\n  returns a new [[PowerSeries]] that scales its argument by `(first factor)` on\n  application.\n\n  Given a [[Series]], recursively applies [[arg-scale]] to each element, making\n  this ONLY appropriate in its current form for a [[Series]] of [[PowerSeries]]\n  instances."],
null)),scb,$APP.z(R0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(NV,$APP.Vv)],null)],null)))),$APP.P,"Returns a new [[PowerSeries]] $U$ that represents the compositional inverse (the\n  'reversion') of the input power series $S$, satisfying:\n\n  ```\n  $$S(U(x)) \x3d x$$\n  ```"],null)),lvb,$APP.z(HX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,
AY],null))),$APP.P,"Given a univariate [[PowerSeries]] and a singleton sequence of `shifts`,\n  returns a function that, when applied, returns a value equivalent to calling\n  the original `s` with its argument shifted by `(first shifts)`.\n\n  NOTE: [[arg-shift]] can't return a [[PowerSeries]] instance because the\n  implementation of [[compose]] does not currently allow a constant element in\n  the right-hand series.\n\n  Given a [[Series]], recursively applies [[arg-shift]] to each element, making\n  this ONLY appropriate in its current form for a [[Series]] of [[PowerSeries]]\n  instances. Returns a [[Series]] of functions."],
null)),LIb,mHb,gqb,i1b,ZXb,$APP.z($APP.MK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.Uv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(NV,$APP.Vv),$APP.M(NV,$APP.Uv)],null)],null)))),$APP.P,"Returns a new [[PowerSeries]] $U$ that represents the composition of the two\n  input power series $S$ and $T$, where $U$ evaluates like:\n\n  ```\n  $$U(x) \x3d S(T(x))$$\n  ```"],null)),$APP.z(JJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.sx],null))),$APP.P,"Given a sequence, returns a new [[PowerSeries]] object that wraps that\n  sequence (potentially padding its tail with zeros if it's finite)."],null)),y2b,k4b,hYb],[new $APP.f(null,3,[$APP.Q,z2b,$APP.X,i1,$APP.h,new $APP.f(null,2,[$APP.P,"Return a [[PowerSeries]] starting with the supplied values. The remainder of\n  the series will be filled with the zero-value corresponding to the first of\n  the given values.\n\n  If you have a sequence already, prefer [[power-series*]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null))],null)],null),new $APP.f(null,3,[$APP.Q,Obb,$APP.X,TI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is specifically a [[PowerSeries]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,M2b,$APP.X,r1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,HXb,$APP.X,t1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,yOb,$APP.X,XI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new series generated by applying the supplied `f` to each element in\n  the input series `s`. The returned series will be the same type as the input\n  series, either [[Series]] or [[PowerSeries]].\n\n  NOTE scmutils calls this `series:elementwise`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,vAb,$APP.X,QI,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.series/Series.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,cNb,$APP.X,function(a){return VI($APP.N.A($APP.Vj.A(a,0),new $APP.H(null,1,5,$APP.I,[1],null)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] instance representing $x^n$.",$APP.U,
$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.cw,$APP.wU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,PLb,$APP.X,w1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,HRb,$APP.X,HXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sum of all elements in the input series `s` up to order\n  `n` (inclusive). For example:\n\n  ```clojure\n  (sum (series 1 1 1 1 1 1 1) 3)\n  ;; \x3d\x3e 4\n  ```\n\n  NOTE that [[sum]] sums the first `n + 1` terms, since a series starts with an\n  order 0 term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,ezb,$APP.X,DXa,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a [[Series]] or [[PowerSeries]] and coerces the input to\n  a [[PowerSeries]] without any application. Returns the coerced [[PowerSeries]]\n  instance.\n\n  Supplying a non-series will throw.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,bwb,$APP.X,j1,$APP.h,new $APP.f(null,2,[$APP.P,
"Returns a [[PowerSeries]] representing the supplied constant term.\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[$APP.Mv,$V],null))],null)],null),new $APP.f(null,3,[$APP.Q,dqb,$APP.X,m1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] $U$ that represents the definite integral of the\n  input power series $S$ with constant term $c$:\n\n  ```\n  $$U \x3d c + \\int_0^{\\infty} S$$\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),$APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$S],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(NV,$APP.Vv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,kpb,$APP.X,n1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Unb,$APP.X,SI,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.series/PowerSeries.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Qr],null))],null)],null),new $APP.f(null,
3,[$APP.Q,ohb,$APP.X,JXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] instance representing a\n  [Binomial series](https://en.wikipedia.org/wiki/Binomial_series), i.e., the\n  taylor series of the function $f$ given by\n\n  ```\n  $$f(x) \x3d (1 + x)^\\alpha$$\n  ```",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null))],null)],null),new $APP.f(null,3,[$APP.Q,svb,$APP.X,UI,$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence, returns a new [[Series]] object that wraps that\n  sequence (potentially padding its tail with zeros if it's finite).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.sx],null))],null)],null),new $APP.f(null,3,[$APP.Q,tec,$APP.X,function(a,b){return TI(a)?EXa(a,b):BXa(a)?WI(a,b):yD(["value only works on `Series` or `PowerSeries`; received ",$APP.m.j(a)].join(""))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the value of the supplied [[Series]] or [[PowerSeries]] applied to `xs`.\n\n  If a [[PowerSeries]] is supplied, `xs` (despite its name) must be a single\n  value. Returns a [[Series]] generated by multiplying each `i`th term in `s` by\n  $x^i$, where $x$ is the `xs` argument.\n\n  If a [[Series]] `s` is supplied:\n\n  Assumes that `s` is a series of applicables of arity equal to the count of\n  `xs`. If, in fact, `s` is a series of series-valued applicables, then the\n  result will be a sort of layered sum of the values.\n\n  Concretely, suppose that `s` has the form:\n\n  ```\n  [x \x3d\x3e [A1 A2 A3...], x \x3d\x3e [B1 B2 B3...], x \x3d\x3e [C1 C2 C3...], ...]\n  ```\n\n  Then, this series applied to x will yield the new series:\n\n  ```\n  [A1 (+ A2 B1) (+ A3 B2 C1) ...]\n  ```\n\n  The way to think about this is, that if a power series has some other series\n  as the coefficient of the $x^n$ term, the series must shift by $n$ positions\n  before being added into the final total.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,ZRb,$APP.X,s1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,zIb,$APP.X,QK,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Rbb,$APP.X,mpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Ftb,$APP.X,h1,$APP.h,new $APP.f(null,2,[$APP.P,"Return a [[Series]] starting with the supplied values. The remainder of the\n  series will be filled with the zero-value corresponding to the first of the\n  given values.\n\n  If you have a sequence already, prefer [[series*]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null))],null)],null),new $APP.f(null,3,[$APP.Q,Fyb,$APP.X,GXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a series (of the same type as the input) of partial sums of the terms\n  in the supplied series `s`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,qWb,$APP.X,FXa,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts an input series `s` and an exponent `n`, and expands the series in the\n  `n`th power of its argument. Every term `i` maps to position `i*n`, with zeros\n  padded in the new missing slots.\n\n  For example:\n\n  ```clojure\n  (inflate identity 3)\n  ;; \x3d\x3e (series 0 0 0 1)\n\n  (take 6 (inflate (generate inc) 3))\n  ;; \x3d\x3e (1 0 2 0 3 0)\n  ```\n\n  NOTE this operation makes sense as described for a [[PowerSeries]], where each\n  entry represents the coefficient of some power of `x`; functionally it still\n  works with [[Series]] objects.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,tHb,$APP.X,q1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,xrb,$APP.X,k1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] generated by `(f i)` for `i` in `0, 1, ...`\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$V],null))],
null)],null),new $APP.f(null,3,[$APP.Q,Kzb,$APP.X,lpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,cjb,$APP.X,o1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,C5b,$APP.X,y1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,urb,$APP.X,l1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) expansion of `f` at the\n  point specified by `xs`. Multiple arguments are allowed. If no arguments `xs`\n  are supplied, the expansion point defaults to 0.\n\n  The expansion at 0 is also called a 'Maclaurin series'.\n\n  NOTE: this function takes derivatives internally, so if you pass a function\n  make sure you require [[emmy.calculus.derivative]] to install the\n  derivative implementation for functions. If you pass some other callable,\n  differentiable function-like thing, like a polynomial, this is not necessary.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,jvb,$APP.X,BXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `s` is either a [[Series]] or a [[PowerSeries]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,PMb,$APP.X,kpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Ytb,$APP.X,p1,$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.Q,kzb,$APP.X,function zsc(a,b){return TI(a)?IXa(a,VI(new $APP.H(null,2,5,$APP.I,[0,$APP.u(b)],null))):XI(function(d){return zsc.A?zsc.A(d,b):zsc.call(null,d,b)},a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given a univariate [[PowerSeries]] and a singleton sequence of `factors`,\n  returns a new [[PowerSeries]] that scales its argument by `(first factor)` on\n  application.\n\n  Given a [[Series]], recursively applies [[arg-scale]] to each element, making\n  this ONLY appropriate in its current form for a [[Series]] of [[PowerSeries]]\n  instances.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,oV],null))],null)],null),new $APP.f(null,3,[$APP.Q,aLb,$APP.X,opc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,iRb,$APP.X,function(a){return SI(zXa($APP.r(a)),$APP.ed(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new [[PowerSeries]] $U$ that represents the compositional inverse (the\n  'reversion') of the input power series $S$, satisfying:\n\n  ```\n  $$S(U(x)) \x3d x$$\n  ```",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null),
new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(NV,$APP.Vv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Gdc,$APP.X,u1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,M_b,$APP.X,function Asc(a,b){return TI(a)?$APP.Je.B(dI,a,b):XI(function(d){return Asc.A?Asc.A(d,b):Asc.call(null,d,b)},a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given a univariate [[PowerSeries]] and a singleton sequence of `shifts`,\n  returns a function that, when applied, returns a value equivalent to calling\n  the original `s` with its argument shifted by `(first shifts)`.\n\n  NOTE: [[arg-shift]] can't return a [[PowerSeries]] instance because the\n  implementation of [[compose]] does not currently allow a constant element in\n  the right-hand series.\n\n  Given a [[Series]], recursively applies [[arg-shift]] to each element, making\n  this ONLY appropriate in its current form for a [[Series]] of [[PowerSeries]]\n  instances. Returns a [[Series]] of functions.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,AY],null))],null)],null),new $APP.f(null,3,[$APP.Q,o9b,$APP.X,npc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,wPb,$APP.X,rpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,TCb,$APP.X,qpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,KBb,$APP.X,z1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,fpb,$APP.X,v1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,a6b,$APP.X,IXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new [[PowerSeries]] $U$ that represents the composition of the two\n  input power series $S$ and $T$, where $U$ evaluates like:\n\n  ```\n  $$U(x) \x3d S(T(x))$$\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.Uv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(NV,$APP.Vv),$APP.M(NV,$APP.Uv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Mbb,$APP.X,VI,$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence, returns a new [[PowerSeries]] object that wraps that\n  sequence (potentially padding its tail with zeros if it's finite).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.sx],null))],null)],null),new $APP.f(null,3,
[$APP.Q,akb,$APP.X,ppc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,LFb,$APP.X,spc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,rfb,$APP.X,x1,$APP.h,$APP.F],null)]),$APP.ap(V0b)),$APP.cp($APP.fg([$APP.z(oFb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null))),$APP.P,"Alternative definition of [[wedge]] in terms of alternation.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Ou)],null),$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(QV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SVb],null))),$APP.P,"Returns true if the supplied `f` is a form field operator, false otherwise."],null)),$APP.z(CJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,qW],null))),$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a one-form field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3eoneform-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-form-field`'s component\n  functions will accept a single non-structural argument."],
null)),$APP.z($ac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(CHb,$APP.Nv)],null)],null)))),$APP.P,"One of the two incompatible definitions of differential.\n\n  This differential is a special case of exterior derivative. The other one\n  lives at [[map/differential]]."],null)),$APP.z(s1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qyb,zU],null))),$APP.P,
"Given a structure `w` of and a vector field basis `vector-basis`, returns a new\n  structure generated by applying the full vector basis to each element of `w`.\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [vb    (vf/coordinate-system-\x3evector-basis coordsys)\n        basis (coordinate-system-\x3eoneform-basis coordsys)\n        components (down d:dx d:dy)]\n    (\x3d components\n       (-\x3e components\n           (basis-components-\x3eoneform-field basis)\n           (oneform-field-\x3ebasis-components vb))))\n  ```"],
null)),Smb,$APP.z(itb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,wHb],null))),$APP.P,"Given a structure of `components` functions defined on manifold points and and\n  a matching `oneform-basis` (of identical structure),\n\n  Returns a new one-form field that\n\n  - passes its vector-field argument to `oneform-basis`, returning a new\n    equivalent structure with each slot populated by functions from a manifold\n    point to the directional derivative (using the vector field) in that\n    coordinate direction\n\n  - contracts the result of that operation with the result of applying each\n    component in `components` to the manifold point.\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[oneform-field-\x3ebasis-components]]"],
null)),$APP.z(pUb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null))),$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation, returns a\n  one-form field.\n\n  The returned one-form field at each structural spot takes a vector field and\n  returns a function that takes the directional derivative in that coordinate's\n  direction using the vector field.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,$APP.Yw,qS)],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null)),$APP.Cx,$APP.M(null)],null)],null)),mNb,$APP.z(COb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Ev,qW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(QV,$APP.Ev)],null)],null)))),$APP.P,"Given a one-form field `form` and a `coordinate-system`, returns a function\n  from the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the form field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-oneform-field 'f R2-rect)]\n      ((oneform-field-\x3ecomponents f R2-rect)\n       (up 'x0 'y0))))\n\n  ;;\x3d\x3e (down (f_0 (up x0 y0))\n  ;;         (f_1 (up x0 y0)))\n  ```"],
null)),$APP.z(Ifb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null))),$APP.P,"Returns true if the supplied `f` is an [form field of rank\n  n](https://en.wikipedia.org/wiki/Differential_form), false otherwise.\n\n  A form-field of rank n is an operator that takes n vector fields to a\n  real-valued function on the manifold."],null)),$APP.z(WCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-oneform-field` instances.\n\n  The one-form field at each structural spot takes a vector field and returns a\n  function that takes the directional derivative in that coordinate's direction\n  using the vector field.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-oneform-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied."],
null)),$APP.z(D4a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null))),$APP.P,"Returns the alternation of the supplied differential `form`."],null)),$APP.z(nIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Returns the rank of the supplied differential form `f`. Functions are treated\n  as differential forms of rank 0.\n\n  Throws for any non differential form supplied."],null)),$APP.z(AKb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Returns a form field that returns, for any supplied vector field `vf`, a\n  manifold function [[manifold/zero-manifold-function]] that maps every input\n  manifold `point` to the scalar value 0."],null)),$APP.z(mYb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null))),$APP.P,"Takes:\n\n  - a `down` tuple of `components` of the one-form field relative to\n    `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a full one-form field.\n\n  A one-field field is an operator that takes a vector field to a real-valued\n  function on the manifold.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.lP,$APP.z(B4a,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.px],
null))),$APP.P,"Computes the wedge product of the sequence `fs` of one-forms.\n\n  Higher rank forms can be constructed from one-forms by wedging them together.\n  This antisymmetric tensor product is computed as a determinant. The purpose of\n  this is to allow us to use the construction dx^dy to compute the area\n  described by the vectors that are given to it.\n\n  See Spivak p275 v1 of 'Differential Geometry' to see the correct definition.\n  The key is that the wedge of the coordinate basis forms had better be the\n  volume element.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.px],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(cbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Returns true if the supplied `f` is\n  a [One-form](https://en.wikipedia.org/wiki/One-form), false\n  otherwise.\n\n  A [One-form](https://en.wikipedia.org/wiki/One-form) takes a single vector\n  field to a real-valued function on the manifold."],
null))],[new $APP.f(null,3,[$APP.Q,qmb,$APP.X,J3,$APP.h,new $APP.f(null,2,[$APP.P,"Alternative definition of [[wedge]] in terms of alternation.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null))],null)],null),new $APP.f(null,3,[$APP.Q,qec,$APP.X,eP,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `f` is a form field operator, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[SVb],null))],null)],null),new $APP.f(null,3,[$APP.Q,EPb,$APP.X,w4a,$APP.h,new $APP.f(null,
2,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a one-form field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3eoneform-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-form-field`'s component\n  functions will accept a single non-structural argument.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Yw,qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ueb,$APP.X,mP,$APP.h,new $APP.f(null,2,[$APP.P,"One of the two incompatible definitions of differential.\n\n  This differential is a special case of exterior derivative. The other one\n  lives at [[map/differential]].",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(CHb,$APP.Nv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,URb,$APP.X,A4a,$APP.h,
new $APP.f(null,2,[$APP.P,"Given a structure `w` of and a vector field basis `vector-basis`, returns a new\n  structure generated by applying the full vector basis to each element of `w`.\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [vb    (vf/coordinate-system-\x3evector-basis coordsys)\n        basis (coordinate-system-\x3eoneform-basis coordsys)\n        components (down d:dx d:dy)]\n    (\x3d components\n       (-\x3e components\n           (basis-components-\x3eoneform-field basis)\n           (oneform-field-\x3ebasis-components vb))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[qyb,zU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Bzb,$APP.X,mP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,mIb,$APP.X,z4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a structure of `components` functions defined on manifold points and and\n  a matching `oneform-basis` (of identical structure),\n\n  Returns a new one-form field that\n\n  - passes its vector-field argument to `oneform-basis`, returning a new\n    equivalent structure with each slot populated by functions from a manifold\n    point to the directional derivative (using the vector field) in that\n    coordinate direction\n\n  - contracts the result of that operation with the result of applying each\n    component in `components` to the manifold point.\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[oneform-field-\x3ebasis-components]]",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,wHb],null))],null)],null),new $APP.f(null,3,[$APP.Q,oIb,$APP.X,jP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation, returns a\n  one-form field.\n\n  The returned one-form field at each structural spot takes a vector field and\n  returns a function that takes the directional derivative in that coordinate's\n  direction using the vector field.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Dcb,$APP.X,WP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,djb,$APP.X,v4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a one-form field `form` and a `coordinate-system`, returns a function\n  from the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the form field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-oneform-field 'f R2-rect)]\n      ((oneform-field-\x3ecomponents f R2-rect)\n       (up 'x0 'y0))))\n\n  ;;\x3d\x3e (down (f_0 (up x0 y0))\n  ;;         (f_1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Ev,qW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(QV,$APP.Ev)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,obc,$APP.X,r4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `f` is an [form field of rank\n  n](https://en.wikipedia.org/wiki/Differential_form), false otherwise.\n\n  A form-field of rank n is an operator that takes n vector fields to a\n  real-valued function on the manifold.",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,xT,$APP.X,kP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-oneform-field` instances.\n\n  The one-form field at each structural spot takes a vector field and returns a\n  function that takes the directional derivative in that coordinate's direction\n  using the vector field.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-oneform-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,b8b,$APP.X,E4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the alternation of the supplied differential `form`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null))],null)],null),new $APP.f(null,3,[$APP.Q,lgb,$APP.X,cP,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the rank of the supplied differential form `f`. Functions are treated\n  as differential forms of rank 0.\n\n  Throws for any non differential form supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,vNb,$APP.X,p4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a form field that returns, for any supplied vector field `vf`, a\n  manifold function [[manifold/zero-manifold-function]] that maps every input\n  manifold `point` to the scalar value 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.Q,RTb,$APP.X,iP,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - a `down` tuple of `components` of the one-form field relative to\n    `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a full one-form field.\n\n  A one-field field is an operator that takes a vector field to a real-valued\n  function on the manifold.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null))],null)],null),new $APP.f(null,3,[$APP.Q,Dsb,$APP.X,WP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,bhb,$APP.X,H3,$APP.h,new $APP.f(null,2,[$APP.P,"Computes the wedge product of the sequence `fs` of one-forms.\n\n  Higher rank forms can be constructed from one-forms by wedging them together.\n  This antisymmetric tensor product is computed as a determinant. The purpose of\n  this is to allow us to use the construction dx^dy to compute the area\n  described by the vectors that are given to it.\n\n  See Spivak p275 v1 of 'Differential Geometry' to see the correct definition.\n  The key is that the wedge of the coordinate basis forms had better be the\n  volume element.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.px],null))],null)],null),new $APP.f(null,3,[$APP.Q,TKb,$APP.X,s4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `f` is\n  a [One-form](https://en.wikipedia.org/wiki/One-form), false\n  otherwise.\n\n  A [One-form](https://en.wikipedia.org/wiki/One-form) takes a single vector\n  field to a real-valued function on the manifold.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Nv],null))],null)],null)]),$APP.ap(ZNb)),$APP.cp($APP.fg([sdb,Jzb,Fhb,s4b,Iob,$APP.z(IX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XTb,YTb],null))),$APP.P,"Returns the symbolic dot product of the two supplied numbers `z1` and `z2`.\n\n  If both are numbers, defers to [[emmy.generic/dot-product]]. Else,\n  returns\n\n  $$\\Re(z_1)\\Re(z_2) + \\Im(z_1)\\Im(z_2)$$"],null)),heb,$APP.z(kYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],
null))),$APP.P,"Given a symbol (like `'+`) returns an applicable operator if there is a\n  corresponding symbolic operator construction available."],null)),Lkb,$APP.z(ftb,new $APP.f(null,1,[$APP.im,!0],null)),HJ,vQb,OOb,$APP.z(a3b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null)))],null))],[new $APP.f(null,3,[$APP.Q,H2b,$APP.X,jH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Dac,$APP.X,hH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,NGb,$APP.X,bWa,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.Q,BYb,$APP.X,Mnc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,t7b,$APP.X,$APP.u,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,eEb,$APP.X,aWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the symbolic dot product of the two supplied numbers `z1` and `z2`.\n\n  If both are numbers, defers to [[emmy.generic/dot-product]]. Else,\n  returns\n\n  $$\\Re(z_1)\\Re(z_2) + \\Im(z_1)\\Im(z_2)$$",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[XTb,YTb],null))],null)],null),new $APP.f(null,
3,[$APP.Q,Rcb,$APP.X,m0a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Ztb,$APP.X,FH,$APP.h,new $APP.f(null,2,[$APP.P,"Given a symbol (like `'+`) returns an applicable operator if there is a\n  corresponding symbolic operator construction available.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Scb,$APP.X,Lnc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,CWb,$APP.X,TM,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Tmb,$APP.X,Onc,$APP.h,$APP.F],
null),new $APP.f(null,3,[$APP.Q,LPb,$APP.X,dH,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,grb,$APP.X,$APP.Fc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,FYb,$APP.X,PVa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null)]),$APP.ap(K6b)),$APP.cp(new $APP.f(null,5,[$APP.z(Zob,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv],null),new $APP.H(null,4,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv,$cc],null),new $APP.H(null,
5,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv,$APP.Sv,xU],null))),$APP.P,"Function with an identical interface to [[richardson-sequence]], except for an\n  additional second argument `col`.\n\n  `richardson-column` will return that _column_ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  Richardson accelerations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the Richardson tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a single acceleration by combining points\n  from column 0; `2` kills two terms from the error sequence, etc.\n\n  NOTE Given a better interface for [[richardson-sequence]] this function could\n  be merged with that function.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,5,$APP.qw,5,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv],null),new $APP.H(null,4,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv,$cc],null),new $APP.H(null,5,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv,$APP.Sv,xU],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv],null),new $APP.H(null,4,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv,$cc],null),new $APP.H(null,5,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv,$APP.Sv,xU],null)),$APP.Cx,
$APP.M(null,null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Nvb,$APP.X,c4,$APP.h,new $APP.f(null,2,[$APP.P,"Function with an identical interface to [[richardson-sequence]], except for an\n  additional second argument `col`.\n\n  `richardson-column` will return that _column_ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  Richardson accelerations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the Richardson tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a single acceleration by combining points\n  from column 0; `2` kills two terms from the error sequence, etc.\n\n  NOTE Given a better interface for [[richardson-sequence]] this function could\n  be merged with that function.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv],null),new $APP.H(null,4,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv,$cc],null),new $APP.H(null,5,5,$APP.I,[$APP.ix,$APP.Rx,$APP.Uv,$APP.Sv,xU],null))],null)],null),$APP.z(EAb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uv,$APP.Lh,$APP.Ox],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns the best approximation of `A(0)` using the algorithm described\n  in [[richardson-sequence]].\n\n  Equivalent to `(last ([[richardson-sequence]] t))`\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Uv,$APP.Ox)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uv,$APP.Lh,$APP.Ox],null)),$APP.Cx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.Q,wob,$APP.X,e4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns the best approximation of `A(0)` using the algorithm described\n  in [[richardson-sequence]].\n\n  Equivalent to `(last ([[richardson-sequence]] t))`\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uv,$APP.Lh,$APP.Ox],null))],null)],null),$APP.z(hfb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uv,$APP.Lh,$APP.Ox],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns a lazy sequence of successive approximations `A(0)` using the\n  algorithm described in [[richardson-sequence]].\n\n  Equivalent to `([[richardson-sequence]] t)`.\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Uv,$APP.Ox)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uv,$APP.Lh,$APP.Ox],null)),$APP.Cx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.Q,mDb,$APP.X,f4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns a lazy sequence of successive approximations `A(0)` using the\n  algorithm described in [[richardson-sequence]].\n\n  Equivalent to `([[richardson-sequence]] t)`.\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Uv,$APP.Lh,$APP.Ox],null))],null)],null),$APP.z(Oac,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Uv],null),new $APP.H(null,3,5,$APP.I,[$APP.ix,$APP.Uv,Bob],null),new $APP.H(null,4,5,$APP.I,[$APP.ix,$APP.Uv,$APP.Sv,xU],null))),$APP.P,"Takes:\n\n  - `xs`: a (potentially lazy) sequence of points representing function values\n  generated by inputs continually decreasing by a factor of `t`. For example:\n  `[f(x), f(x/t), f(x/t^2), ...]`\n  - `t`: the ratio between successive inputs that generated `xs`.\n\n  And returns a new (lazy) sequence of 'accelerated' using [Richardson\n  extrapolation](https://en.wikipedia.org/wiki/Richardson_extrapolation) to\n  cancel out error terms in the taylor series expansion of `f(x)` around the\n  value the series to which the series is trying to converge.\n\n  Each term in the returned sequence cancels one of the error terms through a\n  linear combination of neighboring terms in the sequence.\n\n  ### Custom P Sequence\n\n  The three-arity version takes one more argument:\n\n  - `p-sequence`: the orders of the error terms in the taylor series expansion\n  of the function that `xs` is estimating. For example, if `xs` is generated\n  from some `f(x)` trying to approximate `A`, then `[p_1, p_2...]` etc are the\n  correction terms:\n\n  ```\n  $$f(x) \x3d A + B x^{p_1} + C x^{p_2}...$$\n  ```\n\n  The two-arity version uses a default `p-sequence` of `[1, 2, 3, ...]`\n\n  ### Arithmetic Progression\n\n  The FOUR arity version takes `xs` and `t` as before, but instead of\n  `p-sequence` makes the assumption that `p-sequence` is an arithmetic\n  progression of the form `p + iq`, customized by:\n\n  - `p`: the exponent on the highest-order error term\n  - `q`: the step size on the error term exponent for each new seq element\n\n  ## Notes\n\n  Richardson extrapolation is a special case of polynomial extrapolation,\n  implemented in `polynomial.cljc`.\n\n  Instead of a sequence of `xs`, if you generate an explicit series of points of\n  the form `[x (f x)]` with successively smaller `x` values and\n  polynomial-extrapolate it forward to x \x3d\x3d 0 (with,\n  say, `(polynomial/modified-neville xs 0)`) you'll get the exact same result.\n\n  Richardson extrapolation is more efficient since it can make assumptions about\n  the spacing between points and pre-calculate a few quantities. See the\n  namespace for more discussion.\n\n  References:\n\n  - Wikipedia, [\"Richardson Extrapolation\"](https://en.wikipedia.org/wiki/Richardson_extrapolation)\n  - GJS, ['Abstraction in Numerical Methods'](https://dspace.mit.edu/bitstream/handle/1721.1/6060/AIM-997.pdf?sequence\x3d2)",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Uv],null),new $APP.H(null,3,5,$APP.I,[$APP.ix,$APP.Uv,Bob],null),new $APP.H(null,4,5,$APP.I,[$APP.ix,$APP.Uv,$APP.Sv,xU],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Uv],null),new $APP.H(null,3,5,$APP.I,[$APP.ix,$APP.Uv,Bob],null),new $APP.H(null,4,5,$APP.I,[$APP.ix,$APP.Uv,$APP.Sv,xU],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),new $APP.f(null,
3,[$APP.Q,bpb,$APP.X,IQ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - `xs`: a (potentially lazy) sequence of points representing function values\n  generated by inputs continually decreasing by a factor of `t`. For example:\n  `[f(x), f(x/t), f(x/t^2), ...]`\n  - `t`: the ratio between successive inputs that generated `xs`.\n\n  And returns a new (lazy) sequence of 'accelerated' using [Richardson\n  extrapolation](https://en.wikipedia.org/wiki/Richardson_extrapolation) to\n  cancel out error terms in the taylor series expansion of `f(x)` around the\n  value the series to which the series is trying to converge.\n\n  Each term in the returned sequence cancels one of the error terms through a\n  linear combination of neighboring terms in the sequence.\n\n  ### Custom P Sequence\n\n  The three-arity version takes one more argument:\n\n  - `p-sequence`: the orders of the error terms in the taylor series expansion\n  of the function that `xs` is estimating. For example, if `xs` is generated\n  from some `f(x)` trying to approximate `A`, then `[p_1, p_2...]` etc are the\n  correction terms:\n\n  ```\n  $$f(x) \x3d A + B x^{p_1} + C x^{p_2}...$$\n  ```\n\n  The two-arity version uses a default `p-sequence` of `[1, 2, 3, ...]`\n\n  ### Arithmetic Progression\n\n  The FOUR arity version takes `xs` and `t` as before, but instead of\n  `p-sequence` makes the assumption that `p-sequence` is an arithmetic\n  progression of the form `p + iq`, customized by:\n\n  - `p`: the exponent on the highest-order error term\n  - `q`: the step size on the error term exponent for each new seq element\n\n  ## Notes\n\n  Richardson extrapolation is a special case of polynomial extrapolation,\n  implemented in `polynomial.cljc`.\n\n  Instead of a sequence of `xs`, if you generate an explicit series of points of\n  the form `[x (f x)]` with successively smaller `x` values and\n  polynomial-extrapolate it forward to x \x3d\x3d 0 (with,\n  say, `(polynomial/modified-neville xs 0)`) you'll get the exact same result.\n\n  Richardson extrapolation is more efficient since it can make assumptions about\n  the spacing between points and pre-calculate a few quantities. See the\n  namespace for more discussion.\n\n  References:\n\n  - Wikipedia, [\"Richardson Extrapolation\"](https://en.wikipedia.org/wiki/Richardson_extrapolation)\n  - GJS, ['Abstraction in Numerical Methods'](https://dspace.mit.edu/bitstream/handle/1721.1/6060/AIM-997.pdf?sequence\x3d2)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Uv],null),new $APP.H(null,3,5,$APP.I,[$APP.ix,$APP.Uv,Bob],null),new $APP.H(null,4,5,$APP.I,[$APP.ix,$APP.Uv,$APP.Sv,xU],null))],null)],null),$APP.z(Kpb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Uv],null),new $APP.H(null,3,5,$APP.I,[$APP.Uv,xCb,Twb],null))),$APP.P,"Returns a fold expected to process the outputs of some function `A` for inputs\n  of the form:\n\n  $$A(h), A(h/t), A(h/t^2) \\ldots$$\n\n  and generate (when present is called) successively tighter estimates of A(0)\n  using the algorithm described in [[richardson-sequence]].\n\n  Takes as a required argument:\n\n  - `t`: the ratio between the successive inputs that generated the\n    data to be processed by this fold (see above)\n\n\n  If `initial-p` and `next-p-fn` are not supplied, it's assumed that the order\n  of the error terms in the taylor series expansion of `A` start at 1 and\n  increase by 1 with each new term.\n\n  You can tune this by supplying:\n\n  - `initial-p`: The order of the first error term\n  - `next-p-fn`: a function that will generate the next term given the previous\n    term\n\n  For the geometrically increasing error series `[2, 4, 6, 8]`, for example,\n  try\n\n  ```clj\n  (richardson-fold \x3ct\x3e 2 #(+ % 2))\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Uv],null),new $APP.H(null,3,5,$APP.I,[$APP.Uv,xCb,Twb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Uv],null),new $APP.H(null,3,5,$APP.I,[$APP.Uv,xCb,Twb],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,JIb,$APP.X,d4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a fold expected to process the outputs of some function `A` for inputs\n  of the form:\n\n  $$A(h), A(h/t), A(h/t^2) \\ldots$$\n\n  and generate (when present is called) successively tighter estimates of A(0)\n  using the algorithm described in [[richardson-sequence]].\n\n  Takes as a required argument:\n\n  - `t`: the ratio between the successive inputs that generated the\n    data to be processed by this fold (see above)\n\n\n  If `initial-p` and `next-p-fn` are not supplied, it's assumed that the order\n  of the error terms in the taylor series expansion of `A` start at 1 and\n  increase by 1 with each new term.\n\n  You can tune this by supplying:\n\n  - `initial-p`: The order of the first error term\n  - `next-p-fn`: a function that will generate the next term given the previous\n    term\n\n  For the geometrically increasing error series `[2, 4, 6, 8]`, for example,\n  try\n\n  ```clj\n  (richardson-fold \x3ct\x3e 2 #(+ % 2))\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Uv],null),new $APP.H(null,3,5,$APP.I,[$APP.Uv,xCb,Twb],null))],null)],null)],null),$APP.ap(Dwb)),$APP.cp($APP.fg([$APP.z(Gab,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,2,5,$APP.I,[RS,$APP.Fy],null))),$APP.P,"Takes a `pattern` or matcher combinator, and returns a function from a data\n  object to either:\n\n  - A successful map of bindings extracted by matching the supplied `pattern` or\n    combinator to the input data\n  - An explicit `failure` object\n\n  Check for failure with [[failed?]].\n\n  Optionally, you can supply a predicate `pred`. `pred` takes the map of\n  bindings from a successful match and returns either:\n\n  - `nil`, `false` or the explicit `failure` object to force a match failure,\n    potentially causing a backtrack back into the data\n  - a map of NEW bindings to merge into the binding map (and signal success)\n\n  Any other truthy value signals success with no new bindings.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,2,5,$APP.I,[RS,$APP.Fy],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,2,5,$APP.I,[RS,$APP.Fy],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($APP.uDa,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null))),$APP.P,"Takes a binding variable `sym` and an optional predicate `pred`, and returns a\n  matcher that binds its input to `sym` in the returned `frame`.\n\n  The returned matcher only succeeds if `input` passes `pred`.\n\n  If `sym` is already present in `frame`, the matcher only succeeds if the\n  values are equal, fails otherwise.\n\n  NOTE: If `sym` is the wildcard `_`, the returned matcher will not introduce a\n  new binding, but _will_ still check the predicate.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($APP.ko,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Lh,$APP.Zw],
null))),$APP.P,"Takes a sequence of patterns and returns a matcher that will apply its\n  arguments to the first pattern;\n\n  If that match succeeds, the next pattern will be called with the new, returned\n  frame (and the original data and success continuation).\n\n  The returned matcher succeeds only of all patterns succeed, and returns the\n  value of the final pattern.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,
[RS],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(Rvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[RS,$APP.Nv,$APP.dx],null))),$APP.P,"Convenience function that creates a [[foreach-matcher]] from the supplied\n  `pattern` and callback `f` and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((foreach-matcher pattern pred) data)\n  ```"],
null)),$APP.z(Agb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[fsb],null))),$APP.P,"Takes a `new-frame` of bindings and returns a matcher that will ignore its\n  input and always succeed by replacing the current map of bindings with\n  `new-frame`."],null)),$APP.z(o2b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Fy,SV],null),new $APP.H(null,3,5,$APP.I,[$APP.Fy,SV,zLb],null))),$APP.P,"Returns a matcher that passes its `frame` on to `success-pattern` if `pred`\n  succeeds on its data input, `fail-pattern` otherwise.\n\n  If no `fail-matcher` is supplied, the behavior is equivalent\n  to [[match-when]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Fy,SV],null),new $APP.H(null,3,5,$APP.I,[$APP.Fy,SV,zLb],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Fy,SV],null),new $APP.H(null,3,5,$APP.I,[$APP.Fy,SV,zLb],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(dX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,gCb],null))),$APP.P,
"Takes some input `x` and returns a matcher which succeeds if its data input is\n  equal to `x` (via `\x3d` or the optional `eq-fn` argument). Fails otherwise.\n\n  The frame is not modified.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,gCb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,gCb],null)),$APP.Cx,$APP.M(null,
null)],null)],null)),$APP.z(fqb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.Ou],null))),$APP.P,"Takes a function from `frame` to a new frame (or false) and any number of\n  arguments `args`, and returns a matcher that will ignore its input and\n\n  - succeed with `(apply f frame args)` if that value is truthy,\n  - fail otherwise.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Nv,$APP.Ou)],
null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.Ou],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(WEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Fy],null))),$APP.P,"Takes a predicate function `pred` and returns a matcher that succeeds (with no\n  new bindings) if its data input passes the predicate, fails otherwise."],null)),$APP.z($APP.Iu,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Takes a `pattern` and returns a matcher that will apply its arguments to the\n  `pattern`. The returned pattern will succeed with the original frame if\n  `pattern` fails, and fail if `pattern` succeeds."],
null)),$APP.z(Qeb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Kv,$APP.Kv],null))),$APP.P,"Matcher which will fail for any input."],null)),$APP.z($APP.uAa,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,mY],null))),$APP.P,"Takes a sequence of patterns and returns a matcher that accepts a sequential\n  data input, and attempts to match successive items (or segments) in the\n  sequence with the supplied patterns.\n\n  The returned matcher succeeds if `patterns` can consume all elements, fails\n  otherwise (or of any of the supplied patterns fails on its argument).\n\n  On success, the returned matcher calls its success continuation with a frame\n  processed by each pattern in sequence.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(mY)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,mY],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(KRb,new $APP.f(null,4,[aY,!0,$APP.ow,$APP.oj,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CIb],null))),$APP.P,"Factory function for emmy.pattern.match/Failure, taking a map of keywords to field values."],null)),$APP.z($APP.jdc,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null))),$APP.P,"Takes a binding variable `sym` and returns a matcher that calls its success\n  continuation with successively longer prefixes of its (sequential) data input\n  bound to `sym` inside the frame.\n\n  If `sym` is already present in the frame, the returned matcher only succeeds\n  if the bound value is a prefix of the data argument `xs`.\n\n  If `sym` matches the wildcard symbol `_`, the behavior is the same, but no new\n  binding is introduced.\n\n  NOTE: the returned matcher will call its success continuation with TWO\n  arguments; the new frame and the remaining elements in `xs`. This is a\n  different contract than all other matchers, making `segment` appropriate for\n  use inside `sequence`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(Dbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[rT,$APP.Kv,X$b],null))),$APP.P,"Matcher that succeeds (with no new bindings) for any input, passing along its\n  input frame."],
null)),$APP.z(jzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Fy],null))),$APP.P,"Takes a predicate function `pred` and returns a matcher that succeeds (with no\n  new bindings) if its data input passes the predicate, fails otherwise."],null)),$APP.z(Tvb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null))),$APP.P,"Returns a matcher that takes a binding variable `sym`, and succeeds if it's\n  called with a sequential data argument with a prefix that is the REVERSE of\n  the sequence bound to `sym` in `frame`.\n\n  Fails if any of the following are true:\n\n  - `sym` is not bound in the frame\n  - `sym` is bound to something other than a vector prefix created by `segment`\n  - the data argument does not have a prefix matching the reverse of vector\n    bound to `sym`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(l5b,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(fib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[RS,$APP.dx],null))),$APP.P,
"Convenience function that creates an [[all-results-matcher]] from the supplied\n  `pattern` and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((all-results-matcher pattern pred) data)\n  ```"],null)),$APP.z(TIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is equivalent to the failure sentinel [[failure]], false\n  otherwise."],null)),FGb,$APP.z(LHb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[RS,$APP.dx],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Fy,$APP.dx],null))),$APP.P,"Convenience function that creates a matcher from the supplied `pattern` (and\n  optional predicate `pred`) and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((matcher pattern pred) data)\n  ```",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[RS,$APP.dx],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Fy,$APP.dx],
null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[RS,$APP.dx],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Fy,$APP.dx],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(uHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Takes a matcher and returns `f` with its metadata modified such\n  that [[segment-matcher?]] will return `true` when applied to `f`."],null)),$APP.z(NLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[RS],null))),$APP.P,"Takes a `pattern` and callback function `f`, and returns a matcher that takes a\n  `data` argument and returns a sequence of every possible match of `pattern` to\n  the data.\n\n  For a convenience function that applies the matcher to data immediately,\n  see [[all-results]].\n\n  NOTE: If you pass a segment matcher, `f` must accept two arguments - the\n  binding map, and the sequence of all remaining items that the segment\n  matcher rejected."],null)),$APP.z(DLb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mY],null))),$APP.P,"Version of [[sequence]] that takes an explicit sequence of `patterns`, vs the\n  multi-arity version. See [[sequence]] for documentation."],null)),$APP.z(ZQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Fy,SV],null))),$APP.P,"Returns a matcher that passes its `frame` on to `success-pattern` if `pred`\n  succeeds on its data input, fails otherwise."],null)),$APP.z(YUb,new $APP.f(null,4,
[aY,!0,$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"Positional factory function for emmy.pattern.match/Failure."],null)),$APP.z(IIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[RS,$APP.Nv],null))),$APP.P,"Takes a `pattern` and side-effecting callback function `f`, and returns a\n  matcher that calls `f` with a map of bindings for every possible match of\n  `pattern` to its input data.\n\n  For a convenience function that applies the matcher to data immediately,\n  see [[foreach]].\n\n  NOTE: If you pass a segment matcher, `f` must accept two arguments - the\n  binding map, and the sequence of all remaining items that the segment\n  matcher rejected."],
null)),$APP.z($APP.po,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Lh,$APP.Zw],null))),$APP.P,"Takes a sequence of patterns, and returns a matcher that will apply its\n  arguments to each matcher in turn. Returns the value of the first pattern that\n  succeeds.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[RS],null)],null),$APP.U,
$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null)],null)],null))],[new $APP.f(null,3,[$APP.Q,LWb,$APP.X,kJ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `pattern` or matcher combinator, and returns a function from a data\n  object to either:\n\n  - A successful map of bindings extracted by matching the supplied `pattern` or\n    combinator to the input data\n  - An explicit `failure` object\n\n  Check for failure with [[failed?]].\n\n  Optionally, you can supply a predicate `pred`. `pred` takes the map of\n  bindings from a successful match and returns either:\n\n  - `nil`, `false` or the explicit `failure` object to force a match failure,\n    potentially causing a backtrack back into the data\n  - a map of NEW bindings to merge into the binding map (and signal success)\n\n  Any other truthy value signals success with no new bindings.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,2,5,$APP.I,[RS,$APP.Fy],null))],null)],null),new $APP.f(null,3,[$APP.Q,Bub,$APP.X,rK,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a binding variable `sym` and an optional predicate `pred`, and returns a\n  matcher that binds its input to `sym` in the returned `frame`.\n\n  The returned matcher only succeeds if `input` passes `pred`.\n\n  If `sym` is already present in `frame`, the matcher only succeeds if the\n  values are equal, fails otherwise.\n\n  NOTE: If `sym` is the wildcard `_`, the returned matcher will not introduce a\n  new binding, but _will_ still check the predicate.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null))],null)],null),new $APP.f(null,3,[$APP.Q,V6b,$APP.X,uK,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a sequence of patterns and returns a matcher that will apply its\n  arguments to the first pattern;\n\n  If that match succeeds, the next pattern will be called with the new, returned\n  frame (and the original data and success continuation).\n\n  The returned matcher succeeds only of all patterns succeed, and returns the\n  value of the final pattern.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lmb,$APP.X,function(a,b,c){return eYa(a,b)(c)},$APP.h,new $APP.f(null,2,[$APP.P,"Convenience function that creates a [[foreach-matcher]] from the supplied\n  `pattern` and callback `f` and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((foreach-matcher pattern pred) data)\n  ```",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,
[RS,$APP.Nv,$APP.dx],null))],null)],null),new $APP.f(null,3,[$APP.Q,IHb,$APP.X,function(a){return function(b,c,d){return d.j?d.j(a):d.call(null,a)}},$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `new-frame` of bindings and returns a matcher that will ignore its\n  input and always succeed by replacing the current map of bindings with\n  `new-frame`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[fsb],null))],null)],null),new $APP.f(null,3,[$APP.Q,HZb,$APP.X,P1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matcher that passes its `frame` on to `success-pattern` if `pred`\n  succeeds on its data input, `fail-pattern` otherwise.\n\n  If no `fail-matcher` is supplied, the behavior is equivalent\n  to [[match-when]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Fy,SV],null),new $APP.H(null,3,5,$APP.I,[$APP.Fy,SV,zLb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Zbc,$APP.X,O1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes some input `x` and returns a matcher which succeeds if its data input is\n  equal to `x` (via `\x3d` or the optional `eq-fn` argument). Fails otherwise.\n\n  The frame is not modified.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,gCb],null))],null)],
null),new $APP.f(null,3,[$APP.Q,j2b,$APP.X,N1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function from `frame` to a new frame (or false) and any number of\n  arguments `args`, and returns a matcher that will ignore its input and\n\n  - succeed with `(apply f frame args)` if that value is truthy,\n  - fail otherwise.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.Ou],null))],null)],null),new $APP.f(null,3,[$APP.Q,cVb,$APP.X,YXa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a predicate function `pred` and returns a matcher that succeeds (with no\n  new bindings) if its data input passes the predicate, fails otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Fy],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lhb,$APP.X,$Xa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `pattern` and returns a matcher that will apply its arguments to the\n  `pattern`. The returned pattern will succeed with the original frame if\n  `pattern` fails, and fail if `pattern` succeeds.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,xcb,$APP.X,VXa,$APP.h,new $APP.f(null,2,[$APP.P,"Matcher which will fail for any input.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,$APP.Kv,$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.Q,mac,$APP.X,S1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a sequence of patterns and returns a matcher that accepts a sequential\n  data input, and attempts to match successive items (or segments) in the\n  sequence with the supplied patterns.\n\n  The returned matcher succeeds if `patterns` can consume all elements, fails\n  otherwise (or of any of the supplied patterns fails on its argument).\n\n  On success, the returned matcher calls its success continuation with a frame\n  processed by each pattern in sequence.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,mY],null))],null)],null),new $APP.f(null,3,[$APP.Q,JNb,$APP.X,function(a){var b=$APP.Oi.j(a);a=$APP.nd(a)?$APP.Lf.A($APP.F,b):b;return new iJ(null,$APP.re(a),null)},$APP.h,new $APP.f(null,2,[$APP.P,"Factory function for emmy.pattern.match/Failure, taking a map of keywords to field values.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CIb],null))],null)],null),new $APP.f(null,3,[$APP.Q,WQb,$APP.X,Q1,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a binding variable `sym` and returns a matcher that calls its success\n  continuation with successively longer prefixes of its (sequential) data input\n  bound to `sym` inside the frame.\n\n  If `sym` is already present in the frame, the returned matcher only succeeds\n  if the bound value is a prefix of the data argument `xs`.\n\n  If `sym` matches the wildcard symbol `_`, the behavior is the same, but no new\n  binding is introduced.\n\n  NOTE: the returned matcher will call its success continuation with TWO\n  arguments; the new frame and the remaining elements in `xs`. This is a\n  different contract than all other matchers, making `segment` appropriate for\n  use inside `sequence`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null))],null)],null),new $APP.f(null,3,[$APP.Q,cwb,$APP.X,WXa,$APP.h,new $APP.f(null,2,[$APP.P,"Matcher that succeeds (with no new bindings) for any input, passing along its\n  input frame.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[rT,$APP.Kv,X$b],null))],null)],null),new $APP.f(null,3,[$APP.Q,Hub,$APP.X,XXa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a predicate function `pred` and returns a matcher that succeeds (with no\n  new bindings) if its data input passes the predicate, fails otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Fy],null))],null)],null),new $APP.f(null,3,[$APP.Q,Iac,$APP.X,R1,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matcher that takes a binding variable `sym`, and succeeds if it's\n  called with a sequential data argument with a prefix that is the REVERSE of\n  the sequence bound to `sym` in `frame`.\n\n  Fails if any of the following are true:\n\n  - `sym` is not bound in the frame\n  - `sym` is bound to something other than a vector prefix created by `segment`\n  - the data argument does not have a prefix matching the reverse of vector\n    bound to `sym`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yx],null),new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.Fy],null))],null)],null),new $APP.f(null,3,[$APP.Q,mLb,$APP.X,hJ,$APP.h,new $APP.f(null,2,[$APP.P,"Given a pattern (built using the syntax elements described in\n  `emmy.pattern.syntax`), returns a matcher combinator that will successfully\n  match data structures described by the input pattern, and fail otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,
[$APP.Q,Ybc,$APP.X,function(a,b){return fYa(a)(b)},$APP.h,new $APP.f(null,2,[$APP.P,"Convenience function that creates an [[all-results-matcher]] from the supplied\n  `pattern` and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((all-results-matcher pattern pred) data)\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[RS,$APP.dx],null))],null)],null),new $APP.f(null,3,[$APP.Q,T1b,$APP.X,jJ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is equivalent to the failure sentinel [[failure]], false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Z_b,$APP.X,lJ,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Iab,$APP.X,T1,$APP.h,new $APP.f(null,2,[$APP.P,"Convenience function that creates a matcher from the supplied `pattern` (and\n  optional predicate `pred`) and immediately applies it to `data`.\n\n  Equivalent to:\n\n  ```clojure\n  ((matcher pattern pred) data)\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[RS,$APP.dx],null),new $APP.H(null,
3,5,$APP.I,[RS,$APP.Fy,$APP.dx],null))],null)],null),new $APP.f(null,3,[$APP.Q,UCb,$APP.X,bYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a matcher and returns `f` with its metadata modified such\n  that [[segment-matcher?]] will return `true` when applied to `f`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,YSb,$APP.X,fYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `pattern` and callback function `f`, and returns a matcher that takes a\n  `data` argument and returns a sequence of every possible match of `pattern` to\n  the data.\n\n  For a convenience function that applies the matcher to data immediately,\n  see [[all-results]].\n\n  NOTE: If you pass a segment matcher, `f` must accept two arguments - the\n  binding map, and the sequence of all remaining items that the segment\n  matcher rejected.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,ybc,$APP.X,dYa,$APP.h,new $APP.f(null,2,[$APP.P,"Version of [[sequence]] that takes an explicit sequence of `patterns`, vs the\n  multi-arity version. See [[sequence]] for documentation.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[mY],null))],null)],null),new $APP.f(null,3,[$APP.Q,Bqb,$APP.X,ZXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matcher that passes its `frame` on to `success-pattern` if `pred`\n  succeeds on its data input, fails otherwise.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Fy,SV],null))],null)],null),new $APP.f(null,3,[$APP.Q,fjb,$APP.X,function(){return new iJ(null,null,null)},$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.pattern.match/Failure.",$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.Q,Wgb,$APP.X,eYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `pattern` and side-effecting callback function `f`, and returns a\n  matcher that calls `f` with a map of bindings for every possible match of\n  `pattern` to its input data.\n\n  For a convenience function that applies the matcher to data immediately,\n  see [[foreach]].\n\n  NOTE: If you pass a segment matcher, `f` must accept two arguments - the\n  binding map, and the sequence of all remaining items that the segment\n  matcher rejected.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[RS,$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ibc,$APP.X,tK,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a sequence of patterns, and returns a matcher that will apply its\n  arguments to each matcher in turn. Returns the value of the first pattern that\n  succeeds.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[RS],null),new $APP.H(null,3,5,$APP.I,[RS,$APP.Lh,$APP.Zw],null))],null)],null)]),$APP.ap(IVb)),$APP.cp($APP.fg([$APP.z(zRb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,xV],null))),$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]]."],null)),$APP.z(yub,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[JU,VU],null)))],null)),$APP.z(fVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Nv,xV],null))),$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]]."],null)),$APP.z(LQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Rwb,Swb],null)))],null)),$APP.z(bBb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,VU],null)))],null)),
$APP.z(Uib,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Qgb,VU],null)))],null)),$APP.z(Wkb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields."],null)),$APP.z(Jrb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields."],null)),$APP.z(XSb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,
[JU,yU,$APP.lP,$APP.wU],null)))],null)),$APP.z(tWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hdb,VU],null)))],null))],[new $APP.f(null,3,[$APP.Q,O0b,$APP.X,xP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,xV],
null))],null)],null),new $APP.f(null,3,[$APP.Q,RNb,$APP.X,a5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[JU,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,TQb,$APP.X,vP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Nv,xV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ijb,$APP.X,Y4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[Rwb,Swb],null))],null)],null),new $APP.f(null,3,[$APP.Q,sSb,$APP.X,W4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,h9b,$APP.X,X4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[Qgb,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,BCb,$APP.X,wP,$APP.h,new $APP.f(null,
2,[$APP.P,"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,KMb,$APP.X,uP,$APP.h,new $APP.f(null,2,[$APP.P,"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,MIb,$APP.X,$4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[JU,yU,$APP.lP,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,q0b,$APP.X,b5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hdb,VU],null))],null)],null)]),$APP.ap(sRb)),$APP.cp($APP.fg([$APP.z(hWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,
"If `pattern` is a variable binding form in a pattern with restriction predicates,\n  returns a predicate that only returns true if all of the predicates pass for\n  its input, false otherwise.\n\n  If `pattern` has no restrictions or is some other input type, returns a\n  predicate that will always return `true`."],null)),$APP.z(Ebc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Given a pattern with unquoted binding forms and, potentially, `~` and `~@`\n  entries, returns a pattern appropriately quoted such that it can be evaluated\n  by the Clojure reader.\n\n  Changes:\n\n  - `(? x) \x3d\x3e (list '? 'x)`\n  - any bare symbol is quoted\n  - Any form unquoted like `~x` is left UNquoted, even in the symbol spot of `(?\n    ~sym ...)`\n  - Any form marked `~@[1 2 3]` is spliced in directly, EVEN in the symbol spot\n    of `(? ~@sym ...)`\n\n  These rules proceed recursively down into map, vector and sequential data\n  structures. (Recursion only pushes down into values for map-shaped patterns.)"],
null)),$APP.z(j7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Returns true if `pattern` is a sequence form that should be spliced directly\n  into the returned pattern, false otherwise."],null)),$APP.z(JSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[ldc,$APP.Nv,$APP.ix],null))),$APP.P,"Helper function for reducing over a sequence that might contain forms that need\n  to be spliced into the resulting sequence. This is a sort of helper for a\n  guarded `mapcat`.\n\n  Takes a sequence `xs` and mapping function `f` and returns a sequence of\n  sequences that, if concatenated together, would be identical to\n\n  ```clojure\n  (map f xs)\n  ```\n\n  Where any `x` such that `(splice? x)` returns true would have its sequential\n  value `(f x)` spliced into the result.\n\n  For example:\n\n  ```clojure\n  (let [f (fn [x] (if (odd? x)  [x x x] x))]\n    (splice-reduce odd? f (range 5)))\n\n  ;;\x3d\x3e [[0] [1 1 1] [2] [3 3 3] [4]]\n  ```"],
null)),$APP.z(Pcb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Returns true if `pattern` is a reversed-segment variable reference, false\n  otherwise.\n\n  A reverse-segment binding variable is either:\n\n  - A symbol starting with `$$`\n  - A sequence of the form `(:$$ \x3cbinding\x3e ...)`."],null)),$APP.z(FCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Returns true if `pattern` is a binding pattern with restriction predicates,\n  false otherwise."],
null)),$APP.z(oLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Returns true if `pattern` is a binding variable reference, false otherwise.\n\n  A binding variable is either:\n\n  - A symbol starting with a single `?` character\n  - A sequence of the form `(? \x3cbinding\x3e ...)`."],null)),$APP.z(O7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Given a REVERSE-segment name, either extracts the symbol from a pattern\n  like `(:$$ x)`, or transforms symbols like `$$x` into `??x`."],
null)),$APP.z(C7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Given a variable or segment binding form, returns the binding variable.\n\n  NOTE that [[variable-name]] will not guard against incorrect inputs."],null)),$APP.z(kob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Returns true if `pattern` is a segment variable reference, false otherwise.\n\n  A segment binding variable is either:\n\n  - A symbol starting with `??`\n  - A sequence of the form `(?? \x3cbinding\x3e ...)`."],
null)),$APP.z(aZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Given a `pattern` that responds `true` to [[unquote?]] or [[unquote-splice?]],\n  returns the form from that pattern."],null)),$APP.z(lAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))),$APP.P,"Returns true if `pattern` matches the wildcard character `_`, false otherwise."],null)),$APP.z(Mdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[RS],null))),$APP.P,"Returns true if `pattern` is a form that should be included with no quoting\n  into the returned pattern, false otherwise."],null))],[new $APP.f(null,3,[$APP.Q,Tbb,$APP.X,cJ,$APP.h,new $APP.f(null,2,[$APP.P,"If `pattern` is a variable binding form in a pattern with restriction predicates,\n  returns a predicate that only returns true if all of the predicates pass for\n  its input, false otherwise.\n\n  If `pattern` has no restrictions or is some other input type, returns a\n  predicate that will always return `true`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Dbb,$APP.X,M1,$APP.h,new $APP.f(null,2,[$APP.P,"Given a pattern with unquoted binding forms and, potentially, `~` and `~@`\n  entries, returns a pattern appropriately quoted such that it can be evaluated\n  by the Clojure reader.\n\n  Changes:\n\n  - `(? x) \x3d\x3e (list '? 'x)`\n  - any bare symbol is quoted\n  - Any form unquoted like `~x` is left UNquoted, even in the symbol spot of `(?\n    ~sym ...)`\n  - Any form marked `~@[1 2 3]` is spliced in directly, EVEN in the symbol spot\n    of `(? ~@sym ...)`\n\n  These rules proceed recursively down into map, vector and sequential data\n  structures. (Recursion only pushes down into values for map-shaped patterns.)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,SGb,$APP.X,eJ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a sequence form that should be spliced directly\n  into the returned pattern, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,R$b,$APP.X,OXa,$APP.h,new $APP.f(null,2,[$APP.P,"Helper function for reducing over a sequence that might contain forms that need\n  to be spliced into the resulting sequence. This is a sort of helper for a\n  guarded `mapcat`.\n\n  Takes a sequence `xs` and mapping function `f` and returns a sequence of\n  sequences that, if concatenated together, would be identical to\n\n  ```clojure\n  (map f xs)\n  ```\n\n  Where any `x` such that `(splice? x)` returns true would have its sequential\n  value `(f x)` spliced into the result.\n\n  For example:\n\n  ```clojure\n  (let [f (fn [x] (if (odd? x)  [x x x] x))]\n    (splice-reduce odd? f (range 5)))\n\n  ;;\x3d\x3e [[0] [1 1 1] [2] [3 3 3] [4]]\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[ldc,$APP.Nv,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,G_b,$APP.X,aJ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a reversed-segment variable reference, false\n  otherwise.\n\n  A reverse-segment binding variable is either:\n\n  - A symbol starting with `$$`\n  - A sequence of the form `(:$$ \x3cbinding\x3e ...)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ntb,$APP.X,function(a){return $APP.kd(a)&&
2<$APP.Tc(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a binding pattern with restriction predicates,\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,UAb,$APP.X,KXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a binding variable reference, false otherwise.\n\n  A binding variable is either:\n\n  - A symbol starting with a single `?` character\n  - A sequence of the form `(? \x3cbinding\x3e ...)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Llb,$APP.X,NXa,$APP.h,new $APP.f(null,2,[$APP.P,"Given a REVERSE-segment name, either extracts the symbol from a pattern\n  like `(:$$ x)`, or transforms symbols like `$$x` into `??x`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,M4b,$APP.X,bJ,$APP.h,new $APP.f(null,2,[$APP.P,"Given a variable or segment binding form, returns the binding variable.\n\n  NOTE that [[variable-name]] will not guard against incorrect inputs.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,W9b,$APP.X,$I,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a segment variable reference, false otherwise.\n\n  A segment binding variable is either:\n\n  - A symbol starting with `??`\n  - A sequence of the form `(?? \x3cbinding\x3e ...)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,osb,$APP.X,function(a){return $APP.Xc(a)},$APP.h,new $APP.f(null,
2,[$APP.P,"Given a `pattern` that responds `true` to [[unquote?]] or [[unquote-splice?]],\n  returns the form from that pattern.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,pEb,$APP.X,YI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` matches the wildcard character `_`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null),new $APP.f(null,3,[$APP.Q,o$b,$APP.X,dJ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `pattern` is a form that should be included with no quoting\n  into the returned pattern, false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RS],null))],null)],null)]),$APP.ap(fBb)),$APP.cp($APP.fg([$APP.z(uac,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.H(null,3,5,$APP.I,[$APP.ew,yU,$APP.Wv],null))),$APP.P,"Given two polynomials `u` and `v` (potentially multivariate) with\n  non-polynomial coefficients, returns the greatest common divisor of `u` and\n  `v` calculated using a multivariate extension of Knuth's algorithm 4.6.1E.\n\n  Optionally takes a debugging `level`. To see the debugging logs generated over\n  the course of the run, set [[*poly-gcd-debug*]] to true.\n\n  NOTE: [[full-gcd]] Internally checks that it hasn't run out a stopwatch set\n  with [[with-limited-time]]; you can wrap a call to [[full-gcd]] in this\n  function to limit its execution time.\n\n  For example, this form will throw a TimeoutException after 1 second:\n\n  ```clojure\n  (with-limited-time [1 :seconds]\n    (fn [] (full-gcd u v)))\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.H(null,3,5,$APP.I,[$APP.ew,yU,$APP.Wv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.H(null,3,5,$APP.I,[$APP.ew,yU,$APP.Wv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(jqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,
2,5,$APP.I,[$APP.M(ZIb,yU),$APP.M(ZIb,$APP.Wv)],null)],null)))),$APP.P,"Given two univariate polynomials `u` and `v`, returns the greatest common\n  divisor of `u` and `v` calculated using Knuth's algorithm 4.6.1E."],null)),$APP.z(kK,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[yU],null),new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.H(null,4,5,$APP.I,[yU,$APP.Wv,$APP.Lh,$APP.Zw],null)))],null)),$APP.z(eAb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(ARb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"Returns true if the [[*clock*]] dynamic variable contains a Stopwatch with an\n  elapsed time that's passed the limit allowed by the\n  dynamic [[*poly-gcd-time-limit*]], false otherwise."],null)),$APP.z(vBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vu,gY],null))),$APP.P,"Given an explicit `timeout` and a no-argument function `thunk`, calls `thunk`\n  in a context where [[*poly-gcd-time-limit*]] is dynamically bound to\n  `timeout`. Calling [[time-expired?]] or [[maybe-bail-out!]] inside `thunk`\n  will signal failure appropriately if `thunk` has taken longer than `timeout`."],
null)),$APP.z(Imb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))),$APP.P,"Higher-level wrapper around [[full-gcd]] that:\n\n  - optimizes the case where `u` and `v` share no variables\n  - sorts the variables in `u` and `v` in order of increasing degree\n\n  before attempting [[full-gcd]]. See [[full-gcd]] for a full description."],null)),$APP.z(rFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"When called, logs statistics about the GCD memoization cache, and the number of\n  times the system has encountered monomial or other trivial GCDs. "],
null)),$APP.z(vXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the greatest common divisor of all partial derivatives of the\n  polynomial `p` using binary applications of the [[gcd]] algorithm between each\n  partial derivative.\n\n  This algorithm assumes that all coefficients are integral, and halts when it\n  encounters a result that responds true to [[emmy.value/one?]].\n\n  If a non-[[p/Polynomial]] is supplied, returns 1."],null)),
$APP.z(FV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))),$APP.P,"Returns the least common multiple of (possibly polynomial) arguments `u` and\n  `v`, using [[gcd]] to calculate the gcd portion of\n\n  ```\n  (/ (g/abs (* u v))\n     (gcd u v))\n  ```"],null)),$APP.z(xNb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(FOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,kK],null))),$APP.P,"Given some polynomial `p`, and a multi-arity `gcd` function for its\n  coefficients, returns a pair of the polynomial's content and primitive.\n\n  The 'content' of a polynomial is the greatest common divisor of its\n  coefficients. The 'primitive part' of a polynomial is the quotient of the\n  polynomial by its content.\n\n  See Wikipedia's ['Primitive Part and\n  Content'](https://en.wikipedia.org/wiki/Primitive_part_and_content) page for\n  more details. "],
null)),$APP.z(Qtb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(Gdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))),$APP.P,"Given two polynomials `u` and `v`, attempts to return the greatest common\n  divisor of `u` and `v` by testing for trivial cases. If no trivial case\n  applies, returns `nil`."],null)),$APP.z(sub,new $APP.f(null,1,[$APP.im,!0],null))],[new $APP.f(null,3,[$APP.Q,QNb,$APP.X,pM,$APP.h,new $APP.f(null,2,[$APP.P,"Given two polynomials `u` and `v` (potentially multivariate) with\n  non-polynomial coefficients, returns the greatest common divisor of `u` and\n  `v` calculated using a multivariate extension of Knuth's algorithm 4.6.1E.\n\n  Optionally takes a debugging `level`. To see the debugging logs generated over\n  the course of the run, set [[*poly-gcd-debug*]] to true.\n\n  NOTE: [[full-gcd]] Internally checks that it hasn't run out a stopwatch set\n  with [[with-limited-time]]; you can wrap a call to [[full-gcd]] in this\n  function to limit its execution time.\n\n  For example, this form will throw a TimeoutException after 1 second:\n\n  ```clojure\n  (with-limited-time [1 :seconds]\n    (fn [] (full-gcd u v)))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.H(null,3,5,$APP.I,[$APP.ew,yU,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lsb,$APP.X,d0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given two univariate polynomials `u` and `v`, returns the greatest common\n  divisor of `u` and `v` calculated using Knuth's algorithm 4.6.1E.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(ZIb,yU),$APP.M(ZIb,$APP.Wv)],
null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Btb,$APP.X,rM,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[yU],null),new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.H(null,4,5,$APP.I,[yU,$APP.Wv,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lib,$APP.X,gM,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,zqb,$APP.X,O_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the [[*clock*]] dynamic variable contains a Stopwatch with an\n  elapsed time that's passed the limit allowed by the\n  dynamic [[*poly-gcd-time-limit*]], false otherwise.",
$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.Q,WYb,$APP.X,Q_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an explicit `timeout` and a no-argument function `thunk`, calls `thunk`\n  in a context where [[*poly-gcd-time-limit*]] is dynamically bound to\n  `timeout`. Calling [[time-expired?]] or [[maybe-bail-out!]] inside `thunk`\n  will signal failure appropriately if `thunk` has taken longer than `timeout`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vu,gY],null))],null)],null),new $APP.f(null,
3,[$APP.Q,BNb,$APP.X,e0a,$APP.h,new $APP.f(null,2,[$APP.P,"Higher-level wrapper around [[full-gcd]] that:\n\n  - optimizes the case where `u` and `v` share no variables\n  - sorts the variables in `u` and `v` in order of increasing degree\n\n  before attempting [[full-gcd]]. See [[full-gcd]] for a full description.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,dtb,$APP.X,function(){var a=$APP.Tc($APP.Fb(R_a));if(0<a){var b=$APP.Fb(S_a),c=$APP.Fb(T_a);
bH($APP.Yu,"emmy.polynomial.gcd",71,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,[JG("GCD cache hit rate %.2f%% (%d entries)",b/(b+c)*100,a)],null)},null),-1143507686)}return bH($APP.Yu,"emmy.polynomial.gcd",76,new $APP.bh(function(){return new $APP.H(null,1,5,$APP.I,[JG("GCD triv %d mono %d",$APP.Fb(Y_a),$APP.Fb(a0a))],null)},null),-190209174)},$APP.h,new $APP.f(null,2,[$APP.P,"When called, logs statistics about the GCD memoization cache, and the number of\n  times the system has encountered monomial or other trivial GCDs. ",
$APP.U,$APP.M($APP.sf)],null)],null),new $APP.f(null,3,[$APP.Q,b7b,$APP.X,h0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the greatest common divisor of all partial derivatives of the\n  polynomial `p` using binary applications of the [[gcd]] algorithm between each\n  partial derivative.\n\n  This algorithm assumes that all coefficients are integral, and halts when it\n  encounters a result that responds true to [[emmy.value/one?]].\n\n  If a non-[[p/Polynomial]] is supplied, returns 1.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Abc,$APP.X,g0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the least common multiple of (possibly polynomial) arguments `u` and\n  `v`, using [[gcd]] to calculate the gcd portion of\n\n  ```\n  (/ (g/abs (* u v))\n     (gcd u v))\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,bQb,$APP.X,!1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,A2b,$APP.X,W_a,$APP.h,new $APP.f(null,
2,[$APP.P,"Given some polynomial `p`, and a multi-arity `gcd` function for its\n  coefficients, returns a pair of the polynomial's content and primitive.\n\n  The 'content' of a polynomial is the greatest common divisor of its\n  coefficients. The 'primitive part' of a polynomial is the quotient of the\n  polynomial by its content.\n\n  See Wikipedia's ['Primitive Part and\n  Content'](https://en.wikipedia.org/wiki/Primitive_part_and_content) page for\n  more details. ",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Sv,kK],null))],null)],null),new $APP.f(null,3,[$APP.Q,rIb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,y9b,$APP.X,$_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given two polynomials `u` and `v`, attempts to return the greatest common\n  divisor of `u` and `v` by testing for trivial cases. If no trivial case\n  applies, returns `nil`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xob,$APP.X,hM,$APP.h,$APP.F],null)]),$APP.ap(w0b)),
$APP.cp($APP.fg([$APP.z(Tfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),$APP.P,"Given a metric and a basis, computes the inverse metric."],null)),$APP.z(Rob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))),$APP.P,"For making a (0,2) tensor into a (2,0) tensor."],null)),$APP.z(jX,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))],null)),$APP.z(nOb,new $APP.f(null,1,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,NRb],null)))],null)),OAb,$APP.z(HBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))),$APP.P,"Computes the trace of a (0,2) tensor."],null)),$APP.z(Utb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))],null)),$APP.z(hhb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,VU],null)))],null)),$APP.z(Xab,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[OX,VU],null))),$APP.P,"Computes the trace of a (2,0) tensor"],null)),Zvb,$APP.z(hQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mT],null)))],null)),$APP.z(a6a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),$APP.P,"To make a one-form field into a vector field, i.e., a (0,1) tensor into a (1,0)\n  tensor."],null)),$APP.z(Fdc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,qW],null))),
$APP.P,"Flat coordinate systems here only."],null)),$APP.z(znb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))),$APP.P,"For making a (2,0) tensor into a (0,2) tensor."],null)),$APP.z($5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[jW],null))),$APP.P,"To make a vector field into a one-form field, i.e., a (1,0) tensor into a (0,1)\n  tensor."],null)),Gtb,$APP.z(GGb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[jW,VU],null)))],null)),Sob,ynb,$APP.z(iec,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))],null)),$APP.z(Bjb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[jW,VU,$APP.Qr],null)))],null)),$APP.z(Sdc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,kBb],null)))],null))],[new $APP.f(null,3,[$APP.Q,Teb,$APP.X,Y5a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a metric and a basis, computes the inverse metric.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,ajb,$APP.X,c6a,$APP.h,new $APP.f(null,2,[$APP.P,"For making a (0,2) tensor into a (2,0) tensor.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,D_b,$APP.X,QP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,MZb,$APP.X,Z5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,
[MT,NRb],null))],null)],null),new $APP.f(null,3,[$APP.Q,dTb,$APP.X,RP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Z4b,$APP.X,d6a,$APP.h,new $APP.f(null,2,[$APP.P,"Computes the trace of a (0,2) tensor.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Bsb,$APP.X,T5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,fCb,$APP.X,W5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[XV,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Bhb,$APP.X,e6a,$APP.h,new $APP.f(null,2,[$APP.P,"Computes the trace of a (2,0) tensor",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,qZb,$APP.X,wrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,nGb,$APP.X,PP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[mT],null))],null)],null),new $APP.f(null,3,[$APP.Q,i8b,$APP.X,SP,$APP.h,new $APP.f(null,2,[$APP.P,"To make a one-form field into a vector field, i.e., a (0,1) tensor into a (1,0)\n  tensor.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,GIb,$APP.X,V5a,$APP.h,new $APP.f(null,2,[$APP.P,"Flat coordinate systems here only.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,c2b,$APP.X,b6a,$APP.h,new $APP.f(null,2,[$APP.P,"For making a (2,0) tensor into a (0,2) tensor.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,qdc,$APP.X,RP,$APP.h,new $APP.f(null,
2,[$APP.P,"To make a vector field into a one-form field, i.e., a (1,0) tensor into a (0,1)\n  tensor.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[jW],null))],null)],null),new $APP.f(null,3,[$APP.Q,rib,$APP.X,SP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,K2b,$APP.X,X5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,bjb,$APP.X,SP,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,d2b,$APP.X,RP,$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.Q,U$b,$APP.X,S5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,L9b,$APP.X,f6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[jW,VU,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,KSb,$APP.X,R5a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,kBb],null))],null)],null)]),$APP.ap(aDb)),$APP.cp(new $APP.f(null,2,[$APP.z(qEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,$APP.Ox],null))),$APP.P,"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\n\n  See [[brent-min]] for all supported `opts`."],null)),new $APP.f(null,3,[$APP.Q,q6b,$APP.X,N7a,$APP.h,new $APP.f(null,2,[$APP.P,"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\n\n  See [[brent-min]] for all supported `opts`.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,$APP.Ox],null))],null)],null),$APP.z(fDb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,6,5,$APP.I,[PT,RT,RY,KT,uX,$APP.Gw],null),$APP.Ml,new $APP.f(null,5,[PT,AV,RT,QY,RY,$APP.M(WT,$APP.Lv,$APP.sU),KT,1E3,$APP.Gw,$APP.M($APP.fw,null)],null)],null)],null))),$APP.P,"Find the minimum of the function f: R -\x3e R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id\x3dAITCAgAAQBAJ\x26q\x3dBrent%E2%80%99s#v\x3donepage\x26q\x3dParabolic\x26f\x3dfalse).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  [[brent-min]] supports the following optional keyword arguments:\n\n  - `:callback`: if supplied, the supplied fn will be invoked at each\n    intermediate point with the iteration count and the values of x and f(x) at\n    each search step.\n\n  - `:initial-guess`: the first internal point checked by the algorithm. Defaults\n    to `([[initial-brent-guess]] a b)`.\n\n  - `:relative-threshold`: multiplied by each guess to determine a relative\n    threshold. Defaults to 1.0e-11.\n\n  - `:absolute-threshold`: a smaller absolute threshold that applies when the\n    candidate minimum point is close to 0. defaults to around 1.49e8, the sqrt of\n    the machine tolerance. You won't gain any benefit attempting to set the value\n    less than the default.\n\n  - `:maxiter`: Maximum number of iterations allowed for the minimizer. Defaults\n    to 1000.\n\n  - `:maxfun`: Maximum number of times the function can be evaluated before\n    exiting. Defaults to `(inc maxiter)`.\n  ",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,6,5,$APP.I,[PT,RT,RY,KT,uX,$APP.Gw],null),$APP.Ml,new $APP.f(null,5,[PT,AV,RT,QY,RY,$APP.M(WT,$APP.Lv,$APP.sU),KT,1E3,$APP.Gw,$APP.M($APP.fw,null)],null)],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,
4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,6,5,$APP.I,[PT,RT,RY,KT,uX,$APP.Gw],null),$APP.Ml,new $APP.f(null,5,[PT,AV,RT,QY,RY,$APP.M(WT,$APP.Lv,$APP.sU),KT,1E3,$APP.Gw,$APP.M($APP.fw,null)],null)],null)],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Tjb,$APP.X,vQ,$APP.h,new $APP.f(null,2,[$APP.P,"Find the minimum of the function f: R -\x3e R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id\x3dAITCAgAAQBAJ\x26q\x3dBrent%E2%80%99s#v\x3donepage\x26q\x3dParabolic\x26f\x3dfalse).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  [[brent-min]] supports the following optional keyword arguments:\n\n  - `:callback`: if supplied, the supplied fn will be invoked at each\n    intermediate point with the iteration count and the values of x and f(x) at\n    each search step.\n\n  - `:initial-guess`: the first internal point checked by the algorithm. Defaults\n    to `([[initial-brent-guess]] a b)`.\n\n  - `:relative-threshold`: multiplied by each guess to determine a relative\n    threshold. Defaults to 1.0e-11.\n\n  - `:absolute-threshold`: a smaller absolute threshold that applies when the\n    candidate minimum point is close to 0. defaults to around 1.49e8, the sqrt of\n    the machine tolerance. You won't gain any benefit attempting to set the value\n    less than the default.\n\n  - `:maxiter`: Maximum number of iterations allowed for the minimizer. Defaults\n    to 1000.\n\n  - `:maxfun`: Maximum number of times the function can be evaluated before\n    exiting. Defaults to `(inc maxiter)`.\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,6,5,$APP.I,[PT,RT,RY,KT,uX,$APP.Gw],null),$APP.Ml,new $APP.f(null,5,[PT,AV,RT,QY,RY,$APP.M(WT,$APP.Lv,$APP.sU),KT,1E3,$APP.Gw,$APP.M($APP.fw,null)],null)],null)],null))],null)],null)],null),$APP.ap(vYb)),$APP.cp($APP.fg([$APP.z(Idc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))),$APP.P,
"Generates a lagrange interpolating polynomial that fits every point in the\n  supplied sequence `points` (of form `[x (f x)]`) and returns the value of the\n  polynomial evaluated at `x`.\n\n  The Lagrange polynomial has this form:\n\n  ```\n  g(x) \x3d  (f(a) * [(x-b)(x-c)...] / [(a-b)(a-c)...])\n        + (f(b) * [(x-a)(x-c)...] / [(b-a)(b-c)...])\n        + ...\n  ```\n\n  for points `[a f(a)], [b f(b)], [c f(c)]` etc.\n\n  This particular method of interpolating `x` into the polynomial is\n  inefficient; any new calculation requires fully recomputing. Takes `O(n^2)`\n  operations in the number of points.\n  "],
null)),$APP.z(a_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described in [[neville]].\n\n  Faster than, but equivalent to, `(last ([[neville]] xs x))`"],null)),$APP.z(h1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[modified-neville]].\n\n  Equivalent to `([[modified-neville]] xs x)`."],null)),$APP.z(I8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),
$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[neville]].\n\n  Equivalent to `([[neville]] xs x)`."],null)),$APP.z(o6b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-neville]]."],
null)),$APP.z(ckb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described\n  in [[modified-neville]].\n\n  Faster than, but equivalent to, `(last ([[modified-neville]] xs x))`"],null)),$APP.z(VYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))),$APP.P,"Top-down implementation of [Neville's\n  algorithm]((https://en.wikipedia.org/wiki/Neville%27s_algorithm))\n\n  Returns the value of `P(x)`, where `P` is a polynomial fit (using Neville's\n  algorithm) to every point in the supplied sequence `points` (of form `[x (f\n  x)]`)\n\n  The efficiency and results should be identical to\n  [[emmy.numerical.interpolate/lagrange]]. This function represents a step\n  on the journey toward more incremental methods of polynomial interpolation.\n\n  References:\n\n  - Press's Numerical Recipes (p103), [chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)"],
null)),$APP.z(yBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))),$APP.P,"Similar to [[neville]] (the interface is identical) but slightly more efficient.\n  Internally this builds up its estimates by tracking the delta from the\n  previous estimate.\n\n  This non-obvious change lets us swap an addition in for a multiplication,\n  making the algorithm slightly more efficient.\n\n  See [[neville]] for usage information, and info about the required structure\n  of the arguments.\n\n  The structure of the [[modified-neville]] algorithm makes it difficult to\n  select a particular column. See [[neville]] if you'd like to generate\n  polynomial approximations between successive sequences of points.\n\n  References:\n\n  - [\"A comparison of algorithms for polynomial interpolation\"](https://www.sciencedirect.com/science/article/pii/0771050X82900511), A. Macleod\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)"],
null)),$APP.z(ENb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tBb,$APP.nu,$APP.JT],null))),$APP.P,"Given `prepare` and `merge` and `present` functions, returns a fold capable of\n  aggregating a point of the form [x, f(x)] into an accumulating tableau\n  row (generating the next tableau row).\n\n  The 0-arity of the returned function returns an empty row, `[]`.\n\n  The 1-arity calls the supplied `present` on the accumulated tableau row.\n\n  The 2-arity scans the supplied `merge` across all entries in the accumulating\n  row, producing a new row.\n\n  ### More detail on the arguments:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  l -- return\n     /\n    /\n   /\n  r\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `present`: Transforms a `tableau` row into an estimate at some value `x` of\n  the polynomial interpolated to hit all supplied points."],
null)),$APP.z(nNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))),$APP.P,"Takes a potentially lazy sequence of `points` and a point `x` and generates a\n  lazy sequence of approximations of P(x).\n\n  entry N in the returned sequence is the estimate using a polynomial generated\n  from the first N points of the input sequence."],null)),$APP.z(LMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tBb,$APP.nu,$APP.uS],null))),
$APP.P,"Returns a Newton-style approximation tableau, given:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  ```\n  l -- return\n     /\n    /\n   /\n  r\n  ```\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `points`: the (potentially lazy) sequence of points used to generate the\n  first column of the tableau.\n  "],
null)),$APP.z($1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n    and returns the next row of the tableau using the algorithm described in\n  [[neville]]."],
null)),$APP.z(IOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.uS,$APP.Yv,$APP.nv],null))),$APP.P,"Takes:\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  Said another way: the Nth in the returned sequence is the estimate using a\n  polynomial generated from the first `N` points of the input sequence:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  ```\n\n  This function generates each estimate using Neville's algorithm:\n\n  ```\n  $$P(x) \x3d [(x - x_r) P_l(x) - (x - x_l) P_r(x)] / [x_l - x_r]$$\n  ```\n\n  ### Column\n\n  If you supply an integer for the third `column` argument, `neville` will\n  return that _column_ of the interpolation tableau instead of the first row.\n  This will give you a sequence of nth-order polynomial approximations taken\n  between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n   p0 p01 p012 p0123 p01234\n   p1 p12 p123 p1234 .\n   p2 p23 p234 .     .\n   p3 p34 .    .     .\n   p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of linear approximations\n  between pairs of points; `2` gives quadratic approximations between successive\n  triplets, etc.\n\n  References:\n\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.uS,$APP.Yv,$APP.nv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.uS,$APP.Yv,$APP.nv],null)),$APP.Cx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.Q,zVb,$APP.X,cXa,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a lagrange interpolating polynomial that fits every point in the\n  supplied sequence `points` (of form `[x (f x)]`) and returns the value of the\n  polynomial evaluated at `x`.\n\n  The Lagrange polynomial has this form:\n\n  ```\n  g(x) \x3d  (f(a) * [(x-b)(x-c)...] / [(a-b)(a-c)...])\n        + (f(b) * [(x-a)(x-c)...] / [(b-a)(b-c)...])\n        + ...\n  ```\n\n  for points `[a f(a)], [b f(b)], [c f(c)]` etc.\n\n  This particular method of interpolating `x` into the polynomial is\n  inefficient; any new calculation requires fully recomputing. Takes `O(n^2)`\n  operations in the number of points.\n  ",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Gub,$APP.X,function(a){return G_.j(kXa(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described in [[neville]].\n\n  Faster than, but equivalent to, `(last ([[neville]] xs x))`",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,aFb,$APP.X,nXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[modified-neville]].\n\n  Equivalent to `([[modified-neville]] xs x)`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Z3b,$APP.X,function(a){return GI.j(kXa(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[neville]].\n\n  Equivalent to `([[neville]] xs x)`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,phb,$APP.X,mXa,$APP.h,new $APP.f(null,2,[$APP.P,"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-neville]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Rib,$APP.X,function(a){return G_.j(mXa(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described\n  in [[modified-neville]].\n\n  Faster than, but equivalent to, `(last ([[modified-neville]] xs x))`",$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Cxb,$APP.X,function(a,b){return function g(d){if($APP.Uc.A(1,$APP.Tc(d))){var l=$APP.x.B(d,0,null);$APP.x.B(l,0,null);return $APP.x.B(l,1,null)}l=$APP.gd(d);var n=$APP.pi.A(d,1),p=$APP.u(d);p=$APP.x.B(p,0,null);d=$APP.fd(d);d=$APP.x.B(d,0,null);return SF.A(mG.A(kG.A(TF.A(b,d),g(l)),kG.A(TF.A(p,b),g(n))),TF.A(p,d))}($APP.tf(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Top-down implementation of [Neville's\n  algorithm]((https://en.wikipedia.org/wiki/Neville%27s_algorithm))\n\n  Returns the value of `P(x)`, where `P` is a polynomial fit (using Neville's\n  algorithm) to every point in the supplied sequence `points` (of form `[x (f\n  x)]`)\n\n  The efficiency and results should be identical to\n  [[emmy.numerical.interpolate/lagrange]]. This function represents a step\n  on the journey toward more incremental methods of polynomial interpolation.\n\n  References:\n\n  - Press's Numerical Recipes (p103), [chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Qob,$APP.X,function(a,b){return jXa(BI(CI(hXa,iXa(b),a)))},$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[neville]] (the interface is identical) but slightly more efficient.\n  Internally this builds up its estimates by tracking the delta from the\n  previous estimate.\n\n  This non-obvious change lets us swap an addition in for a multiplication,\n  making the algorithm slightly more efficient.\n\n  See [[neville]] for usage information, and info about the required structure\n  of the arguments.\n\n  The structure of the [[modified-neville]] algorithm makes it difficult to\n  select a particular column. See [[neville]] if you'd like to generate\n  polynomial approximations between successive sequences of points.\n\n  References:\n\n  - [\"A comparison of algorithms for polynomial interpolation\"](https://www.sciencedirect.com/science/article/pii/0771050X82900511), A. Macleod\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,BVb,$APP.X,EI,$APP.h,new $APP.f(null,2,[$APP.P,"Given `prepare` and `merge` and `present` functions, returns a fold capable of\n  aggregating a point of the form [x, f(x)] into an accumulating tableau\n  row (generating the next tableau row).\n\n  The 0-arity of the returned function returns an empty row, `[]`.\n\n  The 1-arity calls the supplied `present` on the accumulated tableau row.\n\n  The 2-arity scans the supplied `merge` across all entries in the accumulating\n  row, producing a new row.\n\n  ### More detail on the arguments:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  l -- return\n     /\n    /\n   /\n  r\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `present`: Transforms a `tableau` row into an estimate at some value `x` of\n  the polynomial interpolated to hit all supplied points.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[tBb,$APP.nu,$APP.JT],null))],null)],null),new $APP.f(null,3,[$APP.Q,ycb,$APP.X,function(a,b){return $APP.Vg.A($APP.fd,BI($APP.Hg.A($APP.r,$APP.af(fXa(b),$APP.Vg.A(dXa,a)))))},$APP.h,new $APP.f(null,2,[$APP.P,"Takes a potentially lazy sequence of `points` and a point `x` and generates a\n  lazy sequence of approximations of P(x).\n\n  entry N in the returned sequence is the estimate using a polynomial generated\n  from the first N points of the input sequence.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,aGb,$APP.X,CI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a Newton-style approximation tableau, given:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  ```\n  l -- return\n     /\n    /\n   /\n  r\n  ```\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `points`: the (potentially lazy) sequence of points used to generate the\n  first column of the tableau.\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[tBb,$APP.nu,$APP.uS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mdc,$APP.X,kXa,$APP.h,new $APP.f(null,2,[$APP.P,"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n    and returns the next row of the tableau using the algorithm described in\n  [[neville]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,hwb,$APP.X,Y0,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  Said another way: the Nth in the returned sequence is the estimate using a\n  polynomial generated from the first `N` points of the input sequence:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  ```\n\n  This function generates each estimate using Neville's algorithm:\n\n  ```\n  $$P(x) \x3d [(x - x_r) P_l(x) - (x - x_l) P_r(x)] / [x_l - x_r]$$\n  ```\n\n  ### Column\n\n  If you supply an integer for the third `column` argument, `neville` will\n  return that _column_ of the interpolation tableau instead of the first row.\n  This will give you a sequence of nth-order polynomial approximations taken\n  between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n   p0 p01 p012 p0123 p01234\n   p1 p12 p123 p1234 .\n   p2 p23 p234 .     .\n   p3 p34 .    .     .\n   p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of linear approximations\n  between pairs of points; `2` gives quadratic approximations between successive\n  triplets, etc.\n\n  References:\n\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.uS,$APP.Yv,$APP.nv],null))],null)],null)]),$APP.ap(ntb)),$APP.cp(new $APP.f(null,6,[$APP.z(Gyb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null))),$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  forward-difference estimate of the the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x + h) - f(x)] / h\n  ```\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,oub,$APP.X,FR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  forward-difference estimate of the the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x + h) - f(x)] / h\n  ```\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null))],null)],null),$APP.z($Rb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null))),$APP.P,"Takes a function `f: R \x3d\x3e R` (function of a single real variable), and returns\n  a new function of `x` that approximates the derivative $Df(x)$ (or $D^2f(x)$\n  if you pass `:method :central-d2`).\n\n  Returns the estimated value of the derivative at `x`. If you pass `:info?\n  true`, the fn returns a dictionary of the results of `us/seq-limit`:\n\n  ```clojure\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3cderivative estimate\x3e}\n  ```\n\n  Make sure to visit [[emmy.calculus.derivative/D]] if you want symbolic or\n  automatic differentiation.\n\n  ### Roundoff Estimate\n\n  The returned function will attempt to estimate how many times it can halve the\n  step size used to estimate the derivative before roundoff error swamps the\n  calculation, and force the function to return (with `:converged? false`, if\n  you pass `:info?`)\n\n  ### Optional Arguments\n\n  `D-numeric` takes optional args as its second param. Any of these can be\n  overridden by passing a second argument to the function returned by\n  `D-numeric`; helpful for setting defaults and then overriding them later.\n\n  The returned function passes through these and any other options to\n  `us/seq-limit`, where they control the sequence of richardson\n  extrapolation-accelerated estimates.\n\n  Options:\n\n  - `:method`: one of `:central`, `:central-d2`, `:forward` or `:backward`.\n  `:central-d2` forces a second derivative estimate; the other methods configure\n  a first derivative estimator.\n\n  - `:info?` if false (default), returns the estimated value of `x`. If true,\n  returns a dictionary with more information (see `D-numeric`'s docstring for\n  more info.)\n\n  - `:initial-h`: the initial `h` to use for derivative estimates before $h \to\n  0$. Defaults to `0.1 * abs(x)`.\n\n  - `:tolerance`: see `us/stream-limit` for a discussion of how this value\n  handles relative vs absolute tolerance. $\\sqrt(\\epsilon)$ by default, where\n  $\\epsilon$ \x3d machine tolerance.\n\n  - `:maxterms`: the maximum number of terms to consider when hunting for a\n  derivative estimate. This defaults to an estimate generated internally,\n  designed to prevent roundoff error from swamping the result. If you want to\n  disable this feature, set `:maxterms` to something moderately large, like\n  `:maxterms 100`. But do so carefully! See the surrounding namespace for a\n  larger discussion.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,tvb,$APP.X,I4,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function `f: R \x3d\x3e R` (function of a single real variable), and returns\n  a new function of `x` that approximates the derivative $Df(x)$ (or $D^2f(x)$\n  if you pass `:method :central-d2`).\n\n  Returns the estimated value of the derivative at `x`. If you pass `:info?\n  true`, the fn returns a dictionary of the results of `us/seq-limit`:\n\n  ```clojure\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3cderivative estimate\x3e}\n  ```\n\n  Make sure to visit [[emmy.calculus.derivative/D]] if you want symbolic or\n  automatic differentiation.\n\n  ### Roundoff Estimate\n\n  The returned function will attempt to estimate how many times it can halve the\n  step size used to estimate the derivative before roundoff error swamps the\n  calculation, and force the function to return (with `:converged? false`, if\n  you pass `:info?`)\n\n  ### Optional Arguments\n\n  `D-numeric` takes optional args as its second param. Any of these can be\n  overridden by passing a second argument to the function returned by\n  `D-numeric`; helpful for setting defaults and then overriding them later.\n\n  The returned function passes through these and any other options to\n  `us/seq-limit`, where they control the sequence of richardson\n  extrapolation-accelerated estimates.\n\n  Options:\n\n  - `:method`: one of `:central`, `:central-d2`, `:forward` or `:backward`.\n  `:central-d2` forces a second derivative estimate; the other methods configure\n  a first derivative estimator.\n\n  - `:info?` if false (default), returns the estimated value of `x`. If true,\n  returns a dictionary with more information (see `D-numeric`'s docstring for\n  more info.)\n\n  - `:initial-h`: the initial `h` to use for derivative estimates before $h \to\n  0$. Defaults to `0.1 * abs(x)`.\n\n  - `:tolerance`: see `us/stream-limit` for a discussion of how this value\n  handles relative vs absolute tolerance. $\\sqrt(\\epsilon)$ by default, where\n  $\\epsilon$ \x3d machine tolerance.\n\n  - `:maxterms`: the maximum number of terms to consider when hunting for a\n  derivative estimate. This defaults to an estimate generated internally,\n  designed to prevent roundoff error from swamping the result. If you want to\n  disable this feature, set `:maxterms` to something moderately large, like\n  `:maxterms 100`. But do so carefully! See the surrounding namespace for a\n  larger discussion.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null))],null)],null),$APP.z(N8b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null))),$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  central-difference estimate of the second derivative of `f` at point `x`:\n\n  f''(x) \x3d [f(x + h) - 2f(x) + f(x - h)] / h^2\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,j3b,$APP.X,IR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  central-difference estimate of the second derivative of `f` at point `x`:\n\n  f''(x) \x3d [f(x + h) - 2f(x) + f(x - h)] / h^2\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null))],null)],null),$APP.z(Amb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null))),$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  central-difference estimate of the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x + h) - f(x - h)] / 2h\n  ```"],null)),new $APP.f(null,3,[$APP.Q,$Cb,$APP.X,
K$a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  central-difference estimate of the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x + h) - f(x - h)] / 2h\n  ```",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null))],null)],null),$APP.z(sKb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null))),$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  backward-difference estimate of the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x) - f(x - h)] / h\n  ```\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Jkb,$APP.X,HR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a single-variable function of a step size `h` that calculates the\n  backward-difference estimate of the first derivative of `f` at point `x`:\n\n  ```\n  f'(x) \x3d [f(x) - f(x - h)] / h\n  ```\n\n  Optionally accepts a third argument `fx \x3d\x3d (f x)`, in case you've already\n  calculated it elsewhere and would like to save a function evaluation.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Yv,eX],null))],null)],null),tdb,new $APP.f(null,3,[$APP.Q,wBb,$APP.X,L$a,$APP.h,$APP.F],null)],null),$APP.ap(J2b)),$APP.cp($APP.fg([$APP.z(tEb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,ST],null))),$APP.P,"Accepts:\n\n  - some function `f` of potentially many arguments\n  - optionally, a sequence of selectors meant to index into the structural\n    argument, or argument vector, of `f`\n\n  And returns a new function that computes either the\n  full [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  or the entry at `selectors` using [reverse-mode automatic\n  differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation#Reverse_accumulation).\n\n  Any multivariable function will have its argument vector coerced into an `up`\n  structure. Any [[emmy.matrix/Matrix]] in a multiple-arg function call will be\n  converted into a `down` of `up`s (a row of columns).\n\n  Arguments to single-variable functions are not transformed.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,ST],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,ST],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(o0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))],null)),$APP.z(txb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null))),$APP.P,"Similar to [[taylor-series]], except `f` is evaluated with symbolic arguments,\n  and these arguments are only replaced with the values `xs` after Taylor series\n  expansion.\n\n  Please see the docs for [[taylor-series]]!",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(J9b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))),$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses forward-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,
$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(ST)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(LKb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null)))],null)),$APP.z(gKb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))),$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses reverse-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(ST)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z($APP.Vw,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null)))],null)),$APP.z(eW,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(aRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))],null)),$APP.z(eH,new $APP.f(null,
1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))],null)),$APP.z(QCb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null))),$APP.P,"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[emmy.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, i.e., the Taylor series expansion at `(\x3d x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[emmy.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[emmy.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.Q,v2b,$APP.X,t3,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts:\n\n  - some function `f` of potentially many arguments\n  - optionally, a sequence of selectors meant to index into the structural\n    argument, or argument vector, of `f`\n\n  And returns a new function that computes either the\n  full [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  or the entry at `selectors` using [reverse-mode automatic\n  differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation#Reverse_accumulation).\n\n  Any multivariable function will have its argument vector coerced into an `up`\n  structure. Any [[emmy.matrix/Matrix]] in a multiple-arg function call will be\n  converted into a `down` of `up`s (a row of columns).\n\n  Arguments to single-variable functions are not transformed.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,ST],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wxb,$APP.X,vrc,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,nbb,$APP.X,C3,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[taylor-series]], except `f` is evaluated with symbolic arguments,\n  and these arguments are only replaced with the values `xs` after Taylor series\n  expansion.\n\n  Please see the docs for [[taylor-series]]!",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,IRb,$APP.X,A3,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses forward-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))],null)],
null),new $APP.f(null,3,[$APP.Q,GKb,$APP.X,Q3a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Isb,$APP.X,SQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses reverse-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))],
null)],null),new $APP.f(null,3,[$APP.Q,dwb,$APP.X,SQ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))],null)],null),new $APP.f(null,3,[$APP.Q,ukb,$APP.X,u3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,R7b,$APP.X,UO,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,uwb,$APP.X,UO,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,
3,[$APP.Q,NUb,$APP.X,B3,$APP.h,new $APP.f(null,2,[$APP.P,"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[emmy.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, i.e., the Taylor series expansion at `(\x3d x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[emmy.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[emmy.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null))],null)],null)]),$APP.ap(TUb)),$APP.cp(new $APP.f(null,6,[$APP.z(lob,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,4,[mU,"null",YE,"null",NY,"null",iV,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Rv,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,2,[mU,"null",iV,"null"],null),null),$APP.P,"Positional factory function for emmy.modint/ModInt."],
null)),new $APP.f(null,3,[$APP.Q,c9b,$APP.X,GWa,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.modint/ModInt.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Rv,$APP.Qr],null))],null)],null),$APP.z(mzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),new $APP.f(null,3,[$APP.Q,jdb,$APP.X,function(a){return a.i},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),$APP.z(xMb,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oX],null))),$APP.P,"[Chinese Remainder Algorithm](https://en.wikipedia.org/wiki/Chinese_remainder_theorem).\n\n  Accepts a sequence of [[ModInt]] instances (where the `modulus` of\n  all [[ModInt]] instances are relatively prime), and returns a [[ModInt]] `x`\n  such that `(residue input) \x3d\x3d (mod x (modulus input))`.\n\n  For example:\n\n  ```clojure\n  (let [a1 (m/make 2 5)\n        a2 (m/make 3 13)]\n    [(\x3d 42 (chinese-remainder a1 a2))\n     (\x3d (residue a1) (mod cr (modulus a1)))\n     (\x3d (residue a2) (mod cr (modulus a2)))])\n  ;;\x3d\x3e [true true true]\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(oX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oX],null)),$APP.Cx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.Q,pbb,$APP.X,z0,$APP.h,new $APP.f(null,2,[$APP.P,"[Chinese Remainder Algorithm](https://en.wikipedia.org/wiki/Chinese_remainder_theorem).\n\n  Accepts a sequence of [[ModInt]] instances (where the `modulus` of\n  all [[ModInt]] instances are relatively prime), and returns a [[ModInt]] `x`\n  such that `(residue input) \x3d\x3d (mod x (modulus input))`.\n\n  For example:\n\n  ```clojure\n  (let [a1 (m/make 2 5)\n        a2 (m/make 3 13)]\n    [(\x3d 42 (chinese-remainder a1 a2))\n     (\x3d (residue a1) (mod cr (modulus a1)))\n     (\x3d (residue a2) (mod cr (modulus a2)))])\n  ;;\x3d\x3e [true true true]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oX],null))],null)],null),$APP.z(iU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Rv,$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dRb,$APP.Rv),$APP.M(dRb,$APP.Qr)],null)],null)))),$APP.P,"Returns an instance of [[ModInt]] that represents integer `i` with integral\n  modulus `m`."],null)),new $APP.f(null,3,[$APP.Q,bYb,$APP.X,pI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an instance of [[ModInt]] that represents integer `i` with integral\n  modulus `m`.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Rv,$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dRb,$APP.Rv),$APP.M(dRb,$APP.Qr)],null)],null)))],null)],null),$APP.z(mWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is an instance of [[ModInt]], false otherwise."],null)),new $APP.f(null,3,[$APP.Q,s$b,$APP.X,HWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is an instance of [[ModInt]], false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),$APP.z(EIb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),new $APP.f(null,3,[$APP.Q,Mkb,$APP.X,IWa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null)],null),$APP.ap(g3b)),$APP.cp($APP.fg([$APP.z(wtb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  that will take a symbolic expression, and return a simplified expression with\n  any subexpression NOT supported by the analyzer backend replaced by a\n  generated symbol.\n\n  Any replaced subexpression will map to the SAME symbol over repeated\n  invocations, unless you call the resetting function generated by passing\n  `analyzer` to [[initializer]].\n\n  For example:\n\n  ```clojure\n  (let [a  (poly-analyzer)\n        ea (expression-analyzer a)]\n    (ea '(+ x x x (sin x) (sin x))))\n  ;;\x3d\x3e (+ (* 3 x) (* 2 -s-0000000000000000))\n  ```"],
null)),$APP.z(uV,new $APP.f(null,3,[$APP.Pm,ZX,$APP.P,"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression-\x3e]], so these functions are complementary.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[YS,$APP.sU,lRb],null)))],null)),$APP.z(tfb,new $APP.f(null,3,[$APP.Pm,ZX,$APP.P,"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[YS,$APP.Yv],null)))],null)),$APP.z(JOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression \x3d\x3e simplified S-expression) that will\n  reset its internal symbolic bindings at every invocation.\n\n  Equivalent to:\n\n  ```clojure\n  (let [new-analysis! (initializer analyzer)\n        simplify (expression-simplifier analyzer)]\n    (fn [expr]\n      (new-analysis!)\n      (simplify expr)))\n  ```\n\n  See [[expression-simplifier]] for a version that will assign the same symbol\n  to every expression it sees more than once."],
null)),$APP.z(oeb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression \x3d\x3e simplified S-expression) that will\n  NOT reset its internal symbolic bindings across invocations.\n\n  This can be useful if the analyzer backend has any sort of memoization or\n  caching of expressions.\n\n  Pass `analyzer` to [[initializer]] to create a function that, when called,\n  will explicitly reset the internal cache:\n\n  ```clojure\n  (def reset-analyzer! (initializer analyzer))\n  (def simplify (expression-simplifier analyzer))\n\n  (reset-analyzer!)\n  (simplify \x3cexpr\x3e)\n  ```\n\n  See [[default-simplifier]] for a version that will reset its internal variable\n  assignment cache at each invocation."],
null)),$APP.z(PKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will return the analyzer's current map of\n  generated symbol \x3d\x3e subexpression.\n\n  Call the no-argument function returned by passing `analyzer`\n  to [[initializer]] to reset the table.\n\n  For example:\n\n  ```clojure\n  (def a (poly-analyzer))\n  (def ea (expression-analyzer a))\n\n  (def get-tables (auxiliary-variable-fetcher a))\n  (def reset-tables! (initializer a))\n\n  (ea '(+ x x x (sin x) (sin x)))\n  ;;\x3d\x3e (+ (* 3 x) (* 2 -s-0000000000000000))\n\n  (get-tables)\n  ;;\x3d\x3e {'-s-0000000000000000 '(sin x)}\n\n  (reset-tables!)\n  (get-tables)\n  ;;\x3d\x3e {}\n  ```"],
null)),$APP.z(PFb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.yY],null),new $APP.H(null,2,5,$APP.I,[$APP.yY,$APP.sx],null))),$APP.P,'Called with no arguments, produces a function mapping a string prefix\n   to a generated symbol with a four-digit suffix which increments\n   with each call, providing a stream of unique symbols. If the returned\n   function is called without arguments, a default prefix of "_" is\n   used (but see below).\n\n   May be called with one integer argument to set the size of the\n   suffix field in digits.\n\n   Supplying yet one more string argument changes the default prefix.\n   ```\n   (def g (monotonic-symbol-generator))\n   (take 5 (repeatedly #(g "a")))\n   (take 5 (repeatedly g))\n   ;; (a0000 a0001 a0002 a0003 a0004)\n   ;; (_0005 _0006 _0007 _0008 _0009)\n\n\n   (def h (monotonic-symbol-generator 2))\n   (take 5 (repeatedly #(h "b")))\n   (take 5 (repeatedly h))\n   ;; (b00 b01 b02 b03 b04)\n   ;; (_05 _06 _07 _08 _09)\n\n   (def j (monotonic-symbol-generator 3 "x"))\n   (take 5 (repeatedly #(j "a")))\n   (take 5 (repeatedly j))\n   ;; (a000 a001 a002 a003 a004)\n   ;; (x005 x006 x007 x008 x009)\n   ```\n   ',
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.yY],null),new $APP.H(null,2,5,$APP.I,[$APP.yY,$APP.sx],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.yY],null),new $APP.H(null,2,5,$APP.I,[$APP.yY,$APP.sx],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z($8b,new $APP.f(null,5,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,new $APP.f(null,3,[$APP.z(KX,new $APP.f(null,1,[$APP.P,"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]]."],
null)),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[YS,$APP.Yv,HT],null),new $APP.H(null,4,5,$APP.I,[YS,$APP.Yv,HT,kT],null)],null),$APP.z(uV,new $APP.f(null,1,[$APP.P,"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression-\x3e]], so these functions are complementary."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,
3,5,$APP.I,[YS,$APP.sU,lRb],null)],null),$APP.z(tfb,new $APP.f(null,1,[$APP.P,"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[YS,$APP.Yv],null)],null)],null)],null),$APP.Ov,new $APP.f(null,3,[r6b,new $APP.f(null,3,[$APP.Q,KX,$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[YS,$APP.Yv,HT],null),new $APP.H(null,4,5,$APP.I,[YS,$APP.Yv,HT,kT],null)),$APP.P,"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]]."],
null),xWb,new $APP.f(null,3,[$APP.Q,uV,$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[YS,$APP.sU,lRb],null)),$APP.P,"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression-\x3e]], so these functions are complementary."],null),xhb,new $APP.f(null,3,[$APP.Q,tfb,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[YS,$APP.Yv],null)),$APP.P,
"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise."],null)],null),$APP.P,"[[ICanonicalize]] captures the methods exposed by a Emmy analyzer backend.",gU,$APP.M("@interface")],null)),$APP.z(xBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))),$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will reset the analyzer's internal caches\n  of symbol \x3d\x3e subexpression and subexpression \x3d\x3e symbol."],
null)),$APP.z(KX,new $APP.f(null,4,[$APP.Pm,ZX,$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[YS,$APP.Yv,HT],null),new $APP.H(null,4,5,$APP.I,[YS,$APP.Yv,HT,kT],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[YS,$APP.Yv,HT],null),new $APP.H(null,4,5,$APP.I,[YS,$APP.Yv,HT,kT],null)),$APP.Cx,$APP.M(null,null)],null),$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[YS,$APP.Yv,HT],null),new $APP.H(null,4,5,$APP.I,
[YS,$APP.Yv,HT,kT],null))),$APP.P,"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]]."],null)),$APP.z(Prb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(lYb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[sV],null),new $APP.H(null,2,5,$APP.I,[sV,C4b],null))),
$APP.P,"Make-analyzer takes an analyzer `backend` (which implements [[ICanonicalize]])\n  and returns a dictionary with the apparatus necessary to prepare expressions\n  for analysis by replacing subexpressions formed from operations unknown to the\n  analyzer with generated symbols, and backsubstituting after analysis is\n  complete.\n\n  For example, in the case of polynomial canonical form, we would replace a\n  subexpression like `(sin x)` with a gensym, before entry, since the `sin`\n  operation is not available to the polynomial canonicalizer, and restore it\n  afterwards.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[sV],null),new $APP.H(null,2,5,$APP.I,[sV,C4b],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[sV],null),new $APP.H(null,2,5,$APP.I,[sV,C4b],null)),$APP.Cx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.Q,NIb,$APP.X,function(a){return yUb.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  that will take a symbolic expression, and return a simplified expression with\n  any subexpression NOT supported by the analyzer backend replaced by a\n  generated symbol.\n\n  Any replaced subexpression will map to the SAME symbol over repeated\n  invocations, unless you call the resetting function generated by passing\n  `analyzer` to [[initializer]].\n\n  For example:\n\n  ```clojure\n  (let [a  (poly-analyzer)\n        ea (expression-analyzer a)]\n    (ea '(+ x x x (sin x) (sin x))))\n  ;;\x3d\x3e (+ (* 3 x) (* 2 -s-0000000000000000))\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Z0b,$APP.X,iWa,$APP.h,new $APP.f(null,2,[$APP.P,"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression-\x3e]], so these functions are complementary.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[YS,$APP.sU,lRb],null))],null)],null),
new $APP.f(null,3,[$APP.Q,Cbc,$APP.X,jWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[YS,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Qpb,$APP.X,lWa,$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression \x3d\x3e simplified S-expression) that will\n  reset its internal symbolic bindings at every invocation.\n\n  Equivalent to:\n\n  ```clojure\n  (let [new-analysis! (initializer analyzer)\n        simplify (expression-simplifier analyzer)]\n    (fn [expr]\n      (new-analysis!)\n      (simplify expr)))\n  ```\n\n  See [[expression-simplifier]] for a version that will assign the same symbol\n  to every expression it sees more than once.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))],null)],null),new $APP.f(null,3,[$APP.Q,AIb,$APP.X,GH,$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression \x3d\x3e simplified S-expression) that will\n  NOT reset its internal symbolic bindings across invocations.\n\n  This can be useful if the analyzer backend has any sort of memoization or\n  caching of expressions.\n\n  Pass `analyzer` to [[initializer]] to create a function that, when called,\n  will explicitly reset the internal cache:\n\n  ```clojure\n  (def reset-analyzer! (initializer analyzer))\n  (def simplify (expression-simplifier analyzer))\n\n  (reset-analyzer!)\n  (simplify \x3cexpr\x3e)\n  ```\n\n  See [[default-simplifier]] for a version that will reset its internal variable\n  assignment cache at each invocation.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Nkb,$APP.X,function(a){return CMb.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will return the analyzer's current map of\n  generated symbol \x3d\x3e subexpression.\n\n  Call the no-argument function returned by passing `analyzer`\n  to [[initializer]] to reset the table.\n\n  For example:\n\n  ```clojure\n  (def a (poly-analyzer))\n  (def ea (expression-analyzer a))\n\n  (def get-tables (auxiliary-variable-fetcher a))\n  (def reset-tables! (initializer a))\n\n  (ea '(+ x x x (sin x) (sin x)))\n  ;;\x3d\x3e (+ (* 3 x) (* 2 -s-0000000000000000))\n\n  (get-tables)\n  ;;\x3d\x3e {'-s-0000000000000000 '(sin x)}\n\n  (reset-tables!)\n  (get-tables)\n  ;;\x3d\x3e {}\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Olb,$APP.X,FM,$APP.h,new $APP.f(null,2,[$APP.P,'Called with no arguments, produces a function mapping a string prefix\n   to a generated symbol with a four-digit suffix which increments\n   with each call, providing a stream of unique symbols. If the returned\n   function is called without arguments, a default prefix of "_" is\n   used (but see below).\n\n   May be called with one integer argument to set the size of the\n   suffix field in digits.\n\n   Supplying yet one more string argument changes the default prefix.\n   ```\n   (def g (monotonic-symbol-generator))\n   (take 5 (repeatedly #(g "a")))\n   (take 5 (repeatedly g))\n   ;; (a0000 a0001 a0002 a0003 a0004)\n   ;; (_0005 _0006 _0007 _0008 _0009)\n\n\n   (def h (monotonic-symbol-generator 2))\n   (take 5 (repeatedly #(h "b")))\n   (take 5 (repeatedly h))\n   ;; (b00 b01 b02 b03 b04)\n   ;; (_05 _06 _07 _08 _09)\n\n   (def j (monotonic-symbol-generator 3 "x"))\n   (take 5 (repeatedly #(j "a")))\n   (take 5 (repeatedly j))\n   ;; (a000 a001 a002 a003 a004)\n   ;; (x005 x006 x007 x008 x009)\n   ```\n   ',
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.yY],null),new $APP.H(null,2,5,$APP.I,[$APP.yY,$APP.sx],null))],null)],null),new $APP.f(null,3,[$APP.Q,ZX,$APP.X,function(){},$APP.h,new $APP.f(null,1,[$APP.P,"[[ICanonicalize]] captures the methods exposed by a Emmy analyzer backend."],null)],null),new $APP.f(null,3,[$APP.Q,Cnb,$APP.X,function(a){return QHb.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will reset the analyzer's internal caches\n  of symbol \x3d\x3e subexpression and subexpression \x3d\x3e symbol.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[YS],null))],null)],null),new $APP.f(null,3,[$APP.Q,nub,$APP.X,Y_,$APP.h,new $APP.f(null,2,[$APP.P,"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]].",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[YS,$APP.Yv,HT],null),new $APP.H(null,4,5,$APP.I,
[YS,$APP.Yv,HT,kT],null))],null)],null),new $APP.f(null,3,[$APP.Q,wUb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Bcc,$APP.X,GM,$APP.h,new $APP.f(null,2,[$APP.P,"Make-analyzer takes an analyzer `backend` (which implements [[ICanonicalize]])\n  and returns a dictionary with the apparatus necessary to prepare expressions\n  for analysis by replacing subexpressions formed from operations unknown to the\n  analyzer with generated symbols, and backsubstituting after analysis is\n  complete.\n\n  For example, in the case of polynomial canonical form, we would replace a\n  subexpression like `(sin x)` with a gensym, before entry, since the `sin`\n  operation is not available to the polynomial canonicalizer, and restore it\n  afterwards.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[sV],null),new $APP.H(null,2,5,$APP.I,[sV,C4b],null))],null)],null)]),$APP.ap(qqb)),$APP.cp($APP.fg([$APP.z(kDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UHb],null))),$APP.P,"Find the most relaxed possible statement of the joint arity of the given sequence of `arities`.\n  If they are incompatible, an exception is thrown."],null)),$APP.z(EU,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(fdc,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,aU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,aU,$APP.Qr],null))),$APP.P,"Appends the supplied `arity` to the metadata of `f`, knocking out any\n  pre-existing arity notation.\n\n  Optionally accepts a third parameter `m` of metadata to attach to the return\n  function, in addition to the new `:arity` key.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,aU],null),new $APP.H(null,
3,5,$APP.I,[$APP.Nv,aU,$APP.Qr],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,aU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,aU,$APP.Qr],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(wDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,aU],null))),$APP.P,"Given an [[emmy.value/scalar?]] input `x`, returns a function of arity `arity`\n  that always returns `x` no matter what input it receives.\n\n  For non-numerical `x`, returns `x`."],null)),
$APP.z(nYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Returns true if `f` is of [[v/kind]] `::v/function`, false otherwise."],null)),$APP.z(Wab,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"Returns the joint arity of arities `a` and `b`.\n\n  The joint arity is the loosest possible arity specification compatible with\n  both `a` and `b`. Throws if `a` and `b` are incompatible.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z($APP.Zv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,yW],null),new $APP.H(null,3,5,$APP.I,
[$APP.Nv,yW,$APP.wu],null))),$APP.P,"For non-functions, acts like [[clojure.core/get-in]]. For function\n  arguments (anything that responds true to [[function?]]), returns\n\n  ```clojure\n  (comp #(clojure.core/get-in % ks) f)\n  ```\n\n  If `not-found` is supplied it's passed through to the\n  composed [[clojure.core/get-in]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,yW],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,
yW,$APP.wu],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,yW],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,yW,$APP.wu],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($APP.vua,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"meta-preserving version of `clojure.core/memoize`.\n\n  The returned function will have a new `:arity` entry in its metadata with the\n  `arity` of the original `f`; this is because the process used to figure out a\n  function's arity will not work across the memoization boundary."],
null)),$APP.z($APP.Ow,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.vU,$APP.wu],null))),$APP.P,"For non-functions, acts like [[clojure.core/get]]. For function\n  arguments (anything that responds true to [[function?]]), returns\n\n  ```clojure\n  (comp #(clojure.core/get % k) f)\n  ```\n\n  If `not-found` is supplied it's passed through to the\n  composed [[clojure.core/get]].",$APP.ky,new $APP.f(null,6,
[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.vU,$APP.wu],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.vU,$APP.wu],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(pjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))),$APP.P,"Returns the most general arity compatible with the aritiies of all entries in\n  the supplied sequence `xs` of values."],
null)),$APP.z(fU,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,oV],null))),$APP.P,"Takes a function `f` and a sequence of `factors`, and returns a new function\n  that multiplies each factor by the corresponding argument of `f`. Too many or\n  two few factors are ignored.\n\n  ```clojure\n  ((arg-scale square 3) 4) \x3d\x3d\x3e 144\n  ((arg-scale square 3 2 1) 4) \x3d\x3d\x3e 144\n  ```",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,
new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Nv,oV)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,oV],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(HX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,AY],null))),$APP.P,"Takes a function `f` and a sequence of `shifts`, and returns a new function\n  that adds each shift to the corresponding argument of `f`. Too many or two few\n  shifts are ignored.\n\n  ```clojure\n  ((arg-shift square 3) 4) \x3d\x3d\x3e 49\n  ((arg-shift square 3 2 1) 4) \x3d\x3d\x3e 49\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Nv,AY)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,AY],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(vxb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(aU,new $APP.f(null,3,[$APP.Pm,TV,$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))],
null)),$APP.z(abc,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,new $APP.f(null,1,[$APP.z(aU,new $APP.f(null,1,[$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)],null)],null)],null),$APP.Ov,new $APP.f(null,1,[ZH,new $APP.f(null,3,[$APP.Q,aU,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)),$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection."],
null)],null),gU,$APP.M("@interface")],null)),$APP.z($APP.MK,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,bW],null))),$APP.P,"Arity-preserving version of `clojure.core/comp`.\n\n  The arity of a composition is the arity of the rightmost (that is, first to be\n  applied) function term in `fns`.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(bW)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,bW],null)),
$APP.Cx,$APP.M(null)],null)],null))],[new $APP.f(null,3,[$APP.Q,cLb,$APP.X,AWa,$APP.h,new $APP.f(null,2,[$APP.P,"Find the most relaxed possible statement of the joint arity of the given sequence of `arities`.\n  If they are incompatible, an exception is thrown.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[UHb],null))],null)],null),new $APP.f(null,3,[$APP.Q,jYb,$APP.X,$APP.Kd,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,BJb,$APP.X,XH,$APP.h,new $APP.f(null,2,[$APP.P,"Appends the supplied `arity` to the metadata of `f`, knocking out any\n  pre-existing arity notation.\n\n  Optionally accepts a third parameter `m` of metadata to attach to the return\n  function, in addition to the new `:arity` key.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,aU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,aU,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,T7b,$APP.X,gI,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[emmy.value/scalar?]] input `x`, returns a function of arity `arity`\n  that always returns `x` no matter what input it receives.\n\n  For non-numerical `x`, returns `x`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,aU],null))],null)],null),new $APP.f(null,3,[$APP.Q,alb,$APP.X,WH,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if `f` is of [[v/kind]] `::v/function`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,bEb,$APP.X,fI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the joint arity of arities `a` and `b`.\n\n  The joint arity is the loosest possible arity specification compatible with\n  both `a` and `b`. Throws if `a` and `b` are incompatible.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,
2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,JGb,$APP.X,bI,$APP.h,new $APP.f(null,2,[$APP.P,"For non-functions, acts like [[clojure.core/get-in]]. For function\n  arguments (anything that responds true to [[function?]]), returns\n\n  ```clojure\n  (comp #(clojure.core/get-in % ks) f)\n  ```\n\n  If `not-found` is supplied it's passed through to the\n  composed [[clojure.core/get-in]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,yW],null),new $APP.H(null,3,5,$APP.I,
[$APP.Nv,yW,$APP.wu],null))],null)],null),new $APP.f(null,3,[$APP.Q,Blb,$APP.X,$H,$APP.h,new $APP.f(null,2,[$APP.P,"meta-preserving version of `clojure.core/memoize`.\n\n  The returned function will have a new `:arity` entry in its metadata with the\n  `arity` of the original `f`; this is because the process used to figure out a\n  function's arity will not work across the memoization boundary.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ugb,
$APP.X,aI,$APP.h,new $APP.f(null,2,[$APP.P,"For non-functions, acts like [[clojure.core/get]]. For function\n  arguments (anything that responds true to [[function?]]), returns\n\n  ```clojure\n  (comp #(clojure.core/get % k) f)\n  ```\n\n  If `not-found` is supplied it's passed through to the\n  composed [[clojure.core/get]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.vU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.vU,$APP.wu],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kjb,$APP.X,
BWa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the most general arity compatible with the aritiies of all entries in\n  the supplied sequence `xs` of values.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,UIb,$APP.X,eI,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function `f` and a sequence of `factors`, and returns a new function\n  that multiplies each factor by the corresponding argument of `f`. Too many or\n  two few factors are ignored.\n\n  ```clojure\n  ((arg-scale square 3) 4) \x3d\x3d\x3e 144\n  ((arg-scale square 3 2 1) 4) \x3d\x3d\x3e 144\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,oV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mab,$APP.X,dI,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a function `f` and a sequence of `shifts`, and returns a new function\n  that adds each shift to the corresponding argument of `f`. Too many or two few\n  shifts are ignored.\n\n  ```clojure\n  ((arg-shift square 3) 4) \x3d\x3d\x3e 49\n  ((arg-shift square 3 2 1) 4) \x3d\x3d\x3e 49\n  ```",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,
$APP.Lh,AY],null))],null)],null),new $APP.f(null,3,[$APP.Q,kcb,$APP.X,!1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,jBb,$APP.X,UH,$APP.h,new $APP.f(null,2,[$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,TV,$APP.X,uWa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,n9b,$APP.X,YH,$APP.h,new $APP.f(null,2,[$APP.P,"Arity-preserving version of `clojure.core/comp`.\n\n  The arity of a composition is the arity of the rightmost (that is, first to be\n  applied) function term in `fns`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,bW],null))],null)],null)]),$APP.ap(Zeb)),$APP.cp($APP.fg([$APP.z(mCb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[gT,xVb,T_b],null),$APP.Yv],null))),$APP.P,"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using a second-order variation of [[kahan-babushka-neumaier]].\n\n  See [this Wikipedia\n  page](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements)\n  for more information.\n\n  This algorithm was proposed by Klein in ['A Generalized Kahan-Babushka\n  Summation\n  Algorithm'](https://citeseerx.ist.psu.edu/viewdoc/download?doi\x3d10.1.1.582.288\x26rep\x3drep1\x26type\x3dpdf),\n  along with the higher-order versions implemented by [[kbk-n]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[gT,xVb,T_b],null),$APP.Yv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[gT,xVb,T_b],null),$APP.Yv],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(Wcc,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,
1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Mv],null),$APP.Yv],null))),$APP.P,"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using Neumaier's improvement to [[kahan]].\n\n  This algorithm is more efficient than [[kahan]], handles a wider range of\n  cases (adding in numbers larger than the current running sum, for example) and\n  should be preferred.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,
new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Mv],null),$APP.Yv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Mv],null),$APP.Yv],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z($APP.tv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Fy],null))),$APP.P,"Given some predicate `pred`, returns a fold that counts the number of items it\n  encounters that return true when passed to `pred`, false otherwise.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Fy],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Fy],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($S,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[h3b],null))),$APP.P,"Given some value `const`, returns a fold that ignores all input and returns\n  `const` for a call to any of its arities."],null)),$APP.z($APP.yu,
new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,3,5,$APP.I,[nU,$APP.Lh,z5b],null))),$APP.P,"Given some number of `folds`, returns a new fold with the following properties:\n\n  - the accumulator is a vector of the accumulators of each input fold\n  - each `x` is merged into each accumulator using the appropriate fold\n  - `present` is called for every entry in the final vector\n\n  Given a single `fold`, acts as identity.\n\n  The no-argument call `(join)` is equivalent to `([[constant]] [])`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,2,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[nU],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,3,5,$APP.I,[nU,$APP.Lh,z5b],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(r9b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Kv],null)],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,
[gT,$APP.Mv],null),$APP.Yv],null))),$APP.P,"Fold that tracks the summation of a sequence of floating point numbers, using\n  the [Kahan summation\n  algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) for\n  maintaining stability in the face of accumulating floating point errors.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Kv],null)],null),new $APP.H(null,2,5,
$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Mv],null),$APP.Yv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Kv],null)],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Mv],null),$APP.Yv],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z($APP.kva,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null))),$APP.P,"Fold that stores its minimum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(SXb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,2,5,$APP.I,[nU,$APP.JT],null),new $APP.H(null,
3,5,$APP.I,[$APP.Cy,nU,$APP.JT],null))),$APP.P,'Given\n\n  - a 0-argument fn `init` that returns some "empty" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) \x3d\x3e accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator \x3d\x3e final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns the result of accumulating all elements in `xs` using the functions\n  above, then `present`ing the result.\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns the result of\n  accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.',
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,2,5,$APP.I,[nU,$APP.JT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,nU,$APP.JT],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,2,5,$APP.I,[nU,$APP.JT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,nU,$APP.JT],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),f2b,$APP.z($APP.uw,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,
new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null))),$APP.P,"Fold that stores its maximum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),
new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(U1b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null))),$APP.P,"Fold-style function. The 2-arity merge operation adds the value `x` into the\n  accumulating stating using [[emmy.generic/+]].\n\n  - given 0 arguments, returns an accumulator of 0.0\n  - given a single argument `acc`, acts as identity.",$APP.ky,new $APP.f(null,
6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(Abb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,2,5,$APP.I,[nU,$APP.JT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,nU,
$APP.JT],null))),$APP.P,'Given\n\n  - a 0-argument fn `init` that returns some "empty" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) \x3d\x3e accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator \x3d\x3e final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns a lazy sequence of all intermediate results of the summation. For\n  example, given [0 1 2 3], the return sequence would be equivalent to:\n\n  ```clj\n  (def sum-fn (fold-\x3esum-fn init fold present))\n\n  [(sum-fn [0])\n   (sum-fn [0 1])\n   (sum-fn [0 1 2])\n   (sum-fn [0 1 2 3])]\n  ```\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns a lazy sequence of all\n  intermediate results of accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.',
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,2,5,$APP.I,[nU,$APP.JT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,nU,$APP.JT],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,2,5,$APP.I,[nU,$APP.JT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,nU,$APP.JT],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),Ttb],[new $APP.f(null,3,[$APP.Q,PYb,$APP.X,M_,$APP.h,new $APP.f(null,
2,[$APP.P,"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using a second-order variation of [[kahan-babushka-neumaier]].\n\n  See [this Wikipedia\n  page](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements)\n  for more information.\n\n  This algorithm was proposed by Klein in ['A Generalized Kahan-Babushka\n  Summation\n  Algorithm'](https://citeseerx.ist.psu.edu/viewdoc/download?doi\x3d10.1.1.582.288\x26rep\x3drep1\x26type\x3dpdf),\n  along with the higher-order versions implemented by [[kbk-n]].",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[gT,xVb,T_b],null),$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,QQb,$APP.X,FI,$APP.h,new $APP.f(null,2,[$APP.P,"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using Neumaier's improvement to [[kahan]].\n\n  This algorithm is more efficient than [[kahan]], handles a wider range of\n  cases (adding in numbers larger than the current running sum, for example) and\n  should be preferred.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Mv],null),$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Usb,$APP.X,H_,$APP.h,new $APP.f(null,2,[$APP.P,"Given some predicate `pred`, returns a fold that counts the number of items it\n  encounters that return true when passed to `pred`, false otherwise.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Fy],null))],null)],null),new $APP.f(null,3,[$APP.Q,ujb,$APP.X,
FTa,$APP.h,new $APP.f(null,2,[$APP.P,"Given some value `const`, returns a fold that ignores all input and returns\n  `const` for a call to any of its arities.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[h3b],null))],null)],null),new $APP.f(null,3,[$APP.Q,RBb,$APP.X,K_,$APP.h,new $APP.f(null,2,[$APP.P,"Given some number of `folds`, returns a new fold with the following properties:\n\n  - the accumulator is a vector of the accumulators of each input fold\n  - each `x` is merged into each accumulator using the appropriate fold\n  - `present` is called for every entry in the final vector\n\n  Given a single `fold`, acts as identity.\n\n  The no-argument call `(join)` is equivalent to `([[constant]] [])`.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,3,5,$APP.I,[nU,$APP.Lh,z5b],null))],null)],null),new $APP.f(null,3,[$APP.Q,Qfb,$APP.X,L_,$APP.h,new $APP.f(null,2,[$APP.P,"Fold that tracks the summation of a sequence of floating point numbers, using\n  the [Kahan summation\n  algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) for\n  maintaining stability in the face of accumulating floating point errors.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,
[new $APP.H(null,2,5,$APP.I,[gT,$APP.Kv],null)],null),new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[gT,$APP.Mv],null),$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,AZb,$APP.X,I_,$APP.h,new $APP.f(null,2,[$APP.P,"Fold that stores its minimum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,eJb,$APP.X,G_,$APP.h,new $APP.f(null,2,[$APP.P,'Given\n\n  - a 0-argument fn `init` that returns some "empty" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) \x3d\x3e accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator \x3d\x3e final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns the result of accumulating all elements in `xs` using the functions\n  above, then `present`ing the result.\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns the result of\n  accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.',
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,2,5,$APP.I,[nU,$APP.JT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,nU,$APP.JT],null))],null)],null),new $APP.f(null,3,[$APP.Q,dec,$APP.X,function(a,b,c){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.ay,null,1,null),OTa(c))))},$APP.h,new $APP.f(null,4,[$APP.P,"Given some order `n`, returns a fold implementing `n`-th order\n  Kahan-Babushka-Klein summation.\n\n  Given `n` \x3d\x3d 0, this is identical to a naive sum.\n  Given `n` \x3d\x3d 1, identical to [[kahan-babushka-neumaier]].\n  Given `n` \x3d\x3d 2, identical to [[kahan-babushka-klein]].\n\n  `n` \x3e 2 represent new compensated summation algorithms.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,kSb,$APP.X,J_,$APP.h,new $APP.f(null,2,[$APP.P,"Fold that stores its maximum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,LBb,$APP.X,F_,$APP.h,new $APP.f(null,
2,[$APP.P,"Fold-style function. The 2-arity merge operation adds the value `x` into the\n  accumulating stating using [[emmy.generic/+]].\n\n  - given 0 arguments, returns an accumulator of 0.0\n  - given a single argument `acc`, acts as identity.",$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[gT],null),new $APP.H(null,2,5,$APP.I,[gT,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,UMb,$APP.X,GI,$APP.h,new $APP.f(null,2,[$APP.P,'Given\n\n  - a 0-argument fn `init` that returns some "empty" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) \x3d\x3e accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator \x3d\x3e final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns a lazy sequence of all intermediate results of the summation. For\n  example, given [0 1 2 3], the return sequence would be equivalent to:\n\n  ```clj\n  (def sum-fn (fold-\x3esum-fn init fold present))\n\n  [(sum-fn [0])\n   (sum-fn [0 1])\n   (sum-fn [0 1 2])\n   (sum-fn [0 1 2 3])]\n  ```\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns a lazy sequence of all\n  intermediate results of accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.',
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nU],null),new $APP.H(null,2,5,$APP.I,[nU,$APP.JT],null),new $APP.H(null,3,5,$APP.I,[$APP.Cy,nU,$APP.JT],null))],null)],null),new $APP.f(null,3,[$APP.Q,jKb,$APP.X,FI,$APP.h,$APP.F],null)]),$APP.ap(Y5b)),$APP.cp($APP.fg([$APP.z(b$b,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(Xub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given some 2-tensor-shaped structure `s`, returns the corresponding matrix.\n\n  The outer orientation is ignored; If the inner structures are `up`, they're\n  treated as columns. Inner `down` structures are treated as rows."],
null)),$APP.z(p2b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,BV],null))),$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  Variadic equivalent to [[by-rows*]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(BV)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,BV],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(qY,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns true if `m` is a matrix with a single column (a 'column matrix'),\n  false otherwise."],null)),$APP.z(aSb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null)))],null)),$APP.z(RZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns the number of rows of the supplied matrix `m`. Throws if a\n  non-matrix is supplied."],
null)),$APP.z(gfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"If `m` is already a vector, acts as identity. Else, returns the matrix as a\n  vector of rows (or throws if neither of these types is passed)."],null)),$APP.z(MYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(qY,$APP.Qr)],null)],null)))),$APP.P,"Returns the single column from the supplied column matrix as a vector. Errors\n  if some other type is supplied."],
null)),$APP.z(oJb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(hvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,LV],null))),$APP.P,"Returns a column matrix of `nrows` symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-column-matrix 'x 3)\n     (by-cols ['x↑0 'x↑1 'x↑2]))\n  ```"],null)),$APP.z($APP.CY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),
new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(zY,$APP.Qr)],null)],null)))),$APP.P,"Returns the 'dimension', i.e., the number of rows \x26 columns, of the supplied\n  square matrix. Errors if some other type is supplied."],null)),$APP.z(zY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns true if `m` is a square matrix, false otherwise."],null)),$APP.z(IAb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(qAb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))),$APP.P,"Returns true if the supplied matrix `M` is equal to the negation of its own\n  transpose (i.e., antisymmetric), false otherwise."],null)),$APP.z(Seb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.wU],null))),$APP.P,"Returns the `n`-th column of the supplied matrix `m` as an `up` structure."],null)),$APP.z(KZb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(OUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(MUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Yx,iX],null))),$APP.P,"Returns a row matrix of `ncols` symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-row-matrix 'x 3)\n     (by-rows ['x_0 'x_1 'x_2]))\n  ```"],null)),$APP.z(WJb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null))),$APP.P,"Convert the structure `ms`, which would be a scalar if the (compatible)\n  multiplication `(* ls ms rs)` were performed, to a matrix.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(jX,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(EU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),$APP.P,"Return the identity matrix of order `n`."],
null)),$APP.z(xpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(dY,$APP.Wv)],null)],null)))),$APP.P,"Returns a column matrix with the contents of the supplied `up` structure.\n  Errors if any other type is provided."],null)),$APP.z(Kqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.iT,$APP.LX,$U,$APP.Cv],null))),$APP.P,"Given coefficient procedures `add`, `sub`, `mul` and `zero?`, returns a\n  procedure that efficiently computes the determinant of the supplied square\n  matrix `m`.\n\n  [[general-determinant]] is useful for generating fast type-specific\n  determinant routines. See [[determinant]] for a default using generic\n  arithmetic."],
null)),$APP.z(aWb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null))),$APP.P,"Given structural inputs `ls` (optional), `ms` and `rs`, constrained such\n  that `(* ls ms rs)` returns a numerical quantity, returns a result such that\n  the following relationship remains true:\n\n  ```clj\n  (* \x3cls| (* ms |rs\x3e)) \x3d (* \x3crs| (* (s:transpose ms) |ls\x3e))\n  ```\n\n  For example:\n\n  ```clj\n  (let [ls (s/up 1 2)\n      ms (s/up (s/down 1 2) (s/down 3 4))\n      rs (s/down 1 2)]\n  (g/* ls (g/* ms rs))\n  ;;\x3d\x3e 27\n\n  (g/* rs (g/* (s:transpose ls ms rs) ls))\n  ;;\x3d\x3e 27\n  )\n  ```\n\n  `ls` is optional. If `ls` is not supplied, a compatible shape is generated\n  internally.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(DHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.kx,
$APP.ix)],null)],null)))),$APP.P,"Returns a row matrix populated by the supplied `xs`. For a variadic equivalent,\n  see [[row]]."],null)),$APP.z(r4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(qY,$APP.Qr)],null)],null)))),$APP.P,"Returns the single column from the supplied column matrix as an `up`. Errors if\n  some other type is supplied."],null)),$APP.z(cY,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(zY,$APP.Qr)],null)],null)))),$APP.P,"Returns the trace (the sum of diagonal elements) of the square matrix `m`.\n\n  Generic operations are used, so this works on symbolic square matrices."],null)),$APP.z(gdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))),$APP.P,"Convert a sequence `xs` (typically, of function arguments) to an up-structure.\n\n  Any matrix present in the argument list will be converted to row of columns\n  via [[-\x3estructure]]."],
null)),$APP.z(f7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.kx,$APP.ix)],null)],null)))),$APP.P,"Returns a column matrix populated by the supplied `xs`. For a variadic equivalent,\n  see [[column]]."],null)),$APP.z(P0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[hX],null))),$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  for a variadic equivalent, see [[by-cols]]."],
null)),$APP.z(YPb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Mv,$APP.Nv],null))),$APP.P,"Returns a matrix with `r` rows and `c` columns, whose entries are generated by\n  the supplied function `f`.\n\n  If you only supply one dimension `n` the returned matrix will be square.\n\n  The entry in the `i`th row and `j`-th column is `(f i j)`.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,
new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Mv,$APP.Nv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Mv,$APP.Nv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(q8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Qr,$APP.Rv,uU],null))),$APP.P,"Returns the matrix formed by deleting the `i`-th row and `j`-th column of the\n  given matrix `m`.\n\n  This is also called the 'minor' of m."],
null)),$APP.z(nlb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),$APP.z(new $APP.H(null,4,5,$APP.I,[$APP.Qr,pV,iY,kTb],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(j_b,pV),$APP.M(j_b,iY)],null)],null)))),$APP.P,"Returns a structure generated by converting `m` into a nested structure with\n  the supplied `outer-orientation` and `inner-orientation`.\n\n  If `t?` is true, the columns of `m` will form the inner tuples. If `t?` is\n  false, the rows of `m` will form the inner tuples.\n\n  By default, if you supply a single argument (the matrix `m`), a matrix turns\n  into a single outer `::s/down` of inner columns represented as `::up`\n  structures.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.H(null,4,5,$APP.I,[$APP.Qr,pV,iY,kTb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.H(null,4,5,$APP.I,[$APP.Qr,pV,iY,kTb],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(xPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[AW,$APP.Qr,MW],null))),$APP.P,"Convert the matrix `m` into a structure `S`, guided by the requirement that `(*\n  ls S rs)` should be a scalar."],
null)),$APP.z(GAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,fX],null))),$APP.P,"Converts the square structure `s` into a matrix, and calls the supplied\n  continuation `cont` with\n\n  - the generated matrix\n  - a function which will restore a matrix to a structure with the same inner\n    and outer orientations as s\n\n  Returns the result of the continuation call."],null)),$APP.z(Pbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(zY,$APP.Qr)],null)],null)))),$APP.P,"Returns the diagonal of the supplied matrix `m` as an up structure. Errors if a\n  type other than a diagonal matrix is supplied."],null)),$APP.z(EHb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,hX],null))),$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  Variadic equivalent to [[by-cols*]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(hX)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,hX],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z($APP.Yza,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Qr],null))),$APP.P,"Returns true if `f` is true for some element of the matrix `m`, false\n  otherwise. (Also works on arbitrary nested sequences.)"],null)),$APP.z($APP.Zv,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,WRb],null))),$APP.P,"Like [[clojure.core/get-in]] for matrices, but obeying the scmutils convention:\n  only one index is required to get an unboxed element from a column vector.\n\n  NOTE that this is perhaps an unprincipled exception..."],null)),$APP.z(kdb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[HU,aBb],null)))],null)),$APP.z(dsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[CU],null))),$APP.P,"Any one argument function of a structure can be seen as a matrix. This is only\n  useful if the function has a linear multiplier (e.g. derivative)"],null)),$APP.z(nBb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,LV],null),new $APP.H(null,3,5,$APP.I,[$APP.Yx,LV,iX],null))),$APP.P,"Generates a `nrows` x `ncols` matrix of symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  If `ncols` (the third argument) is not supplied, returns a square matrix of\n  size `nrows` x `nrows`.\n\n  NOTE: The symbols in the returned matrix record their Einstein-notation path\n  into the structure that this matrix represents; a `down` of `up` columns. This\n  means that the returned indices embedded in the symbols look flipped, `ji` vs\n  `ij`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-matrix 'x 2 2)\n     (by-rows ['x_0↑0 'x_1↑0]\n              ['x_0↑1 'x_1↑1]))\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Yx,LV],null),new $APP.H(null,3,5,$APP.I,[$APP.Yx,LV,iX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,LV],null),new $APP.H(null,3,5,$APP.I,[$APP.Yx,LV,iX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(pmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.wU],null))),$APP.P,"Returns the `n`-th row of the supplied matrix `m` as a `down` structure."],
null)),$APP.z(FHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(SOb,$APP.Wv)],null)],null)))),$APP.P,"Returns a row matrix with the contents of the supplied `down` structure.\n  Errors if any other type is provided."],null)),$APP.z(G5b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.wU],null))),$APP.P,"Return a zero-valued matrix of `m` rows and `n` columns (`nXn` if only `n` is\n  supplied).",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.wU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.wU],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(XFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,
[$APP.M(DV,$APP.Qr)],null)],null)))),$APP.P,"Returns the single row from the supplied row matrix as a vector. Errors if some\n  other type is supplied."],null)),$APP.z(T3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Qr,$APP.Rv,$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,4,5,$APP.I,[$APP.M(Xdc,$APP.Qr),$APP.M($APP.Xv,0,$APP.Rv),$APP.M($APP.$v,$APP.Rv,$APP.M(RZb,$APP.Qr)),$APP.M($APP.bw,$APP.M(Srb,$APP.Qr),$APP.M($APP.tv,$APP.Wv))],null)],null)))),
$APP.P,"Returns a new matrix of identical shape to `m`, with the vector `v` substituted\n  for the `i`th row."],null)),$APP.z(o8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.iT,$APP.LX,$U,LY,$APP.Cv],null))),$APP.P,"Given coefficient procedures `add`, `sub`, `mul`, `div` and `zero?`, returns a\n  procedure that efficiently computes the solution to an inhomogeneous system of\n  linear equations, `A*x\x3db`, where the matrix `A` and the column matrix `b` are\n  given. The returned procedure returns the column matrix `x`.\n\n  Unlike LU decomposition, Cramer's rule generalizes to symbolic solutions.\n\n  [[cramers-rule]] is useful for generating fast type-specific linear equation\n  solvers. See [[solve]] for a default using generic arithmetic."],
null)),$APP.z(eKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given some 2 tensor `s`, returns a structure with elements 'transposed' by\n  swapping the inner and outer orientations and dimensions, like a matrix\n  transpose.\n\n  Orientations are only flipped if they are different in the input. If the inner\n  and outer orientations of `s` are the same, the returned structure has this\n  identical orientation.\n\n  For example:\n\n  ```clj\n  ;; opposite orientation gets flipped:\n  (s:transpose-orientation (s/up (s/down 1 2 3) (s/down 4 5 6)))\n  ;;\x3d\x3e (down (up 1 4) (up 2 5) (up 3 6))\n\n  ;; same orientation stays the same:\n  (s:transpose-orientation (s/down (s/down 1 2 3) (s/down 4 5 6)))\n  ;;\x3d\x3e (down (down 1 4) (down 2 5) (down 3 6))\n  ```\n\n  See [[structure/two-tensor?]] for more detail on 2 tensors.\n\n  NOTE: In scmutils, this function is called `s:transpose2`."],
null)),$APP.z($APP.VBa,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))),$APP.P,"Returns a row matrix populated by the supplied `xs`. Variadic equivalent\n  to [[row*]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ix)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(N$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[BV],null))),$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  for a variadic equivalent, see [[by-rows]]."],null)),$APP.z(WNb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.Yv],null))),$APP.P,"Returns the [characteristic\n  polynomial](https://en.wikipedia.org/wiki/Characteristic_polynomial) of the\n  square matrix `m`.\n\n  If only `m` is supplied, returns a [[polynomial/Polynomial]] instance\n  representing the matrix `m`'s characteristic polynomial.\n\n  If `x` is supplied, returns the value of the characteristic polynomial of `m`\n  evaluated at `x`.\n\n  Typically `x` will be a symbolic variable, but if you wanted to get the value\n  of the characteristic polynomial at some particular numerical point `x` you\n  could pass that too.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.Yv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.Yv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(kXb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[aBb,HU],null)))],null)),$APP.z(pnb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[BU,$APP.sU],null)))],null)),$APP.z(f1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(zY,$APP.Qr)],null)],null)))),$APP.P,"Returns the matrix of cofactors of the supplied square matrix `m`."],null)),$APP.z(TLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))),$APP.P,"Returns true if the supplied matrix `M` is equal to its own transpose (i.e.,\n  symmetric), false otherwise."],
null)),$APP.z($$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),$APP.P,"Given some 2-tensor `s` (a 'square' nested structure), returns a structure\n  that represents the multiplicative inverse of the supplied structure. The\n  inner and outer structure orientations of `(s:invert s)` are the SAME as `s`.\n\n  If `s` is an up-of-downs or down-of-ups, `(g/* s (s:invert s))`\n  and `(g/* (s:invert s) s)` will evaluate to an identity-matrix-shaped\n  up-of-downs or down-of-ups.\n\n  If `s` is an up-of-ups or down-of-downs, multiplying `s` `(s:invert s)` will\n  result in a scalar, as both structures collapse.\n\n  NOTE: I DO NOT yet understand the meaning of this scalar! If you do, please\n  open a pull request and explain it here."],
null)),$APP.z($APP.XX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns the transpose of the matrix `m`. The transpose is the original matrix,\n  with rows and columns swapped."],null)),$APP.z($APP.nv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))),$APP.P,"Returns a column matrix populated by the supplied `xs`. Variadic equivalent\n  to [[column*]].",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,
$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ix)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z($5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.iT,$APP.LX,$U,LY,$APP.Cv],null))),$APP.P,"Given coefficient procedures `add`, `sub`, `mul` and `zero?`, returns a\n  procedure that efficiently computes the inverse of the supplied square\n  matrix `m`.\n\n  [[classical-adjoint-formula]] is useful for generating fast type-specific\n  matrix inversion routines. See [[invert]] for a default using generic\n  arithmetic."],
null)),$APP.z(DV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns true if `m` is a matrix with a single row (a 'row matrix'), false\n  otherwise."],null)),$APP.z(dIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(DV,$APP.Qr)],null)],null)))),$APP.P,"Returns the single row from the supplied row matrix as a `down`. Errors if some\n  other type is supplied."],
null)),$APP.z(Xdc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns true if the supplied `m` is an instance of [[Matrix]], false\n  otherwise."],null)),$APP.z(Srb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns the number of columns of the supplied matrix `m`. Throws if a\n  non-matrix is supplied."],null)),$APP.z(BGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Nv,$APP.Qr],null))),$APP.P,"Maps `f` over three arguments:\n\n  - each element of the matrix `m`\n  - its row `i`\n  - its column `j`\n\n  and returns a new matrix of the same dimensions as `m`. "],null)),$APP.z(A_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[gTb,$APP.Vv],null)))],null)),$APP.z(Veb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sU,BU],null))),$APP.P,"Generalization of [[solve]] that can handle `up` and `down` structures, as well\n  as `row` and `column` matrices.\n\n  Given `row` or `down` values for `b`, `A` is appropriately transposed before\n  solving."],
null)),$APP.z(m9b,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,15,[bT,"null",mU,"null",UW,"null",jU,"null",YE,"null",OLb,"null",zX,"null",US,"null",tS,"null",NY,"null",iV,"null",wY,"null",TW,"null",lW,"null",TV,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Mv,$APP.Wv],null))),YR,new $APP.ug(null,new $APP.f(null,10,[bT,"null",mU,"null",UW,"null",zX,"null",US,"null",tS,"null",iV,"null",wY,"null",TW,"null",lW,"null"],null),null),$APP.P,
"Positional factory function for emmy.matrix/Matrix."],null)),$APP.z(qfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.Nv],null))),$APP.P,"Applies matrix operation `f` to square structure `s` and returns a structure of\n  the same type as the supplied structure."],null)),$APP.z(lS,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(cIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns true if `m` is a diagonal matrix (i.e., a square matrix where every\n  non-diagonal element is zero), false otherwise."],
null)),$APP.z(f4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Yv,N2b,ILb,Pac,QUb],null))),$APP.P,"Returns the submatrix of the matrix (or matrix-like structure) `s` generated by\n  taking\n\n  - rows    from `lowrow` -\x3e `hirow` (inclusive)\n  - columns from `lowcol` -\x3e `hicol` (inclusive)"],null))],[new $APP.f(null,3,[$APP.Q,yzb,$APP.X,h2a,$APP.h,new $APP.f(null,2,[$APP.P,"Return an identity matrix whose ones and zeros match the types of the supplied\n  square matrix `M`. Errors if a non-square matrix `M` is supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))],null)],null),new $APP.f(null,3,[$APP.Q,lyb,$APP.X,function(a){return BN(a,function(b){return b})},$APP.h,new $APP.f(null,2,[$APP.P,"Given some 2-tensor-shaped structure `s`, returns the corresponding matrix.\n\n  The outer orientation is ignored; If the inner structures are `up`, they're\n  treated as columns. Inner `down` structures are treated as rows.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,
[$APP.Q,gec,$APP.X,EN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  Variadic equivalent to [[by-rows*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,BV],null))],null)],null),new $APP.f(null,3,[$APP.Q,zjb,$APP.X,F1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `m` is a matrix with a single column (a 'column matrix'),\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],
null))],null)],null),new $APP.f(null,3,[$APP.Q,cbc,$APP.X,T2,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,UVb,$APP.X,rN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of rows of the supplied matrix `m`. Throws if a\n  non-matrix is supplied.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,i6b,$APP.X,E1a,$APP.h,new $APP.f(null,2,[$APP.P,"If `m` is already a vector, acts as identity. Else, returns the matrix as a\n  vector of rows (or throws if neither of these types is passed).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,XDb,$APP.X,X1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the single column from the supplied column matrix as a vector. Errors\n  if some other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(qY,$APP.Qr)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,E3b,$APP.X,vN,$APP.h,new $APP.f(null,2,[$APP.P,
"Maps `f` over the elements of the matrix `m` returning a new matrix of the same\n  dimensions as `m`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,CKb,$APP.X,function(a,b){return xN.B(b,1,function(c){return $APP.Zg.j([$APP.m.j(a),"↑",$APP.m.j(c)].join(""))})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a column matrix of `nrows` symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-column-matrix 'x 3)\n     (by-cols ['x↑0 'x↑1 'x↑2]))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,LV],null))],null)],null),new $APP.f(null,3,[$APP.Q,X0b,$APP.X,function(a){return rN(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the 'dimension', i.e., the number of rows \x26 columns, of the supplied\n  square matrix. Errors if some other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(zY,$APP.Qr)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,
BSb,$APP.X,tN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `m` is a square matrix, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mib,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,HNb,$APP.X,function(a){return MF.j(dG.j(gH.A(yN(a),a)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied matrix `M` is equal to the negation of its own\n  transpose (i.e., antisymmetric), false otherwise.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[HU],null))],null)],null),new $APP.f(null,3,[$APP.Q,KHb,$APP.X,CN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `n`-th column of the supplied matrix `m` as an `up` structure.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,K8b,$APP.X,V2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a single (sequential) argument `v`, returns the diagonal matrix of\n  order `(count v)` with the elements of the sequence `v` along the diagonal.\n\n  Given two arguments `n` and some constant `x`, returns a diagonal `n` by `n`\n  matrix with `x` in every entry of the diagonal.\n\n  `(make-diagonal \x3cn\x3e 1)` is equivalent to `(I n)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,a4b,$APP.X,LN,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null))],null)],null),new $APP.f(null,3,[$APP.Q,Obc,$APP.X,function(a,b){return xN.B(1,b,function(c,d){return $APP.Zg.j([$APP.m.j(a),"_",$APP.m.j(d)].join(""))})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a row matrix of `ncols` symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-row-matrix 'x 3)\n     (by-rows ['x_0 'x_1 'x_2]))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,iX],null))],null)],null),new $APP.f(null,3,[$APP.Q,IJb,$APP.X,TO,$APP.h,new $APP.f(null,2,[$APP.P,"Convert the structure `ms`, which would be a scalar if the (compatible)\n  multiplication `(* ls ms rs)` were performed, to a matrix.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null))],null)],null),new $APP.f(null,3,[$APP.Q,kbb,$APP.X,JN,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[BU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ggb,$APP.X,MN,$APP.h,new $APP.f(null,2,[$APP.P,"Return the identity matrix of order `n`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,f8b,$APP.X,W1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a column matrix with the contents of the supplied `up` structure.\n  Errors if any other type is provided.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,
1,5,$APP.I,[$APP.M(dY,$APP.Wv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,ALb,$APP.X,d2a,$APP.h,new $APP.f(null,2,[$APP.P,"Given coefficient procedures `add`, `sub`, `mul` and `zero?`, returns a\n  procedure that efficiently computes the determinant of the supplied square\n  matrix `m`.\n\n  [[general-determinant]] is useful for generating fast type-specific\n  determinant routines. See [[determinant]] for a default using generic\n  arithmetic.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,
[$APP.iT,$APP.LX,$U,$APP.Cv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ebb,$APP.X,sP,$APP.h,new $APP.f(null,2,[$APP.P,"Given structural inputs `ls` (optional), `ms` and `rs`, constrained such\n  that `(* ls ms rs)` returns a numerical quantity, returns a result such that\n  the following relationship remains true:\n\n  ```clj\n  (* \x3cls| (* ms |rs\x3e)) \x3d (* \x3crs| (* (s:transpose ms) |ls\x3e))\n  ```\n\n  For example:\n\n  ```clj\n  (let [ls (s/up 1 2)\n      ms (s/up (s/down 1 2) (s/down 3 4))\n      rs (s/down 1 2)]\n  (g/* ls (g/* ms rs))\n  ;;\x3d\x3e 27\n\n  (g/* rs (g/* (s:transpose ls ms rs) ls))\n  ;;\x3d\x3e 27\n  )\n  ```\n\n  `ls` is optional. If `ls` is not supplied, a compatible shape is generated\n  internally.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null))],null)],null),new $APP.f(null,3,[$APP.Q,O4b,$APP.X,M1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a row matrix populated by the supplied `xs`. For a variadic equivalent,\n  see [[row]].",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.kx,$APP.ix)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,ZHb,$APP.X,DN,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns the single column from the supplied column matrix as an `up`. Errors if\n  some other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(qY,$APP.Qr)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,oBb,$APP.X,c2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the trace (the sum of diagonal elements) of the square matrix `m`.\n\n  Generic operations are used, so this works on symbolic square matrices.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(zY,$APP.Qr)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Vmb,$APP.X,N1a,$APP.h,new $APP.f(null,2,[$APP.P,"Convert a sequence `xs` (typically, of function arguments) to an up-structure.\n\n  Any matrix present in the argument list will be converted to row of columns\n  via [[-\x3estructure]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),
new $APP.f(null,3,[$APP.Q,Cjb,$APP.X,wN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a column matrix populated by the supplied `xs`. For a variadic equivalent,\n  see [[column]].",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.kx,$APP.ix)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,ygb,$APP.X,L1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  for a variadic equivalent, see [[by-cols]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[hX],null))],null)],null),new $APP.f(null,3,[$APP.Q,nsb,$APP.X,xN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix with `r` rows and `c` columns, whose entries are generated by\n  the supplied function `f`.\n\n  If you only supply one dimension `n` the returned matrix will be square.\n\n  The entry in the `i`th row and `j`-th column is `(f i j)`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Mv,
$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,vSb,$APP.X,b2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the matrix formed by deleting the `i`-th row and `j`-th column of the\n  given matrix `m`.\n\n  This is also called the 'minor' of m.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Qr,$APP.Rv,uU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Cyb,$APP.X,zN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure generated by converting `m` into a nested structure with\n  the supplied `outer-orientation` and `inner-orientation`.\n\n  If `t?` is true, the columns of `m` will form the inner tuples. If `t?` is\n  false, the rows of `m` will form the inner tuples.\n\n  By default, if you supply a single argument (the matrix `m`), a matrix turns\n  into a single outer `::s/down` of inner columns represented as `::up`\n  structures.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),$APP.z(new $APP.H(null,4,5,$APP.I,[$APP.Qr,pV,iY,kTb],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(j_b,pV),$APP.M(j_b,iY)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,j$b,$APP.X,IN,$APP.h,new $APP.f(null,2,[$APP.P,"Convert the matrix `m` into a structure `S`, guided by the requirement that `(*\n  ls S rs)` should be a scalar.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[AW,$APP.Qr,MW],null))],null)],null),new $APP.f(null,
3,[$APP.Q,yEb,$APP.X,BN,$APP.h,new $APP.f(null,2,[$APP.P,"Converts the square structure `s` into a matrix, and calls the supplied\n  continuation `cont` with\n\n  - the generated matrix\n  - a function which will restore a matrix to a structure with the same inner\n    and outer orientations as s\n\n  Returns the result of the continuation call.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,fX],null))],null)],null),new $APP.f(null,3,[$APP.Q,Tsb,$APP.X,V1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the diagonal of the supplied matrix `m` as an up structure. Errors if a\n  type other than a diagonal matrix is supplied.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(zY,$APP.Qr)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Xlb,$APP.X,R2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  Variadic equivalent to [[by-cols*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,hX],null))],null)],null),new $APP.f(null,3,[$APP.Q,hMb,
$APP.X,function(a,b){return $APP.He(a,$APP.ef(b))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `f` is true for some element of the matrix `m`, false\n  otherwise. (Also works on arbitrary nested sequences.)",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,Aeb,$APP.X,H1a,$APP.h,new $APP.f(null,2,[$APP.P,"Like [[clojure.core/get-in]] for matrices, but obeying the scmutils convention:\n  only one index is required to get an unboxed element from a column vector.\n\n  NOTE that this is perhaps an unprincipled exception...",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,WRb],null))],null)],null),new $APP.f(null,3,[$APP.Q,cZb,$APP.X,f2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[HU,aBb],null))],null)],null),new $APP.f(null,3,[$APP.Q,cWb,$APP.X,function(a){return function(b){var c=a.j?a.j(b):a.call(null,b);return TO.A(c,b)}},$APP.h,new $APP.f(null,2,[$APP.P,"Any one argument function of a structure can be seen as a matrix. This is only\n  useful if the function has a linear multiplier (e.g. derivative)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xxb,$APP.X,Q2,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a `nrows` x `ncols` matrix of symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  If `ncols` (the third argument) is not supplied, returns a square matrix of\n  size `nrows` x `nrows`.\n\n  NOTE: The symbols in the returned matrix record their Einstein-notation path\n  into the structure that this matrix represents; a `down` of `up` columns. This\n  means that the returned indices embedded in the symbols look flipped, `ji` vs\n  `ij`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-matrix 'x 2 2)\n     (by-rows ['x_0↑0 'x_1↑0]\n              ['x_0↑1 'x_1↑1]))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,LV],null),new $APP.H(null,3,5,$APP.I,[$APP.Yx,LV,iX],null))],null)],null),new $APP.f(null,3,[$APP.Q,zhb,$APP.X,U1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `n`-th row of the supplied matrix `m` as a `down` structure.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vcb,$APP.X,Y1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a row matrix with the contents of the supplied `down` structure.\n  Errors if any other type is provided.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(SOb,$APP.Wv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,ITb,$APP.X,U2,$APP.h,new $APP.f(null,2,[$APP.P,"Return a zero-valued matrix of `m` rows and `n` columns (`nXn` if only `n` is\n  supplied).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,tbb,$APP.X,GN,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns the single row from the supplied row matrix as a vector. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(DV,$APP.Qr)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Ulb,$APP.X,$1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new matrix of identical shape to `m`, with the vector `v` substituted\n  for the `i`th row.",$APP.U,$APP.M($APP.z(new $APP.H(null,
3,5,$APP.I,[$APP.Qr,$APP.Rv,$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,4,5,$APP.I,[$APP.M(Xdc,$APP.Qr),$APP.M($APP.Xv,0,$APP.Rv),$APP.M($APP.$v,$APP.Rv,$APP.M(RZb,$APP.Qr)),$APP.M($APP.bw,$APP.M(Srb,$APP.Qr),$APP.M($APP.tv,$APP.Wv))],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,R3b,$APP.X,j2a,$APP.h,new $APP.f(null,2,[$APP.P,"Given coefficient procedures `add`, `sub`, `mul`, `div` and `zero?`, returns a\n  procedure that efficiently computes the solution to an inhomogeneous system of\n  linear equations, `A*x\x3db`, where the matrix `A` and the column matrix `b` are\n  given. The returned procedure returns the column matrix `x`.\n\n  Unlike LU decomposition, Cramer's rule generalizes to symbolic solutions.\n\n  [[cramers-rule]] is useful for generating fast type-specific linear equation\n  solvers. See [[solve]] for a default using generic arithmetic.",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.iT,$APP.LX,$U,LY,$APP.Cv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ryb,$APP.X,function(a){a=R1a(a,yN);return $APP.Uc.A(VK(a),VK($APP.u(a)))?a:oL(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given some 2 tensor `s`, returns a structure with elements 'transposed' by\n  swapping the inner and outer orientations and dimensions, like a matrix\n  transpose.\n\n  Orientations are only flipped if they are different in the input. If the inner\n  and outer orientations of `s` are the same, the returned structure has this\n  identical orientation.\n\n  For example:\n\n  ```clj\n  ;; opposite orientation gets flipped:\n  (s:transpose-orientation (s/up (s/down 1 2 3) (s/down 4 5 6)))\n  ;;\x3d\x3e (down (up 1 4) (up 2 5) (up 3 6))\n\n  ;; same orientation stays the same:\n  (s:transpose-orientation (s/down (s/down 1 2 3) (s/down 4 5 6)))\n  ;;\x3d\x3e (down (down 1 4) (down 2 5) (down 3 6))\n  ```\n\n  See [[structure/two-tensor?]] for more detail on 2 tensors.\n\n  NOTE: In scmutils, this function is called `s:transpose2`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,h7b,$APP.X,S2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a row matrix populated by the supplied `xs`. Variadic equivalent\n  to [[row*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,lbc,$APP.X,K1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  for a variadic equivalent, see [[by-rows]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[BV],null))],null)],null),new $APP.f(null,3,[$APP.Q,rCb,$APP.X,W2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the [characteristic\n  polynomial](https://en.wikipedia.org/wiki/Characteristic_polynomial) of the\n  square matrix `m`.\n\n  If only `m` is supplied, returns a [[polynomial/Polynomial]] instance\n  representing the matrix `m`'s characteristic polynomial.\n\n  If `x` is supplied, returns the value of the characteristic polynomial of `m`\n  evaluated at `x`.\n\n  Typically `x` will be a symbolic variable, but if you wanted to get the value\n  of the characteristic polynomial at some particular numerical point `x` you\n  could pass that too.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Cwb,$APP.X,g2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[aBb,HU],null))],null)],null),new $APP.f(null,3,[$APP.Q,ttb,$APP.X,NN,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BU,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,zdc,$APP.X,function(a){var b=rN(a);if(2>b)return a;if($APP.Uc.A(b,2)){var c=
$APP.x.B(a,0,null);b=$APP.x.B(c,0,null);c=$APP.x.B(c,1,null);var d=$APP.x.B(a,1,null),g=$APP.x.B(d,0,null);d=$APP.x.B(d,1,null);return pN(2,2,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[d,RF.j(g)],null),new $APP.H(null,2,5,$APP.I,[RF.j(c),b],null)],null))}return xN.B(b,b,function(l,n){var p=T2(b2a(a,l,n));return $APP.Ie(l+n)?p:RF.j(p)})},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the matrix of cofactors of the supplied square matrix `m`.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,
[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(zY,$APP.Qr)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,aMb,$APP.X,function(a){return MF.j(dG.j(AG.A(yN(a),a)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied matrix `M` is equal to its own transpose (i.e.,\n  symmetric), false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Qac,$APP.X,Z1a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some 2-tensor `s` (a 'square' nested structure), returns a structure\n  that represents the multiplicative inverse of the supplied structure. The\n  inner and outer structure orientations of `(s:invert s)` are the SAME as `s`.\n\n  If `s` is an up-of-downs or down-of-ups, `(g/* s (s:invert s))`\n  and `(g/* (s:invert s) s)` will evaluate to an identity-matrix-shaped\n  up-of-downs or down-of-ups.\n\n  If `s` is an up-of-ups or down-of-downs, multiplying `s` `(s:invert s)` will\n  result in a scalar, as both structures collapse.\n\n  NOTE: I DO NOT yet understand the meaning of this scalar! If you do, please\n  open a pull request and explain it here.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,pac,$APP.X,yN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the transpose of the matrix `m`. The transpose is the original matrix,\n  with rows and columns swapped.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ecb,$APP.X,BR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a column matrix populated by the supplied `xs`. Variadic equivalent\n  to [[column*]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,JLb,$APP.X,e2a,$APP.h,new $APP.f(null,2,[$APP.P,"Given coefficient procedures `add`, `sub`, `mul` and `zero?`, returns a\n  procedure that efficiently computes the inverse of the supplied square\n  matrix `m`.\n\n  [[classical-adjoint-formula]] is useful for generating fast type-specific\n  matrix inversion routines. See [[invert]] for a default using generic\n  arithmetic.",$APP.U,$APP.M(new $APP.H(null,
5,5,$APP.I,[$APP.iT,$APP.LX,$U,LY,$APP.Cv],null))],null)],null),new $APP.f(null,3,[$APP.Q,W4b,$APP.X,G1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `m` is a matrix with a single row (a 'row matrix'), false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,qzb,$APP.X,FN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the single row from the supplied row matrix as a `down`. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(DV,$APP.Qr)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,lVb,$APP.X,qN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `m` is an instance of [[Matrix]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,DFb,$APP.X,sN,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of columns of the supplied matrix `m`. Throws if a\n  non-matrix is supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,ozb,$APP.X,I1a,$APP.h,new $APP.f(null,2,[$APP.P,"Maps `f` over three arguments:\n\n  - each element of the matrix `m`\n  - its row `i`\n  - its column `j`\n\n  and returns a new matrix of the same dimensions as `m`. ",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,GRb,$APP.X,function(a,b){return f2a(b,a)},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[gTb,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Rqb,$APP.X,ON,$APP.h,new $APP.f(null,2,[$APP.P,"Generalization of [[solve]] that can handle `up` and `down` structures, as well\n  as `row` and `column` matrices.\n\n  Given `row` or `down` values for `b`, `A` is appropriately transposed before\n  solving.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.sU,BU],null))],null)],null),new $APP.f(null,3,[$APP.Q,H6b,$APP.X,pN,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.matrix/Matrix.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Mv,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,rbc,$APP.X,R1a,$APP.h,new $APP.f(null,2,[$APP.P,"Applies matrix operation `f` to square structure `s` and returns a structure of\n  the same type as the supplied structure.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,aOb,$APP.X,i2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied matrix `m` is an identity matrix, false\n  otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,EJb,$APP.X,function(a){var b=tN(a);if(b){var c=rN(a);return $APP.Ge($APP.rd,function(){return function l(g){return new $APP.de(null,function(){for(var n=g;;){var p=$APP.r(n);if(p){var v=p,t=$APP.u(v);if(p=$APP.r(function(A,B,G,J,O,R){return function fa(Z){return new $APP.de(null,function(ia,ja){return function(){for(var ta=Z;;)if(ta=$APP.r(ta)){if($APP.pd(ta)){var ua=$APP.lc(ta),ca=$APP.Tc(ua),V=$APP.fe(ca);
a:for(var da=0;;)if(da<ca){var Y=$APP.bd(ua,da);$APP.qg.A(ja,Y)&&(Y=$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[ja,Y],null)),$APP.je(V,MF.j(Y)));da+=1}else{ua=!0;break a}return ua?$APP.ie($APP.ke(V),fa($APP.mc(ta))):$APP.ie($APP.ke(V),null)}V=$APP.u(ta);if($APP.qg.A(ja,V))return V=$APP.am.A(a,new $APP.H(null,2,5,$APP.I,[ja,V],null)),$APP.Yd(MF.j(V),fa($APP.Fc(ta)));ta=$APP.Fc(ta)}else return null}}(A,B,G,J,O,R),null,null)}}(n,t,v,p,c,b)($APP.Jj.j(c))))return $APP.N.A(p,l($APP.Fc(n)));n=$APP.Fc(n)}else return null}},
null,null)}($APP.Jj.j(c))}())}return b},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `m` is a diagonal matrix (i.e., a square matrix where every\n  non-diagonal element is zero), false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,f3b,$APP.X,a2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the submatrix of the matrix (or matrix-like structure) `s` generated by\n  taking\n\n  - rows    from `lowrow` -\x3e `hirow` (inclusive)\n  - columns from `lowcol` -\x3e `hicol` (inclusive)",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Yv,N2b,ILb,Pac,QUb],null))],null)],null)]),$APP.ap(tzb)),$APP.cp(new $APP.f(null,1,[$APP.z(U3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,HT,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[kY],null),$APP.Ml,new $APP.f(null,1,[kY,$APP.M(nY,8,"_")],null)],null)],null))),$APP.P,"Considers an S-expression from the point of view of optimizing its evaluation\n  by isolating common subexpressions into auxiliary variables.\n\n Accepts:\n\n  - A symbolic expression `expr`\n  - a continuation fn `continue` of two arguments:\n    - a new equivalent expression with possibly some subexpressions replaced by\n      new variables (delivered by the supplied generator, see below)\n    - a seq of pairs of `[aux variable, subexpression]` used to reconstitute the\n      value.\n\n  Calls the continuation at completion and returns the continuation's value.\n\n  The special form `(doto v (aset i v_i)...)` is recognized at the top level,\n  and the CSE process is then confined to the $v_i$ expressions.\n\n  ### Optional Arguments\n\n  `:gensym-fn`: side-effecting function that returns a new, unique\n  variable name prefixed by its argument on each invocation.\n  `monotonic-symbol-generator` by default."],
null)),new $APP.f(null,3,[$APP.Q,Nmb,$APP.X,S7a,$APP.h,new $APP.f(null,2,[$APP.P,"Considers an S-expression from the point of view of optimizing its evaluation\n  by isolating common subexpressions into auxiliary variables.\n\n Accepts:\n\n  - A symbolic expression `expr`\n  - a continuation fn `continue` of two arguments:\n    - a new equivalent expression with possibly some subexpressions replaced by\n      new variables (delivered by the supplied generator, see below)\n    - a seq of pairs of `[aux variable, subexpression]` used to reconstitute the\n      value.\n\n  Calls the continuation at completion and returns the continuation's value.\n\n  The special form `(doto v (aset i v_i)...)` is recognized at the top level,\n  and the CSE process is then confined to the $v_i$ expressions.\n\n  ### Optional Arguments\n\n  `:gensym-fn`: side-effecting function that returns a new, unique\n  variable name prefixed by its argument on each invocation.\n  `monotonic-symbol-generator` by default.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,HT,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[kY],null),$APP.Ml,new $APP.f(null,1,[kY,$APP.M(nY,8,"_")],null)],null)],null))],null)],null)],null),$APP.ap(mcb)),$APP.cp($APP.fg([$APP.z(Ywb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),$APP.P,"Returns a function which rotates a vector α radians about the y axis."],null)),$APP.z(Uwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,
$APP.I,[rU],null))),$APP.P,"Returns a function which rotates a vector α radians about the x axis."],null)),jEb,$APP.z(Ssb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),$APP.P,"Produce the matrix of a rotation of α radians about the y axis."],null)),Ksb,Adb,sib,$APP.z(Azb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))],null)),$APP.z(Zwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),
$APP.P,"Returns a function which rotates a vector α radians about the z axis."],null)),$APP.z(bRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))],null)),$APP.z(INb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UX,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null)))],null)),$APP.z(C$b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[BU],null)))],null)),$APP.z(YLb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[UX,ZR,YT],null)],null))),$APP.P,"Compute the rotation matrix from a 3-vector of Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)"],null)),$APP.z(hlb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),$APP.P,"Produce the matrix of a rotation of α radians about the z axis."],null)),$APP.z(B3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),$APP.P,"Produce the matrix of a rotation of α radians about the x axis."],null)),$APP.z(Xvb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))],null)),$APP.z(Eib,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null),new $APP.H(null,2,5,$APP.I,[HU,GYb],null))),$APP.P,"Given a 3x3 rotation matrix, returns a [[emmy.structure/up]] of the\n  corresponding Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[HU],null),new $APP.H(null,2,5,$APP.I,[HU,GYb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null),new $APP.H(null,2,5,$APP.I,[HU,GYb],null)),$APP.Cx,$APP.M(null,null)],null)],null)),Jsb,Msb],[new $APP.f(null,3,[$APP.Q,dbc,$APP.X,V2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function which rotates a vector α radians about the y axis.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[rU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xac,$APP.X,U2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function which rotates a vector α radians about the x axis.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))],null)],null),new $APP.f(null,3,[$APP.Q,hJb,$APP.X,jO,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,isb,$APP.X,kO,$APP.h,new $APP.f(null,2,[$APP.P,"Produce the matrix of a rotation of α radians about the y axis.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))],
null)],null),new $APP.f(null,3,[$APP.Q,Ysb,$APP.X,W2a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,zgb,$APP.X,lO,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Rjb,$APP.X,kO,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,egb,$APP.X,S2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))],null)],null),new $APP.f(null,3,[$APP.Q,ebc,$APP.X,W2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function which rotates a vector α radians about the z axis.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[rU],null))],null)],null),new $APP.f(null,3,[$APP.Q,$bb,$APP.X,R2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))],null)],null),new $APP.f(null,3,[$APP.Q,beb,$APP.X,Q2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[UX,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,Tcc,$APP.X,X2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[BU],null))],null)],null),new $APP.f(null,
3,[$APP.Q,MRb,$APP.X,pO,$APP.h,new $APP.f(null,2,[$APP.P,"Compute the rotation matrix from a 3-vector of Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[UX,ZR,YT],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,zYb,$APP.X,lO,$APP.h,new $APP.f(null,2,[$APP.P,"Produce the matrix of a rotation of α radians about the z axis.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],
null))],null)],null),new $APP.f(null,3,[$APP.Q,O2b,$APP.X,jO,$APP.h,new $APP.f(null,2,[$APP.P,"Produce the matrix of a rotation of α radians about the x axis.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Jxb,$APP.X,T2a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Fmb,$APP.X,Y2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a 3x3 rotation matrix, returns a [[emmy.structure/up]] of the\n  corresponding Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[HU],null),new $APP.H(null,2,5,$APP.I,[HU,GYb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Zsb,$APP.X,V2a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Xsb,$APP.X,U2a,$APP.h,$APP.F],null)]),$APP.ap(Urb)),$APP.cp(new $APP.f(null,6,[$APP.z(AUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null)))],null)),new $APP.f(null,3,[$APP.Q,c3b,$APP.X,q6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null))],
null)],null),$APP.z(vRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null)))],null)),new $APP.f(null,3,[$APP.Q,Whb,$APP.X,r6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null))],null)],null),$APP.z(KJb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KP,VU],null)))],null)),new $APP.f(null,3,[$APP.Q,v1b,$APP.X,s6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[KP,VU],null))],null)],null),$APP.z(Inb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null)))],null)),new $APP.f(null,3,[$APP.Q,REb,$APP.X,t6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null))],null)],null),$APP.z(u8b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null)))],null)),new $APP.f(null,3,[$APP.Q,vwb,$APP.X,u6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null))],null)],null),$APP.z(iTb,new $APP.f(null,1,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KP,mvb],null)))],null)),new $APP.f(null,3,[$APP.Q,nXb,$APP.X,v6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[KP,mvb],null))],null)],null)],null),$APP.ap(myb)),$APP.cp($APP.fg([$APP.z(dGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"If `x` is a fixed-precision integer, returns a [[emmy.util/bigint]]\n     version of `x`. Else, acts as identity.\n\n     This is useful in cases where you may want to multiply `x` by other large\n     numbers, but don't want to try and convert something that can't overflow,\n     like a symbol, into `bigint`."],
null)),$APP.z(ysb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M($APP.cw,$APP.wU,0)],null)],null)))),$APP.P,"Returns the factorial of `n`, i.e., the product of 1 to `n` (inclusive).\n\n  [[factorial]] will return a platform-specific [[emmy.util/bigint]] given\n  some `n` that causes integer overflow."],null)),$APP.z(lWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic falling-factorial.\n\nReturns the [falling\n  factorial](https://en.wikipedia.org/wiki/Falling_and_rising_factorials), of\n  `a` to the `b`, defined as the polynomial\n\n  $$(a)_b \x3d a^{\\underline{b}} \x3d a(a - 1)(a - 2) \\cdots (a - b - 1)$$\n\n  Given a negative `b`, `([[falling-factorial]] a b)` is equivalent\n  to `(invert ([[rising-factorial]] (inc a) (- b)))`, or `##Inf` if the\n  denominator evaluates to 0.\n\n  The coefficients that appear in the expansions of [[falling-factorial]] called\n  with a symbolic first argument and positive integral second argument are the\n  Stirling numbers of the first kind (see [[stirling-first-kind]])."],
null)),$APP.z(jpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.cw,$APP.wU,0)],null)],null)))),$APP.P,"Returns the `n`th [Bell number](https://en.wikipedia.org/wiki/Bell_number), i.e.,\n  the number of ways a set of `n` elements can be partitioned into nonempty\n  subsets.\n\n  The `n`th Bell number is denoted $B_n$."],null)),$APP.z(rGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,4,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M(rW,$APP.vU),$APP.M($APP.cw,$APP.wU,0),$APP.M($APP.aw,$APP.vU,0)],null)],null)))),$APP.P,"Returns the product of the positive integers up to `n` that are congruent\n  to `(mod n k)`.\n\n  When `k` equals 1, equivalent to `([[factorial]] n)`.\n\n  See the [Wikipedia page on generalizations\n  of [[double-factorial]]](https://en.wikipedia.org/wiki/Double_factorial#Generalizations)\n  for more detail.\n\n  If you need to extend [[multi-factorial]] to negative `n` or `k`, that page\n  has suggestions for generalization."],
null)),$APP.z(Ycb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),$APP.P,"Returns the number of permutations of `n` objects in which no object appears in\n  its original position. (Each of these permutations is called\n  a ['derangement'](https://en.wikipedia.org/wiki/Derangement) of the set.)\n\n  ## References\n\n  - [Subfactorial page at Wolfram Mathworld](https://mathworld.wolfram.com/Subfactorial.html)\n  - John Cook, [Variations on Factorial](https://www.johndcook.com/blog/2010/09/21/variations-on-factorial/)\n  - John Cook, [Subfactorial](https://www.johndcook.com/blog/2010/04/06/subfactorial/)\n  - ['Derangement' on Wikipedia](https://en.wikipedia.org/wiki/Derangement)"],
null)),$APP.z(Iqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rW,$APP.wU)],null)],null)))),$APP.P,"Returns the product of all integers from 1 up to `n` that have the same\n  parity (odd or even) as `n`.\n\n  `([[double-factorial]] 0)` is defined as an empty product and equal to 1.\n\n  [[double-factorial]] with argument `n` is equivalent to `([[multi-factorial]]\n  n 2)`, but slightly more general in that it can handle negative values of\n  `n`.\n\n  If `n` is negative and even, returns `##Inf`.\n\n  If `n` is negative and odd, returns `(/ (double-factorial (+ n 2)) (+ n 2))`.\n\n  For justification, see the [Wikipedia page on the extension of double\n  factorial to negative\n  arguments](https://en.wikipedia.org/wiki/Double_factorial#Negative_arguments)."],
null)),$APP.z(uTb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,4,5,$APP.I,[$APP.wU,$APP.vU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[prb],null)],null)],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,4,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M(rW,$APP.vU),$APP.M($APP.Xv,0,$APP.vU),$APP.M($APP.Xv,0,$APP.wU)],null)],null)))),$APP.P,"Given `n` and `k`, returns the number of permutations of `n` elements which\n  contain exactly `k` [permutation\n  cycles](https://mathworld.wolfram.com/PermutationCycle.html). This is called\n  the [Stirling number s(n, k) of the first\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind).\n\n  By default, returns the [signed Stirling number of the first\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind#Signs).\n  Pass the `:unsigned? true` keyword option to retrieve the signed Stirling\n  number. (Or take the absolute value of the result...)\n\n  ```clj\n  (stirling-first-kind 13 2)\n  ;;\x3d\x3e -1486442880\n\n  (stirling-first-kind 13 2 :unsigned? true)\n  ;;\x3d\x3e 1486442880\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.wU,$APP.vU,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[prb],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.wU,$APP.vU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[prb],null)],null)],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(vCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,
1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M(rW,$APP.vU)],null)],null)))),$APP.P,'Returns the [binomial\n  coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient), i.e., the\n  coefficient of the $x^k$ term in the polynomial expansion of the binomial\n  power $(1 + x)^n$.\n\n  This quantity is sometimes pronounced "n choose k".\n\n  For negative `n` or `k`, [[binomial-coefficient]] matches the behavior\n  provided by Mathematica, described at [this\n  page](https://mathworld.wolfram.com/BinomialCoefficient.html). Given negative\n  `n`, returns\n\n  ```clj\n  ;; for k \x3e\x3d 0\n  (* (expt -1 k)\n     (binomial-coefficient (+ (- n) k -1) k))\n\n  ;; for k \x3e\x3d 0\n  (* (expt -1 (- n k))\n     (binomial-coefficient (+ (- k) -1) (- n k)))\n\n  ;; otherwise:\n  0\n  ```'],
null)),$APP.z(Elb,new $APP.f(null,1,[$APP.Ru,!0],null)),iKb,$APP.z(OXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,4,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M(rW,$APP.vU),$APP.M($APP.Xv,0,$APP.vU),$APP.M($APP.Xv,0,$APP.wU)],null)],null)))),$APP.P,"Returns $S(n,k)$, the number of ways to partition a set of `n` objects into `k`\n  non-empty subsets.\n\n  This is called a [Stirling number of the second\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind)."],
null)),xFb],[new $APP.f(null,3,[$APP.Q,vcb,$APP.X,oXa,$APP.h,new $APP.f(null,2,[$APP.P,"If `x` is a fixed-precision integer, returns a [[emmy.util/bigint]]\n     version of `x`. Else, acts as identity.\n\n     This is useful in cases where you may want to multiply `x` by other large\n     numbers, but don't want to try and convert something that can't overflow,\n     like a symbol, into `bigint`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Sqb,
$APP.X,HI,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the factorial of `n`, i.e., the product of 1 to `n` (inclusive).\n\n  [[factorial]] will return a platform-specific [[emmy.util/bigint]] given\n  some `n` that causes integer overflow.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M($APP.cw,$APP.wU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Qsb,$APP.X,Z0,$APP.h,new $APP.f(null,2,[$APP.P,
"generic falling-factorial.\n\nReturns the [falling\n  factorial](https://en.wikipedia.org/wiki/Falling_and_rising_factorials), of\n  `a` to the `b`, defined as the polynomial\n\n  $$(a)_b \x3d a^{\\underline{b}} \x3d a(a - 1)(a - 2) \\cdots (a - b - 1)$$\n\n  Given a negative `b`, `([[falling-factorial]] a b)` is equivalent\n  to `(invert ([[rising-factorial]] (inc a) (- b)))`, or `##Inf` if the\n  denominator evaluates to 0.\n\n  The coefficients that appear in the expansions of [[falling-factorial]] called\n  with a symbolic first argument and positive integral second argument are the\n  Stirling numbers of the first kind (see [[stirling-first-kind]]).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Plb,$APP.X,rXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the `n`th [Bell number](https://en.wikipedia.org/wiki/Bell_number), i.e.,\n  the number of ways a set of `n` elements can be partitioned into nonempty\n  subsets.\n\n  The `n`th Bell number is denoted $B_n$.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.cw,
$APP.wU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,tbc,$APP.X,pXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the product of the positive integers up to `n` that are congruent\n  to `(mod n k)`.\n\n  When `k` equals 1, equivalent to `([[factorial]] n)`.\n\n  See the [Wikipedia page on generalizations\n  of [[double-factorial]]](https://en.wikipedia.org/wiki/Double_factorial#Generalizations)\n  for more detail.\n\n  If you need to extend [[multi-factorial]] to negative `n` or `k`, that page\n  has suggestions for generalization.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,4,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M(rW,$APP.vU),$APP.M($APP.cw,$APP.wU,0),$APP.M($APP.aw,$APP.vU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Hbb,$APP.X,function(a){if(0===a)return 1;a=BG.A(HI(a),Math.E);return rZ.j(gH.A(.5,a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of permutations of `n` objects in which no object appears in\n  its original position. (Each of these permutations is called\n  a ['derangement'](https://en.wikipedia.org/wiki/Derangement) of the set.)\n\n  ## References\n\n  - [Subfactorial page at Wolfram Mathworld](https://mathworld.wolfram.com/Subfactorial.html)\n  - John Cook, [Variations on Factorial](https://www.johndcook.com/blog/2010/09/21/variations-on-factorial/)\n  - John Cook, [Subfactorial](https://www.johndcook.com/blog/2010/04/06/subfactorial/)\n  - ['Derangement' on Wikipedia](https://en.wikipedia.org/wiki/Derangement)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,MBb,$APP.X,function Bsc(a){if(0===a)a=1;else if(0<a)a=pXa(a,2);else if($APP.Ie(a))a=Infinity;else{var c=BG,d=c.A;var g=a+2;g=Bsc.j?Bsc.j(g):Bsc.call(null,g);a=d.call(c,g,a+2)}return a},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the product of all integers from 1 up to `n` that have the same\n  parity (odd or even) as `n`.\n\n  `([[double-factorial]] 0)` is defined as an empty product and equal to 1.\n\n  [[double-factorial]] with argument `n` is equivalent to `([[multi-factorial]]\n  n 2)`, but slightly more general in that it can handle negative values of\n  `n`.\n\n  If `n` is negative and even, returns `##Inf`.\n\n  If `n` is negative and odd, returns `(/ (double-factorial (+ n 2)) (+ n 2))`.\n\n  For justification, see the [Wikipedia page on the extension of double\n  factorial to negative\n  arguments](https://en.wikipedia.org/wiki/Double_factorial#Negative_arguments).",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rW,$APP.wU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Ufb,$APP.X,b1,$APP.h,new $APP.f(null,2,[$APP.P,"Given `n` and `k`, returns the number of permutations of `n` elements which\n  contain exactly `k` [permutation\n  cycles](https://mathworld.wolfram.com/PermutationCycle.html). This is called\n  the [Stirling number s(n, k) of the first\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind).\n\n  By default, returns the [signed Stirling number of the first\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind#Signs).\n  Pass the `:unsigned? true` keyword option to retrieve the signed Stirling\n  number. (Or take the absolute value of the result...)\n\n  ```clj\n  (stirling-first-kind 13 2)\n  ;;\x3d\x3e -1486442880\n\n  (stirling-first-kind 13 2 :unsigned? true)\n  ;;\x3d\x3e 1486442880\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,4,5,$APP.I,[$APP.wU,$APP.vU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[prb],null)],null)],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,4,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M(rW,$APP.vU),$APP.M($APP.Xv,0,$APP.vU),$APP.M($APP.Xv,0,$APP.wU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,B7b,$APP.X,a1,$APP.h,new $APP.f(null,2,[$APP.P,'Returns the [binomial\n  coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient), i.e., the\n  coefficient of the $x^k$ term in the polynomial expansion of the binomial\n  power $(1 + x)^n$.\n\n  This quantity is sometimes pronounced "n choose k".\n\n  For negative `n` or `k`, [[binomial-coefficient]] matches the behavior\n  provided by Mathematica, described at [this\n  page](https://mathworld.wolfram.com/BinomialCoefficient.html). Given negative\n  `n`, returns\n\n  ```clj\n  ;; for k \x3e\x3d 0\n  (* (expt -1 k)\n     (binomial-coefficient (+ (- n) k -1) k))\n\n  ;; for k \x3e\x3d 0\n  (* (expt -1 (- n k))\n     (binomial-coefficient (+ (- k) -1) (- n k)))\n\n  ;; otherwise:\n  0\n  ```',
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M(rW,$APP.vU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,fbb,$APP.X,$0,$APP.h,new $APP.f(null,2,[$APP.P,"generic rising-factorial.\n\nReturns the [rising\n  factorial](https://en.wikipedia.org/wiki/Falling_and_rising_factorials), of\n  `a` to the `b`, defined as the polynomial\n\n  $$(a)^b \x3d a^{\\overline{b}} \x3d a(a + 1)(a + 2) \\cdots (a + b - 1)$$\n\n  Given a negative `b`, `([[rising-factorial]] a b)` is equivalent\n  to `(invert ([[falling-factorial]] (dec a) (- b)))`, or `##Inf` if the\n  denominator evaluates to 0.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,jAb,$APP.X,$0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,jbb,$APP.X,qXa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns $S(n,k)$, the number of ways to partition a set of `n` objects into `k`\n  non-empty subsets.\n\n  This is called a [Stirling number of the second\n  kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind).",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,
$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,4,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M(rW,$APP.vU),$APP.M($APP.Xv,0,$APP.vU),$APP.M($APP.Xv,0,$APP.wU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,gac,$APP.X,Z0,$APP.h,$APP.F],null)]),$APP.ap(gSb)),$APP.cp(new $APP.f(null,3,[$APP.z(W0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,jW],null)))],null)),new $APP.f(null,3,[$APP.Q,g9b,$APP.X,w6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,
5,$APP.I,[zU,jW],null))],null)],null),$APP.z(Fkb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[VU,jW,qW],null)))],null)),new $APP.f(null,3,[$APP.Q,KAb,$APP.X,x6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[VU,jW,qW],null))],null)],null),$APP.z(zSb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[jW,$APP.Dw,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[OT],null),$APP.Ml,new $APP.f(null,1,[OT,!1],null)],
null)],null))),$APP.P,"Takes a `metric` and a `spec` and returns the [Hodge star\n  operator](https://en.wikipedia.org/wiki/Hodge_star_operator) (actually just a\n  function, but I suspect this should be a proper operator!)\n\n  `spec` may be:\n\n  - a coordinate system with an orthonormal basis\n  - an orthonormal basis\n  - a basis\n\n  if the spec is a basis that needs to be orthonormalized, the optional\n  `:orthonormalize?` keyword argument must be a coordinate system.",$APP.ky,new $APP.f(null,
6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(jW,$APP.Dw,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[OT],null),$APP.Ml,new $APP.f(null,1,[OT,!1],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[jW,$APP.Dw,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[OT],null),$APP.Ml,new $APP.f(null,1,[OT,!1],null)],null)],null)),$APP.Cx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.Q,Nbb,$APP.X,XP,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a `metric` and a `spec` and returns the [Hodge star\n  operator](https://en.wikipedia.org/wiki/Hodge_star_operator) (actually just a\n  function, but I suspect this should be a proper operator!)\n\n  `spec` may be:\n\n  - a coordinate system with an orthonormal basis\n  - an orthonormal basis\n  - a basis\n\n  if the spec is a basis that needs to be orthonormalized, the optional\n  `:orthonormalize?` keyword argument must be a coordinate system.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[jW,$APP.Dw,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[OT],null),$APP.Ml,new $APP.f(null,1,[OT,!1],null)],null)],null))],null)],null)],null),$APP.ap(Cib)),$APP.cp($APP.fg([$APP.z(rzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null)))],null)),$APP.z(qT,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null)))],null)),$APP.z(dxb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
5,5,$APP.I,[$APP.Yw,sS,qT,lqb,a8b],null)))],null)),$APP.z(PY,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null)))],null)),xTb,$APP.z(hcc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,Jqb,$APP.Kv],null)))],null)),$APP.z(Kfb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null)))],null)),$APP.z(zsb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[rT,iS],null),new $APP.f(null,
1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dY,iS),$APP.M($APP.bw,$APP.M($APP.tv,iS),4)],null)],null))))],null)),$APP.z(X7b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,Jqb,$APP.Kv],null)))],null)),AJb,$APP.z(z_b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hec,Z1b],null)))],null)),$APP.z(sTb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null)))],null)),$APP.z($sb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))),$APP.P,"velocities must be in meters/second, since we don't yet have units support."],null))],[new $APP.f(null,3,[$APP.Q,v0b,$APP.X,tab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null))],null)],null),new $APP.f(null,3,[$APP.Q,MXb,$APP.X,Aab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vfb,$APP.X,xab,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Yw,sS,qT,lqb,a8b],null))],null)],null),new $APP.f(null,3,[$APP.Q,QBb,$APP.X,Bab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null))],null)],null),new $APP.f(null,3,[$APP.Q,yMb,$APP.X,rsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,sGb,$APP.X,yab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,Jqb,$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.Q,hVb,$APP.X,sab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.pW],null))],null)],null),new $APP.f(null,3,[$APP.Q,wbc,$APP.X,SR,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[rT,iS],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dY,iS),$APP.M($APP.bw,$APP.M($APP.tv,iS),4)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,fAb,$APP.X,zab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Kv,Jqb,$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.Q,d7b,$APP.X,qsc,$APP.h,
$APP.F],null),new $APP.f(null,3,[$APP.Q,Lcc,$APP.X,Dab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[hec,Z1b],null))],null)],null),new $APP.f(null,3,[$APP.Q,asb,$APP.X,Cab,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null))],null)],null),new $APP.f(null,3,[$APP.Q,$2b,$APP.X,Eab,$APP.h,new $APP.f(null,2,[$APP.P,"velocities must be in meters/second, since we don't yet have units support.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))],
null)],null)]),$APP.ap(Rbc)),$APP.cp($APP.fg([XNb,$APP.z(tEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),$APP.P,"[[gradient]] implements equation (10.3) in Functional Differential Geometry,\n  defined on page 154."],null)),AQb,zBb,$APP.z(ndb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))],null)),$APP.z(HOb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,EV],null)))],null)),$APP.z(R4b,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mT],null)))],null)),$APP.z(Rtb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,EV],null))),$APP.P,"[[curl]] implements equation (10.7) of Functional Differential Geometry,\n  defined on page 155."],null)),VDb,$APP.z(SIb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[jW,EV],null))),$APP.P,"Both arities of [[divergence]] are defined on page 156 of Functional Differential Geometry.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[jW,EV],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[jW,EV],null)),$APP.Cx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.Q,o3b,$APP.X,xrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Dgb,$APP.X,y6a,$APP.h,new $APP.f(null,2,[$APP.P,"[[gradient]] implements equation (10.3) in Functional Differential Geometry,\n  defined on page 154.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,gMb,$APP.X,yrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Fzb,$APP.X,zrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,bzb,$APP.X,B6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,vOb,$APP.X,A6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,EV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Lbc,$APP.X,
function(a){var b=aP(a),c=B6a(a),d=HO.j(rO(a));return eL(d,ZK,function(g){return kG.A($APP.x.A(b,g),SF.A(1,YH.C($APP.y([$APP.C.A(c,g),FO(a)]))))})},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[mT],null))],null)],null),new $APP.f(null,3,[$APP.Q,F5b,$APP.X,z6a,$APP.h,new $APP.f(null,2,[$APP.P,"[[curl]] implements equation (10.7) of Functional Differential Geometry,\n  defined on page 155.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,EV],null))],null)],null),new $APP.f(null,3,
[$APP.Q,sdc,$APP.X,P3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,eOb,$APP.X,YP,$APP.h,new $APP.f(null,2,[$APP.P,"Both arities of [[divergence]] are defined on page 156 of Functional Differential Geometry.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[jW,EV],null))],null)],null)]),$APP.ap(KQb)),$APP.cp(new $APP.f(null,5,[Ujb,new $APP.f(null,3,[$APP.Q,zlb,$APP.X,N3,$APP.h,new $APP.f(null,4,[$APP.P,"similar to a `let` binding that holds pairs of\n\n  \x3ccoordinate-structure-prototype\x3e, \x3ccoordinate-system\x3e\n\n  And internally binds, for each pair: (take `[x y]` and `m/R2-rect` as\n  examples):\n\n  - The coordinate system symbol `R2-rect` to a new version of the coordinate\n    system with its `coordinate-prototype` replaced by the one you supplied.\n    That's `(up x y)` in this example.\n\n  - the entries `x` and `y` to coordinate functions, i.e., functions from manifold\n    point to this particular coordinate\n\n  - `d:dx` and `d:dy` vector field procedures (I'm fuzzy here!)\n\n  - `dx` and `dy` 1-forms for each coordinate (fuzzy here too!)\n\n  Example:\n\n  ```clojure\n  (let-coordinates [[x y]    R2-rect\n                   [r theta] R2-polar]\n    ;; bindings:\n    ;; R2-rect, x, y, d:dx, d:dy, dx, dy\n    ;; R2-polar, r, theta, d:dr, d:dtheta, dr, dtheta\n    body...)\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Fw,$APP.Lh,$APP.Tw],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),Ibb,new $APP.f(null,3,[$APP.Q,hUb,$APP.X,function(a,b,c,d){a=$APP.rg.B(b,BX,!0);b=$APP.Zg.j($APP.Ag(d));var g=$APP.Oj.j([$APP.m.j(b),"-values"].join("")),l=M3(c),n=$APP.Vg.A(Z3a,l),p=$APP.Vg.A(x4a,l);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Qh,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,tCb,null,1,null),new $APP.D(null,b,null,1,null),$APP.y([new $APP.D(null,
$APP.T.j($APP.r($APP.N.C(new $APP.D(null,jWb,null,1,null),new $APP.D(null,d,null,1,null),$APP.y([new $APP.D(null,Q5a(c),null,1,null)])))),null,1,null)])))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.di,null,1,null),new $APP.D(null,g,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.mqa,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.J()))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
t$b,null,1,null),new $APP.D(null,$APP.tf($APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,jS,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,NX,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,xT,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null)]))))),null,1,null)))),null,1,null)])))),null,1,null)])))),null,1,null),
$APP.ip.A(function(v,t){return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,tCb,null,1,null),new $APP.D(null,t,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.UCa,null,1,null),new $APP.D(null,g,null,1,null),$APP.y([new $APP.D(null,v,null,1,null)])))),null,1,null)]))))},$APP.N.C(l,n,$APP.y([p]))),new $APP.D(null,$APP.k(BX.j(a))?$APP.T.j($APP.r($APP.N.C(new $APP.D(null,fEb,null,1,null),new $APP.D(null,$APP.ox,null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,
$APP.K,null,1,null),new $APP.D(null,g,null,1,null)))),null,1,null)])))):$APP.T.j($APP.r($APP.N.C(new $APP.D(null,$APP.Zh,null,1,null),new $APP.D(null,g,null,1,null),$APP.y([new $APP.D(null,null,null,1,null)])))),null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,$APP.ai,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null)]))))},$APP.h,new $APP.f(null,4,[$APP.P,"Give some `coordinate-system` like `R2-rect` and a `coordinate-prototype` like\n  `[x y]` or `(up x y), `binds the following definitions into the namespace\n  where [[define-coordinates]] is invoked:\n\n  - `R2-rect` binds to a new version of the coordinate system with its\n    `coordinate-prototype` replaced by the supplied prototype\n\n  - `x` and `y` bind to coordinate functions, i.e., functions from manifold point\n  to that particular coordinate\n\n  - `d:dx` and `d:dy` bind to the corresponding vector field procedures\n\n  - `dx` and `dy` bind to 1-forms for each coordinate.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[pU,qW],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),pCb,new $APP.f(null,3,[$APP.Q,w1b,$APP.X,O3,$APP.h,new $APP.f(null,4,[$APP.P,"[[using-coordinates]] wraps [[let-coordinates]] and allows you to supply a\n  single coordinate prototype and a single coordinate system.\n  See [[let-coordinates]] for details about what symbols are bound inside the\n  body.\n\n  Example:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect\n                     body...)\n  ```",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[pU,qW,$APP.Lh,$APP.Tw],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),$APP.z(NNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),$APP.P,"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point \x3d\x3e\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`."],null)),new $APP.f(null,
3,[$APP.Q,jS,$APP.X,P5a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point \x3d\x3e\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),$APP.z(Dyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,
"Scmutils wants to allow forms like this:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect ...)\n  ```\n\n   Note that `x`, `y` are unquoted. This function converts such an unquoted form\n  into a quoted one that could be evaluated to return an up-tuple of the\n  symbols:\n\n  ```clojure\n  (up 'x 'y)\n  ```\n\n  Such an object is useful for [[structure/mapr]]."],null)),new $APP.f(null,3,[$APP.Q,Lac,$APP.X,Q5a,$APP.h,new $APP.f(null,2,[$APP.P,"Scmutils wants to allow forms like this:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect ...)\n  ```\n\n   Note that `x`, `y` are unquoted. This function converts such an unquoted form\n  into a quoted one that could be evaluated to return an up-tuple of the\n  symbols:\n\n  ```clojure\n  (up 'x 'y)\n  ```\n\n  Such an object is useful for [[structure/mapr]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null)],null),$APP.ap(ADb)),$APP.cp(new $APP.f(null,4,[$APP.z(xbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),$APP.P,"Returns true if the supplied object is an instance of [[Function]], false\n  otherwise."],null)),new $APP.f(null,3,[$APP.Q,SKb,$APP.X,q2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied object is an instance of [[Function]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Nv],null))],null)],null),$APP.z(Mrb,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,6,[mU,"null",UW,"null",YE,"null",NY,"null",iV,"null",TV,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[PZb,aU,eU,$APP.By],null))),YR,new $APP.ug(null,new $APP.f(null,3,[mU,"null",UW,"null",iV,"null"],null),null),$APP.P,"Positional factory function for emmy.abstract.function/Function."],null)),new $APP.f(null,3,[$APP.Q,f5b,$APP.X,UN,$APP.h,new $APP.f(null,
2,[$APP.P,"Positional factory function for emmy.abstract.function/Function.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[PZb,aU,eU,$APP.By],null))],null)],null),Cpb,new $APP.f(null,3,[$APP.Q,QVb,$APP.X,XN,$APP.h,new $APP.f(null,3,[$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[pIb,$APP.Lh,$APP.Tw],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),$APP.z(Znb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,Nzb],null),new $APP.H(null,3,
5,$APP.I,[$APP.Nv,eU,$APP.By],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,Nzb],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,eU,$APP.By],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,Nzb],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,eU,$APP.By],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),new $APP.f(null,
3,[$APP.Q,WN,$APP.X,VN,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,Nzb],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,eU,$APP.By],null))],null)],null)],null),$APP.ap(Yac)),$APP.cp($APP.fg([$APP.z(NZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WV],null)))),lU,$APP.M($APP.K,enb)],null)),$APP.z(FLb,new $APP.f(null,3,[$APP.P,"Find the minimum of the function f: R^n -\x3e R, given an initial point q ∈ R^n.\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked with iteration count,\n  the values of X and the value of f(X) at each intermediate point of\n  evaluation.\n\n  `:info?` if true, wraps the result with evaluation information.\n\n  `:adaptive?` if true, the Nelder-Mead parameters for contraction, expansion,\n  reflection and shrinking will be set adaptively, as functions of the number of\n  dimensions. If false they stay constant.\n\n  `:alpha` sets the reflection coefficient used for each step of Nelder-Mead.\n\n  `:beta` sets the expansion coefficient used for each step of Nelder-Mead.\n\n  `:gamma` sets the contraction coefficient used for each step of Nelder-Mead.\n\n  `:sigma` sets the shrink coefficient used for each step of Nelder-Mead.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  200*dimension.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 200*dimension.\n\n  `:simplex-tolerance` When the absolute value of the max difference between the\n  best point and any point in the simplex falls below this tolerance, the\n  minimizer stops. Defaults to 1e-4.\n\n  `:fn-tolerance` When the absolute value of the max difference between the best\n  point's function value and the fn value of any point in the simplex falls\n  below this tolerance, the minimizer stops. Defaults to 1e-4.\n\n  `:zero-delta` controls the value to which 0 entries in the initial vector are\n  set during initial simplex generation. Defaults to 0.00025.\n\n  `:nonzero-delta` factor by which entries in the initial vector are perturbed to\n  generate the initial simplex. Defaults to 0.05.\n\n  See Gao, F. and Han, L.\n      Implementing the Nelder-Mead simplex algorithm with adaptive\n      parameters. 2012. Computational Optimization and Applications.\n      51:1, pp. 259-277\n  I gratefully acknowledge the [Python implementation in\n  SciPy](https://github.com/scipy/scipy/blob/589c9afe41774ee96ec121f1867361146add8276/scipy/optimize/optimize.py#L556:5)\n  which I have imitated here.\n  ",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Iy,$APP.PW,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.Gw],null),$APP.dk,$APP.Ox],null)],null)))),lU,$APP.M($APP.K,KUb)],null)),$APP.z(nX,new $APP.f(null,3,[$APP.P,"generic quotient",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,k6b)],null)),$APP.z(Qqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.DU],
null)))),lU,$APP.M($APP.K,Ptb)],null)),$APP.z(ACb,new $APP.f(null,3,[$APP.P,"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null)))),lU,$APP.M($APP.K,LLb)],null)),$APP.z(p5a,new $APP.f(null,3,[$APP.P,"Takes a system derivative `R` and returns a operator that takes a function `F`\n  of coordinatized state and performs the operation described below, from\n  ODE.scm in scmutils:\n\n  Let `(sigma t)` be the state of a system at time `t`. Let the\n  (first-order) system of differential equations governing the evolution of\n  this state be:\n\n  ```clojure\n  ((D sigma) t) \x3d (R (sigma t))\n  ```\n\n  ```clojure\n  (D sigma) \x3d (compose R sigma)\n  ```\n\n  i.e. `R` is a system derivative.\n\n  Let `F` be any function of state, then a differential equation for the\n  evolution of `F`, as it is dragged along the integral curve sigma is:\n\n  ```clojure\n  (D (compose F sigma)) \x3d (* (compose (D F) sigma) (D sigma))\n  \x3d (compose (* (D F) R) sigma)\n  ```\n\n  Let's call this operation `Lie-D` (the Lie derivative for coordinates).",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null)))),lU,$APP.M($APP.K,Fjb)],null)),$APP.z(PCb,new $APP.f(null,3,[$APP.P,"Returns a row matrix populated by the supplied `xs`. Variadic equivalent\n  to [[row*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))),lU,$APP.M($APP.K,h7b)],null)),$APP.z(nxb,new $APP.f(null,3,[$APP.P,"Returns a data structure representing [Christoffel symbols of the first\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_first_kind).",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[FX,VU],null)))),lU,$APP.M($APP.K,sbb)],null)),$APP.z(zSb,new $APP.f(null,3,[$APP.P,"Takes a `metric` and a `spec` and returns the [Hodge star\n  operator](https://en.wikipedia.org/wiki/Hodge_star_operator) (actually just a\n  function, but I suspect this should be a proper operator!)\n\n  `spec` may be:\n\n  - a coordinate system with an orthonormal basis\n  - an orthonormal basis\n  - a basis\n\n  if the spec is a basis that needs to be orthonormalized, the optional\n  `:orthonormalize?` keyword argument must be a coordinate system.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[jW,$APP.Dw,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[OT],null),$APP.Ml,new $APP.f(null,1,[OT,!1],null)],null)],null))),lU,$APP.M($APP.K,Nbb)],null)),$APP.z(ZKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.FU,xU,KW,LW],null),new $APP.H(null,5,5,$APP.I,[$APP.FU,xU,KW,LW,ZV],null))),lU,$APP.M($APP.K,y1b)],null)),$APP.z($nb,new $APP.f(null,3,[$APP.P,"Returns true if `x` implements [[IFrame]], false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,gxb)],null)),$APP.z(d4b,new $APP.f(null,3,[$APP.P,"Alias for [[solve-linear]]; present for compatibility with the original\n  `scmutils` codebase.\n\n  NOTE: In `scmutils`, `solve-linear-left` and `solve-linear` act identically in\n  all cases except matrices. `solve-linear-left` only accepted a column\n  matrix (or up structure) in the `b` position, while `solve-linear` accepted\n  either a column or row (up or down structure).\n\n  In Emmy, both functions accept either type.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,KLb)],null)),$APP.z(Oab,new $APP.f(null,3,[$APP.P,"SICM p. 23. The optional parameter values is a callback which will report\n  intermediate points of the minimization.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,8,5,$APP.I,[bY,JW,CW,KW,DW,$APP.wU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[dW],null)],null)],null))),lU,$APP.M($APP.K,cKb)],null)),$APP.z(umb,new $APP.f(null,
3,[$APP.P,"Marks (via metadata) the supplied set of `coords` as being owned by `owner`. If\n  `coords` already has an owner (that is not equal to `owner`), throws.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.pW,h6b],null)))),lU,$APP.M($APP.K,Ffb)],null)),$APP.z(gS,new $APP.f(null,3,[$APP.P,"generic remainder.\n\nReturns the remainder of dividing the dividend `a` by divisor `b`.\n\n The contract satisfied by [[remainder]] is:\n\n```clojure\n(\x3d a (+ (* b (quotient a b))\n        (remainder a b)))\n```\n\n For numbers, this differs from the contract offered by [[modulo]]\n because [[quotient]] rounds toward 0, while `(floor (/ a b))` rounds toward\n negative infinity.\n\n The result will be either `0` or of the same sign as the dividend `a`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,w9b)],null)),$APP.z(b$b,new $APP.f(null,3,[$APP.P,"generic identity-like.\n\nLike `one-like` but works for square matrices.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,i4b)],null)),$APP.z(xMb,new $APP.f(null,3,[$APP.P,"[Chinese Remainder Algorithm](https://en.wikipedia.org/wiki/Chinese_remainder_theorem).\n\n  Accepts a sequence of [[ModInt]] instances (where the `modulus` of\n  all [[ModInt]] instances are relatively prime), and returns a [[ModInt]] `x`\n  such that `(residue input) \x3d\x3d (mod x (modulus input))`.\n\n  For example:\n\n  ```clojure\n  (let [a1 (m/make 2 5)\n        a2 (m/make 3 13)]\n    [(\x3d 42 (chinese-remainder a1 a2))\n     (\x3d (residue a1) (mod cr (modulus a1)))\n     (\x3d (residue a2) (mod cr (modulus a2)))])\n  ;;\x3d\x3e [true true true]\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oX],null))),lU,$APP.M($APP.K,pbb)],null)),$APP.z(Hsb,new $APP.f(null,3,[$APP.P,"Return a [[PowerSeries]] starting with the supplied values. The remainder of\n  the series will be filled with the zero-value corresponding to the first of\n  the given values.\n\n  If you have a sequence already, prefer [[power-series*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null))),lU,$APP.M($APP.K,z2b)],null)),$APP.z(dKb,
new $APP.f(null,1,[lU,$APP.M($APP.K,Mwb)],null)),$APP.z(XNb,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that\n  calculates the [Divergence](https://en.wikipedia.org/wiki/Divergence) of\n  `f` at its input point.\n\n  The divergence is a one-level contraction of the gradient.",lU,$APP.M($APP.K,o3b)],null)),pCb,$APP.z(gW,new $APP.f(null,3,[$APP.P,"generic csch.\n\nComputes the [hyperbolic\n cosecant](https://mathworld.wolfram.com/HyperbolicCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / sinh(x)`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,b9b)],null)),$APP.z(Ywb,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector α radians about the y axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),lU,$APP.M($APP.K,dbc)],null)),$APP.z(UUb,new $APP.f(null,1,[lU,$APP.M($APP.K,eDb)],null)),$APP.z(nib,new $APP.f(null,3,[$APP.P,"SICM p. 47. Polar to rectangular coordinates of state.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GX],null)))),lU,$APP.M($APP.K,d9b)],null)),$APP.z(Kwb,new $APP.f(null,1,[lU,$APP.M($APP.K,Uob)],null)),$APP.z(Kvb,new $APP.f(null,3,[$APP.P,"p. 334",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))),lU,$APP.M($APP.K,vUb)],null)),$APP.z(oFb,new $APP.f(null,3,[$APP.P,"Alternative definition of [[wedge]] in terms of alternation.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null))),
lU,$APP.M($APP.K,qmb)],null)),$APP.z(Qlb,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null))),lU,$APP.M($APP.K,p_b)],null)),$APP.z(aob,new $APP.f(null,2,[$APP.P,"Alias for [[time]].",lU,$APP.M($APP.K,EDb)],null)),$APP.z(NHb,new $APP.f(null,1,[lU,$APP.M($APP.K,B0b)],null)),$APP.z(FT,new $APP.f(null,3,[$APP.P,"generic make-polar",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,gcc)],null)),$APP.z(QV,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is a form field operator, false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SVb],null)))),lU,$APP.M($APP.K,qec)],null)),$APP.z($vb,new $APP.f(null,3,[$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.Qx],null)))),lU,$APP.M($APP.K,g6b)],null)),$APP.z(oU,new $APP.f(null,3,[$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),lU,$APP.M($APP.K,Asb)],null)),$APP.z(vV,new $APP.f(null,3,[$APP.P,"generic cube",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,q_b)],null)),$APP.z(Qwb,new $APP.f(null,1,[lU,$APP.M($APP.K,Mob)],null)),$APP.z(zP,new $APP.f(null,3,[$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,$APP.ix],null))),lU,$APP.M($APP.K,NP)],null)),$APP.z(tEb,new $APP.f(null,3,[$APP.P,"[[gradient]] implements equation (10.3) in Functional Differential Geometry,\n  defined on page 154.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))),lU,$APP.M($APP.K,Dgb)],null)),$APP.z(zXb,new $APP.f(null,3,[$APP.P,"generic tanc.\n\n`tanc` is defined, by analogy with [[sinc]], to be equal to $\\frac{\\tan\n  x}{x}$ for nonzero $x$ and equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/TancFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,uLb)],null)),$APP.z(aSb,new $APP.f(null,3,[$APP.P,"generic determinant",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Xqb)],null)),$APP.z(ueb,new $APP.f(null,3,[$APP.P,"Extract the dual basis from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,
new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null))))),lU,$APP.M($APP.K,reb)],null)),$APP.z(VCb,new $APP.f(null,3,[$APP.P,"Make a basis object out of a vector and dual basis.\n\n  The dimensions of `vector-basis` and `dual-basis` must agree.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,tW],null)))),lU,$APP.M($APP.K,W$b)],null)),$APP.z(yH,new $APP.f(null,3,[$APP.P,"generic sinh.\n\nComputes the [hyperbolic\n sine](https://mathworld.wolfram.com/HyperbolicSine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x - e^{-x}) / 2`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,fJb)],null)),$APP.z(Tfb,new $APP.f(null,3,[$APP.P,"Given a metric and a basis, computes the inverse metric.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))),lU,$APP.M($APP.K,Teb)],null)),$APP.z(fDb,new $APP.f(null,3,[$APP.P,"Find the minimum of the function f: R -\x3e R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id\x3dAITCAgAAQBAJ\x26q\x3dBrent%E2%80%99s#v\x3donepage\x26q\x3dParabolic\x26f\x3dfalse).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  [[brent-min]] supports the following optional keyword arguments:\n\n  - `:callback`: if supplied, the supplied fn will be invoked at each\n    intermediate point with the iteration count and the values of x and f(x) at\n    each search step.\n\n  - `:initial-guess`: the first internal point checked by the algorithm. Defaults\n    to `([[initial-brent-guess]] a b)`.\n\n  - `:relative-threshold`: multiplied by each guess to determine a relative\n    threshold. Defaults to 1.0e-11.\n\n  - `:absolute-threshold`: a smaller absolute threshold that applies when the\n    candidate minimum point is close to 0. defaults to around 1.49e8, the sqrt of\n    the machine tolerance. You won't gain any benefit attempting to set the value\n    less than the default.\n\n  - `:maxiter`: Maximum number of iterations allowed for the minimizer. Defaults\n    to 1000.\n\n  - `:maxfun`: Maximum number of times the function can be evaluated before\n    exiting. Defaults to `(inc maxiter)`.\n  ",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,6,5,$APP.I,[PT,RT,RY,KT,uX,$APP.Gw],null),$APP.Ml,new $APP.f(null,5,[PT,AV,RT,QY,RY,$APP.M(WT,$APP.Lv,$APP.sU),KT,1E3,$APP.Gw,$APP.M($APP.fw,null)],null)],null)],null))),lU,$APP.M($APP.K,Tjb)],null)),$APP.z(G7b,new $APP.f(null,2,[$APP.P,"Alias for [[/]].",lU,$APP.M($APP.K,r_b)],null)),$APP.z(CJb,new $APP.f(null,3,[$APP.P,
"Given a symbolic name `sym` and a `coordinate-system`, returns a one-form field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3eoneform-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-form-field`'s component\n  functions will accept a single non-structural argument.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,qW],null)))),lU,$APP.M($APP.K,EPb)],null)),$APP.z(Uwb,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector α radians about the x axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),lU,$APP.M($APP.K,Xac)],null)),$APP.z(uOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Gx,VU],null)))),lU,$APP.M($APP.K,uhb)],null)),$APP.z($ac,new $APP.f(null,3,[$APP.P,"One of the two incompatible definitions of differential.\n\n  This differential is a special case of exterior derivative. The other one\n  lives at [[map/differential]].",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(CHb,$APP.Nv)],null)],null))))),lU,$APP.M($APP.K,Ueb)],null)),$APP.z(Cdb,new $APP.f(null,2,[$APP.P,"Converts an S-expression to printable infix form. Numeric exponents are\n  written as superscripts. Partial derivatives get subscripts.",lU,$APP.M($APP.K,nHb)],null)),$APP.z(WX,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a basis, false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,GWb)],null)),$APP.z(MYb,new $APP.f(null,3,[$APP.P,"Returns the single column from the supplied column matrix as a vector. Errors\n  if some other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(qY,$APP.Qr)],null)],null))))),lU,$APP.M($APP.K,XDb)],null)),$APP.z(EQb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[jW,VU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rS,VU)],null)],null))))),lU,$APP.M($APP.K,Mbc)],null)),$APP.z($APP.hU,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from coordinates in\n  `coordinate-system`'s repesentation to the matching point on the manifold\n  associated with `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,a$b)],null)),$APP.z(zwb,new $APP.f(null,1,[lU,$APP.M($APP.K,sob)],null)),Cpb,$APP.z(mH,new $APP.f(null,3,[$APP.P,"generic sin.\n\nReturns the [sine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,pib)],null)),$APP.z(AQb,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that\n  calculates the [Curl](https://en.wikipedia.org/wiki/Curl_(mathematics)) of `f`\n  at its input point.\n\n  `f` must be a function from $\\mathbb{R}^3 \\to \\mathbb{R}^3$.",
lU,$APP.M($APP.K,gMb)],null)),$APP.z(zBb,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that calculates\n  the [Vector\n  Laplacian](https://en.wikipedia.org/wiki/Laplace_operator#Vector_Laplacian) of\n  `f` at its input point.",lU,$APP.M($APP.K,Fzb)],null)),$APP.z(lib,new $APP.f(null,3,[$APP.P,"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.ix],
null)))),lU,$APP.M($APP.K,xdc)],null)),$APP.z(r0b,new $APP.f(null,1,[lU,$APP.M($APP.K,x_b)],null)),$APP.z(FVb,new $APP.f(null,1,[lU,$APP.M($APP.K,sAb)],null)),$APP.z(w6b,new $APP.f(null,3,[$APP.P,"generic exact-divide.\n\nSimilar to the binary case of [[/]], but throws if `(g/exact? \x3cresult\x3e)`\n  returns false.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,l2b)],null)),$APP.z(FFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null)))),lU,$APP.M($APP.K,BAb)],null)),$APP.z(nK,new $APP.f(null,3,[$APP.P,"generic tan.\n\nComputes the trigonometric tangent function of the supplied argument `a`.\n\nEquivalent to `(/ (sin a) (cos a))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,OBb)],null)),$APP.z(B_b,new $APP.f(null,3,[$APP.P,"generic solve-linear.\n\nFor a given `a` and `b`, returns `x` such that `a*x \x3d b`.\n\n  See[[solve-linear-right]] for a similar function that solves for `a \x3d x*b`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,Xbc)],null)),$APP.z(K1b,new $APP.f(null,3,[$APP.P,"generic freeze.\n\nFreezing an expression means removing wrappers and other metadata from\n  subexpressions, so that the result is basically a pure S-expression with the\n  same structure as the input. Doing this will rob an expression of useful\n  information for further computation; so this is intended to be done just\n  before simplification and printing, to simplify those processes.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,LUb)],null)),$APP.z(rzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null)))),lU,$APP.M($APP.K,v0b)],null)),$APP.z(dvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[ZT],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(IT,ZT)],null)],null))))),lU,$APP.M($APP.K,xJb)],null)),$APP.z(klb,
new $APP.f(null,3,[$APP.P,"Extract the dimension from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null))))),lU,$APP.M($APP.K,Kub)],null)),$APP.z($APP.CY,new $APP.f(null,3,[$APP.P,"generic dimension",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Xcb)],null)),$APP.z(Uub,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))),lU,$APP.M($APP.K,d_b)],null)),$APP.z(u8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null)))),lU,$APP.M($APP.K,vwb)],null)),$APP.z(Rob,new $APP.f(null,3,[$APP.P,"For making a (0,2) tensor into a (2,0) tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null)))),lU,$APP.M($APP.K,ajb)],null)),$APP.z(QPb,new $APP.f(null,3,[$APP.P,"Returns the owning [[IFrame]] instance of the supplied coordinates `coords`,\n  nil if there's no owner otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null)))),lU,$APP.M($APP.K,ELb)],null)),$APP.z(oxb,new $APP.f(null,1,[lU,$APP.M($APP.K,Eob)],null)),$APP.z(mdb,new $APP.f(null,1,[lU,$APP.M($APP.K,O6b)],null)),$APP.z(ljb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,3,5,$APP.I,[$APP.Lv,$APP.Lh,yW],null))),$APP.P,"A shim so that ref can act like nth in SICM contexts, as clojure core ref\n  elsewhere.",$APP.ky,new $APP.f(null,
6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,3,5,$APP.I,[$APP.Lv,$APP.Lh,yW],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(vjb,new $APP.f(null,3,[$APP.P,"Returns the Jacobian of transition from `from-basis` to `to-basis`.\n\n  The Jacobian is a structure of manifold functions. The outer index is the\n  from-basis index, so this structure can be multiplied by tuple of component\n  functions of a vector field relative to `from-basis` to get component\n  functions for a vector field in `to-basis`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wsb,DMb],null)))),lU,$APP.M($APP.K,dQb)],null)),$APP.z(Ssb,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of α radians about the y axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),lU,$APP.M($APP.K,isb)],null)),$APP.z(Fnb,new $APP.f(null,3,[$APP.P,"generic tanhc.\n\nThe [tanhc function](https://en.wikipedia.org/wiki/Tanhc_function),\n  equivalent to $\\frac{\\tanh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanhc_function)\n   - [Mathworld page on Tanhc](https://mathworld.wolfram.com/TanhcFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,cfb)],null)),$APP.z(uH,new $APP.f(null,3,[$APP.P,"generic cos.\n\nReturns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,RDb)],null)),$APP.z(pGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),$APP.P,
"Returns a string containing a LaTeX representation of `expr`, wrapped in single\n  `$` to mark the string as an inline LaTeX form."],null)),$APP.z(kgb,new $APP.f(null,3,[$APP.P,"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components-\x3evector-field\n     (up x y)\n     (coordinate-system-\x3evector-basis R2-rect)))\n  ;; \x3d\x3e (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[XV,zU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(KFb,XV,zU)],null)],null))))),lU,$APP.M($APP.K,yYb)],null)),$APP.z(rcc,new $APP.f(null,3,[$APP.P,"Returns the parameters registered with the supplied frame.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),lU,$APP.M($APP.K,EYb)],null)),$APP.z(s1b,new $APP.f(null,3,[$APP.P,"Given a structure `w` of and a vector field basis `vector-basis`, returns a new\n  structure generated by applying the full vector basis to each element of `w`.\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [vb    (vf/coordinate-system-\x3evector-basis coordsys)\n        basis (coordinate-system-\x3eoneform-basis coordsys)\n        components (down d:dx d:dy)]\n    (\x3d components\n       (-\x3e components\n           (basis-components-\x3eoneform-field basis)\n           (oneform-field-\x3ebasis-components vb))))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qyb,zU],null)))),lU,$APP.M($APP.K,URb)],null)),$APP.z(CAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))),lU,$APP.M($APP.K,MOb)],null)),$APP.z(k1b,new $APP.f(null,3,[$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns the result of aggregating either `xs` or `(map f (range low\n  high))` using the fold dynamically bound to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (sum inc 0 10))\n  ;;\x3d\x3e [55.0 1 10]\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null))),lU,$APP.M($APP.K,$gb)],null)),$APP.z(cmb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Yw,$APP.iy,bZb],null)))),lU,$APP.M($APP.K,FRb)],null)),$APP.z(kK,new $APP.f(null,3,[$APP.P,"generic gcd.\n\nReturns the [greatest common\n  divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the two\n  inputs `a` and `b`.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,ZTb)],null)),$APP.z(cdc,new $APP.f(null,3,[$APP.P,"generic exp10.\n\nReturns the base-10 exponential of `x`. Equivalent to `(expt 10 x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,sJb)],null)),$APP.z(P1b,new $APP.f(null,1,[lU,$APP.M($APP.K,pSb)],null)),$APP.z(qXb,new $APP.f(null,3,[$APP.P,"Returns a function that takes a single manifold `point` embedded in the\n  manifold `embedded` and transfers the point to the supplied `embedding`\n  manifold.\n\n  The embedding dimension must be the same for both manifolds.\n\n  NOTE that `embedded` and `embedding` can be either manifolds, or instances\n  of [[ICoordinateSystem]]. In the latter case `embedded` and `embedding` will\n  bind to the manifold associated with the supplied [[ICoordinateSystem]].",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[tKb,K9b],null)))),lU,$APP.M($APP.K,q$b)],null)),$APP.z(Icc,new $APP.f(null,3,[$APP.P,"generic cross-product",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,c5b)],null)),$APP.z(wwb,new $APP.f(null,3,[$APP.P,"Returns a predicate that returns true if its argument matches the supplied\n  kind-keyword `k`, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,HVb)],null)),$APP.z(h5a,new $APP.f(null,3,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null)))),lU,$APP.M($APP.K,CNb)],null)),$APP.z(apb,new $APP.f(null,3,[$APP.P,"Returns a data structure representing [Christoffel symbols of the second\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_second_kind_(symmetric_definition)).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[FX,VU],null)))),lU,$APP.M($APP.K,oac)],null)),$APP.z(Bnb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))),lU,$APP.M($APP.K,KXb)],null)),$APP.z(acc,new $APP.f(null,3,[$APP.P,"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gNb],
null)))),lU,$APP.M($APP.K,N5b)],null)),$APP.z(zRb,new $APP.f(null,3,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,xV],null)))),lU,$APP.M($APP.K,O0b)],null)),$APP.z(Rgb,new $APP.f(null,3,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null)))),lU,$APP.M($APP.K,LAb)],null)),$APP.z(gzb,new $APP.f(null,3,[$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,
1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null))))),lU,$APP.M($APP.K,H9b)],null)),$APP.z(otb,new $APP.f(null,3,[$APP.P,"Returns the velocity element of a local tuple (by convention, the third\n  element).\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),2)],null)],null))))),lU,$APP.M($APP.K,
qLb)],null)),$APP.z(cGb,new $APP.f(null,3,[$APP.P,"Legendre elliptic integral of the first kind F(φ, k).\n   See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.19\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[ZR,$APP.vU],null)))),lU,$APP.M($APP.K,J7b)],null)),$APP.z($X,new $APP.f(null,3,[$APP.P,"generic modulo.\n\nReturns the result of the\n  mathematical [Modulo](https://en.wikipedia.org/wiki/Modulo_operation)\n  operation between `a` and `b` (using the Knuth definition listed).\n\n The contract satisfied by [[modulo]] is:\n\n```clojure\n(\x3d a (+ (* b (floor (/ a b)))\n        (modulo a b)))\n```\n\n For numbers, this differs from the contract offered by [[remainder]]\n because `(floor (/ a b))` rounds toward negative infinity, while\n the [[quotient]] operation in the contract for [[remainder]] rounds toward 0.\n\n The result will be either `0` or of the same sign as the divisor `b`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,xlb)],null)),$APP.z(o0b,new $APP.f(null,3,[$APP.P,"Forward-mode derivative operator. Takes some function `f` and returns a\n  function whose value at some point can multiply an increment in the arguments\n  to produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D-forward]] computes a derivative. For vector-valued\n  functions, [[D-forward]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,Wxb)],null)),$APP.z(yub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[JU,VU],null)))),lU,$APP.M($APP.K,RNb)],null)),$APP.z($APP.sj,new $APP.f(null,3,[$APP.P,"Generic implementation of `/`.\n\n  If one argument is supplied, returns the multiplicative inverse of `a`. Else\n  returns the result of dividing first argument `a` by the product of all\n  remaining arguments. `(/)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core//`. Dispatch is open,\n  however, making it possible to 'divide' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (/ [2 4 6] 2)\n  ;;\x3d\x3e (up 1 2 3)\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))),lU,$APP.M($APP.K,Ypb)],null)),$APP.z(ydb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$W,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null)))),lU,$APP.M($APP.K,bIb)],null)),$APP.z(sS,new $APP.f(null,3,[$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),lU,$APP.M($APP.K,emb)],null)),$APP.z(fVb,new $APP.f(null,3,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,xV],null)))),lU,$APP.M($APP.K,TQb)],null)),
$APP.z(J3b,new $APP.f(null,3,[$APP.P,"Entrypoint for multidimensional minimization routines.\n\n  See [[emmy.numerical.multimin.nelder-mead/nelder-mead]] for the only\n  supported option.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Iy,$APP.PW,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[eY],null),$APP.dk,$APP.Ox],null)],null))),lU,$APP.M($APP.K,pMb)],null)),$APP.z(r5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[tyb],
null)))),lU,$APP.M($APP.K,QDb)],null)),$APP.z(u7b,new $APP.f(null,3,[$APP.P,"Returns a [[PowerSeries]] instance representing a\n  [Binomial series](https://en.wikipedia.org/wiki/Binomial_series), i.e., the\n  taylor series of the function $f$ given by\n\n  ```\n  $$f(x) \x3d (1 + x)^\\alpha$$\n  ```",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null)))),lU,$APP.M($APP.K,ohb)],null)),$APP.z(qT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[rT],null)))),lU,$APP.M($APP.K,MXb)],null)),$APP.z(wpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[iS],null)))),lU,$APP.M($APP.K,WMb)],null)),$APP.z($wb,new $APP.f(null,1,[lU,$APP.M($APP.K,ipb)],null)),$APP.z(jJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GX],null)))),lU,$APP.M($APP.K,nKb)],null)),$APP.z(ysb,new $APP.f(null,3,[$APP.P,"Returns the factorial of `n`, i.e., the product of 1 to `n` (inclusive).\n\n  [[factorial]] will return a platform-specific [[emmy.util/bigint]] given\n  some `n` that causes integer overflow.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M($APP.cw,$APP.wU,0)],null)],null))))),lU,$APP.M($APP.K,Sqb)],null)),$APP.z(edb,new $APP.f(null,1,[lU,$APP.M($APP.K,hrb)],null)),$APP.z(Izb,new $APP.f(null,1,[lU,$APP.M($APP.K,Pvb)],null)),$APP.z(BOb,new $APP.f(null,3,[$APP.P,"Golden Section search attempts to locate the minimum of the supplied function\n  `f` by evaluating points located at golden-ratioed intervals between the two\n  starting endpoints `a` and `b`. This method is slow, steady and reliable.\n\n  Supports the following optional keyword arguments:\n\n  `:converged?` is an optional predicate accepting five arguments:\n\n  - `[a fa]`\n  - `[l fl]`\n  - `[r fr]`\n  - `[b fb]`\n  - `current-iteration`\n\n  If the supplied `fn` returns true, it will signal convergence and the\n  optimizer will return. Returning false will continue.\n\n  `:choose` is called at the final step of optimization with all 4 points and\n  their fn values (see the first four arguments to `:converged?`), and returns\n  the final choice.\n\n  `:callback` receives all 5 arguments on every iteration.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n\n  `:fn-tolerance` check that the minimal value of any of the checked points is\n  within the maximum of f(a) or f(b).\n\n  `:arg-tolerance` check that `a` and `b` are within this supplied absolute\n  distance.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,2,5,$APP.I,[YX,$APP.Gw],null),$APP.Ml,new $APP.f(null,2,[YX,kW,$APP.Gw,$APP.M($APP.fw,null)],null),$APP.dk,$APP.Ox],null)],null))),lU,$APP.M($APP.K,f9b)],null)),$APP.z(avb,new $APP.f(null,3,[$APP.P,"generic exact?.\n\nEntries that are exact are available for `gcd`, among other operations.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,plb)],null)),$APP.z(Inb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null)))),lU,$APP.M($APP.K,REb)],null)),$APP.z(Slb,new $APP.f(null,2,[$APP.P,"Similar to the [[S2-spherical]] coordinate system, with the north pole rotated\n  90 degrees and lying along the positive y axis.",lU,$APP.M($APP.K,hmb)],null)),$APP.z(LQb,new $APP.f(null,3,[$APP.P,"generic outer-product",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,qtb)],null)),$APP.z(oH,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(WJb,new $APP.f(null,3,[$APP.P,"Convert the structure `ms`, which would be a scalar if the (compatible)\n  multiplication `(* ls ms rs)` were performed, to a matrix.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null))),lU,$APP.M($APP.K,IJb)],null)),$APP.z(Ksb,new $APP.f(null,1,[lU,$APP.M($APP.K,Ysb)],null)),$APP.z($APP.Ku,
new $APP.f(null,3,[$APP.P,"generic abs",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Wcb)],null)),$APP.z(QS,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a coordinate basis, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,V1b)],null)),$APP.z(J5b,new $APP.f(null,3,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold, false\n  otherwise.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null)))),lU,$APP.M($APP.K,Y_b)],null)),$APP.z(jX,new $APP.f(null,3,[$APP.P,"generic invert.\n\nReturns the multiplicative inverse of `a`.\n\n  Equivalent to `(/ 1 a)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,EGb)],null)),$APP.z(EU,new $APP.f(null,2,[$APP.P,"Identity function. Returns its argument.",lU,$APP.M($APP.K,jYb)],null)),$APP.z(nOb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,NRb],null)))),lU,$APP.M($APP.K,MZb)],null)),$APP.z(OAb,new $APP.f(null,2,[$APP.P,"Alias for [[lower]].",lU,$APP.M($APP.K,dTb)],null)),$APP.z(wFb,new $APP.f(null,3,[$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  Variadic equivalent to [[by-rows*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,BV],null))),lU,$APP.M($APP.K,gec)],null)),$APP.z(dAb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bY],null)))),lU,$APP.M($APP.K,Fab)],null)),$APP.z(IX,new $APP.f(null,3,[$APP.P,"generic dot-product",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,Y8b)],null)),$APP.z(mjb,new $APP.f(null,3,[$APP.P,"Returns a column matrix populated by the supplied `xs`. Variadic equivalent\n  to [[column*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Lh,$APP.ix],null))),lU,$APP.M($APP.K,Ecb)],null)),$APP.z(jwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[ycc,Bdb],null)))),lU,$APP.M($APP.K,x1b)],null)),$APP.z(kkb,new $APP.f(null,3,[$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  Variadic equivalent to [[by-cols*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,hX],null))),lU,$APP.M($APP.K,Xlb)],null)),
$APP.z(Uhb,new $APP.f(null,3,[$APP.P,"p.324",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UR,$APP.DU],null)))),lU,$APP.M($APP.K,bnb)],null)),$APP.z(bU,new $APP.f(null,3,[$APP.P,"generic real-part",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Kkb)],null)),$APP.z(Szb,new $APP.f(null,1,[lU,$APP.M($APP.K,kwb)],null)),$APP.z(xpb,new $APP.f(null,3,[$APP.P,"Returns a column matrix with the contents of the supplied `up` structure.\n  Errors if any other type is provided.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(dY,$APP.Wv)],null)],null))))),lU,$APP.M($APP.K,f8b)],null)),$APP.z(qEb,new $APP.f(null,3,[$APP.P,"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\n\n  See [[brent-min]] for all supported `opts`.",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,$APP.Ox],null)))),lU,$APP.M($APP.K,q6b)],null)),$APP.z(Fbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null)))),lU,$APP.M($APP.K,u9b)],null)),$APP.z(DJ,new $APP.f(null,3,[$APP.P,"generic log.\n\nReturns the natural logarithm of `x`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Vbc)],null)),$APP.z(ZR,new $APP.f(null,
1,[$APP.Nw,!0],null)),$APP.z(E1b,new $APP.f(null,3,[$APP.P,"Returns a concrete manifold generated by specializing the supplied manifold\n  `family` into a concrete manifold of dimension `n`. `n` must be a positive\n  integer.\n\n  Optionally takes an `embedding-dimension`; this must be \x3e\x3d the value of `n`.\n  Use this in cases like an n-sphere embedded in a euclidean space of dimension\n  n+1.\n\n  A [manifold](https://en.wikipedia.org/wiki/Manifold) is a topological space\n  that locally resembles Euclidean space near each point.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wV,$APP.wU],null),new $APP.H(null,3,5,$APP.I,[wV,$APP.wU,vX],null))),lU,$APP.M($APP.K,bAb)],null)),$APP.z(OY,new $APP.f(null,3,[$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),lU,$APP.M($APP.K,uAb)],null)),$APP.z(Fub,new $APP.f(null,3,[$APP.P,"Return a structure with the same shape as s but with f applied to each\n  primitive (that is, not structural) component.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null))),lU,$APP.M($APP.K,dyb)],null)),$APP.z(kS,new $APP.f(null,3,[$APP.P,"generic partial-derivative",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,ODb)],null)),$APP.z(jrb,new $APP.f(null,1,[lU,$APP.M($APP.K,HGb)],null)),$APP.z(w8b,new $APP.f(null,3,[$APP.P,"Returns the sum of all elements in the input series `s` up to order\n  `n` (inclusive). For example:\n\n  ```clojure\n  (sum (series 1 1 1 1 1 1 1) 3)\n  ;; \x3d\x3e 4\n  ```\n\n  NOTE that [[sum]] sums the first `n + 1` terms, since a series starts with an\n  order 0 term.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.wU],null)))),lU,$APP.M($APP.K,HRb)],null)),$APP.z(dxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Yw,sS,qT,lqb,a8b],null)))),lU,$APP.M($APP.K,Vfb)],null)),$APP.z(itb,new $APP.f(null,3,[$APP.P,"Given a structure of `components` functions defined on manifold points and and\n  a matching `oneform-basis` (of identical structure),\n\n  Returns a new one-form field that\n\n  - passes its vector-field argument to `oneform-basis`, returning a new\n    equivalent structure with each slot populated by functions from a manifold\n    point to the directional derivative (using the vector field) in that\n    coordinate direction\n\n  - contracts the result of that operation with the result of applying each\n    component in `components` to the manifold point.\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[oneform-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,wHb],null)))),lU,$APP.M($APP.K,mIb)],null)),$APP.z(YAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null)))),lU,$APP.M($APP.K,p4b)],null)),$APP.z(HBb,new $APP.f(null,3,[$APP.P,"Computes the trace of a (0,2) tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null)))),lU,$APP.M($APP.K,Z4b)],null)),$APP.z(rdc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Sv],null)))),lU,$APP.M($APP.K,YIb)],null)),$APP.z(pH,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(lsb,new $APP.f(null,3,[$APP.P,"Extract the vector basis from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null))))),lU,$APP.M($APP.K,zdb)],null)),$APP.z(fHb,new $APP.f(null,3,[$APP.P,
"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)))),lU,$APP.M($APP.K,RSb)],null)),$APP.z(sFb,new $APP.f(null,3,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q`, velocity tuple (or scalar)\n  `qdot` and any number of additional higher-order derivative tuples (or\n  scalars), returns a 'Local tuple', i.e., the state expected by a Lagrangian.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Uv,xU,TY,$APP.Lh,vT],null))),lU,$APP.M($APP.K,Dvb)],null)),$APP.z(E7b,new $APP.f(null,3,[$APP.P,"Return the structure `s` in unoriented vector form.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),lU,$APP.M($APP.K,A4b)],null)),$APP.z(iTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KP,mvb],null)))),lU,$APP.M($APP.K,nXb)],null)),$APP.z($ub,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,q9b],null)))),lU,$APP.M($APP.K,rQb)],null)),$APP.z(Bmb,new $APP.f(null,3,[$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null)))),lU,$APP.M($APP.K,Ghb)],
null)),$APP.z(PY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null)))),lU,$APP.M($APP.K,QBb)],null)),$APP.z(dNb,new $APP.f(null,3,[$APP.P,"Return a [[Series]] starting with the supplied values. The remainder of the\n  series will be filled with the zero-value corresponding to the first of the\n  given values.\n\n  If you have a sequence already, prefer [[series*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null))),lU,
$APP.M($APP.K,Ftb)],null)),$APP.z(vRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null)))),lU,$APP.M($APP.K,Whb)],null)),$APP.z(q5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,tU],null)))),lU,$APP.M($APP.K,PRb)],null)),$APP.z(O1b,new $APP.f(null,3,[$APP.P,"Returns a series (of the same type as the input) of partial sums of the terms\n  in the supplied series `s`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),lU,$APP.M($APP.K,Fyb)],null)),$APP.z(Utb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,Bsb)],null)),$APP.z(X3a,new $APP.f(null,3,[$APP.P,"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Kv],null)))),lU,$APP.M($APP.K,Mxb)],null)),$APP.z($APP.bw,new $APP.f(null,1,[lU,$APP.M($APP.K,w5b)],null)),$APP.z(pdc,new $APP.f(null,3,[$APP.P,"Returns a matrix with `r` rows and `c` columns, whose entries are generated by\n  the supplied function `f`.\n\n  If you only supply one dimension `n` the returned matrix will be square.\n\n  The entry in the `i`th row and `j`-th column is `(f i j)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null),new $APP.H(null,
3,5,$APP.I,[$APP.oO,$APP.Mv,$APP.Nv],null))),lU,$APP.M($APP.K,nsb)],null)),$APP.z(FY,new $APP.f(null,3,[$APP.P,"Returns true if `p` is a manifold point, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null)))),lU,$APP.M($APP.K,d8b)],null)),$APP.z(j0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null)))),lU,$APP.M($APP.K,pWb)],null)),$APP.z(zGb,new $APP.f(null,2,[$APP.P,"Converts an S-expression to JavaScript.",
lU,$APP.M($APP.K,E9b)],null)),$APP.z(wH,new $APP.f(null,3,[$APP.P,"generic cosh.\n\nComputes the [hyperbolic\n cosine](https://mathworld.wolfram.com/HyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x + e^{-x}) / 2`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,mXb)],null)),$APP.z(y8b,new $APP.f(null,3,[$APP.P,"Given a vector field `vf` generated from [[basis-components-\x3evector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis-\x3edual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system-\x3evector-basis coordsys)\n        dual  (basis/vector-basis-\x3edual basis coordsys)]\n    (\x3d basis-components\n       (-\x3e basis-components\n           (basis-components-\x3evector-field basis)\n           (vector-field-\x3ebasis-components dual))))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hx,tW],null)))),lU,$APP.M($APP.K,Vub)],null)),$APP.z(vW,new $APP.f(null,3,[$APP.P,"generic coth.\n\nComputes the [hyperbolic\n cotangent](https://mathworld.wolfram.com/HyperbolicCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `cosh(x) / sinh(x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,xXb)],null)),$APP.z(uIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tY,rX,uW],null)))),lU,$APP.M($APP.K,Dib)],null)),$APP.z(ECb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[TX],null)))),lU,$APP.M($APP.K,Xyb)],null)),$APP.z(Lpb,new $APP.f(null,3,[$APP.P,"generic one-like.\n\nIn general, this procedure returns the multiplicative identity of the type of\n  its argument, if it exists. For numbers this is 1.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Lv],null)))),lU,$APP.M($APP.K,dib)],null)),$APP.z(u5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.PW,$APP.QW,$APP.wU],null)))),lU,$APP.M($APP.K,Efb)],null)),$APP.z(m5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null),new $APP.H(null,2,5,$APP.I,[MT,TX],null))),lU,$APP.M($APP.K,Lqb)],null)),$APP.z(OYb,new $APP.f(null,1,[lU,$APP.M($APP.K,wnb)],null)),$APP.z(CCb,new $APP.f(null,1,[lU,$APP.M($APP.K,qac)],null)),
$APP.z(V$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,SY)],null)),$APP.z(FJ,new $APP.f(null,3,[$APP.P,"generic expt",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,p9b)],null)),$APP.z($qb,new $APP.f(null,1,[lU,$APP.M($APP.K,y_b)],null)),$APP.z(U9b,new $APP.f(null,3,[$APP.P,"Returns an [[ICoordinateSystem]] instance specialized to the patch named\n  `patch-name` on `manifold`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aS,VX,iW],null)))),lU,$APP.M($APP.K,eyb)],null)),$APP.z(YRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null))),lU,$APP.M($APP.K,HFb)],null)),$APP.z(Vvb,new $APP.f(null,3,[$APP.P,"p.327",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null)))),lU,$APP.M($APP.K,thb)],null)),$APP.z(lfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))),lU,$APP.M($APP.K,uub)],null)),$APP.z(FIb,new $APP.f(null,3,[$APP.P,"Returns a structure compatible for multiplication with `s` down to 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),lU,$APP.M($APP.K,z1b)],null)),$APP.z(xTb,new $APP.f(null,1,[lU,$APP.M($APP.K,yMb)],null)),$APP.z(zW,new $APP.f(null,3,[$APP.P,"generic fractional-part.\n\nReturns the fractional part of the given value, defined as `x - ⌊x⌋`.\n\n  For positive numbers, this is identical to `(- a (integer-part a))`. For\n  negative `a`, because [[floor]] truncates toward negative infinity, you might\n  be surprised to find that [[fractional-part]] returns the distance between `a`\n  and the next-lowest integer:\n\n```clojure\n(\x3d 0.6 (fractional-part -0.4))\n```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,SQb)],null)),$APP.z(yRb,new $APP.f(null,3,[$APP.P,"Returns true if `e` is an event, false otherwise.\n\n  Make new events with [[make-event]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null)))),lU,$APP.M($APP.K,J$b)],null)),$APP.z(pUb,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation, returns a\n  one-form field.\n\n  The returned one-form field at each structural spot takes a vector field and\n  returns a function that takes the directional derivative in that coordinate's\n  direction using the vector field.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null))),lU,$APP.M($APP.K,oIb)],null)),$APP.z(r4b,new $APP.f(null,3,[$APP.P,"Returns the single column from the supplied column matrix as an `up`. Errors if\n  some other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(qY,$APP.Qr)],null)],null))))),lU,$APP.M($APP.K,ZHb)],null)),Ibb,$APP.z(cY,new $APP.f(null,
3,[$APP.P,"generic trace",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Tlb)],null)),$APP.z($APP.Iv,new $APP.f(null,3,[$APP.P,"Generic implementation of `+`. Returns the sum of all supplied arguments. `(+)`\n  returns 0, the additive identity.\n\n  When applied between numbers, acts like `clojure.core/+`. Dispatch is open,\n  however, making it possible to 'add' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (+ [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up 3 5 7)\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))),lU,$APP.M($APP.K,$pb)],null)),$APP.z(lJb,new $APP.f(null,3,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q` and momentum tuple (or\n  scalar) `p`, returns a 'Hamiltonian state tuple', i.e., the state expected by a\n  Hamiltonian.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,
5,$APP.I,[$APP.Uv,xU,$APP.Sv],null)))),lU,$APP.M($APP.K,mtb)],null)),$APP.z(Kfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null)))),lU,$APP.M($APP.K,hVb)],null)),$APP.z(NNb,new $APP.f(null,3,[$APP.P,"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point \x3d\x3e\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,jS)],null)),$APP.z(Rub,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,TX],null)))),lU,$APP.M($APP.K,nkb)],null)),$APP.z(HOb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,EV],null)))),lU,$APP.M($APP.K,vOb)],null)),$APP.z(HQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,
5,$APP.I,[jW,VU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rS,VU)],null)],null))))),lU,$APP.M($APP.K,Kbc)],null)),$APP.z(tac,new $APP.f(null,3,[$APP.P,"Marks the input event `e` as an event via its metadata. The return value will\n  return `true` when passed to [[event?]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null)))),lU,$APP.M($APP.K,esb)],null)),$APP.z(Opb,new $APP.f(null,2,[$APP.P,"Alias for [[compatible-zero]].",lU,$APP.M($APP.K,
skb)],null)),Znb,$APP.z(Z$b,new $APP.f(null,1,[lU,$APP.M($APP.K,Chb)],null)),$APP.z(mNb,new $APP.f(null,1,[lU,$APP.M($APP.K,Dcb)],null)),$APP.z(oOb,new $APP.f(null,1,[lU,$APP.M($APP.K,mJb)],null)),$APP.z(oQb,new $APP.f(null,3,[$APP.P,"Construct a ratio.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.lP],null))),lU,$APP.M($APP.K,MX)],null)),$APP.z(COb,new $APP.f(null,3,[$APP.P,"Given a one-form field `form` and a `coordinate-system`, returns a function\n  from the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the form field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-oneform-field 'f R2-rect)]\n      ((oneform-field-\x3ecomponents f R2-rect)\n       (up 'x0 'y0))))\n\n  ;;\x3d\x3e (down (f_0 (up x0 y0))\n  ;;         (f_1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Ev,qW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(QV,$APP.Ev)],null)],null))))),lU,$APP.M($APP.K,djb)],null)),$APP.z(A5b,new $APP.f(null,3,[$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null))))),lU,$APP.M($APP.K,Xmb)],null)),$APP.z(pDb,new $APP.f(null,1,[lU,$APP.M($APP.K,Wwb)],null)),$APP.z(ndc,new $APP.f(null,3,[$APP.P,"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field-\x3ecomponents f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;\x3d\x3e (up (f↑0 (up x0 y0))\n  ;;       (f↑1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.hx,qW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(eV,$APP.hx)],null)],null))))),lU,$APP.M($APP.K,CVb)],null)),$APP.z(NM,new $APP.f(null,3,[$APP.P,"generic sec.\n\nComputes the secant of the supplied argument `a`.\n\nEquivalent to `(invert (cos a))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Ogb)],null)),$APP.z(fZb,new $APP.f(null,
2,[$APP.P,"Alias for [[-\x3eL-state]].",lU,$APP.M($APP.K,Iwb)],null)),$APP.z(R5b,new $APP.f(null,3,[$APP.P,"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.hx,qW],null)))),lU,$APP.M($APP.K,BTb)],null)),$APP.z(hhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,VU],null)))),lU,$APP.M($APP.K,fCb)],null)),$APP.z(Xab,new $APP.f(null,3,[$APP.P,"Computes the trace of a (2,0) tensor",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null)))),lU,$APP.M($APP.K,Bhb)],null)),$APP.z(RX,new $APP.f(null,3,[$APP.P,"generic negate.\n\nReturns the negation of `a`.\n\n  Equivalent to `(- (g/zero-like a) a)`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Ykb)],null)),$APP.z(MEb,new $APP.f(null,3,[$APP.P,"generic acoth.\n\nComputes the [inverse hyperbolic\n cotangent](https://mathworld.wolfram.com/InverseHyperbolicCotangent.html) of\n the supplied argument `a`.\n\ndefaults to `1/2 ln((x+1)/(x-1))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,p1b)],null)),$APP.z(bBb,new $APP.f(null,2,
[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,VU],null)))),lU,$APP.M($APP.K,sSb)],null)),$APP.z(uT,new $APP.f(null,3,[$APP.P,"generic sech.\n\nComputes the [hyperbolic\n secant](https://mathworld.wolfram.com/HyperbolicSecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / cosh(x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Bpb)],null)),$APP.z(OHb,new $APP.f(null,3,[$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),lU,$APP.M($APP.K,Q6b)],null)),$APP.z(spb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))),lU,$APP.M($APP.K,D_b)],null)),$APP.z(r5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QN],null)))),lU,$APP.M($APP.K,zac)],null)),$APP.z(Ynb,new $APP.f(null,3,[$APP.P,"generic log10.\n\nReturns the base-10 logarithm of `x`, i.e., $log_10(x)$.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,fdb)],null)),$APP.z(xPb,new $APP.f(null,3,[$APP.P,"Convert the matrix `m` into a structure `S`, guided by the requirement that `(*\n  ls S rs)` should be a scalar.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[AW,$APP.Qr,MW],null)))),lU,$APP.M($APP.K,j$b)],null)),$APP.z(KVb,new $APP.f(null,3,[$APP.P,"Returns the acceleration element of a local tuple (by convention, the fourth\n  element).\n\n  See [[coordinate]] for more detail.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),3)],null)],null))))),lU,$APP.M($APP.K,J6b)],null)),$APP.z(yZb,new $APP.f(null,3,[$APP.P,"p.326",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))),lU,$APP.M($APP.K,Rxb)],null)),$APP.z(dZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,
4,5,$APP.I,[$APP.Kv,$APP.Yv,$APP.UP,$APP.VP],null)],null)))),lU,$APP.M($APP.K,Nib)],null)),$APP.z(Ifb,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is an [form field of rank\n  n](https://en.wikipedia.org/wiki/Differential_form), false otherwise.\n\n  A form-field of rank n is an operator that takes n vector fields to a\n  real-valued function on the manifold.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null)))),lU,$APP.M($APP.K,obc)],null)),
$APP.z(BPb,new $APP.f(null,3,[$APP.P,"Returns a [[PowerSeries]] representing the supplied constant term.\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[$APP.Mv,$V],null))),lU,$APP.M($APP.K,bwb)],null)),$APP.z(TOb,new $APP.f(null,3,[$APP.P,"For convenience, we also provide the sister-procedure for finding\n  the maximum of a unimodal function using the golden section method.\n\n  Negate the function, minimize, negate the result.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,$APP.Ox],null))),lU,$APP.M($APP.K,mdc)],null)),$APP.z(cT,new $APP.f(null,3,[$APP.P,"generic square",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Vzb)],null)),$APP.z(kQb,new $APP.f(null,3,[$APP.P,"generic exp2.\n\nReturns the base-2 exponential of `x`. Equivalent to `(expt 2 x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,$9b)],null)),$APP.z(nLb,new $APP.f(null,3,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.hU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(FY,$APP.hU)],null)],null))))),lU,$APP.M($APP.K,m1b)],null)),$APP.z(eQb,new $APP.f(null,3,[$APP.P,"Gamma takes a path function (from time to coordinates) to a state\n  function (from time to local tuple).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[xU,$APP.wU],null))),lU,$APP.M($APP.K,Wrb)],null)),$APP.z(NK,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))),$APP.P,"Given a sequence of `selectors`, return a function that accepts some object `x`\n  and returns:\n\n  ```clojure\n  (apply ref x selectors)\n  ```\n  ",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,
[$APP.M(ST)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(CK,new $APP.f(null,3,[$APP.P,"generic magnitude",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,mQb)],null)),$APP.z(n7b,new $APP.f(null,1,[lU,$APP.M($APP.K,p5b)],null)),$APP.z(Hwb,new $APP.f(null,3,[$APP.P,"A convenience function on local tuples. A local tuple describes\n  the state of a system at a particular time:\n\n  ```\n  [t, q, D q, D^2 q]\n  ```\n\n  representing time, position, velocity (and optionally acceleration etc.)\n\n  [[coordinate]] returns the `q` element, which is expected to be a mapping from\n  time to a structure of coordinates.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),1)],null)],null))))),lU,$APP.M($APP.K,ZAb)],null)),$APP.z(WV,new $APP.f(null,3,[$APP.P,"Returns function signature for a Hamiltonian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Hamiltonian literal functions.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.wU],null)))),lU,$APP.M($APP.K,W8b)],null)),$APP.z($APP.vw,new $APP.f(null,3,[$APP.P,"Comparator. Clone of [[cljs.core/compare]] that works with the expanded\n      Emmy numeric tower.\n\n  Returns a negative number, zero, or a positive number when x is logically\n  'less than', 'equal to', or 'greater than' y. Uses IComparable if available\n  and google.array.defaultCompare for objects of the same type and special-cases\n  nil to be less than any other object.",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null)))),lU,$APP.M($APP.K,$mb)],null)),$APP.z($APP.dw,new $APP.f(null,3,[$APP.P,"generic infinite?.\n\nReturns true if `a` is either numerically infinite (i.e., equal to `##Inf`) or\n  a compound number (complex or quaterion, for example) with some infinite\n  component.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,X2b)],null)),$APP.z(ugb,new $APP.f(null,1,[lU,$APP.M($APP.K,
rMb)],null)),$APP.z(WCb,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-oneform-field` instances.\n\n  The one-form field at each structural spot takes a vector field and returns a\n  function that takes the directional derivative in that coordinate's direction\n  using the vector field.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-oneform-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,xT)],null)),$APP.z(mgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GU],null)))),lU,$APP.M($APP.K,jVb)],null)),$APP.z(rsb,new $APP.f(null,3,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 1.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.hU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,
1,5,$APP.I,[$APP.M(FY,$APP.hU)],null)],null))))),lU,$APP.M($APP.K,peb)],null)),$APP.z(rob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RFb],null)))),lU,$APP.M($APP.K,Zkb)],null)),$APP.z(jlb,new $APP.f(null,3,[$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Sdb)],null)),$APP.z(Uib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[Qgb,VU],null)))),lU,$APP.M($APP.K,h9b)],null)),$APP.z(OM,new $APP.f(null,3,[$APP.P,"generic cot.\n\nComputes the trigonometric cotangent function of the supplied argument `a`.\n\nEquivalent to `(invert (tan a))`, or `(/ (cos a) (sin a))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,SDb)],null)),$APP.z(Azb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),
lU,$APP.M($APP.K,egb)],null)),$APP.z(IT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,Adc)],null)),$APP.z(zsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[rT,iS],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dY,iS),$APP.M($APP.bw,$APP.M($APP.tv,iS),4)],null)],null))))),lU,$APP.M($APP.K,wbc)],null)),$APP.z($APP.Hv,new $APP.f(null,3,[$APP.P,'Generic implementation of `*`. Returns the product of all supplied\n  arguments. `(*)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core/*`. Dispatch is open,\n  however, making it possible to \'multiply\' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (* 2 #emmy/complex "3 + 1i")\n  ;;\x3d\x3e #emmy/complex "6 + 2i"\n  ```',
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))),lU,$APP.M($APP.K,Zpb)],null)),$APP.z(eV,new $APP.f(null,3,[$APP.P,"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.hx],null)))),lU,$APP.M($APP.K,sec)],null)),$APP.z(ISb,new $APP.f(null,
1,[lU,$APP.M($APP.K,Bkb)],null)),$APP.z(Nnb,new $APP.f(null,3,[$APP.P,"generic asec.\n\nComputes the [inverse\n secant](https://mathworld.wolfram.com/InverseSecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(sqrt(x^2 - 1))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,abb)],null)),$APP.z(VEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$W],null)],null)))),
lU,$APP.M($APP.K,Gpb)],null)),$APP.z(iDb,new $APP.f(null,3,[$APP.P,"generic solve-linear-right.\n\nFor a given `a` and `b`, returns `x` such that `a \x3d x*b`.\n\n  See[[solve-linear]] for a similar function that solves for `a*x \x3d b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,xdb)],null)),$APP.z(Wkb,new $APP.f(null,3,[$APP.P,"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,BCb)],null)),$APP.z(Ivb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(QS,$APP.sU)],null)],null))))),lU,$APP.M($APP.K,dOb)],null)),$APP.z(rAb,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a unique, symbolically-represented\n  point on the manifold associated with `coordinate-system`.\n\n  See [[typical-coords]] for a coordinate-based version of this function.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,qjb)],null)),$APP.z(m3b,new $APP.f(null,1,[lU,$APP.M($APP.K,P_b)],null)),$APP.z(Zwb,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector α radians about the z axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),lU,$APP.M($APP.K,ebc)],null)),$APP.z(vhb,new $APP.f(null,3,[$APP.P,"generic acsch.\n\nComputes the [inverse hyperbolic\n cosecant](https://mathworld.wolfram.com/InverseHyperbolicCosecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1+x^2)) / x)`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Yhb)],null)),$APP.z(Etb,new $APP.f(null,3,[$APP.P,"generic log2.\n\nReturns the base-2 logarithm of `x`, i.e., $log_2(x)$.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,m5b)],null)),$APP.z(Zvb,new $APP.f(null,1,[lU,$APP.M($APP.K,qZb)],null)),$APP.z(oyb,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,Fqb)],null)),$APP.z(gYb,new $APP.f(null,3,[$APP.P,"Takes a coordinate representation `coords` of a manifold point with all\n  symbolic entries, and returns a structure of the same shape with `v:`\n  prepended to all symbols.\n\n  This structure is appropriate for representing the velocities associated with\n  each coordinate.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.pW],null)))),lU,$APP.M($APP.K,Web)],null)),$APP.z(Yib,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(I5b,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `x` is a `BigInt`, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,WWb)],null)),$APP.z($APP.Cv,new $APP.f(null,3,[$APP.P,"generic zero?.\n\nIs true if `x` is an additive identity.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),
lU,$APP.M($APP.K,n3b)],null)),$APP.z(LTb,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),lU,$APP.M($APP.K,L1b)],null)),$APP.z(Jrb,new $APP.f(null,3,[$APP.P,"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,KMb)],null)),$APP.z(dDb,new $APP.f(null,3,[$APP.P,"Returns the momentum element of a local Hamiltonian state tuple (by convention,\n  the third element).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[YU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dY,YU),$APP.M($APP.aw,$APP.M($APP.tv,YU),2)],null)],null))))),lU,$APP.M($APP.K,AOb)],null)),
$APP.z(jK,new $APP.f(null,3,[$APP.P,"generic atan.\n\nComputes the inverse tangent of the supplied argument `a`. Given two\n  arguments `a` and `b`, returns the inverse tangent of the angle formed by the\n  point `(b, a)` in a 2-dimensional euclidean plane.\n\n  The two-argument version is sometimes\n  called [Atan2](https://en.wikipedia.org/wiki/Atan2).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,
Mfb)],null)),$APP.z(nBb,new $APP.f(null,3,[$APP.P,"Generates a `nrows` x `ncols` matrix of symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  If `ncols` (the third argument) is not supplied, returns a square matrix of\n  size `nrows` x `nrows`.\n\n  NOTE: The symbols in the returned matrix record their Einstein-notation path\n  into the structure that this matrix represents; a `down` of `up` columns. This\n  means that the returned indices embedded in the symbols look flipped, `ji` vs\n  `ij`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-matrix 'x 2 2)\n     (by-rows ['x_0↑0 'x_1↑0]\n              ['x_0↑1 'x_1↑1]))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,LV],null),new $APP.H(null,3,5,$APP.I,[$APP.Yx,LV,iX],null))),lU,$APP.M($APP.K,Xxb)],null)),$APP.z(Hbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(XW,PV)],null)],null))))),lU,$APP.M($APP.K,Qdc)],null)),$APP.z(xqb,new $APP.f(null,3,[$APP.P,"p. 334 (used, but not defined there)",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.wU],null)))),lU,$APP.M($APP.K,gob)],null)),$APP.z(Gbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null)))),lU,$APP.M($APP.K,v9b)],null)),$APP.z(XSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,VU],null)))),lU,$APP.M($APP.K,Tdc)],null)),$APP.z(RV,new $APP.f(null,3,[$APP.P,"generic make-rectangular",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,
$APP.sU],null)))),lU,$APP.M($APP.K,MMb)],null)),$APP.z(Onb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null)))),lU,$APP.M($APP.K,Icb)],null)),$APP.z(EKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Rwb,Swb],null)))),lU,$APP.M($APP.K,Ijb)],null)),$APP.z(bRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),lU,$APP.M($APP.K,$bb)],null)),$APP.z(Tqb,
new $APP.f(null,3,[$APP.P,"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null))),lU,$APP.M($APP.K,jcb)],null)),$APP.z(AJb,new $APP.f(null,1,[lU,$APP.M($APP.K,d7b)],null)),$APP.z(Rtb,new $APP.f(null,3,[$APP.P,"[[curl]] implements equation (10.7) of Functional Differential Geometry,\n  defined on page 155.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,EV],null)))),lU,$APP.M($APP.K,F5b)],null)),$APP.z(TWb,new $APP.f(null,3,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold family, false\n  otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null)))),lU,$APP.M($APP.K,hxb)],null)),$APP.z(PM,new $APP.f(null,3,[$APP.P,"generic csc.\n\nComputes the cosecant of the supplied argument `a`.\n\nEquivalent to `(invert (sin a))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,MFb)],null)),$APP.z(qsb,new $APP.f(null,1,[lU,$APP.M($APP.K,lhb)],null)),$APP.z(S2b,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a structure that matches\n  the [[coordinate-prototype]] of `coordinate-system`, with all unique,\n  gensym-ed entries.\n\n  Use [[typical-coords]] if you require a unique symbolic coordinate\n  representation compatible with `coordinate-system`.\n\n  See [[typical-point]] for a coordinate-free version of this function.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,TMb)],null)),$APP.z(FV,new $APP.f(null,3,[$APP.P,"generic lcm.\n\nReturns the [least common\n  multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of the two\n  inputs `a` and `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,nbc)],null)),$APP.z(fY,new $APP.f(null,3,[$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null))),lU,$APP.M($APP.K,wG)],null)),$APP.z(upb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))),lU,$APP.M($APP.K,bib)],null)),$APP.z(cCb,new $APP.f(null,3,[$APP.P,"Convert the given expression to TeX format, as a string.\n\n  If you set the `:equation` keyword argument to a truthy value, the result will\n  be wrapped in an equation environment. `:equation \x3cstring\x3e` will insert a\n  `\\label{\x3cstring\x3e}` entry inside the equation environment.\n\n  For example:\n\n  ```clojure\n  (let [expr (+ 'x 'xy)]\n    (println\n      (-\x3eTeX expr :equation \"label!\")))\n\n  \\begin{equation}\n  \\label{label!}\n  x + y\n  \\end{equation}\n  ```\n  ",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[fV],null)],null)],null))),lU,$APP.M($APP.K,Edb)],null)),$APP.z(aAb,new $APP.f(null,1,[lU,$APP.M($APP.K,vob)],null)),$APP.z(GPb,new $APP.f(null,3,[$APP.P,"The supplied manifold `m` locally resembles some vector space; this function\n  returns the field over which that vector space was specified.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[aS],null)))),
lU,$APP.M($APP.K,ddc)],null)),$APP.z(iWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null)))),lU,$APP.M($APP.K,jub)],null)),$APP.z(F2b,new $APP.f(null,3,[$APP.P,"Given a state tuple (of finite length), reconstitutes the initial segment of\n  the Taylor series corresponding to the state tuple data as a function of t.\n\n  Time is measured beginning at the point of time specified in the input state\n  tuple.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[nrb],null)))),lU,$APP.M($APP.K,BDb)],null)),$APP.z(Ohb,new $APP.f(null,3,[$APP.P,"generic acsc.\n\nComputes the [inverse\n cosecant](https://mathworld.wolfram.com/InverseCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(1 / sqrt(x^2 - 1))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,wCb)],null)),$APP.z(J9b,new $APP.f(null,3,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses forward-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))),lU,$APP.M($APP.K,IRb)],null)),$APP.z(nCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,TX],null)))),lU,$APP.M($APP.K,Lub)],null)),$APP.z(mK,new $APP.f(null,3,[$APP.P,"generic acos.\n\nComputes the inverse cosine of the supplied argument `a`.\n\nDefaults to `atan(sqrt(1-x^2)/x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,
XCb)],null)),$APP.z(i0b,new $APP.f(null,1,[lU,$APP.M($APP.K,iZb)],null)),$APP.z(Cdc,new $APP.f(null,3,[$APP.P,"Accepts a single symbolic expression and returns a factored version of that\n  expression.\n\n  Differs from [[factor-expression]] in that it can handle any expression, not\n  just expressions limited to polynomial operations.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null)))),lU,$APP.M($APP.K,mUb)],null)),$APP.z(ZS,new $APP.f(null,3,[$APP.P,"generic acot.\n\nComputes the [inverse\n cotangent](https://mathworld.wolfram.com/InverseCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `pi/2 - atan(x)`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,bDb)],null)),$APP.z(dT,new $APP.f(null,3,[$APP.P,"generic floor.\n\nReturns the largest integer less than or equal to `a`.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,
Ahb)],null)),$APP.z(LKb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null)))),lU,$APP.M($APP.K,GKb)],null)),$APP.z(nTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))),lU,$APP.M($APP.K,lwb)],null)),$APP.z(Fkb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[VU,jW,qW],null)))),lU,$APP.M($APP.K,KAb)],null)),$APP.z(Jib,new $APP.f(null,1,[lU,$APP.M($APP.K,jIb)],
null)),$APP.z(rjb,new $APP.f(null,1,[lU,$APP.M($APP.K,$Nb)],null)),$APP.z(jV,new $APP.f(null,3,[$APP.P,"generic imag-part",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,G1b)],null)),$APP.z(Bwb,new $APP.f(null,1,[lU,$APP.M($APP.K,uob)],null)),$APP.z(FHb,new $APP.f(null,3,[$APP.P,"Returns a row matrix with the contents of the supplied `down` structure.\n  Errors if any other type is provided.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(SOb,$APP.Wv)],null)],null))))),lU,$APP.M($APP.K,Vcb)],null)),$APP.z(KJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KP,VU],null)))),lU,$APP.M($APP.K,v1b)],null)),$APP.z(Cob,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null)))),lU,$APP.M($APP.K,Jdc)],null)),$APP.z(AMb,new $APP.f(null,1,[lU,$APP.M($APP.K,Q9b)],null)),$APP.z(qHb,
new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),lU,$APP.M($APP.K,e$b)],null)),$APP.z(tRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[iac,hac,nac,VU,jW],null)))),lU,$APP.M($APP.K,tZb)],null)),$APP.z(XFb,new $APP.f(null,3,[$APP.P,"Returns the single row from the supplied row matrix as a vector. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(DV,$APP.Qr)],null)],null))))),lU,$APP.M($APP.K,tbb)],null)),$APP.z(izb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,OGb)],null)),$APP.z(fU,new $APP.f(null,3,[$APP.P,"Takes a function `f` and a sequence of `factors`, and returns a new function\n  that multiplies each factor by the corresponding argument of `f`. Too many or\n  two few factors are ignored.\n\n  ```clojure\n  ((arg-scale square 3) 4) \x3d\x3d\x3e 144\n  ((arg-scale square 3 2 1) 4) \x3d\x3d\x3e 144\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,oV],null))),lU,$APP.M($APP.K,UIb)],null)),$APP.z(VDb,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a new function that\n  calculates the [Gradient](https://en.wikipedia.org/wiki/Gradient) of `f`.\n\n  The related [[emmy.env/D]] operator returns a function that produces a\n  structure of the opposite orientation as [[Grad]]. Both of these functions use\n  reverse-mode automatic differentiation.",lU,
$APP.M($APP.K,sdc)],null)),$APP.z(INb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UX,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null)))),lU,$APP.M($APP.K,beb)],null)),$APP.z(Myb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null))),lU,$APP.M($APP.K,TGb)],null)),$APP.z(C$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[BU],null)))),lU,$APP.M($APP.K,Tcc)],null)),$APP.z(Akb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VU,wW],null)))),lU,$APP.M($APP.K,c8b)],null)),$APP.z(gKb,new $APP.f(null,3,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses reverse-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,ST],null))),lU,$APP.M($APP.K,Isb)],null)),$APP.z(vZb,new $APP.f(null,3,[$APP.P,"Returns the symbolic name of the suppplied frame.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),lU,$APP.M($APP.K,NOb)],null)),$APP.z(kfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))),lU,$APP.M($APP.K,vub)],null)),$APP.z(AUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[KP],null)))),lU,$APP.M($APP.K,c3b)],null)),$APP.z(mib,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.JY],null)],null)],null))),$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in an\n  `equation` environment.\n\n  Optionally supply a `:label` keyword argument to set a custom label.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,
1,5,$APP.I,[$APP.M($APP.Ww,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.JY],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.JY],null)],null)],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(cR,new $APP.f(null,3,[$APP.P,"generic Lie-derivative",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Htb)],null)),$APP.z(pJb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rV],null)))),lU,$APP.M($APP.K,lKb)],null)),$APP.z(z_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hec,Z1b],null)))),lU,$APP.M($APP.K,Lcc)],null)),$APP.z(sTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null)))),lU,$APP.M($APP.K,asb)],null)),$APP.z(hQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mT],
null)))),lU,$APP.M($APP.K,nGb)],null)),$APP.z(Lgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null)))),lU,$APP.M($APP.K,Ccb)],null)),$APP.z(D4a,new $APP.f(null,3,[$APP.P,"Returns the alternation of the supplied differential `form`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null)))),lU,$APP.M($APP.K,b8b)],null)),$APP.z(G$b,new $APP.f(null,1,[lU,$APP.M($APP.K,NKb)],null)),$APP.z(H_b,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Wdb],null)))),lU,$APP.M($APP.K,$Sb)],null)),$APP.z(Ewb,new $APP.f(null,1,[lU,$APP.M($APP.K,Vob)],null)),$APP.z(YWb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(w2b,new $APP.f(null,1,[lU,$APP.M($APP.K,zfb)],null)),$APP.z($APP.Jv,new $APP.f(null,3,[$APP.P,"Generic implementation of `-`.\n\n  If one argument is supplied, returns the negation of `a`. Else returns the\n  difference of the first argument `a` and the sum of all remaining\n  arguments. `(-)` returns 0.\n\n  When applied between numbers, acts like `clojure.core/-`. Dispatch is open,\n  however, making it possible to 'subtract' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (- [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up -1 -1 -1)\n\n  (- [1 10])\n  ;;\x3d\x3e (up -1 -10)\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))),lU,$APP.M($APP.K,Xpb)],null)),$APP.z(Tib,new $APP.f(null,3,[$APP.P,"Given `ys` (a sequence of function values) and `xs` (an equal-length sequence\n  of function inputs), returns a [[emmy.polynomial/Polynomial]] instance\n  guaranteed to pass through all supplied `xs` and `ys`.\n\n  The contract for inputs is that `(map vector xs ys)` should return a sequence\n  of pairs of points.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[fUb,$APP.ix],null)))),lU,$APP.M($APP.K,bfb)],null)),$APP.z(a6a,new $APP.f(null,3,[$APP.P,"To make a one-form field into a vector field, i.e., a (0,1) tensor into a (1,0)\n  tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))),lU,$APP.M($APP.K,i8b)],null)),$APP.z(ztb,new $APP.f(null,2,[$APP.P,"Alias for [[F-\x3eCH]].",lU,$APP.M($APP.K,B$b)],null)),$APP.z($Xb,new $APP.f(null,3,[$APP.P,"Takes a unit 3-vector `direction` (representing a direction) and a velocity\n  `v:c` normalized by `C`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hFb,PY],null)))),lU,$APP.M($APP.K,Y$b)],null)),$APP.z(jgb,new $APP.f(null,3,[$APP.P,"Returns the standard basis object for `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,ogb)],null)),$APP.z(YLb,new $APP.f(null,3,[$APP.P,"Compute the rotation matrix from a 3-vector of Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[UX,ZR,YT],null)],null)))),lU,$APP.M($APP.K,MRb)],null)),$APP.z(N1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tY,rX,uW],null)))),lU,$APP.M($APP.K,AEb)],null)),$APP.z(Awb,new $APP.f(null,1,[lU,$APP.M($APP.K,tob)],null)),$APP.z(YZb,new $APP.f(null,1,[lU,$APP.M($APP.K,ikb)],null)),$APP.z(H5b,new $APP.f(null,3,[$APP.P,"Returns true if `x` implements [[ICoordinateSystem]], false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,TTb)],null)),$APP.z(dnb,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null))),lU,$APP.M($APP.K,lQb)],null)),$APP.z(fyb,new $APP.f(null,3,[$APP.P,"Returns its argument, wrapped in a marker type that responds to the generic\n  operations registered in [[emmy.numsymb]].\n\n  Symbols are automatically treated as [[literal-number]] instances, so\n\n  ```clojure\n  (* 10 (literal-number 'x))\n  ```\n\n  is equivalent to\n\n  ```clojure\n  (* 10 'x)\n  ```\n\n  If you pass an actual number, emmy will attempt to preserve exact values\n  through various operations:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 4))))\n  ;;\x3d\x3e (+ 1 (cos 8))\n  ```\n\n  Notice that the `(g/* 2 ...)` is evaluated, but `cos` evaluation is deferred,\n  since the result is inexact. On the other hand, if the number is inexact to\n  begin with:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 2.2))))\n  ;;\x3d\x3e 0.6926671300215806\n  ```\n\n  the system will go ahead and evaluate it.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,Jbc)],null)),$APP.z(RJb,new $APP.f(null,1,[lU,$APP.M($APP.K,Mcc)],null)),$APP.z(ZVb,new $APP.f(null,1,[lU,$APP.M($APP.K,Vcc)],null)),$APP.z(v4b,new $APP.f(null,3,[$APP.P,"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null)))),lU,$APP.M($APP.K,jib)],null)),$APP.z($APP.$Mb,new $APP.f(null,3,[$APP.P,"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null))),lU,$APP.M($APP.K,Yob)],null)),
$APP.z(s3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))),lU,$APP.M($APP.K,Drb)],null)),$APP.z(HX,new $APP.f(null,3,[$APP.P,"Takes a function `f` and a sequence of `shifts`, and returns a new function\n  that adds each shift to the corresponding argument of `f`. Too many or two few\n  shifts are ignored.\n\n  ```clojure\n  ((arg-shift square 3) 4) \x3d\x3d\x3e 49\n  ((arg-shift square 3 2 1) 4) \x3d\x3d\x3e 49\n  ```",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,AY],null))),lU,$APP.M($APP.K,Mab)],null)),$APP.z($APP.Vw,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))),$APP.P,"A shim. Dispatches to [[d/partial]] when all the arguments are integers; falls\n  back to [[clojure.core/partial]] (partial function application) otherwise.",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(ST)],null),$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,ST],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(tX,new $APP.f(null,3,[$APP.P,"generic inner-product",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null)))),lU,$APP.M($APP.K,QMb)],null)),$APP.z(qV,new $APP.f(null,3,[$APP.P,"generic acosh.\n\nComputes the [inverse hyperbolic\n cosine](https://mathworld.wolfram.com/InverseHyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `2 ln(sqrt((x+1)/2) + sqrt((x-1)/2))`.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,l1b)],null)),$APP.z(lY,new $APP.f(null,3,[$APP.P,"generic ceiling.\n\nReturns the result of rounding `a` up to the next largest integer.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),
lU,$APP.M($APP.K,IGb)],null)),$APP.z(I$b,new $APP.f(null,3,[$APP.P,"generic sinc.\n\nThe unnormalized [sinc\n  function](https://en.wikipedia.org/wiki/Sinc_function), equivalent to\n  $\\frac{\\sin x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/SincFunction.html)\n   - [Boost notes on [[sinc]]\n     and [[sinch]]](https://www.boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sinc/sinc_overview.html)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,iJb)],null)),$APP.z(pVb,new $APP.f(null,1,[lU,$APP.M($APP.K,uFb)],null)),Ujb,$APP.z(Mvb,new $APP.f(null,3,[$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null))),lU,$APP.M($APP.K,MDb)],
null)),$APP.z($Rb,new $APP.f(null,3,[$APP.P,"Takes a function `f: R \x3d\x3e R` (function of a single real variable), and returns\n  a new function of `x` that approximates the derivative $Df(x)$ (or $D^2f(x)$\n  if you pass `:method :central-d2`).\n\n  Returns the estimated value of the derivative at `x`. If you pass `:info?\n  true`, the fn returns a dictionary of the results of `us/seq-limit`:\n\n  ```clojure\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3cderivative estimate\x3e}\n  ```\n\n  Make sure to visit [[emmy.calculus.derivative/D]] if you want symbolic or\n  automatic differentiation.\n\n  ### Roundoff Estimate\n\n  The returned function will attempt to estimate how many times it can halve the\n  step size used to estimate the derivative before roundoff error swamps the\n  calculation, and force the function to return (with `:converged? false`, if\n  you pass `:info?`)\n\n  ### Optional Arguments\n\n  `D-numeric` takes optional args as its second param. Any of these can be\n  overridden by passing a second argument to the function returned by\n  `D-numeric`; helpful for setting defaults and then overriding them later.\n\n  The returned function passes through these and any other options to\n  `us/seq-limit`, where they control the sequence of richardson\n  extrapolation-accelerated estimates.\n\n  Options:\n\n  - `:method`: one of `:central`, `:central-d2`, `:forward` or `:backward`.\n  `:central-d2` forces a second derivative estimate; the other methods configure\n  a first derivative estimator.\n\n  - `:info?` if false (default), returns the estimated value of `x`. If true,\n  returns a dictionary with more information (see `D-numeric`'s docstring for\n  more info.)\n\n  - `:initial-h`: the initial `h` to use for derivative estimates before $h \to\n  0$. Defaults to `0.1 * abs(x)`.\n\n  - `:tolerance`: see `us/stream-limit` for a discussion of how this value\n  handles relative vs absolute tolerance. $\\sqrt(\\epsilon)$ by default, where\n  $\\epsilon$ \x3d machine tolerance.\n\n  - `:maxterms`: the maximum number of terms to consider when hunting for a\n  derivative estimate. This defaults to an estimate generated internally,\n  designed to prevent roundoff error from swamping the result. If you want to\n  disable this feature, set `:maxterms` to something moderately large, like\n  `:maxterms 100`. But do so carefully! See the surrounding namespace for a\n  larger discussion.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null))),lU,$APP.M($APP.K,tvb)],null)),$APP.z($Zb,new $APP.f(null,3,[$APP.P,"Returns a function which will pull a form back across a map (without needing\n  its inverse)",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null)))),lU,$APP.M($APP.K,YOb)],null)),$APP.z(W0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,
jW],null)))),lU,$APP.M($APP.K,g9b)],null)),$APP.z(RUb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[iS],null)))),lU,$APP.M($APP.K,QAb)],null)),$APP.z(hlb,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of α radians about the z axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),lU,$APP.M($APP.K,zYb)],null)),$APP.z(u0b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Qr],null)))),lU,$APP.M($APP.K,zub)],null)),$APP.z(HEb,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from a point on the\n  coordinate system's manifold to the coordinate representation specified by the\n  supplied `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,X9b)],null)),$APP.z(Fvb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(cxb,new $APP.f(null,2,[$APP.P,"Alias for [[-\x3eL-state]].",
lU,$APP.M($APP.K,idc)],null)),$APP.z(onb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,qW],null)))),lU,$APP.M($APP.K,Ctb)],null)),$APP.z($sb,new $APP.f(null,3,[$APP.P,"velocities must be in meters/second, since we don't yet have units support.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null)))),lU,$APP.M($APP.K,$2b)],null)),$APP.z(pY,new $APP.f(null,3,[$APP.P,"generic conjugate",$APP.U,$APP.M($APP.K,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Arb)],null)),$APP.z(Fdc,new $APP.f(null,3,[$APP.P,"Flat coordinate systems here only.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,qW],null)))),lU,$APP.M($APP.K,GIb)],null)),$APP.z(N_b,new $APP.f(null,3,[$APP.P,"generic sinhc.\n\nThe [sinhc function](https://en.wikipedia.org/wiki/Sinhc_function),\n  equivalent to $\\frac{\\sinh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinhc_function)\n   - [Mathworld page on Sinhc](https://mathworld.wolfram.com/SinhcFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,zzb)],null)),$APP.z(yP,new $APP.f(null,3,[$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null))),lU,$APP.M($APP.K,OP)],null)),$APP.z(D5b,new $APP.f(null,3,[$APP.P,"f is a function of (x y continue fail), which calls continue with the values of\n  x' y' that follow x y in the mapping.\n\n  Returns a map of the same shape that iterates the iterated map n times before\n  invoking the continuation, or invokes the fail continuation if the inner map\n  fails.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Iu,$APP.M($APP.mv,$APP.wU))],null)],null))))),lU,$APP.M($APP.K,mrb)],null)),$APP.z($Eb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Sv],null)))),lU,$APP.M($APP.K,vcc)],null)),$APP.z(HJ,new $APP.f(null,3,[$APP.P,"generic sqrt",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,r8b)],null)),$APP.z(zNb,new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and an [[ICoordinateSystem]], returns a literal\n  function that maps coordinate-free manifold points to a scalar output.\n\n  Also aliased as [[literal-manifold-function]].",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,qW],null)))),lU,$APP.M($APP.K,mKb)],null)),$APP.z(sac,new $APP.f(null,3,[$APP.P,"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.ix],null)))),lU,$APP.M($APP.K,b2b)],null)),$APP.z(Evb,new $APP.f(null,1,[lU,$APP.M($APP.K,ehb)],null)),$APP.z(a1b,new $APP.f(null,2,[$APP.P,"Alias for [[Hamiltonian-\x3estate-derivative]], for compatibility with\n  1st edition of SICM.",lU,$APP.M($APP.K,orb)],null)),$APP.z(aU,new $APP.f(null,3,[$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection.",$APP.U,
$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,jBb)],null)),$APP.z(O3b,new $APP.f(null,3,[$APP.P,"generic asech.\n\nComputes the [inverse hyperbolic\n secant](https://mathworld.wolfram.com/InverseHyperbolicSecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1-x^2)) / x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,ewb)],null)),$APP.z(znb,new $APP.f(null,3,[$APP.P,
"For making a (2,0) tensor into a (0,2) tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null)))),lU,$APP.M($APP.K,c2b)],null)),$APP.z(lK,new $APP.f(null,3,[$APP.P,"generic asin.\n\nComputes the inverse sine of the supplied argument `a`.\n\nDefaults to `atan(x/sqrt(1-x^2))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Kcb)],null)),$APP.z(XW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null)))),lU,$APP.M($APP.K,AAb)],null)),$APP.z(B3b,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of α radians about the x axis.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),lU,$APP.M($APP.K,O2b)],null)),$APP.z(tWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hdb,VU],null)))),lU,$APP.M($APP.K,q0b)],null)),$APP.z($APP.XX,new $APP.f(null,3,[$APP.P,"generic transpose",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Avb)],null)),$APP.z(xwb,new $APP.f(null,1,[lU,$APP.M($APP.K,xob)],null)),$APP.z(Xhb,new $APP.f(null,2,[$APP.P,"Alias for [[differential-of-map]].",lU,$APP.M($APP.K,kHb)],null)),$APP.z(bbb,new $APP.f(null,3,[$APP.P,"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[dS,XT,eY],null),$APP.Ml,new $APP.f(null,3,[dS,TT,XT,!1,eY,!1],null),$APP.dk,$APP.Ox],null)],null))),lU,$APP.M($APP.K,Ncc)],null)),$APP.z(ivb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in double\n  `$$` to mark the string as a block LaTeX form."],
null)),$APP.z(k5a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null)))),lU,$APP.M($APP.K,QKb)],null)),$APP.z(AKb,new $APP.f(null,3,[$APP.P,"Returns a form field that returns, for any supplied vector field `vf`, a\n  manifold function [[manifold/zero-manifold-function]] that maps every input\n  manifold `point` to the scalar value 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))),lU,$APP.M($APP.K,vNb)],null)),
$APP.z(BJ,new $APP.f(null,3,[$APP.P,"generic exp.\n\nReturns the base-e exponential of `x`. Equivalent to `(expt e x)`, given\n  some properly-defined `e` symbol.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,ywb)],null)),$APP.z(ZDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WU],null)))),lU,$APP.M($APP.K,Vrb)],null)),$APP.z(OMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[UR],null)))),lU,$APP.M($APP.K,rXb)],null)),$APP.z(AX,new $APP.f(null,3,[$APP.P,"generic negative?.\n\nReturns true if the argument `a` is less than `(g/zero-like a)`,\n  false otherwise. The default implementation depends on a proper Comparable\n  implementation on the type.`",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,iSb)],null)),$APP.z(aRb,new $APP.f(null,3,[$APP.P,"Reverse-mode derivative operator. Takes some function `f` and returns a\n  function whose value at some point can multiply an increment in the arguments\n  to produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D-reverse]] computes a derivative. For vector-valued\n  functions, [[D-reverse]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,R7b)],null)),$APP.z(YV,new $APP.f(null,3,[$APP.P,"generic integer-part.\n\nReturns the integer part of `a` by removing any fractional digits.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,qbb)],null)),$APP.z(Xvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null)))),lU,$APP.M($APP.K,Jxb)],
null)),$APP.z(Iib,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,NX)],null)),$APP.z(yCb,new $APP.f(null,3,[$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null)))),lU,$APP.M($APP.K,lmb)],null)),$APP.z(wVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null)))),lU,$APP.M($APP.K,kOb)],null)),
$APP.z($5a,new $APP.f(null,3,[$APP.P,"To make a vector field into a one-form field, i.e., a (1,0) tensor into a (0,1)\n  tensor.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[jW],null)))),lU,$APP.M($APP.K,qdc)],null)),$APP.z(XMb,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - `c-\x3ee`, a function mapping coordinates to events\n  - `e-\x3ec`, a function mapping events to coordinates\n\n  and returns a function that takes:\n\n  - a symbolic name\n  - an ancestor frame\n  - a dictionary of params\n\n  and returns instance of [[IFrame]].\n\n  Both `c-\x3ee` and `e-\x3ec` must accept three arguments:\n\n  - `ancestor-frame`\n  - the [[IFrame]] instance\n  - a map of parameters supplied to the returned function (possibly empty!).",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[sX,aT],null)))),lU,$APP.M($APP.K,oSb)],null)),$APP.z($APP.MK,new $APP.f(null,3,[$APP.P,"Arity-preserving version of `clojure.core/comp`.\n\n  The arity of a composition is the arity of the rightmost (that is, first to be\n  applied) function term in `fns`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,bW],null))),lU,$APP.M($APP.K,n9b)],null)),$APP.z(UJb,new $APP.f(null,3,[$APP.P,"SICM p. 83",$APP.U,$APP.M($APP.K,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rV],null)))),lU,$APP.M($APP.K,nwb)],null)),$APP.z(Gtb,new $APP.f(null,2,[$APP.P,"Alias for [[raise]].",lU,$APP.M($APP.K,rib)],null)),$APP.z(mMb,new $APP.f(null,3,[$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],null))),lU,$APP.M($APP.K,eqb)],null)),
$APP.z(dIb,new $APP.f(null,3,[$APP.P,"Returns the single row from the supplied row matrix as a `down`. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(DV,$APP.Qr)],null)],null))))),lU,$APP.M($APP.K,qzb)],null)),$APP.z(eFb,new $APP.f(null,3,[$APP.P,"Find the minimum of the function `f: R -\x3e R` in the interval `[a, b]`.\n\n  If an `observe` function is supplied, it will be invoked with the iteration\n  count and the values of x and f(x) at each search step.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,dW],null))),lU,$APP.M($APP.K,iNb)],null)),$APP.z(hW,new $APP.f(null,3,[$APP.P,"generic asinh.\n\nComputes the [inverse hyperbolic\n sine](https://mathworld.wolfram.com/InverseHyperbolicSine.html) of the\n supplied argument `a`.\n\ndefaults to `ln(x + sqrt(1 + x^2))`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,
DOb)],null)),$APP.z(mYb,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - a `down` tuple of `components` of the one-form field relative to\n    `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a full one-form field.\n\n  A one-field field is an operator that takes a vector field to a real-valued\n  function on the manifold.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null))),lU,$APP.M($APP.K,RTb)],null)),$APP.z(uUb,new $APP.f(null,
2,[$APP.U,null,lU,$APP.M($APP.K,QZb)],null)),$APP.z(arb,new $APP.f(null,3,[$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x↑0 'x↑1 'x↑2))\n  ```",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null)))),lU,$APP.M($APP.K,y6b)],null)),$APP.z(Zdb,new $APP.f(null,1,[lU,$APP.M($APP.K,rhb)],null)),$APP.z(Jsb,
new $APP.f(null,1,[lU,$APP.M($APP.K,Zsb)],null)),$APP.z(GGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))),lU,$APP.M($APP.K,K2b)],null)),$APP.z(JFb,new $APP.f(null,1,[lU,$APP.M($APP.K,ZGb)],null)),$APP.z(iub,new $APP.f(null,3,[$APP.P,"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[emmy.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to handle [[Dual]]\n  inputs in addition to any types that a normal `(f x)` call would present. This\n  restriction does _not_ apply to operations like putting `x` into a container\n  or destructuring; just primitive function calls.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,Eyb)],null)),$APP.z(Sob,new $APP.f(null,2,[$APP.P,"Alias for [[raise]].",lU,$APP.M($APP.K,bjb)],null)),$APP.z(Qrb,new $APP.f(null,3,[$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.CY,oU,$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,
1,5,$APP.I,[$APP.M(sW,oU)],null)],null))))),lU,$APP.M($APP.K,qUb)],null)),$APP.z(u4b,new $APP.f(null,3,[$APP.P,"Optionally takes a dissipation function.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null))),lU,$APP.M($APP.K,agb)],null)),$APP.z(H9a,new $APP.f(null,3,[$APP.P,"p. 428, the Lie transform is just the time-advance operator using the Lie\n  derivative (see Hamiltonian.scm).",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.DU,$APP.Uv],null)))),lU,$APP.M($APP.K,Cqb)],null)),$APP.z(vac,new $APP.f(null,3,[$APP.P,"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[cW,OV,$APP.UU,KW,$APP.cX],null)))),lU,
$APP.M($APP.K,KIb)],null)),$APP.z(ynb,new $APP.f(null,2,[$APP.P,"Alias for [[lower]].",lU,$APP.M($APP.K,d2b)],null)),$APP.z(JAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[JU,yU,$APP.lP,$APP.wU],null)))),lU,$APP.M($APP.K,MIb)],null)),$APP.z(yac,new $APP.f(null,3,[$APP.P,"Renders an expression through the simplifier and onto the stream.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ww,dU],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,dU,$APP.Au],
null))),lU,$APP.M($APP.K,twb)],null)),$APP.z(n6b,new $APP.f(null,1,[lU,$APP.M($APP.K,omb)],null)),$APP.z($APP.lP,new $APP.f(null,1,[lU,$APP.M($APP.K,Dsb)],null)),$APP.z(OZb,new $APP.f(null,3,[$APP.P,"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null)))),lU,$APP.M($APP.K,iPb)],null)),$APP.z(xIb,new $APP.f(null,3,[$APP.P,"Accepts a coordinate transformation `F` from a local tuple to a new coordinate\n  structure, and returns a function from `local -\x3e local` that applies the\n  transformation directly.\n\n  [[F-\x3eC]] handles local tuples of arbitrary length.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null)))),lU,$APP.M($APP.K,HJb)],null)),$APP.z(qX,new $APP.f(null,3,[$APP.P,"generic tanh.\n\nComputes the [hyperbolic\n tangent](https://mathworld.wolfram.com/HyperbolicTangent.html) of the supplied\n argument `a`.\n\ndefaults to `sinh(x) / cosh(x)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,FKb)],null)),$APP.z(zcb,new $APP.f(null,3,[$APP.P,"Returns a set of patch names registered in the supplied manifold.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[aS],null)))),lU,$APP.M($APP.K,Fob)],null)),$APP.z(qCb,new $APP.f(null,1,[lU,$APP.M($APP.K,iwb)],null)),$APP.z(iec,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null)))),lU,$APP.M($APP.K,U$b)],null)),$APP.z(Bjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[jW,VU,$APP.Qr],null)))),lU,$APP.M($APP.K,L9b)],null)),$APP.z(lS,new $APP.f(null,3,[$APP.P,
"generic identity?.\n\nLike `one?`, but this is true of square identity matrices as well.\n  No matrix is considered `one?` because its function as a multiplicative\n  identity depends on the shape of the other multiplicand.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,vDb)],null)),$APP.z(Msb,new $APP.f(null,1,[lU,$APP.M($APP.K,Xsb)],null)),$APP.z(wcc,new $APP.f(null,3,[$APP.P,"generic zero-like.\n\nIn general, this procedure returns the additive identity of the type of its\n  argument, if it exists. For numbers this is 0.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,bFb)],null)),$APP.z(Brb,new $APP.f(null,1,[lU,$APP.M($APP.K,Sub)],null)),$APP.z(Mnb,new $APP.f(null,1,[lU,$APP.M($APP.K,Yqb)],null)),$APP.z(SIb,new $APP.f(null,3,[$APP.P,"Both arities of [[divergence]] are defined on page 156 of Functional Differential Geometry.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[jW,EV],null))),lU,$APP.M($APP.K,eOb)],
null)),$APP.z(m2b,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(Q2b,new $APP.f(null,3,[$APP.P,"Returns a set of names of all coordinate system constructors registered in the\n  supplied patch.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Gfb],null)))),lU,$APP.M($APP.K,cRb)],null)),$APP.z(EY,new $APP.f(null,3,[$APP.P,"generic angle",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Cub)],null)),$APP.z(rnb,new $APP.f(null,
1,[lU,$APP.M($APP.K,zpb)],null)),$APP.z(eH,new $APP.f(null,3,[$APP.P,"Derivative operator. Takes some function `f` and returns a function whose value\n  at some point can multiply an increment in the arguments to produce the best\n  linear estimate of the increment in the function value.\n\n  For univariate functions, [[D]] computes a derivative. For vector-valued\n  functions, [[D]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.\n\n  The related [[emmy.env/Grad]] returns a function that produces a structure of\n  the opposite orientation as [[D]]. Both of these functions use reverse-mode\n  automatic differentiation.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,uwb)],null)),$APP.z(y3b,new $APP.f(null,1,[lU,$APP.M($APP.K,Lab)],null)),$APP.z(B4a,new $APP.f(null,3,[$APP.P,"Computes the wedge product of the sequence `fs` of one-forms.\n\n  Higher rank forms can be constructed from one-forms by wedging them together.\n  This antisymmetric tensor product is computed as a determinant. The purpose of\n  this is to allow us to use the construction dx^dy to compute the area\n  described by the vectors that are given to it.\n\n  See Spivak p275 v1 of 'Differential Geometry' to see the correct definition.\n  The key is that the wedge of the coordinate basis forms had better be the\n  volume element.",
$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.px],null))),lU,$APP.M($APP.K,bhb)],null)),$APP.z($V,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Su],null)))),lU,$APP.M($APP.K,lbb)],null)),$APP.z(cbb,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is\n  a [One-form](https://en.wikipedia.org/wiki/One-form), false\n  otherwise.\n\n  A [One-form](https://en.wikipedia.org/wiki/One-form) takes a single vector\n  field to a real-valued function on the manifold.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null)))),lU,$APP.M($APP.K,TKb)],null)),$APP.z(Jwb,new $APP.f(null,1,[lU,$APP.M($APP.K,Wob)],null)),$APP.z(D1b,new $APP.f(null,3,[$APP.P,"Takes some constant `c` and returns a manifold function that maps every input\n  manifold `point` to `c.`",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null)))),lU,$APP.M($APP.K,ypb)],null)),$APP.z(n8b,new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3evector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,qW],null)))),lU,$APP.M($APP.K,Yzb)],null)),$APP.z(QCb,new $APP.f(null,3,[$APP.P,"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[emmy.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, i.e., the Taylor series expansion at `(\x3d x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[emmy.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[emmy.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null))),lU,$APP.M($APP.K,NUb)],null)),$APP.z(bS,new $APP.f(null,3,[$APP.P,"generic simplify",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,j6b)],null)),$APP.z(HV,new $APP.f(null,3,[$APP.P,"generic atanh.\n\nComputes the [inverse hyperbolic\n tangent](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) of the\n supplied argument `a`.\n\ndefaults to `1/2 ln((1+x)/(1-x))`.",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,Udc)],null)),$APP.z(x$b,new $APP.f(null,3,[$APP.P,"generic one?.\n\nIs true if `x` is a multiplicative identity.",$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null)))),lU,$APP.M($APP.K,nJb)],null)),$APP.z(f4b,new $APP.f(null,3,[$APP.P,"Returns the submatrix of the matrix (or matrix-like structure) `s` generated by\n  taking\n\n  - rows    from `lowrow` -\x3e `hirow` (inclusive)\n  - columns from `lowcol` -\x3e `hicol` (inclusive)",
$APP.U,$APP.M($APP.K,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Yv,N2b,ILb,Pac,QUb],null)))),lU,$APP.M($APP.K,f3b)],null))],[new $APP.f(null,3,[$APP.Q,Ppb,$APP.X,A9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[WV],null))),lU,enb],null)],null),new $APP.f(null,3,[$APP.Q,rLb,$APP.X,v7a,$APP.h,new $APP.f(null,3,[$APP.P,"Find the minimum of the function f: R^n -\x3e R, given an initial point q ∈ R^n.\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked with iteration count,\n  the values of X and the value of f(X) at each intermediate point of\n  evaluation.\n\n  `:info?` if true, wraps the result with evaluation information.\n\n  `:adaptive?` if true, the Nelder-Mead parameters for contraction, expansion,\n  reflection and shrinking will be set adaptively, as functions of the number of\n  dimensions. If false they stay constant.\n\n  `:alpha` sets the reflection coefficient used for each step of Nelder-Mead.\n\n  `:beta` sets the expansion coefficient used for each step of Nelder-Mead.\n\n  `:gamma` sets the contraction coefficient used for each step of Nelder-Mead.\n\n  `:sigma` sets the shrink coefficient used for each step of Nelder-Mead.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  200*dimension.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 200*dimension.\n\n  `:simplex-tolerance` When the absolute value of the max difference between the\n  best point and any point in the simplex falls below this tolerance, the\n  minimizer stops. Defaults to 1e-4.\n\n  `:fn-tolerance` When the absolute value of the max difference between the best\n  point's function value and the fn value of any point in the simplex falls\n  below this tolerance, the minimizer stops. Defaults to 1e-4.\n\n  `:zero-delta` controls the value to which 0 entries in the initial vector are\n  set during initial simplex generation. Defaults to 0.00025.\n\n  `:nonzero-delta` factor by which entries in the initial vector are perturbed to\n  generate the initial simplex. Defaults to 0.05.\n\n  See Gao, F. and Han, L.\n      Implementing the Nelder-Mead simplex algorithm with adaptive\n      parameters. 2012. Computational Optimization and Applications.\n      51:1, pp. 259-277\n  I gratefully acknowledge the [Python implementation in\n  SciPy](https://github.com/scipy/scipy/blob/589c9afe41774ee96ec121f1867361146add8276/scipy/optimize/optimize.py#L556:5)\n  which I have imitated here.\n  ",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Iy,$APP.PW,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.Gw],null),$APP.dk,$APP.Ox],null)],null))),lU,KUb],null)],null),new $APP.f(null,3,[$APP.Q,Krb,$APP.X,sI,$APP.h,new $APP.f(null,3,[$APP.P,"generic quotient",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,k6b],null)],null),new $APP.f(null,3,[$APP.Q,xkb,$APP.X,$APP.$Q,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.DU],null))),lU,Ptb],null)],null),new $APP.f(null,3,[$APP.Q,chb,$APP.X,L2a,$APP.h,new $APP.f(null,3,[$APP.P,"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null))),lU,LLb],null)],null),new $APP.f(null,3,[$APP.Q,LGb,$APP.X,q5a,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a system derivative `R` and returns a operator that takes a function `F`\n  of coordinatized state and performs the operation described below, from\n  ODE.scm in scmutils:\n\n  Let `(sigma t)` be the state of a system at time `t`. Let the\n  (first-order) system of differential equations governing the evolution of\n  this state be:\n\n  ```clojure\n  ((D sigma) t) \x3d (R (sigma t))\n  ```\n\n  ```clojure\n  (D sigma) \x3d (compose R sigma)\n  ```\n\n  i.e. `R` is a system derivative.\n\n  Let `F` be any function of state, then a differential equation for the\n  evolution of `F`, as it is dragged along the integral curve sigma is:\n\n  ```clojure\n  (D (compose F sigma)) \x3d (* (compose (D F) sigma) (D sigma))\n  \x3d (compose (* (D F) R) sigma)\n  ```\n\n  Let's call this operation `Lie-D` (the Lie derivative for coordinates).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null))),lU,Fjb],null)],null),new $APP.f(null,3,[$APP.Q,aec,$APP.X,S2,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a row matrix populated by the supplied `xs`. Variadic equivalent\n  to [[row*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),lU,h7b],null)],null),new $APP.f(null,3,[$APP.Q,jfb,$APP.X,h6a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a data structure representing [Christoffel symbols of the first\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_first_kind).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[FX,VU],null))),lU,sbb],null)],null),new $APP.f(null,3,[$APP.Q,Tob,$APP.X,XP,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a `metric` and a `spec` and returns the [Hodge star\n  operator](https://en.wikipedia.org/wiki/Hodge_star_operator) (actually just a\n  function, but I suspect this should be a proper operator!)\n\n  `spec` may be:\n\n  - a coordinate system with an orthonormal basis\n  - an orthonormal basis\n  - a basis\n\n  if the spec is a basis that needs to be orthonormalized, the optional\n  `:orthonormalize?` keyword argument must be a coordinate system.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[jW,$APP.Dw,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[OT],null),$APP.Ml,new $APP.f(null,1,[OT,!1],null)],null)],null)),lU,Nbb],null)],null),new $APP.f(null,3,[$APP.Q,hXb,$APP.X,UQ,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.FU,xU,KW,LW],null),new $APP.H(null,5,5,$APP.I,[$APP.FU,xU,KW,LW,ZV],null)),lU,y1b],null)],null),new $APP.f(null,3,[$APP.Q,Pgb,$APP.X,z2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` implements [[IFrame]], false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,gxb],null)],null),new $APP.f(null,3,[$APP.Q,VJb,$APP.X,LSa,$APP.h,new $APP.f(null,3,[$APP.P,"Alias for [[solve-linear]]; present for compatibility with the original\n  `scmutils` codebase.\n\n  NOTE: In `scmutils`, `solve-linear-left` and `solve-linear` act identically in\n  all cases except matrices. `solve-linear-left` only accepted a column\n  matrix (or up structure) in the `b` position, while `solve-linear` accepted\n  either a column or row (up or down structure).\n\n  In Emmy, both functions accept either type.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,KLb],null)],null),new $APP.f(null,3,[$APP.Q,M6b,$APP.X,y4,$APP.h,new $APP.f(null,3,[$APP.P,"SICM p. 23. The optional parameter values is a callback which will report\n  intermediate points of the minimization.",$APP.U,$APP.M(new $APP.H(null,8,5,$APP.I,[bY,JW,CW,KW,DW,$APP.wU,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[dW],null)],null)],null)),lU,cKb],null)],null),new $APP.f(null,3,[$APP.Q,qYb,$APP.X,
F2a,$APP.h,new $APP.f(null,3,[$APP.P,"Marks (via metadata) the supplied set of `coords` as being owned by `owner`. If\n  `coords` already has an owner (that is not equal to `owner`), throws.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.pW,h6b],null))),lU,Ffb],null)],null),new $APP.f(null,3,[$APP.Q,K$b,$APP.X,CG,$APP.h,new $APP.f(null,3,[$APP.P,"generic remainder.\n\nReturns the remainder of dividing the dividend `a` by divisor `b`.\n\n The contract satisfied by [[remainder]] is:\n\n```clojure\n(\x3d a (+ (* b (quotient a b))\n        (remainder a b)))\n```\n\n For numbers, this differs from the contract offered by [[modulo]]\n because [[quotient]] rounds toward 0, while `(floor (/ a b))` rounds toward\n negative infinity.\n\n The result will be either `0` or of the same sign as the dividend `a`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,w9b],null)],null),new $APP.f(null,3,[$APP.Q,pvb,$APP.X,lZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic identity-like.\n\nLike `one-like` but works for square matrices.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,i4b],null)],null),new $APP.f(null,3,[$APP.Q,YEb,$APP.X,z0,$APP.h,new $APP.f(null,3,[$APP.P,"[Chinese Remainder Algorithm](https://en.wikipedia.org/wiki/Chinese_remainder_theorem).\n\n  Accepts a sequence of [[ModInt]] instances (where the `modulus` of\n  all [[ModInt]] instances are relatively prime), and returns a [[ModInt]] `x`\n  such that `(residue input) \x3d\x3d (mod x (modulus input))`.\n\n  For example:\n\n  ```clojure\n  (let [a1 (m/make 2 5)\n        a2 (m/make 3 13)]\n    [(\x3d 42 (chinese-remainder a1 a2))\n     (\x3d (residue a1) (mod cr (modulus a1)))\n     (\x3d (residue a2) (mod cr (modulus a2)))])\n  ;;\x3d\x3e [true true true]\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,oX],null)),lU,pbb],null)],null),new $APP.f(null,3,[$APP.Q,Aac,$APP.X,i1,$APP.h,new $APP.f(null,3,[$APP.P,"Return a [[PowerSeries]] starting with the supplied values. The remainder of\n  the series will be filled with the zero-value corresponding to the first of\n  the given values.\n\n  If you have a sequence already, prefer [[power-series*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.sx],null)),lU,z2b],null)],null),new $APP.f(null,3,
[$APP.Q,qxb,$APP.X,arc,$APP.h,new $APP.f(null,1,[lU,Mwb],null)],null),new $APP.f(null,3,[$APP.Q,tcc,$APP.X,xrc,$APP.h,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that\n  calculates the [Divergence](https://en.wikipedia.org/wiki/Divergence) of\n  `f` at its input point.\n\n  The divergence is a one-level contraction of the gradient.",lU,o3b],null)],null),new $APP.f(null,3,[$APP.Q,CQb,$APP.X,R4,$APP.h,new $APP.f(null,4,[$APP.P,"[[using-coordinates]] wraps [[let-coordinates]] and allows you to supply a\n  single coordinate prototype and a single coordinate system.\n  See [[let-coordinates]] for details about what symbols are bound inside the\n  body.\n\n  Example:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect\n                     body...)\n  ```",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[pU,qW,$APP.Lh,$APP.Tw],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,Svb,$APP.X,GZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic csch.\n\nComputes the [hyperbolic\n cosecant](https://mathworld.wolfram.com/HyperbolicCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / sinh(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,b9b],null)],null),new $APP.f(null,3,[$APP.Q,hBb,$APP.X,V2a,$APP.h,new $APP.f(null,
3,[$APP.P,"Returns a function which rotates a vector α radians about the y axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,dbc],null)],null),new $APP.f(null,3,[$APP.Q,fkb,$APP.X,Vqc,$APP.h,new $APP.f(null,1,[lU,eDb],null)],null),new $APP.f(null,3,[$APP.Q,x5b,$APP.X,r9a,$APP.h,new $APP.f(null,3,[$APP.P,"SICM p. 47. Polar to rectangular coordinates of state.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GX],null))),lU,d9b],null)],null),new $APP.f(null,3,[$APP.Q,
sBb,$APP.X,s3,$APP.h,new $APP.f(null,1,[lU,Uob],null)],null),new $APP.f(null,3,[$APP.Q,RYb,$APP.X,$9a,$APP.h,new $APP.f(null,3,[$APP.P,"p. 334",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),lU,vUb],null)],null),new $APP.f(null,3,[$APP.Q,A6b,$APP.X,J3,$APP.h,new $APP.f(null,3,[$APP.P,"Alternative definition of [[wedge]] in terms of alternation.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null)),lU,qmb],null)],null),new $APP.f(null,3,[$APP.Q,Csb,$APP.X,$O,$APP.h,
new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null)),lU,p_b],
null)],null),new $APP.f(null,3,[$APP.Q,Kmb,$APP.X,MQ,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[time]].",lU,EDb],null)],null),new $APP.f(null,3,[$APP.Q,amb,$APP.X,Hqc,$APP.h,new $APP.f(null,1,[lU,B0b],null)],null),new $APP.f(null,3,[$APP.Q,GTb,$APP.X,QZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic make-polar",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,gcc],null)],null),new $APP.f(null,3,[$APP.Q,jLb,$APP.X,eP,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is a form field operator, false otherwise.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[SVb],null))),lU,qec],null)],null),new $APP.f(null,3,[$APP.Q,a2b,$APP.X,cO,$APP.h,new $APP.f(null,3,[$APP.P,"Accepts a reference frame and an `event`, and returns this reference\n    frame's coordinate representation of the supplied `event`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.Qx],null))),lU,g6b],null)],null),new $APP.f(null,3,[$APP.Q,W2b,$APP.X,VK,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the orientation of `s`, either `::up` or `::down`. Defaults to `::up`,\n  even for non-structures.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),lU,Asb],null)],null),new $APP.f(null,3,[$APP.Q,mqb,$APP.X,qZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic cube",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,q_b],null)],null),new $APP.f(null,3,[$APP.Q,uBb,$APP.X,m3,$APP.h,new $APP.f(null,1,[lU,Mob],null)],null),new $APP.f(null,3,[$APP.Q,Rfb,$APP.X,wL,$APP.h,new $APP.f(null,3,[$APP.P,"Construct an up (contravariant) tuple from the arguments.\n\n  Variadic version of [[up*]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),lU,NP],null)],null),new $APP.f(null,3,[$APP.Q,EFb,$APP.X,y6a,$APP.h,new $APP.f(null,3,[$APP.P,"[[gradient]] implements equation (10.3) in Functional Differential Geometry,\n  defined on page 154.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),lU,Dgb],null)],null),new $APP.f(null,3,[$APP.Q,tFb,$APP.X,NZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic tanc.\n\n`tanc` is defined, by analogy with [[sinc]], to be equal to $\\frac{\\tan\n  x}{x}$ for nonzero $x$ and equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/TancFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,uLb],null)],null),new $APP.f(null,3,[$APP.Q,nZb,$APP.X,aR,$APP.h,new $APP.f(null,3,[$APP.P,"generic determinant",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Xqb],null)],null),new $APP.f(null,3,[$APP.Q,IMb,$APP.X,oP,$APP.h,new $APP.f(null,3,[$APP.P,"Extract the dual basis from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,
1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null)))),lU,reb],null)],null),new $APP.f(null,3,[$APP.Q,DPb,$APP.X,N4a,$APP.h,new $APP.f(null,3,[$APP.P,"Make a basis object out of a vector and dual basis.\n\n  The dimensions of `vector-basis` and `dual-basis` must agree.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,tW],null))),lU,W$b],null)],null),new $APP.f(null,3,[$APP.Q,I1b,$APP.X,xH,$APP.h,new $APP.f(null,3,[$APP.P,"generic sinh.\n\nComputes the [hyperbolic\n sine](https://mathworld.wolfram.com/HyperbolicSine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x - e^{-x}) / 2`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,fJb],null)],null),new $APP.f(null,3,[$APP.Q,GFb,$APP.X,Y5a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a metric and a basis, computes the inverse metric.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),lU,Teb],null)],null),new $APP.f(null,3,[$APP.Q,Vdb,$APP.X,vQ,$APP.h,new $APP.f(null,3,[$APP.P,"Find the minimum of the function f: R -\x3e R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id\x3dAITCAgAAQBAJ\x26q\x3dBrent%E2%80%99s#v\x3donepage\x26q\x3dParabolic\x26f\x3dfalse).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  [[brent-min]] supports the following optional keyword arguments:\n\n  - `:callback`: if supplied, the supplied fn will be invoked at each\n    intermediate point with the iteration count and the values of x and f(x) at\n    each search step.\n\n  - `:initial-guess`: the first internal point checked by the algorithm. Defaults\n    to `([[initial-brent-guess]] a b)`.\n\n  - `:relative-threshold`: multiplied by each guess to determine a relative\n    threshold. Defaults to 1.0e-11.\n\n  - `:absolute-threshold`: a smaller absolute threshold that applies when the\n    candidate minimum point is close to 0. defaults to around 1.49e8, the sqrt of\n    the machine tolerance. You won't gain any benefit attempting to set the value\n    less than the default.\n\n  - `:maxiter`: Maximum number of iterations allowed for the minimizer. Defaults\n    to 1000.\n\n  - `:maxfun`: Maximum number of times the function can be evaluated before\n    exiting. Defaults to `(inc maxiter)`.\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,6,5,$APP.I,[PT,RT,RY,KT,uX,$APP.Gw],null),$APP.Ml,new $APP.f(null,5,[PT,AV,RT,QY,RY,$APP.M(WT,$APP.Lv,$APP.sU),KT,1E3,$APP.Gw,$APP.M($APP.fw,null)],null)],null)],null)),lU,Tjb],null)],null),new $APP.f(null,3,[$APP.Q,Tdb,$APP.X,SF,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[/]].",lU,r_b],null)],null),new $APP.f(null,3,[$APP.Q,ayb,
$APP.X,w4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a one-form field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3eoneform-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-form-field`'s component\n  functions will accept a single non-structural argument.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,qW],null))),lU,EPb],null)],null),new $APP.f(null,3,[$APP.Q,gBb,$APP.X,U2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector α radians about the x axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,Xac],null)],null),new $APP.f(null,3,[$APP.Q,GZb,$APP.X,GP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Gx,VU],null))),lU,uhb],null)],null),new $APP.f(null,
3,[$APP.Q,hZb,$APP.X,mP,$APP.h,new $APP.f(null,3,[$APP.P,"One of the two incompatible definitions of differential.\n\n  This differential is a special case of exterior derivative. The other one\n  lives at [[map/differential]].",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(CHb,$APP.Nv)],null)],null)))),lU,Ueb],null)],null),new $APP.f(null,3,[$APP.Q,oUb,$APP.X,Jrc,$APP.h,new $APP.f(null,2,[$APP.P,"Converts an S-expression to printable infix form. Numeric exponents are\n  written as superscripts. Partial derivatives get subscripts.",
lU,nHb],null)],null),new $APP.f(null,3,[$APP.Q,Zdc,$APP.X,O4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a basis, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,GWb],null)],null),new $APP.f(null,3,[$APP.Q,$hb,$APP.X,X1a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the single column from the supplied column matrix as a vector. Errors\n  if some other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],
null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(qY,$APP.Qr)],null)],null)))),lU,XDb],null)],null),new $APP.f(null,3,[$APP.Q,l8b,$APP.X,j6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[jW,VU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rS,VU)],null)],null)))),lU,Mbc],null)],null),new $APP.f(null,3,[$APP.Q,kec,$APP.X,GO,$APP.h,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from coordinates in\n  `coordinate-system`'s repesentation to the matching point on the manifold\n  associated with `coordinate-system`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,a$b],null)],null),new $APP.f(null,3,[$APP.Q,CBb,$APP.X,Iqc,$APP.h,new $APP.f(null,1,[lU,sob],null)],null),new $APP.f(null,3,[$APP.Q,Ndb,$APP.X,P4,$APP.h,new $APP.f(null,3,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,WXb,$APP.X,iO,$APP.h,new $APP.f(null,3,[$APP.P,"generic sin.\n\nReturns the [sine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,pib],null)],null),new $APP.f(null,3,[$APP.Q,Zyb,$APP.X,yrc,$APP.h,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a function that\n  calculates the [Curl](https://en.wikipedia.org/wiki/Curl_(mathematics)) of `f`\n  at its input point.\n\n  `f` must be a function from $\\mathbb{R}^3 \\to \\mathbb{R}^3$.",lU,gMb],null)],null),new $APP.f(null,3,[$APP.Q,qrb,$APP.X,zrc,$APP.h,new $APP.f(null,2,[$APP.P,
"Operator that takes a function `f` and returns a function that calculates\n  the [Vector\n  Laplacian](https://en.wikipedia.org/wiki/Laplace_operator#Vector_Laplacian) of\n  `f` at its input point.",lU,Fzb],null)],null),new $APP.f(null,3,[$APP.Q,fTb,$APP.X,J2a,$APP.h,new $APP.f(null,3,[$APP.P,"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.ix],null))),lU,xdc],null)],null),new $APP.f(null,3,[$APP.Q,
NAb,$APP.X,$qc,$APP.h,new $APP.f(null,1,[lU,x_b],null)],null),new $APP.f(null,3,[$APP.Q,Fsb,$APP.X,Hqc,$APP.h,new $APP.f(null,1,[lU,sAb],null)],null),new $APP.f(null,3,[$APP.Q,Wzb,$APP.X,kM,$APP.h,new $APP.f(null,3,[$APP.P,"generic exact-divide.\n\nSimilar to the binary case of [[/]], but throws if `(g/exact? \x3cresult\x3e)`\n  returns false.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,l2b],null)],null),new $APP.f(null,3,[$APP.Q,dHb,$APP.X,USa,$APP.h,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),lU,BAb],null)],null),new $APP.f(null,3,[$APP.Q,DUb,$APP.X,vZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic tan.\n\nComputes the trigonometric tangent function of the supplied argument `a`.\n\nEquivalent to `(/ (sin a) (cos a))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,OBb],null)],null),new $APP.f(null,3,[$APP.Q,vtb,$APP.X,XF,$APP.h,new $APP.f(null,3,[$APP.P,"generic solve-linear.\n\nFor a given `a` and `b`, returns `x` such that `a*x \x3d b`.\n\n  See[[solve-linear-right]] for a similar function that solves for `a \x3d x*b`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,Xbc],null)],null),new $APP.f(null,3,[$APP.Q,Sjb,$APP.X,cG,$APP.h,new $APP.f(null,3,[$APP.P,"generic freeze.\n\nFreezing an expression means removing wrappers and other metadata from\n  subexpressions, so that the result is basically a pure S-expression with the\n  same structure as the input. Doing this will rob an expression of useful\n  information for further computation; so this is intended to be done just\n  before simplification and printing, to simplify those processes.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,LUb],null)],null),new $APP.f(null,3,[$APP.Q,E_b,$APP.X,tab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null))),lU,v0b],null)],null),new $APP.f(null,3,[$APP.Q,Gsb,$APP.X,B5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[ZT],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(IT,ZT)],null)],null)))),lU,xJb],null)],null),
new $APP.f(null,3,[$APP.Q,wdb,$APP.X,P4a,$APP.h,new $APP.f(null,3,[$APP.P,"Extract the dimension from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null)))),lU,Kub],null)],null),new $APP.f(null,3,[$APP.Q,YKb,$APP.X,NO,$APP.h,new $APP.f(null,3,[$APP.P,"generic dimension",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Xcb],null)],
null),new $APP.f(null,3,[$APP.Q,jUb,$APP.X,y5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),lU,d_b],null)],null),new $APP.f(null,3,[$APP.Q,X_b,$APP.X,u6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null))),lU,vwb],null)],null),new $APP.f(null,3,[$APP.Q,Qab,$APP.X,c6a,$APP.h,new $APP.f(null,3,[$APP.P,"For making a (0,2) tensor into a (2,0) tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],
null))),lU,ajb],null)],null),new $APP.f(null,3,[$APP.Q,NPb,$APP.X,E2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the owning [[IFrame]] instance of the supplied coordinates `coords`,\n  nil if there's no owner otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null))),lU,ELb],null)],null),new $APP.f(null,3,[$APP.Q,Qyb,$APP.X,SN,$APP.h,new $APP.f(null,1,[lU,Eob],null)],null),new $APP.f(null,3,[$APP.Q,knb,$APP.X,Qqc,$APP.h,new $APP.f(null,1,[lU,O6b],null)],null),new $APP.f(null,
3,[$APP.Q,OKb,$APP.X,S4,$APP.h,new $APP.f(null,2,[$APP.P,"A shim so that ref can act like nth in SICM contexts, as clojure core ref\n  elsewhere.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,3,5,$APP.I,[$APP.Lv,$APP.Lh,yW],null))],null)],null),new $APP.f(null,3,[$APP.Q,zob,$APP.X,S4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the Jacobian of transition from `from-basis` to `to-basis`.\n\n  The Jacobian is a structure of manifold functions. The outer index is the\n  from-basis index, so this structure can be multiplied by tuple of component\n  functions of a vector field relative to `from-basis` to get component\n  functions for a vector field in `to-basis`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wsb,DMb],null))),lU,dQb],null)],null),new $APP.f(null,3,[$APP.Q,S5b,$APP.X,kO,$APP.h,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of α radians about the y axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,isb],null)],null),new $APP.f(null,3,[$APP.Q,lub,$APP.X,OZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic tanhc.\n\nThe [tanhc function](https://en.wikipedia.org/wiki/Tanhc_function),\n  equivalent to $\\frac{\\tanh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanhc_function)\n   - [Mathworld page on Tanhc](https://mathworld.wolfram.com/TanhcFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,cfb],null)],null),new $APP.f(null,3,[$APP.Q,mSb,$APP.X,hO,$APP.h,new $APP.f(null,3,[$APP.P,"generic cos.\n\nReturns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,RDb],null)],null),new $APP.f(null,3,[$APP.Q,snb,$APP.X,function(a){return["$",$APP.m.j(S3(dG.j(a))),"$"].join("")},$APP.h,new $APP.f(null,2,
[$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in single\n  `$` to mark the string as an inline LaTeX form.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.Q,pFb,$APP.X,$3a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components-\x3evector-field\n     (up x y)\n     (coordinate-system-\x3evector-basis R2-rect)))\n  ;; \x3d\x3e (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[XV,zU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(KFb,XV,zU)],null)],null)))),lU,yYb],null)],null),new $APP.f(null,3,[$APP.Q,Yab,$APP.X,eO,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the parameters registered with the supplied frame.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),lU,EYb],null)],null),new $APP.f(null,3,[$APP.Q,YCb,$APP.X,A4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a structure `w` of and a vector field basis `vector-basis`, returns a new\n  structure generated by applying the full vector basis to each element of `w`.\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [vb    (vf/coordinate-system-\x3evector-basis coordsys)\n        basis (coordinate-system-\x3eoneform-basis coordsys)\n        components (down d:dx d:dy)]\n    (\x3d components\n       (-\x3e components\n           (basis-components-\x3eoneform-field basis)\n           (oneform-field-\x3ebasis-components vb))))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[qyb,zU],null))),lU,URb],null)],null),new $APP.f(null,3,[$APP.Q,u3b,$APP.X,c9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))),lU,MOb],null)],null),new $APP.f(null,3,[$APP.Q,oVb,$APP.X,HQ,$APP.h,new $APP.f(null,3,[$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns the result of aggregating either `xs` or `(map f (range low\n  high))` using the fold dynamically bound to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (sum inc 0 10))\n  ;;\x3d\x3e [55.0 1 10]\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null)),lU,$gb],null)],null),new $APP.f(null,3,[$APP.Q,pPb,$APP.X,g5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Yw,$APP.iy,bZb],null))),lU,FRb],null)],null),new $APP.f(null,3,[$APP.Q,kac,$APP.X,yM,$APP.h,new $APP.f(null,3,[$APP.P,"generic gcd.\n\nReturns the [greatest common\n  divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the two\n  inputs `a` and `b`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,ZTb],null)],null),new $APP.f(null,3,[$APP.Q,XAb,$APP.X,nZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic exp10.\n\nReturns the base-10 exponential of `x`. Equivalent to `(expt 10 x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,sJb],null)],null),new $APP.f(null,3,[$APP.Q,lXb,$APP.X,r3,$APP.h,new $APP.f(null,1,[lU,pSb],null)],null),new $APP.f(null,3,[$APP.Q,cSb,$APP.X,w3a,$APP.h,new $APP.f(null,
3,[$APP.P,"Returns a function that takes a single manifold `point` embedded in the\n  manifold `embedded` and transfers the point to the supplied `embedding`\n  manifold.\n\n  The embedding dimension must be the same for both manifolds.\n\n  NOTE that `embedded` and `embedding` can be either manifolds, or instances\n  of [[ICoordinateSystem]]. In the latter case `embedded` and `embedding` will\n  bind to the manifold associated with the supplied [[ICoordinateSystem]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[tKb,K9b],null))),lU,q$b],null)],null),new $APP.f(null,3,[$APP.Q,eGb,$APP.X,VZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic cross-product",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,c5b],null)],null),new $APP.f(null,3,[$APP.Q,tsb,$APP.X,FSa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a predicate that returns true if its argument matches the supplied\n  kind-keyword `k`, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],
null))),lU,HVb],null)],null),new $APP.f(null,3,[$APP.Q,tOb,$APP.X,i5a,$APP.h,new $APP.f(null,3,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))),lU,CNb],null)],null),new $APP.f(null,3,[$APP.Q,Vnb,$APP.X,JP,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a data structure representing [Christoffel symbols of the second\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_second_kind_(symmetric_definition)).",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[FX,VU],null))),lU,oac],null)],null),new $APP.f(null,3,[$APP.Q,VXb,$APP.X,z5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),lU,KXb],null)],null),new $APP.f(null,3,[$APP.Q,xeb,$APP.X,d4a,$APP.h,new $APP.f(null,3,[$APP.P,"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[gNb],null))),lU,N5b],null)],null),new $APP.f(null,3,[$APP.Q,zOb,$APP.X,xP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,xV],null))),lU,O0b],null)],null),new $APP.f(null,3,[$APP.Q,fcc,$APP.X,CP,$APP.h,new $APP.f(null,
3,[$APP.P,"Defined on FDG p.72.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))),lU,LAb],null)],null),new $APP.f(null,3,[$APP.Q,TSb,$APP.X,NZa,$APP.h,new $APP.f(null,3,[$APP.P,"Form a down-tuple from a vector.\n\n  NOTE that this is an alias of [[down*]] that is more restrictive, in that it\n  only accepts a vector. Use [[down*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[down*]]) it will be just as efficient.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null)))),lU,H9b],null)],null),new $APP.f(null,3,[$APP.Q,Fbb,$APP.X,OQ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the velocity element of a local tuple (by convention, the third\n  element).\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,
$APP.M($APP.tv,rV),2)],null)],null)))),lU,qLb],null)],null),new $APP.f(null,3,[$APP.Q,teb,$APP.X,jab,$APP.h,new $APP.f(null,3,[$APP.P,"Legendre elliptic integral of the first kind F(φ, k).\n   See W.H. Press, Numerical Recipes in C++, 2ed. eq. 6.11.19\n\n  See [page 260](http://phys.uri.edu/nigh/NumRec/bookfpdf/f6-11.pdf).",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[ZR,$APP.vU],null))),lU,J7b],null)],null),new $APP.f(null,3,[$APP.Q,m7b,$APP.X,nI,$APP.h,new $APP.f(null,3,[$APP.P,"generic modulo.\n\nReturns the result of the\n  mathematical [Modulo](https://en.wikipedia.org/wiki/Modulo_operation)\n  operation between `a` and `b` (using the Knuth definition listed).\n\n The contract satisfied by [[modulo]] is:\n\n```clojure\n(\x3d a (+ (* b (floor (/ a b)))\n        (modulo a b)))\n```\n\n For numbers, this differs from the contract offered by [[remainder]]\n because `(floor (/ a b))` rounds toward negative infinity, while\n the [[quotient]] operation in the contract for [[remainder]] rounds toward 0.\n\n The result will be either `0` or of the same sign as the divisor `b`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,xlb],null)],null),new $APP.f(null,3,[$APP.Q,NEb,$APP.X,vrc,$APP.h,new $APP.f(null,3,[$APP.P,"Forward-mode derivative operator. Takes some function `f` and returns a\n  function whose value at some point can multiply an increment in the arguments\n  to produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D-forward]] computes a derivative. For vector-valued\n  functions, [[D-forward]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,Wxb],null)],null),new $APP.f(null,3,[$APP.Q,DCb,$APP.X,a5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[JU,VU],null))),lU,RNb],null)],null),new $APP.f(null,3,[$APP.Q,CEb,$APP.X,SF,$APP.h,new $APP.f(null,3,[$APP.P,"Generic implementation of `/`.\n\n  If one argument is supplied, returns the multiplicative inverse of `a`. Else\n  returns the result of dividing first argument `a` by the product of all\n  remaining arguments. `(/)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core//`. Dispatch is open,\n  however, making it possible to 'divide' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (/ [2 4 6] 2)\n  ;;\x3d\x3e (up 1 2 3)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null)),lU,Ypb],null)],null),new $APP.f(null,3,[$APP.Q,fcb,$APP.X,PR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$W,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null))),lU,bIb],null)],null),new $APP.f(null,3,[$APP.Q,Kab,$APP.X,y2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the ancestor [[IFrame]] instance of this frame, or nil if there is\n    no ancestor.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),lU,emb],null)],null),new $APP.f(null,3,[$APP.Q,eRb,$APP.X,vP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,xV],null))),lU,TQb],null)],null),new $APP.f(null,
3,[$APP.Q,vTb,$APP.X,a4,$APP.h,new $APP.f(null,3,[$APP.P,"Entrypoint for multidimensional minimization routines.\n\n  See [[emmy.numerical.multimin.nelder-mead/nelder-mead]] for the only\n  supported option.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Iy,$APP.PW,$APP.Lh,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[eY],null),$APP.dk,$APP.Ox],null)],null)),lU,pMb],null)],null),new $APP.f(null,3,[$APP.Q,rYb,$APP.X,C5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[tyb],null))),lU,QDb],null)],null),new $APP.f(null,3,[$APP.Q,Nfb,$APP.X,JXa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a [[PowerSeries]] instance representing a\n  [Binomial series](https://en.wikipedia.org/wiki/Binomial_series), i.e., the\n  taylor series of the function $f$ given by\n\n  ```\n  $$f(x) \x3d (1 + x)^\\alpha$$\n  ```",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null))),lU,ohb],null)],null),new $APP.f(null,3,[$APP.Q,fhb,$APP.X,Aab,$APP.h,new $APP.f(null,2,
[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null))),lU,MXb],null)],null),new $APP.f(null,3,[$APP.Q,$Ib,$APP.X,mab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[iS],null))),lU,WMb],null)],null),new $APP.f(null,3,[$APP.Q,mBb,$APP.X,p3,$APP.h,new $APP.f(null,1,[lU,ipb],null)],null),new $APP.f(null,3,[$APP.Q,npb,$APP.X,p9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GX],null))),lU,nKb],null)],null),new $APP.f(null,
3,[$APP.Q,WSb,$APP.X,HI,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the factorial of `n`, i.e., the product of 1 to `n` (inclusive).\n\n  [[factorial]] will return a platform-specific [[emmy.util/bigint]] given\n  some `n` that causes integer overflow.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(rW,$APP.wU),$APP.M($APP.cw,$APP.wU,0)],null)],null)))),lU,Sqb],null)],null),new $APP.f(null,3,[$APP.Q,ocb,$APP.X,
erc,$APP.h,new $APP.f(null,1,[lU,hrb],null)],null),new $APP.f(null,3,[$APP.Q,hIb,$APP.X,WQ,$APP.h,new $APP.f(null,1,[lU,Pvb],null)],null),new $APP.f(null,3,[$APP.Q,cub,$APP.X,U3,$APP.h,new $APP.f(null,3,[$APP.P,"Golden Section search attempts to locate the minimum of the supplied function\n  `f` by evaluating points located at golden-ratioed intervals between the two\n  starting endpoints `a` and `b`. This method is slow, steady and reliable.\n\n  Supports the following optional keyword arguments:\n\n  `:converged?` is an optional predicate accepting five arguments:\n\n  - `[a fa]`\n  - `[l fl]`\n  - `[r fr]`\n  - `[b fb]`\n  - `current-iteration`\n\n  If the supplied `fn` returns true, it will signal convergence and the\n  optimizer will return. Returning false will continue.\n\n  `:choose` is called at the final step of optimization with all 4 points and\n  their fn values (see the first four arguments to `:converged?`), and returns\n  the final choice.\n\n  `:callback` receives all 5 arguments on every iteration.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n\n  `:fn-tolerance` check that the minimal value of any of the checked points is\n  within the maximum of f(a) or f(b).\n\n  `:arg-tolerance` check that `a` and `b` are within this supplied absolute\n  distance.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,2,5,$APP.I,[YX,$APP.Gw],null),$APP.Ml,new $APP.f(null,2,[YX,kW,$APP.Gw,$APP.M($APP.fw,null)],null),$APP.dk,$APP.Ox],null)],null)),lU,f9b],null)],null),new $APP.f(null,3,[$APP.Q,Hvb,$APP.X,VF,$APP.h,new $APP.f(null,3,[$APP.P,"generic exact?.\n\nEntries that are exact are available for `gcd`, among other operations.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),lU,plb],null)],null),new $APP.f(null,3,[$APP.Q,Grb,$APP.X,t6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null))),lU,REb],null)],null),new $APP.f(null,3,[$APP.Q,h5b,$APP.X,Wqc,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to the [[S2-spherical]] coordinate system, with the north pole rotated\n  90 degrees and lying along the positive y axis.",lU,hmb],null)],null),new $APP.f(null,3,[$APP.Q,x4b,$APP.X,UZ,$APP.h,new $APP.f(null,3,[$APP.P,
"generic outer-product",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,qtb],null)],null),new $APP.f(null,3,[$APP.Q,FNb,$APP.X,tsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,sEb,$APP.X,TO,$APP.h,new $APP.f(null,3,[$APP.P,"Convert the structure `ms`, which would be a scalar if the (compatible)\n  multiplication `(* ls ms rs)` were performed, to a matrix.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[BW,MW],null),new $APP.H(null,3,5,$APP.I,[AW,BW,MW],null)),lU,IJb],
null)],null),new $APP.f(null,3,[$APP.Q,kGb,$APP.X,W2a,$APP.h,new $APP.f(null,1,[lU,Ysb],null)],null),new $APP.f(null,3,[$APP.Q,WKb,$APP.X,jG,$APP.h,new $APP.f(null,3,[$APP.P,"generic abs",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Wcb],null)],null),new $APP.f(null,3,[$APP.Q,c7b,$APP.X,K4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a coordinate basis, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,V1b],null)],
null),new $APP.f(null,3,[$APP.Q,gkb,$APP.X,$2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold, false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),lU,Y_b],null)],null),new $APP.f(null,3,[$APP.Q,A7b,$APP.X,QF,$APP.h,new $APP.f(null,3,[$APP.P,"generic invert.\n\nReturns the multiplicative inverse of `a`.\n\n  Equivalent to `(/ 1 a)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,
EGb],null)],null),new $APP.f(null,3,[$APP.Q,PEb,$APP.X,$APP.Kd,$APP.h,new $APP.f(null,2,[$APP.P,"Identity function. Returns its argument.",lU,jYb],null)],null),new $APP.f(null,3,[$APP.Q,VTb,$APP.X,Z5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,NRb],null))),lU,MZb],null)],null),new $APP.f(null,3,[$APP.Q,Psb,$APP.X,RP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[lower]].",lU,dTb],null)],null),new $APP.f(null,3,[$APP.Q,cBb,$APP.X,EN,$APP.h,new $APP.f(null,3,
[$APP.P,"Returns a matrix whose rows consist of the supplied sequence of `rows`. These\n  all must be the same length.\n\n  Variadic equivalent to [[by-rows*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,BV],null)),lU,gec],null)],null),new $APP.f(null,3,[$APP.Q,Hfb,$APP.X,n9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bY],null))),lU,Fab],null)],null),new $APP.f(null,3,[$APP.Q,ctb,$APP.X,DH,$APP.h,new $APP.f(null,3,[$APP.P,"generic dot-product",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,Y8b],null)],null),new $APP.f(null,3,[$APP.Q,xZb,$APP.X,BR,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a column matrix populated by the supplied `xs`. Variadic equivalent\n  to [[column*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),lU,Ecb],null)],null),new $APP.f(null,3,[$APP.Q,dgb,$APP.X,F5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[ycc,Bdb],null))),lU,x1b],null)],
null),new $APP.f(null,3,[$APP.Q,Pqb,$APP.X,R2,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a matrix whose columns consist of the supplied sequence of `cols`.\n  These all must be the same length.\n\n  Variadic equivalent to [[by-cols*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,hX],null)),lU,Xlb],null)],null),new $APP.f(null,3,[$APP.Q,P3b,$APP.X,N9a,$APP.h,new $APP.f(null,3,[$APP.P,"p.324",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UR,$APP.DU],null))),lU,bnb],null)],null),new $APP.f(null,
3,[$APP.Q,n$b,$APP.X,zH,$APP.h,new $APP.f(null,3,[$APP.P,"generic real-part",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Kkb],null)],null),new $APP.f(null,3,[$APP.Q,yrb,$APP.X,wL,$APP.h,new $APP.f(null,1,[lU,kwb],null)],null),new $APP.f(null,3,[$APP.Q,qkb,$APP.X,W1a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a column matrix with the contents of the supplied `up` structure.\n  Errors if any other type is provided.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,
5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(dY,$APP.Wv)],null)],null)))),lU,f8b],null)],null),new $APP.f(null,3,[$APP.Q,tgb,$APP.X,N7a,$APP.h,new $APP.f(null,3,[$APP.P,"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\n\n  See [[brent-min]] for all supported `opts`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.Nv,
$APP.Lv,$APP.sU,$APP.Ox],null))),lU,q6b],null)],null),new $APP.f(null,3,[$APP.Q,K0b,$APP.X,l6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null))),lU,u9b],null)],null),new $APP.f(null,3,[$APP.Q,Oxb,$APP.X,rG,$APP.h,new $APP.f(null,3,[$APP.P,"generic log.\n\nReturns the natural logarithm of `x`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Vbc],null)],null),new $APP.f(null,3,[$APP.Q,DAb,$APP.X,xsc,$APP.h,$APP.F],null),
new $APP.f(null,3,[$APP.Q,$Gb,$APP.X,f3,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a concrete manifold generated by specializing the supplied manifold\n  `family` into a concrete manifold of dimension `n`. `n` must be a positive\n  integer.\n\n  Optionally takes an `embedding-dimension`; this must be \x3e\x3d the value of `n`.\n  Use this in cases like an n-sphere embedded in a euclidean space of dimension\n  n+1.\n\n  A [manifold](https://en.wikipedia.org/wiki/Manifold) is a topological space\n  that locally resembles Euclidean space near each point.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wV,$APP.wU],null),new $APP.H(null,3,5,$APP.I,[wV,$APP.wU,vX],null)),lU,bAb],null)],null),new $APP.f(null,3,[$APP.Q,F4b,$APP.X,YK,$APP.h,new $APP.f(null,3,[$APP.P,"Returns `true` if `s` is an `up` structure, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),lU,uAb],null)],null),new $APP.f(null,3,[$APP.Q,Ilb,$APP.X,mL,$APP.h,new $APP.f(null,3,[$APP.P,"Return a structure with the same shape as s but with f applied to each\n  primitive (that is, not structural) component.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null)),lU,dyb],null)],null),new $APP.f(null,3,[$APP.Q,Dtb,$APP.X,oR,$APP.h,new $APP.f(null,3,[$APP.P,"generic partial-derivative",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,ODb],null)],null),new $APP.f(null,3,[$APP.Q,E0b,$APP.X,Zqc,$APP.h,new $APP.f(null,1,[lU,HGb],null)],null),new $APP.f(null,3,[$APP.Q,nDb,$APP.X,HXa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the sum of all elements in the input series `s` up to order\n  `n` (inclusive). For example:\n\n  ```clojure\n  (sum (series 1 1 1 1 1 1 1) 3)\n  ;; \x3d\x3e 4\n  ```\n\n  NOTE that [[sum]] sums the first `n + 1` terms, since a series starts with an\n  order 0 term.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.wU],null))),lU,HRb],null)],null),new $APP.f(null,3,[$APP.Q,iOb,$APP.X,xab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Yw,sS,qT,lqb,a8b],null))),lU,Vfb],null)],null),new $APP.f(null,3,[$APP.Q,BUb,$APP.X,z4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a structure of `components` functions defined on manifold points and and\n  a matching `oneform-basis` (of identical structure),\n\n  Returns a new one-form field that\n\n  - passes its vector-field argument to `oneform-basis`, returning a new\n    equivalent structure with each slot populated by functions from a manifold\n    point to the directional derivative (using the vector field) in that\n    coordinate direction\n\n  - contracts the result of that operation with the result of applying each\n    component in `components` to the manifold point.\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[oneform-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,wHb],null))),lU,mIb],null)],null),new $APP.f(null,3,[$APP.Q,Ecc,$APP.X,D5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null))),lU,p4b],null)],null),new $APP.f(null,3,[$APP.Q,Kac,$APP.X,d6a,$APP.h,new $APP.f(null,3,[$APP.P,"Computes the trace of a (0,2) tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))),lU,Z4b],null)],null),new $APP.f(null,3,[$APP.Q,mec,$APP.X,yZa,$APP.h,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Sv],null))),lU,YIb],null)],null),new $APP.f(null,3,[$APP.Q,xgb,$APP.X,ssc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Pxb,$APP.X,pP,$APP.h,new $APP.f(null,3,[$APP.P,"Extract the vector basis from the given basis object `b`.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null)))),lU,zdb],null)],null),
new $APP.f(null,3,[$APP.Q,pbc,$APP.X,bO,$APP.h,new $APP.f(null,3,[$APP.P,"Accepts a coordinate representation `coords` of some `event` and returns a\n coordinate-free representation of the event.\n\n `coords` must be owned this this reference frame; [[coords-\x3eevent]] will throw\n if not.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null))),lU,RSb],null)],null),new $APP.f(null,3,[$APP.Q,Cfb,$APP.X,QQ,$APP.h,new $APP.f(null,3,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q`, velocity tuple (or scalar)\n  `qdot` and any number of additional higher-order derivative tuples (or\n  scalars), returns a 'Local tuple', i.e., the state expected by a Lagrangian.",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Uv,xU,TY,$APP.Lh,vT],null)),lU,Dvb],null)],null),new $APP.f(null,3,[$APP.Q,TEb,$APP.X,TK,$APP.h,new $APP.f(null,3,[$APP.P,"Return the structure `s` in unoriented vector form.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),lU,A4b],null)],null),new $APP.f(null,3,[$APP.Q,RGb,$APP.X,v6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KP,mvb],null))),lU,nXb],null)],null),new $APP.f(null,3,[$APP.Q,
DKb,$APP.X,l5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,q9b],null))),lU,rQb],null)],null),new $APP.f(null,3,[$APP.Q,bSb,$APP.X,iL,$APP.h,new $APP.f(null,3,[$APP.P,"Generates a `down` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-down 'x 3)\n     (down 'x_0 'x_1 'x_2))\n  ```",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],
null))),lU,Ghb],null)],null),new $APP.f(null,3,[$APP.Q,M5b,$APP.X,Bab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null))),lU,QBb],null)],null),new $APP.f(null,3,[$APP.Q,CRb,$APP.X,h1,$APP.h,new $APP.f(null,3,[$APP.P,"Return a [[Series]] starting with the supplied values. The remainder of the\n  series will be filled with the zero-value corresponding to the first of the\n  given values.\n\n  If you have a sequence already, prefer [[series*]].",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Lh,$APP.sx],null)),lU,Ftb],null)],null),new $APP.f(null,3,[$APP.Q,Ehb,$APP.X,r6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null))),lU,Whb],null)],null),new $APP.f(null,3,[$APP.Q,tJb,$APP.X,bR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,tU],null))),lU,PRb],null)],null),new $APP.f(null,3,[$APP.Q,jsb,$APP.X,GXa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a series (of the same type as the input) of partial sums of the terms\n  in the supplied series `s`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),lU,Fyb],null)],null),new $APP.f(null,3,[$APP.Q,lOb,$APP.X,T5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,Bsb],null)],null),new $APP.f(null,3,[$APP.Q,mub,$APP.X,W3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),lU,Mxb],null)],null),new $APP.f(null,3,[$APP.Q,JEb,$APP.X,hG,$APP.h,new $APP.f(null,1,[lU,w5b],null)],null),new $APP.f(null,3,[$APP.Q,qDb,$APP.X,xN,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a matrix with `r` rows and `c` columns, whose entries are generated by\n  the supplied function `f`.\n\n  If you only supply one dimension `n` the returned matrix will be square.\n\n  The entry in the `i`th row and `j`-th column is `(f i j)`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.oO,$APP.Mv,$APP.Nv],null)),lU,nsb],null)],null),new $APP.f(null,3,[$APP.Q,aeb,$APP.X,p3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `p` is a manifold point, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),lU,d8b],null)],null),new $APP.f(null,3,[$APP.Q,mfb,$APP.X,c5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],
null))),lU,pWb],null)],null),new $APP.f(null,3,[$APP.Q,L0b,$APP.X,BQ,$APP.h,new $APP.f(null,2,[$APP.P,"Converts an S-expression to JavaScript.",lU,E9b],null)],null),new $APP.f(null,3,[$APP.Q,bNb,$APP.X,vH,$APP.h,new $APP.f(null,3,[$APP.P,"generic cosh.\n\nComputes the [hyperbolic\n cosine](https://mathworld.wolfram.com/HyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x + e^{-x}) / 2`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,mXb],null)],
null),new $APP.f(null,3,[$APP.Q,ccb,$APP.X,a4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a vector field `vf` generated from [[basis-components-\x3evector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis-\x3edual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system-\x3evector-basis coordsys)\n        dual  (basis/vector-basis-\x3edual basis coordsys)]\n    (\x3d basis-components\n       (-\x3e basis-components\n           (basis-components-\x3evector-field basis)\n           (vector-field-\x3ebasis-components dual))))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hx,tW],null))),lU,Vub],null)],null),new $APP.f(null,3,[$APP.Q,VMb,$APP.X,FZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic coth.\n\nComputes the [hyperbolic\n cotangent](https://mathworld.wolfram.com/HyperbolicCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `cosh(x) / sinh(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,xXb],null)],null),new $APP.f(null,3,[$APP.Q,$6b,$APP.X,N5a,$APP.h,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tY,rX,uW],null))),lU,Dib],null)],null),new $APP.f(null,3,[$APP.Q,D4b,$APP.X,d5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[TX],null))),lU,Xyb],null)],null),new $APP.f(null,3,[$APP.Q,Fcb,$APP.X,PF,$APP.h,new $APP.f(null,3,[$APP.P,"generic one-like.\n\nIn general, this procedure returns the multiplicative identity of the type of\n  its argument, if it exists. For numbers this is 1.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,dib],null)],null),new $APP.f(null,3,[$APP.Q,z0b,$APP.X,e9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.PW,$APP.QW,$APP.wU],null))),lU,Efb],null)],null),new $APP.f(null,3,[$APP.Q,wWb,$APP.X,K3,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null),new $APP.H(null,2,5,$APP.I,[MT,TX],null)),lU,Lqb],null)],null),new $APP.f(null,3,[$APP.Q,lHb,$APP.X,Pqc,$APP.h,new $APP.f(null,1,[lU,
wnb],null)],null),new $APP.f(null,3,[$APP.Q,Lzb,$APP.X,z4,$APP.h,new $APP.f(null,1,[lU,qac],null)],null),new $APP.f(null,3,[$APP.Q,Hib,$APP.X,uD,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,SY],null)],null),new $APP.f(null,3,[$APP.Q,DBb,$APP.X,tI,$APP.h,new $APP.f(null,3,[$APP.P,"generic expt",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,p9b],null)],null),new $APP.f(null,3,[$APP.Q,U5b,$APP.X,crc,$APP.h,
new $APP.f(null,1,[lU,y_b],null)],null),new $APP.f(null,3,[$APP.Q,mkb,$APP.X,vO,$APP.h,new $APP.f(null,3,[$APP.P,"Returns an [[ICoordinateSystem]] instance specialized to the patch named\n  `patch-name` on `manifold`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aS,VX,iW],null))),lU,eyb],null)],null),new $APP.f(null,3,[$APP.Q,aEb,$APP.X,MP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null)),lU,HFb],null)],null),new $APP.f(null,
3,[$APP.Q,S7b,$APP.X,T9a,$APP.h,new $APP.f(null,3,[$APP.P,"p.327",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QX],null))),lU,thb],null)],null),new $APP.f(null,3,[$APP.Q,YVb,$APP.X,p6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),lU,uub],null)],null),new $APP.f(null,3,[$APP.Q,IKb,$APP.X,pL,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a structure compatible for multiplication with `s` down to 0.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Vv],null))),lU,z1b],null)],null),new $APP.f(null,3,[$APP.Q,fzb,$APP.X,rsc,$APP.h,new $APP.f(null,1,[lU,yMb],null)],null),new $APP.f(null,3,[$APP.Q,mFb,$APP.X,uZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic fractional-part.\n\nReturns the fractional part of the given value, defined as `x - ⌊x⌋`.\n\n  For positive numbers, this is identical to `(- a (integer-part a))`. For\n  negative `a`, because [[floor]] truncates toward negative infinity, you might\n  be surprised to find that [[fractional-part]] returns the distance between `a`\n  and the next-lowest integer:\n\n```clojure\n(\x3d 0.6 (fractional-part -0.4))\n```",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,SQb],null)],null),new $APP.f(null,3,[$APP.Q,LJb,$APP.X,C2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `e` is an event, false otherwise.\n\n  Make new events with [[make-event]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),lU,J$b],null)],null),new $APP.f(null,3,[$APP.Q,qgb,$APP.X,jP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation, returns a\n  one-form field.\n\n  The returned one-form field at each structural spot takes a vector field and\n  returns a function that takes the directional derivative in that coordinate's\n  direction using the vector field.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null)),lU,oIb],null)],null),new $APP.f(null,3,[$APP.Q,Udb,$APP.X,DN,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the single column from the supplied column matrix as an `up`. Errors if\n  some other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(qY,$APP.Qr)],null)],null)))),lU,ZHb],null)],null),new $APP.f(null,3,[$APP.Q,yqb,$APP.X,
function(a,b,c,d){$APP.rg.B(b,BX,!0);return $APP.T.j($APP.r($APP.N.C(new $APP.D(null,hUb,null,1,null),new $APP.D(null,c,null,1,null),$APP.y([new $APP.D(null,d,null,1,null)]))))},$APP.h,new $APP.f(null,4,[$APP.P,"Given some `coordinate-system` like `R2-rect` and a `coordinate-prototype` like\n  `[x y]` or `(up x y), `binds the following definitions into the namespace\n  where [[define-coordinates]] is invoked:\n\n  - `R2-rect` binds to a new version of the coordinate system with its\n    `coordinate-prototype` replaced by the supplied prototype\n\n  - `x` and `y` bind to coordinate functions, i.e., functions from manifold point\n  to that particular coordinate\n\n  - `d:dx` and `d:dy` bind to the corresponding vector field procedures\n\n  - `dx` and `dy` bind to 1-forms for each coordinate.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[pU,qW],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,XEb,$APP.X,SZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic trace",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Tlb],null)],null),new $APP.f(null,3,[$APP.Q,BEb,$APP.X,mG,$APP.h,new $APP.f(null,3,[$APP.P,"Generic implementation of `+`. Returns the sum of all supplied arguments. `(+)`\n  returns 0, the additive identity.\n\n  When applied between numbers, acts like `clojure.core/+`. Dispatch is open,\n  however, making it possible to 'add' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (+ [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up 3 5 7)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null)),lU,$pb],null)],null),new $APP.f(null,3,[$APP.Q,I4b,$APP.X,YQ,$APP.h,new $APP.f(null,3,[$APP.P,"Given a time `t`, coordinate tuple (or scalar) `q` and momentum tuple (or\n  scalar) `p`, returns a 'Hamiltonian state tuple', i.e., the state expected by a\n  Hamiltonian.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,
$APP.I,[$APP.Uv,xU,$APP.Sv],null))),lU,mtb],null)],null),new $APP.f(null,3,[$APP.Q,Hkb,$APP.X,sab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null))),lU,hVb],null)],null),new $APP.f(null,3,[$APP.Q,Phb,$APP.X,P5a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point \x3d\x3e\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,jS],null)],null),new $APP.f(null,3,[$APP.Q,Igb,$APP.X,o5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,TX],null))),lU,nkb],null)],null),new $APP.f(null,3,[$APP.Q,G2b,$APP.X,A6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,EV],null))),lU,vOb],null)],null),new $APP.f(null,3,[$APP.Q,k8b,$APP.X,i6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
2,5,$APP.I,[jW,VU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rS,VU)],null)],null)))),lU,Kbc],null)],null),new $APP.f(null,3,[$APP.Q,Bib,$APP.X,B2a,$APP.h,new $APP.f(null,3,[$APP.P,"Marks the input event `e` as an event via its metadata. The return value will\n  return `true` when passed to [[event?]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Pv],null))),lU,esb],null)],null),new $APP.f(null,3,[$APP.Q,ZOb,$APP.X,pL,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[compatible-zero]].",
lU,skb],null)],null),new $APP.f(null,3,[$APP.Q,tYb,$APP.X,O4,$APP.h,new $APP.f(null,3,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,d5b],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,eU,$APP.By],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,jnb,$APP.X,Jqc,$APP.h,new $APP.f(null,1,[lU,Chb],null)],null),new $APP.f(null,3,[$APP.Q,HTb,$APP.X,WP,$APP.h,new $APP.f(null,1,[lU,Dcb],null)],null),new $APP.f(null,3,[$APP.Q,Enb,$APP.X,Rqc,$APP.h,
new $APP.f(null,1,[lU,mJb],null)],null),new $APP.f(null,3,[$APP.Q,dac,$APP.X,YZ,$APP.h,new $APP.f(null,3,[$APP.P,"Construct a ratio.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.lP],null)),lU,MX],null)],null),new $APP.f(null,3,[$APP.Q,sZb,$APP.X,v4a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a one-form field `form` and a `coordinate-system`, returns a function\n  from the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the form field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-oneform-field 'f R2-rect)]\n      ((oneform-field-\x3ecomponents f R2-rect)\n       (up 'x0 'y0))))\n\n  ;;\x3d\x3e (down (f_0 (up x0 y0))\n  ;;         (f_1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Ev,qW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(QV,$APP.Ev)],null)],null)))),lU,djb],null)],null),new $APP.f(null,3,[$APP.Q,tTb,$APP.X,MZa,$APP.h,new $APP.f(null,3,[$APP.P,"Form an up-tuple from a vector.\n\n  NOTE that this is an alias of [[up*]] that is more restrictive, in that it\n  only accepts a vector. Use [[up*]] if you'd like to pass an arbitrary\n  sequence. (If you pass a vector to [[up*]]) it will be just as efficient.",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ax,$APP.Wv)],null)],null)))),lU,Xmb],null)],null),new $APP.f(null,3,[$APP.Q,$Kb,$APP.X,Tqc,$APP.h,new $APP.f(null,1,[lU,Wwb],null)],null),new $APP.f(null,3,[$APP.Q,IFb,$APP.X,V3a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field-\x3ecomponents f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;\x3d\x3e (up (f↑0 (up x0 y0))\n  ;;       (f↑1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.hx,qW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(eV,$APP.hx)],null)],null)))),lU,CVb],null)],null),new $APP.f(null,3,[$APP.Q,FXb,$APP.X,yZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic sec.\n\nComputes the secant of the supplied argument `a`.\n\nEquivalent to `(invert (cos a))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Ogb],null)],null),new $APP.f(null,3,[$APP.Q,Ndc,$APP.X,
QQ,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[-\x3eL-state]].",lU,Iwb],null)],null),new $APP.f(null,3,[$APP.Q,hib,$APP.X,c4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hx,qW],null))),lU,BTb],null)],null),new $APP.f(null,3,[$APP.Q,d0b,$APP.X,W5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,VU],null))),lU,fCb],null)],null),new $APP.f(null,3,[$APP.Q,l4b,$APP.X,e6a,$APP.h,new $APP.f(null,3,[$APP.P,"Computes the trace of a (2,0) tensor",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))),lU,Bhb],null)],null),new $APP.f(null,3,[$APP.Q,qSb,$APP.X,RF,$APP.h,new $APP.f(null,
3,[$APP.P,"generic negate.\n\nReturns the negation of `a`.\n\n  Equivalent to `(- (g/zero-like a) a)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Ykb],null)],null),new $APP.f(null,3,[$APP.Q,lcc,$APP.X,KZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acoth.\n\nComputes the [inverse hyperbolic\n cotangent](https://mathworld.wolfram.com/InverseHyperbolicCotangent.html) of\n the supplied argument `a`.\n\ndefaults to `1/2 ln((x+1)/(x-1))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),lU,p1b],null)],null),new $APP.f(null,3,[$APP.Q,FPb,$APP.X,W4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,VU],null))),lU,sSb],null)],null),new $APP.f(null,3,[$APP.Q,Xfb,$APP.X,EZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic sech.\n\nComputes the [hyperbolic\n secant](https://mathworld.wolfram.com/HyperbolicSecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / cosh(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[$APP.Lv],null))),lU,Bpb],null)],null),new $APP.f(null,3,[$APP.Q,xOb,$APP.X,XK,$APP.h,new $APP.f(null,3,[$APP.P,"Returns `true` if `s` is a structure, false otherwise. (Vectors are treated as\n  up structures.)",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),lU,Q6b],null)],null),new $APP.f(null,3,[$APP.Q,pZb,$APP.X,QP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),lU,D_b],null)],null),new $APP.f(null,3,[$APP.Q,bcb,
$APP.X,s5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[QN],null))),lU,zac],null)],null),new $APP.f(null,3,[$APP.Q,XWb,$APP.X,pZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic log10.\n\nReturns the base-10 logarithm of `x`, i.e., $log_10(x)$.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,fdb],null)],null),new $APP.f(null,3,[$APP.Q,Hxb,$APP.X,IN,$APP.h,new $APP.f(null,3,[$APP.P,"Convert the matrix `m` into a structure `S`, guided by the requirement that `(*\n  ls S rs)` should be a scalar.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[AW,$APP.Qr,MW],null))),lU,j$b],null)],null),new $APP.f(null,3,[$APP.Q,mmb,$APP.X,PQ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the acceleration element of a local tuple (by convention, the fourth\n  element).\n\n  See [[coordinate]] for more detail.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),3)],null)],null)))),
lU,J6b],null)],null),new $APP.f(null,3,[$APP.Q,pNb,$APP.X,S9a,$APP.h,new $APP.f(null,3,[$APP.P,"p.326",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),lU,Rxb],null)],null),new $APP.f(null,3,[$APP.Q,CXb,$APP.X,RR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[$APP.Kv,$APP.Yv,$APP.UP,$APP.VP],null)],null))),lU,Nib],null)],null),new $APP.f(null,3,[$APP.Q,qMb,$APP.X,r4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is an [form field of rank\n  n](https://en.wikipedia.org/wiki/Differential_form), false otherwise.\n\n  A form-field of rank n is an operator that takes n vector fields to a\n  real-valued function on the manifold.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null))),lU,obc],null)],null),new $APP.f(null,3,[$APP.Q,qKb,$APP.X,j1,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a [[PowerSeries]] representing the supplied constant term.\n\n  Optionally, pass `kind` of either `::series` or `::power-series` to specify\n  the type of series returned.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[$APP.Mv,$V],null)),lU,bwb],null)],null),new $APP.f(null,3,[$APP.Q,
kvb,$APP.X,V3,$APP.h,new $APP.f(null,3,[$APP.P,"For convenience, we also provide the sister-procedure for finding\n  the maximum of a unimodal function using the golden section method.\n\n  Negate the function, minimize, negate the result.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,$APP.Ox],null)),lU,mdc],null)],null),new $APP.f(null,3,[$APP.Q,Neb,$APP.X,nG,$APP.h,new $APP.f(null,3,[$APP.P,"generic square",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),lU,Vzb],null)],null),new $APP.f(null,3,[$APP.Q,VBb,$APP.X,mZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic exp2.\n\nReturns the base-2 exponential of `x`. Equivalent to `(expt 2 x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,$9b],null)],null),new $APP.f(null,3,[$APP.Q,UNb,$APP.X,z3a,$APP.h,new $APP.f(null,3,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 0.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.hU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(FY,$APP.hU)],null)],null)))),lU,m1b],null)],null),new $APP.f(null,3,[$APP.Q,evb,$APP.X,TQ,$APP.h,new $APP.f(null,3,[$APP.P,"Gamma takes a path function (from time to coordinates) to a state\n  function (from time to local tuple).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[xU],null),new $APP.H(null,2,5,$APP.I,[xU,$APP.wU],null)),lU,Wrb],null)],null),new $APP.f(null,3,[$APP.Q,Pbc,$APP.X,T4,$APP.h,new $APP.f(null,
2,[$APP.P,"Given a sequence of `selectors`, return a function that accepts some object `x`\n  and returns:\n\n  ```clojure\n  (apply ref x selectors)\n  ```\n  ",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))],null)],null),new $APP.f(null,3,[$APP.Q,pqb,$APP.X,zG,$APP.h,new $APP.f(null,3,[$APP.P,"generic magnitude",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,mQb],null)],null),new $APP.f(null,3,[$APP.Q,Ubb,$APP.X,jrc,$APP.h,new $APP.f(null,1,[lU,p5b],null)],
null),new $APP.f(null,3,[$APP.Q,g_b,$APP.X,$APP.NQ,$APP.h,new $APP.f(null,3,[$APP.P,"A convenience function on local tuples. A local tuple describes\n  the state of a system at a particular time:\n\n  ```\n  [t, q, D q, D^2 q]\n  ```\n\n  representing time, position, velocity (and optionally acceleration etc.)\n\n  [[coordinate]] returns the `q` element, which is expected to be a mapping from\n  time to a structure of coordinates.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[rV],
null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(OY,rV),$APP.M($APP.aw,$APP.M($APP.tv,rV),1)],null)],null)))),lU,ZAb],null)],null),new $APP.f(null,3,[$APP.Q,kFb,$APP.X,w9a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns function signature for a Hamiltonian with n degrees of freedom (or an\n  unrestricted number if n is not given).\n\n  Useful for constructing Hamiltonian literal functions.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),lU,W8b],null)],null),
new $APP.f(null,3,[$APP.Q,qVb,$APP.X,JF,$APP.h,new $APP.f(null,3,[$APP.P,"Comparator. Clone of [[cljs.core/compare]] that works with the expanded\n      Emmy numeric tower.\n\n  Returns a negative number, zero, or a positive number when x is logically\n  'less than', 'equal to', or 'greater than' y. Uses IComparable if available\n  and google.array.defaultCompare for objects of the same type and special-cases\n  nil to be less than any other object.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,
5,$APP.I,[$APP.Yv,$APP.UP],null))),lU,$mb],null)],null),new $APP.f(null,3,[$APP.Q,Kob,$APP.X,oG,$APP.h,new $APP.f(null,3,[$APP.P,"generic infinite?.\n\nReturns true if `a` is either numerically infinite (i.e., equal to `##Inf`) or\n  a compound number (complex or quaterion, for example) with some infinite\n  component.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,X2b],null)],null),new $APP.f(null,3,[$APP.Q,gRb,$APP.X,Lqc,$APP.h,new $APP.f(null,1,[lU,rMb],null)],null),
new $APP.f(null,3,[$APP.Q,Vjb,$APP.X,kP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-oneform-field` instances.\n\n  The one-form field at each structural spot takes a vector field and returns a\n  function that takes the directional derivative in that coordinate's direction\n  using the vector field.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-oneform-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,xT],null)],null),new $APP.f(null,3,[$APP.Q,bKb,$APP.X,J9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[GU],null))),lU,jVb],null)],null),new $APP.f(null,3,[$APP.Q,jOb,$APP.X,A3a,$APP.h,new $APP.f(null,3,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 1.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.hU],null),new $APP.f(null,1,[$APP.Bw,
new $APP.H(null,1,5,$APP.I,[$APP.M(FY,$APP.hU)],null)],null)))),lU,peb],null)],null),new $APP.f(null,3,[$APP.Q,E2b,$APP.X,ISa,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RFb],null))),lU,Zkb],null)],null),new $APP.f(null,3,[$APP.Q,sVb,$APP.X,xG,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Sdb],null)],null),new $APP.f(null,3,[$APP.Q,
Ybb,$APP.X,X4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Qgb,VU],null))),lU,h9b],null)],null),new $APP.f(null,3,[$APP.Q,lSb,$APP.X,wZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic cot.\n\nComputes the trigonometric cotangent function of the supplied argument `a`.\n\nEquivalent to `(invert (tan a))`, or `(/ (cos a) (sin a))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,SDb],null)],null),new $APP.f(null,3,[$APP.Q,Nyb,$APP.X,S2a,$APP.h,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,egb],null)],null),new $APP.f(null,3,[$APP.Q,WTb,$APP.X,x5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,Adc],null)],null),new $APP.f(null,3,[$APP.Q,Ktb,$APP.X,SR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[rT,iS],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dY,iS),$APP.M($APP.bw,$APP.M($APP.tv,
iS),4)],null)],null)))),lU,wbc],null)],null),new $APP.f(null,3,[$APP.Q,wEb,$APP.X,kG,$APP.h,new $APP.f(null,3,[$APP.P,'Generic implementation of `*`. Returns the product of all supplied\n  arguments. `(*)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core/*`. Dispatch is open,\n  however, making it possible to \'multiply\' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (* 2 #emmy/complex "3 + 1i")\n  ;;\x3d\x3e #emmy/complex "6 + 2i"\n  ```',
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null)),lU,Zpb],null)],null),new $APP.f(null,3,[$APP.Q,Jab,$APP.X,WO,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.hx],null))),lU,sec],null)],null),new $APP.f(null,3,[$APP.Q,wgb,$APP.X,
USa,$APP.h,new $APP.f(null,1,[lU,Bkb],null)],null),new $APP.f(null,3,[$APP.Q,Ibc,$APP.X,BZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic asec.\n\nComputes the [inverse\n secant](https://mathworld.wolfram.com/InverseSecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(sqrt(x^2 - 1))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,abb],null)],null),new $APP.f(null,3,[$APP.Q,ytb,$APP.X,QR,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,
5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$W],null)],null))),lU,Gpb],null)],null),new $APP.f(null,3,[$APP.Q,tGb,$APP.X,eR,$APP.h,new $APP.f(null,3,[$APP.P,"generic solve-linear-right.\n\nFor a given `a` and `b`, returns `x` such that `a \x3d x*b`.\n\n  See[[solve-linear]] for a similar function that solves for `a*x \x3d b`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,xdb],null)],null),new $APP.f(null,3,[$APP.Q,uzb,$APP.X,wP,$APP.h,new $APP.f(null,3,[$APP.P,"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,BCb],null)],null),new $APP.f(null,3,[$APP.Q,aUb,$APP.X,L4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(QS,$APP.sU)],null)],null)))),lU,dOb],null)],null),new $APP.f(null,3,[$APP.Q,h0b,$APP.X,v3a,$APP.h,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a unique, symbolically-represented\n  point on the manifold associated with `coordinate-system`.\n\n  See [[typical-coords]] for a coordinate-based version of this function.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,qjb],null)],null),new $APP.f(null,3,[$APP.Q,usb,$APP.X,Xqc,$APP.h,new $APP.f(null,1,[lU,P_b],null)],null),new $APP.f(null,3,[$APP.Q,iBb,$APP.X,W2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a function which rotates a vector α radians about the z axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,ebc],null)],null),new $APP.f(null,3,[$APP.Q,s_b,$APP.X,MZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acsch.\n\nComputes the [inverse hyperbolic\n cosecant](https://mathworld.wolfram.com/InverseHyperbolicCosecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1+x^2)) / x)`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Yhb],null)],null),new $APP.f(null,3,[$APP.Q,cpb,$APP.X,oZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic log2.\n\nReturns the base-2 logarithm of `x`, i.e., $log_2(x)$.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,m5b],null)],null),new $APP.f(null,3,[$APP.Q,xbc,$APP.X,wrc,$APP.h,new $APP.f(null,1,[lU,qZb],null)],null),new $APP.f(null,3,[$APP.Q,U_b,$APP.X,BF,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,Fqb],null)],null),new $APP.f(null,3,[$APP.Q,Dqb,$APP.X,x3a,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a coordinate representation `coords` of a manifold point with all\n  symbolic entries, and returns a structure of the same shape with `v:`\n  prepended to all symbols.\n\n  This structure is appropriate for representing the velocities associated with\n  each coordinate.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.pW],null))),lU,Web],null)],null),new $APP.f(null,3,[$APP.Q,kmb,$APP.X,.5772156649015329,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,rgb,$APP.X,SNa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `x` is a `BigInt`, false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,WWb],null)],null),new $APP.f(null,3,[$APP.Q,gcb,$APP.X,MF,$APP.h,new $APP.f(null,3,[$APP.P,"generic zero?.\n\nIs true if `x` is an additive identity.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,n3b],null)],null),new $APP.f(null,3,[$APP.Q,Yeb,$APP.X,DG,$APP.h,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),lU,L1b],null)],null),new $APP.f(null,3,[$APP.Q,HWb,$APP.X,uP,$APP.h,new $APP.f(null,3,[$APP.P,"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,KMb],null)],null),new $APP.f(null,3,[$APP.Q,lCb,$APP.X,ZQ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the momentum element of a local Hamiltonian state tuple (by convention,\n  the third element).",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[YU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(dY,YU),$APP.M($APP.aw,$APP.M($APP.tv,YU),2)],null)],null)))),lU,AOb],null)],null),new $APP.f(null,
3,[$APP.Q,T$b,$APP.X,tG,$APP.h,new $APP.f(null,3,[$APP.P,"generic atan.\n\nComputes the inverse tangent of the supplied argument `a`. Given two\n  arguments `a` and `b`, returns the inverse tangent of the angle formed by the\n  point `(b, a)` in a 2-dimensional euclidean plane.\n\n  The two-argument version is sometimes\n  called [Atan2](https://en.wikipedia.org/wiki/Atan2).",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),
lU,Mfb],null)],null),new $APP.f(null,3,[$APP.Q,JDb,$APP.X,Q2,$APP.h,new $APP.f(null,3,[$APP.P,"Generates a `nrows` x `ncols` matrix of symbolic entries, each prefixed by the\n  supplied symbol `sym`.\n\n  If `ncols` (the third argument) is not supplied, returns a square matrix of\n  size `nrows` x `nrows`.\n\n  NOTE: The symbols in the returned matrix record their Einstein-notation path\n  into the structure that this matrix represents; a `down` of `up` columns. This\n  means that the returned indices embedded in the symbols look flipped, `ji` vs\n  `ij`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-matrix 'x 2 2)\n     (by-rows ['x_0↑0 'x_1↑0]\n              ['x_0↑1 'x_1↑1]))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,LV],null),new $APP.H(null,3,5,$APP.I,[$APP.Yx,LV,iX],null)),lU,Xxb],null)],null),new $APP.f(null,3,[$APP.Q,J_b,$APP.X,A5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(XW,PV)],null)],null)))),lU,Qdc],null)],null),new $APP.f(null,3,[$APP.Q,Hhb,$APP.X,W9a,$APP.h,new $APP.f(null,3,[$APP.P,"p. 334 (used, but not defined there)",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),lU,gob],null)],null),new $APP.f(null,3,[$APP.Q,M0b,$APP.X,m6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null))),lU,v9b],null)],null),new $APP.f(null,3,[$APP.Q,ixb,$APP.X,rP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,VU],null))),lU,Tdc],null)],null),new $APP.f(null,3,[$APP.Q,I6b,$APP.X,PZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic make-rectangular",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,MMb],null)],null),new $APP.f(null,3,[$APP.Q,Eqb,$APP.X,n6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null))),lU,Icb],null)],null),new $APP.f(null,3,[$APP.Q,ucc,$APP.X,Y4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Rwb,Swb],null))),lU,Ijb],null)],null),new $APP.f(null,3,[$APP.Q,$Qb,$APP.X,R2a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,$bb],null)],null),new $APP.f(null,3,[$APP.Q,Ymb,$APP.X,J4,$APP.h,new $APP.f(null,3,[$APP.P,"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null)),lU,jcb],null)],null),new $APP.f(null,3,[$APP.Q,zrb,$APP.X,qsc,$APP.h,new $APP.f(null,1,[lU,d7b],null)],null),new $APP.f(null,3,[$APP.Q,nob,$APP.X,z6a,$APP.h,new $APP.f(null,3,[$APP.P,"[[curl]] implements equation (10.7) of Functional Differential Geometry,\n  defined on page 155.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,EV],null))),lU,F5b],null)],null),new $APP.f(null,3,[$APP.Q,BXb,$APP.X,Z2a,$APP.h,new $APP.f(null,
3,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold family, false\n  otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),lU,hxb],null)],null),new $APP.f(null,3,[$APP.Q,QSb,$APP.X,xZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic csc.\n\nComputes the cosecant of the supplied argument `a`.\n\nEquivalent to `(invert (sin a))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,MFb],null)],null),new $APP.f(null,3,[$APP.Q,R_b,$APP.X,
irc,$APP.h,new $APP.f(null,1,[lU,lhb],null)],null),new $APP.f(null,3,[$APP.Q,u_b,$APP.X,u3a,$APP.h,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a structure that matches\n  the [[coordinate-prototype]] of `coordinate-system`, with all unique,\n  gensym-ed entries.\n\n  Use [[typical-coords]] if you require a unique symbolic coordinate\n  representation compatible with `coordinate-system`.\n\n  See [[typical-point]] for a coordinate-free version of this function.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,TMb],null)],null),new $APP.f(null,3,[$APP.Q,yjb,$APP.X,qM,$APP.h,new $APP.f(null,3,[$APP.P,"generic lcm.\n\nReturns the [least common\n  multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of the two\n  inputs `a` and `b`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,nbc],null)],null),new $APP.f(null,3,[$APP.Q,yeb,$APP.X,yG,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null)),lU,wG],null)],null),new $APP.f(null,3,[$APP.Q,tdc,$APP.X,m9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))),lU,bib],null)],null),new $APP.f(null,3,[$APP.Q,Kdc,$APP.X,S3,$APP.h,new $APP.f(null,3,[$APP.P,"Convert the given expression to TeX format, as a string.\n\n  If you set the `:equation` keyword argument to a truthy value, the result will\n  be wrapped in an equation environment. `:equation \x3cstring\x3e` will insert a\n  `\\label{\x3cstring\x3e}` entry inside the equation environment.\n\n  For example:\n\n  ```clojure\n  (let [expr (+ 'x 'xy)]\n    (println\n      (-\x3eTeX expr :equation \"label!\")))\n\n  \\begin{equation}\n  \\label{label!}\n  x + y\n  \\end{equation}\n  ```\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[fV],null)],null)],null)),lU,Edb],null)],null),new $APP.f(null,3,[$APP.Q,l6b,$APP.X,mrc,$APP.h,new $APP.f(null,1,[lU,vob],null)],null),new $APP.f(null,3,[$APP.Q,Dfb,$APP.X,c3a,$APP.h,new $APP.f(null,3,[$APP.P,"The supplied manifold `m` locally resembles some vector space; this function\n  returns the field over which that vector space was specified.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[aS],null))),lU,ddc],null)],null),new $APP.f(null,3,[$APP.Q,Xtb,$APP.X,qab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null))),lU,jub],null)],null),new $APP.f(null,3,[$APP.Q,S3b,$APP.X,j9a,$APP.h,new $APP.f(null,3,[$APP.P,"Given a state tuple (of finite length), reconstitutes the initial segment of\n  the Taylor series corresponding to the state tuple data as a function of t.\n\n  Time is measured beginning at the point of time specified in the input state\n  tuple.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[nrb],null))),lU,BDb],null)],null),new $APP.f(null,3,[$APP.Q,B8b,$APP.X,CZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acsc.\n\nComputes the [inverse\n cosecant](https://mathworld.wolfram.com/InverseCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(1 / sqrt(x^2 - 1))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,wCb],null)],null),new $APP.f(null,3,[$APP.Q,ptb,$APP.X,A3,$APP.h,new $APP.f(null,3,
[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses forward-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null)),lU,IRb],null)],null),new $APP.f(null,3,[$APP.Q,UEb,$APP.X,f5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[MT,TX],null))),lU,Lub],null)],null),new $APP.f(null,3,[$APP.Q,
P8b,$APP.X,mO,$APP.h,new $APP.f(null,3,[$APP.P,"generic acos.\n\nComputes the inverse cosine of the supplied argument `a`.\n\nDefaults to `atan(sqrt(1-x^2)/x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,XCb],null)],null),new $APP.f(null,3,[$APP.Q,VRb,$APP.X,lrc,$APP.h,new $APP.f(null,1,[lU,iZb],null)],null),new $APP.f(null,3,[$APP.Q,Ojb,$APP.X,sM,$APP.h,new $APP.f(null,3,[$APP.P,"Accepts a single symbolic expression and returns a factored version of that\n  expression.\n\n  Differs from [[factor-expression]] in that it can handle any expression, not\n  just expressions limited to polynomial operations.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),lU,mUb],null)],null),new $APP.f(null,3,[$APP.Q,O8b,$APP.X,AZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acot.\n\nComputes the [inverse\n cotangent](https://mathworld.wolfram.com/InverseCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `pi/2 - atan(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,bDb],null)],null),new $APP.f(null,3,[$APP.Q,c1b,$APP.X,rZ,$APP.h,new $APP.f(null,3,[$APP.P,
"generic floor.\n\nReturns the largest integer less than or equal to `a`.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Ahb],null)],null),new $APP.f(null,3,[$APP.Q,XLb,$APP.X,Q3a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null))),lU,GKb],null)],null),
new $APP.f(null,3,[$APP.Q,B1b,$APP.X,a9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))),lU,lwb],null)],null),new $APP.f(null,3,[$APP.Q,Ylb,$APP.X,x6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[VU,jW,qW],null))),lU,KAb],null)],null),new $APP.f(null,3,[$APP.Q,dYb,$APP.X,hrc,$APP.h,new $APP.f(null,1,[lU,jIb],null)],null),new $APP.f(null,3,[$APP.Q,zZb,$APP.X,krc,$APP.h,new $APP.f(null,1,[lU,$Nb],null)],null),new $APP.f(null,
3,[$APP.Q,Xcc,$APP.X,CH,$APP.h,new $APP.f(null,3,[$APP.P,"generic imag-part",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,G1b],null)],null),new $APP.f(null,3,[$APP.Q,FBb,$APP.X,Oqc,$APP.h,new $APP.f(null,1,[lU,uob],null)],null),new $APP.f(null,3,[$APP.Q,SHb,$APP.X,Y1a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a row matrix with the contents of the supplied `down` structure.\n  Errors if any other type is provided.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,
5,$APP.I,[$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(SOb,$APP.Wv)],null)],null)))),lU,Vcb],null)],null),new $APP.f(null,3,[$APP.Q,gub,$APP.X,s6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[KP,VU],null))),lU,v1b],null)],null),new $APP.f(null,3,[$APP.Q,Qjb,$APP.X,M5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null))),lU,Jdc],null)],null),new $APP.f(null,3,[$APP.Q,vrb,$APP.X,csc,$APP.h,
new $APP.f(null,1,[lU,Q9b],null)],null),new $APP.f(null,3,[$APP.Q,lcb,$APP.X,EG,$APP.h,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),lU,e$b],null)],null),new $APP.f(null,3,[$APP.Q,k3b,$APP.X,TP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[iac,hac,nac,VU,jW],null))),lU,tZb],null)],null),new $APP.f(null,3,[$APP.Q,$Fb,$APP.X,GN,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the single row from the supplied row matrix as a vector. Errors if some\n  other type is supplied.",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(DV,$APP.Qr)],null)],null)))),lU,tbb],null)],null),new $APP.f(null,3,[$APP.Q,kqb,$APP.X,VQ,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,OGb],null)],null),new $APP.f(null,3,[$APP.Q,Zcc,$APP.X,eI,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a function `f` and a sequence of `factors`, and returns a new function\n  that multiplies each factor by the corresponding argument of `f`. Too many or\n  two few factors are ignored.\n\n  ```clojure\n  ((arg-scale square 3) 4) \x3d\x3d\x3e 144\n  ((arg-scale square 3 2 1) 4) \x3d\x3d\x3e 144\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,oV],null)),lU,UIb],null)],null),new $APP.f(null,3,[$APP.Q,eub,$APP.X,P3,$APP.h,new $APP.f(null,2,[$APP.P,"Operator that takes a function `f` and returns a new function that\n  calculates the [Gradient](https://en.wikipedia.org/wiki/Gradient) of `f`.\n\n  The related [[emmy.env/D]] operator returns a function that produces a\n  structure of the opposite orientation as [[Grad]]. Both of these functions use\n  reverse-mode automatic differentiation.",
lU,sdc],null)],null),new $APP.f(null,3,[$APP.Q,qNb,$APP.X,Q2a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[UX,new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.VP],null)],null))),lU,beb],null)],null),new $APP.f(null,3,[$APP.Q,QOb,$APP.X,w4,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null)),lU,TGb],null)],null),new $APP.f(null,3,[$APP.Q,mxb,$APP.X,X2a,$APP.h,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[BU],null))),lU,Tcc],null)],null),new $APP.f(null,3,[$APP.Q,fLb,$APP.X,R4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VU,wW],null))),lU,c8b],null)],null),new $APP.f(null,3,[$APP.Q,rWb,$APP.X,SQ,$APP.h,new $APP.f(null,3,[$APP.P,"Returns an operator that, when applied to a function `f`, produces a function\n  that uses reverse-mode automatic differentiation to compute the partial\n  derivative of `f` at the (zero-based) slot index provided via `selectors`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null)),lU,Isb],null)],null),new $APP.f(null,3,[$APP.Q,hjb,$APP.X,dO,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the symbolic name of the suppplied frame.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),lU,NOb],null)],null),new $APP.f(null,3,[$APP.Q,WVb,$APP.X,o6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),lU,vub],null)],null),new $APP.f(null,3,[$APP.Q,POb,$APP.X,q6a,
$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[KP],null))),lU,c3b],null)],null),new $APP.f(null,3,[$APP.Q,$jb,$APP.X,V4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in an\n  `equation` environment.\n\n  Optionally supply a `:label` keyword argument to set a custom label.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[$APP.JY],null)],null)],
null))],null)],null),new $APP.f(null,3,[$APP.Q,W6b,$APP.X,dR,$APP.h,new $APP.f(null,3,[$APP.P,"generic Lie-derivative",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Htb],null)],null),new $APP.f(null,3,[$APP.Q,mpb,$APP.X,v9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rV],null))),lU,lKb],null)],null),new $APP.f(null,3,[$APP.Q,Hgb,$APP.X,Dab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hec,Z1b],
null))),lU,Lcc],null)],null),new $APP.f(null,3,[$APP.Q,zWb,$APP.X,Cab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rT],null))),lU,asb],null)],null),new $APP.f(null,3,[$APP.Q,fmb,$APP.X,PP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mT],null))),lU,nGb],null)],null),new $APP.f(null,3,[$APP.Q,t3b,$APP.X,G5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[PV,$APP.tw],null))),lU,Ccb],null)],null),
new $APP.f(null,3,[$APP.Q,nSb,$APP.X,E4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the alternation of the supplied differential `form`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ev],null))),lU,b8b],null)],null),new $APP.f(null,3,[$APP.Q,y0b,$APP.X,Xqc,$APP.h,new $APP.f(null,1,[lU,NKb],null)],null),new $APP.f(null,3,[$APP.Q,Ekb,$APP.X,oab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Wdb],null))),lU,$Sb],null)],null),new $APP.f(null,3,[$APP.Q,
pBb,$APP.X,q3,$APP.h,new $APP.f(null,1,[lU,Vob],null)],null),new $APP.f(null,3,[$APP.Q,WFb,$APP.X,vsc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,unb,$APP.X,Sqc,$APP.h,new $APP.f(null,1,[lU,zfb],null)],null),new $APP.f(null,3,[$APP.Q,zEb,$APP.X,TF,$APP.h,new $APP.f(null,3,[$APP.P,"Generic implementation of `-`.\n\n  If one argument is supplied, returns the negation of `a`. Else returns the\n  difference of the first argument `a` and the sum of all remaining\n  arguments. `(-)` returns 0.\n\n  When applied between numbers, acts like `clojure.core/-`. Dispatch is open,\n  however, making it possible to 'subtract' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (- [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up -1 -1 -1)\n\n  (- [1 10])\n  ;;\x3d\x3e (up -1 -10)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null)),lU,Xpb],null)],null),new $APP.f(null,3,[$APP.Q,Khb,$APP.X,f9a,$APP.h,new $APP.f(null,3,[$APP.P,"Given `ys` (a sequence of function values) and `xs` (an equal-length sequence\n  of function inputs), returns a [[emmy.polynomial/Polynomial]] instance\n  guaranteed to pass through all supplied `xs` and `ys`.\n\n  The contract for inputs is that `(map vector xs ys)` should return a sequence\n  of pairs of points.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[fUb,$APP.ix],null))),lU,bfb],null)],null),new $APP.f(null,3,[$APP.Q,UXb,$APP.X,SP,$APP.h,new $APP.f(null,3,[$APP.P,"To make a one-form field into a vector field, i.e., a (0,1) tensor into a (1,0)\n  tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),lU,i8b],null)],null),new $APP.f(null,3,[$APP.Q,rbb,$APP.X,L9a,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[F-\x3eCH]].",lU,B$b],null)],null),new $APP.f(null,3,[$APP.Q,
JZb,$APP.X,pab,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a unit 3-vector `direction` (representing a direction) and a velocity\n  `v:c` normalized by `C`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hFb,PY],null))),lU,Y$b],null)],null),new $APP.f(null,3,[$APP.Q,jeb,$APP.X,nP,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the standard basis object for `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,ogb],null)],null),new $APP.f(null,3,[$APP.Q,Frb,$APP.X,
pO,$APP.h,new $APP.f(null,3,[$APP.P,"Compute the rotation matrix from a 3-vector of Euler angles.\n\n  Our Euler Angle convention:\n\n  M(theta, phi, psi) \x3d R_z(phi)*R_x(theta)*R_z(psi)",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[UX,ZR,YT],null)],null))),lU,MRb],null)],null),new $APP.f(null,3,[$APP.Q,N6b,$APP.X,O5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[tY,rX,uW],null))),lU,AEb],null)],null),new $APP.f(null,3,[$APP.Q,
EBb,$APP.X,n3,$APP.h,new $APP.f(null,1,[lU,tob],null)],null),new $APP.f(null,3,[$APP.Q,oqb,$APP.X,Nqc,$APP.h,new $APP.f(null,1,[lU,ikb],null)],null),new $APP.f(null,3,[$APP.Q,$7b,$APP.X,t3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if `x` implements [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,TTb],null)],null),new $APP.f(null,3,[$APP.Q,d1b,$APP.X,ZO,$APP.h,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null)),lU,lQb],null)],null),new $APP.f(null,3,[$APP.Q,JUb,$APP.X,SM,$APP.h,new $APP.f(null,3,[$APP.P,"Returns its argument, wrapped in a marker type that responds to the generic\n  operations registered in [[emmy.numsymb]].\n\n  Symbols are automatically treated as [[literal-number]] instances, so\n\n  ```clojure\n  (* 10 (literal-number 'x))\n  ```\n\n  is equivalent to\n\n  ```clojure\n  (* 10 'x)\n  ```\n\n  If you pass an actual number, emmy will attempt to preserve exact values\n  through various operations:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 4))))\n  ;;\x3d\x3e (+ 1 (cos 8))\n  ```\n\n  Notice that the `(g/* 2 ...)` is evaluated, but `cos` evaluation is deferred,\n  since the result is inexact. On the other hand, if the number is inexact to\n  begin with:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 2.2))))\n  ;;\x3d\x3e 0.6926671300215806\n  ```\n\n  the system will go ahead and evaluate it.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,Jbc],null)],null),new $APP.f(null,3,[$APP.Q,Zib,$APP.X,Uqc,$APP.h,new $APP.f(null,1,[lU,Mcc],null)],null),new $APP.f(null,3,[$APP.Q,Sib,$APP.X,drc,$APP.h,new $APP.f(null,1,[lU,Vcc],null)],null),new $APP.f(null,3,[$APP.Q,oDb,$APP.X,$F,$APP.h,new $APP.f(null,3,[$APP.P,"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),lU,jib],null)],null),new $APP.f(null,3,[$APP.Q,rRb,$APP.X,K4,$APP.h,new $APP.f(null,3,[$APP.P,"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[cW,$APP.Lh,OV],null)),lU,
Yob],null)],null),new $APP.f(null,3,[$APP.Q,mhb,$APP.X,b9a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))),lU,Drb],null)],null),new $APP.f(null,3,[$APP.Q,DDb,$APP.X,dI,$APP.h,new $APP.f(null,3,[$APP.P,"Takes a function `f` and a sequence of `shifts`, and returns a new function\n  that adds each shift to the corresponding argument of `f`. Too many or two few\n  shifts are ignored.\n\n  ```clojure\n  ((arg-shift square 3) 4) \x3d\x3d\x3e 49\n  ((arg-shift square 3 2 1) 4) \x3d\x3d\x3e 49\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,AY],null)),lU,Mab],null)],null),new $APP.f(null,3,[$APP.Q,f6b,$APP.X,U4,$APP.h,new $APP.f(null,2,[$APP.P,"A shim. Dispatches to [[d/partial]] when all the arguments are integers; falls\n  back to [[clojure.core/partial]] (partial function application) otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,ST],null))],null)],null),new $APP.f(null,3,[$APP.Q,$kb,$APP.X,TZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic inner-product",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),lU,QMb],null)],null),new $APP.f(null,3,[$APP.Q,ecc,$APP.X,HZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic acosh.\n\nComputes the [inverse hyperbolic\n cosine](https://mathworld.wolfram.com/InverseHyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `2 ln(sqrt((x+1)/2) + sqrt((x-1)/2))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,l1b],null)],null),new $APP.f(null,3,[$APP.Q,GLb,
$APP.X,tZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic ceiling.\n\nReturns the result of rounding `a` up to the next largest integer.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,IGb],null)],null),new $APP.f(null,3,[$APP.Q,J1b,$APP.X,tR,$APP.h,new $APP.f(null,3,[$APP.P,"generic sinc.\n\nThe unnormalized [sinc\n  function](https://en.wikipedia.org/wiki/Sinc_function), equivalent to\n  $\\frac{\\sin x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/SincFunction.html)\n   - [Boost notes on [[sinc]]\n     and [[sinch]]](https://www.boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sinc/sinc_overview.html)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,iJb],null)],null),new $APP.f(null,3,[$APP.Q,z6b,$APP.X,Mqc,$APP.h,new $APP.f(null,1,[lU,uFb],null)],null),new $APP.f(null,3,[$APP.Q,nmb,$APP.X,Q4,$APP.h,new $APP.f(null,4,[$APP.P,"similar to a `let` binding that holds pairs of\n\n  \x3ccoordinate-structure-prototype\x3e, \x3ccoordinate-system\x3e\n\n  And internally binds, for each pair: (take `[x y]` and `m/R2-rect` as\n  examples):\n\n  - The coordinate system symbol `R2-rect` to a new version of the coordinate\n    system with its `coordinate-prototype` replaced by the one you supplied.\n    That's `(up x y)` in this example.\n\n  - the entries `x` and `y` to coordinate functions, i.e., functions from manifold\n    point to this particular coordinate\n\n  - `d:dx` and `d:dy` vector field procedures (I'm fuzzy here!)\n\n  - `dx` and `dy` 1-forms for each coordinate (fuzzy here too!)\n\n  Example:\n\n  ```clojure\n  (let-coordinates [[x y]    R2-rect\n                   [r theta] R2-polar]\n    ;; bindings:\n    ;; R2-rect, x, y, d:dx, d:dy, dx, dy\n    ;; R2-polar, r, theta, d:dr, d:dtheta, dr, dtheta\n    body...)\n  ```",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Fw,$APP.Lh,$APP.Tw],null)),$APP.Tl,!0,$APP.Dl,!0],null)],null),new $APP.f(null,3,[$APP.Q,zib,$APP.X,qP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some function `f` and any number of isomorphic `structures`,\n  returns the sum of the results of applying `f` to each associated set of\n  entries in each `structure`.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,CV],null)),lU,MDb],null)],null),new $APP.f(null,3,[$APP.Q,dbb,$APP.X,I4,$APP.h,new $APP.f(null,
3,[$APP.P,"Takes a function `f: R \x3d\x3e R` (function of a single real variable), and returns\n  a new function of `x` that approximates the derivative $Df(x)$ (or $D^2f(x)$\n  if you pass `:method :central-d2`).\n\n  Returns the estimated value of the derivative at `x`. If you pass `:info?\n  true`, the fn returns a dictionary of the results of `us/seq-limit`:\n\n  ```clojure\n  {:converged? \x3cboolean\x3e\n   :terms-checked \x3cint\x3e\n   :result \x3cderivative estimate\x3e}\n  ```\n\n  Make sure to visit [[emmy.calculus.derivative/D]] if you want symbolic or\n  automatic differentiation.\n\n  ### Roundoff Estimate\n\n  The returned function will attempt to estimate how many times it can halve the\n  step size used to estimate the derivative before roundoff error swamps the\n  calculation, and force the function to return (with `:converged? false`, if\n  you pass `:info?`)\n\n  ### Optional Arguments\n\n  `D-numeric` takes optional args as its second param. Any of these can be\n  overridden by passing a second argument to the function returned by\n  `D-numeric`; helpful for setting defaults and then overriding them later.\n\n  The returned function passes through these and any other options to\n  `us/seq-limit`, where they control the sequence of richardson\n  extrapolation-accelerated estimates.\n\n  Options:\n\n  - `:method`: one of `:central`, `:central-d2`, `:forward` or `:backward`.\n  `:central-d2` forces a second derivative estimate; the other methods configure\n  a first derivative estimator.\n\n  - `:info?` if false (default), returns the estimated value of `x`. If true,\n  returns a dictionary with more information (see `D-numeric`'s docstring for\n  more info.)\n\n  - `:initial-h`: the initial `h` to use for derivative estimates before $h \to\n  0$. Defaults to `0.1 * abs(x)`.\n\n  - `:tolerance`: see `us/stream-limit` for a discussion of how this value\n  handles relative vs absolute tolerance. $\\sqrt(\\epsilon)$ by default, where\n  $\\epsilon$ \x3d machine tolerance.\n\n  - `:maxterms`: the maximum number of terms to consider when hunting for a\n  derivative estimate. This defaults to an estimate generated internally,\n  designed to prevent roundoff error from swamping the result. If you want to\n  disable this feature, set `:maxterms` to something moderately large, like\n  `:maxterms 100`. But do so carefully! See the surrounding namespace for a\n  larger discussion.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Ox],null)),lU,tvb],null)],null),new $APP.f(null,3,[$APP.Q,hob,$APP.X,n5a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a function which will pull a form back across a map (without needing\n  its inverse)",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))),lU,YOb],null)],null),new $APP.f(null,3,[$APP.Q,DXb,$APP.X,w6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,
5,$APP.I,[zU,jW],null))),lU,g9b],null)],null),new $APP.f(null,3,[$APP.Q,dSb,$APP.X,nab,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[iS],null))),lU,QAb],null)],null),new $APP.f(null,3,[$APP.Q,QEb,$APP.X,lO,$APP.h,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of α radians about the z axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,zYb],null)],null),new $APP.f(null,3,[$APP.Q,lxb,$APP.X,Z9a,$APP.h,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),lU,zub],null)],null),new $APP.f(null,3,[$APP.Q,occ,$APP.X,FO,$APP.h,new $APP.f(null,3,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from a point on the\n  coordinate system's manifold to the coordinate representation specified by the\n  supplied `coordinate-system`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,X9b],null)],null),new $APP.f(null,3,[$APP.Q,jcc,$APP.X,wsc,$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.Q,awb,$APP.X,QQ,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[-\x3eL-state]].",lU,idc],null)],null),new $APP.f(null,3,[$APP.Q,wZb,$APP.X,Q4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,qW],null))),lU,Ctb],null)],null),new $APP.f(null,3,[$APP.Q,YHb,$APP.X,Eab,$APP.h,new $APP.f(null,3,[$APP.P,"velocities must be in meters/second, since we don't yet have units support.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.NW,$APP.OW],null))),lU,
$2b],null)],null),new $APP.f(null,3,[$APP.Q,rrb,$APP.X,sL,$APP.h,new $APP.f(null,3,[$APP.P,"generic conjugate",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Arb],null)],null),new $APP.f(null,3,[$APP.Q,ncc,$APP.X,V5a,$APP.h,new $APP.f(null,3,[$APP.P,"Flat coordinate systems here only.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,qW],null))),lU,GIb],null)],null),new $APP.f(null,3,[$APP.Q,MHb,$APP.X,vR,$APP.h,new $APP.f(null,3,[$APP.P,"generic sinhc.\n\nThe [sinhc function](https://en.wikipedia.org/wiki/Sinhc_function),\n  equivalent to $\\frac{\\sinh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinhc_function)\n   - [Mathworld page on Sinhc](https://mathworld.wolfram.com/SinhcFunction.html)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,zzb],null)],null),new $APP.f(null,3,[$APP.Q,PWb,$APP.X,SN,$APP.h,new $APP.f(null,3,[$APP.P,"Construct a down (covariant) tuple from the arguments. Variadic version\n  of [[down*]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.ix],null)),lU,OP],null)],null),new $APP.f(null,3,[$APP.Q,lzb,$APP.X,K9a,$APP.h,new $APP.f(null,3,[$APP.P,"f is a function of (x y continue fail), which calls continue with the values of\n  x' y' that follow x y in the mapping.\n\n  Returns a map of the same shape that iterates the iterated map n times before\n  invoking the continuation, or invokes the fail continuation if the inner map\n  fails.",
$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Iu,$APP.M($APP.mv,$APP.wU))],null)],null)))),lU,mrb],null)],null),new $APP.f(null,3,[$APP.Q,Eac,$APP.X,PK,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Sv],null))),lU,vcc],null)],null),new $APP.f(null,3,[$APP.Q,Bvb,$APP.X,lG,$APP.h,new $APP.f(null,3,[$APP.P,"generic sqrt",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),lU,r8b],null)],null),new $APP.f(null,3,[$APP.Q,QJb,$APP.X,JO,$APP.h,new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and an [[ICoordinateSystem]], returns a literal\n  function that maps coordinate-free manifold points to a scalar output.\n\n  Also aliased as [[literal-manifold-function]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,qW],null))),lU,mKb],null)],null),new $APP.f(null,3,[$APP.Q,vHb,$APP.X,K2a,$APP.h,new $APP.f(null,3,[$APP.P,"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.ix],null))),lU,b2b],null)],null),new $APP.f(null,3,[$APP.Q,ETb,$APP.X,erc,$APP.h,new $APP.f(null,1,[lU,ehb],null)],null),new $APP.f(null,3,[$APP.Q,CGb,$APP.X,$APP.$Q,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[Hamiltonian-\x3estate-derivative]], for compatibility with\n  1st edition of SICM.",lU,orb],null)],null),new $APP.f(null,3,[$APP.Q,odb,$APP.X,UH,$APP.h,new $APP.f(null,3,[$APP.P,"Return the cached or obvious arity of `f` if we know it. Otherwise\n    delegates to heavy duty reflection.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,jBb],null)],null),new $APP.f(null,3,[$APP.Q,gJb,$APP.X,LZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic asech.\n\nComputes the [inverse hyperbolic\n secant](https://mathworld.wolfram.com/InverseHyperbolicSecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1-x^2)) / x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,ewb],null)],null),new $APP.f(null,3,[$APP.Q,YQb,$APP.X,b6a,
$APP.h,new $APP.f(null,3,[$APP.P,"For making a (2,0) tensor into a (0,2) tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[OX,VU],null))),lU,c2b],null)],null),new $APP.f(null,3,[$APP.Q,bbc,$APP.X,zZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic asin.\n\nComputes the inverse sine of the supplied argument `a`.\n\nDefaults to `atan(x/sqrt(1-x^2))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Kcb],null)],null),new $APP.f(null,3,[$APP.Q,Vtb,$APP.X,u5a,$APP.h,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),lU,AAb],null)],null),new $APP.f(null,3,[$APP.Q,v_b,$APP.X,jO,$APP.h,new $APP.f(null,3,[$APP.P,"Produce the matrix of a rotation of α radians about the x axis.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,O2b],null)],null),new $APP.f(null,3,[$APP.Q,UZb,$APP.X,b5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[hdb,VU],null))),lU,q0b],null)],null),
new $APP.f(null,3,[$APP.Q,vVb,$APP.X,gR,$APP.h,new $APP.f(null,3,[$APP.P,"generic transpose",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Avb],null)],null),new $APP.f(null,3,[$APP.Q,BBb,$APP.X,Gqc,$APP.h,new $APP.f(null,1,[lU,xob],null)],null),new $APP.f(null,3,[$APP.Q,fRb,$APP.X,CP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[differential-of-map]].",lU,kHb],null)],null),new $APP.f(null,3,[$APP.Q,BFb,$APP.X,u4,$APP.h,new $APP.f(null,3,[$APP.P,"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[dS,XT,eY],null),$APP.Ml,new $APP.f(null,3,[dS,TT,XT,!1,eY,!1],null),$APP.dk,$APP.Ox],null)],null)),lU,Ncc],null)],null),new $APP.f(null,3,[$APP.Q,tcb,$APP.X,function(a){return["$$",$APP.m.j(S3(dG.j(a))),"$$"].join("")},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string containing a LaTeX representation of `expr`, wrapped in double\n  `$$` to mark the string as a block LaTeX form.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))],null)],null),new $APP.f(null,3,[$APP.Q,hHb,$APP.X,DP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[MT],null))),lU,QKb],null)],null),new $APP.f(null,3,[$APP.Q,VIb,$APP.X,p4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a form field that returns, for any supplied vector field `vf`, a\n  manifold function [[manifold/zero-manifold-function]] that maps every input\n  manifold `point` to the scalar value 0.",$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),lU,vNb],null)],null),new $APP.f(null,3,[$APP.Q,O_b,$APP.X,qG,$APP.h,new $APP.f(null,3,[$APP.P,"generic exp.\n\nReturns the base-e exponential of `x`. Equivalent to `(expt e x)`, given\n  some properly-defined `e` symbol.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,ywb],null)],null),new $APP.f(null,3,[$APP.Q,zcc,$APP.X,W8a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[WU],null))),lU,Vrb],null)],null),new $APP.f(null,3,[$APP.Q,g7b,$APP.X,IP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),lU,rXb],null)],null),new $APP.f(null,3,[$APP.Q,wkb,$APP.X,sG,$APP.h,new $APP.f(null,3,[$APP.P,"generic negative?.\n\nReturns true if the argument `a` is less than `(g/zero-like a)`,\n  false otherwise. The default implementation depends on a proper Comparable\n  implementation on the type.`",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),lU,iSb],null)],null),new $APP.f(null,3,[$APP.Q,Gcb,$APP.X,UO,$APP.h,new $APP.f(null,3,[$APP.P,"Reverse-mode derivative operator. Takes some function `f` and returns a\n  function whose value at some point can multiply an increment in the arguments\n  to produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D-reverse]] computes a derivative. For vector-valued\n  functions, [[D-reverse]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,R7b],null)],null),new $APP.f(null,3,[$APP.Q,Deb,$APP.X,sZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic integer-part.\n\nReturns the integer part of `a` by removing any fractional digits.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,qbb],null)],null),new $APP.f(null,3,[$APP.Q,Yrb,$APP.X,T2a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rU],null))),lU,Jxb],null)],
null),new $APP.f(null,3,[$APP.Q,X5b,$APP.X,aP,$APP.h,new $APP.f(null,3,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,NX],null)],null),new $APP.f(null,3,[$APP.Q,Oeb,$APP.X,qL,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a structure compatible for multiplication with `s` down to a scalar,\n  with the slots filled with gensyms.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Vv],null))),lU,lmb],null)],null),new $APP.f(null,3,[$APP.Q,gbb,$APP.X,HP,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[UR],null))),
lU,kOb],null)],null),new $APP.f(null,3,[$APP.Q,zUb,$APP.X,RP,$APP.h,new $APP.f(null,3,[$APP.P,"To make a vector field into a one-form field, i.e., a (1,0) tensor into a (0,1)\n  tensor.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[jW],null))),lU,qdc],null)],null),new $APP.f(null,3,[$APP.Q,Rcc,$APP.X,I2a,$APP.h,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - `c-\x3ee`, a function mapping coordinates to events\n  - `e-\x3ec`, a function mapping events to coordinates\n\n  and returns a function that takes:\n\n  - a symbolic name\n  - an ancestor frame\n  - a dictionary of params\n\n  and returns instance of [[IFrame]].\n\n  Both `c-\x3ee` and `e-\x3ec` must accept three arguments:\n\n  - `ancestor-frame`\n  - the [[IFrame]] instance\n  - a map of parameters supplied to the returned function (possibly empty!).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[sX,aT],null))),lU,oSb],null)],null),new $APP.f(null,3,[$APP.Q,v6b,$APP.X,YH,$APP.h,new $APP.f(null,3,[$APP.P,"Arity-preserving version of `clojure.core/comp`.\n\n  The arity of a composition is the arity of the rightmost (that is, first to be\n  applied) function term in `fns`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,bW],null)),lU,n9b],null)],null),new $APP.f(null,3,[$APP.Q,lEb,$APP.X,t9a,$APP.h,new $APP.f(null,3,[$APP.P,"SICM p. 83",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[rV],null))),lU,nwb],null)],null),new $APP.f(null,3,[$APP.Q,ijb,$APP.X,SP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[raise]].",lU,rib],null)],null),new $APP.f(null,3,[$APP.Q,q1b,$APP.X,m2,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a basis sequence of `n` 0s, with `1` in the `i`th position.\n\n  If `n` is not supplied returns an infinite sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Rv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.Rv],
null)),lU,eqb],null)],null),new $APP.f(null,3,[$APP.Q,WGb,$APP.X,FN,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the single row from the supplied row matrix as a `down`. Errors if some\n  other type is supplied.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(DV,$APP.Qr)],null)],null)))),lU,qzb],null)],null),new $APP.f(null,3,[$APP.Q,cEb,$APP.X,$3,$APP.h,new $APP.f(null,3,[$APP.P,"Find the minimum of the function `f: R -\x3e R` in the interval `[a, b]`.\n\n  If an `observe` function is supplied, it will be invoked with the iteration\n  count and the values of x and f(x) at each search step.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,dW],null)),lU,iNb],null)],null),new $APP.f(null,3,[$APP.Q,qpb,$APP.X,IZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic asinh.\n\nComputes the [inverse hyperbolic\n sine](https://mathworld.wolfram.com/InverseHyperbolicSine.html) of the\n supplied argument `a`.\n\ndefaults to `ln(x + sqrt(1 + x^2))`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,DOb],
null)],null),new $APP.f(null,3,[$APP.Q,eSb,$APP.X,iP,$APP.h,new $APP.f(null,3,[$APP.P,"Takes:\n\n  - a `down` tuple of `components` of the one-form field relative to\n    `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a full one-form field.\n\n  A one-field field is an operator that takes a vector field to a real-valued\n  function on the manifold.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null)),lU,RTb],null)],null),new $APP.f(null,
3,[$APP.Q,tPb,$APP.X,xTa,$APP.h,new $APP.f(null,2,[$APP.U,null,lU,QZb],null)],null),new $APP.f(null,3,[$APP.Q,X1b,$APP.X,hL,$APP.h,new $APP.f(null,3,[$APP.P,"Generates an `up` structure of dimension `size` populated by symbolic entries,\n  each prefixed by the supplied symbol `sym`.\n\n  For example:\n\n  ```clojure\n  (\x3d (literal-up 'x 3)\n     (up 'x↑0 'x↑1 'x↑2))\n  ```",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,$APP.yY],null))),lU,y6b],null)],null),new $APP.f(null,3,[$APP.Q,
swb,$APP.X,wL,$APP.h,new $APP.f(null,1,[lU,rhb],null)],null),new $APP.f(null,3,[$APP.Q,jGb,$APP.X,V2a,$APP.h,new $APP.f(null,1,[lU,Zsb],null)],null),new $APP.f(null,3,[$APP.Q,gFb,$APP.X,X5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))),lU,K2b],null)],null),new $APP.f(null,3,[$APP.Q,Z9b,$APP.X,grc,$APP.h,new $APP.f(null,1,[lU,ZGb],null)],null),new $APP.f(null,3,[$APP.Q,t0b,$APP.X,tWa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[emmy.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to handle [[Dual]]\n  inputs in addition to any types that a normal `(f x)` call would present. This\n  restriction does _not_ apply to operations like putting `x` into a container\n  or destructuring; just primitive function calls.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,Eyb],null)],null),new $APP.f(null,3,[$APP.Q,Pab,$APP.X,SP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[raise]].",lU,bjb],null)],null),new $APP.f(null,3,[$APP.Q,j4b,$APP.X,eL,$APP.h,new $APP.f(null,3,[$APP.P,"Generate a structure with the given `orientation` whose elements are\n\n  (f i)\n\n  where i ranges from `[0..dimension)`.",$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[$APP.CY,oU,$APP.Nv],null),new $APP.f(null,
1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(sW,oU)],null)],null)))),lU,qUb],null)],null),new $APP.f(null,3,[$APP.Q,aHb,$APP.X,$APP.RQ,$APP.h,new $APP.f(null,3,[$APP.P,"Optionally takes a dissipation function.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null),new $APP.H(null,2,5,$APP.I,[$APP.FU,xY],null)),lU,agb],null)],null),new $APP.f(null,3,[$APP.Q,jZb,$APP.X,I9a,$APP.h,new $APP.f(null,3,[$APP.P,"p. 428, the Lie transform is just the time-advance operator using the Lie\n  derivative (see Hamiltonian.scm).",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.DU,$APP.Uv],null))),lU,Cqb],null)],null),new $APP.f(null,3,[$APP.Q,Zfb,$APP.X,fab,$APP.h,new $APP.f(null,3,[$APP.P,"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
5,5,$APP.I,[cW,OV,$APP.UU,KW,$APP.cX],null))),lU,KIb],null)],null),new $APP.f(null,3,[$APP.Q,yQb,$APP.X,RP,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[lower]].",lU,d2b],null)],null),new $APP.f(null,3,[$APP.Q,Zac,$APP.X,$4a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[JU,yU,$APP.lP,$APP.wU],null))),lU,MIb],null)],null),new $APP.f(null,3,[$APP.Q,Dcc,$APP.X,XZ,$APP.h,new $APP.f(null,3,[$APP.P,"Renders an expression through the simplifier and onto the stream.",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Ww,dU],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,dU,$APP.Au],null)),lU,twb],null)],null),new $APP.f(null,3,[$APP.Q,zmb,$APP.X,brc,$APP.h,new $APP.f(null,1,[lU,omb],null)],null),new $APP.f(null,3,[$APP.Q,xDb,$APP.X,WP,$APP.h,new $APP.f(null,1,[lU,Dsb],null)],null),new $APP.f(null,3,[$APP.Q,xUb,$APP.X,TSa,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`.",$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null))),lU,iPb],null)],null),new $APP.f(null,3,[$APP.Q,Npb,$APP.X,$APP.XQ,$APP.h,new $APP.f(null,3,[$APP.P,"Accepts a coordinate transformation `F` from a local tuple to a new coordinate\n  structure, and returns a function from `local -\x3e local` that applies the\n  transformation directly.\n\n  [[F-\x3eC]] handles local tuples of arbitrary length.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[CU],null))),lU,HJb],null)],null),new $APP.f(null,
3,[$APP.Q,qFb,$APP.X,DZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic tanh.\n\nComputes the [hyperbolic\n tangent](https://mathworld.wolfram.com/HyperbolicTangent.html) of the supplied\n argument `a`.\n\ndefaults to `sinh(x) / cosh(x)`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,FKb],null)],null),new $APP.f(null,3,[$APP.Q,rcb,$APP.X,e3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a set of patch names registered in the supplied manifold.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[aS],null))),lU,Fob],null)],null),new $APP.f(null,3,[$APP.Q,Ebb,$APP.X,nrc,$APP.h,new $APP.f(null,1,[lU,iwb],null)],null),new $APP.f(null,3,[$APP.Q,Djb,$APP.X,S5a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),lU,U$b],null)],null),new $APP.f(null,3,[$APP.Q,SJb,$APP.X,f6a,$APP.h,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[jW,VU,$APP.Qr],null))),lU,L9b],null)],null),new $APP.f(null,3,[$APP.Q,yGb,$APP.X,kZ,$APP.h,
new $APP.f(null,3,[$APP.P,"generic identity?.\n\nLike `one?`, but this is true of square identity matrices as well.\n  No matrix is considered `one?` because its function as a multiplicative\n  identity depends on the shape of the other multiplicand.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,vDb],null)],null),new $APP.f(null,3,[$APP.Q,iGb,$APP.X,U2a,$APP.h,new $APP.f(null,1,[lU,Xsb],null)],null),new $APP.f(null,3,[$APP.Q,LEb,$APP.X,vG,$APP.h,new $APP.f(null,3,[$APP.P,
"generic zero-like.\n\nIn general, this procedure returns the additive identity of the type of its\n  argument, if it exists. For numbers this is 0.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,bFb],null)],null),new $APP.f(null,3,[$APP.Q,b4b,$APP.X,frc,$APP.h,new $APP.f(null,1,[lU,Sub],null)],null),new $APP.f(null,3,[$APP.Q,dpb,$APP.X,wL,$APP.h,new $APP.f(null,1,[lU,Yqb],null)],null),new $APP.f(null,3,[$APP.Q,s9b,$APP.X,YP,$APP.h,new $APP.f(null,3,[$APP.P,"Both arities of [[divergence]] are defined on page 156 of Functional Differential Geometry.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[PV],null),new $APP.H(null,2,5,$APP.I,[jW,EV],null)),lU,eOb],null)],null),new $APP.f(null,3,[$APP.Q,XUb,$APP.X,usc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,gPb,$APP.X,i3a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns a set of names of all coordinate system constructors registered in the\n  supplied patch.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Gfb],null))),lU,cRb],null)],null),new $APP.f(null,3,[$APP.Q,CFb,$APP.X,RZ,$APP.h,new $APP.f(null,
3,[$APP.P,"generic angle",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Cub],null)],null),new $APP.f(null,3,[$APP.Q,Hob,$APP.X,Yqc,$APP.h,new $APP.f(null,1,[lU,zpb],null)],null),new $APP.f(null,3,[$APP.Q,OEb,$APP.X,UO,$APP.h,new $APP.f(null,3,[$APP.P,"Derivative operator. Takes some function `f` and returns a function whose value\n  at some point can multiply an increment in the arguments to produce the best\n  linear estimate of the increment in the function value.\n\n  For univariate functions, [[D]] computes a derivative. For vector-valued\n  functions, [[D]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.\n\n  The related [[emmy.env/Grad]] returns a function that produces a structure of\n  the opposite orientation as [[D]]. Both of these functions use reverse-mode\n  automatic differentiation.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,uwb],null)],null),new $APP.f(null,3,[$APP.Q,v8b,$APP.X,Kqc,$APP.h,new $APP.f(null,1,[lU,Lab],null)],null),new $APP.f(null,3,[$APP.Q,pgb,$APP.X,H3,$APP.h,new $APP.f(null,3,[$APP.P,"Computes the wedge product of the sequence `fs` of one-forms.\n\n  Higher rank forms can be constructed from one-forms by wedging them together.\n  This antisymmetric tensor product is computed as a determinant. The purpose of\n  this is to allow us to use the construction dx^dy to compute the area\n  described by the vectors that are given to it.\n\n  See Spivak p275 v1 of 'Differential Geometry' to see the correct definition.\n  The key is that the wedge of the coordinate basis forms had better be the\n  volume element.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.px],null)),lU,bhb],null)],null),new $APP.f(null,3,[$APP.Q,Mzb,$APP.X,DF,$APP.h,new $APP.f(null,3,[$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Su],null))),lU,lbb],null)],null),new $APP.f(null,3,[$APP.Q,Jfb,$APP.X,s4a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns true if the supplied `f` is\n  a [One-form](https://en.wikipedia.org/wiki/One-form), false\n  otherwise.\n\n  A [One-form](https://en.wikipedia.org/wiki/One-form) takes a single vector\n  field to a real-valued function on the manifold.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null))),lU,TKb],null)],null),new $APP.f(null,3,[$APP.Q,rBb,$APP.X,o3,$APP.h,new $APP.f(null,1,[lU,Wob],null)],null),new $APP.f(null,3,[$APP.Q,GSb,$APP.X,B3a,$APP.h,new $APP.f(null,3,[$APP.P,"Takes some constant `c` and returns a manifold function that maps every input\n  manifold `point` to `c.`",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))),lU,ypb],null)],null),new $APP.f(null,3,[$APP.Q,JVb,$APP.X,Y3a,$APP.h,
new $APP.f(null,3,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3evector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,qW],null))),lU,Yzb],null)],null),new $APP.f(null,3,[$APP.Q,q2b,$APP.X,B3,$APP.h,new $APP.f(null,3,[$APP.P,"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[emmy.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, i.e., the Taylor series expansion at `(\x3d x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[emmy.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[emmy.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) \x3d f(x) + \\frac{f'(x)}{1!}(p-x) + \\frac{f''(x)}{2!} (p-x)^2 + \\ldots,$$\n\n  where `p` is the evaluation point. When `(\x3d p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) \x3d T(x+dx) \x3d f(x) + \\frac{f'(x)}{1!}(dx) + \\frac{f''(x)}{2!} (dx)^2 + \\ldots.$$",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lh,$APP.ix],null)),lU,NUb],null)],null),new $APP.f(null,3,[$APP.Q,hub,$APP.X,dG,$APP.h,new $APP.f(null,3,[$APP.P,"generic simplify",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,j6b],null)],null),new $APP.f(null,3,[$APP.Q,y7b,$APP.X,JZ,$APP.h,new $APP.f(null,3,[$APP.P,"generic atanh.\n\nComputes the [inverse hyperbolic\n tangent](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) of the\n supplied argument `a`.\n\ndefaults to `1/2 ln((1+x)/(1-x))`.",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,Udc],null)],null),new $APP.f(null,3,[$APP.Q,H1b,$APP.X,uG,$APP.h,new $APP.f(null,3,[$APP.P,"generic one?.\n\nIs true if `x` is a multiplicative identity.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),lU,nJb],null)],null),new $APP.f(null,3,[$APP.Q,Gqb,$APP.X,a2a,$APP.h,new $APP.f(null,3,[$APP.P,"Returns the submatrix of the matrix (or matrix-like structure) `s` generated by\n  taking\n\n  - rows    from `lowrow` -\x3e `hirow` (inclusive)\n  - columns from `lowcol` -\x3e `hicol` (inclusive)",
$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[$APP.Yv,N2b,ILb,Pac,QUb],null))),lU,f3b],null)],null)]),$APP.ap(KCb)),$APP.cp(new $APP.f(null,3,[$APP.z(X$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`"],
null)),new $APP.f(null,3,[$APP.Q,gJ,$APP.X,fJ,$APP.h,new $APP.f(null,2,[$APP.P,"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),$APP.z($APP.pra,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Given a form returned by a consequence function, unwraps the top level\n  `succeed` wrapper if present to return the final value."],null)),new $APP.f(null,3,[$APP.Q,$lb,$APP.X,QXa,$APP.h,new $APP.f(null,2,[$APP.P,"Given a form returned by a consequence function, unwraps the top level\n  `succeed` wrapper if present to return the final value.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),$APP.z(T9b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[cUb,Jcc],null))),$APP.P,"Takes:\n\n  - a symbol `frame-sym` meant to reference a map of bindings\n  - a skeleton expression `skel`\n\n  and returns an unevaluated body that, when evaluated, will produce a form\n  structure of identical shape to `skel`, with:\n\n  - all variable binding forms replaced by forms that look up the binding in a\n    map bound to `frame-sym`\n  - same with any segment binding form, with the added note that these should\n    be spliced in\n  - any `unquote` or `unquote-splicing` forms respected."],
null)),new $APP.f(null,3,[$APP.Q,VZb,$APP.X,UXa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - a symbol `frame-sym` meant to reference a map of bindings\n  - a skeleton expression `skel`\n\n  and returns an unevaluated body that, when evaluated, will produce a form\n  structure of identical shape to `skel`, with:\n\n  - all variable binding forms replaced by forms that look up the binding in a\n    map bound to `frame-sym`\n  - same with any segment binding form, with the added note that these should\n    be spliced in\n  - any `unquote` or `unquote-splicing` forms respected.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[cUb,Jcc],null))],null)],null)],null),$APP.ap(XGb)),$APP.cp(new $APP.f(null,3,[Lxb,new $APP.f(null,3,[$APP.Q,Xjb,$APP.X,bsc,$APP.h,$APP.F],null),$APP.z(FSb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[dS,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[dS,$APP.Lv,$APP.sU,$APP.Qr],null))),$APP.P,"Takes:\n\n  - An integration method, specified as either:\n    - a keyword naming one of the available methods in `available-methods`\n    - a function with the proper integrator signature\n    - a dictionary of integrator options with a `:method` key\n\n  - `a` and `b` integration endpoints\n  - an optional dictionary of options `m`\n\n  And returns a pair of an integrator function and a possibly-enhanced options\n  dictionary.\n\n  (Some integration functions require extra options, so the returned dictionary\n  may have more entries than the `m` you pass in.)\n\n  If either endpoint is infinite, the returned integrator is wrapped in\n  `qi/improper` and able to handle infinite endpoints (as well as non-infinite\n  endpoints by passing through directly to the underlying integrator).",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[dS,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[dS,$APP.Lv,$APP.sU,$APP.Qr],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[dS,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[dS,$APP.Lv,$APP.sU,$APP.Qr],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Gnb,$APP.X,t4,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - An integration method, specified as either:\n    - a keyword naming one of the available methods in `available-methods`\n    - a function with the proper integrator signature\n    - a dictionary of integrator options with a `:method` key\n\n  - `a` and `b` integration endpoints\n  - an optional dictionary of options `m`\n\n  And returns a pair of an integrator function and a possibly-enhanced options\n  dictionary.\n\n  (Some integration functions require extra options, so the returned dictionary\n  may have more entries than the `m` you pass in.)\n\n  If either endpoint is infinite, the returned integrator is wrapped in\n  `qi/improper` and able to handle infinite endpoints (as well as non-infinite\n  endpoints by passing through directly to the underlying integrator).",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[dS,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[dS,$APP.Lv,$APP.sU,$APP.Qr],null))],null)],null),$APP.z(bbb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[dS,XT,eY],null),$APP.Ml,new $APP.f(null,3,[dS,TT,XT,!1,eY,!1],null),$APP.dk,$APP.Ox],null)],null))),$APP.P,"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[dS,XT,eY],null),$APP.Ml,new $APP.f(null,3,[dS,TT,XT,!1,eY,!1],null),$APP.dk,$APP.Ox],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,
3,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[dS,XT,eY],null),$APP.Ml,new $APP.f(null,3,[dS,TT,XT,!1,eY,!1],null),$APP.dk,$APP.Ox],null)],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Ncc,$APP.X,u4,$APP.h,new $APP.f(null,2,[$APP.P,"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Lv,$APP.sU,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[dS,XT,eY],null),$APP.Ml,new $APP.f(null,3,[dS,TT,XT,!1,eY,!1],null),$APP.dk,$APP.Ox],null)],null))],null)],null)],null),$APP.ap(j5b)),$APP.cp(new $APP.f(null,2,[$APP.z(wAb,new $APP.f(null,1,[$APP.im,!0],null)),new $APP.f(null,3,[$APP.Q,ecb,$APP.X,!0,$APP.h,$APP.F],null),$APP.z(dhb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[$T,$APP.lw],null),new $APP.H(null,3,5,$APP.I,[$T,$APP.lw,U6b],null))),$APP.P,"Log an assumption.\n\n  NOTE that `if-false` is not used right now. Currently this always returns true.\n\n  NOTE: what this WILL do is check if the assumption is correct, to the extent\n  that this is possible, and fail if it's provably false.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$T,$APP.lw],null),new $APP.H(null,
3,5,$APP.I,[$T,$APP.lw,U6b],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$T,$APP.lw],null),new $APP.H(null,3,5,$APP.I,[$T,$APP.lw,U6b],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,qIb,$APP.X,GJ,$APP.h,new $APP.f(null,2,[$APP.P,"Log an assumption.\n\n  NOTE that `if-false` is not used right now. Currently this always returns true.\n\n  NOTE: what this WILL do is check if the assumption is correct, to the extent\n  that this is possible, and fail if it's provably false.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$T,$APP.lw],null),new $APP.H(null,3,5,$APP.I,[$T,$APP.lw,U6b],null))],null)],null)],null),$APP.ap(Yxb)),$APP.cp(new $APP.f(null,7,[$APP.z(Q3b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.wU,$APP.Ox],null))),$APP.P,"Returns a compiled, simplified version of `f`, given a function `f` of arity\n  `n` (i.e., able to accept `n` symbolic arguments).\n\n  `n` defaults to `([[f/arity]] f)`.\n\n  You may also specify options in the third argument. See [[compile-state-fn]]\n  for information on the options supported.\n\n  The returned, compiled function expects `n` `Double` (or `js/Number`)\n  arguments. The function body is simplified and all common subexpressions\n  identified during compilation are extracted and computed only once.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.wU,$APP.Ox],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.wU,$APP.Ox],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,iHb,$APP.X,
$APP.b4,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a compiled, simplified version of `f`, given a function `f` of arity\n  `n` (i.e., able to accept `n` symbolic arguments).\n\n  `n` defaults to `([[f/arity]] f)`.\n\n  You may also specify options in the third argument. See [[compile-state-fn]]\n  for information on the options supported.\n\n  The returned, compiled function expects `n` `Double` (or `js/Number`)\n  arguments. The function body is simplified and all common subexpressions\n  identified during compilation are extracted and computed only once.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Nv],null),new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.wU],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.wU,$APP.Ox],null))],null)],null),$APP.z(YJb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mW],null))),$APP.P,"Set the default compilation mode by supplying an entry from [[valid-modes]]."],null)),new $APP.f(null,3,[$APP.Q,Q1b,$APP.X,function(a){W7a(a);return Mrc=a},$APP.h,new $APP.f(null,2,[$APP.P,"Set the default compilation mode by supplying an entry from [[valid-modes]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[mW],null))],null)],null),$APP.z(rTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf)),$APP.P,"Validates and returns the dynamically bound compilation [[*mode*]].\n  Throws on an invalid setting."],null)),new $APP.f(null,3,[$APP.Q,Rpb,$APP.X,function(){return W7a(Mrc)},$APP.h,new $APP.f(null,2,[$APP.P,"Validates and returns the dynamically bound compilation [[*mode*]].\n  Throws on an invalid setting.",$APP.U,$APP.M($APP.sf)],null)],null),$APP.z(Z8b,
new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Iw,$APP.UU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Iw,$APP.UU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,7,5,$APP.I,[mW,WW,aU,KY,kY,mS,hY],null),$APP.Ml,new $APP.f(null,6,[mW,eW,WW,kV,KY,$APP.M($APP.zv,$APP.Iw),kY,$APP.M(nY,4),mS,!0,hY,!0],null)],null)],null))),$APP.P,"Returns a compiled, simplified function with signature `(f state params?)`,\n  given:\n\n  - a state function that can accept a symbolic arguments\n\n  - `params`: really any sequence of count equal to the number of arguments\n    taken by `f`. The values are ignored. If the specific value `false` is\n    provided, then `f` is considered to be the function to compile itself, and not\n    the producer of such a function via application of parameters.\n\n  - `initial-state`: Some structure of the same shape as the argument expected\n    by the fn returned by the state function `f`. Only the shape matters; the\n    values are ignored.\n\n  - an optional argument `opts`. Options accepted are:\n\n    - `:calling-convention`: May have one of the following values. (In\n      each of these examples, assume that the initial state\n      `(up 1 (up 2 3) (up 3 4)) has been provided.)\n\n      - `:structure`: The arguments to the compiled function will have\n        the same shape as the initial-state, and elements of that state\n        will be made available to the function via argument destructuring\n        in function signature, e.g.:\n\n        ```clojure\n        (fn [[y1 [y2 y3] [y4 y5]]] [p1 ...] ...)\n        ```\n\n      - `:primitive`: The compiled function will expect a primitive array\n        containing the state in flat form to be passed as the first\n        argument, and will return its value by mutating its second argument,\n        which will also be a primitive array of the same size. The parameters\n        will be provided via a third primitive array:\n\n        ```clojure\n        (fn [ys yps ps] ...)\n        ```\n\n        This is the fastest form, as no allocations are needed to destructure\n        arguments list or to construct the return value, but requires the use\n        of primitive arrays (not general Clojure sequences, even if mutable) by\n        the caller. The generated code will use `aget` and `aset` on the arrays.\n\n    - `:generic-params?`: if `true` (default), the returned function will take a\n      second argument for the parameters of the state derivative and keep params\n      generic. If false, the returned function will take a single state argument,\n      and the supplied params will be hardcoded; moreover, the resulting compiled\n      function will not be cached.\n\n    - `:mode`: Explicitly set the compilation mode to one of the values\n      in [[valid-modes]]. Explicit alternative to dynamically binding [[*mode*]].\n\n    - `:cache`: If falsy, the compilation cache is avoided (it will neither\n      be consulted nor updated).\n\n    - `:gensym-fn` allows injection of a symbol generator for unit test\n      purposes\n\n    - `:arity` records the arity selected for a compiled non-state function\n      and is ordinarily provided automatically by [[compile-fn]].\n\n    - `:simplify?` If `true`, simplify the expanded function body before proceeding\n      to subexpression elimination and successive steps. If `false`, skip this step.\n      Defaults to `true`.\n\n  The returned, compiled function expects all `Double` (or `js/Number`) for all\n  state primitives. The function body is simplified and all common\n  subexpressions identified during compilation are extracted and computed only\n  once.\n\n  Function compilations are cached with a key that attempts to capture all of\n  the relevant information ",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Iw,$APP.UU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Iw,$APP.UU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,7,5,$APP.I,[mW,WW,aU,KY,kY,mS,hY],null),$APP.Ml,new $APP.f(null,6,[mW,eW,WW,kV,KY,$APP.M($APP.zv,$APP.Iw),kY,$APP.M(nY,4),mS,!0,hY,!0],null)],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Iw,$APP.UU],null),new $APP.H(null,4,
5,$APP.I,[$APP.Nv,$APP.Iw,$APP.UU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,7,5,$APP.I,[mW,WW,aU,KY,kY,mS,hY],null),$APP.Ml,new $APP.f(null,6,[mW,eW,WW,kV,KY,$APP.M($APP.zv,$APP.Iw),kY,$APP.M(nY,4),mS,!0,hY,!0],null)],null)],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,Ddc,$APP.X,$APP.MR,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a compiled, simplified function with signature `(f state params?)`,\n  given:\n\n  - a state function that can accept a symbolic arguments\n\n  - `params`: really any sequence of count equal to the number of arguments\n    taken by `f`. The values are ignored. If the specific value `false` is\n    provided, then `f` is considered to be the function to compile itself, and not\n    the producer of such a function via application of parameters.\n\n  - `initial-state`: Some structure of the same shape as the argument expected\n    by the fn returned by the state function `f`. Only the shape matters; the\n    values are ignored.\n\n  - an optional argument `opts`. Options accepted are:\n\n    - `:calling-convention`: May have one of the following values. (In\n      each of these examples, assume that the initial state\n      `(up 1 (up 2 3) (up 3 4)) has been provided.)\n\n      - `:structure`: The arguments to the compiled function will have\n        the same shape as the initial-state, and elements of that state\n        will be made available to the function via argument destructuring\n        in function signature, e.g.:\n\n        ```clojure\n        (fn [[y1 [y2 y3] [y4 y5]]] [p1 ...] ...)\n        ```\n\n      - `:primitive`: The compiled function will expect a primitive array\n        containing the state in flat form to be passed as the first\n        argument, and will return its value by mutating its second argument,\n        which will also be a primitive array of the same size. The parameters\n        will be provided via a third primitive array:\n\n        ```clojure\n        (fn [ys yps ps] ...)\n        ```\n\n        This is the fastest form, as no allocations are needed to destructure\n        arguments list or to construct the return value, but requires the use\n        of primitive arrays (not general Clojure sequences, even if mutable) by\n        the caller. The generated code will use `aget` and `aset` on the arrays.\n\n    - `:generic-params?`: if `true` (default), the returned function will take a\n      second argument for the parameters of the state derivative and keep params\n      generic. If false, the returned function will take a single state argument,\n      and the supplied params will be hardcoded; moreover, the resulting compiled\n      function will not be cached.\n\n    - `:mode`: Explicitly set the compilation mode to one of the values\n      in [[valid-modes]]. Explicit alternative to dynamically binding [[*mode*]].\n\n    - `:cache`: If falsy, the compilation cache is avoided (it will neither\n      be consulted nor updated).\n\n    - `:gensym-fn` allows injection of a symbol generator for unit test\n      purposes\n\n    - `:arity` records the arity selected for a compiled non-state function\n      and is ordinarily provided automatically by [[compile-fn]].\n\n    - `:simplify?` If `true`, simplify the expanded function body before proceeding\n      to subexpression elimination and successive steps. If `false`, skip this step.\n      Defaults to `true`.\n\n  The returned, compiled function expects all `Double` (or `js/Number`) for all\n  state primitives. The function body is simplified and all common\n  subexpressions identified during compilation are extracted and computed only\n  once.\n\n  Function compilations are cached with a key that attempts to capture all of\n  the relevant information ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Iw,$APP.UU],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,$APP.Iw,$APP.UU,new $APP.f(null,2,[$APP.Bu,new $APP.H(null,7,5,$APP.I,[mW,WW,aU,KY,kY,mS,hY],null),$APP.Ml,new $APP.f(null,6,[mW,eW,WW,kV,KY,$APP.M($APP.zv,$APP.Iw),kY,$APP.M(nY,4),mS,!0,hY,!0],null)],null)],null))],null)],null),bcc,new $APP.f(null,3,[$APP.Q,kRb,$APP.X,wQ,$APP.h,$APP.F],null),$APP.z(OWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mW],null))),
$APP.P,"Given a keyword `mode` specifying a compilation mode, returns `mode` if valid,\n  and throws otherwise."],null)),new $APP.f(null,3,[$APP.Q,Stb,$APP.X,W7a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a keyword `mode` specifying a compilation mode, returns `mode` if valid,\n  and throws otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[mW],null))],null)],null),$APP.z(bPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[x9b],null))),$APP.P,"Given an unevaluated source code form `f-form` representing a function,\n  evaluates `f-form` using the bindings in [[sci-context]].\n\n  Generate these forms by setting `*mode*` to `:source`."],
null)),new $APP.f(null,3,[$APP.Q,$_b,$APP.X,e8a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an unevaluated source code form `f-form` representing a function,\n  evaluates `f-form` using the bindings in [[sci-context]].\n\n  Generate these forms by setting `*mode*` to `:source`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[x9b],null))],null)],null)],null),$APP.ap(GQb)),$APP.cp($APP.fg([$APP.z(ZZb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,
5,$APP.I,[$APP.Nv,KV,BY],null)))],null)),$APP.z(k1b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null))),$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns the result of aggregating either `xs` or `(map f (range low\n  high))` using the fold dynamically bound to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (sum inc 0 10))\n  ;;\x3d\x3e [55.0 1 10]\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($APP.H3b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[GT,tT,jX,$APP.wx],null),new $APP.H(null,5,5,$APP.I,[GT,tT,jX,$APP.wx,
VV],null))),$APP.P,"Similar to [[monoid]] for types with invertible elements. Accepts:\n\n  - binary `minus` and (associative) `plus` functions\n  - a unary `negate` function\n  - an element `id` that obeys `(plus id other) \x3d\x3d (plus other id) \x3d\x3d other`\n  - optionally, an `annihilate?` function that should return true for any `x`\n    such that `(plus x \x3cany\x3e) \x3d\x3d x`.\n\n  And returns a function that will SUBTRACT elements. Given `x`, `y`, `z`, for\n  example, the returned function will return `(- x y z)`, implemented as `(minus\n  x (plus y z))`\n\n  If the `annihilate?` function is supplied, then if the aggregation produces a\n  value that returns `(annihilate? true)` at any point, the reduction will\n  return immediately.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,5,$APP.qw,5,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,4,5,$APP.I,[GT,tT,jX,$APP.wx],null),new $APP.H(null,5,5,$APP.I,[GT,tT,jX,$APP.wx,VV],null)],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[GT,tT,jX,$APP.wx],null),new $APP.H(null,5,5,$APP.I,[GT,tT,jX,$APP.wx,VV],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(oZb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.vw,$APP.iT,$APP.Cv,iU],null))),$APP.P,"NOTE that the returned function recurs on increasing indices internally instead\n  of walking through the lists directly. This method of traversing vectors is\n  more efficient, and this function is called so often that the performance gain\n  is worth it, and reads almost like the explicit sequence traversal."],
null)),$APP.z(tjb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[tT,$APP.wx],null),new $APP.H(null,3,5,$APP.I,[tT,$APP.wx,VV],null))),$APP.P,"Accepts a binary (associative) aggregation function `plus` and an identity\n  element `id` and returns a multi-arity function that will combine its\n  arguments via `plus`. A 0-arity call returns `id`.\n\n  optionally takes an `annihilate?` function that should return true for any `x`\n  such that `(plus x \x3cany\x3e) \x3d\x3d x`.\n\n  If the `annihilate?` function is supplied, then if the aggregation produces a\n  value that returns `(annihilate? true)` at any point, the reduction will\n  return immediately.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[tT,$APP.wx],null),new $APP.H(null,3,5,$APP.I,[tT,$APP.wx,VV],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[tT,$APP.wx],null),new $APP.H(null,3,5,$APP.I,[tT,$APP.wx,VV],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(rSb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null))),$APP.P,
"Given a vector of numbers, returns the [pairwise\n  summation](https://en.wikipedia.org/wiki/Pairwise_summation) of the vector\n  generated by arranging the vector into a binary tree and summing leaves\n  together all the way up to the root.\n\n  If `xs` is _not_ a vector, [[pairwise-sum]] will realize all elements into a\n  vector before operating.\n\n  If the initial vector, or some recursive slice, reaches a count\n  \x3c\x3d [[*cutoff*]], [[pairwise-sum]] defers to `(reduce + xs)`.\n\n  ### Performance Discussion\n\n  [[pairwise-sum]] is perhaps 10% faster than [[sum]]\n  with [[emmy.algebra.fold/kbn]] bound to [[*fold*]], but has poorer bounds\n  on its error growth. Instead of having roughly constant error regardless of\n  the size of the input, in the worst case its accumulated error grows with\n  $O(\\log n)$.\n\n  This improvement is due to the fact that [[pairwise-sum]] tends to add up\n  numbers of similar magnitude, instead of adding deltas into a progressively\n  larger sum.\n\n  This implementation was inspired by the `pairwiseSum` implementation in\n  the [`math-functions`](https://hackage.haskell.org/package/math-functions-0.3.4.2/docs/src/Numeric.Sum.html#pairwiseSum)\n  Haskell package. The notes above were adapted from that function's docs.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(aJb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(TDb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(Mub,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null))),$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns a lazy sequence of all intermediate values seen while aggregating\n  either `xs` or `(map f (range low high))` using the fold dynamically bound\n  to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (scan inc 0 3))\n  ;;\x3d\x3e ([1.0 1 1] [3.0 1 2] [6.0 1 3])\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null)),$APP.Cx,$APP.M(null,null)],null)],null))],[new $APP.f(null,3,[$APP.Q,dVb,$APP.X,jL,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,
KV,BY],null))],null)],null),new $APP.f(null,3,[$APP.Q,$gb,$APP.X,HQ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns the result of aggregating either `xs` or `(map f (range low\n  high))` using the fold dynamically bound to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (sum inc 0 10))\n  ;;\x3d\x3e [55.0 1 10]\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null))],null)],null),new $APP.f(null,3,[$APP.Q,d6b,$APP.X,P_,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[monoid]] for types with invertible elements. Accepts:\n\n  - binary `minus` and (associative) `plus` functions\n  - a unary `negate` function\n  - an element `id` that obeys `(plus id other) \x3d\x3d (plus other id) \x3d\x3d other`\n  - optionally, an `annihilate?` function that should return true for any `x`\n    such that `(plus x \x3cany\x3e) \x3d\x3d x`.\n\n  And returns a function that will SUBTRACT elements. Given `x`, `y`, `z`, for\n  example, the returned function will return `(- x y z)`, implemented as `(minus\n  x (plus y z))`\n\n  If the `annihilate?` function is supplied, then if the aggregation produces a\n  value that returns `(annihilate? true)` at any point, the reduction will\n  return immediately.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[GT,tT,jX,$APP.wx],null),new $APP.H(null,5,5,$APP.I,[GT,tT,jX,$APP.wx,VV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Hmb,$APP.X,QTa,$APP.h,new $APP.f(null,2,[$APP.P,"NOTE that the returned function recurs on increasing indices internally instead\n  of walking through the lists directly. This method of traversing vectors is\n  more efficient, and this function is called so often that the performance gain\n  is worth it, and reads almost like the explicit sequence traversal.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[$APP.vw,$APP.iT,$APP.Cv,iU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Jgb,$APP.X,O_,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a binary (associative) aggregation function `plus` and an identity\n  element `id` and returns a multi-arity function that will combine its\n  arguments via `plus`. A 0-arity call returns `id`.\n\n  optionally takes an `annihilate?` function that should return true for any `x`\n  such that `(plus x \x3cany\x3e) \x3d\x3d x`.\n\n  If the `annihilate?` function is supplied, then if the aggregation produces a\n  value that returns `(annihilate? true)` at any point, the reduction will\n  return immediately.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[tT,$APP.wx],null),new $APP.H(null,3,5,$APP.I,[tT,$APP.wx,VV],null))],null)],null),new $APP.f(null,3,[$APP.Q,etb,$APP.X,N_,$APP.h,new $APP.f(null,2,[$APP.P,"Given a vector of numbers, returns the [pairwise\n  summation](https://en.wikipedia.org/wiki/Pairwise_summation) of the vector\n  generated by arranging the vector into a binary tree and summing leaves\n  together all the way up to the root.\n\n  If `xs` is _not_ a vector, [[pairwise-sum]] will realize all elements into a\n  vector before operating.\n\n  If the initial vector, or some recursive slice, reaches a count\n  \x3c\x3d [[*cutoff*]], [[pairwise-sum]] defers to `(reduce + xs)`.\n\n  ### Performance Discussion\n\n  [[pairwise-sum]] is perhaps 10% faster than [[sum]]\n  with [[emmy.algebra.fold/kbn]] bound to [[*fold*]], but has poorer bounds\n  on its error growth. Instead of having roughly constant error regardless of\n  the size of the input, in the worst case its accumulated error grows with\n  $O(\\log n)$.\n\n  This improvement is due to the fact that [[pairwise-sum]] tends to add up\n  numbers of similar magnitude, instead of adding deltas into a progressively\n  larger sum.\n\n  This implementation was inspired by the `pairwiseSum` implementation in\n  the [`math-functions`](https://hackage.haskell.org/package/math-functions-0.3.4.2/docs/src/Numeric.Sum.html#pairwiseSum)\n  Haskell package. The notes above were adapted from that function's docs.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null))],null)],null),new $APP.f(null,3,[$APP.Q,hPb,$APP.X,FI,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Hzb,$APP.X,128,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,W_b,$APP.X,DI,$APP.h,new $APP.f(null,2,[$APP.P,"Takes either:\n\n  - a series `xs` of numbers\n  - A transformation function `f`, an inclusive-lower bound `low` and\n    exclusive-upper bound `upper`\n\n  And returns a lazy sequence of all intermediate values seen while aggregating\n  either `xs` or `(map f (range low high))` using the fold dynamically bound\n  to [[*fold*]].\n\n  Use `binding` to substitute in a different fold:\n\n  ```clj\n  (require '[emmy.algebra.fold :as af])\n\n  (binding [*fold* (af/join af/kahan af/min af/max)]\n    (scan inc 0 3))\n  ;;\x3d\x3e ([1.0 1 1] [3.0 1 2] [6.0 1 3])\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,KV,BY],null))],null)],null)]),$APP.ap(L6b)),$APP.cp($APP.fg([$APP.z(Rrb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.f(null,1,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[KT,uX,Shb],null)],null)],null))),$APP.P,"Returns a fn that returns true if any of the following are true::\n\n  - the supplied `fn-counter` atom contains a value \x3e `maxfun`\n  - the loop has exceeded `maxiter` iterations\n\n  false otherwise.\n  "],
null)),$APP.z(fT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.f(null,1,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[Ikb,btb,lnb],null)],null)],null))),$APP.P,"Returns a fn that returns true if any of the following are true:\n\n  - the max interior value is within `fn-tolerance` of the smallest bound,\n  - `convergence?` (if supplied) returns true\n  - the bounds are within `arg-tolerance` absolute distance,\n\n  false otherwise."],null)),$APP.z(Sab,new $APP.f(null,2,
[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Nab,ATb],null))),$APP.P,"Returns the point between `from` and `to` that cuts the region between the two\n  into two sections in golden-ratioed proportion to each other.\n\n  For example, depending on the ordering of `from` and `to`, `x` would be\n  either:\n\n  ```\n  from------x1---to\n  to---x2------from\n  ```\n\n  Such that `from-\x3ex1 / from-\x3eto \x3d\x3d to-\x3ex2 / from-\x3ex1`."],null)),$APP.z(BOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,2,5,$APP.I,[YX,$APP.Gw],null),$APP.Ml,new $APP.f(null,2,[YX,kW,$APP.Gw,$APP.M($APP.fw,null)],null),$APP.dk,$APP.Ox],null)],null))),$APP.P,"Golden Section search attempts to locate the minimum of the supplied function\n  `f` by evaluating points located at golden-ratioed intervals between the two\n  starting endpoints `a` and `b`. This method is slow, steady and reliable.\n\n  Supports the following optional keyword arguments:\n\n  `:converged?` is an optional predicate accepting five arguments:\n\n  - `[a fa]`\n  - `[l fl]`\n  - `[r fr]`\n  - `[b fb]`\n  - `current-iteration`\n\n  If the supplied `fn` returns true, it will signal convergence and the\n  optimizer will return. Returning false will continue.\n\n  `:choose` is called at the final step of optimization with all 4 points and\n  their fn values (see the first four arguments to `:converged?`), and returns\n  the final choice.\n\n  `:callback` receives all 5 arguments on every iteration.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n\n  `:fn-tolerance` check that the minimal value of any of the checked points is\n  within the maximum of f(a) or f(b).\n\n  `:arg-tolerance` check that `a` and `b` are within this supplied absolute\n  distance.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,2,5,$APP.I,[YX,$APP.Gw],null),$APP.Ml,new $APP.f(null,2,[YX,kW,$APP.Gw,$APP.M($APP.fw,null)],null),$APP.dk,$APP.Ox],null)],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,
2,5,$APP.I,[YX,$APP.Gw],null),$APP.Ml,new $APP.f(null,2,[YX,kW,$APP.Gw,$APP.M($APP.fw,null)],null),$APP.dk,$APP.Ox],null)],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(ZR,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(MAb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(kW,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Tbc],null))),$APP.P,"Default selection function for the best possible point. This function chooses\n  the point out of (a, l, r, b) with the minimum function value.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(Tbc)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Tbc],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(TOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,$APP.Ox],null))),$APP.P,"For convenience, we also provide the sister-procedure for finding\n  the maximum of a unimodal function using the golden section method.\n\n  Negate the function, minimize, negate the result.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,4,$APP.qw,4,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,$APP.Ox],null)],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,$APP.Ox],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(nVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,yHb],null))),$APP.P,"generate a new point by extending x away from `away-from`. The invariant is\n  that `x` sits between the new point and `away-from` at the golden ratio\n  point."],
null)),$APP.z(vdc,new $APP.f(null,1,[$APP.Nw,!0],null))],[new $APP.f(null,3,[$APP.Q,gVb,$APP.X,G7a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a fn that returns true if any of the following are true::\n\n  - the supplied `fn-counter` atom contains a value \x3e `maxfun`\n  - the loop has exceeded `maxiter` iterations\n\n  false otherwise.\n  ",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.f(null,1,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[KT,uX,Shb],null)],null)],null))],null)],null),new $APP.f(null,
3,[$APP.Q,dLb,$APP.X,E7a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a fn that returns true if any of the following are true:\n\n  - the max interior value is within `fn-tolerance` of the smallest bound,\n  - `convergence?` (if supplied) returns true\n  - the bounds are within `arg-tolerance` absolute distance,\n\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.f(null,1,[$APP.Bu,new $APP.H(null,3,5,$APP.I,[Ikb,btb,lnb],null)],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,
aXb,$APP.X,tQ,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the point between `from` and `to` that cuts the region between the two\n  into two sections in golden-ratioed proportion to each other.\n\n  For example, depending on the ordering of `from` and `to`, `x` would be\n  either:\n\n  ```\n  from------x1---to\n  to---x2------from\n  ```\n\n  Such that `from-\x3ex1 / from-\x3eto \x3d\x3d to-\x3ex2 / from-\x3ex1`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[Nab,ATb],null))],null)],null),new $APP.f(null,
3,[$APP.Q,f9b,$APP.X,U3,$APP.h,new $APP.f(null,2,[$APP.P,"Golden Section search attempts to locate the minimum of the supplied function\n  `f` by evaluating points located at golden-ratioed intervals between the two\n  starting endpoints `a` and `b`. This method is slow, steady and reliable.\n\n  Supports the following optional keyword arguments:\n\n  `:converged?` is an optional predicate accepting five arguments:\n\n  - `[a fa]`\n  - `[l fl]`\n  - `[r fr]`\n  - `[b fb]`\n  - `current-iteration`\n\n  If the supplied `fn` returns true, it will signal convergence and the\n  optimizer will return. Returning false will continue.\n\n  `:choose` is called at the final step of optimization with all 4 points and\n  their fn values (see the first four arguments to `:converged?`), and returns\n  the final choice.\n\n  `:callback` receives all 5 arguments on every iteration.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before exiting.\n  Defaults to 1000.\n\n  `:fn-tolerance` check that the minimal value of any of the checked points is\n  within the maximum of f(a) or f(b).\n\n  `:arg-tolerance` check that `a` and `b` are within this supplied absolute\n  distance.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,new $APP.f(null,3,[$APP.Bu,new $APP.H(null,2,5,$APP.I,[YX,$APP.Gw],null),$APP.Ml,new $APP.f(null,2,[YX,kW,$APP.Gw,$APP.M($APP.fw,null)],null),$APP.dk,$APP.Ox],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,$yb,$APP.X,y7a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,bOb,$APP.X,w7a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,zJb,$APP.X,T3,$APP.h,new $APP.f(null,2,[$APP.P,"Default selection function for the best possible point. This function chooses\n  the point out of (a, l, r, b) with the minimum function value.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,Tbc],null))],null)],null),new $APP.f(null,3,[$APP.Q,mdc,$APP.X,V3,$APP.h,new $APP.f(null,2,[$APP.P,"For convenience, we also provide the sister-procedure for finding\n  the maximum of a unimodal function using the golden section method.\n\n  Negate the function, minimize, negate the result.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Nv,RW,SW],null),new $APP.H(null,4,5,$APP.I,[$APP.Nv,RW,SW,$APP.Ox],null))],null)],null),new $APP.f(null,3,[$APP.Q,
neb,$APP.X,uQ,$APP.h,new $APP.f(null,2,[$APP.P,"generate a new point by extending x away from `away-from`. The invariant is\n  that `x` sits between the new point and `away-from` at the golden ratio\n  point.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,yHb],null))],null)],null),new $APP.f(null,3,[$APP.Q,mwb,$APP.X,x7a,$APP.h,$APP.F],null)]),$APP.ap(rkb)),$APP.cp(new $APP.f(null,8,[$APP.z(JMb,new $APP.f(null,1,[$APP.Nw,!0],null)),new $APP.f(null,3,[$APP.Q,C9b,$APP.X,eTa,$APP.h,$APP.F],null),
$APP.z(Wbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))),$APP.P,"Used as a [data reader](https://www.clojurescript.org/guides/reader#_clojurescript_compilation).\n  In Clojure, we could get away with just using the constructor above, but in\n  ClojureScript we need to act as a macro to delay evaluation of the constructor."],null)),new $APP.f(null,3,[$APP.Q,Jhb,$APP.X,sTa,$APP.h,new $APP.f(null,2,[$APP.P,"Used as a [data reader](https://www.clojurescript.org/guides/reader#_clojurescript_compilation).\n  In Clojure, we could get away with just using the constructor above, but in\n  ClojureScript we need to act as a macro to delay evaluation of the constructor.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))],null)],null),$APP.z(Irb,new $APP.f(null,1,[$APP.Nw,!0],null)),new $APP.f(null,3,[$APP.Q,l0b,$APP.X,gTa,$APP.h,$APP.F],null),$APP.z(EU,new $APP.f(null,1,[$APP.Nw,!0],null)),new $APP.f(null,3,[$APP.Q,psb,$APP.X,pG,$APP.h,$APP.F],null),$APP.z(fY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null))),$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,wG,$APP.X,yG,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null))],null)],null),$APP.z(jlb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise."],null)),new $APP.f(null,3,[$APP.Q,Sdb,$APP.X,xG,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],
null)],null),$APP.z(o5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.VP],null))),$APP.P,"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values. (Note: the use of cast-to-double is\n   unfortunate here, as complex numbers can now contain exact fractions, and\n   we'd want a nearest integer generic function for those)"],null)),
new $APP.f(null,3,[$APP.Q,tNb,$APP.X,tTa,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values. (Note: the use of cast-to-double is\n   unfortunate here, as complex numbers can now contain exact fractions, and\n   we'd want a nearest integer generic function for those)",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.VP],
null))],null)],null),$APP.z(opb,new $APP.f(null,1,[$APP.Nw,!0],null)),new $APP.f(null,3,[$APP.Q,Exb,$APP.X,anc,$APP.h,$APP.F],null)],null),$APP.ap(Egb)),$APP.cp($APP.fg([$APP.z(Qlb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null))),$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(qW,$APP.Yw,qS)],null),$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(kgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[XV,zU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(KFb,XV,zU)],null)],null)))),$APP.P,"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components-\x3evector-field\n     (up x y)\n     (coordinate-system-\x3evector-basis R2-rect)))\n  ;; \x3d\x3e (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field-\x3ebasis-components]]"],
null)),$APP.z(acc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[gNb],null))),$APP.P,"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!"],null)),$APP.z(X3a,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))),$APP.P,"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0."],
null)),$APP.z(y8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hx,tW],null))),$APP.P,"Given a vector field `vf` generated from [[basis-components-\x3evector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis-\x3edual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system-\x3evector-basis coordsys)\n        dual  (basis/vector-basis-\x3edual basis coordsys)]\n    (\x3d basis-components\n       (-\x3e basis-components\n           (basis-components-\x3evector-field basis)\n           (vector-field-\x3ebasis-components dual))))\n  ```"],
null)),$APP.z(ndc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.hx,qW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(eV,$APP.hx)],null)],null)))),$APP.P,"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field-\x3ecomponents f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;\x3d\x3e (up (f↑0 (up x0 y0))\n  ;;       (f↑1 (up x0 y0)))\n  ```"],
null)),$APP.z(R5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hx,qW],null))),$APP.P,"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`."],null)),$APP.z(eV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.hx],null))),$APP.P,"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise."],null)),$APP.z(dnb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null))),$APP.P,"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(Iib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied."],
null)),$APP.z(n8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,qW],null))),$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3evector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument."],
null))],[new $APP.f(null,3,[$APP.Q,p_b,$APP.X,$O,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.",$APP.U,$APP.M(new $APP.H(null,
4,5,$APP.I,[qW,$APP.Yw,$APP.Lh,qS],null))],null)],null),new $APP.f(null,3,[$APP.Q,yYb,$APP.X,$3a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components-\x3evector-field\n     (up x y)\n     (coordinate-system-\x3evector-basis R2-rect)))\n  ;; \x3d\x3e (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field-\x3ebasis-components]]",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[XV,zU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(KFb,XV,zU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,N5b,$APP.X,d4a,$APP.h,new $APP.f(null,2,[$APP.P,"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[gNb],null))],null)],null),new $APP.f(null,3,[$APP.Q,
Mxb,$APP.X,W3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vub,$APP.X,a4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a vector field `vf` generated from [[basis-components-\x3evector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis-\x3edual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system-\x3evector-basis coordsys)\n        dual  (basis/vector-basis-\x3edual basis coordsys)]\n    (\x3d basis-components\n       (-\x3e basis-components\n           (basis-components-\x3evector-field basis)\n           (vector-field-\x3ebasis-components dual))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hx,tW],null))],null)],null),new $APP.f(null,3,[$APP.Q,CVb,$APP.X,V3a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field-\x3ecomponents f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;\x3d\x3e (up (f↑0 (up x0 y0))\n  ;;       (f↑1 (up x0 y0)))\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.hx,qW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(eV,$APP.hx)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,BTb,$APP.X,c4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.hx,qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,sec,$APP.X,WO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.hx],null))],null)],null),new $APP.f(null,3,[$APP.Q,lQb,$APP.X,ZO,$APP.h,new $APP.f(null,2,[$APP.P,"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[XV,qW],null),new $APP.H(null,3,5,$APP.I,[XV,qW,$APP.Yw],null))],null)],null),new $APP.f(null,3,[$APP.Q,NX,$APP.X,aP,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field \x3ccoordinate-system\x3e 'ignored-name)\n  ```\n\n  With no indices supplied.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,Yzb,$APP.X,Y3a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components-\x3evector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,qW],null))],null)],null)]),$APP.ap(TYb)),$APP.cp($APP.fg([r2b,$APP.z(DYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[FW,$S],null))),$APP.P,"Takes an operator symbol `op` and an identity element `constant` and returns a\n  rule that turns binary forms with `constant` on either side into `constant`.\n\n  This rule is useful for commutative annihilators like:\n\n  ```clojure\n  (* 0 \x3canything\x3e) \x3d\x3e 0\n  (and false \x3canything\x3e) \x3d\x3e false\n  (or true \x3canything\x3e) \x3d\x3e true\n  ```"],
null)),Dnb,Ycc,$APP.z(C8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))),$APP.P,"Returns a rule simplifier of rules that are almost always helpful."],null)),$APP.z($APP.Kw,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(dcb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null)))],null)),Occ,$APP.z(gEb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,
[$APP.Lh,eS],null))),$APP.P,"Returns a simplifier that will remove consecutive duplicate arguments to any\n  of the operations supplied as `ops`. Acts as identity otherwise.\n\n  ```clojure\n  (let [rule (idempotent 'and)]\n    (\x3d '(and a b c d)\n       (rule '(and a b b c c c d))))\n  ```",$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(eS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null)),$APP.Cx,$APP.M(null)],null)],null)),
$APP.z(epb,new $APP.f(null,1,[$APP.im,!0],null)),eTb,$APP.z(kAb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),Umb,Bxb,G0b,WZb,ssb,$APP.z(xAb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(WAb,new $APP.f(null,1,[$APP.im,!0],null)),qnb,$APP.z(DSb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(VVb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))),$APP.P,
"Simplifications for various exponent forms (assuming commutative multiplication).\n\n  NOTE that we have some similarities to [[exponent-contract]] above - that\n  function works for non-commutative multiplication - AND that this needs a new\n  name."],null)),TXb,$APP.z(cyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))),$APP.P,"TODO consolidate the symbolic checkers here with the constructor\n  simplifications in [[trig:special]]. "],null)),$APP.z(MKb,new $APP.f(null,
1,[$APP.im,!0],null)),$APP.z(nQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null)))],null)),$APP.z(Bfb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[FW,$S],null))),$APP.P,"Takes an operator symbol `op` and an identity element `constant` and returns a\n  rule that eliminates instances of `constant` inside any-arity forms like\n\n  ```clojure\n  (\x3cop\x3e ,,,args,,,)\n  ```"],null)),wJb,$APP.z(pQb,new $APP.f(null,1,[$APP.im,!0],null)),
$APP.z(Hlb,new $APP.f(null,1,[$APP.im,!0],null)),Flb,khb,$APP.z(Gmb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null)))],null)),wbb,$APP.z(Wdc,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z($bc,new $APP.f(null,1,[$APP.im,!0],null)),q7b,$APP.z(BMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))),$APP.P,"Returns a rule simplifier that attempts to simplify nested exp and log forms.\n\n  You can tune the behavior of this simplifier with [[*log-exp-simplify?*]]\n  and [[*sqrt-expt-simplify?*]].\n\n  NOTE: [[logexp]] returns a `rule-simplifier`, which memoizes its traversal\n  through the supplied expression. This means that if you try to\n  customize [[logexp]] with dynamic binding variables AFTER passing an\n  expression into it, you may get a memoized result which used the previous\n  dynamic binding.\n\n  This is a problem we should address!"],
null)),gHb,$APP.z(JTb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null))),$APP.P,"Takes any number of operator symbols `ops` like `'+`, `'*` and returns a rule\n  that sorts the argument list of any multiple-arity call to any of the supplied\n  operators. Sorting is accomplished with [[emmy.expression/sort]].\n\n  For example:\n\n  ```clojure\n  (let [rule (commutative '* '+)]\n    (\x3d '(* 2 3 a b c (+ c a b))\n       (rule '(* c a b (+ c a b) 3 2))))\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(eS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(e1b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.wx],null),new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.wx],null))),$APP.P,"Takes one or two simplified expressions `x` and `y` and a symbolic identifier\n  `id` and registers an assumption that both sides are non-negative.\n\n  Returns the conjuction of both assumptions in the two argument case, or the\n  single assumption in the one-argument case.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.wx],null),new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.wx],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.wx],null),new $APP.H(null,3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.wx],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(xQb,new $APP.f(null,1,[$APP.im,!0],null)),CK,jhb,$APP.z(wLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[bS],null))),$APP.P,"Returns a rule simplifier that distributes the radical sign across products and\n  quotients. The companion rule [[sqrt-contract]] reassembles what remains.\n\n  NOTE that doing this may allow equal subexpressions within the radicals to\n  cancel in various ways.\n\n  Turn this simplifier on and off with [[*sqrt-factor-simplify?*]]."],null)),tnb,Mcb,$APP.z(Mmb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null)))],null)),$APP.z(fSb,
new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null)))],null)),$APP.z(S1b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(SYb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(Wlb,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(Hjb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(Sac,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],
null)))],null)),$APP.z(MWb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null)))],null)),o1b,$APP.z(C3b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null))),$APP.P,"Takes a sequence `ops` of operator symbols like `'+`, `'*` and returns a rule\n  that strips these operations off of unary applications.\n\n  ```clojure\n  (let [rule (unary-elimination '+ '*)\n        f    (rule-simplifier rule)]\n    (f '(+ x y (* z) (+ a))))\n  ;;\x3d\x3e (+ x y z a)\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(eS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null)),$APP.Cx,$APP.M(null)],null)],null)),Q$b,$APP.z($APP.IAa,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),XKb,$APP.z(v7b,new $APP.f(null,1,[$APP.im,!0],null)),$APP.z(SMb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null)))],null)),$APP.z(fnb,new $APP.f(null,
3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null))),$APP.P,"Takes any number of operator symbols `ops` like `'+`, `'*` and returns a rule\n  that collapses nested applications of each operation into a single\n  sequence. (The associative property lets us strip parentheses.)\n\n  ```clojure\n  (let [rule (associative '+ '*)\n        f    (rule-simplifier rule)]\n    (\x3d (+ x y z a (* b c d) cake face)\n       (f '(+ x (+ y (+ z a) (* b (* c d))\n                   (+ cake face))))))\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M(eS)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null)),$APP.Cx,$APP.M(null)],null)],null))],[new $APP.f(null,3,[$APP.Q,Edc,$APP.X,Epc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Y2b,$APP.X,function(a,b){return wJ.C($APP.y([mJ(xJ.A(new $APP.D(null,a,new $APP.D(null,$APP.Kv,new $APP.D(null,b,null,1,null),2,null),3,null),zJ),function(){return $APP.k(b)?b:fJ(b)}),mJ(xJ.A(new $APP.D(null,
a,new $APP.D(null,b,new $APP.D(null,$APP.Kv,null,1,null),2,null),3,null),zJ),function(){return $APP.k(b)?b:fJ(b)})]))},$APP.h,new $APP.f(null,2,[$APP.P,"Takes an operator symbol `op` and an identity element `constant` and returns a\n  rule that turns binary forms with `constant` on either side into `constant`.\n\n  This rule is useful for commutative annihilators like:\n\n  ```clojure\n  (* 0 \x3canything\x3e) \x3d\x3e 0\n  (and false \x3canything\x3e) \x3d\x3e false\n  (or true \x3canything\x3e) \x3d\x3e true\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[FW,$S],null))],null)],null),new $APP.f(null,3,[$APP.Q,csb,$APP.X,k1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,C6b,$APP.X,m1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,N4b,$APP.X,nZa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule simplifier of rules that are almost always helpful.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vib,$APP.X,uYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,e0b,$APP.X,iZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Bgb,$APP.X,Ipc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,cnb,$APP.X,d2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a simplifier that will remove consecutive duplicate arguments to any\n  of the operations supplied as `ops`. Acts as identity otherwise.\n\n  ```clojure\n  (let [rule (idempotent 'and)]\n    (\x3d '(and a b c d)\n       (rule '(and a b b c c c d))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null))],null)],null),new $APP.f(null,3,[$APP.Q,p$b,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,seb,$APP.X,X0a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Jtb,$APP.X,xYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,vEb,$APP.X,Apc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Nwb,$APP.X,e1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,oMb,$APP.X,Bpc,
$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,wSb,$APP.X,Fpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,ddb,$APP.X,h1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,hNb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Okb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,V7b,$APP.X,Jpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,OFb,$APP.X,sYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mac,$APP.X,
IYa,$APP.h,new $APP.f(null,2,[$APP.P,"Simplifications for various exponent forms (assuming commutative multiplication).\n\n  NOTE that we have some similarities to [[exponent-contract]] above - that\n  function works for non-commutative multiplication - AND that this needs a new\n  name.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,nWb,$APP.X,g1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,yib,$APP.X,hZa,$APP.h,new $APP.f(null,2,[$APP.P,"TODO consolidate the symbolic checkers here with the constructor\n  simplifications in [[trig:special]]. ",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,XPb,$APP.X,!1,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,iQb,$APP.X,WYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,HLb,$APP.X,zYa,$APP.h,new $APP.f(null,2,[$APP.P,"Takes an operator symbol `op` and an identity element `constant` and returns a\n  rule that eliminates instances of `constant` inside any-arity forms like\n\n  ```clojure\n  (\x3cop\x3e ,,,args,,,)\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[FW,$S],null))],null)],null),new $APP.f(null,3,[$APP.Q,WDb,$APP.X,c1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,eHb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,kZb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,erb,$APP.X,Dpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Oib,$APP.X,Hpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,ZEb,$APP.X,gZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],
null),new $APP.f(null,3,[$APP.Q,PIb,$APP.X,ypc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,KEb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,w_b,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,H4b,$APP.X,b1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,efb,$APP.X,CYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule simplifier that attempts to simplify nested exp and log forms.\n\n  You can tune the behavior of this simplifier with [[*log-exp-simplify?*]]\n  and [[*sqrt-expt-simplify?*]].\n\n  NOTE: [[logexp]] returns a `rule-simplifier`, which memoizes its traversal\n  through the supplied expression. This means that if you try to\n  customize [[logexp]] with dynamic binding variables AFTER passing an\n  expression into it, you may get a memoized result which used the previous\n  dynamic binding.\n\n  This is a problem we should address!",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,V_b,$APP.X,jZa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,t9b,$APP.X,c2,$APP.h,new $APP.f(null,2,[$APP.P,"Takes any number of operator symbols `ops` like `'+`, `'*` and returns a rule\n  that sorts the argument list of any multiple-arity call to any of the supplied\n  operators. Sorting is accomplished with [[emmy.expression/sort]].\n\n  For example:\n\n  ```clojure\n  (let [rule (commutative '* '+)]\n    (\x3d '(* 2 3 a b c (+ c a b))\n       (rule '(* c a b (+ c a b) 3 2))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null))],null)],null),new $APP.f(null,3,[$APP.Q,vkb,$APP.X,TJ,$APP.h,new $APP.f(null,2,[$APP.P,"Takes one or two simplified expressions `x` and `y` and a symbolic identifier\n  `id` and registers an assumption that both sides are non-negative.\n\n  Returns the conjuction of both assumptions in the two argument case, or the\n  single assumption in the one-argument case.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.wx],null),new $APP.H(null,
3,5,$APP.I,[$APP.Yv,$APP.UP,$APP.wx],null))],null)],null),new $APP.f(null,3,[$APP.Q,o_b,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,LYb,$APP.X,mZa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Pib,$APP.X,Gpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,tLb,$APP.X,QYa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rule simplifier that distributes the radical sign across products and\n  quotients. The companion rule [[sqrt-contract]] reassembles what remains.\n\n  NOTE that doing this may allow equal subexpressions within the radicals to\n  cancel in various ways.\n\n  Turn this simplifier on and off with [[*sqrt-factor-simplify?*]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,MGb,$APP.X,zpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Hnb,$APP.X,a1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,qJb,$APP.X,function(a){function b(d){var g=a.j?a.j(d):a.call(null,d),l=GJ.A;g=$APP.r(new $APP.H(null,2,5,$APP.I,[tM,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Iv,pH,g,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,4,pH,$APP.r(new $APP.H(null,2,5,$APP.I,[dT,$APP.r(new $APP.H(null,3,5,$APP.I,
[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,pH,g],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,4,pH],null))],null))],null))],null))],null))],null));l=l.call(GJ,g?g:fJ(g),mob);return $APP.k(l)?(d=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Iv,1,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,d],null))],null)),2],null))],null)))?d:fJ(d):l}function c(d){var g=a.j?a.j(d):a.call(null,d),l=GJ.A;g=$APP.r(new $APP.H(null,2,5,
$APP.I,[tM,$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Iv,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,2,pH],null)),$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,-1,g],null)),$APP.r(new $APP.H(null,4,5,$APP.I,[$APP.Hv,4,pH,$APP.r(new $APP.H(null,2,5,$APP.I,[dT,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.sj,g,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Hv,4,pH],null))],null))],null))],null))],null))],null));l=l.call(GJ,g?g:fJ(g),VGb);return $APP.k(l)?(d=$APP.r(new $APP.H(null,2,5,$APP.I,[HJ,$APP.r(new $APP.H(null,
3,5,$APP.I,[$APP.sj,$APP.r(new $APP.H(null,3,5,$APP.I,[$APP.Jv,1,$APP.r(new $APP.H(null,2,5,$APP.I,[uH,d],null))],null)),2],null))],null)))?d:fJ(d):l}return pJ(rJ(function(){return!0},AJ.C($APP.y([wJ.C($APP.y([mJ(xJ.j(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,1,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,EJ,new $APP.D(null,DT,null,1,null),2,null),3,null),4,null),null,1,null),2,null)),function(d){d=$APP.r($APP.N.A(new $APP.H(null,
2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(d):EJ.call(null,d)],null),DT.j?DT.j(d):DT.call(null,d)));return c(d?d:fJ(d))}),mJ(xJ.j(new $APP.D(null,mH,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,EJ,new $APP.D(null,2,null,1,null),2,null),3,null),null,1,null),2,null)),function(d){return c(d.j?d.j(EJ):d.call(null,EJ))}),mJ(xJ.j(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.Hv,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,1,new $APP.D(null,2,null,1,null),2,null),3,null),new $APP.D(null,
EJ,new $APP.D(null,DT,null,1,null),2,null),3,null),4,null),null,1,null),2,null)),function(d){d=$APP.r($APP.N.A(new $APP.H(null,2,5,$APP.I,[$APP.Hv,EJ.j?EJ.j(d):EJ.call(null,d)],null),DT.j?DT.j(d):DT.call(null,d)));return b(d?d:fJ(d))}),mJ(xJ.j(new $APP.D(null,uH,new $APP.D(null,new $APP.D(null,$APP.sj,new $APP.D(null,EJ,new $APP.D(null,2,null,1,null),2,null),3,null),null,1,null),2,null)),function(d){return b(d.j?d.j(EJ):d.call(null,EJ))})]))]))))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,P6b,$APP.X,LYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,FTb,$APP.X,sJ,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,stb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,jxb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,nqb,$APP.X,wYa,$APP.h,new $APP.f(null,1,[$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,C2b,$APP.X,kZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,bsb,$APP.X,XYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,Hdb,$APP.X,l1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,rlb,$APP.X,a2,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a sequence `ops` of operator symbols like `'+`, `'*` and returns a rule\n  that strips these operations off of unary applications.\n\n  ```clojure\n  (let [rule (unary-elimination '+ '*)\n        f    (rule-simplifier rule)]\n    (f '(+ x y (* z) (+ a))))\n  ;;\x3d\x3e (+ x y z a)\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null))],null)],null),new $APP.f(null,3,[$APP.Q,P4b,$APP.X,i1a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Xgb,$APP.X,tYa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,njb,$APP.X,Cpc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,ASb,$APP.X,!0,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,gWb,$APP.X,lZa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,
[bS],null))],null)],null),new $APP.f(null,3,[$APP.Q,M9b,$APP.X,b2,$APP.h,new $APP.f(null,2,[$APP.P,"Takes any number of operator symbols `ops` like `'+`, `'*` and returns a rule\n  that collapses nested applications of each operation into a single\n  sequence. (The associative property lets us strip parentheses.)\n\n  ```clojure\n  (let [rule (associative '+ '*)\n        f    (rule-simplifier rule)]\n    (\x3d (+ x y z a (* b c d) cake face)\n       (f '(+ x (+ y (+ z a) (* b (* c d))\n                   (+ cake face))))))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,eS],null))],null)],null)]),$APP.ap(hGb)),$APP.cp($APP.fg([$APP.z(NFb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if x is an integral number that Clojure's math operations work\n  with, false otherwise."],null)),$APP.z(OJb,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,$APP.F],null),$APP.Ov,$APP.F,gU,$APP.M("@interface")],null)),$APP.z(pzb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[Q8b],null)))],null)),$APP.z(Uqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,0,$APP.qw,0,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Ou)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null)),$APP.Cx,$APP.M(null)],null)],null)),$APP.z(JWb,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,$APP.F],null),$APP.Ov,$APP.F,gU,$APP.M("@interface")],
null)),$APP.z(JHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is either an integral number or a floating point number (i.e.,\n  in the numeric tower but not complex), false otherwise."],null)),$APP.z(Vgb,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,new $APP.f(null,1,[$APP.z($V,new $APP.f(null,1,[$APP.P,null],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Su],null)],null)],null)],null),$APP.Ov,
new $APP.f(null,1,[p3b,new $APP.f(null,3,[$APP.Q,$V,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Su],null)),$APP.P,null],null)],null),gU,$APP.M("@interface")],null)),$APP.z(VLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if x is an integral number, false otherwise."],null)),$APP.z(pkb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(wwb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,
"Returns a predicate that returns true if its argument matches the supplied\n  kind-keyword `k`, false otherwise."],null)),$APP.z(hbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(sxb,new $APP.f(null,1,[$APP.tj,$APP.py],null))],null))),$APP.P,"Returns a function that tests whether two values are within ε of each other."],null)),$APP.bw,$tb,$APP.z($APP.vw,new $APP.f(null,3,[$APP.tj,$APP.$u,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],
null))),$APP.P,"Comparator. Clone of [[cljs.core/compare]] that works with the expanded\n      Emmy numeric tower.\n\n  Returns a negative number, zero, or a positive number when x is logically\n  'less than', 'equal to', or 'greater than' y. Uses IComparable if available\n  and google.array.defaultCompare for objects of the same type and special-cases\n  nil to be less than any other object."],null)),$APP.z(rob,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[RFb],null)))],
null)),$APP.z(Vac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Qr],null))),$APP.P,"Mutates the native JS object `o` to have the given metadata. The\n       previous metadata, if any, is discarded. `o` is returned."],null)),$APP.z(oyb,new $APP.f(null,4,[$APP.Pm,gvb,$APP.tj,$APP.zv,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved."],
null)),$APP.z(fxb,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,new $APP.f(null,1,[$APP.z(oyb,new $APP.f(null,2,[$APP.tj,$APP.zv,$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Yv],
null)],null)],null)],null),$APP.Ov,new $APP.f(null,1,[cac,new $APP.f(null,3,[$APP.Q,$APP.z(oyb,new $APP.f(null,1,[$APP.tj,$APP.zv],null)),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)),$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved."],null)],null),gU,
$APP.M("@interface")],null)),$APP.z(kWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.vU],null))),$APP.P,"Make s callable. This is done by re-hosting all of the object properties of `s`\n      in a new native JS function which delegates to the Clojure application. The\n      result of the application of this new function is supplied to the continuation `k`."],null)),$APP.z($APP.Ux,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],
null))),$APP.P,"Returns true if `x` is any number type in the numeric tower:\n\n  - integral\n  - floating point\n  - complex\n  - fraction\n\n  false otherwise."],null)),$APP.z(dzb,new $APP.f(null,1,[$APP.Nw,!0],null)),$APP.z(H$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true for anything that derives from `::scalar`, i.e., any numeric type in\n  the numeric tower that responds true to [[number?]], plus symbolic expressions\n  generated by [[emmy.abstract.number/literal-number]],\n\n  false otherwise."],
null)),$APP.z($V,new $APP.f(null,3,[$APP.Pm,NY,$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Su],null)))],null))],[new $APP.f(null,3,[$APP.Q,$Lb,$APP.X,function(a){return $APP.xd(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if x is an integral number that Clojure's math operations work\n  with, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,kJb,$APP.X,function(){},$APP.h,$APP.F],null),new $APP.f(null,
3,[$APP.Q,xmb,$APP.X,HSa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Q8b],null))],null)],null),new $APP.f(null,3,[$APP.Q,Qnb,$APP.X,LP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lh,$APP.Ou],null))],null)],null),new $APP.f(null,3,[$APP.Q,Zrb,$APP.X,CSa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,u1b,$APP.X,FF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is either an integral number or a floating point number (i.e.,\n  in the numeric tower but not complex), false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,NY,$APP.X,CF,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,IPb,$APP.X,EF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if x is an integral number, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,RXb,$APP.X,LF,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,HVb,$APP.X,FSa,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a predicate that returns true if its argument matches the supplied\n  kind-keyword `k`, false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,wXb,$APP.X,KF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that tests whether two values are within ε of each other.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.z(sxb,new $APP.f(null,1,[$APP.tj,$APP.py],null))],null))],null)],null),new $APP.f(null,3,[$APP.Q,w5b,$APP.X,hG,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,dMb,$APP.X,GSa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,$mb,$APP.X,
JF,$APP.h,new $APP.f(null,2,[$APP.P,"Comparator. Clone of [[cljs.core/compare]] that works with the expanded\n      Emmy numeric tower.\n\n  Returns a negative number, zero, or a positive number when x is logically\n  'less than', 'equal to', or 'greater than' y. Uses IComparable if available\n  and google.array.defaultCompare for objects of the same type and special-cases\n  nil to be less than any other object.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null))],null)],null),new $APP.f(null,
3,[$APP.Q,Zkb,$APP.X,ISa,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[RFb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Rhb,$APP.X,ESa,$APP.h,new $APP.f(null,2,[$APP.P,"Mutates the native JS object `o` to have the given metadata. The\n       previous metadata, if any, is discarded. `o` is returned.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Tv,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,Fqb,$APP.X,BF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is a purely numerical value and should be considered for\n   numerical simplifications, such as $x * 1 \x3d\x3d x$ or $x * 0 \x3d\x3d\n   0$.\n\n  [[numerical?]] should return `false` if `x` has additional, non-numerical\n   structure that should be preserved.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,gvb,$APP.X,BSa,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,hRb,$APP.X,function(a,b){var c=function(){function v(A){var B=null;if(0<arguments.length){B=0;for(var G=Array(arguments.length-0);B<G.length;)G[B]=arguments[B+0],++B;B=new $APP.Bc(G,0,null)}return t.call(this,B)}function t(A){A=$APP.Je.A(a,A);return b.j?b.j(A):b.call(null,A)}v.G=0;v.M=function(A){A=$APP.r(A);return t(A)};v.C=t;return v}();
Object.setPrototypeOf(c,Object.getPrototypeOf(a));for(var d=$APP.r(Object.getOwnPropertyNames(a)),g=null,l=0,n=0;;)if(n<l){var p=g.aa(null,n);c[p]=$APP.Na(a,p);n+=1}else if(d=$APP.r(d))g=d,$APP.pd(g)?(d=$APP.lc(g),n=$APP.mc(g),g=d,l=$APP.Tc(d),d=n):(d=$APP.u(g),c[d]=$APP.Na(a,d),d=$APP.w(g),g=null,l=0),n=0;else break;d=$APP.r(Object.getOwnPropertySymbols(a));g=null;for(n=l=0;;)if(n<l)p=g.aa(null,n),c[p]=$APP.Na(a,p),n+=1;else if(d=$APP.r(d))g=d,$APP.pd(g)?(d=$APP.lc(g),n=$APP.mc(g),g=d,l=$APP.Tc(d),
d=n):(d=$APP.u(g),c[d]=$APP.Na(a,d),d=$APP.w(g),g=null,l=0),n=0;else break;return c},$APP.h,new $APP.f(null,2,[$APP.P,"Make s callable. This is done by re-hosting all of the object properties of `s`\n      in a new native JS function which delegates to the Clojure application. The\n      result of the application of this new function is supplied to the continuation `k`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Vv,$APP.vU],null))],null)],null),new $APP.f(null,3,[$APP.Q,wqb,$APP.X,GF,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if `x` is any number type in the numeric tower:\n\n  - integral\n  - floating point\n  - complex\n  - fraction\n\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ylb,$APP.X,$R,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,ERb,$APP.X,IF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true for anything that derives from `::scalar`, i.e., any numeric type in\n  the numeric tower that responds true to [[number?]], plus symbolic expressions\n  generated by [[emmy.abstract.number/literal-number]],\n\n  false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,lbb,$APP.X,DF,$APP.h,new $APP.f(null,2,[$APP.P,null,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Su],null))],null)],null)]),$APP.ap(krb)),$APP.cp(new $APP.f(null,6,[$APP.z(eib,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[bY],null)))],null)),new $APP.f(null,3,[$APP.Q,SAb,$APP.X,function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null);b=$APP.x.B(b,2,null);
var g=$APP.x.B(b,0,null);b=$APP.x.B(b,1,null);var l=D9a(function(n){n=wL.C($APP.y([c,d,wL.C($APP.y([g,n]))]));return a.j?a.j(n):a.call(null,n)});return l.j?l.j(b):l.call(null,b)}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[bY],null))],null)],null),$APP.z(kUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Hdc],null)))],null)),new $APP.f(null,3,[$APP.Q,QXb,$APP.X,function(a){return function(b,c,d){return function(g){function l(p){var v=$APP.x.B(p,
0,null),t=$APP.x.B(p,1,null);p=$APP.x.B(p,2,null);var A=wL.C;t=wL.C($APP.y([b.j?b.j(v):b.call(null,v),t]));var B=wL.C;var G=UO.j?UO.j(b):UO.call(null,b);G=G.j?G.j(v):G.call(null,v);v=A.call(wL,$APP.y([v,t,B.call(wL,$APP.y([G,p]))]));return a.j?a.j(v):a.call(null,v)}function n(p){var v=$APP.x.B(p,0,null),t=$APP.x.B(p,1,null);p=$APP.x.B(p,2,null);v=wL.C($APP.y([v,wL.C($APP.y([t,c.j?c.j(v):c.call(null,v)])),wL.C($APP.y([p,d.j?d.j(v):d.call(null,v)]))]));return a.j?a.j(v):a.call(null,v)}return wL.C($APP.y([function(){var p=
w4.j(n);p=p.j?p.j(b):p.call(null,b);return p.j?p.j(g):p.call(null,g)}(),function(){var p=A9a(l)(c,d);return p.j?p.j(g):p.call(null,g)}()]))}}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Hdc],null))],null)],null),$APP.z(pXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null),new $APP.H(null,2,5,$APP.I,[$APP.IU,xY],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,
[$APP.IU],null),new $APP.H(null,2,5,$APP.I,[$APP.IU,xY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null),new $APP.H(null,2,5,$APP.I,[$APP.IU,xY],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,P7b,$APP.X,G4,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null),new $APP.H(null,2,5,$APP.I,[$APP.IU,xY],null))],null)],null),$APP.z(aac,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null),new $APP.H(null,
2,5,$APP.I,[$APP.IU,xY],null))),$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.IU],null),new $APP.H(null,2,5,$APP.I,[$APP.IU,xY],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null),new $APP.H(null,2,5,$APP.I,[$APP.IU,xY],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,w4b,$APP.X,$APP.H4,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null),new $APP.H(null,
2,5,$APP.I,[$APP.IU,xY],null))],null)],null),$APP.z(Jac,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null)))],null)),new $APP.f(null,3,[$APP.Q,vsb,$APP.X,function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null),g=$APP.x.B(b,2,null);g=$APP.x.B(g,0,null);var l=$APP.x,n=l.A;var p=SQ.j?SQ.j(2):SQ.call(null,2);p=p.j?p.j(a):p.call(null,a);b=p.j?p.j(b):p.call(null,b);b=n.call(l,b,1);return wL.C($APP.y([c,d,wL.C($APP.y([g,b]))]))}},$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.FU],null))],null)],null),$APP.z(yKb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null)))],null)),new $APP.f(null,3,[$APP.Q,MQb,$APP.X,function(a){return function(b){var c=$APP.x.B(b,0,null),d=$APP.x.B(b,1,null),g=$APP.x.B(b,2,null);g=$APP.x.B(g,0,null);var l=$APP.x,n=l.A;var p=SQ.j?SQ.j(2):SQ.call(null,2);p=p.j?p.j(a):p.call(null,a);b=p.j?p.j(b):p.call(null,b);b=n.call(l,b,1);return wL.C($APP.y([c,d,wL.C($APP.y([g,
b]))]))}},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.IU],null))],null)],null)],null),$APP.ap(b0b)),$APP.cp($APP.fg([$APP.z(Ccc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))),$APP.P,"Returns the value of `P(x)`, where `P` is rational function fit (using the\n  Bulirsch-Stoer algorithm, of similar style to Neville's algorithm described in\n  [[emmy.numerical.interpolate.polynomial]]) to every point in the supplied\n  sequence `points`.\n\n  `points`: is a sequence of pairs of the form `[x (f x)]`.\n\n  \"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  References:\n\n    - Stoer \x26 Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)"],
null)),$APP.z(lBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-bulirsch-stoer]]."],
null)),$APP.z(jNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[modified-bulirsch-stoer]] xs x)`."],
null)),$APP.z(L_b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.uS,$APP.Yv,$APP.nv],null))),$APP.P,"Takes\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  `P(x)` is rational function fit (using the Bulirsch-Stoer algorithm, of\n  similar style to Neville's algorithm described\n  in [[emmy.numerical.interpolate.polynomial]]) to every point in the\n  supplied sequence `points`.\n\n  \"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  ### Column\n\n  If you supply an integer for the third (optional) `column` argument,\n  `bulirsch-stoer` will return that /column/ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  polynomial approximations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of 2-point approximations\n  between pairs of points; `2` gives 3-point approximations between successive\n  triplets, etc.\n\n  References:\n\n    - Stoer \x26 Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.uS,$APP.Yv,$APP.nv],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.uS,$APP.Yv,$APP.nv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($Jb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[bulirsch-stoer]] xs x)`."],
null)),$APP.z(I0b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Yv,eX],null)],null)))],null)),$APP.z(VQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[bulirsch-stoer]]."],
null)),$APP.z(xzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[bulirsch-stoer]] xs x))`"],null)),$APP.z(OPb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null)))],null)),$APP.z(Odb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[modified-bulirsch-stoer]] xs x))`"],
null)),$APP.z(Q4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))),$APP.P,"Similar to [[bulirsch-stoer]] (the interface is identical) but slightly more\n  efficient. Internally this builds up its estimates by tracking the delta from\n  the previous estimate.\n\n  This non-obvious change lets us swap an addition in for a division,\n  making the algorithm slightly more efficient.\n\n  See [[bulirsch-stoer]] for usage information, and info about the required\n  structure of the arguments.\n\n  References:\n\n   - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)"],
null))],[new $APP.f(null,3,[$APP.Q,ucb,$APP.X,o0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the value of `P(x)`, where `P` is rational function fit (using the\n  Bulirsch-Stoer algorithm, of similar style to Neville's algorithm described in\n  [[emmy.numerical.interpolate.polynomial]]) to every point in the supplied\n  sequence `points`.\n\n  `points`: is a sequence of pairs of the form `[x (f x)]`.\n\n  \"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  References:\n\n    - Stoer \x26 Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,s6b,$APP.X,u0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-bulirsch-stoer]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ccc,$APP.X,v0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[modified-bulirsch-stoer]] xs x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,T6b,$APP.X,L2,$APP.h,new $APP.f(null,2,[$APP.P,"Takes\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  `P(x)` is rational function fit (using the Bulirsch-Stoer algorithm, of\n  similar style to Neville's algorithm described\n  in [[emmy.numerical.interpolate.polynomial]]) to every point in the\n  supplied sequence `points`.\n\n  \"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  ### Column\n\n  If you supply an integer for the third (optional) `column` argument,\n  `bulirsch-stoer` will return that /column/ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  polynomial approximations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of 2-point approximations\n  between pairs of points; `2` gives 3-point approximations between successive\n  triplets, etc.\n\n  References:\n\n    - Stoer \x26 Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null),new $APP.H(null,3,5,$APP.I,[$APP.uS,$APP.Yv,$APP.nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,sjb,$APP.X,function(a){return GI.j(t0a(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[bulirsch-stoer]] xs x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,EMb,$APP.X,p0a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Yv,eX],null)],null))],null)],null),new $APP.f(null,3,[$APP.Q,Nqb,$APP.X,t0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[bulirsch-stoer]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,s2b,$APP.X,function(a){return G_.j(t0a(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[bulirsch-stoer]] xs x))`",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,vMb,$APP.X,q0a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,NCb,$APP.X,function(a){return G_.j(u0a(a))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[modified-bulirsch-stoer]] xs x))`",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,tVb,$APP.X,function(a,b){return jXa(BI(CI(r0a,s0a(b),a)))},$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[bulirsch-stoer]] (the interface is identical) but slightly more\n  efficient. Internally this builds up its estimates by tracking the delta from\n  the previous estimate.\n\n  This non-obvious change lets us swap an addition in for a division,\n  making the algorithm slightly more efficient.\n\n  See [[bulirsch-stoer]] for usage information, and info about the required\n  structure of the arguments.\n\n  References:\n\n   - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.uS,$APP.Yv],null))],null)],null)]),$APP.ap(whb)),$APP.cp($APP.fg([$APP.z(ueb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null)))),$APP.P,"Extract the dual basis from the given basis object `b`."],null)),$APP.z(VCb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,tW],null))),$APP.P,"Make a basis object out of a vector and dual basis.\n\n  The dimensions of `vector-basis` and `dual-basis` must agree."],
null)),$APP.z(WX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is a basis, false otherwise."],null)),$APP.z(klb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null)))),$APP.P,"Extract the dimension from the given basis object `b`."],null)),$APP.z(vjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[wsb,DMb],null))),$APP.P,"Returns the Jacobian of transition from `from-basis` to `to-basis`.\n\n  The Jacobian is a structure of manifold functions. The outer index is the\n  from-basis index, so this structure can be multiplied by tuple of component\n  functions of a vector field relative to `from-basis` to get component\n  functions for a vector field in `to-basis`."],null)),$APP.z(QS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,
"Returns true if `x` is a coordinate basis, false otherwise."],null)),$APP.z(lsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null)))),$APP.P,"Extract the vector basis from the given basis object `b`."],null)),$APP.z(Ivb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,
[$APP.M(QS,$APP.sU)],null)],null))))],null)),$APP.z(XSb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,VU],null)))],null)),$APP.z(Akb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[VU,wW],null)))],null)),$APP.z(jgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),$APP.P,"Returns the standard basis object for `coordinate-system`."],null)),$APP.z(onb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[zU,qW],null)))],null))],[new $APP.f(null,3,[$APP.Q,reb,$APP.X,oP,$APP.h,new $APP.f(null,2,[$APP.P,"Extract the dual basis from the given basis object `b`.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,W$b,$APP.X,N4a,$APP.h,new $APP.f(null,2,[$APP.P,"Make a basis object out of a vector and dual basis.\n\n  The dimensions of `vector-basis` and `dual-basis` must agree.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,tW],null))],null)],null),new $APP.f(null,3,[$APP.Q,GWb,$APP.X,O4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is a basis, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kub,$APP.X,P4a,$APP.h,new $APP.f(null,2,[$APP.P,"Extract the dimension from the given basis object `b`.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,
1,5,$APP.I,[$APP.M(WX,$APP.sU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,dQb,$APP.X,S4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the Jacobian of transition from `from-basis` to `to-basis`.\n\n  The Jacobian is a structure of manifold functions. The outer index is the\n  from-basis index, so this structure can be multiplied by tuple of component\n  functions of a vector field relative to `from-basis` to get component\n  functions for a vector field in `to-basis`.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[wsb,DMb],null))],null)],null),new $APP.f(null,3,[$APP.Q,V1b,$APP.X,K4a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is a coordinate basis, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,zdb,$APP.X,pP,$APP.h,new $APP.f(null,2,[$APP.P,"Extract the vector basis from the given basis object `b`.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,
[$APP.M(WX,$APP.sU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,dOb,$APP.X,L4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.sU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(QS,$APP.sU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Tdc,$APP.X,rP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,c8b,$APP.X,R4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[VU,wW],null))],null)],null),new $APP.f(null,3,[$APP.Q,ogb,$APP.X,nP,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the standard basis object for `coordinate-system`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ctb,$APP.X,Q4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[zU,qW],null))],null)],null)]),$APP.ap(Ozb)),$APP.cp($APP.fg([$APP.z(P9b,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[nW],
null)))],null)),$APP.z(APb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))),$APP.P,"Returns a lazy sequence of every possible arrangement of the elements of `xs`."],null)),$APP.z(ppb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[Xdb,$APP.ix],null))),$APP.P,"Given a `permutation` (represented as a list of numbers), and a sequence `xs`\n  to be permuted, construct the list so permuted."],null)),$APP.z(iyb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.ix],null))),$APP.P,"Given a sequence `xs` and a map `m` of replacement indices, returns a new\n  version of `xs` with the element at the position marked by each key in `m`\n  replaced by the element at each value in the original `xs`."],null)),$APP.z(r$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M($APP.cw,$APP.wU,0),
$APP.M($APP.cw,$APP.vU,0)],null)],null)))),$APP.P,"Returns the number of possible ways of choosing a multiset with cardinality `k`\n  from a set of `n` items, where each item is allowed to be chosen multiple\n  times."],null)),$APP.z(oHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[nW,nV],null))),$APP.P,"Given a `permuted-list` and the `original-list`, returns the number of\n  interchanges required to generate the permuted list from the original list."],null)),$APP.z(HDb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hra],null))),$APP.P,"Accepts a sequence of collections `colls` and returns a lazy sequence of the\n  cartesian product of all collections.\n\n  The cartesian product of N collections is a sequences of sequences, each `N`\n  long, of every possible way of choosing `N` items where the first comes from\n  the first entry in `colls`, the second from the second entry and so on.\n\n  NOTE: This implementation comes from Alan Malloy at this [StackOverflow\n  post](https://stackoverflow.com/a/18248031). Thanks, Alan!"],
null)),$APP.z(Omb,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,4,[YE,"null",nS,"null",wX,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,3,[nS,"null",wX,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,10,5,$APP.I,[$APP.wv,$APP.Lv,Bbb,$APP.Tv,uQb,$APP.wU,mVb,mRb,$APP.Mv,Ofb],null))),$APP.P,"Positional factory function for emmy.util.permute/t_emmy$util$permute49436."],null)),$APP.z(sMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
3,5,$APP.I,[Emb,nyb,fX],null))),$APP.P,"cont \x3d (fn [ulist slist perm iperm] ...)\n\n  Given a short list and a comparison function, to sort the list by the\n  comparison, returning the original list, the sorted list, the permutation\n  procedure and the inverse permutation procedure developed by the sort."],null)),$APP.z(D8b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.cw,
$APP.wU,0)],null)],null)))),$APP.P,"Returns 'n choose k', the number of possible ways of choosing `k` distinct\n  elements from a collection of `n` total items."],null)),$APP.z(jSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),$APP.P,"Returns the number of possible ways of permuting a collection of `n` distinct\n  elements."],null)),$APP.z(uMb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mVb],null))),$APP.P,"Produces an iterable sequence developing the permutations of the input sequence\n  of objects (which are considered distinct) in church-bell-changes order - that\n  is, each permutation differs from the previous by a transposition of adjacent\n  elements (Algorithm P from §7.2.1.2 of Knuth).\n\n  This is an unusual way to go about this in a functional language, but it's\n  fun.\n\n  This approach has the side-effect of arranging for the parity of the generated\n  permutations to alternate; the first permutation yielded is the identity\n  permutation (which of course is even).\n\n  Inside, there is a great deal of mutable state, but this cannot be observed by\n  the user."],
null)),$APP.z(MLb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[nW],null),new $APP.H(null,2,5,$APP.I,[nW,nV],null))),$APP.P,"If a single `permuted-list` is supplied, returns the parity of the number of\n  interchanges required to sort the permutation.\n\n  NOTE that the requirement that elements be sortable currently constrains\n  `permuted-list`'s elements to be numbers that respond to `\x3e\x3d`.\n\n  For two arguments, given a `permuted-list` and the `original-list`, returns\n  the parity (1 for even, -1 for odd) of the number of the number of\n  interchanges required to generate the permuted list from the original list.\n\n  In the two-argument case, if the two lists aren't permutations of each other,\n  returns 0.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[nW],null),new $APP.H(null,2,5,$APP.I,[nW,nV],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nW],null),new $APP.H(null,2,5,$APP.I,[nW,nV],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(vIb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Sv],null))),$APP.P,"Returns a lazy sequence of every possible set of `p` elements chosen from\n  `xs`."],
null))],[new $APP.f(null,3,[$APP.Q,J4b,$APP.X,f4a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nW],null))],null)],null),new $APP.f(null,3,[$APP.Q,UYb,$APP.X,function Csc(a){return $APP.hd(a)?$APP.M($APP.Ec):$APP.T.A($APP.Jl.A($APP.ip.j(function(c,d){return $APP.Vg.A(function(g){return $APP.Yd(d,g)},function(){var g=$APP.N.A($APP.We.A(c,a),$APP.Se.A(c+1,a));return Csc.j?Csc.j(g):Csc.call(null,g)}())}),$APP.eh),a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a lazy sequence of every possible arrangement of the elements of `xs`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,YBb,$APP.X,g4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a `permutation` (represented as a list of numbers), and a sequence `xs`\n  to be permuted, construct the list so permuted.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[Xdb,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,Skb,$APP.X,function(a,b){return $APP.Jd(function(c,d,g){return $APP.rg.B(c,d,$APP.C.A(b,g))},b,a)},$APP.h,new $APP.f(null,
2,[$APP.P,"Given a sequence `xs` and a map `m` of replacement indices, returns a new\n  version of `xs` with the element at the position marked by each key in `m`\n  replaced by the element at each value in the original `xs`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Qr,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,S$b,$APP.X,function(a,b){if(0===b)return 1;a=$0.A(a,b);b=HI(b);return SF.A?SF.A(a,b):SF.call(null,a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of possible ways of choosing a multiset with cardinality `k`\n  from a set of `n` items, where each item is allowed to be chosen multiple\n  times.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M($APP.cw,$APP.wU,0),$APP.M($APP.cw,$APP.vU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,a9b,$APP.X,e4a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a `permuted-list` and the `original-list`, returns the number of\n  interchanges required to generate the permuted list from the original list.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[nW,nV],null))],null)],null),
new $APP.f(null,3,[$APP.Q,Gac,$APP.X,AP,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a sequence of collections `colls` and returns a lazy sequence of the\n  cartesian product of all collections.\n\n  The cartesian product of N collections is a sequences of sequences, each `N`\n  long, of every possible way of choosing `N` items where the first comes from\n  the first entry in `colls`, the second from the second entry and so on.\n\n  NOTE: This implementation comes from Alan Malloy at this [StackOverflow\n  post](https://stackoverflow.com/a/18248031). Thanks, Alan!",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Hra],null))],null)],null),new $APP.f(null,3,[$APP.Q,WOb,$APP.X,l4a,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.util.permute/t_emmy$util$permute49436.",$APP.U,$APP.M(new $APP.H(null,10,5,$APP.I,[$APP.wv,$APP.Lv,Bbb,$APP.Tv,uQb,$APP.wU,mVb,mRb,$APP.Mv,Ofb],null))],null)],null),new $APP.f(null,3,[$APP.Q,rUb,$APP.X,function(a,b,c){function d(t){return g4a(v,t)}function g(t){return g4a(p,t)}var l=$APP.Tc(a),n=$APP.Vg.B($APP.ps,a,
$APP.Jj.j(l));b=$APP.Vs.B($APP.u,$APP.rda(b),n);n=$APP.Hl.A($APP.u,b);var p=$APP.Hl.A($APP.Xc,b),v=$APP.Vg.A(function(t){return j4a(p,t)},$APP.Jj.j(l));return c.K?c.K(a,n,g,d):c.call(null,a,n,g,d)},$APP.h,new $APP.f(null,2,[$APP.P,"cont \x3d (fn [ulist slist perm iperm] ...)\n\n  Given a short list and a comparison function, to sort the list by the\n  comparison, returning the original list, the sorted list, the permutation\n  procedure and the inverse permutation procedure developed by the sort.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[Emb,nyb,fX],null))],null)],null),new $APP.f(null,3,[$APP.Q,cHb,$APP.X,function(a,b){return a1(a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns 'n choose k', the number of possible ways of choosing `k` distinct\n  elements from a collection of `n` total items.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.vU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.cw,$APP.wU,0)],null)],null)))],null)],null),new $APP.f(null,
3,[$APP.Q,cib,$APP.X,function(a){return HI(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the number of possible ways of permuting a collection of `n` distinct\n  elements.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vyb,$APP.X,o4a,$APP.h,new $APP.f(null,2,[$APP.P,"Produces an iterable sequence developing the permutations of the input sequence\n  of objects (which are considered distinct) in church-bell-changes order - that\n  is, each permutation differs from the previous by a transposition of adjacent\n  elements (Algorithm P from §7.2.1.2 of Knuth).\n\n  This is an unusual way to go about this in a functional language, but it's\n  fun.\n\n  This approach has the side-effect of arranging for the parity of the generated\n  permutations to alternate; the first permutation yielded is the identity\n  permutation (which of course is even).\n\n  Inside, there is a great deal of mutable state, but this cannot be observed by\n  the user.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[mVb],null))],null)],null),new $APP.f(null,3,[$APP.Q,EOb,$APP.X,F3,$APP.h,new $APP.f(null,2,[$APP.P,"If a single `permuted-list` is supplied, returns the parity of the number of\n  interchanges required to sort the permutation.\n\n  NOTE that the requirement that elements be sortable currently constrains\n  `permuted-list`'s elements to be numbers that respond to `\x3e\x3d`.\n\n  For two arguments, given a `permuted-list` and the `original-list`, returns\n  the parity (1 for even, -1 for odd) of the number of the number of\n  interchanges required to generate the permuted list from the original list.\n\n  In the two-argument case, if the two lists aren't permutations of each other,\n  returns 0.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[nW],null),new $APP.H(null,2,5,$APP.I,[nW,nV],null))],null)],null),new $APP.f(null,3,[$APP.Q,N3b,$APP.X,E3,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a lazy sequence of every possible set of `p` elements chosen from\n  `xs`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.ix,$APP.Sv],null))],null)],null)]),$APP.ap(m4b)),$APP.cp($APP.fg([$APP.z(h_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.f(null,
1,[$APP.Bw,new $APP.H(null,3,5,$APP.I,[$APP.M(NU,yU),$APP.M(NU,$APP.Wv),$APP.M($APP.Iu,$APP.M(Bac,$APP.Wv))],null)],null)))),$APP.P,"Returns the pseudo-remainder of univariate polynomials `u` and `v`.\n\n  NOTE: Fractions won't appear in the result; instead the divisor is multiplied\n  by the leading coefficient of the dividend before quotient terms are generated\n  so that division will not result in fractions.\n\n  Returns a pair of\n\n  - the remainder\n  - the integerizing factor needed to make this happen.\n\n  Similar in spirit to Knuth's algorithm 4.6.1R, except we don't multiply the\n  remainder through during gaps in the remainder. Since you don't know up front\n  how many times the integerizing multiplication will be done, we also return\n  the number d for which d * u \x3d q * v + r."],
null)),$APP.z(uV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,DY],null))),$APP.P,"Accepts a [[Polynomial]] `p` and a sequence of symbols for each indeterminate,\n  and emits the canonical form of the symbolic expression that\n  represents [[Polynomial]] `p`.\n\n  A similar result could be achieved by calling `(apply p vars)`;\n  but [[Polynomial]] application uses [Horner's\n  rule](https://en.wikipedia.org/wiki/Horner%27s_method), and form of the\n  returned result will be different.\n\n  NOTE: this is the output stage of Flat Polynomial canonical form\n  simplification. The input stage is handled by [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]]."],
null)),$APP.z(KTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if the supplied argument is an instance of [[Polynomial]], false\n  otherwise."],null)),$APP.z($APP.Fac,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Mv],null))),$APP.P,"Given a polynomial `p`, returns a normalized polynomial generated by dividing\n  through either the [[leading-coefficient]] of `p` or an optional, explicitly\n  supplied scaling factor `c`.\n\n  For example:\n\n  ```clojure\n  (let [p (make [5 3 2 2 10])]\n    (univariate-\x3edense (normalize p)))\n  ;;\x3d\x3e [1/2 3/10 1/5 1/5 1]\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Mv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Mv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(qcc,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,10,[mU,"null",UW,"null",jU,"null",YE,"null",tS,"null",nS,"null",NY,"null",iV,"null",pT,"null",
TV,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aU,$Yb,$APP.Qr],null))),YR,new $APP.ug(null,new $APP.f(null,6,[mU,"null",UW,"null",tS,"null",nS,"null",iV,"null",pT,"null"],null),null),$APP.P,"Positional factory function for emmy.polynomial/Polynomial."],null)),$APP.z(vV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the cube of polynomial `p`. Equivalent to `(mul p (mul p p))`."],null)),$APP.z(AXb,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Similar to [[leading-coefficient]], but of the coefficient itself is\n  a [[Polynomial]], recurses down until it reaches a non-[[Polynomial]] lead\n  coefficient.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity."],null)),$APP.z(QYb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,RRb],null))),$APP.P,"Given a univariate [[Polynomial]] (see [[univariate?]]) returns a dense vector\n  of the coefficients of each term in ascending order.\n\n  For example:\n\n  ```clojure\n  (univariate-\x3edense (make [1 0 0 2 3 4]))\n  ;;\x3d\x3e [1 0 0 2 3 4]\n  ```\n\n  Supplying the second argument `x-degree` will pad the right side of the\n  returning coefficient vector to be the max of `x-degree` and `(degree x)`.\n\n  NOTE use [[lower-arity]] to generate a univariate polynomial in the first\n  indeterminate, given a multivariate polynomial.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,RRb],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,RRb],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(G7b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))),$APP.P,"Given two polynomials `u` and `v`, returns a pair of polynomials of the form\n  `[quotient, remainder]` using [polynomial long\n  division](https://en.wikipedia.org/wiki/Polynomial_long_division).\n\n  The contract satisfied by this returned pair is that\n\n  ```\n  u \x3d\x3d (add (mul quotient v) remainder)\n  ```"],
null)),$APP.z(KWb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(b5b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.VP],null),$APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Lv,$APP.VP,fX],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(NU,$APP.Lv),$APP.M($APP.Ux,$APP.VP)],null)],null)))),$APP.P,"Takes a univariate polynomial `a`, an argument `z` and a continuation\n  `cont` (`vector` by default) and calls the continuation with (SEE BELOW).\n\n  This Horner's rule evaluator is restricted to numerical coefficients and\n  univariate polynomials. It returns by calling `cont` with 4 arguments:\n\n  - the computed value\n  - the values of the first two derivatives\n  - an estimate of the roundoff error incurred in computing the value\n\n  The recurrences used are from Kahan's 18 Nov 1986 paper ['Roundoff in\n  Polynomial\n  Evaluation'](https://people.eecs.berkeley.edu/~wkahan/Math128/Poly.pdf),\n  generalized for sparse representations and another derivative by GJS.\n\n  For $p \x3d A(z)$, $q \x3d A'(z)$, $r \x3d A''(z)$, and $e$ \x3d error in $A(x)$,\n\n  $$p_{j+n} \x3d z^n p_j + a_{j+n}$$\n\n  $$e_{j+n} \x3d |z|^n ( e_j + (n-1) p_j ) + |p_{j+n}|$$\n\n  $$q_{j+n} \x3d z^n q_j + n z^{n-1} p_j$$\n\n  $$r_{j+n} \x3d z^n r_j + n z^{n-1} q_j + 1/2 n (n-1) z^{n-2} p_j$$",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.VP],null),new $APP.H(null,3,5,$APP.I,[$APP.Lv,$APP.VP,fX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.VP],null),new $APP.H(null,3,5,$APP.I,[$APP.Lv,$APP.VP,fX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(ZLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given a univariate polynomial `p`, returns a [[series/PowerSeries]]\n  representation of the supplied [[Polynomial]].\n\n  Given a [[series/PowerSeries]], acts as identity.\n\n  Non-[[Polynomial]] coefficients return [[series/PowerSeries]] instances\n  via [[series/constant]]; any multivariate [[Polynomial]] throws an exception.\n\n  NOTE use [[lower-arity]] to generate a univariate polynomial in the first\n  indeterminate, given a multivariate polynomial."],
null)),$APP.z(K7b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Sv,V8b],null))),$APP.P,"Given a [[Polynomial]], returns a new [[Polynomial]] instance generated by\n  applying `f` to the exponents of each term in `p` and filtering out all\n  resulting zeros. The resulting [[Polynomial]] will have either the\n  same [[arity]] as `p`, or the explicit, optional `new-arity` argument. (This\n  is because `f` might increase or decrease the total arity.)\n\n  Given a non-[[Polynomial]] coefficient, if `(f empty-exponents)` produces a\n  non-zero result, errors without an explicit `new-arity` argument..\n\n  NOTE that [[map-exponents]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Sv,V8b],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Sv,V8b],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z($S,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(Dhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Sv],null))),$APP.P,"Returns the coefficient of the leading (highest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity."],null)),$APP.z(rVb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))),$APP.P,"Returns the [degree](https://en.wikipedia.org/wiki/Degree_of_a_polynomial) of\n  the supplied polynomial.\n\n  the degree of a polynomial is the highest of the degrees of the polynomial's\n  individual terms with non-zero coefficients. The degree of an individual term\n  is the sum of all exponents in the term.\n\n  Optionally, [[degree]] takes an indeterminate index `i`; in this\n  case, [[degree]] returns the maximum power found for the `i`th indeterminate\n  across all terms.\n\n  NOTE when passed either a `0` or a zero-polynomial, [[degree]] returns -1. See\n  Wikipedia's ['degree of the zero\n  polynomial'](https://en.wikipedia.org/wiki/Degree_of_a_polynomial#Degree_of_the_zero_polynomial)\n  for color on why this is the case.\n  ",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(NU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `p` is a [[Polynomial]] of arity 1, false otherwise."],
null)),$APP.z(nvb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Lv],null))),$APP.P,"Given either a non-[[Polynomial]] coefficient or a univariate [[Polynomial]]\n  with possibly-[[Polynomial]] coefficients, returns a new [[Polynomial]] of\n  arity `a` generated by attaching the polynomial coefficients back as variables\n  starting with `1`.\n\n  [[raise-arity]] undoes the transformation of [[lower-arity]].\n  See [[with-lower-arity]] for a function that packages these two\n  transformations."],
null)),$APP.z($APP.LX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,xU],null))),$APP.P,"Returns the difference of polynomials `p` and `q`, with appropriate handling\n  for non-[[Polynomial]] coefficient inputs on either or both sides."],null)),$APP.z(dX,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z($APP.Ku,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"If the [[leading-coefficient]] of `p` is negative, returns `(negate p)`, else\n  acts as identity."],
null)),$APP.z(ZPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the sequence of partial derivatives of [[Polynomial]] `p` with respect\n  to each indeterminate. The returned sequence has length equal to the [[arity]]\n  of `p`.\n\n  For non-[[Polynomial]] inputs, returns an empty sequence."],null)),$APP.z(DIb,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[nS,"null",ZX,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,
2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[f0b],null))),$APP.P,"Positional factory function for emmy.polynomial/t_emmy$polynomial48683."],null)),$APP.z($APP.Fx,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[aU],null),$APP.z(new $APP.H(null,2,5,$APP.I,[aU,$APP.Rv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ko,$APP.M($APP.cw,$APP.Rv,0),$APP.M($APP.$v,$APP.Rv,aU))],null)],null)))),
$APP.P,"Generates a [[Polynomial]] instance representing a single indeterminate with\n  constant 1.\n\n  When called with no arguments, returns a monomial of arity 1 that acts as\n  identity in the first indeterminate.\n\n  The one-argument version takes an explicit `arity`, but still sets the\n  identity to the first indeterminate.\n\n  The two-argument version takes an explicit `i` and returns a monomial of arity\n  `arity` with an exponent of 1 in the `i`th indeterminate.",$APP.ky,new $APP.f(null,
6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[aU],null),new $APP.H(null,2,5,$APP.I,[aU,$APP.Rv],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[aU],null),new $APP.H(null,2,5,$APP.I,[aU,$APP.Rv],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(zbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Mv,$APP.Sv],null))),$APP.P,"Given some polynomial `p` and a coefficient `c`, returns a new [[Polynomial]]\n  generated by multiplying each coefficient of `p` by `c` (on the left).\n\n  See [[scale]] if right multiplication is important.\n\n  NOTE that [[scale-l]] will return a non-[[Polynomial]] if the result of the\n  mapping has only a constant term."],
null)),$APP.z(kS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))),$APP.P,"Given some [[Polynomial]] `p`, returns the partial derivative of `p` with\n  respect to the `i`th indeterminate. Throws if `i` is an invalid indeterminate\n  index for `p`.\n\n  For non-[[Polynomial]] inputs, returns `0`."],null)),$APP.z(Dpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `p` is a [[Polynomial]] of arity \x3e 1, false otherwise."],
null)),$APP.z(S4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given some [[Polynomial]] `p`, returns `p` without its [[leading-term]].\n  non-[[Polynomial]] `p` inputs are treated at constant polynomials and return\n  `0`.\n\n  NOTE that [[drop-leading-term]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term."],null)),$APP.z(YGb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(MVb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Given some [[Polynomial]], returns the `terms` entry of the type. Handles other types as well:\n\n  - Acts as identity on vectors, interpreting them as vectors of terms\n  - any zero-valued `p` returns `[]`\n  - any other coefficient returns a vector of a single constant term."],null)),$APP.z(iU,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[fbc],null),new $APP.H(null,2,5,$APP.I,[aU,L7b],null))),
$APP.P,"Generates a [[Polynomial]] instance (or a bare coefficient!) from either:\n\n  - a sequence of dense coefficients of a univariate polynomial (in ascending\n  order)\n  - an explicit `arity`, and a sparse mapping (or sequence of pairs) of exponent\n  \x3d\x3e coefficient\n\n  In the first case, the sequence is interpreted as a dense sequence of\n  coefficients of an arity-1 (univariate) polynomial. The coefficients begin\n  with the constant term and proceed to each higher power of the indeterminate.\n  For example, x^2 - 1 can be constructed by (make [-1 0 1]).\n\n  In the 2-arity case,\n\n  - `arity` is the number of indeterminates\n  - `expts-\x3ecoef` is a map of an exponent representation to a coefficient.\n\n  The `exponent` portion of the mapping can be any of:\n\n  - a proper exponent entry created by `emmy.polynomial.exponent`\n  - a map of the form `{variable-index, power}`\n  - a dense vector of variable powers, like `[3 0 1]` for $x^3z$. The length of\n    each vector should be equal to `arity`, in this case.\n\n  For example, any of the following would generate $4x^2y + 5xy^2$:\n\n  ```clojure\n  (make 2 [[[2 1] 4] [[1 2] 5]])\n  (make 2 {[2 1] 4, [1 2] 5})\n  (make 2 {{0 2, 1 1} 4, {0 1, 1 2} 5})\n  ```\n\n  NOTE: [[make]] will try and return a bare coefficient if possible. For\n  example, the following form will return a constant, since there are no\n  explicit indeterminates with powers \x3e 0:\n\n  ```clojure\n  (make 10 {{} 1 {} 2})\n  ;;\x3d\x3e 3\n  ```\n\n  See [[constant]] if you need an explicit [[Polynomial]] instance wrapping a\n  constant.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[fbc],null),new $APP.H(null,2,5,$APP.I,[aU,L7b],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[fbc],null),new $APP.H(null,2,5,$APP.I,[aU,L7b],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(FJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.wU],null))),$APP.P,"Returns a polynomial generated by raising the input polynomial `p` to\n  the (integer) power `n`.\n\n  Negative exponents are not supported. For negative polynomial exponentation,\n  see [[rational-function/expt]]."],
null)),$APP.z(RHb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aU,$APP.Rv,$APP.Qua],null))),$APP.P,"Given some `arity`, an indeterminate index `i` and some constant `root`,\n  returns a polynomial of the form `x_i - root`. The returned polynomial\n  represents a linear equation in the `i`th indeterminate.\n\n  If `root` is 0, [[linear]] is equivalent to the two-argument version\n  of [[identity]]."],null)),$APP.z(pAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.wU],null))),$APP.P,"Returns a sequence of `n` monomials of arity `n`, each with an exponent of `1`\n  for the `i`th indeterminate (where `i` matches the position in the returned\n  sequence)."],null)),$APP.z(Heb,new $APP.f(null,1,[$APP.Ru,!0],null)),YS,$APP.z(Zbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the lowest degree found across any term in the supplied [[Polynomial]].\n  If a non-[[Polynomial]] is supplied, returns either `0` or `-1` if the input\n  is itself a `0`.\n\n  See [[degree]] for a discussion of this `-1` case."],
null)),$APP.z(RX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the negation of polynomial `p`, i.e., a polynomial with all coefficients\n  negated."],null)),$APP.z(XZb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(CTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if the input `x` is explicitly _not_ an instance\n  of [[Polynomial]], false otherwise.\n\n  Equivalent to `(not (polynomial? x))`."],
null)),$APP.z(Pcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))),$APP.P,"Given some input `p` and an indeterminate index `i`, returns true if `0 \x3c\x3d i\n  \x3c (arity p)`, false otherwise."],null)),$APP.z(cT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the square of polynomial `p`. Equivalent to `(mul p p)`."],null)),$APP.z(B2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.ix],null))),$APP.P,"Given a sequence of points of the form `[x, f(x)]`, returns a univariate\n  polynomial that passes through each input point.\n\n  The degree of the returned polynomial is equal to `(dec (count xs))`."],null)),$APP.z(n4b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[aU,$APP.Mv,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.cw,$APP.wU,0)],null)],null)))),$APP.P,"Given some `arity`, a coefficient `c` and an exponent `n`, returns a monomial\n  representing $c{x_0}^n$. The first indeterminate is always exponentiated.\n\n  Similar to [[make]], this function attempts to drop down to scalar-land if\n  possible:\n\n  - If `c` is [[emmy.value/zero?]], returns `c`\n  - if `n` is `zero?`, returns `(constant arity c)`\n\n  NOTE that negative exponents are not allowed."],
null)),$APP.z(Jdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.lP],null))),$APP.P,"Returns true if the numerator `n` is evenly divisible by `d` (i.e., leaves no\n  remainder), false otherwise.\n\n  NOTE that this performs a full division with [[divide]]. If you're planning on\n  doing this, you may as well call [[divide]] and check that the remainder\n  satisfies [[emmy.value/zero?]]."],null)),$APP.z(Gjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Sv,$APP.wU],null))),$APP.P,"Returns true if `n` is a valid variable index for the [[Polynomial]] `p`, and\n  the variable with that index has no powers greater than `0` in `p`, false\n  otherwise."],null)),$APP.z(XSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.wU],null))),$APP.P,"If `p` is [[contractible?]] at index `n`, returns a new [[Polynomial]] instance\n  of [[arity]] `1` less than `p` with all variable indices \x3e `n` decremented.\n\n  For non-[[Polynomial]] inputs, acts as identity. Throws if `p` is not\n  explicitly [[contractible?]].\n\n  For example:\n\n  ```clojure\n  (\x3d (make 2 {[1 2] 3 [3 4] 5})\n     (contract\n       (make 3 {[0 1 2] 3 [0 3 4] 5}) 0))\n  ```"],
null)),$APP.z($APP.ry,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.wU],null))),$APP.P,"Interpolates a new variable into the supplied [[Polynomial]] `p` at index `n`\n  by incrementing any existing variable index \x3e\x3d `n`.\n\n  Returns a new [[Polynomial]] of [[arity]] 1 greater than the [[arity]] of `p`,\n  or equal to `(inc n)` if `n` is greater than the [[arity]] of `p`.\n\n  For non-[[Polynomial]] inputs (or negative `n`), acts as identity."],null)),
$APP.z(owb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[yU,$APP.Wv,HT],null))),$APP.P,"Given:\n\n  - multivariate [[Polynomial]]s `u` and `v`\n  - a `continue` function that accepts two univariate [[Polynomial]]s with\n    possibly-[[Polynomial]] coefficients,\n\n  Returns the result of calling [[lower-arity]] on `u` and `v`, passing the\n  results to `continue` and using [[raise-arity]] to raise the result back to\n  the original shared [[arity]] of `u` and `v`.\n\n  The exception is that if `continue` returns a\n  non-[[Polynomial]], [[with-lower-arity]] will not attempt to re-package it as\n  a [[Polynomial]]."],
null)),$APP.z(uCb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(fU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,oV],null),new $APP.f(null,1,[$APP.Bw,$APP.M($APP.bw,$APP.M(aU,$APP.Sv),$APP.M($APP.tv,oV))],null)))),$APP.P,"Given some [[Polynomial]] `p`, returns a new [[Polynomial]] generated by\n  substituting each indeterminate `x_i` for `f_i * x_i`, where `f_i` is a factor\n  supplied in the `factors` sequence.\n\n  When `p` is a multivariate [[Polynomial]], each factor must be either a\n  non-[[Polynomial]] or a [[Polynomial]] with the same [[arity]] as `p`."],
null)),$APP.z($APP.iT,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(wjb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the exponents of the leading (highest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, returns [[exponent/empty]]."],null)),$APP.z(HX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,AY],null),new $APP.f(null,1,[$APP.Bw,$APP.M($APP.bw,$APP.M(aU,
$APP.Sv),$APP.M($APP.tv,AY))],null)))),$APP.P,"Given some [[Polynomial]] `p`, returns a new [[Polynomial]] generated by\n  substituting each indeterminate `x_i` for `s_i + x_i`, where `s_i` is a shift\n  supplied in the `shifts` sequence.\n\n  When `p` is a multivariate [[Polynomial]], each shift must be either a\n  non-[[Polynomial]] or a [[Polynomial]] with the same [[arity]] as `p`."],null)),$APP.z($APP.kX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Mv],
null))),$APP.P,"Given some polynomial `p` and a coefficient `c`, returns a new [[Polynomial]]\n  generated by multiplying each coefficient of `p` by `c` (on the right).\n\n  See [[scale-l]] if left multiplication is important.\n\n  NOTE that [[scale]] will return a non-[[Polynomial]] if the result of the\n  mapping has only a constant term."],null)),$APP.z(aU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the declared arity of the supplied [[Polynomial]], or `0` for\n  non-polynomial arguments."],
null)),$APP.z(wOb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))),$APP.P,"Given a polynomial `p`, returns the [reciprocal\n  polynomial](https://en.wikipedia.org/wiki/Reciprocal_polynomial) with respect\n  to the `i`th indeterminate. `i` defaults to 0.\n\n  The reciprocal polynomial of `p` with respect to `i` is generated by\n\n  - treating the polynomial as univariate with respect to `i` and pushing all\n    other terms into the coefficients of the polynomial\n  - reversing the order of these coefficients\n  - flattening the polynomial out again\n\n  For example, note that the entries for the first indeterminate are reversed:\n\n  ```clojure\n  (\x3d (make 3 {[3 0 0] 5 [2 0 1] 2 [0 2 1] 3})\n     (reciprocal\n       (make 3 {[0 0 0] 5 [1 0 1] 2 [3 2 1] 3})))\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null)),$APP.Cx,$APP.M(null,null)],null)],null)),$APP.z(ifb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),$APP.P,"Returns the nth [Touchard\n  polynomial](https://en.wikipedia.org/wiki/Touchard_polynomials).\n\n  These are also called [Bell\n  polynomials](https://mathworld.wolfram.com/BellPolynomial.html) (in\n  Mathematica, implemented as `BellB`) or /exponential polynomials/."],
null)),$APP.z(zbb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns a sequence of the coefficients of the supplied polynomial `p`. A\n  coefficient is treated here as a monomial, and returns a sequence of itself.\n\n  If `p` is zero, returns an empty list."],null)),$APP.z(AX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if the [[leading-base-coefficient]] of `p`\n  is [[generic/negative?]], false otherwise."],
null)),$APP.z(cdb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `p` is either:\n\n  - a [[Polynomial]] instance with a single term, or\n  - a non-[[Polynomial]] coefficient,\n\n  false otherwise."],null)),$APP.z(pcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns the coefficient of the trailing (lowest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity."],
null)),$APP.z(SBb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Vv,xYb],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(Ygb,$APP.Vv)],null)],null)))),$APP.P,"Returns a univariate polynomial of all terms in the\n  supplied [[series/PowerSeries]] instance, up to (and including) order\n  `n-terms`.\n\n  ```clojure\n  (g/simplify\n    ((from-power-series series/exp-series 3) 'x))\n  ;; \x3d\x3e (+ (* 1/6 (expt x 3)) (* 1/2 (expt x 2)) x 1)\n  ```"],
null)),$APP.z(KX,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,fX],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,fX,kU],null))),$APP.P,"Converts the supplied symbolic expression `expr` into Flat Polynomial canonical\n  form (i.e., a [[Polynomial]] instance). `expr` should be a bare, unwrapped\n  expression built out of Clojure data structures.\n\n  Returns the result of calling continuation `cont` with the [[Polynomial]] and\n  the list of variables corresponding to each indeterminate in\n  the [[Polynomial]]. (`cont `defaults to `vector`).\n\n  The second optional argument `v-compare` allows you to provide a Comparator\n  between variables. Sorting indeterminates by `v-compare` will determine the\n  order of the indeterminates in the generated [[Polynomial]]. The list of\n  variables passed to `cont` will be sorted using `v-compare`.\n\n  Absorbing an expression with [[expression-\x3e]] and emitting it again\n  with [[-\x3eexpression]] will generate the canonical form of an expression, with\n  respect to the operations in the [[operators-known]] set.\n\n  This kind of simplification proceeds purely symbolically over the known Flat\n  Polynomial operations; other operations outside the arithmetic available in\n  polynomials over commutative rings should be factored out by an expression\n  analyzer (see [[emmy.expression.analyze/make-analyzer]]) before\n  calling [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,fX],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,fX,kU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,fX],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,fX,kU],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z(Tzb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `p` is a [monic\n  polynomial](https://en.wikipedia.org/wiki/Monic_polynomial), false otherwise.\n\n  A monic polynomial is a univariate polynomial with a leading coefficient that\n  responds `true` to [[emmy.value/one?]]. This means that any coefficient\n  that responds `true` to [[emmy.value/one?]] also qualifies as a monic\n  polynomial."],null)),$APP.z(E5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Sv],
null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(Dpb,$APP.Sv)],null)],null)))),$APP.P,"Given a multivariate [[Polynomial]] `p`, returns an equivalent\n  univariate [[Polynomial]] whose coefficients are polynomials of [[arity]]\n  equal to one less than the [[arity]] of `p`.\n\n  Use [[raise-arity]] to undo this transformation. See [[with-lower-arity]] for\n  a function that packages these two transformations.\n\n  NOTE that [[lower-arity]] will drop a coefficient down to a non-[[Polynomial]]\n  if the result of extracting the first variable leaves a constant term."],
null)),$APP.z($U,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,xU],null))),$APP.P,"Returns the product of polynomials `p` and `q`, with appropriate handling for\n  non-[[Polynomial]] coefficient inputs on either or both sides."],null))],[new $APP.f(null,3,[$APP.Q,l7b,$APP.X,q_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the pseudo-remainder of univariate polynomials `u` and `v`.\n\n  NOTE: Fractions won't appear in the result; instead the divisor is multiplied\n  by the leading coefficient of the dividend before quotient terms are generated\n  so that division will not result in fractions.\n\n  Returns a pair of\n\n  - the remainder\n  - the integerizing factor needed to make this happen.\n\n  Similar in spirit to Knuth's algorithm 4.6.1R, except we don't multiply the\n  remainder through during gaps in the remainder. Since you don't know up front\n  how many times the integerizing multiplication will be done, we also return\n  the number d for which d * u \x3d q * v + r.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,3,5,$APP.I,[$APP.M(NU,yU),$APP.M(NU,$APP.Wv),$APP.M($APP.Iu,$APP.M(Bac,$APP.Wv))],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,I3b,$APP.X,YL,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a [[Polynomial]] `p` and a sequence of symbols for each indeterminate,\n  and emits the canonical form of the symbolic expression that\n  represents [[Polynomial]] `p`.\n\n  A similar result could be achieved by calling `(apply p vars)`;\n  but [[Polynomial]] application uses [Horner's\n  rule](https://en.wikipedia.org/wiki/Horner%27s_method), and form of the\n  returned result will be different.\n\n  NOTE: this is the output stage of Flat Polynomial canonical form\n  simplification. The input stage is handled by [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,DY],null))],null)],null),new $APP.f(null,3,[$APP.Q,Scc,$APP.X,zL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied argument is an instance of [[Polynomial]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,h$b,$APP.X,A2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a polynomial `p`, returns a normalized polynomial generated by dividing\n  through either the [[leading-coefficient]] of `p` or an optional, explicitly\n  supplied scaling factor `c`.\n\n  For example:\n\n  ```clojure\n  (let [p (make [5 3 2 2 10])]\n    (univariate-\x3edense (normalize p)))\n  ;;\x3d\x3e [1/2 3/10 1/5 1/5 1]\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Mv],null))],null)],null),new $APP.f(null,3,[$APP.Q,aVb,$APP.X,yL,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.polynomial/Polynomial.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[aU,$Yb,$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,edc,$APP.X,QL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the cube of polynomial `p`. Equivalent to `(mul p (mul p p))`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,$3b,$APP.X,e_a,$APP.h,new $APP.f(null,2,[$APP.P,"Similar to [[leading-coefficient]], but of the coefficient itself is\n  a [[Polynomial]], recurses down until it reaches a non-[[Polynomial]] lead\n  coefficient.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,zFb,$APP.X,z2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a univariate [[Polynomial]] (see [[univariate?]]) returns a dense vector\n  of the coefficients of each term in ascending order.\n\n  For example:\n\n  ```clojure\n  (univariate-\x3edense (make [1 0 0 2 3 4]))\n  ;;\x3d\x3e [1 0 0 2 3 4]\n  ```\n\n  Supplying the second argument `x-degree` will pad the right side of the\n  returning coefficient vector to be the max of `x-degree` and `(degree x)`.\n\n  NOTE use [[lower-arity]] to generate a univariate polynomial in the first\n  indeterminate, given a multivariate polynomial.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,RRb],null))],null)],null),new $APP.f(null,3,[$APP.Q,pTb,$APP.X,SL,$APP.h,new $APP.f(null,2,[$APP.P,"Given two polynomials `u` and `v`, returns a pair of polynomials of the form\n  `[quotient, remainder]` using [polynomial long\n  division](https://en.wikipedia.org/wiki/Polynomial_long_division).\n\n  The contract satisfied by this returned pair is that\n\n  ```\n  u \x3d\x3d (add (mul quotient v) remainder)\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wqb,$APP.X,TL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of dividing the polynomial `u` by `v` (non-[[Polynomial]]\n  instances are allowed).\n\n  Throws an exception if the division leaves a remainder. Else, returns the\n  quotient.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,X6b,$APP.X,C2,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a univariate polynomial `a`, an argument `z` and a continuation\n  `cont` (`vector` by default) and calls the continuation with (SEE BELOW).\n\n  This Horner's rule evaluator is restricted to numerical coefficients and\n  univariate polynomials. It returns by calling `cont` with 4 arguments:\n\n  - the computed value\n  - the values of the first two derivatives\n  - an estimate of the roundoff error incurred in computing the value\n\n  The recurrences used are from Kahan's 18 Nov 1986 paper ['Roundoff in\n  Polynomial\n  Evaluation'](https://people.eecs.berkeley.edu/~wkahan/Math128/Poly.pdf),\n  generalized for sparse representations and another derivative by GJS.\n\n  For $p \x3d A(z)$, $q \x3d A'(z)$, $r \x3d A''(z)$, and $e$ \x3d error in $A(x)$,\n\n  $$p_{j+n} \x3d z^n p_j + a_{j+n}$$\n\n  $$e_{j+n} \x3d |z|^n ( e_j + (n-1) p_j ) + |p_{j+n}|$$\n\n  $$q_{j+n} \x3d z^n q_j + n z^{n-1} p_j$$\n\n  $$r_{j+n} \x3d z^n r_j + n z^{n-1} q_j + 1/2 n (n-1) z^{n-2} p_j$$",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.VP],null),$APP.z(new $APP.H(null,3,5,$APP.I,[$APP.Lv,$APP.VP,fX],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[$APP.M(NU,$APP.Lv),$APP.M($APP.Ux,$APP.VP)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,qeb,$APP.X,function(a){return TI(a)?a:g_a(a)?VI(z2.j(a)):zL(a)?yD("Only univariate polynomials can be converted to [[PowerSeries]].\n         Use [[polynomial/lower]] to generate a univariate."):j1.j(a)},$APP.h,new $APP.f(null,
2,[$APP.P,"Given a univariate polynomial `p`, returns a [[series/PowerSeries]]\n  representation of the supplied [[Polynomial]].\n\n  Given a [[series/PowerSeries]], acts as identity.\n\n  Non-[[Polynomial]] coefficients return [[series/PowerSeries]] instances\n  via [[series/constant]]; any multivariate [[Polynomial]] throws an exception.\n\n  NOTE use [[lower-arity]] to generate a univariate polynomial in the first\n  indeterminate, given a multivariate polynomial.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Yvb,$APP.X,jM,$APP.h,new $APP.f(null,2,[$APP.P,"Given a [[Polynomial]], returns a new [[Polynomial]] instance generated by\n  applying `f` to the exponents of each term in `p` and filtering out all\n  resulting zeros. The resulting [[Polynomial]] will have either the\n  same [[arity]] as `p`, or the explicit, optional `new-arity` argument. (This\n  is because `f` might increase or decrease the total arity.)\n\n  Given a non-[[Polynomial]] coefficient, if `(f empty-exponents)` produces a\n  non-zero result, errors without an explicit `new-arity` argument..\n\n  NOTE that [[map-exponents]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Sv],null),new $APP.H(null,3,5,$APP.I,[$APP.Nv,$APP.Sv,V8b],null))],null)],null),new $APP.f(null,3,[$APP.Q,fec,$APP.X,DL,$APP.h,new $APP.f(null,2,[$APP.P,"Given some coefficient `c`, returns a [[Polynomial]] instance with a single\n  constant term referencing `c`.\n\n  `arity` defaults to 1; supply it to set the arity of the\n  returned [[Polynomial]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[aU,$APP.Mv],
null))],null)],null),new $APP.f(null,3,[$APP.Q,Acc,$APP.X,IL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the coefficient of the leading (highest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,WIb,$APP.X,UL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the [degree](https://en.wikipedia.org/wiki/Degree_of_a_polynomial) of\n  the supplied polynomial.\n\n  the degree of a polynomial is the highest of the degrees of the polynomial's\n  individual terms with non-zero coefficients. The degree of an individual term\n  is the sum of all exponents in the term.\n\n  Optionally, [[degree]] takes an indeterminate index `i`; in this\n  case, [[degree]] returns the maximum power found for the `i`th indeterminate\n  across all terms.\n\n  NOTE when passed either a `0` or a zero-polynomial, [[degree]] returns -1. See\n  Wikipedia's ['degree of the zero\n  polynomial'](https://en.wikipedia.org/wiki/Degree_of_a_polynomial#Degree_of_the_zero_polynomial)\n  for color on why this is the case.\n  ",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.Q,zDb,$APP.X,g_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `p` is a [[Polynomial]] of arity 1, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,vKb,$APP.X,t_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given either a non-[[Polynomial]] coefficient or a univariate [[Polynomial]]\n  with possibly-[[Polynomial]] coefficients, returns a new [[Polynomial]] of\n  arity `a` generated by attaching the polynomial coefficients back as variables\n  starting with `1`.\n\n  [[raise-arity]] undoes the transformation of [[lower-arity]].\n  See [[with-lower-arity]] for a function that packages these two\n  transformations.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,hzb,$APP.X,NL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the difference of polynomials `p` and `q`, with appropriate handling\n  for non-[[Polynomial]] coefficient inputs on either or both sides.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,keb,$APP.X,FL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the [[Polynomial]] this is equal to `that`. If `that` is\n  a [[Polynomial]], `this` and `that` are equal if they have equal terms and\n  equal arity. Coefficients are compared using [[emmy.value/\x3d]].\n\n  If `that` is non-[[Polynomial]], `eq` only returns true if `this` is a\n  monomial and its coefficient is equal to `that` (again\n  using [[emmy.value/\x3d]]).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.z($APP.Su,new $APP.f(null,1,[$APP.tj,MJb],null)),clb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Jnb,$APP.X,o_a,$APP.h,new $APP.f(null,2,[$APP.P,"If the [[leading-coefficient]] of `p` is negative, returns `(negate p)`, else\n  acts as identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,icc,$APP.X,y_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sequence of partial derivatives of [[Polynomial]] `p` with respect\n  to each indeterminate. The returned sequence has length equal to the [[arity]]\n  of `p`.\n\n  For non-[[Polynomial]] inputs, returns an empty sequence.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,dBb,$APP.X,Doc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.polynomial/t_emmy$polynomial48683.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[f0b],null))],null)],null),new $APP.f(null,3,[$APP.Q,nzb,$APP.X,BL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [[Polynomial]] instance representing a single indeterminate with\n  constant 1.\n\n  When called with no arguments, returns a monomial of arity 1 that acts as\n  identity in the first indeterminate.\n\n  The one-argument version takes an explicit `arity`, but still sets the\n  identity to the first indeterminate.\n\n  The two-argument version takes an explicit `i` and returns a monomial of arity\n  `arity` with an exponent of 1 in the `i`th indeterminate.",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[aU],null),$APP.z(new $APP.H(null,2,5,$APP.I,[aU,$APP.Rv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.ko,$APP.M($APP.cw,$APP.Rv,0),$APP.M($APP.$v,$APP.Rv,aU))],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Yjb,$APP.X,j_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some polynomial `p` and a coefficient `c`, returns a new [[Polynomial]]\n  generated by multiplying each coefficient of `p` by `c` (on the left).\n\n  See [[scale]] if right multiplication is important.\n\n  NOTE that [[scale-l]] will return a non-[[Polynomial]] if the result of the\n  mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Mv,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,TAb,$APP.X,XL,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]] `p`, returns the partial derivative of `p` with\n  respect to the `i`th indeterminate. Throws if `i` is an invalid indeterminate\n  index for `p`.\n\n  For non-[[Polynomial]] inputs, returns `0`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.Q,JQb,$APP.X,h_a,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns true if `p` is a [[Polynomial]] of arity \x3e 1, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kib,$APP.X,k_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]] `p`, returns `p` without its [[leading-term]].\n  non-[[Polynomial]] `p` inputs are treated at constant polynomials and return\n  `0`.\n\n  NOTE that [[drop-leading-term]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ilb,$APP.X,HL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the leading (highest degree) term of the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, returns a term with zero exponents\n  and `p` as its coefficient.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ofb,$APP.X,a_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]], returns the `terms` entry of the type. Handles other types as well:\n\n  - Acts as identity on vectors, interpreting them as vectors of terms\n  - any zero-valued `p` returns `[]`\n  - any other coefficient returns a vector of a single constant term.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,sbc,$APP.X,VL,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [[Polynomial]] instance (or a bare coefficient!) from either:\n\n  - a sequence of dense coefficients of a univariate polynomial (in ascending\n  order)\n  - an explicit `arity`, and a sparse mapping (or sequence of pairs) of exponent\n  \x3d\x3e coefficient\n\n  In the first case, the sequence is interpreted as a dense sequence of\n  coefficients of an arity-1 (univariate) polynomial. The coefficients begin\n  with the constant term and proceed to each higher power of the indeterminate.\n  For example, x^2 - 1 can be constructed by (make [-1 0 1]).\n\n  In the 2-arity case,\n\n  - `arity` is the number of indeterminates\n  - `expts-\x3ecoef` is a map of an exponent representation to a coefficient.\n\n  The `exponent` portion of the mapping can be any of:\n\n  - a proper exponent entry created by `emmy.polynomial.exponent`\n  - a map of the form `{variable-index, power}`\n  - a dense vector of variable powers, like `[3 0 1]` for $x^3z$. The length of\n    each vector should be equal to `arity`, in this case.\n\n  For example, any of the following would generate $4x^2y + 5xy^2$:\n\n  ```clojure\n  (make 2 [[[2 1] 4] [[1 2] 5]])\n  (make 2 {[2 1] 4, [1 2] 5})\n  (make 2 {{0 2, 1 1} 4, {0 1, 1 2} 5})\n  ```\n\n  NOTE: [[make]] will try and return a bare coefficient if possible. For\n  example, the following form will return a constant, since there are no\n  explicit indeterminates with powers \x3e 0:\n\n  ```clojure\n  (make 10 {{} 1 {} 2})\n  ;;\x3d\x3e 3\n  ```\n\n  See [[constant]] if you need an explicit [[Polynomial]] instance wrapping a\n  constant.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[fbc],null),new $APP.H(null,2,5,$APP.I,[aU,L7b],null))],null)],null),new $APP.f(null,3,[$APP.Q,ySb,$APP.X,RL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a polynomial generated by raising the input polynomial `p` to\n  the (integer) power `n`.\n\n  Negative exponents are not supported. For negative polynomial exponentation,\n  see [[rational-function/expt]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,
uYb,$APP.X,function(a,b,c){if($APP.k(MF.j(c)))return BL.A(a,b);c=DL.A(a,RF.j(c));a=BL.A(a,b);return ML.A?ML.A(c,a):ML.call(null,c,a)},$APP.h,new $APP.f(null,2,[$APP.P,"Given some `arity`, an indeterminate index `i` and some constant `root`,\n  returns a polynomial of the form `x_i - root`. The returned polynomial\n  represents a linear equation in the `i`th indeterminate.\n\n  If `root` is 0, [[linear]] is equivalent to the two-argument version\n  of [[identity]].",$APP.U,$APP.M(new $APP.H(null,3,
5,$APP.I,[aU,$APP.Rv,$APP.Qua],null))],null)],null),new $APP.f(null,3,[$APP.Q,x3b,$APP.X,CL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a sequence of `n` monomials of arity `n`, each with an exponent of `1`\n  for the `i`th indeterminate (where `i` matches the position in the returned\n  sequence).",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,wfb,$APP.X,KL,$APP.h,new $APP.f(null,2,[$APP.P,"Given a [[Polynomial]], returns a new [[Polynomial]] instance generated by\n  applying `f` to the coefficient of each term in `p` and filtering out all\n  resulting zeros.\n\n  Given a non-[[Polynomial]] coefficient, returns `(f p)`.\n\n  NOTE that [[map-coefficients]] will return a non-[[Polynomial]] if the result\n  of the mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Nv,$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wmb,$APP.X,T0a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,h2b,$APP.X,function(a){return zL(a)?vI(xI($APP.x.A(a.Ra,0))):$APP.k(MF.j(a))?-1:0},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the lowest degree found across any term in the supplied [[Polynomial]].\n  If a non-[[Polynomial]] is supplied, returns either `0` or `-1` if the input\n  is itself a `0`.\n\n  See [[degree]] for a discussion of this `-1` case.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,czb,$APP.X,LL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the negation of polynomial `p`, i.e., a polynomial with all coefficients\n  negated.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,kVb,$APP.X,y2,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a string representation of the supplied [[Polynomial]] instance `p`.\n\n  The optional argument `n` specifies how many terms to include in the returned\n  string before an ellipsis cuts them off.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),$APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,2,5,$APP.I,[KTb,$APP.Sv],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,gDb,$APP.X,function(a){return!zL(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the input `x` is explicitly _not_ an instance\n  of [[Polynomial]], false otherwise.\n\n  Equivalent to `(not (polynomial? x))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],
null))],null)],null),new $APP.f(null,3,[$APP.Q,ZUb,$APP.X,c_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some input `p` and an indeterminate index `i`, returns true if `0 \x3c\x3d i\n  \x3c (arity p)`, false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.Q,hEb,$APP.X,PL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the square of polynomial `p`. Equivalent to `(mul p p)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,ROb,$APP.X,ZZa,$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence of points of the form `[x, f(x)]`, returns a univariate\n  polynomial that passes through each input point.\n\n  The degree of the returned polynomial is equal to `(dec (count xs))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,lPb,$APP.X,$Za,$APP.h,new $APP.f(null,2,[$APP.P,"Given some `arity`, a coefficient `c` and an exponent `n`, returns a monomial\n  representing $c{x_0}^n$. The first indeterminate is always exponentiated.\n\n  Similar to [[make]], this function attempts to drop down to scalar-land if\n  possible:\n\n  - If `c` is [[emmy.value/zero?]], returns `c`\n  - if `n` is `zero?`, returns `(constant arity c)`\n\n  NOTE that negative exponents are not allowed.",
$APP.U,$APP.M($APP.z(new $APP.H(null,3,5,$APP.I,[aU,$APP.Mv,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.cw,$APP.wU,0)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,eMb,$APP.X,function(a,b){a=SL(a,b);$APP.x.B(a,0,null);a=$APP.x.B(a,1,null);return MF.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the numerator `n` is evenly divisible by `d` (i.e., leaves no\n  remainder), false otherwise.\n\n  NOTE that this performs a full division with [[divide]]. If you're planning on\n  doing this, you may as well call [[divide]] and check that the remainder\n  satisfies [[emmy.value/zero?]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.lP],null))],null)],null),new $APP.f(null,3,[$APP.Q,xnb,$APP.X,r_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `n` is a valid variable index for the [[Polynomial]] `p`, and\n  the variable with that index has no powers greater than `0` in `p`, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,GXb,$APP.X,function(a,b){return zL(a)?r_a(a,b)?jM.B(function(c){return MWa(c,
b)},a,a.arity-1):yD(["Polynomial not contractible: ",$APP.m.j(a)," in position ",$APP.m.j(b)].join("")):a},$APP.h,new $APP.f(null,2,[$APP.P,"If `p` is [[contractible?]] at index `n`, returns a new [[Polynomial]] instance\n  of [[arity]] `1` less than `p` with all variable indices \x3e `n` decremented.\n\n  For non-[[Polynomial]] inputs, acts as identity. Throws if `p` is not\n  explicitly [[contractible?]].\n\n  For example:\n\n  ```clojure\n  (\x3d (make 2 {[1 2] 3 [3 4] 5})\n     (contract\n       (make 3 {[0 1 2] 3 [0 3 4] 5}) 0))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,jTb,$APP.X,function(a,b){if(!zL(a)||0>b)return a;var c=a.arity;return b>c?yL(b+1,a.Ra,$APP.ed(a)):jM.B(function(d){return NWa(d,b,0)},a,c+1)},$APP.h,new $APP.f(null,2,[$APP.P,"Interpolates a new variable into the supplied [[Polynomial]] `p` at index `n`\n  by incrementing any existing variable index \x3e\x3d `n`.\n\n  Returns a new [[Polynomial]] of [[arity]] 1 greater than the [[arity]] of `p`,\n  or equal to `(inc n)` if `n` is greater than the [[arity]] of `p`.\n\n  For non-[[Polynomial]] inputs (or negative `n`), acts as identity.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,ufb,$APP.X,u_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given:\n\n  - multivariate [[Polynomial]]s `u` and `v`\n  - a `continue` function that accepts two univariate [[Polynomial]]s with\n    possibly-[[Polynomial]] coefficients,\n\n  Returns the result of calling [[lower-arity]] on `u` and `v`, passing the\n  results to `continue` and using [[raise-arity]] to raise the result back to\n  the original shared [[arity]] of `u` and `v`.\n\n  The exception is that if `continue` returns a\n  non-[[Polynomial]], [[with-lower-arity]] will not attempt to re-package it as\n  a [[Polynomial]].",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[yU,$APP.Wv,HT],null))],null)],null),new $APP.f(null,3,[$APP.Q,yVb,$APP.X,WL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the result of evaluating a multivariate [[Polynomial]] `p` at the\n  values in the sequence `xs` using [Horner's\n  rule](https://en.wikipedia.org/wiki/Horner%27s_method).\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity.\n\n  Supplying too many arguments in `xs` (i.e., a greater number than the [[arity]]\n  of `p`) will throw an exception. Too few arguments will result in a partial\n  evaluation of `p`, leaving the remaining indeterminates with their variable\n  indices shifted down.\n\n  For example:\n\n  ```clojure\n  (\x3d (make [0 0 '(* 3 (expt x 2) y) 0 '(* 5 (expt x 2) (expt y 3))])\n     (simplify\n       (evaluate\n         (make 3 {[2 1 2] 3 [2 3 4] 5}) ['x 'y])))\n  ```",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,$Ab,$APP.X,w_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]] `p`, returns a new [[Polynomial]] generated by\n  substituting each indeterminate `x_i` for `f_i * x_i`, where `f_i` is a factor\n  supplied in the `factors` sequence.\n\n  When `p` is a multivariate [[Polynomial]], each factor must be either a\n  non-[[Polynomial]] or a [[Polynomial]] with the same [[arity]] as `p`.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,oV],null),new $APP.f(null,1,[$APP.Bw,$APP.M($APP.bw,$APP.M(aU,$APP.Sv),$APP.M($APP.tv,oV))],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Iub,$APP.X,ML,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sum of polynomials `p` and `q`, with appropriate handling for\n  non-[[Polynomial]] coefficient inputs on either or both sides.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,xU],null))],null)],null),new $APP.f(null,3,[$APP.Q,ihb,$APP.X,function(a){return zL(a)?
xI($APP.fd(a.Ra)):uI},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the exponents of the leading (highest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, returns [[exponent/empty]].",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,xac,$APP.X,x_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[Polynomial]] `p`, returns a new [[Polynomial]] generated by\n  substituting each indeterminate `x_i` for `s_i + x_i`, where `s_i` is a shift\n  supplied in the `shifts` sequence.\n\n  When `p` is a multivariate [[Polynomial]], each shift must be either a\n  non-[[Polynomial]] or a [[Polynomial]] with the same [[arity]] as `p`.",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Sv,AY],null),new $APP.f(null,1,[$APP.Bw,$APP.M($APP.bw,$APP.M(aU,$APP.Sv),$APP.M($APP.tv,AY))],null)))],null)],null),new $APP.f(null,3,[$APP.Q,Knb,$APP.X,i_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some polynomial `p` and a coefficient `c`, returns a new [[Polynomial]]\n  generated by multiplying each coefficient of `p` by `c` (on the right).\n\n  See [[scale-l]] if left multiplication is important.\n\n  NOTE that [[scale]] will return a non-[[Polynomial]] if the result of the\n  mapping has only a constant term.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Mv],null))],null)],null),new $APP.f(null,3,[$APP.Q,i9b,$APP.X,EL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the declared arity of the supplied [[Polynomial]], or `0` for\n  non-polynomial arguments.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,$ab,$APP.X,B2,$APP.h,new $APP.f(null,2,[$APP.P,"Given a polynomial `p`, returns the [reciprocal\n  polynomial](https://en.wikipedia.org/wiki/Reciprocal_polynomial) with respect\n  to the `i`th indeterminate. `i` defaults to 0.\n\n  The reciprocal polynomial of `p` with respect to `i` is generated by\n\n  - treating the polynomial as univariate with respect to `i` and pushing all\n    other terms into the coefficients of the polynomial\n  - reversing the order of these coefficients\n  - flattening the polynomial out again\n\n  For example, note that the entries for the first indeterminate are reversed:\n\n  ```clojure\n  (\x3d (make 3 {[3 0 0] 5 [2 0 1] 2 [0 2 1] 3})\n     (reciprocal\n       (make 3 {[0 0 0] 5 [1 0 1] 2 [3 2 1] 3})))\n  ```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.H(null,2,5,$APP.I,[$APP.Sv,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.Q,bdb,$APP.X,function(a){return VL.j($APP.Vg.A(function(b){return qXa(a,b)},$APP.Jj.j(a+1)))},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the nth [Touchard\n  polynomial](https://en.wikipedia.org/wiki/Touchard_polynomials).\n\n  These are also called [Bell\n  polynomials](https://mathworld.wolfram.com/BellPolynomial.html) (in\n  Mathematica, implemented as `BellB`) or /exponential polynomials/.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))],null)],null),new $APP.f(null,3,[$APP.Q,FDb,$APP.X,GL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a sequence of the coefficients of the supplied polynomial `p`. A\n  coefficient is treated here as a monomial, and returns a sequence of itself.\n\n  If `p` is zero, returns an empty list.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,EZb,$APP.X,JL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the [[leading-base-coefficient]] of `p`\n  is [[generic/negative?]], false otherwise.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,web,$APP.X,f_a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `p` is either:\n\n  - a [[Polynomial]] instance with a single term, or\n  - a non-[[Polynomial]] coefficient,\n\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Yfb,$APP.X,function(a){return zL(a)?yI($APP.x.B(a.Ra,0,$APP.sf)):a},$APP.h,new $APP.f(null,2,[$APP.P,"Returns the coefficient of the trailing (lowest degree) term of\n  the [[Polynomial]] `p`.\n\n  If `p` is a non-[[Polynomial]] coefficient, acts as identity.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ghb,$APP.X,function(a,b){var c=BL.J();a=a.j?a.j(c):a.call(null,c);return HXa(a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns a univariate polynomial of all terms in the\n  supplied [[series/PowerSeries]] instance, up to (and including) order\n  `n-terms`.\n\n  ```clojure\n  (g/simplify\n    ((from-power-series series/exp-series 3) 'x))\n  ;; \x3d\x3e (+ (* 1/6 (expt x 3)) (* 1/2 (expt x 2)) x 1)\n  ```",
$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.Vv,xYb],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(Ygb,$APP.Vv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,eUb,$APP.X,D2,$APP.h,new $APP.f(null,2,[$APP.P,"Converts the supplied symbolic expression `expr` into Flat Polynomial canonical\n  form (i.e., a [[Polynomial]] instance). `expr` should be a bare, unwrapped\n  expression built out of Clojure data structures.\n\n  Returns the result of calling continuation `cont` with the [[Polynomial]] and\n  the list of variables corresponding to each indeterminate in\n  the [[Polynomial]]. (`cont `defaults to `vector`).\n\n  The second optional argument `v-compare` allows you to provide a Comparator\n  between variables. Sorting indeterminates by `v-compare` will determine the\n  order of the indeterminates in the generated [[Polynomial]]. The list of\n  variables passed to `cont` will be sorted using `v-compare`.\n\n  Absorbing an expression with [[expression-\x3e]] and emitting it again\n  with [[-\x3eexpression]] will generate the canonical form of an expression, with\n  respect to the operations in the [[operators-known]] set.\n\n  This kind of simplification proceeds purely symbolically over the known Flat\n  Polynomial operations; other operations outside the arithmetic available in\n  polynomials over commutative rings should be factored out by an expression\n  analyzer (see [[emmy.expression.analyze/make-analyzer]]) before\n  calling [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,fX],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,fX,kU],null))],null)],null),new $APP.f(null,3,[$APP.Q,K_b,$APP.X,function(a){if(zL(a)){var b=$APP.Uc.A(1,EL(a));return b?uG.j(IL(a)):b}return uG.j(a)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `p` is a [monic\n  polynomial](https://en.wikipedia.org/wiki/Monic_polynomial), false otherwise.\n\n  A monic polynomial is a univariate polynomial with a leading coefficient that\n  responds `true` to [[emmy.value/one?]]. This means that any coefficient\n  that responds `true` to [[emmy.value/one?]] also qualifies as a monic\n  polynomial.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mgb,$APP.X,s_a,$APP.h,new $APP.f(null,2,[$APP.P,"Given a multivariate [[Polynomial]] `p`, returns an equivalent\n  univariate [[Polynomial]] whose coefficients are polynomials of [[arity]]\n  equal to one less than the [[arity]] of `p`.\n\n  Use [[raise-arity]] to undo this transformation. See [[with-lower-arity]] for\n  a function that packages these two transformations.\n\n  NOTE that [[lower-arity]] will drop a coefficient down to a non-[[Polynomial]]\n  if the result of extracting the first variable leaves a constant term.",
$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(Dpb,$APP.Sv)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,hbc,$APP.X,OL,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the product of polynomials `p` and `q`, with appropriate handling for\n  non-[[Polynomial]] coefficient inputs on either or both sides.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Sv,xU],null))],null)],null)]),$APP.ap(l3b)),$APP.cp(new $APP.f(null,
6,[Cdb,new $APP.f(null,3,[$APP.Q,nHb,$APP.X,Jrc,$APP.h,$APP.F],null),V9b,new $APP.f(null,3,[$APP.Q,l$b,$APP.X,Irc,$APP.h,$APP.F],null),$APP.z(cCb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[fV],null)],null)],null))),$APP.P,"Convert the given expression to TeX format, as a string.\n\n  If you set the `:equation` keyword argument to a truthy value, the result will\n  be wrapped in an equation environment. `:equation \x3cstring\x3e` will insert a\n  `\\label{\x3cstring\x3e}` entry inside the equation environment.\n\n  For example:\n\n  ```clojure\n  (let [expr (+ 'x 'xy)]\n    (println\n      (-\x3eTeX expr :equation \"label!\")))\n\n  \\begin{equation}\n  \\label{label!}\n  x + y\n  \\end{equation}\n  ```\n  ",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,1,$APP.qw,1,$APP.wy,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.Ww,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[fV],null)],null))],null),$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[fV],null)],null)],null)),$APP.Cx,$APP.M(null)],null)],null)),new $APP.f(null,3,[$APP.Q,Edb,$APP.X,S3,$APP.h,new $APP.f(null,2,[$APP.P,"Convert the given expression to TeX format, as a string.\n\n  If you set the `:equation` keyword argument to a truthy value, the result will\n  be wrapped in an equation environment. `:equation \x3cstring\x3e` will insert a\n  `\\label{\x3cstring\x3e}` entry inside the equation environment.\n\n  For example:\n\n  ```clojure\n  (let [expr (+ 'x 'xy)]\n    (println\n      (-\x3eTeX expr :equation \"label!\")))\n\n  \\begin{equation}\n  \\label{label!}\n  x + y\n  \\end{equation}\n  ```\n  ",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.Ww,$APP.Lh,new $APP.f(null,1,[$APP.Bu,new $APP.H(null,1,5,$APP.I,[fV],null)],null)],null))],null)],null),zGb,new $APP.f(null,3,[$APP.Q,E9b,$APP.X,BQ,$APP.h,$APP.F],null),$APP.z(Kgb,new $APP.f(null,1,[$APP.im,!0],null)),new $APP.f(null,3,[$APP.Q,fIb,$APP.X,!0,$APP.h,$APP.F],null),$APP.z(xGb,new $APP.f(null,1,[$APP.im,!0],null)),new $APP.f(null,3,[$APP.Q,U8b,$APP.X,!1,$APP.h,$APP.F],null)],null),$APP.ap(Hqb)),$APP.cp($APP.fg([$APP.z(uV,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,DY],null))),$APP.P,"Accepts a [[RationalFunction]] `r` and a sequence of symbols for each indeterminate,\n  and emits the canonical form of the symbolic expression that\n  represents [[RationalFunction]] `r`.\n\n  NOTE: this is the output stage of Rational Function canonical form\n  simplification. The input stage is handled by [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]]."],
null)),$APP.z(vV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Returns the cube of rational function `r`. Equivalent to `(mul r (mul r r))`."],null)),$APP.z(jFb,new $APP.f(null,5,[XE,new $APP.ug(null,new $APP.f(null,10,[mU,"null",UW,"null",YE,"null",aKb,"null",tS,"null",nS,"null",NY,"null",iV,"null",pT,"null",TV,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[aU,yU,$APP.Wv,$APP.Qr],null))),YR,new $APP.ug(null,
new $APP.f(null,6,[mU,"null",UW,"null",tS,"null",nS,"null",iV,"null",pT,"null"],null),null),$APP.P,"Positional factory function for emmy.rational-function/RationalFunction."],null)),$APP.z(kK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))),$APP.P,"Returns the greatest common divisor of rational functions `r` and `s`, with\n  appropriate handling of [[RationalFunction]], [[polynomial/Polynomial]] or\n  coefficients of neither type on either side. "],
null)),$APP.z($APP.LX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))),$APP.P,"Returns the difference of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side."],null)),$APP.z(dX,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z($APP.Ku,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"If the numerator of `r` is negative, returns `(negate r)`, else acts as\n  identity."],
null)),$APP.z(jX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Given some rational function `r`, returns the inverse of `r`, i.e., a rational\n  function with numerator and denominator reversed. The returned rational\n  function guarantees a positive denominator.\n\n  Acts as [[generic/invert]] for non-[[RationalFunction]] inputs."],null)),$APP.z(ZPb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,
"Returns the sequence of partial derivatives\n  of [[RationalFunction]] (or [[polynomial/Polynomial]]) `r` with respect to\n  each indeterminate. The returned sequence has length equal to the [[arity]] of\n  `r`.\n\n  For non-polynomial or rational function inputs, returns an empty sequence."],null)),$APP.z(kS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Rv],null))),$APP.P,"Given some [[RationalFunction]] or [[polynomial/Polynomial]] `r`, returns the\n  partial derivative of `r` with respect to the `i`th indeterminate. Throws if\n  `i` is an invalid indeterminate index for `r`.\n\n  For non-polynomial or rational function inputs, returns `0`."],
null)),$APP.z(iU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))),$APP.P,"Given a numerator `u` and denominator `v`, attempts to form\n  a [[RationalFunction]] instance by\n\n  - cancelling out any common factors between `u` and `v`\n  - normalizing `u` and `v` such that `v` is always positive\n  - multiplying `u` and `v` through by a commo factor, such that neither term\n    contains any rational coefficients\n\n  Returns a [[RationalFunction]] instance if either `u` or `v` remains\n  a [[polynomial/Polynomial]] after this process; else, returns `(g/div u' v')`,\n  where `u'` and `v'` are the reduced numerator and denominator."],
null)),$APP.z(FJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rW,$APP.wU)],null)],null)))),$APP.P,"Returns a rational function generated by raising the input rational function\n  `r` to the (integer) power `n`."],null)),$APP.z(gbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Returns true if the supplied argument is an instance of [[RationalFunction]],\n  false otherwise."],
null)),YS,$APP.z(RX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Returns the negation of rational function `r`, i.e., a [[RationalFunction]] with\n  its numerator negated.\n\n  Acts as [[generic/negate]] for non-[[RationalFunction]] inputs."],null)),$APP.z(CTb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is explicitly _not_ an instance of [[RationalFunction]]\n  or [[polynomial/Polynomial]], false if it is."],
null)),$APP.z(cT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Returns the square of rational function `r`. Equivalent to `(mul r r)`."],null)),$APP.z(LY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))),$APP.P,"Returns the quotient of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side."],
null)),$APP.z(B2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))),$APP.P,"Given a sequence of points of the form `[x, f(x)]`, returns a rational function\n  that passes through each input point."],null)),$APP.z(Uac,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[nS,"null",ZX,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[Zub],null))),$APP.P,"Positional factory function for emmy.rational-function/t_emmy$rational_function49062."],null)),$APP.z(uCb,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(fU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,oV],null))),$APP.P,"Given some [[RationalFunction]] `r`, returns a new [[RationalFunction]]\n  generated by substituting each indeterminate `x_i` for `f_i * x_i`, where\n  `f_i` is a factor supplied in the `factors` sequence.\n\n  Given a non-[[RationalFunction]], delegates to [[polynomial/arg-scale]]."],
null)),$APP.z($APP.iT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))),$APP.P,"Returns the sum of rational functions `r` and `s`, with appropriate handling\n  of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of neither\n  type on either side."],null)),$APP.z(HX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,AY],null))),$APP.P,"Given some [[RationalFunction]] `r`, returns a new [[RationalFunction]]\n  generated by substituting each indeterminate `x_i` for `s_i + x_i`, where\n  `s_i` is a shift supplied in the `shifts` sequence.\n\n  Given a non-[[RationalFunction]], delegates to [[polynomial/arg-shift]]."],
null)),$APP.z(aU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Returns the declared arity of the supplied [[RationalFunction]]\n  or [[polynomial/Polynomial]], or `0` for arguments of other types."],null)),$APP.z(AX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))),$APP.P,"Returns true if the numerator of `r` is [[polynomial/negative?]], false\n  otherwise."],null)),$APP.z(KX,new $APP.f(null,3,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,fX],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,fX,kU],null))),$APP.P,"Converts the supplied symbolic expression `expr` into Rational Function\n  canonical form (i.e., a [[RationalFunction]] instance). `expr` should be a bare,\n  unwrapped expression built out of Clojure data structures.\n\n  Returns the result of calling continuation `cont` with\n  the [[RationalFunction]] and the list of variables corresponding to each\n  indeterminate in the [[RationalFunction]]. (`cont `defaults to `vector`).\n\n  The second optional argument `v-compare` allows you to provide a Comparator\n  between variables. Sorting indeterminates by `v-compare` will determine the\n  order of the indeterminates in the generated [[RationalFunction]]. The list of\n  variables passed to `cont` will be sorted using `v-compare`.\n\n  Absorbing an expression with [[expression-\x3e]] and emitting it again\n  with [[-\x3eexpression]] will generate the canonical form of an expression, with\n  respect to the operations in the [[operators-known]] set.\n\n  This kind of simplification proceeds purely symbolically over the known\n  Rational Function operations; other operations outside the arithmetic\n  available should be factored out by an expression\n  analyzer (see [[emmy.expression.analyze/make-analyzer]]) before\n  calling [[expression-\x3e]].\n\n  NOTE that `cont` might receive a scalar, fraction or [[polynomial/Polynomial]]\n  instance; both are valid 'rational functions'. The latter as a rational\n  function with a denominator equal to `1`, and the former 2 result from\n  non-polynomial numerator and denominator.\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,3,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,fX],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,fX,kU],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,fX],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,fX,kU],null)),$APP.Cx,$APP.M(null,null,null)],null)],null)),$APP.z($U,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.oO,$APP.Vv],null))),$APP.P,"Returns the product of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side."],null))],[new $APP.f(null,3,[$APP.Q,q3b,$APP.X,R0a,$APP.h,new $APP.f(null,2,[$APP.P,"Accepts a [[RationalFunction]] `r` and a sequence of symbols for each indeterminate,\n  and emits the canonical form of the symbolic expression that\n  represents [[RationalFunction]] `r`.\n\n  NOTE: this is the output stage of Rational Function canonical form\n  simplification. The input stage is handled by [[expression-\x3e]].\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,DY],null))],null)],null),new $APP.f(null,3,[$APP.Q,cAb,$APP.X,M0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the cube of rational function `r`. Equivalent to `(mul r (mul r r))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,m_b,$APP.X,vM,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.rational-function/RationalFunction.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[aU,yU,$APP.Wv,
$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,STb,$APP.X,P0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the greatest common divisor of rational functions `r` and `s`, with\n  appropriate handling of [[RationalFunction]], [[polynomial/Polynomial]] or\n  coefficients of neither type on either side. ",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,j9b,$APP.X,J0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the difference of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,X3b,$APP.X,xM,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the [[RationalFunction]] this is equal to `that`. If `that` is\n  a [[RationalFunction]], `this` and `that` are equal if they have equal `u` and\n  `v` and equal arity. `u` and `v` entries are compared\n  using [[emmy.value/\x3d]].\n\n  If `that` is non-[[RationalFunction]], `eq` only returns true if `u` and `v`\n  respectively match the [[ratio/numerator]] and [[ratio/denominator]] of\n  `that`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.z($APP.Su,new $APP.f(null,1,[$APP.tj,Xwb],null)),clb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Rab,$APP.X,H0a,$APP.h,new $APP.f(null,2,[$APP.P,"If the numerator of `r` is negative, returns `(negate r)`, else acts as\n  identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,ORb,$APP.X,O0a,$APP.h,new $APP.f(null,2,[$APP.P,"Given some rational function `r`, returns the inverse of `r`, i.e., a rational\n  function with numerator and denominator reversed. The returned rational\n  function guarantees a positive denominator.\n\n  Acts as [[generic/invert]] for non-[[RationalFunction]] inputs.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,RIb,$APP.X,Q0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sequence of partial derivatives\n  of [[RationalFunction]] (or [[polynomial/Polynomial]]) `r` with respect to\n  each indeterminate. The returned sequence has length equal to the [[arity]] of\n  `r`.\n\n  For non-polynomial or rational function inputs, returns an empty sequence.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],
null),new $APP.f(null,3,[$APP.Q,Osb,$APP.X,CM,$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[RationalFunction]] or [[polynomial/Polynomial]] `r`, returns the\n  partial derivative of `r` with respect to the `i`th indeterminate. Throws if\n  `i` is an invalid indeterminate index for `r`.\n\n  For non-polynomial or rational function inputs, returns `0`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Rv],null))],null)],null),new $APP.f(null,3,[$APP.Q,yxb,$APP.X,zM,$APP.h,new $APP.f(null,2,[$APP.P,
"Given a numerator `u` and denominator `v`, attempts to form\n  a [[RationalFunction]] instance by\n\n  - cancelling out any common factors between `u` and `v`\n  - normalizing `u` and `v` such that `v` is always positive\n  - multiplying `u` and `v` through by a commo factor, such that neither term\n    contains any rational coefficients\n\n  Returns a [[RationalFunction]] instance if either `u` or `v` remains\n  a [[polynomial/Polynomial]] after this process; else, returns `(g/div u' v')`,\n  where `u'` and `v'` are the reduced numerator and denominator.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[yU,$APP.Wv],null))],null)],null),new $APP.f(null,3,[$APP.Q,MTb,$APP.X,N0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a rational function generated by raising the input rational function\n  `r` to the (integer) power `n`.",$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.wU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rW,$APP.wU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,fKb,$APP.X,wM,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns true if the supplied argument is an instance of [[RationalFunction]],\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wsb,$APP.X,V0a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,IQb,$APP.X,G0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the negation of rational function `r`, i.e., a [[RationalFunction]] with\n  its numerator negated.\n\n  Acts as [[generic/negate]] for non-[[RationalFunction]] inputs.",$APP.U,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,yfb,$APP.X,w0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is explicitly _not_ an instance of [[RationalFunction]]\n  or [[polynomial/Polynomial]], false if it is.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,utb,$APP.X,L0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the square of rational function `r`. Equivalent to `(mul r r)`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,e3b,$APP.X,AM,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the quotient of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,rEb,$APP.X,function(a){return dG.j(o0a(a,BL.J()))},$APP.h,new $APP.f(null,2,[$APP.P,"Given a sequence of points of the form `[x, f(x)]`, returns a rational function\n  that passes through each input point.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ezb,$APP.X,vqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.rational-function/t_emmy$rational_function49062.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Zub],null))],null)],null),new $APP.f(null,3,[$APP.Q,n5b,$APP.X,BM,$APP.h,new $APP.f(null,2,[$APP.P,"Given some rational function `xs` and a sequence of arguments with length \x3e\x3d 0\n  and \x3c the [[arity]] of `r`, returns the result of evaluating the numerator and\n  denominator using `xs` and re-forming a rational function with the results.\n\n  Supplying fewer arguments than the arity will result in a partial evaluation.\n  Supplying too many arguments will error.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.ix],null))],null)],null),new $APP.f(null,3,[$APP.Q,fNb,$APP.X,function(a,b){return wM(a)?AM(w_a(a.Jb,b),w_a(a.v,b)):w_a(a,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[RationalFunction]] `r`, returns a new [[RationalFunction]]\n  generated by substituting each indeterminate `x_i` for `f_i * x_i`, where\n  `f_i` is a factor supplied in the `factors` sequence.\n\n  Given a non-[[RationalFunction]], delegates to [[polynomial/arg-scale]].",$APP.U,
$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,oV],null))],null)],null),new $APP.f(null,3,[$APP.Q,Zab,$APP.X,I0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the sum of rational functions `r` and `s`, with appropriate handling\n  of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of neither\n  type on either side.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))],null)],null),new $APP.f(null,3,[$APP.Q,bqb,$APP.X,function(a,b){return wM(a)?AM(x_a(a.Jb,b),x_a(a.v,b)):x_a(a,
b)},$APP.h,new $APP.f(null,2,[$APP.P,"Given some [[RationalFunction]] `r`, returns a new [[RationalFunction]]\n  generated by substituting each indeterminate `x_i` for `s_i + x_i`, where\n  `s_i` is a shift supplied in the `shifts` sequence.\n\n  Given a non-[[RationalFunction]], delegates to [[polynomial/arg-shift]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,AY],null))],null)],null),new $APP.f(null,3,[$APP.Q,A0b,$APP.X,x0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the declared arity of the supplied [[RationalFunction]]\n  or [[polynomial/Polynomial]], or `0` for arguments of other types.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,vbb,$APP.X,z0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the numerator of `r` is [[polynomial/negative?]], false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.oO],null))],null)],null),new $APP.f(null,3,[$APP.Q,Aub,$APP.X,M2,$APP.h,new $APP.f(null,2,[$APP.P,"Converts the supplied symbolic expression `expr` into Rational Function\n  canonical form (i.e., a [[RationalFunction]] instance). `expr` should be a bare,\n  unwrapped expression built out of Clojure data structures.\n\n  Returns the result of calling continuation `cont` with\n  the [[RationalFunction]] and the list of variables corresponding to each\n  indeterminate in the [[RationalFunction]]. (`cont `defaults to `vector`).\n\n  The second optional argument `v-compare` allows you to provide a Comparator\n  between variables. Sorting indeterminates by `v-compare` will determine the\n  order of the indeterminates in the generated [[RationalFunction]]. The list of\n  variables passed to `cont` will be sorted using `v-compare`.\n\n  Absorbing an expression with [[expression-\x3e]] and emitting it again\n  with [[-\x3eexpression]] will generate the canonical form of an expression, with\n  respect to the operations in the [[operators-known]] set.\n\n  This kind of simplification proceeds purely symbolically over the known\n  Rational Function operations; other operations outside the arithmetic\n  available should be factored out by an expression\n  analyzer (see [[emmy.expression.analyze/make-analyzer]]) before\n  calling [[expression-\x3e]].\n\n  NOTE that `cont` might receive a scalar, fraction or [[polynomial/Polynomial]]\n  instance; both are valid 'rational functions'. The latter as a rational\n  function with a denominator equal to `1`, and the former 2 result from\n  non-polynomial numerator and denominator.\n\n  NOTE See [[analyzer]] for an instance usable\n  by [[emmy.expression.analyze/make-analyzer]].",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Ww],null),new $APP.H(null,2,5,$APP.I,[$APP.Ww,fX],null),new $APP.H(null,3,5,$APP.I,[$APP.Ww,fX,kU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Crb,$APP.X,K0a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the product of rational functions `r` and `s`, with appropriate\n  handling of [[RationalFunction]], [[polynomial/Polynomial]] or coefficients of\n  neither type on either side.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.oO,$APP.Vv],null))],null)],
null)]),$APP.ap(eZb)),$APP.cp($APP.fg([$APP.z(nxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[FX,VU],null))),$APP.P,"Returns a data structure representing [Christoffel symbols of the first\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_first_kind)."],null)),$APP.z(EQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[jW,VU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rS,VU)],
null)],null))))],null)),$APP.z(Fbc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null)))],null)),$APP.z(lfb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))],null)),$APP.z(HQb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[jW,VU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rS,VU)],null)],null))))],null)),$APP.z(Gbc,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
2,5,$APP.I,[$APP.Yw,mT],null)))],null)),$APP.z(Onb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null)))],null)),$APP.z(tRb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[iac,hac,nac,VU,jW],null)))],null)),$APP.z(kfb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null)))],null))],[new $APP.f(null,3,[$APP.Q,sbb,$APP.X,h6a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a data structure representing [Christoffel symbols of the first\n  kind](https://en.wikipedia.org/wiki/Christoffel_symbols#Christoffel_symbols_of_the_first_kind).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[FX,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mbc,$APP.X,j6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[jW,VU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rS,VU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,u9b,$APP.X,l6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null))],null)],null),new $APP.f(null,3,[$APP.Q,uub,$APP.X,p6a,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kbc,$APP.X,i6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M($APP.z(new $APP.H(null,2,5,$APP.I,[jW,VU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(rS,VU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,v9b,$APP.X,m6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null))],null)],null),new $APP.f(null,3,[$APP.Q,Icb,$APP.X,n6a,$APP.h,new $APP.f(null,
1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yw,mT],null))],null)],null),new $APP.f(null,3,[$APP.Q,tZb,$APP.X,TP,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[iac,hac,nac,VU,jW],null))],null)],null),new $APP.f(null,3,[$APP.Q,vub,$APP.X,o6a,$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[jW,VU],null))],null)],null)]),$APP.ap(NWb)),$APP.cp(new $APP.f(null,3,[$APP.z(fyb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],
null))),$APP.P,"Returns its argument, wrapped in a marker type that responds to the generic\n  operations registered in [[emmy.numsymb]].\n\n  Symbols are automatically treated as [[literal-number]] instances, so\n\n  ```clojure\n  (* 10 (literal-number 'x))\n  ```\n\n  is equivalent to\n\n  ```clojure\n  (* 10 'x)\n  ```\n\n  If you pass an actual number, emmy will attempt to preserve exact values\n  through various operations:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 4))))\n  ;;\x3d\x3e (+ 1 (cos 8))\n  ```\n\n  Notice that the `(g/* 2 ...)` is evaluated, but `cos` evaluation is deferred,\n  since the result is inexact. On the other hand, if the number is inexact to\n  begin with:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 2.2))))\n  ;;\x3d\x3e 0.6926671300215806\n  ```\n\n  the system will go ahead and evaluate it."],
null)),new $APP.f(null,3,[$APP.Q,Jbc,$APP.X,SM,$APP.h,new $APP.f(null,2,[$APP.P,"Returns its argument, wrapped in a marker type that responds to the generic\n  operations registered in [[emmy.numsymb]].\n\n  Symbols are automatically treated as [[literal-number]] instances, so\n\n  ```clojure\n  (* 10 (literal-number 'x))\n  ```\n\n  is equivalent to\n\n  ```clojure\n  (* 10 'x)\n  ```\n\n  If you pass an actual number, emmy will attempt to preserve exact values\n  through various operations:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 4))))\n  ;;\x3d\x3e (+ 1 (cos 8))\n  ```\n\n  Notice that the `(g/* 2 ...)` is evaluated, but `cos` evaluation is deferred,\n  since the result is inexact. On the other hand, if the number is inexact to\n  begin with:\n\n  ```clojure\n  (g/+ 1 (g/cos (g/* 2 (literal-number 2.2))))\n  ;;\x3d\x3e 0.6926671300215806\n  ```\n\n  the system will go ahead and evaluate it.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),$APP.z(n_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is an explicit symbolic expression or something passed to\n  `literal-number`, false otherwise.\n\n  See [[abstract-number?]] for a similar function that also responds true to\n  symbols."],null)),new $APP.f(null,3,[$APP.Q,PBb,$APP.X,o1a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is an explicit symbolic expression or something passed to\n  `literal-number`, false otherwise.\n\n  See [[abstract-number?]] for a similar function that also responds true to\n  symbols.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),$APP.z(imb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is:\n\n  - a symbolic expression\n  - some object wrapped by a call to [[literal-number]]\n  - a symbol (which implicitly acts as a [[literal-number]])\n\n  See [[literal-number?]] for a similar function that won't respond true to\n  symbols, only to explicit symbolic expressions or wrapped literal numbers."],
null)),new $APP.f(null,3,[$APP.Q,nfb,$APP.X,function(a){return o1a(a)||a instanceof $APP.q},$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is:\n\n  - a symbolic expression\n  - some object wrapped by a call to [[literal-number]]\n  - a symbol (which implicitly acts as a [[literal-number]])\n\n  See [[literal-number?]] for a similar function that won't respond true to\n  symbols, only to explicit symbolic expressions or wrapped literal numbers.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],
null))],null)],null)],null),$APP.ap(e5b)),$APP.cp(new $APP.f(null,8,[$APP.z(JMb,new $APP.f(null,1,[$APP.Nw,!0],null)),new $APP.f(null,3,[$APP.Q,C9b,$APP.X,eTa,$APP.h,$APP.F],null),$APP.z(Wbc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))),$APP.P,"Used as a [data reader](https://www.clojurescript.org/guides/reader#_clojurescript_compilation).\n  In Clojure, we could get away with just using the constructor above, but in\n  ClojureScript we need to act as a macro to delay evaluation of the constructor."],
null)),new $APP.f(null,3,[$APP.Q,Jhb,$APP.X,sTa,$APP.h,new $APP.f(null,2,[$APP.P,"Used as a [data reader](https://www.clojurescript.org/guides/reader#_clojurescript_compilation).\n  In Clojure, we could get away with just using the constructor above, but in\n  ClojureScript we need to act as a macro to delay evaluation of the constructor.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))],null)],null),$APP.z(Irb,new $APP.f(null,1,[$APP.Nw,!0],null)),new $APP.f(null,3,[$APP.Q,l0b,$APP.X,gTa,
$APP.h,$APP.F],null),$APP.z(EU,new $APP.f(null,1,[$APP.Nw,!0],null)),new $APP.f(null,3,[$APP.Q,psb,$APP.X,pG,$APP.h,$APP.F],null),$APP.z(fY,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null))),$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,
1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,wG,$APP.X,yG,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null),new $APP.H(null,2,5,$APP.I,[IW,gX],null))],null)],
null),$APP.z(jlb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise."],null)),new $APP.f(null,3,[$APP.Q,Sdb,$APP.X,xG,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `a` is an instance of [[Complex]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),$APP.z(o5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.VP],
null))),$APP.P,"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values. (Note: the use of cast-to-double is\n   unfortunate here, as complex numbers can now contain exact fractions, and\n   we'd want a nearest integer generic function for those)"],null)),new $APP.f(null,3,[$APP.Q,tNb,$APP.X,tTa,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values. (Note: the use of cast-to-double is\n   unfortunate here, as complex numbers can now contain exact fractions, and\n   we'd want a nearest integer generic function for those)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.VP],null))],null)],null),$APP.z(opb,new $APP.f(null,1,[$APP.Nw,!0],null)),new $APP.f(null,3,[$APP.Q,Exb,$APP.X,anc,$APP.h,$APP.F],null)],null),$APP.ap(P2b)),$APP.cp(new $APP.f(null,1,[$APP.z(SUb,new $APP.f(null,1,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.FU,e9b],null)))],null)),new $APP.f(null,3,[$APP.Q,IZb,$APP.X,function(a,b){var c=$APP.Xc(UH(b));c=$APP.Vj.A(c,0);var d=kG.A,g=SQ.j?SQ.j(2):SQ.call(null,2);a=g.j?g.j(a):g.call(null,
a);return d.call(kG,a,$APP.Je.A(UO.j?UO.j(b):UO.call(null,b),c))},$APP.h,new $APP.f(null,1,[$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.FU,e9b],null))],null)],null)],null),$APP.ap(Ryb)),$APP.cp(new $APP.f(null,6,[$APP.z(uRb,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,new $APP.f(null,2,[$APP.z(LTb,new $APP.f(null,1,[$APP.P,null],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null),$APP.z(qHb,new $APP.f(null,1,[$APP.P,null],null)),new $APP.H(null,1,5,$APP.I,
[new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)],null)],null)],null),$APP.Ov,new $APP.f(null,2,[U0b,new $APP.f(null,3,[$APP.Q,LTb,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)),$APP.P,null],null),HCb,new $APP.f(null,3,[$APP.Q,qHb,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)),$APP.P,null],null)],null),gU,$APP.M("@interface")],null)),new $APP.f(null,3,[$APP.Q,aKb,$APP.X,yTa,$APP.h,$APP.F],null),$APP.z(LTb,new $APP.f(null,3,[$APP.Pm,aKb,$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Kv],null)))],null)),new $APP.f(null,3,[$APP.Q,L1b,$APP.X,DG,$APP.h,new $APP.f(null,2,[$APP.P,null,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null),uUb,new $APP.f(null,3,[$APP.Q,QZb,$APP.X,xTa,$APP.h,$APP.F],null),$APP.z(Fib,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Parser for the `#emmy/ratio` literal."],null)),new $APP.f(null,3,[$APP.Q,cvb,$APP.X,function(a){if(GF(a))return $APP.T.j($APP.r($APP.N.A(new $APP.D(null,
MX,null,1,null),new $APP.D(null,a,null,1,null))));if("string"===typeof a){var b=$APP.Lg(bnc,a);return $APP.k(b)?($APP.x.B(b,0,null),a=$APP.x.B(b,1,null),b=$APP.x.B(b,2,null),$APP.T.j($APP.r($APP.N.C(new $APP.D(null,MX,null,1,null),new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,SY,null,1,null),new $APP.D(null,a,null,1,null)))),null,1,null),$APP.y([new $APP.D(null,$APP.T.j($APP.r($APP.N.A(new $APP.D(null,SY,null,1,null),new $APP.D(null,b,null,1,null)))),null,1,null)]))))):yD(["Invalid ratio: ",
a].join(""))}return $APP.od(a)&&$APP.Uc.A(2,$APP.Tc(a))?$APP.T.j($APP.r($APP.N.A(new $APP.D(null,MX,null,1,null),a))):yD(["Invalid ratio: ",$APP.m.j(a)].join(""))},$APP.h,new $APP.f(null,2,[$APP.P,"Parser for the `#emmy/ratio` literal.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),$APP.z(oQb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.lP],null))),$APP.P,"Construct a ratio.",$APP.ky,new $APP.f(null,
6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.lP],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,$APP.lP],null)),$APP.Cx,$APP.M(null,null)],null)],null)),new $APP.f(null,3,[$APP.Q,MX,$APP.X,YZ,$APP.h,new $APP.f(null,2,[$APP.P,"Construct a ratio.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.wU,
$APP.lP],null))],null)],null),$APP.z(qHb,new $APP.f(null,3,[$APP.Pm,aKb,$APP.P,null,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null)))],null)),new $APP.f(null,3,[$APP.Q,e$b,$APP.X,EG,$APP.h,new $APP.f(null,2,[$APP.P,null,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Kv],null))],null)],null)],null),$APP.ap(qub)),$APP.cp($APP.fg([$APP.z(nX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic quotient"],null)),$APP.z(d4b,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"Alias for [[solve-linear]]; present for compatibility with the original\n  `scmutils` codebase.\n\n  NOTE: In `scmutils`, `solve-linear-left` and `solve-linear` act identically in\n  all cases except matrices. `solve-linear-left` only accepted a column\n  matrix (or up structure) in the `b` position, while `solve-linear` accepted\n  either a column or row (up or down structure).\n\n  In Emmy, both functions accept either type."],
null)),$APP.z(gS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic remainder.\n\nReturns the remainder of dividing the dividend `a` by divisor `b`.\n\n The contract satisfied by [[remainder]] is:\n\n```clojure\n(\x3d a (+ (* b (quotient a b))\n        (remainder a b)))\n```\n\n For numbers, this differs from the contract offered by [[modulo]]\n because [[quotient]] rounds toward 0, while `(floor (/ a b))` rounds toward\n negative infinity.\n\n The result will be either `0` or of the same sign as the dividend `a`."],
null)),$APP.z(b$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic identity-like.\n\nLike `one-like` but works for square matrices."],null)),$APP.z(gW,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(FT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic make-polar"],null)),$APP.z(vV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,
"generic cube"],null)),$APP.z(zXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic tanc.\n\n`tanc` is defined, by analogy with [[sinc]], to be equal to $\\frac{\\tan\n  x}{x}$ for nonzero $x$ and equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/TancFunction.html)"],null)),$APP.z(aSb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic determinant"],null)),$APP.z(yH,new $APP.f(null,1,[$APP.Ru,!0],null)),G7b,$APP.z(mH,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(w6b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic exact-divide.\n\nSimilar to the binary case of [[/]], but throws if `(g/exact? \x3cresult\x3e)`\n  returns false."],null)),$APP.z(nK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic tan.\n\nComputes the trigonometric tangent function of the supplied argument `a`.\n\nEquivalent to `(/ (sin a) (cos a))`."],null)),$APP.z(B_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic solve-linear.\n\nFor a given `a` and `b`, returns `x` such that `a*x \x3d b`.\n\n  See[[solve-linear-right]] for a similar function that solves for `a \x3d x*b`."],null)),$APP.z(K1b,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic freeze.\n\nFreezing an expression means removing wrappers and other metadata from\n  subexpressions, so that the result is basically a pure S-expression with the\n  same structure as the input. Doing this will rob an expression of useful\n  information for further computation; so this is intended to be done just\n  before simplification and printing, to simplify those processes."],null)),$APP.z($APP.CY,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic dimension"],null)),$APP.z(Fnb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic tanhc.\n\nThe [tanhc function](https://en.wikipedia.org/wiki/Tanhc_function),\n  equivalent to $\\frac{\\tanh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanhc_function)\n   - [Mathworld page on Tanhc](https://mathworld.wolfram.com/TanhcFunction.html)"],
null)),$APP.z(uH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic cos.\n\nReturns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`."],null)),$APP.z(kK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic gcd.\n\nReturns the [greatest common\n  divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the two\n  inputs `a` and `b`."],
null)),$APP.z(cdc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic exp10.\n\nReturns the base-10 exponential of `x`. Equivalent to `(expt 10 x)`."],null)),$APP.z(Icc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic cross-product"],null)),$APP.z($X,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic modulo.\n\nReturns the result of the\n  mathematical [Modulo](https://en.wikipedia.org/wiki/Modulo_operation)\n  operation between `a` and `b` (using the Knuth definition listed).\n\n The contract satisfied by [[modulo]] is:\n\n```clojure\n(\x3d a (+ (* b (floor (/ a b)))\n        (modulo a b)))\n```\n\n For numbers, this differs from the contract offered by [[remainder]]\n because `(floor (/ a b))` rounds toward negative infinity, while\n the [[quotient]] operation in the contract for [[remainder]] rounds toward 0.\n\n The result will be either `0` or of the same sign as the divisor `b`."],
null)),$APP.z($APP.sj,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))),$APP.P,"Generic implementation of `/`.\n\n  If one argument is supplied, returns the multiplicative inverse of `a`. Else\n  returns the result of dividing first argument `a` by the product of all\n  remaining arguments. `(/)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core//`. Dispatch is open,\n  however, making it possible to 'divide' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (/ [2 4 6] 2)\n  ;;\x3d\x3e (up 1 2 3)\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null,null)],null)],null)),$APP.z(avb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic exact?.\n\nEntries that are exact are available for `gcd`, among other operations."],null)),$APP.z(LQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic outer-product"],null)),$APP.z($APP.Ku,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic abs"],null)),$APP.z(jX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,
[$APP.Lv],null))),$APP.P,"generic invert.\n\nReturns the multiplicative inverse of `a`.\n\n  Equivalent to `(/ 1 a)`."],null)),$APP.z(IX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic dot-product"],null)),$APP.z(bU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic real-part"],null)),$APP.z(DJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],
null))),$APP.P,"generic log.\n\nReturns the natural logarithm of `x`."],null)),$APP.z(kS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic partial-derivative"],null)),$APP.z(wH,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic cosh.\n\nComputes the [hyperbolic\n cosine](https://mathworld.wolfram.com/HyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x + e^{-x}) / 2`."],
null)),$APP.z(vW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic coth.\n\nComputes the [hyperbolic\n cotangent](https://mathworld.wolfram.com/HyperbolicCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `cosh(x) / sinh(x)`."],null)),$APP.z(Lpb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic one-like.\n\nIn general, this procedure returns the multiplicative identity of the type of\n  its argument, if it exists. For numbers this is 1."],
null)),$APP.z(FJ,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(zW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic fractional-part.\n\nReturns the fractional part of the given value, defined as `x - ⌊x⌋`.\n\n  For positive numbers, this is identical to `(- a (integer-part a))`. For\n  negative `a`, because [[floor]] truncates toward negative infinity, you might\n  be surprised to find that [[fractional-part]] returns the distance between `a`\n  and the next-lowest integer:\n\n```clojure\n(\x3d 0.6 (fractional-part -0.4))\n```"],
null)),$APP.z(cY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic trace"],null)),$APP.z($APP.Iv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))),$APP.P,"Generic implementation of `+`. Returns the sum of all supplied arguments. `(+)`\n  returns 0, the additive identity.\n\n  When applied between numbers, acts like `clojure.core/+`. Dispatch is open,\n  however, making it possible to 'add' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (+ [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up 3 5 7)\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null,null)],null)],null)),$APP.z(NM,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic sec.\n\nComputes the secant of the supplied argument `a`.\n\nEquivalent to `(invert (cos a))`."],null)),$APP.z(RX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic negate.\n\nReturns the negation of `a`.\n\n  Equivalent to `(- (g/zero-like a) a)`."],null)),$APP.z(MEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic acoth.\n\nComputes the [inverse hyperbolic\n cotangent](https://mathworld.wolfram.com/InverseHyperbolicCotangent.html) of\n the supplied argument `a`.\n\ndefaults to `1/2 ln((x+1)/(x-1))`."],
null)),$APP.z(uT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic sech.\n\nComputes the [hyperbolic\n secant](https://mathworld.wolfram.com/HyperbolicSecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / cosh(x)`."],null)),$APP.z(Ynb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic log10.\n\nReturns the base-10 logarithm of `x`, i.e., $log_10(x)$."],null)),$APP.z(cT,new $APP.f(null,
1,[$APP.Ru,!0],null)),$APP.z(kQb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic exp2.\n\nReturns the base-2 exponential of `x`. Equivalent to `(expt 2 x)`."],null)),$APP.z(CK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic magnitude"],null)),$APP.z(LY,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z($APP.dw,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],
null))),$APP.P,"generic infinite?.\n\nReturns true if `a` is either numerically infinite (i.e., equal to `##Inf`) or\n  a compound number (complex or quaterion, for example) with some infinite\n  component."],null)),$APP.z(OM,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic cot.\n\nComputes the trigonometric cotangent function of the supplied argument `a`.\n\nEquivalent to `(invert (tan a))`, or `(/ (cos a) (sin a))`."],null)),$APP.z($APP.Hv,
new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))),$APP.P,'Generic implementation of `*`. Returns the product of all supplied\n  arguments. `(*)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core/*`. Dispatch is open,\n  however, making it possible to \'multiply\' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (* 2 #emmy/complex "3 + 1i")\n  ;;\x3d\x3e #emmy/complex "6 + 2i"\n  ```',
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null,null)],null)],null)),$APP.z(Nnb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic asec.\n\nComputes the [inverse\n secant](https://mathworld.wolfram.com/InverseSecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(sqrt(x^2 - 1))`."],null)),$APP.z(iDb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic solve-linear-right.\n\nFor a given `a` and `b`, returns `x` such that `a \x3d x*b`.\n\n  See[[solve-linear]] for a similar function that solves for `a*x \x3d b`."],
null)),$APP.z(vhb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic acsch.\n\nComputes the [inverse hyperbolic\n cosecant](https://mathworld.wolfram.com/InverseHyperbolicCosecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1+x^2)) / x)`."],null)),$APP.z(hqb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` is either:\n\n  - [[integral?]],\n  - a floating point number either \x3c [[absolute-integer-tolerance]] (if near\n    zero) or within [[relative-integer-tolerance]] of the closest integer,\n\n  false otherwise."],
null)),$APP.z(Etb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic log2.\n\nReturns the base-2 logarithm of `x`, i.e., $log_2(x)$."],null)),$APP.z($APP.Cv,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic zero?.\n\nIs true if `x` is an additive identity."],null)),$APP.z(jK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,2,5,
$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic atan.\n\nComputes the inverse tangent of the supplied argument `a`. Given two\n  arguments `a` and `b`, returns the inverse tangent of the angle formed by the\n  point `(b, a)` in a 2-dimensional euclidean plane.\n\n  The two-argument version is sometimes\n  called [Atan2](https://en.wikipedia.org/wiki/Atan2)."],null)),$APP.z(RV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic make-rectangular"],
null)),$APP.z(PM,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(FV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic lcm.\n\nReturns the [least common\n  multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of the two\n  inputs `a` and `b`."],null)),$APP.z(Ohb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic acsc.\n\nComputes the [inverse\n cosecant](https://mathworld.wolfram.com/InverseCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(1 / sqrt(x^2 - 1))`."],
null)),$APP.z(mK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic acos.\n\nComputes the inverse cosine of the supplied argument `a`.\n\nDefaults to `atan(sqrt(1-x^2)/x)`."],null)),$APP.z(ZS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic acot.\n\nComputes the [inverse\n cotangent](https://mathworld.wolfram.com/InverseCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `pi/2 - atan(x)`."],
null)),$APP.z(dT,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic floor.\n\nReturns the largest integer less than or equal to `a`.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail."],null)),$APP.z(jV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic imag-part"],
null)),$APP.z(cR,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic Lie-derivative"],null)),$APP.z(cgb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],null))),$APP.P,"Returns true if the supplied argument is an exact numerical zero, false\n  otherwise."],null)),$APP.z($APP.Jv,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,
$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))),$APP.P,"Generic implementation of `-`.\n\n  If one argument is supplied, returns the negation of `a`. Else returns the\n  difference of the first argument `a` and the sum of all remaining\n  arguments. `(-)` returns 0.\n\n  When applied between numbers, acts like `clojure.core/-`. Dispatch is open,\n  however, making it possible to 'subtract' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (- [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up -1 -1 -1)\n\n  (- [1 10])\n  ;;\x3d\x3e (up -1 -10)\n  ```",
$APP.ky,new $APP.f(null,6,[$APP.tu,!0,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,3,5,$APP.I,[$APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null)],null),$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null)),$APP.Cx,$APP.M(null,null,null,null)],null)],null)),$APP.z(pYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns `true` if `x` is both a [[number?]] and [[zero?]], false otherwise."],null)),$APP.z(tX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))),$APP.P,"generic inner-product"],null)),$APP.z(qV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic acosh.\n\nComputes the [inverse hyperbolic\n cosine](https://mathworld.wolfram.com/InverseHyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `2 ln(sqrt((x+1)/2) + sqrt((x-1)/2))`."],
null)),$APP.z(lY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic ceiling.\n\nReturns the result of rounding `a` up to the next largest integer.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail."],null)),$APP.z(I$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,
"generic sinc.\n\nThe unnormalized [sinc\n  function](https://en.wikipedia.org/wiki/Sinc_function), equivalent to\n  $\\frac{\\sin x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/SincFunction.html)\n   - [Boost notes on [[sinc]]\n     and [[sinch]]](https://www.boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sinc/sinc_overview.html)"],
null)),$APP.z(pY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic conjugate"],null)),$APP.z(N_b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic sinhc.\n\nThe [sinhc function](https://en.wikipedia.org/wiki/Sinhc_function),\n  equivalent to $\\frac{\\sinh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinhc_function)\n   - [Mathworld page on Sinhc](https://mathworld.wolfram.com/SinhcFunction.html)"],
null)),$APP.z(HJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic sqrt"],null)),$APP.z(O3b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic asech.\n\nComputes the [inverse hyperbolic\n secant](https://mathworld.wolfram.com/InverseHyperbolicSecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1-x^2)) / x)`."],null)),$APP.z(lK,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic asin.\n\nComputes the inverse sine of the supplied argument `a`.\n\nDefaults to `atan(x/sqrt(1-x^2))`."],null)),$APP.z($APP.XX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic transpose"],null)),$APP.z(BJ,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic exp.\n\nReturns the base-e exponential of `x`. Equivalent to `(expt e x)`, given\n  some properly-defined `e` symbol."],
null)),$APP.z(AX,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(YV,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(hW,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic asinh.\n\nComputes the [inverse hyperbolic\n sine](https://mathworld.wolfram.com/InverseHyperbolicSine.html) of the\n supplied argument `a`.\n\ndefaults to `ln(x + sqrt(1 + x^2))`."],null)),$APP.z(qX,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],
null))),$APP.P,"generic tanh.\n\nComputes the [hyperbolic\n tangent](https://mathworld.wolfram.com/HyperbolicTangent.html) of the supplied\n argument `a`.\n\ndefaults to `sinh(x) / cosh(x)`."],null)),$APP.z(lS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic identity?.\n\nLike `one?`, but this is true of square identity matrices as well.\n  No matrix is considered `one?` because its function as a multiplicative\n  identity depends on the shape of the other multiplicand."],
null)),$APP.z(wcc,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic zero-like.\n\nIn general, this procedure returns the additive identity of the type of its\n  argument, if it exists. For numbers this is 0."],null)),$APP.z(EY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic angle"],null)),$APP.z(bS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],
null))),$APP.P,"generic simplify"],null)),$APP.z(HV,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic atanh.\n\nComputes the [inverse hyperbolic\n tangent](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) of the\n supplied argument `a`.\n\ndefaults to `1/2 ln((1+x)/(1-x))`."],null)),$APP.z(x$b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))),$APP.P,"generic one?.\n\nIs true if `x` is a multiplicative identity."],
null))],[new $APP.f(null,3,[$APP.Q,k6b,$APP.X,sI,$APP.h,new $APP.f(null,2,[$APP.P,"generic quotient",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,KLb,$APP.X,LSa,$APP.h,new $APP.f(null,2,[$APP.P,"Alias for [[solve-linear]]; present for compatibility with the original\n  `scmutils` codebase.\n\n  NOTE: In `scmutils`, `solve-linear-left` and `solve-linear` act identically in\n  all cases except matrices. `solve-linear-left` only accepted a column\n  matrix (or up structure) in the `b` position, while `solve-linear` accepted\n  either a column or row (up or down structure).\n\n  In Emmy, both functions accept either type.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,w9b,$APP.X,CG,$APP.h,new $APP.f(null,2,[$APP.P,"generic remainder.\n\nReturns the remainder of dividing the dividend `a` by divisor `b`.\n\n The contract satisfied by [[remainder]] is:\n\n```clojure\n(\x3d a (+ (* b (quotient a b))\n        (remainder a b)))\n```\n\n For numbers, this differs from the contract offered by [[modulo]]\n because [[quotient]] rounds toward 0, while `(floor (/ a b))` rounds toward\n negative infinity.\n\n The result will be either `0` or of the same sign as the dividend `a`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,i4b,$APP.X,lZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic identity-like.\n\nLike `one-like` but works for square matrices.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,b9b,$APP.X,GZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic csch.\n\nComputes the [hyperbolic\n cosecant](https://mathworld.wolfram.com/HyperbolicCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / sinh(x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,gcc,$APP.X,QZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic make-polar",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,q_b,$APP.X,qZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic cube",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,uLb,$APP.X,NZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic tanc.\n\n`tanc` is defined, by analogy with [[sinc]], to be equal to $\\frac{\\tan\n  x}{x}$ for nonzero $x$ and equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/TancFunction.html)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xqb,$APP.X,aR,$APP.h,new $APP.f(null,2,[$APP.P,"generic determinant",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,fJb,$APP.X,xH,$APP.h,new $APP.f(null,2,[$APP.P,"generic sinh.\n\nComputes the [hyperbolic\n sine](https://mathworld.wolfram.com/HyperbolicSine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x - e^{-x}) / 2`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,r_b,$APP.X,SF,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,pib,$APP.X,iO,$APP.h,new $APP.f(null,2,[$APP.P,"generic sin.\n\nReturns the [sine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,l2b,$APP.X,kM,$APP.h,new $APP.f(null,2,[$APP.P,"generic exact-divide.\n\nSimilar to the binary case of [[/]], but throws if `(g/exact? \x3cresult\x3e)`\n  returns false.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,OBb,$APP.X,vZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic tan.\n\nComputes the trigonometric tangent function of the supplied argument `a`.\n\nEquivalent to `(/ (sin a) (cos a))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xbc,$APP.X,XF,$APP.h,new $APP.f(null,2,[$APP.P,"generic solve-linear.\n\nFor a given `a` and `b`, returns `x` such that `a*x \x3d b`.\n\n  See[[solve-linear-right]] for a similar function that solves for `a \x3d x*b`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,LUb,$APP.X,cG,$APP.h,new $APP.f(null,2,[$APP.P,"generic freeze.\n\nFreezing an expression means removing wrappers and other metadata from\n  subexpressions, so that the result is basically a pure S-expression with the\n  same structure as the input. Doing this will rob an expression of useful\n  information for further computation; so this is intended to be done just\n  before simplification and printing, to simplify those processes.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Xcb,$APP.X,NO,$APP.h,new $APP.f(null,2,[$APP.P,"generic dimension",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,cfb,$APP.X,OZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic tanhc.\n\nThe [tanhc function](https://en.wikipedia.org/wiki/Tanhc_function),\n  equivalent to $\\frac{\\tanh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Tanhc_function)\n   - [Mathworld page on Tanhc](https://mathworld.wolfram.com/TanhcFunction.html)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,RDb,$APP.X,hO,$APP.h,new $APP.f(null,2,[$APP.P,"generic cos.\n\nReturns the [cosine](https://en.wikipedia.org/wiki/Sine_and_cosine) of the\n  supplied argument `a`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ZTb,$APP.X,yM,$APP.h,new $APP.f(null,2,[$APP.P,"generic gcd.\n\nReturns the [greatest common\n  divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of the two\n  inputs `a` and `b`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,sJb,$APP.X,nZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic exp10.\n\nReturns the base-10 exponential of `x`. Equivalent to `(expt 10 x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,c5b,$APP.X,VZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic cross-product",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,
3,[$APP.Q,xlb,$APP.X,nI,$APP.h,new $APP.f(null,2,[$APP.P,"generic modulo.\n\nReturns the result of the\n  mathematical [Modulo](https://en.wikipedia.org/wiki/Modulo_operation)\n  operation between `a` and `b` (using the Knuth definition listed).\n\n The contract satisfied by [[modulo]] is:\n\n```clojure\n(\x3d a (+ (* b (floor (/ a b)))\n        (modulo a b)))\n```\n\n For numbers, this differs from the contract offered by [[remainder]]\n because `(floor (/ a b))` rounds toward negative infinity, while\n the [[quotient]] operation in the contract for [[remainder]] rounds toward 0.\n\n The result will be either `0` or of the same sign as the divisor `b`.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ypb,$APP.X,SF,$APP.h,new $APP.f(null,2,[$APP.P,"Generic implementation of `/`.\n\n  If one argument is supplied, returns the multiplicative inverse of `a`. Else\n  returns the result of dividing first argument `a` by the product of all\n  remaining arguments. `(/)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core//`. Dispatch is open,\n  however, making it possible to 'divide' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (/ [2 4 6] 2)\n  ;;\x3d\x3e (up 1 2 3)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,plb,$APP.X,VF,$APP.h,new $APP.f(null,2,[$APP.P,"generic exact?.\n\nEntries that are exact are available for `gcd`, among other operations.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,qtb,$APP.X,UZ,$APP.h,new $APP.f(null,2,
[$APP.P,"generic outer-product",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Wcb,$APP.X,jG,$APP.h,new $APP.f(null,2,[$APP.P,"generic abs",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,EGb,$APP.X,QF,$APP.h,new $APP.f(null,2,[$APP.P,"generic invert.\n\nReturns the multiplicative inverse of `a`.\n\n  Equivalent to `(/ 1 a)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],
null),new $APP.f(null,3,[$APP.Q,Y8b,$APP.X,DH,$APP.h,new $APP.f(null,2,[$APP.P,"generic dot-product",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kkb,$APP.X,zH,$APP.h,new $APP.f(null,2,[$APP.P,"generic real-part",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vbc,$APP.X,rG,$APP.h,new $APP.f(null,2,[$APP.P,"generic log.\n\nReturns the natural logarithm of `x`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ODb,$APP.X,oR,$APP.h,new $APP.f(null,2,[$APP.P,"generic partial-derivative",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,mXb,$APP.X,vH,$APP.h,new $APP.f(null,2,[$APP.P,"generic cosh.\n\nComputes the [hyperbolic\n cosine](https://mathworld.wolfram.com/HyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `(e^x + e^{-x}) / 2`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,xXb,$APP.X,FZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic coth.\n\nComputes the [hyperbolic\n cotangent](https://mathworld.wolfram.com/HyperbolicCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `cosh(x) / sinh(x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,dib,$APP.X,PF,$APP.h,new $APP.f(null,2,[$APP.P,"generic one-like.\n\nIn general, this procedure returns the multiplicative identity of the type of\n  its argument, if it exists. For numbers this is 1.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,p9b,$APP.X,tI,$APP.h,new $APP.f(null,2,[$APP.P,"generic expt",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,SQb,$APP.X,uZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic fractional-part.\n\nReturns the fractional part of the given value, defined as `x - ⌊x⌋`.\n\n  For positive numbers, this is identical to `(- a (integer-part a))`. For\n  negative `a`, because [[floor]] truncates toward negative infinity, you might\n  be surprised to find that [[fractional-part]] returns the distance between `a`\n  and the next-lowest integer:\n\n```clojure\n(\x3d 0.6 (fractional-part -0.4))\n```",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Tlb,$APP.X,SZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic trace",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,$pb,$APP.X,mG,$APP.h,new $APP.f(null,2,[$APP.P,"Generic implementation of `+`. Returns the sum of all supplied arguments. `(+)`\n  returns 0, the additive identity.\n\n  When applied between numbers, acts like `clojure.core/+`. Dispatch is open,\n  however, making it possible to 'add' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (+ [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up 3 5 7)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ogb,$APP.X,yZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic sec.\n\nComputes the secant of the supplied argument `a`.\n\nEquivalent to `(invert (cos a))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ykb,$APP.X,RF,$APP.h,new $APP.f(null,
2,[$APP.P,"generic negate.\n\nReturns the negation of `a`.\n\n  Equivalent to `(- (g/zero-like a) a)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,p1b,$APP.X,KZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acoth.\n\nComputes the [inverse hyperbolic\n cotangent](https://mathworld.wolfram.com/InverseHyperbolicCotangent.html) of\n the supplied argument `a`.\n\ndefaults to `1/2 ln((x+1)/(x-1))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],
null)],null),new $APP.f(null,3,[$APP.Q,Bpb,$APP.X,EZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic sech.\n\nComputes the [hyperbolic\n secant](https://mathworld.wolfram.com/HyperbolicSecant.html) of the supplied\n argument `a`.\n\ndefaults to `1 / cosh(x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,fdb,$APP.X,pZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic log10.\n\nReturns the base-10 logarithm of `x`, i.e., $log_10(x)$.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vzb,$APP.X,nG,$APP.h,new $APP.f(null,2,[$APP.P,"generic square",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,$9b,$APP.X,mZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic exp2.\n\nReturns the base-2 exponential of `x`. Equivalent to `(expt 2 x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,mQb,$APP.X,zG,$APP.h,new $APP.f(null,2,[$APP.P,
"generic magnitude",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,zHb,$APP.X,BG,$APP.h,new $APP.f(null,2,[$APP.P,"generic div.\n\nReturns the result of dividing `a` and `b`.\n\n  Equivalent to `(* a (negate b))`.\n\n  See [[/]] for a variadic version of [[div]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,X2b,$APP.X,oG,$APP.h,new $APP.f(null,2,[$APP.P,"generic infinite?.\n\nReturns true if `a` is either numerically infinite (i.e., equal to `##Inf`) or\n  a compound number (complex or quaterion, for example) with some infinite\n  component.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,SDb,$APP.X,wZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic cot.\n\nComputes the trigonometric cotangent function of the supplied argument `a`.\n\nEquivalent to `(invert (tan a))`, or `(/ (cos a) (sin a))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Zpb,$APP.X,kG,$APP.h,new $APP.f(null,2,[$APP.P,'Generic implementation of `*`. Returns the product of all supplied\n  arguments. `(*)` returns 1, the multiplicative identity.\n\n  When applied between numbers, acts like `clojure.core/*`. Dispatch is open,\n  however, making it possible to \'multiply\' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (* 2 #emmy/complex "3 + 1i")\n  ;;\x3d\x3e #emmy/complex "6 + 2i"\n  ```',
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,abb,$APP.X,BZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic asec.\n\nComputes the [inverse\n secant](https://mathworld.wolfram.com/InverseSecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(sqrt(x^2 - 1))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],
null)],null),new $APP.f(null,3,[$APP.Q,xdb,$APP.X,eR,$APP.h,new $APP.f(null,2,[$APP.P,"generic solve-linear-right.\n\nFor a given `a` and `b`, returns `x` such that `a \x3d x*b`.\n\n  See[[solve-linear]] for a similar function that solves for `a*x \x3d b`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,Yhb,$APP.X,MZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acsch.\n\nComputes the [inverse hyperbolic\n cosecant](https://mathworld.wolfram.com/InverseHyperbolicCosecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1+x^2)) / x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Jlb,$APP.X,UF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` is either:\n\n  - [[integral?]],\n  - a floating point number either \x3c [[absolute-integer-tolerance]] (if near\n    zero) or within [[relative-integer-tolerance]] of the closest integer,\n\n  false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,m5b,$APP.X,oZ,$APP.h,new $APP.f(null,
2,[$APP.P,"generic log2.\n\nReturns the base-2 logarithm of `x`, i.e., $log_2(x)$.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,n3b,$APP.X,MF,$APP.h,new $APP.f(null,2,[$APP.P,"generic zero?.\n\nIs true if `x` is an additive identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mfb,$APP.X,tG,$APP.h,new $APP.f(null,2,[$APP.P,"generic atan.\n\nComputes the inverse tangent of the supplied argument `a`. Given two\n  arguments `a` and `b`, returns the inverse tangent of the angle formed by the\n  point `(b, a)` in a 2-dimensional euclidean plane.\n\n  The two-argument version is sometimes\n  called [Atan2](https://en.wikipedia.org/wiki/Atan2).",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null),new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,MMb,$APP.X,PZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic make-rectangular",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,MFb,$APP.X,xZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic csc.\n\nComputes the cosecant of the supplied argument `a`.\n\nEquivalent to `(invert (sin a))`.",$APP.U,$APP.M(new $APP.H(null,
1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,nbc,$APP.X,qM,$APP.h,new $APP.f(null,2,[$APP.P,"generic lcm.\n\nReturns the [least common\n  multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of the two\n  inputs `a` and `b`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,wCb,$APP.X,CZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acsc.\n\nComputes the [inverse\n cosecant](https://mathworld.wolfram.com/InverseCosecant.html) of the supplied\n argument `a`.\n\ndefaults to `atan(1 / sqrt(x^2 - 1))`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,XCb,$APP.X,mO,$APP.h,new $APP.f(null,2,[$APP.P,"generic acos.\n\nComputes the inverse cosine of the supplied argument `a`.\n\nDefaults to `atan(sqrt(1-x^2)/x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,bDb,$APP.X,AZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acot.\n\nComputes the [inverse\n cotangent](https://mathworld.wolfram.com/InverseCotangent.html) of the supplied\n argument `a`.\n\ndefaults to `pi/2 - atan(x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Ahb,$APP.X,rZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic floor.\n\nReturns the largest integer less than or equal to `a`.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,G1b,$APP.X,
CH,$APP.h,new $APP.f(null,2,[$APP.P,"generic imag-part",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Htb,$APP.X,dR,$APP.h,new $APP.f(null,2,[$APP.P,"generic Lie-derivative",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vwb,$APP.X,WF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied argument is an exact numerical zero, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.wU],
null))],null)],null),new $APP.f(null,3,[$APP.Q,Xpb,$APP.X,TF,$APP.h,new $APP.f(null,2,[$APP.P,"Generic implementation of `-`.\n\n  If one argument is supplied, returns the negation of `a`. Else returns the\n  difference of the first argument `a` and the sum of all remaining\n  arguments. `(-)` returns 0.\n\n  When applied between numbers, acts like `clojure.core/-`. Dispatch is open,\n  however, making it possible to 'subtract' types wherever the behavior is\n  mathematically sound.\n\n  For example:\n\n  ```clojure\n  (- [1 2 3] [2 3 4])\n  ;;\x3d\x3e (up -1 -1 -1)\n\n  (- [1 10])\n  ;;\x3d\x3e (up -1 -10)\n  ```",
$APP.U,$APP.M($APP.sf,new $APP.H(null,1,5,$APP.I,[$APP.Yv],null),new $APP.H(null,2,5,$APP.I,[$APP.Yv,$APP.UP],null),new $APP.H(null,4,5,$APP.I,[$APP.Yv,$APP.UP,$APP.Lh,$APP.Zw],null))],null)],null),new $APP.f(null,3,[$APP.Q,KKb,$APP.X,NF,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `x` is both a [[number?]] and [[zero?]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,QMb,$APP.X,TZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic inner-product",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Lv,$APP.sU],null))],null)],null),new $APP.f(null,3,[$APP.Q,l1b,$APP.X,HZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic acosh.\n\nComputes the [inverse hyperbolic\n cosine](https://mathworld.wolfram.com/InverseHyperbolicCosine.html) of the supplied\n argument `a`.\n\ndefaults to `2 ln(sqrt((x+1)/2) + sqrt((x-1)/2))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,IGb,$APP.X,tZ,$APP.h,new $APP.f(null,2,[$APP.P,
"generic ceiling.\n\nReturns the result of rounding `a` up to the next largest integer.\n\n  Extensions beyond real numbers may behave differently; see the [Documentation\n  site](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)\n  for more detail.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,iJb,$APP.X,tR,$APP.h,new $APP.f(null,2,[$APP.P,"generic sinc.\n\nThe unnormalized [sinc\n  function](https://en.wikipedia.org/wiki/Sinc_function), equivalent to\n  $\\frac{\\sin x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinc_function)\n   - [Mathworld page on Sinc](https://mathworld.wolfram.com/SincFunction.html)\n   - [Boost notes on [[sinc]]\n     and [[sinch]]](https://www.boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sinc/sinc_overview.html)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Arb,$APP.X,sL,$APP.h,new $APP.f(null,2,[$APP.P,"generic conjugate",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,zzb,$APP.X,vR,$APP.h,new $APP.f(null,2,[$APP.P,"generic sinhc.\n\nThe [sinhc function](https://en.wikipedia.org/wiki/Sinhc_function),\n  equivalent to $\\frac{\\sinh x}{x}$ but defined to be equal to 1 at $x \x3d 0$.\n\n  ### References\n\n   - [Wikipedia page](https://en.wikipedia.org/wiki/Sinhc_function)\n   - [Mathworld page on Sinhc](https://mathworld.wolfram.com/SinhcFunction.html)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,r8b,$APP.X,lG,$APP.h,new $APP.f(null,2,[$APP.P,"generic sqrt",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ewb,$APP.X,LZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic asech.\n\nComputes the [inverse hyperbolic\n secant](https://mathworld.wolfram.com/InverseHyperbolicSecant.html) of the\n supplied argument `a`.\n\ndefaults to `ln((1 + sqrt(1-x^2)) / x)`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Kcb,$APP.X,zZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic asin.\n\nComputes the inverse sine of the supplied argument `a`.\n\nDefaults to `atan(x/sqrt(1-x^2))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Avb,$APP.X,gR,$APP.h,new $APP.f(null,2,[$APP.P,"generic transpose",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,
3,[$APP.Q,ywb,$APP.X,qG,$APP.h,new $APP.f(null,2,[$APP.P,"generic exp.\n\nReturns the base-e exponential of `x`. Equivalent to `(expt e x)`, given\n  some properly-defined `e` symbol.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,iSb,$APP.X,sG,$APP.h,new $APP.f(null,2,[$APP.P,"generic negative?.\n\nReturns true if the argument `a` is less than `(g/zero-like a)`,\n  false otherwise. The default implementation depends on a proper Comparable\n  implementation on the type.`",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,qbb,$APP.X,sZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic integer-part.\n\nReturns the integer part of `a` by removing any fractional digits.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,DOb,$APP.X,IZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic asinh.\n\nComputes the [inverse hyperbolic\n sine](https://mathworld.wolfram.com/InverseHyperbolicSine.html) of the\n supplied argument `a`.\n\ndefaults to `ln(x + sqrt(1 + x^2))`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,FKb,$APP.X,DZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic tanh.\n\nComputes the [hyperbolic\n tangent](https://mathworld.wolfram.com/HyperbolicTangent.html) of the supplied\n argument `a`.\n\ndefaults to `sinh(x) / cosh(x)`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,vDb,$APP.X,kZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic identity?.\n\nLike `one?`, but this is true of square identity matrices as well.\n  No matrix is considered `one?` because its function as a multiplicative\n  identity depends on the shape of the other multiplicand.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,bFb,$APP.X,vG,$APP.h,new $APP.f(null,2,[$APP.P,"generic zero-like.\n\nIn general, this procedure returns the additive identity of the type of its\n  argument, if it exists. For numbers this is 0.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Cub,$APP.X,RZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic angle",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],
null))],null)],null),new $APP.f(null,3,[$APP.Q,j6b,$APP.X,dG,$APP.h,new $APP.f(null,2,[$APP.P,"generic simplify",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Udc,$APP.X,JZ,$APP.h,new $APP.f(null,2,[$APP.P,"generic atanh.\n\nComputes the [inverse hyperbolic\n tangent](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) of the\n supplied argument `a`.\n\ndefaults to `1/2 ln((1+x)/(1-x))`.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],
null))],null)],null),new $APP.f(null,3,[$APP.Q,nJb,$APP.X,uG,$APP.h,new $APP.f(null,2,[$APP.P,"generic one?.\n\nIs true if `x` is a multiplicative identity.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Lv],null))],null)],null)]),$APP.ap(XYb)),$APP.cp($APP.fg([dKb,$APP.z(Afb,new $APP.f(null,3,[$APP.Pm,oW,$APP.P,"Returns a coordinate representation of the supplied manifold point `point`,\n    as specified by this [[ICoordinateSystem]].",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,
$APP.hU],null)))],null)),UUb,Kwb,NHb,Qwb,$APP.z(d$b,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,10,5,$APP.I,[yhb,IV,XU,$APP.wU,aS,$APP.wx,uY,QT,pU,Uxb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57440."],null)),$APP.z($APP.hU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),$APP.P,"Given an [[ICoordinateSystem]], returns a function from coordinates in\n  `coordinate-system`'s repesentation to the matching point on the manifold\n  associated with `coordinate-system`."],null)),zwb,$APP.z(ZBb,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[dV],null),$APP.z(new $APP.H(null,2,5,$APP.I,[dV,fW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.kpa,new $APP.ug(null,new $APP.f(null,
3,[$APP.M($APP.K,PN),"null",$APP.M($APP.K,i$b),"null",$APP.M($APP.K,mX),"null"],null),null),fW)],null)],null)))),$APP.P,"Generates a manifold family (a template for building manifolds) from the\n  supplied `name-format`.\n\n  Generated manifolds locally resemble Euclidean space (Rn) by default. You can\n  optionally pass `'Complex` or `'Quaternion` to `over` to customize the field\n  of the vector space that the manifold locally resembles at each point.\n\n  NOTE: only `'Real` does anything as of 3.15.2021.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,2,$APP.qw,2,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[dV],null),new $APP.H(null,2,5,$APP.I,[dV,fW],null)],null),$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[dV],null),new $APP.H(null,2,5,$APP.I,[dV,fW],null)),$APP.Cx,$APP.M(null,null)],null)],null)),r0b,FVb,$APP.z(pU,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[mT],null))),$APP.P,"Returns the symbolic coordinate prototype associated with `coordsys`. This is\n   a structure of the correct dimension for this coordinate system, with all\n   symbolic entries.\n\n  Returns nil for non-valid inputs."],
null)),mdb,$APP.z(Y9b,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[aS,pU,$APP.wx,Byb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57410."],null)),P1b,$APP.z(qXb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[tKb,K9b],null))),
$APP.P,"Returns a function that takes a single manifold `point` embedded in the\n  manifold `embedded` and transfers the point to the supplied `embedding`\n  manifold.\n\n  The embedding dimension must be the same for both manifolds.\n\n  NOTE that `embedded` and `embedding` can be either manifolds, or instances\n  of [[ICoordinateSystem]]. In the latter case `embedded` and `embedding` will\n  bind to the manifold associated with the supplied [[ICoordinateSystem]]."],null)),$APP.z(EVb,new $APP.f(null,
2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.hU],null))),$APP.P,"Returns the backing Euclidean space representation of the supplied manifold\n  point."],null)),$APP.z(c$b,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,9,5,$APP.I,[XU,IV,aS,pU,$APP.wU,QT,uY,$APP.wx,Qxb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57448."],
null)),$wb,$APP.z(ePb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[iIb,qW,gY],null))),$APP.P,"Returns the representation of `manifold-point` in `coordinate-system`.\n\n  If an entry for the given `coordinate-system` is not found, `thunk` is called\n  to produce the representation. The representation is cached in the point."],null)),edb,Slb,$APP.z(J5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns `true` if `m` is a dictionary representing a manifold, false\n  otherwise."],
null)),$APP.z($APP.zx,new $APP.f(null,1,[$APP.Ru,!0],null)),$APP.z(Idb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[$APP.wU,oU,$APP.Nv],null))),$APP.P,"Generates a coordinate structure of the supplied dimension `n`, and\n  `orientation` using the supplied function `f` for entries. See the very\n  similar [[emmy.structure/generate]] for more details.\n\n  NOTE from GJS: this is a kludge introduced only to allow a coordinate of\n  dimension 1 to automatically unwrap itself."],
null)),$APP.z(E1b,new $APP.f(null,3,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wV,$APP.wU],null),$APP.z(new $APP.H(null,3,5,$APP.I,[wV,$APP.wU,vX],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,3,5,$APP.I,[$APP.M($APP.qsa,$APP.wU),$APP.M($APP.aw,$APP.wU,0),$APP.M($APP.cw,vX,$APP.wU)],null)],null)))),$APP.P,"Returns a concrete manifold generated by specializing the supplied manifold\n  `family` into a concrete manifold of dimension `n`. `n` must be a positive\n  integer.\n\n  Optionally takes an `embedding-dimension`; this must be \x3e\x3d the value of `n`.\n  Use this in cases like an n-sphere embedded in a euclidean space of dimension\n  n+1.\n\n  A [manifold](https://en.wikipedia.org/wiki/Manifold) is a topological space\n  that locally resembles Euclidean space near each point.",
$APP.ky,new $APP.f(null,6,[$APP.tu,!1,$APP.Un,3,$APP.qw,3,$APP.wy,new $APP.H(null,2,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[wV,$APP.wU],null),new $APP.H(null,3,5,$APP.I,[wV,$APP.wU,vX],null)],null),$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wV,$APP.wU],null),new $APP.H(null,3,5,$APP.I,[wV,$APP.wU,vX],null)),$APP.Cx,$APP.M(null,null)],null)],null)),jrb,$APP.z(qPb,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,
2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[aS,pU,$APP.wx,lTb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57394."],null)),$APP.z(jRb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[wV,iW],null))),$APP.P,"Takes a manifold `family` and attaches a patch template with the supplied\n  `patch-name`. Returns a new manifold family.\n\n  All manifolds generated from the returned family will have this coordinate\n  patch attached."],
null)),$APP.z(FY,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))),$APP.P,"Returns true if `p` is a manifold point, false otherwise."],null)),$APP.z(bxb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[wV,VX,iW,ubc],null))),$APP.P,"Returns a new manifold family generated by attaching the supplied coordinate\n  system constructor to `family`, indexed by the supplied patch and coordinate\n  system names."],null)),OYb,$qb,$APP.z(t8b,
new $APP.f(null,3,[$APP.Pm,oW,$APP.P,"Returns the manifold point on this [[ICoordinateSystem]]'s manifold\n    corresponding to the supplied `coords`.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)))],null)),$APP.z(U9b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,3,5,$APP.I,[aS,VX,iW],null))),$APP.P,"Returns an [[ICoordinateSystem]] instance specialized to the patch named\n  `patch-name` on `manifold`."],null)),$APP.z(R9b,new $APP.f(null,6,[nE,!0,
XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[aS,pU,$APP.wx,pyb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57421."],null)),$APP.z(TPb,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,
2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,4,5,$APP.I,[aS,pU,$APP.wx,Kyb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57399."],null)),Z$b,oOb,pDb,$APP.z(e8b,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,
[aS,pU,$APP.wU,$APP.wx,uxb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57471."],null)),$APP.z(aS,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"If `m` is a manifold, acts as identity. Else, if given some structure\n  associated with a manifold (like a coordinate system), returns the associated\n  manifold."],null)),$APP.z(nLb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,
1,5,$APP.I,[$APP.hU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(FY,$APP.hU)],null)],null)))),$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 0."],null)),$APP.z(vGb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.hU],null))),$APP.P,"Return the manifold upon which this `point` was defined."],null)),n7b,ugb,$APP.z(rsb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.hU],
null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(FY,$APP.hU)],null)],null)))),$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 1."],null)),$APP.z(k$b,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,7,5,$APP.I,[oU,kLb,IV,aS,pU,$APP.wx,jyb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57430."],
null)),$APP.z(rAb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),$APP.P,"Given an [[ICoordinateSystem]], returns a unique, symbolically-represented\n  point on the manifold associated with `coordinate-system`.\n\n  See [[typical-coords]] for a coordinate-based version of this function."],null)),m3b,$APP.z(gYb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null))),$APP.P,"Takes a coordinate representation `coords` of a manifold point with all\n  symbolic entries, and returns a structure of the same shape with `v:`\n  prepended to all symbols.\n\n  This structure is appropriate for representing the velocities associated with\n  each coordinate."],
null)),$APP.z(z7b,new $APP.f(null,3,[$APP.Pm,oW,$APP.P,"Returns true if the supplied coordinates `coords` can be converted into a\n    point by this [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)))],null)),$APP.z(TWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))),$APP.P,"Returns `true` if `m` is a dictionary representing a manifold family, false\n  otherwise."],null)),qsb,$APP.z(S2b,
new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),$APP.P,"Given an [[ICoordinateSystem]], returns a structure that matches\n  the [[coordinate-prototype]] of `coordinate-system`, with all unique,\n  gensym-ed entries.\n\n  Use [[typical-coords]] if you require a unique symbolic coordinate\n  representation compatible with `coordinate-system`.\n\n  See [[typical-point]] for a coordinate-free version of this function."],null)),aAb,$APP.z(GPb,new $APP.f(null,2,[$APP.U,
$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[aS],null))),$APP.P,"The supplied manifold `m` locally resembles some vector space; this function\n  returns the field over which that vector space was specified."],null)),i0b,Jib,rjb,Bwb,G$b,Ewb,w2b,Awb,FMb,YZb,$APP.z(H5b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))),$APP.P,"Returns true if `x` implements [[ICoordinateSystem]], false otherwise."],null)),RJb,ZVb,$APP.z(m8b,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,
new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,5,5,$APP.I,[aS,pU,$APP.wU,$APP.wx,Dxb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57463."],null)),pVb,$APP.z(s8b,new $APP.f(null,6,[nE,!0,XE,new $APP.ug(null,new $APP.f(null,3,[oW,"null",nS,"null",pT,"null"],null),null),YR,new $APP.ug(null,new $APP.f(null,2,[nS,
"null",pT,"null"],null),null),$APP.ow,UT,$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,9,5,$APP.I,[XU,IV,aS,pU,$APP.wU,QT,uY,$APP.wx,Kxb],null))),$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57458."],null)),$APP.z(HEb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))),$APP.P,"Given an [[ICoordinateSystem]], returns a function from a point on the\n  coordinate system's manifold to the coordinate representation specified by the\n  supplied `coordinate-system`."],
null)),$APP.z(Xib,new $APP.f(null,4,[FE,!0,fS,new $APP.f(null,1,[$APP.Om,new $APP.f(null,5,[$APP.z(z7b,new $APP.f(null,1,[$APP.P,"Returns true if the supplied coordinates `coords` can be converted into a\n    point by this [[ICoordinateSystem]], false otherwise."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)],null),$APP.z($Ob,new $APP.f(null,1,[$APP.P,"Returns true if the supplied `point` can be converted into coordinates by\n    this [[ICoordinateSystem]], false otherwise."],
null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.hU],null)],null),$APP.z(t8b,new $APP.f(null,1,[$APP.P,"Returns the manifold point on this [[ICoordinateSystem]]'s manifold\n    corresponding to the supplied `coords`."],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)],null),$APP.z(Afb,new $APP.f(null,1,[$APP.P,"Returns a coordinate representation of the supplied manifold point `point`,\n    as specified by this [[ICoordinateSystem]]."],
null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.hU],null)],null),$APP.z($APP.zx,new $APP.f(null,1,[$APP.P,"Returns a unique identifier for this instance of [[ICoordinateSystem]].\n\n    (This is an internal implementation detail to allow us to attach coordinate\n    prototypes and other items as metadata to an [[ICoordinateSystem]] without\n    affecting equality.)"],null)),new $APP.H(null,1,5,$APP.I,[new $APP.H(null,1,5,$APP.I,[$APP.Su],null)],null)],null)],null),$APP.Ov,
new $APP.f(null,5,[adc,new $APP.f(null,3,[$APP.Q,z7b,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)),$APP.P,"Returns true if the supplied coordinates `coords` can be converted into a\n    point by this [[ICoordinateSystem]], false otherwise."],null),ieb,new $APP.f(null,3,[$APP.Q,$Ob,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.hU],null)),$APP.P,"Returns true if the supplied `point` can be converted into coordinates by\n    this [[ICoordinateSystem]], false otherwise."],
null),$Ub,new $APP.f(null,3,[$APP.Q,t8b,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null)),$APP.P,"Returns the manifold point on this [[ICoordinateSystem]]'s manifold\n    corresponding to the supplied `coords`."],null),Pub,new $APP.f(null,3,[$APP.Q,Afb,$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.hU],null)),$APP.P,"Returns a coordinate representation of the supplied manifold point `point`,\n    as specified by this [[ICoordinateSystem]]."],null),Tac,new $APP.f(null,3,[$APP.Q,
$APP.zx,$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Su],null)),$APP.P,"Returns a unique identifier for this instance of [[ICoordinateSystem]].\n\n    (This is an internal implementation detail to allow us to attach coordinate\n    prototypes and other items as metadata to an [[ICoordinateSystem]] without\n    affecting equality.)"],null)],null),gU,$APP.M("@interface")],null)),$APP.z(zNb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,qW],null))),$APP.P,"Given a symbolic name `sym` and an [[ICoordinateSystem]], returns a literal\n  function that maps coordinate-free manifold points to a scalar output.\n\n  Also aliased as [[literal-manifold-function]]."],
null)),Evb,xwb,$APP.z(USb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[aS,iW],null))),$APP.P,"Returns the patch named by `patch-name` within the supplied `manifold` if\n  registered. Throws otherwise.\n\n  NOTE that the returned patch will keep a reference to the supplied `manifold`\n  under a `:manifold` key.\n\n  A coordinate patch is a simply-connected open set around a point in the\n  manifold. A manifold might have many patches. Coordinate systems are defined\n  on patches; these allow the parameterization of any point on the patch in\n  terms of a tuple of real numbers (the coordinates)."],
null)),JFb,n6b,$APP.z(zcb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[aS],null))),$APP.P,"Returns a set of patch names registered in the supplied manifold."],null)),qCb,$APP.z($Ob,new $APP.f(null,3,[$APP.Pm,oW,$APP.P,"Returns true if the supplied `point` can be converted into coordinates by\n    this [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.hU],null)))],null)),$APP.z(oWb,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,
$APP.M(new $APP.H(null,2,5,$APP.I,[mT,qE],null))),$APP.P,"Returns an identical `coordsys` with the new `coordinate-prototype` installed."],null)),Brb,$APP.z(Q2b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[Gfb],null))),$APP.P,"Returns a set of names of all coordinate system constructors registered in the\n  supplied patch."],null)),rnb,y3b,Jwb,$APP.z(D1b,new $APP.f(null,2,[$APP.U,$APP.M($APP.K,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))),$APP.P,"Takes some constant `c` and returns a manifold function that maps every input\n  manifold `point` to `c.`"],
null))],[new $APP.f(null,3,[$APP.Q,Mwb,$APP.X,arc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,uWb,$APP.X,CO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a coordinate representation of the supplied manifold point `point`,\n    as specified by this [[ICoordinateSystem]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.hU],null))],null)],null),new $APP.f(null,3,[$APP.Q,eDb,$APP.X,Vqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Uob,$APP.X,s3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,B0b,
$APP.X,Hqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Mob,$APP.X,m3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,RWb,$APP.X,G3a,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57440.",$APP.U,$APP.M(new $APP.H(null,10,5,$APP.I,[yhb,IV,XU,$APP.wU,aS,$APP.wx,uY,QT,pU,Uxb],null))],null)],null),new $APP.f(null,3,[$APP.Q,a$b,$APP.X,GO,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from coordinates in\n  `coordinate-system`'s repesentation to the matching point on the manifold\n  associated with `coordinate-system`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,sob,$APP.X,Iqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Y4b,$APP.X,e3,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a manifold family (a template for building manifolds) from the\n  supplied `name-format`.\n\n  Generated manifolds locally resemble Euclidean space (Rn) by default. You can\n  optionally pass `'Complex` or `'Quaternion` to `over` to customize the field\n  of the vector space that the manifold locally resembles at each point.\n\n  NOTE: only `'Real` does anything as of 3.15.2021.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[dV],null),$APP.z(new $APP.H(null,2,5,$APP.I,[dV,fW],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M($APP.kpa,new $APP.ug(null,new $APP.f(null,3,[$APP.M($APP.K,PN),"null",$APP.M($APP.K,i$b),"null",$APP.M($APP.K,mX),"null"],null),null),fW)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,x_b,$APP.X,$qc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,sAb,$APP.X,Hqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,wlb,$APP.X,EO,$APP.h,
new $APP.f(null,2,[$APP.P,"Returns the symbolic coordinate prototype associated with `coordsys`. This is\n   a structure of the correct dimension for this coordinate system, with all\n   symbolic entries.\n\n  Returns nil for non-valid inputs.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[mT],null))],null)],null),new $APP.f(null,3,[$APP.Q,O6b,$APP.X,Qqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,LZb,$APP.X,Cqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57410.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[aS,pU,$APP.wx,Byb],null))],null)],null),new $APP.f(null,3,[$APP.Q,pSb,$APP.X,r3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,q$b,$APP.X,w3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a function that takes a single manifold `point` embedded in the\n  manifold `embedded` and transfers the point to the supplied `embedding`\n  manifold.\n\n  The embedding dimension must be the same for both manifolds.\n\n  NOTE that `embedded` and `embedding` can be either manifolds, or instances\n  of [[ICoordinateSystem]]. In the latter case `embedded` and `embedding` will\n  bind to the manifold associated with the supplied [[ICoordinateSystem]].",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[tKb,K9b],null))],null)],null),new $APP.f(null,3,[$APP.Q,K5b,$APP.X,yO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the backing Euclidean space representation of the supplied manifold\n  point.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.hU],null))],null)],null),new $APP.f(null,3,[$APP.Q,oXb,$APP.X,I3a,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57448.",$APP.U,$APP.M(new $APP.H(null,9,5,
$APP.I,[XU,IV,aS,pU,$APP.wU,QT,uY,$APP.wx,Qxb],null))],null)],null),new $APP.f(null,3,[$APP.Q,ipb,$APP.X,p3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,vWb,$APP.X,AO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the representation of `manifold-point` in `coordinate-system`.\n\n  If an entry for the given `coordinate-system` is not found, `thunk` is called\n  to produce the representation. The representation is cached in the point.",$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[iIb,qW,gY],null))],null)],
null),new $APP.f(null,3,[$APP.Q,hrb,$APP.X,erc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,hmb,$APP.X,Wqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Y_b,$APP.X,$2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mhb,$APP.X,wO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a unique identifier for this instance of [[ICoordinateSystem]].\n\n    (This is an internal implementation detail to allow us to attach coordinate\n    prototypes and other items as metadata to an [[ICoordinateSystem]] without\n    affecting equality.)",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Su],null))],null)],null),new $APP.f(null,3,[$APP.Q,gQb,$APP.X,C3a,$APP.h,new $APP.f(null,2,[$APP.P,"Generates a coordinate structure of the supplied dimension `n`, and\n  `orientation` using the supplied function `f` for entries. See the very\n  similar [[emmy.structure/generate]] for more details.\n\n  NOTE from GJS: this is a kludge introduced only to allow a coordinate of\n  dimension 1 to automatically unwrap itself.",$APP.U,$APP.M(new $APP.H(null,
3,5,$APP.I,[$APP.wU,oU,$APP.Nv],null))],null)],null),new $APP.f(null,3,[$APP.Q,bAb,$APP.X,f3,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a concrete manifold generated by specializing the supplied manifold\n  `family` into a concrete manifold of dimension `n`. `n` must be a positive\n  integer.\n\n  Optionally takes an `embedding-dimension`; this must be \x3e\x3d the value of `n`.\n  Use this in cases like an n-sphere embedded in a euclidean space of dimension\n  n+1.\n\n  A [manifold](https://en.wikipedia.org/wiki/Manifold) is a topological space\n  that locally resembles Euclidean space near each point.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wV,$APP.wU],null),$APP.z(new $APP.H(null,3,5,$APP.I,[wV,$APP.wU,vX],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,3,5,$APP.I,[$APP.M($APP.qsa,$APP.wU),$APP.M($APP.aw,$APP.wU,0),$APP.M($APP.cw,vX,$APP.wU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,HGb,$APP.X,Zqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,iLb,$APP.X,Aqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57394.",
$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[aS,pU,$APP.wx,lTb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Vbb,$APP.X,tO,$APP.h,new $APP.f(null,2,[$APP.P,"Takes a manifold `family` and attaches a patch template with the supplied\n  `patch-name`. Returns a new manifold family.\n\n  All manifolds generated from the returned family will have this coordinate\n  patch attached.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[wV,iW],null))],null)],null),new $APP.f(null,3,[$APP.Q,d8b,$APP.X,p3a,$APP.h,new $APP.f(null,
2,[$APP.P,"Returns true if `p` is a manifold point, false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Sv],null))],null)],null),new $APP.f(null,3,[$APP.Q,ZMb,$APP.X,uO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a new manifold family generated by attaching the supplied coordinate\n  system constructor to `family`, indexed by the supplied patch and coordinate\n  system names.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[wV,VX,iW,ubc],null))],null)],null),new $APP.f(null,3,[$APP.Q,wnb,$APP.X,
Pqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,y_b,$APP.X,crc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,sqb,$APP.X,BO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the manifold point on this [[ICoordinateSystem]]'s manifold\n    corresponding to the supplied `coords`.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null))],null)],null),new $APP.f(null,3,[$APP.Q,eyb,$APP.X,vO,$APP.h,new $APP.f(null,2,[$APP.P,"Returns an [[ICoordinateSystem]] instance specialized to the patch named\n  `patch-name` on `manifold`.",
$APP.U,$APP.M(new $APP.H(null,3,5,$APP.I,[aS,VX,iW],null))],null)],null),new $APP.f(null,3,[$APP.Q,BZb,$APP.X,Dqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57421.",$APP.U,$APP.M(new $APP.H(null,4,5,$APP.I,[aS,pU,$APP.wx,pyb],null))],null)],null),new $APP.f(null,3,[$APP.Q,gLb,$APP.X,Bqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57399.",$APP.U,$APP.M(new $APP.H(null,
4,5,$APP.I,[aS,pU,$APP.wx,Kyb],null))],null)],null),new $APP.f(null,3,[$APP.Q,Chb,$APP.X,Jqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,mJb,$APP.X,Rqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Wwb,$APP.X,Tqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,AWb,$APP.X,Fqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57471.",$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[aS,pU,$APP.wU,$APP.wx,uxb],null))],null)],null),new $APP.f(null,
3,[$APP.Q,R2b,$APP.X,rO,$APP.h,new $APP.f(null,2,[$APP.P,"If `m` is a manifold, acts as identity. Else, if given some structure\n  associated with a manifold (like a coordinate system), returns the associated\n  manifold.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,m1b,$APP.X,z3a,$APP.h,new $APP.f(null,2,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 0.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.hU],
null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(FY,$APP.hU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,GUb,$APP.X,o3a,$APP.h,new $APP.f(null,2,[$APP.P,"Return the manifold upon which this `point` was defined.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.hU],null))],null)],null),new $APP.f(null,3,[$APP.Q,p5b,$APP.X,jrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,rMb,$APP.X,Lqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,peb,$APP.X,A3a,$APP.h,new $APP.f(null,
2,[$APP.P,"Manifold function that maps every input manifold `point` to the scalar value 1.",$APP.U,$APP.M($APP.z(new $APP.H(null,1,5,$APP.I,[$APP.hU],null),new $APP.f(null,1,[$APP.Bw,new $APP.H(null,1,5,$APP.I,[$APP.M(FY,$APP.hU)],null)],null)))],null)],null),new $APP.f(null,3,[$APP.Q,$Wb,$APP.X,E3a,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57430.",$APP.U,$APP.M(new $APP.H(null,7,5,$APP.I,[oU,kLb,IV,aS,pU,$APP.wx,jyb],null))],
null)],null),new $APP.f(null,3,[$APP.Q,qjb,$APP.X,v3a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[ICoordinateSystem]], returns a unique, symbolically-represented\n  point on the manifold associated with `coordinate-system`.\n\n  See [[typical-coords]] for a coordinate-based version of this function.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,P_b,$APP.X,Xqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Web,$APP.X,x3a,$APP.h,new $APP.f(null,2,[$APP.P,
"Takes a coordinate representation `coords` of a manifold point with all\n  symbolic entries, and returns a structure of the same shape with `v:`\n  prepended to all symbols.\n\n  This structure is appropriate for representing the velocities associated with\n  each coordinate.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.pW],null))],null)],null),new $APP.f(null,3,[$APP.Q,sQb,$APP.X,r3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied coordinates `coords` can be converted into a\n    point by this [[ICoordinateSystem]], false otherwise.",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.pW],null))],null)],null),new $APP.f(null,3,[$APP.Q,hxb,$APP.X,Z2a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns `true` if `m` is a dictionary representing a manifold family, false\n  otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Qr],null))],null)],null),new $APP.f(null,3,[$APP.Q,lhb,$APP.X,irc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,TMb,$APP.X,u3a,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[ICoordinateSystem]], returns a structure that matches\n  the [[coordinate-prototype]] of `coordinate-system`, with all unique,\n  gensym-ed entries.\n\n  Use [[typical-coords]] if you require a unique symbolic coordinate\n  representation compatible with `coordinate-system`.\n\n  See [[typical-point]] for a coordinate-free version of this function.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,vob,$APP.X,mrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,ddc,$APP.X,c3a,$APP.h,new $APP.f(null,2,[$APP.P,"The supplied manifold `m` locally resembles some vector space; this function\n  returns the field over which that vector space was specified.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[aS],null))],null)],null),new $APP.f(null,3,[$APP.Q,iZb,$APP.X,lrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,
jIb,$APP.X,hrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,$Nb,$APP.X,krc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,uob,$APP.X,Oqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,NKb,$APP.X,Xqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Vob,$APP.X,q3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,zfb,$APP.X,Sqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,tob,$APP.X,n3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,tib,$APP.X,JO,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,ikb,$APP.X,
Nqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,TTb,$APP.X,t3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if `x` implements [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Yv],null))],null)],null),new $APP.f(null,3,[$APP.Q,Mcc,$APP.X,Uqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Vcc,$APP.X,drc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,iXb,$APP.X,Eqc,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57463.",
$APP.U,$APP.M(new $APP.H(null,5,5,$APP.I,[aS,pU,$APP.wU,$APP.wx,Dxb],null))],null)],null),new $APP.f(null,3,[$APP.Q,uFb,$APP.X,Mqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,dXb,$APP.X,K3a,$APP.h,new $APP.f(null,2,[$APP.P,"Positional factory function for emmy.calculus.manifold/t_emmy$calculus$manifold57458.",$APP.U,$APP.M(new $APP.H(null,9,5,$APP.I,[XU,IV,aS,pU,$APP.wU,QT,uY,$APP.wx,Kxb],null))],null)],null),new $APP.f(null,3,[$APP.Q,X9b,$APP.X,FO,$APP.h,new $APP.f(null,2,[$APP.P,"Given an [[ICoordinateSystem]], returns a function from a point on the\n  coordinate system's manifold to the coordinate representation specified by the\n  supplied `coordinate-system`.",
$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,oW,$APP.X,q3a,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,mKb,$APP.X,JO,$APP.h,new $APP.f(null,2,[$APP.P,"Given a symbolic name `sym` and an [[ICoordinateSystem]], returns a literal\n  function that maps coordinate-free manifold points to a scalar output.\n\n  Also aliased as [[literal-manifold-function]].",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Yx,qW],null))],null)],null),new $APP.f(null,3,[$APP.Q,
ehb,$APP.X,erc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,xob,$APP.X,Gqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,iCb,$APP.X,h3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns the patch named by `patch-name` within the supplied `manifold` if\n  registered. Throws otherwise.\n\n  NOTE that the returned patch will keep a reference to the supplied `manifold`\n  under a `:manifold` key.\n\n  A coordinate patch is a simply-connected open set around a point in the\n  manifold. A manifold might have many patches. Coordinate systems are defined\n  on patches; these allow the parameterization of any point on the patch in\n  terms of a tuple of real numbers (the coordinates).",
$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[aS,iW],null))],null)],null),new $APP.f(null,3,[$APP.Q,ZGb,$APP.X,grc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,omb,$APP.X,brc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Fob,$APP.X,e3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a set of patch names registered in the supplied manifold.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[aS],null))],null)],null),new $APP.f(null,3,[$APP.Q,iwb,$APP.X,nrc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Tpb,$APP.X,
s3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns true if the supplied `point` can be converted into coordinates by\n    this [[ICoordinateSystem]], false otherwise.",$APP.U,$APP.M(new $APP.H(null,2,5,$APP.I,[$APP.Su,$APP.hU],null))],null)],null),new $APP.f(null,3,[$APP.Q,jWb,$APP.X,function(a,b){var c=EO(a);return $APP.Uc.A(c,b)?a:$APP.Yj.K(a,$APP.rg,DO,b)},$APP.h,new $APP.f(null,2,[$APP.P,"Returns an identical `coordsys` with the new `coordinate-prototype` installed.",$APP.U,$APP.M(new $APP.H(null,
2,5,$APP.I,[mT,qE],null))],null)],null),new $APP.f(null,3,[$APP.Q,Sub,$APP.X,frc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,cRb,$APP.X,i3a,$APP.h,new $APP.f(null,2,[$APP.P,"Returns a set of names of all coordinate system constructors registered in the\n  supplied patch.",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[Gfb],null))],null)],null),new $APP.f(null,3,[$APP.Q,zpb,$APP.X,Yqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Lab,$APP.X,Kqc,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,Wob,$APP.X,
o3,$APP.h,$APP.F],null),new $APP.f(null,3,[$APP.Q,ypb,$APP.X,B3a,$APP.h,new $APP.f(null,2,[$APP.P,"Takes some constant `c` and returns a manifold function that maps every input\n  manifold `point` to `c.`",$APP.U,$APP.M(new $APP.H(null,1,5,$APP.I,[$APP.Mv],null))],null)],null)]),$APP.ap(gib))]),Esc=new $APP.f(null,2,[$APP.bm,Dsc,$APP.Wo,new $APP.f(null,2,[$APP.bx,$APP.ha,$APP.Xm,$APP.jn],null)],null);$APP.$ja(Esc);$APP.jp(Esc);
}).call(this);